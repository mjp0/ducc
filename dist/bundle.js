async function _k({
  tx: e,
  onData: t,
  onDone: r,
  onError: i,
  request_id: n,
  method_id: s,
  module_id: a
}) {
  const c = {
    request_id: n,
    tx: e,
    abort: async () => {
    },
    setAbort: async (l) => {
      c.abort = l;
    },
    ...{
      onData: async (l) => {
        t && t(l);
      },
      onDone: async (l) => {
        r && r(l);
      },
      onError: async (l) => {
        i && i(l);
      }
    }
  };
  return c;
}
var kt;
(function(e) {
  e.assertEqual = (n) => n;
  function t(n) {
  }
  e.assertIs = t;
  function r(n) {
    throw new Error();
  }
  e.assertNever = r, e.arrayToEnum = (n) => {
    const s = {};
    for (const a of n)
      s[a] = a;
    return s;
  }, e.getValidEnumValues = (n) => {
    const s = e.objectKeys(n).filter((u) => typeof n[n[u]] != "number"), a = {};
    for (const u of s)
      a[u] = n[u];
    return e.objectValues(a);
  }, e.objectValues = (n) => e.objectKeys(n).map(function(s) {
    return n[s];
  }), e.objectKeys = typeof Object.keys == "function" ? (n) => Object.keys(n) : (n) => {
    const s = [];
    for (const a in n)
      Object.prototype.hasOwnProperty.call(n, a) && s.push(a);
    return s;
  }, e.find = (n, s) => {
    for (const a of n)
      if (s(a))
        return a;
  }, e.isInteger = typeof Number.isInteger == "function" ? (n) => Number.isInteger(n) : (n) => typeof n == "number" && isFinite(n) && Math.floor(n) === n;
  function i(n, s = " | ") {
    return n.map((a) => typeof a == "string" ? `'${a}'` : a).join(s);
  }
  e.joinValues = i, e.jsonStringifyReplacer = (n, s) => typeof s == "bigint" ? s.toString() : s;
})(kt || (kt = {}));
var Jm;
(function(e) {
  e.mergeShapes = (t, r) => ({
    ...t,
    ...r
    // second overwrites first
  });
})(Jm || (Jm = {}));
const Ve = kt.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), ns = (e) => {
  switch (typeof e) {
    case "undefined":
      return Ve.undefined;
    case "string":
      return Ve.string;
    case "number":
      return isNaN(e) ? Ve.nan : Ve.number;
    case "boolean":
      return Ve.boolean;
    case "function":
      return Ve.function;
    case "bigint":
      return Ve.bigint;
    case "symbol":
      return Ve.symbol;
    case "object":
      return Array.isArray(e) ? Ve.array : e === null ? Ve.null : e.then && typeof e.then == "function" && e.catch && typeof e.catch == "function" ? Ve.promise : typeof Map < "u" && e instanceof Map ? Ve.map : typeof Set < "u" && e instanceof Set ? Ve.set : typeof Date < "u" && e instanceof Date ? Ve.date : Ve.object;
    default:
      return Ve.unknown;
  }
}, De = kt.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]), wk = (e) => JSON.stringify(e, null, 2).replace(/"([^"]+)":/g, "$1:");
let Tn = class extends Error {
  constructor(t) {
    super(), this.issues = [], this.addIssue = (i) => {
      this.issues = [...this.issues, i];
    }, this.addIssues = (i = []) => {
      this.issues = [...this.issues, ...i];
    };
    const r = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, r) : this.__proto__ = r, this.name = "ZodError", this.issues = t;
  }
  get errors() {
    return this.issues;
  }
  format(t) {
    const r = t || function(s) {
      return s.message;
    }, i = { _errors: [] }, n = (s) => {
      for (const a of s.issues)
        if (a.code === "invalid_union")
          a.unionErrors.map(n);
        else if (a.code === "invalid_return_type")
          n(a.returnTypeError);
        else if (a.code === "invalid_arguments")
          n(a.argumentsError);
        else if (a.path.length === 0)
          i._errors.push(r(a));
        else {
          let u = i, c = 0;
          for (; c < a.path.length; ) {
            const l = a.path[c];
            c === a.path.length - 1 ? (u[l] = u[l] || { _errors: [] }, u[l]._errors.push(r(a))) : u[l] = u[l] || { _errors: [] }, u = u[l], c++;
          }
        }
    };
    return n(this), i;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, kt.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(t = (r) => r.message) {
    const r = {}, i = [];
    for (const n of this.issues)
      n.path.length > 0 ? (r[n.path[0]] = r[n.path[0]] || [], r[n.path[0]].push(t(n))) : i.push(t(n));
    return { formErrors: i, fieldErrors: r };
  }
  get formErrors() {
    return this.flatten();
  }
};
Tn.create = (e) => new Tn(e);
const _u = (e, t) => {
  let r;
  switch (e.code) {
    case De.invalid_type:
      e.received === Ve.undefined ? r = "Required" : r = `Expected ${e.expected}, received ${e.received}`;
      break;
    case De.invalid_literal:
      r = `Invalid literal value, expected ${JSON.stringify(e.expected, kt.jsonStringifyReplacer)}`;
      break;
    case De.unrecognized_keys:
      r = `Unrecognized key(s) in object: ${kt.joinValues(e.keys, ", ")}`;
      break;
    case De.invalid_union:
      r = "Invalid input";
      break;
    case De.invalid_union_discriminator:
      r = `Invalid discriminator value. Expected ${kt.joinValues(e.options)}`;
      break;
    case De.invalid_enum_value:
      r = `Invalid enum value. Expected ${kt.joinValues(e.options)}, received '${e.received}'`;
      break;
    case De.invalid_arguments:
      r = "Invalid function arguments";
      break;
    case De.invalid_return_type:
      r = "Invalid function return type";
      break;
    case De.invalid_date:
      r = "Invalid date";
      break;
    case De.invalid_string:
      typeof e.validation == "object" ? "includes" in e.validation ? (r = `Invalid input: must include "${e.validation.includes}"`, typeof e.validation.position == "number" && (r = `${r} at one or more positions greater than or equal to ${e.validation.position}`)) : "startsWith" in e.validation ? r = `Invalid input: must start with "${e.validation.startsWith}"` : "endsWith" in e.validation ? r = `Invalid input: must end with "${e.validation.endsWith}"` : kt.assertNever(e.validation) : e.validation !== "regex" ? r = `Invalid ${e.validation}` : r = "Invalid";
      break;
    case De.too_small:
      e.type === "array" ? r = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "more than"} ${e.minimum} element(s)` : e.type === "string" ? r = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "over"} ${e.minimum} character(s)` : e.type === "number" ? r = `Number must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${e.minimum}` : e.type === "date" ? r = `Date must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(e.minimum))}` : r = "Invalid input";
      break;
    case De.too_big:
      e.type === "array" ? r = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "less than"} ${e.maximum} element(s)` : e.type === "string" ? r = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "under"} ${e.maximum} character(s)` : e.type === "number" ? r = `Number must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "bigint" ? r = `BigInt must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "date" ? r = `Date must be ${e.exact ? "exactly" : e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(e.maximum))}` : r = "Invalid input";
      break;
    case De.custom:
      r = "Invalid input";
      break;
    case De.invalid_intersection_types:
      r = "Intersection results could not be merged";
      break;
    case De.not_multiple_of:
      r = `Number must be a multiple of ${e.multipleOf}`;
      break;
    case De.not_finite:
      r = "Number must be finite";
      break;
    default:
      r = t.defaultError, kt.assertNever(e);
  }
  return { message: r };
};
let F2 = _u;
function $k(e) {
  F2 = e;
}
function Wl() {
  return F2;
}
const Hl = (e) => {
  const { data: t, path: r, errorMaps: i, issueData: n } = e, s = [...r, ...n.path || []], a = {
    ...n,
    path: s
  };
  let u = "";
  const c = i.filter((l) => !!l).slice().reverse();
  for (const l of c)
    u = l(a, { data: t, defaultError: u }).message;
  return {
    ...n,
    path: s,
    message: n.message || u
  };
}, Ek = [];
function We(e, t) {
  const r = Hl({
    issueData: t,
    data: e.data,
    path: e.path,
    errorMaps: [
      e.common.contextualErrorMap,
      e.schemaErrorMap,
      Wl(),
      _u
      // then global default map
    ].filter((i) => !!i)
  });
  e.common.issues.push(r);
}
class Ar {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(t, r) {
    const i = [];
    for (const n of r) {
      if (n.status === "aborted")
        return dt;
      n.status === "dirty" && t.dirty(), i.push(n.value);
    }
    return { status: t.value, value: i };
  }
  static async mergeObjectAsync(t, r) {
    const i = [];
    for (const n of r)
      i.push({
        key: await n.key,
        value: await n.value
      });
    return Ar.mergeObjectSync(t, i);
  }
  static mergeObjectSync(t, r) {
    const i = {};
    for (const n of r) {
      const { key: s, value: a } = n;
      if (s.status === "aborted" || a.status === "aborted")
        return dt;
      s.status === "dirty" && t.dirty(), a.status === "dirty" && t.dirty(), s.value !== "__proto__" && (typeof a.value < "u" || n.alwaysSet) && (i[s.value] = a.value);
    }
    return { status: t.value, value: i };
  }
}
const dt = Object.freeze({
  status: "aborted"
}), U2 = (e) => ({ status: "dirty", value: e }), Dr = (e) => ({ status: "valid", value: e }), Xm = (e) => e.status === "aborted", Qm = (e) => e.status === "dirty", wu = (e) => e.status === "valid", Gl = (e) => typeof Promise < "u" && e instanceof Promise;
var tt;
(function(e) {
  e.errToObj = (t) => typeof t == "string" ? { message: t } : t || {}, e.toString = (t) => typeof t == "string" ? t : t == null ? void 0 : t.message;
})(tt || (tt = {}));
class ri {
  constructor(t, r, i, n) {
    this._cachedPath = [], this.parent = t, this.data = r, this._path = i, this._key = n;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
}
const t1 = (e, t) => {
  if (wu(t))
    return { success: !0, data: t.value };
  if (!e.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      const r = new Tn(e.common.issues);
      return this._error = r, this._error;
    }
  };
};
function yt(e) {
  if (!e)
    return {};
  const { errorMap: t, invalid_type_error: r, required_error: i, description: n } = e;
  if (t && (r || i))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return t ? { errorMap: t, description: n } : { errorMap: (a, u) => a.code !== "invalid_type" ? { message: u.defaultError } : typeof u.data > "u" ? { message: i ?? u.defaultError } : { message: r ?? u.defaultError }, description: n };
}
class _t {
  constructor(t) {
    this.spa = this.safeParseAsync, this._def = t, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(t) {
    return ns(t.data);
  }
  _getOrReturnCtx(t, r) {
    return r || {
      common: t.parent.common,
      data: t.data,
      parsedType: ns(t.data),
      schemaErrorMap: this._def.errorMap,
      path: t.path,
      parent: t.parent
    };
  }
  _processInputParams(t) {
    return {
      status: new Ar(),
      ctx: {
        common: t.parent.common,
        data: t.data,
        parsedType: ns(t.data),
        schemaErrorMap: this._def.errorMap,
        path: t.path,
        parent: t.parent
      }
    };
  }
  _parseSync(t) {
    const r = this._parse(t);
    if (Gl(r))
      throw new Error("Synchronous parse encountered promise.");
    return r;
  }
  _parseAsync(t) {
    const r = this._parse(t);
    return Promise.resolve(r);
  }
  parse(t, r) {
    const i = this.safeParse(t, r);
    if (i.success)
      return i.data;
    throw i.error;
  }
  safeParse(t, r) {
    var i;
    const n = {
      common: {
        issues: [],
        async: (i = r == null ? void 0 : r.async) !== null && i !== void 0 ? i : !1,
        contextualErrorMap: r == null ? void 0 : r.errorMap
      },
      path: (r == null ? void 0 : r.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: ns(t)
    }, s = this._parseSync({ data: t, path: n.path, parent: n });
    return t1(n, s);
  }
  async parseAsync(t, r) {
    const i = await this.safeParseAsync(t, r);
    if (i.success)
      return i.data;
    throw i.error;
  }
  async safeParseAsync(t, r) {
    const i = {
      common: {
        issues: [],
        contextualErrorMap: r == null ? void 0 : r.errorMap,
        async: !0
      },
      path: (r == null ? void 0 : r.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: ns(t)
    }, n = this._parse({ data: t, path: i.path, parent: i }), s = await (Gl(n) ? n : Promise.resolve(n));
    return t1(i, s);
  }
  refine(t, r) {
    const i = (n) => typeof r == "string" || typeof r > "u" ? { message: r } : typeof r == "function" ? r(n) : r;
    return this._refinement((n, s) => {
      const a = t(n), u = () => s.addIssue({
        code: De.custom,
        ...i(n)
      });
      return typeof Promise < "u" && a instanceof Promise ? a.then((c) => c ? !0 : (u(), !1)) : a ? !0 : (u(), !1);
    });
  }
  refinement(t, r) {
    return this._refinement((i, n) => t(i) ? !0 : (n.addIssue(typeof r == "function" ? r(i, n) : r), !1));
  }
  _refinement(t) {
    return new kn({
      schema: this,
      typeName: ot.ZodEffects,
      effect: { type: "refinement", refinement: t }
    });
  }
  superRefine(t) {
    return this._refinement(t);
  }
  optional() {
    return Ei.create(this, this._def);
  }
  nullable() {
    return Xs.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return In.create(this, this._def);
  }
  promise() {
    return ro.create(this, this._def);
  }
  or(t) {
    return Ou.create([this, t], this._def);
  }
  and(t) {
    return Pu.create(this, t, this._def);
  }
  transform(t) {
    return new kn({
      ...yt(this._def),
      schema: this,
      typeName: ot.ZodEffects,
      effect: { type: "transform", transform: t }
    });
  }
  default(t) {
    const r = typeof t == "function" ? t : () => t;
    return new Tu({
      ...yt(this._def),
      innerType: this,
      defaultValue: r,
      typeName: ot.ZodDefault
    });
  }
  brand() {
    return new V2({
      typeName: ot.ZodBranded,
      type: this,
      ...yt(this._def)
    });
  }
  catch(t) {
    const r = typeof t == "function" ? t : () => t;
    return new Xl({
      ...yt(this._def),
      innerType: this,
      catchValue: r,
      typeName: ot.ZodCatch
    });
  }
  describe(t) {
    const r = this.constructor;
    return new r({
      ...this._def,
      description: t
    });
  }
  pipe(t) {
    return Wu.create(this, t);
  }
  readonly() {
    return ef.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const xk = /^c[^\s-]{8,}$/i, Ok = /^[a-z][a-z0-9]*$/, Pk = /[0-9A-HJKMNP-TV-Z]{26}/, Sk = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, Ak = /^([A-Z0-9_+-]+\.?)*[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, Ck = /^(\p{Extended_Pictographic}|\p{Emoji_Component})+$/u, Rk = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/, Tk = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/, Ik = (e) => e.precision ? e.offset ? new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`) : new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}Z$`) : e.precision === 0 ? e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$") : e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");
function jk(e, t) {
  return !!((t === "v4" || !t) && Rk.test(e) || (t === "v6" || !t) && Tk.test(e));
}
class Rn extends _t {
  constructor() {
    super(...arguments), this._regex = (t, r, i) => this.refinement((n) => t.test(n), {
      validation: r,
      code: De.invalid_string,
      ...tt.errToObj(i)
    }), this.nonempty = (t) => this.min(1, tt.errToObj(t)), this.trim = () => new Rn({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    }), this.toLowerCase = () => new Rn({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    }), this.toUpperCase = () => new Rn({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  _parse(t) {
    if (this._def.coerce && (t.data = String(t.data)), this._getType(t) !== Ve.string) {
      const s = this._getOrReturnCtx(t);
      return We(
        s,
        {
          code: De.invalid_type,
          expected: Ve.string,
          received: s.parsedType
        }
        //
      ), dt;
    }
    const i = new Ar();
    let n;
    for (const s of this._def.checks)
      if (s.kind === "min")
        t.data.length < s.value && (n = this._getOrReturnCtx(t, n), We(n, {
          code: De.too_small,
          minimum: s.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: s.message
        }), i.dirty());
      else if (s.kind === "max")
        t.data.length > s.value && (n = this._getOrReturnCtx(t, n), We(n, {
          code: De.too_big,
          maximum: s.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: s.message
        }), i.dirty());
      else if (s.kind === "length") {
        const a = t.data.length > s.value, u = t.data.length < s.value;
        (a || u) && (n = this._getOrReturnCtx(t, n), a ? We(n, {
          code: De.too_big,
          maximum: s.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: s.message
        }) : u && We(n, {
          code: De.too_small,
          minimum: s.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: s.message
        }), i.dirty());
      } else if (s.kind === "email")
        Ak.test(t.data) || (n = this._getOrReturnCtx(t, n), We(n, {
          validation: "email",
          code: De.invalid_string,
          message: s.message
        }), i.dirty());
      else if (s.kind === "emoji")
        Ck.test(t.data) || (n = this._getOrReturnCtx(t, n), We(n, {
          validation: "emoji",
          code: De.invalid_string,
          message: s.message
        }), i.dirty());
      else if (s.kind === "uuid")
        Sk.test(t.data) || (n = this._getOrReturnCtx(t, n), We(n, {
          validation: "uuid",
          code: De.invalid_string,
          message: s.message
        }), i.dirty());
      else if (s.kind === "cuid")
        xk.test(t.data) || (n = this._getOrReturnCtx(t, n), We(n, {
          validation: "cuid",
          code: De.invalid_string,
          message: s.message
        }), i.dirty());
      else if (s.kind === "cuid2")
        Ok.test(t.data) || (n = this._getOrReturnCtx(t, n), We(n, {
          validation: "cuid2",
          code: De.invalid_string,
          message: s.message
        }), i.dirty());
      else if (s.kind === "ulid")
        Pk.test(t.data) || (n = this._getOrReturnCtx(t, n), We(n, {
          validation: "ulid",
          code: De.invalid_string,
          message: s.message
        }), i.dirty());
      else if (s.kind === "url")
        try {
          new URL(t.data);
        } catch {
          n = this._getOrReturnCtx(t, n), We(n, {
            validation: "url",
            code: De.invalid_string,
            message: s.message
          }), i.dirty();
        }
      else
        s.kind === "regex" ? (s.regex.lastIndex = 0, s.regex.test(t.data) || (n = this._getOrReturnCtx(t, n), We(n, {
          validation: "regex",
          code: De.invalid_string,
          message: s.message
        }), i.dirty())) : s.kind === "trim" ? t.data = t.data.trim() : s.kind === "includes" ? t.data.includes(s.value, s.position) || (n = this._getOrReturnCtx(t, n), We(n, {
          code: De.invalid_string,
          validation: { includes: s.value, position: s.position },
          message: s.message
        }), i.dirty()) : s.kind === "toLowerCase" ? t.data = t.data.toLowerCase() : s.kind === "toUpperCase" ? t.data = t.data.toUpperCase() : s.kind === "startsWith" ? t.data.startsWith(s.value) || (n = this._getOrReturnCtx(t, n), We(n, {
          code: De.invalid_string,
          validation: { startsWith: s.value },
          message: s.message
        }), i.dirty()) : s.kind === "endsWith" ? t.data.endsWith(s.value) || (n = this._getOrReturnCtx(t, n), We(n, {
          code: De.invalid_string,
          validation: { endsWith: s.value },
          message: s.message
        }), i.dirty()) : s.kind === "datetime" ? Ik(s).test(t.data) || (n = this._getOrReturnCtx(t, n), We(n, {
          code: De.invalid_string,
          validation: "datetime",
          message: s.message
        }), i.dirty()) : s.kind === "ip" ? jk(t.data, s.version) || (n = this._getOrReturnCtx(t, n), We(n, {
          validation: "ip",
          code: De.invalid_string,
          message: s.message
        }), i.dirty()) : kt.assertNever(s);
    return { status: i.value, value: t.data };
  }
  _addCheck(t) {
    return new Rn({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  email(t) {
    return this._addCheck({ kind: "email", ...tt.errToObj(t) });
  }
  url(t) {
    return this._addCheck({ kind: "url", ...tt.errToObj(t) });
  }
  emoji(t) {
    return this._addCheck({ kind: "emoji", ...tt.errToObj(t) });
  }
  uuid(t) {
    return this._addCheck({ kind: "uuid", ...tt.errToObj(t) });
  }
  cuid(t) {
    return this._addCheck({ kind: "cuid", ...tt.errToObj(t) });
  }
  cuid2(t) {
    return this._addCheck({ kind: "cuid2", ...tt.errToObj(t) });
  }
  ulid(t) {
    return this._addCheck({ kind: "ulid", ...tt.errToObj(t) });
  }
  ip(t) {
    return this._addCheck({ kind: "ip", ...tt.errToObj(t) });
  }
  datetime(t) {
    var r;
    return typeof t == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      message: t
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof (t == null ? void 0 : t.precision) > "u" ? null : t == null ? void 0 : t.precision,
      offset: (r = t == null ? void 0 : t.offset) !== null && r !== void 0 ? r : !1,
      ...tt.errToObj(t == null ? void 0 : t.message)
    });
  }
  regex(t, r) {
    return this._addCheck({
      kind: "regex",
      regex: t,
      ...tt.errToObj(r)
    });
  }
  includes(t, r) {
    return this._addCheck({
      kind: "includes",
      value: t,
      position: r == null ? void 0 : r.position,
      ...tt.errToObj(r == null ? void 0 : r.message)
    });
  }
  startsWith(t, r) {
    return this._addCheck({
      kind: "startsWith",
      value: t,
      ...tt.errToObj(r)
    });
  }
  endsWith(t, r) {
    return this._addCheck({
      kind: "endsWith",
      value: t,
      ...tt.errToObj(r)
    });
  }
  min(t, r) {
    return this._addCheck({
      kind: "min",
      value: t,
      ...tt.errToObj(r)
    });
  }
  max(t, r) {
    return this._addCheck({
      kind: "max",
      value: t,
      ...tt.errToObj(r)
    });
  }
  length(t, r) {
    return this._addCheck({
      kind: "length",
      value: t,
      ...tt.errToObj(r)
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((t) => t.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((t) => t.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((t) => t.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((t) => t.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((t) => t.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((t) => t.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((t) => t.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((t) => t.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((t) => t.kind === "ip");
  }
  get minLength() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "min" && (t === null || r.value > t) && (t = r.value);
    return t;
  }
  get maxLength() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    return t;
  }
}
Rn.create = (e) => {
  var t;
  return new Rn({
    checks: [],
    typeName: ot.ZodString,
    coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
    ...yt(e)
  });
};
function kk(e, t) {
  const r = (e.toString().split(".")[1] || "").length, i = (t.toString().split(".")[1] || "").length, n = r > i ? r : i, s = parseInt(e.toFixed(n).replace(".", "")), a = parseInt(t.toFixed(n).replace(".", ""));
  return s % a / Math.pow(10, n);
}
class ls extends _t {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = Number(t.data)), this._getType(t) !== Ve.number) {
      const s = this._getOrReturnCtx(t);
      return We(s, {
        code: De.invalid_type,
        expected: Ve.number,
        received: s.parsedType
      }), dt;
    }
    let i;
    const n = new Ar();
    for (const s of this._def.checks)
      s.kind === "int" ? kt.isInteger(t.data) || (i = this._getOrReturnCtx(t, i), We(i, {
        code: De.invalid_type,
        expected: "integer",
        received: "float",
        message: s.message
      }), n.dirty()) : s.kind === "min" ? (s.inclusive ? t.data < s.value : t.data <= s.value) && (i = this._getOrReturnCtx(t, i), We(i, {
        code: De.too_small,
        minimum: s.value,
        type: "number",
        inclusive: s.inclusive,
        exact: !1,
        message: s.message
      }), n.dirty()) : s.kind === "max" ? (s.inclusive ? t.data > s.value : t.data >= s.value) && (i = this._getOrReturnCtx(t, i), We(i, {
        code: De.too_big,
        maximum: s.value,
        type: "number",
        inclusive: s.inclusive,
        exact: !1,
        message: s.message
      }), n.dirty()) : s.kind === "multipleOf" ? kk(t.data, s.value) !== 0 && (i = this._getOrReturnCtx(t, i), We(i, {
        code: De.not_multiple_of,
        multipleOf: s.value,
        message: s.message
      }), n.dirty()) : s.kind === "finite" ? Number.isFinite(t.data) || (i = this._getOrReturnCtx(t, i), We(i, {
        code: De.not_finite,
        message: s.message
      }), n.dirty()) : kt.assertNever(s);
    return { status: n.value, value: t.data };
  }
  gte(t, r) {
    return this.setLimit("min", t, !0, tt.toString(r));
  }
  gt(t, r) {
    return this.setLimit("min", t, !1, tt.toString(r));
  }
  lte(t, r) {
    return this.setLimit("max", t, !0, tt.toString(r));
  }
  lt(t, r) {
    return this.setLimit("max", t, !1, tt.toString(r));
  }
  setLimit(t, r, i, n) {
    return new ls({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: r,
          inclusive: i,
          message: tt.toString(n)
        }
      ]
    });
  }
  _addCheck(t) {
    return new ls({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  int(t) {
    return this._addCheck({
      kind: "int",
      message: tt.toString(t)
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: tt.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: tt.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: tt.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: tt.toString(t)
    });
  }
  multipleOf(t, r) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: tt.toString(r)
    });
  }
  finite(t) {
    return this._addCheck({
      kind: "finite",
      message: tt.toString(t)
    });
  }
  safe(t) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: tt.toString(t)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: tt.toString(t)
    });
  }
  get minValue() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "min" && (t === null || r.value > t) && (t = r.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    return t;
  }
  get isInt() {
    return !!this._def.checks.find((t) => t.kind === "int" || t.kind === "multipleOf" && kt.isInteger(t.value));
  }
  get isFinite() {
    let t = null, r = null;
    for (const i of this._def.checks) {
      if (i.kind === "finite" || i.kind === "int" || i.kind === "multipleOf")
        return !0;
      i.kind === "min" ? (r === null || i.value > r) && (r = i.value) : i.kind === "max" && (t === null || i.value < t) && (t = i.value);
    }
    return Number.isFinite(r) && Number.isFinite(t);
  }
}
ls.create = (e) => new ls({
  checks: [],
  typeName: ot.ZodNumber,
  coerce: (e == null ? void 0 : e.coerce) || !1,
  ...yt(e)
});
class fs extends _t {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = BigInt(t.data)), this._getType(t) !== Ve.bigint) {
      const s = this._getOrReturnCtx(t);
      return We(s, {
        code: De.invalid_type,
        expected: Ve.bigint,
        received: s.parsedType
      }), dt;
    }
    let i;
    const n = new Ar();
    for (const s of this._def.checks)
      s.kind === "min" ? (s.inclusive ? t.data < s.value : t.data <= s.value) && (i = this._getOrReturnCtx(t, i), We(i, {
        code: De.too_small,
        type: "bigint",
        minimum: s.value,
        inclusive: s.inclusive,
        message: s.message
      }), n.dirty()) : s.kind === "max" ? (s.inclusive ? t.data > s.value : t.data >= s.value) && (i = this._getOrReturnCtx(t, i), We(i, {
        code: De.too_big,
        type: "bigint",
        maximum: s.value,
        inclusive: s.inclusive,
        message: s.message
      }), n.dirty()) : s.kind === "multipleOf" ? t.data % s.value !== BigInt(0) && (i = this._getOrReturnCtx(t, i), We(i, {
        code: De.not_multiple_of,
        multipleOf: s.value,
        message: s.message
      }), n.dirty()) : kt.assertNever(s);
    return { status: n.value, value: t.data };
  }
  gte(t, r) {
    return this.setLimit("min", t, !0, tt.toString(r));
  }
  gt(t, r) {
    return this.setLimit("min", t, !1, tt.toString(r));
  }
  lte(t, r) {
    return this.setLimit("max", t, !0, tt.toString(r));
  }
  lt(t, r) {
    return this.setLimit("max", t, !1, tt.toString(r));
  }
  setLimit(t, r, i, n) {
    return new fs({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: r,
          inclusive: i,
          message: tt.toString(n)
        }
      ]
    });
  }
  _addCheck(t) {
    return new fs({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: tt.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: tt.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: tt.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: tt.toString(t)
    });
  }
  multipleOf(t, r) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: tt.toString(r)
    });
  }
  get minValue() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "min" && (t === null || r.value > t) && (t = r.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    return t;
  }
}
fs.create = (e) => {
  var t;
  return new fs({
    checks: [],
    typeName: ot.ZodBigInt,
    coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
    ...yt(e)
  });
};
class $u extends _t {
  _parse(t) {
    if (this._def.coerce && (t.data = !!t.data), this._getType(t) !== Ve.boolean) {
      const i = this._getOrReturnCtx(t);
      return We(i, {
        code: De.invalid_type,
        expected: Ve.boolean,
        received: i.parsedType
      }), dt;
    }
    return Dr(t.data);
  }
}
$u.create = (e) => new $u({
  typeName: ot.ZodBoolean,
  coerce: (e == null ? void 0 : e.coerce) || !1,
  ...yt(e)
});
class Ys extends _t {
  _parse(t) {
    if (this._def.coerce && (t.data = new Date(t.data)), this._getType(t) !== Ve.date) {
      const s = this._getOrReturnCtx(t);
      return We(s, {
        code: De.invalid_type,
        expected: Ve.date,
        received: s.parsedType
      }), dt;
    }
    if (isNaN(t.data.getTime())) {
      const s = this._getOrReturnCtx(t);
      return We(s, {
        code: De.invalid_date
      }), dt;
    }
    const i = new Ar();
    let n;
    for (const s of this._def.checks)
      s.kind === "min" ? t.data.getTime() < s.value && (n = this._getOrReturnCtx(t, n), We(n, {
        code: De.too_small,
        message: s.message,
        inclusive: !0,
        exact: !1,
        minimum: s.value,
        type: "date"
      }), i.dirty()) : s.kind === "max" ? t.data.getTime() > s.value && (n = this._getOrReturnCtx(t, n), We(n, {
        code: De.too_big,
        message: s.message,
        inclusive: !0,
        exact: !1,
        maximum: s.value,
        type: "date"
      }), i.dirty()) : kt.assertNever(s);
    return {
      status: i.value,
      value: new Date(t.data.getTime())
    };
  }
  _addCheck(t) {
    return new Ys({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  min(t, r) {
    return this._addCheck({
      kind: "min",
      value: t.getTime(),
      message: tt.toString(r)
    });
  }
  max(t, r) {
    return this._addCheck({
      kind: "max",
      value: t.getTime(),
      message: tt.toString(r)
    });
  }
  get minDate() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "min" && (t === null || r.value > t) && (t = r.value);
    return t != null ? new Date(t) : null;
  }
  get maxDate() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    return t != null ? new Date(t) : null;
  }
}
Ys.create = (e) => new Ys({
  checks: [],
  coerce: (e == null ? void 0 : e.coerce) || !1,
  typeName: ot.ZodDate,
  ...yt(e)
});
class Kl extends _t {
  _parse(t) {
    if (this._getType(t) !== Ve.symbol) {
      const i = this._getOrReturnCtx(t);
      return We(i, {
        code: De.invalid_type,
        expected: Ve.symbol,
        received: i.parsedType
      }), dt;
    }
    return Dr(t.data);
  }
}
Kl.create = (e) => new Kl({
  typeName: ot.ZodSymbol,
  ...yt(e)
});
class Eu extends _t {
  _parse(t) {
    if (this._getType(t) !== Ve.undefined) {
      const i = this._getOrReturnCtx(t);
      return We(i, {
        code: De.invalid_type,
        expected: Ve.undefined,
        received: i.parsedType
      }), dt;
    }
    return Dr(t.data);
  }
}
Eu.create = (e) => new Eu({
  typeName: ot.ZodUndefined,
  ...yt(e)
});
class xu extends _t {
  _parse(t) {
    if (this._getType(t) !== Ve.null) {
      const i = this._getOrReturnCtx(t);
      return We(i, {
        code: De.invalid_type,
        expected: Ve.null,
        received: i.parsedType
      }), dt;
    }
    return Dr(t.data);
  }
}
xu.create = (e) => new xu({
  typeName: ot.ZodNull,
  ...yt(e)
});
class to extends _t {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(t) {
    return Dr(t.data);
  }
}
to.create = (e) => new to({
  typeName: ot.ZodAny,
  ...yt(e)
});
class Ws extends _t {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(t) {
    return Dr(t.data);
  }
}
Ws.create = (e) => new Ws({
  typeName: ot.ZodUnknown,
  ...yt(e)
});
class Ai extends _t {
  _parse(t) {
    const r = this._getOrReturnCtx(t);
    return We(r, {
      code: De.invalid_type,
      expected: Ve.never,
      received: r.parsedType
    }), dt;
  }
}
Ai.create = (e) => new Ai({
  typeName: ot.ZodNever,
  ...yt(e)
});
class Yl extends _t {
  _parse(t) {
    if (this._getType(t) !== Ve.undefined) {
      const i = this._getOrReturnCtx(t);
      return We(i, {
        code: De.invalid_type,
        expected: Ve.void,
        received: i.parsedType
      }), dt;
    }
    return Dr(t.data);
  }
}
Yl.create = (e) => new Yl({
  typeName: ot.ZodVoid,
  ...yt(e)
});
class In extends _t {
  _parse(t) {
    const { ctx: r, status: i } = this._processInputParams(t), n = this._def;
    if (r.parsedType !== Ve.array)
      return We(r, {
        code: De.invalid_type,
        expected: Ve.array,
        received: r.parsedType
      }), dt;
    if (n.exactLength !== null) {
      const a = r.data.length > n.exactLength.value, u = r.data.length < n.exactLength.value;
      (a || u) && (We(r, {
        code: a ? De.too_big : De.too_small,
        minimum: u ? n.exactLength.value : void 0,
        maximum: a ? n.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: n.exactLength.message
      }), i.dirty());
    }
    if (n.minLength !== null && r.data.length < n.minLength.value && (We(r, {
      code: De.too_small,
      minimum: n.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: n.minLength.message
    }), i.dirty()), n.maxLength !== null && r.data.length > n.maxLength.value && (We(r, {
      code: De.too_big,
      maximum: n.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: n.maxLength.message
    }), i.dirty()), r.common.async)
      return Promise.all([...r.data].map((a, u) => n.type._parseAsync(new ri(r, a, r.path, u)))).then((a) => Ar.mergeArray(i, a));
    const s = [...r.data].map((a, u) => n.type._parseSync(new ri(r, a, r.path, u)));
    return Ar.mergeArray(i, s);
  }
  get element() {
    return this._def.type;
  }
  min(t, r) {
    return new In({
      ...this._def,
      minLength: { value: t, message: tt.toString(r) }
    });
  }
  max(t, r) {
    return new In({
      ...this._def,
      maxLength: { value: t, message: tt.toString(r) }
    });
  }
  length(t, r) {
    return new In({
      ...this._def,
      exactLength: { value: t, message: tt.toString(r) }
    });
  }
  nonempty(t) {
    return this.min(1, t);
  }
}
In.create = (e, t) => new In({
  type: e,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: ot.ZodArray,
  ...yt(t)
});
function Da(e) {
  if (e instanceof Jt) {
    const t = {};
    for (const r in e.shape) {
      const i = e.shape[r];
      t[r] = Ei.create(Da(i));
    }
    return new Jt({
      ...e._def,
      shape: () => t
    });
  } else
    return e instanceof In ? new In({
      ...e._def,
      type: Da(e.element)
    }) : e instanceof Ei ? Ei.create(Da(e.unwrap())) : e instanceof Xs ? Xs.create(Da(e.unwrap())) : e instanceof ni ? ni.create(e.items.map((t) => Da(t))) : e;
}
class Jt extends _t {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const t = this._def.shape(), r = kt.objectKeys(t);
    return this._cached = { shape: t, keys: r };
  }
  _parse(t) {
    if (this._getType(t) !== Ve.object) {
      const l = this._getOrReturnCtx(t);
      return We(l, {
        code: De.invalid_type,
        expected: Ve.object,
        received: l.parsedType
      }), dt;
    }
    const { status: i, ctx: n } = this._processInputParams(t), { shape: s, keys: a } = this._getCached(), u = [];
    if (!(this._def.catchall instanceof Ai && this._def.unknownKeys === "strip"))
      for (const l in n.data)
        a.includes(l) || u.push(l);
    const c = [];
    for (const l of a) {
      const d = s[l], p = n.data[l];
      c.push({
        key: { status: "valid", value: l },
        value: d._parse(new ri(n, p, n.path, l)),
        alwaysSet: l in n.data
      });
    }
    if (this._def.catchall instanceof Ai) {
      const l = this._def.unknownKeys;
      if (l === "passthrough")
        for (const d of u)
          c.push({
            key: { status: "valid", value: d },
            value: { status: "valid", value: n.data[d] }
          });
      else if (l === "strict")
        u.length > 0 && (We(n, {
          code: De.unrecognized_keys,
          keys: u
        }), i.dirty());
      else if (l !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const l = this._def.catchall;
      for (const d of u) {
        const p = n.data[d];
        c.push({
          key: { status: "valid", value: d },
          value: l._parse(
            new ri(n, p, n.path, d)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: d in n.data
        });
      }
    }
    return n.common.async ? Promise.resolve().then(async () => {
      const l = [];
      for (const d of c) {
        const p = await d.key;
        l.push({
          key: p,
          value: await d.value,
          alwaysSet: d.alwaysSet
        });
      }
      return l;
    }).then((l) => Ar.mergeObjectSync(i, l)) : Ar.mergeObjectSync(i, c);
  }
  get shape() {
    return this._def.shape();
  }
  strict(t) {
    return tt.errToObj, new Jt({
      ...this._def,
      unknownKeys: "strict",
      ...t !== void 0 ? {
        errorMap: (r, i) => {
          var n, s, a, u;
          const c = (a = (s = (n = this._def).errorMap) === null || s === void 0 ? void 0 : s.call(n, r, i).message) !== null && a !== void 0 ? a : i.defaultError;
          return r.code === "unrecognized_keys" ? {
            message: (u = tt.errToObj(t).message) !== null && u !== void 0 ? u : c
          } : {
            message: c
          };
        }
      } : {}
    });
  }
  strip() {
    return new Jt({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new Jt({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(t) {
    return new Jt({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...t
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(t) {
    return new Jt({
      unknownKeys: t._def.unknownKeys,
      catchall: t._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...t._def.shape()
      }),
      typeName: ot.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(t, r) {
    return this.augment({ [t]: r });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(t) {
    return new Jt({
      ...this._def,
      catchall: t
    });
  }
  pick(t) {
    const r = {};
    return kt.objectKeys(t).forEach((i) => {
      t[i] && this.shape[i] && (r[i] = this.shape[i]);
    }), new Jt({
      ...this._def,
      shape: () => r
    });
  }
  omit(t) {
    const r = {};
    return kt.objectKeys(this.shape).forEach((i) => {
      t[i] || (r[i] = this.shape[i]);
    }), new Jt({
      ...this._def,
      shape: () => r
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return Da(this);
  }
  partial(t) {
    const r = {};
    return kt.objectKeys(this.shape).forEach((i) => {
      const n = this.shape[i];
      t && !t[i] ? r[i] = n : r[i] = n.optional();
    }), new Jt({
      ...this._def,
      shape: () => r
    });
  }
  required(t) {
    const r = {};
    return kt.objectKeys(this.shape).forEach((i) => {
      if (t && !t[i])
        r[i] = this.shape[i];
      else {
        let s = this.shape[i];
        for (; s instanceof Ei; )
          s = s._def.innerType;
        r[i] = s;
      }
    }), new Jt({
      ...this._def,
      shape: () => r
    });
  }
  keyof() {
    return B2(kt.objectKeys(this.shape));
  }
}
Jt.create = (e, t) => new Jt({
  shape: () => e,
  unknownKeys: "strip",
  catchall: Ai.create(),
  typeName: ot.ZodObject,
  ...yt(t)
});
Jt.strictCreate = (e, t) => new Jt({
  shape: () => e,
  unknownKeys: "strict",
  catchall: Ai.create(),
  typeName: ot.ZodObject,
  ...yt(t)
});
Jt.lazycreate = (e, t) => new Jt({
  shape: e,
  unknownKeys: "strip",
  catchall: Ai.create(),
  typeName: ot.ZodObject,
  ...yt(t)
});
class Ou extends _t {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t), i = this._def.options;
    function n(s) {
      for (const u of s)
        if (u.result.status === "valid")
          return u.result;
      for (const u of s)
        if (u.result.status === "dirty")
          return r.common.issues.push(...u.ctx.common.issues), u.result;
      const a = s.map((u) => new Tn(u.ctx.common.issues));
      return We(r, {
        code: De.invalid_union,
        unionErrors: a
      }), dt;
    }
    if (r.common.async)
      return Promise.all(i.map(async (s) => {
        const a = {
          ...r,
          common: {
            ...r.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await s._parseAsync({
            data: r.data,
            path: r.path,
            parent: a
          }),
          ctx: a
        };
      })).then(n);
    {
      let s;
      const a = [];
      for (const c of i) {
        const l = {
          ...r,
          common: {
            ...r.common,
            issues: []
          },
          parent: null
        }, d = c._parseSync({
          data: r.data,
          path: r.path,
          parent: l
        });
        if (d.status === "valid")
          return d;
        d.status === "dirty" && !s && (s = { result: d, ctx: l }), l.common.issues.length && a.push(l.common.issues);
      }
      if (s)
        return r.common.issues.push(...s.ctx.common.issues), s.result;
      const u = a.map((c) => new Tn(c));
      return We(r, {
        code: De.invalid_union,
        unionErrors: u
      }), dt;
    }
  }
  get options() {
    return this._def.options;
  }
}
Ou.create = (e, t) => new Ou({
  options: e,
  typeName: ot.ZodUnion,
  ...yt(t)
});
const El = (e) => e instanceof Au ? El(e.schema) : e instanceof kn ? El(e.innerType()) : e instanceof Cu ? [e.value] : e instanceof ds ? e.options : e instanceof Ru ? Object.keys(e.enum) : e instanceof Tu ? El(e._def.innerType) : e instanceof Eu ? [void 0] : e instanceof xu ? [null] : null;
class Tf extends _t {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t);
    if (r.parsedType !== Ve.object)
      return We(r, {
        code: De.invalid_type,
        expected: Ve.object,
        received: r.parsedType
      }), dt;
    const i = this.discriminator, n = r.data[i], s = this.optionsMap.get(n);
    return s ? r.common.async ? s._parseAsync({
      data: r.data,
      path: r.path,
      parent: r
    }) : s._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }) : (We(r, {
      code: De.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [i]
    }), dt);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(t, r, i) {
    const n = /* @__PURE__ */ new Map();
    for (const s of r) {
      const a = El(s.shape[t]);
      if (!a)
        throw new Error(`A discriminator value for key \`${t}\` could not be extracted from all schema options`);
      for (const u of a) {
        if (n.has(u))
          throw new Error(`Discriminator property ${String(t)} has duplicate value ${String(u)}`);
        n.set(u, s);
      }
    }
    return new Tf({
      typeName: ot.ZodDiscriminatedUnion,
      discriminator: t,
      options: r,
      optionsMap: n,
      ...yt(i)
    });
  }
}
function ey(e, t) {
  const r = ns(e), i = ns(t);
  if (e === t)
    return { valid: !0, data: e };
  if (r === Ve.object && i === Ve.object) {
    const n = kt.objectKeys(t), s = kt.objectKeys(e).filter((u) => n.indexOf(u) !== -1), a = { ...e, ...t };
    for (const u of s) {
      const c = ey(e[u], t[u]);
      if (!c.valid)
        return { valid: !1 };
      a[u] = c.data;
    }
    return { valid: !0, data: a };
  } else if (r === Ve.array && i === Ve.array) {
    if (e.length !== t.length)
      return { valid: !1 };
    const n = [];
    for (let s = 0; s < e.length; s++) {
      const a = e[s], u = t[s], c = ey(a, u);
      if (!c.valid)
        return { valid: !1 };
      n.push(c.data);
    }
    return { valid: !0, data: n };
  } else
    return r === Ve.date && i === Ve.date && +e == +t ? { valid: !0, data: e } : { valid: !1 };
}
class Pu extends _t {
  _parse(t) {
    const { status: r, ctx: i } = this._processInputParams(t), n = (s, a) => {
      if (Xm(s) || Xm(a))
        return dt;
      const u = ey(s.value, a.value);
      return u.valid ? ((Qm(s) || Qm(a)) && r.dirty(), { status: r.value, value: u.data }) : (We(i, {
        code: De.invalid_intersection_types
      }), dt);
    };
    return i.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: i.data,
        path: i.path,
        parent: i
      }),
      this._def.right._parseAsync({
        data: i.data,
        path: i.path,
        parent: i
      })
    ]).then(([s, a]) => n(s, a)) : n(this._def.left._parseSync({
      data: i.data,
      path: i.path,
      parent: i
    }), this._def.right._parseSync({
      data: i.data,
      path: i.path,
      parent: i
    }));
  }
}
Pu.create = (e, t, r) => new Pu({
  left: e,
  right: t,
  typeName: ot.ZodIntersection,
  ...yt(r)
});
class ni extends _t {
  _parse(t) {
    const { status: r, ctx: i } = this._processInputParams(t);
    if (i.parsedType !== Ve.array)
      return We(i, {
        code: De.invalid_type,
        expected: Ve.array,
        received: i.parsedType
      }), dt;
    if (i.data.length < this._def.items.length)
      return We(i, {
        code: De.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), dt;
    !this._def.rest && i.data.length > this._def.items.length && (We(i, {
      code: De.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), r.dirty());
    const s = [...i.data].map((a, u) => {
      const c = this._def.items[u] || this._def.rest;
      return c ? c._parse(new ri(i, a, i.path, u)) : null;
    }).filter((a) => !!a);
    return i.common.async ? Promise.all(s).then((a) => Ar.mergeArray(r, a)) : Ar.mergeArray(r, s);
  }
  get items() {
    return this._def.items;
  }
  rest(t) {
    return new ni({
      ...this._def,
      rest: t
    });
  }
}
ni.create = (e, t) => {
  if (!Array.isArray(e))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new ni({
    items: e,
    typeName: ot.ZodTuple,
    rest: null,
    ...yt(t)
  });
};
class Su extends _t {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(t) {
    const { status: r, ctx: i } = this._processInputParams(t);
    if (i.parsedType !== Ve.object)
      return We(i, {
        code: De.invalid_type,
        expected: Ve.object,
        received: i.parsedType
      }), dt;
    const n = [], s = this._def.keyType, a = this._def.valueType;
    for (const u in i.data)
      n.push({
        key: s._parse(new ri(i, u, i.path, u)),
        value: a._parse(new ri(i, i.data[u], i.path, u))
      });
    return i.common.async ? Ar.mergeObjectAsync(r, n) : Ar.mergeObjectSync(r, n);
  }
  get element() {
    return this._def.valueType;
  }
  static create(t, r, i) {
    return r instanceof _t ? new Su({
      keyType: t,
      valueType: r,
      typeName: ot.ZodRecord,
      ...yt(i)
    }) : new Su({
      keyType: Rn.create(),
      valueType: t,
      typeName: ot.ZodRecord,
      ...yt(r)
    });
  }
}
class Jl extends _t {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(t) {
    const { status: r, ctx: i } = this._processInputParams(t);
    if (i.parsedType !== Ve.map)
      return We(i, {
        code: De.invalid_type,
        expected: Ve.map,
        received: i.parsedType
      }), dt;
    const n = this._def.keyType, s = this._def.valueType, a = [...i.data.entries()].map(([u, c], l) => ({
      key: n._parse(new ri(i, u, i.path, [l, "key"])),
      value: s._parse(new ri(i, c, i.path, [l, "value"]))
    }));
    if (i.common.async) {
      const u = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const c of a) {
          const l = await c.key, d = await c.value;
          if (l.status === "aborted" || d.status === "aborted")
            return dt;
          (l.status === "dirty" || d.status === "dirty") && r.dirty(), u.set(l.value, d.value);
        }
        return { status: r.value, value: u };
      });
    } else {
      const u = /* @__PURE__ */ new Map();
      for (const c of a) {
        const l = c.key, d = c.value;
        if (l.status === "aborted" || d.status === "aborted")
          return dt;
        (l.status === "dirty" || d.status === "dirty") && r.dirty(), u.set(l.value, d.value);
      }
      return { status: r.value, value: u };
    }
  }
}
Jl.create = (e, t, r) => new Jl({
  valueType: t,
  keyType: e,
  typeName: ot.ZodMap,
  ...yt(r)
});
class Js extends _t {
  _parse(t) {
    const { status: r, ctx: i } = this._processInputParams(t);
    if (i.parsedType !== Ve.set)
      return We(i, {
        code: De.invalid_type,
        expected: Ve.set,
        received: i.parsedType
      }), dt;
    const n = this._def;
    n.minSize !== null && i.data.size < n.minSize.value && (We(i, {
      code: De.too_small,
      minimum: n.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: n.minSize.message
    }), r.dirty()), n.maxSize !== null && i.data.size > n.maxSize.value && (We(i, {
      code: De.too_big,
      maximum: n.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: n.maxSize.message
    }), r.dirty());
    const s = this._def.valueType;
    function a(c) {
      const l = /* @__PURE__ */ new Set();
      for (const d of c) {
        if (d.status === "aborted")
          return dt;
        d.status === "dirty" && r.dirty(), l.add(d.value);
      }
      return { status: r.value, value: l };
    }
    const u = [...i.data.values()].map((c, l) => s._parse(new ri(i, c, i.path, l)));
    return i.common.async ? Promise.all(u).then((c) => a(c)) : a(u);
  }
  min(t, r) {
    return new Js({
      ...this._def,
      minSize: { value: t, message: tt.toString(r) }
    });
  }
  max(t, r) {
    return new Js({
      ...this._def,
      maxSize: { value: t, message: tt.toString(r) }
    });
  }
  size(t, r) {
    return this.min(t, r).max(t, r);
  }
  nonempty(t) {
    return this.min(1, t);
  }
}
Js.create = (e, t) => new Js({
  valueType: e,
  minSize: null,
  maxSize: null,
  typeName: ot.ZodSet,
  ...yt(t)
});
class Ha extends _t {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(t) {
    const { ctx: r } = this._processInputParams(t);
    if (r.parsedType !== Ve.function)
      return We(r, {
        code: De.invalid_type,
        expected: Ve.function,
        received: r.parsedType
      }), dt;
    function i(u, c) {
      return Hl({
        data: u,
        path: r.path,
        errorMaps: [
          r.common.contextualErrorMap,
          r.schemaErrorMap,
          Wl(),
          _u
        ].filter((l) => !!l),
        issueData: {
          code: De.invalid_arguments,
          argumentsError: c
        }
      });
    }
    function n(u, c) {
      return Hl({
        data: u,
        path: r.path,
        errorMaps: [
          r.common.contextualErrorMap,
          r.schemaErrorMap,
          Wl(),
          _u
        ].filter((l) => !!l),
        issueData: {
          code: De.invalid_return_type,
          returnTypeError: c
        }
      });
    }
    const s = { errorMap: r.common.contextualErrorMap }, a = r.data;
    if (this._def.returns instanceof ro) {
      const u = this;
      return Dr(async function(...c) {
        const l = new Tn([]), d = await u._def.args.parseAsync(c, s).catch((v) => {
          throw l.addIssue(i(c, v)), l;
        }), p = await Reflect.apply(a, this, d);
        return await u._def.returns._def.type.parseAsync(p, s).catch((v) => {
          throw l.addIssue(n(p, v)), l;
        });
      });
    } else {
      const u = this;
      return Dr(function(...c) {
        const l = u._def.args.safeParse(c, s);
        if (!l.success)
          throw new Tn([i(c, l.error)]);
        const d = Reflect.apply(a, this, l.data), p = u._def.returns.safeParse(d, s);
        if (!p.success)
          throw new Tn([n(d, p.error)]);
        return p.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...t) {
    return new Ha({
      ...this._def,
      args: ni.create(t).rest(Ws.create())
    });
  }
  returns(t) {
    return new Ha({
      ...this._def,
      returns: t
    });
  }
  implement(t) {
    return this.parse(t);
  }
  strictImplement(t) {
    return this.parse(t);
  }
  static create(t, r, i) {
    return new Ha({
      args: t || ni.create([]).rest(Ws.create()),
      returns: r || Ws.create(),
      typeName: ot.ZodFunction,
      ...yt(i)
    });
  }
}
class Au extends _t {
  get schema() {
    return this._def.getter();
  }
  _parse(t) {
    const { ctx: r } = this._processInputParams(t);
    return this._def.getter()._parse({ data: r.data, path: r.path, parent: r });
  }
}
Au.create = (e, t) => new Au({
  getter: e,
  typeName: ot.ZodLazy,
  ...yt(t)
});
class Cu extends _t {
  _parse(t) {
    if (t.data !== this._def.value) {
      const r = this._getOrReturnCtx(t);
      return We(r, {
        received: r.data,
        code: De.invalid_literal,
        expected: this._def.value
      }), dt;
    }
    return { status: "valid", value: t.data };
  }
  get value() {
    return this._def.value;
  }
}
Cu.create = (e, t) => new Cu({
  value: e,
  typeName: ot.ZodLiteral,
  ...yt(t)
});
function B2(e, t) {
  return new ds({
    values: e,
    typeName: ot.ZodEnum,
    ...yt(t)
  });
}
class ds extends _t {
  _parse(t) {
    if (typeof t.data != "string") {
      const r = this._getOrReturnCtx(t), i = this._def.values;
      return We(r, {
        expected: kt.joinValues(i),
        received: r.parsedType,
        code: De.invalid_type
      }), dt;
    }
    if (this._def.values.indexOf(t.data) === -1) {
      const r = this._getOrReturnCtx(t), i = this._def.values;
      return We(r, {
        received: r.data,
        code: De.invalid_enum_value,
        options: i
      }), dt;
    }
    return Dr(t.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const t = {};
    for (const r of this._def.values)
      t[r] = r;
    return t;
  }
  get Values() {
    const t = {};
    for (const r of this._def.values)
      t[r] = r;
    return t;
  }
  get Enum() {
    const t = {};
    for (const r of this._def.values)
      t[r] = r;
    return t;
  }
  extract(t) {
    return ds.create(t);
  }
  exclude(t) {
    return ds.create(this.options.filter((r) => !t.includes(r)));
  }
}
ds.create = B2;
class Ru extends _t {
  _parse(t) {
    const r = kt.getValidEnumValues(this._def.values), i = this._getOrReturnCtx(t);
    if (i.parsedType !== Ve.string && i.parsedType !== Ve.number) {
      const n = kt.objectValues(r);
      return We(i, {
        expected: kt.joinValues(n),
        received: i.parsedType,
        code: De.invalid_type
      }), dt;
    }
    if (r.indexOf(t.data) === -1) {
      const n = kt.objectValues(r);
      return We(i, {
        received: i.data,
        code: De.invalid_enum_value,
        options: n
      }), dt;
    }
    return Dr(t.data);
  }
  get enum() {
    return this._def.values;
  }
}
Ru.create = (e, t) => new Ru({
  values: e,
  typeName: ot.ZodNativeEnum,
  ...yt(t)
});
class ro extends _t {
  unwrap() {
    return this._def.type;
  }
  _parse(t) {
    const { ctx: r } = this._processInputParams(t);
    if (r.parsedType !== Ve.promise && r.common.async === !1)
      return We(r, {
        code: De.invalid_type,
        expected: Ve.promise,
        received: r.parsedType
      }), dt;
    const i = r.parsedType === Ve.promise ? r.data : Promise.resolve(r.data);
    return Dr(i.then((n) => this._def.type.parseAsync(n, {
      path: r.path,
      errorMap: r.common.contextualErrorMap
    })));
  }
}
ro.create = (e, t) => new ro({
  type: e,
  typeName: ot.ZodPromise,
  ...yt(t)
});
class kn extends _t {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ot.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(t) {
    const { status: r, ctx: i } = this._processInputParams(t), n = this._def.effect || null, s = {
      addIssue: (a) => {
        We(i, a), a.fatal ? r.abort() : r.dirty();
      },
      get path() {
        return i.path;
      }
    };
    if (s.addIssue = s.addIssue.bind(s), n.type === "preprocess") {
      const a = n.transform(i.data, s);
      return i.common.issues.length ? {
        status: "dirty",
        value: i.data
      } : i.common.async ? Promise.resolve(a).then((u) => this._def.schema._parseAsync({
        data: u,
        path: i.path,
        parent: i
      })) : this._def.schema._parseSync({
        data: a,
        path: i.path,
        parent: i
      });
    }
    if (n.type === "refinement") {
      const a = (u) => {
        const c = n.refinement(u, s);
        if (i.common.async)
          return Promise.resolve(c);
        if (c instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return u;
      };
      if (i.common.async === !1) {
        const u = this._def.schema._parseSync({
          data: i.data,
          path: i.path,
          parent: i
        });
        return u.status === "aborted" ? dt : (u.status === "dirty" && r.dirty(), a(u.value), { status: r.value, value: u.value });
      } else
        return this._def.schema._parseAsync({ data: i.data, path: i.path, parent: i }).then((u) => u.status === "aborted" ? dt : (u.status === "dirty" && r.dirty(), a(u.value).then(() => ({ status: r.value, value: u.value }))));
    }
    if (n.type === "transform")
      if (i.common.async === !1) {
        const a = this._def.schema._parseSync({
          data: i.data,
          path: i.path,
          parent: i
        });
        if (!wu(a))
          return a;
        const u = n.transform(a.value, s);
        if (u instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: r.value, value: u };
      } else
        return this._def.schema._parseAsync({ data: i.data, path: i.path, parent: i }).then((a) => wu(a) ? Promise.resolve(n.transform(a.value, s)).then((u) => ({ status: r.value, value: u })) : a);
    kt.assertNever(n);
  }
}
kn.create = (e, t, r) => new kn({
  schema: e,
  typeName: ot.ZodEffects,
  effect: t,
  ...yt(r)
});
kn.createWithPreprocess = (e, t, r) => new kn({
  schema: t,
  effect: { type: "preprocess", transform: e },
  typeName: ot.ZodEffects,
  ...yt(r)
});
class Ei extends _t {
  _parse(t) {
    return this._getType(t) === Ve.undefined ? Dr(void 0) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
}
Ei.create = (e, t) => new Ei({
  innerType: e,
  typeName: ot.ZodOptional,
  ...yt(t)
});
class Xs extends _t {
  _parse(t) {
    return this._getType(t) === Ve.null ? Dr(null) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
}
Xs.create = (e, t) => new Xs({
  innerType: e,
  typeName: ot.ZodNullable,
  ...yt(t)
});
class Tu extends _t {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t);
    let i = r.data;
    return r.parsedType === Ve.undefined && (i = this._def.defaultValue()), this._def.innerType._parse({
      data: i,
      path: r.path,
      parent: r
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
Tu.create = (e, t) => new Tu({
  innerType: e,
  typeName: ot.ZodDefault,
  defaultValue: typeof t.default == "function" ? t.default : () => t.default,
  ...yt(t)
});
class Xl extends _t {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t), i = {
      ...r,
      common: {
        ...r.common,
        issues: []
      }
    }, n = this._def.innerType._parse({
      data: i.data,
      path: i.path,
      parent: {
        ...i
      }
    });
    return Gl(n) ? n.then((s) => ({
      status: "valid",
      value: s.status === "valid" ? s.value : this._def.catchValue({
        get error() {
          return new Tn(i.common.issues);
        },
        input: i.data
      })
    })) : {
      status: "valid",
      value: n.status === "valid" ? n.value : this._def.catchValue({
        get error() {
          return new Tn(i.common.issues);
        },
        input: i.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
}
Xl.create = (e, t) => new Xl({
  innerType: e,
  typeName: ot.ZodCatch,
  catchValue: typeof t.catch == "function" ? t.catch : () => t.catch,
  ...yt(t)
});
class Ql extends _t {
  _parse(t) {
    if (this._getType(t) !== Ve.nan) {
      const i = this._getOrReturnCtx(t);
      return We(i, {
        code: De.invalid_type,
        expected: Ve.nan,
        received: i.parsedType
      }), dt;
    }
    return { status: "valid", value: t.data };
  }
}
Ql.create = (e) => new Ql({
  typeName: ot.ZodNaN,
  ...yt(e)
});
const Mk = Symbol("zod_brand");
class V2 extends _t {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t), i = r.data;
    return this._def.type._parse({
      data: i,
      path: r.path,
      parent: r
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class Wu extends _t {
  _parse(t) {
    const { status: r, ctx: i } = this._processInputParams(t);
    if (i.common.async)
      return (async () => {
        const s = await this._def.in._parseAsync({
          data: i.data,
          path: i.path,
          parent: i
        });
        return s.status === "aborted" ? dt : s.status === "dirty" ? (r.dirty(), U2(s.value)) : this._def.out._parseAsync({
          data: s.value,
          path: i.path,
          parent: i
        });
      })();
    {
      const n = this._def.in._parseSync({
        data: i.data,
        path: i.path,
        parent: i
      });
      return n.status === "aborted" ? dt : n.status === "dirty" ? (r.dirty(), {
        status: "dirty",
        value: n.value
      }) : this._def.out._parseSync({
        data: n.value,
        path: i.path,
        parent: i
      });
    }
  }
  static create(t, r) {
    return new Wu({
      in: t,
      out: r,
      typeName: ot.ZodPipeline
    });
  }
}
class ef extends _t {
  _parse(t) {
    const r = this._def.innerType._parse(t);
    return wu(r) && (r.value = Object.freeze(r.value)), r;
  }
}
ef.create = (e, t) => new ef({
  innerType: e,
  typeName: ot.ZodReadonly,
  ...yt(t)
});
const Z2 = (e, t = {}, r) => e ? to.create().superRefine((i, n) => {
  var s, a;
  if (!e(i)) {
    const u = typeof t == "function" ? t(i) : typeof t == "string" ? { message: t } : t, c = (a = (s = u.fatal) !== null && s !== void 0 ? s : r) !== null && a !== void 0 ? a : !0, l = typeof u == "string" ? { message: u } : u;
    n.addIssue({ code: "custom", ...l, fatal: c });
  }
}) : to.create(), Nk = {
  object: Jt.lazycreate
};
var ot;
(function(e) {
  e.ZodString = "ZodString", e.ZodNumber = "ZodNumber", e.ZodNaN = "ZodNaN", e.ZodBigInt = "ZodBigInt", e.ZodBoolean = "ZodBoolean", e.ZodDate = "ZodDate", e.ZodSymbol = "ZodSymbol", e.ZodUndefined = "ZodUndefined", e.ZodNull = "ZodNull", e.ZodAny = "ZodAny", e.ZodUnknown = "ZodUnknown", e.ZodNever = "ZodNever", e.ZodVoid = "ZodVoid", e.ZodArray = "ZodArray", e.ZodObject = "ZodObject", e.ZodUnion = "ZodUnion", e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", e.ZodIntersection = "ZodIntersection", e.ZodTuple = "ZodTuple", e.ZodRecord = "ZodRecord", e.ZodMap = "ZodMap", e.ZodSet = "ZodSet", e.ZodFunction = "ZodFunction", e.ZodLazy = "ZodLazy", e.ZodLiteral = "ZodLiteral", e.ZodEnum = "ZodEnum", e.ZodEffects = "ZodEffects", e.ZodNativeEnum = "ZodNativeEnum", e.ZodOptional = "ZodOptional", e.ZodNullable = "ZodNullable", e.ZodDefault = "ZodDefault", e.ZodCatch = "ZodCatch", e.ZodPromise = "ZodPromise", e.ZodBranded = "ZodBranded", e.ZodPipeline = "ZodPipeline", e.ZodReadonly = "ZodReadonly";
})(ot || (ot = {}));
const Dk = (e, t = {
  message: `Input not instance of ${e.name}`
}) => Z2((r) => r instanceof e, t), z2 = Rn.create, W2 = ls.create, Lk = Ql.create, qk = fs.create, H2 = $u.create, Fk = Ys.create, Uk = Kl.create, Bk = Eu.create, Vk = xu.create, Zk = to.create, zk = Ws.create, Wk = Ai.create, Hk = Yl.create, Gk = In.create, Kk = Jt.create, Yk = Jt.strictCreate, Jk = Ou.create, Xk = Tf.create, Qk = Pu.create, e3 = ni.create, t3 = Su.create, r3 = Jl.create, n3 = Js.create, i3 = Ha.create, s3 = Au.create, a3 = Cu.create, o3 = ds.create, u3 = Ru.create, c3 = ro.create, r1 = kn.create, l3 = Ei.create, f3 = Xs.create, d3 = kn.createWithPreprocess, p3 = Wu.create, h3 = () => z2().optional(), m3 = () => W2().optional(), y3 = () => H2().optional(), g3 = {
  string: (e) => Rn.create({ ...e, coerce: !0 }),
  number: (e) => ls.create({ ...e, coerce: !0 }),
  boolean: (e) => $u.create({
    ...e,
    coerce: !0
  }),
  bigint: (e) => fs.create({ ...e, coerce: !0 }),
  date: (e) => Ys.create({ ...e, coerce: !0 })
}, v3 = dt;
var Te = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: _u,
  setErrorMap: $k,
  getErrorMap: Wl,
  makeIssue: Hl,
  EMPTY_PATH: Ek,
  addIssueToContext: We,
  ParseStatus: Ar,
  INVALID: dt,
  DIRTY: U2,
  OK: Dr,
  isAborted: Xm,
  isDirty: Qm,
  isValid: wu,
  isAsync: Gl,
  get util() {
    return kt;
  },
  get objectUtil() {
    return Jm;
  },
  ZodParsedType: Ve,
  getParsedType: ns,
  ZodType: _t,
  ZodString: Rn,
  ZodNumber: ls,
  ZodBigInt: fs,
  ZodBoolean: $u,
  ZodDate: Ys,
  ZodSymbol: Kl,
  ZodUndefined: Eu,
  ZodNull: xu,
  ZodAny: to,
  ZodUnknown: Ws,
  ZodNever: Ai,
  ZodVoid: Yl,
  ZodArray: In,
  ZodObject: Jt,
  ZodUnion: Ou,
  ZodDiscriminatedUnion: Tf,
  ZodIntersection: Pu,
  ZodTuple: ni,
  ZodRecord: Su,
  ZodMap: Jl,
  ZodSet: Js,
  ZodFunction: Ha,
  ZodLazy: Au,
  ZodLiteral: Cu,
  ZodEnum: ds,
  ZodNativeEnum: Ru,
  ZodPromise: ro,
  ZodEffects: kn,
  ZodTransformer: kn,
  ZodOptional: Ei,
  ZodNullable: Xs,
  ZodDefault: Tu,
  ZodCatch: Xl,
  ZodNaN: Ql,
  BRAND: Mk,
  ZodBranded: V2,
  ZodPipeline: Wu,
  ZodReadonly: ef,
  custom: Z2,
  Schema: _t,
  ZodSchema: _t,
  late: Nk,
  get ZodFirstPartyTypeKind() {
    return ot;
  },
  coerce: g3,
  any: Zk,
  array: Gk,
  bigint: qk,
  boolean: H2,
  date: Fk,
  discriminatedUnion: Xk,
  effect: r1,
  enum: o3,
  function: i3,
  instanceof: Dk,
  intersection: Qk,
  lazy: s3,
  literal: a3,
  map: r3,
  nan: Lk,
  nativeEnum: u3,
  never: Wk,
  null: Vk,
  nullable: f3,
  number: W2,
  object: Kk,
  oboolean: y3,
  onumber: m3,
  optional: l3,
  ostring: h3,
  pipeline: p3,
  preprocess: d3,
  promise: c3,
  record: t3,
  set: n3,
  strictObject: Yk,
  string: z2,
  symbol: Uk,
  transformer: r1,
  tuple: e3,
  undefined: Bk,
  union: Jk,
  unknown: zk,
  void: Hk,
  NEVER: v3,
  ZodIssueCode: De,
  quotelessJson: wk,
  ZodError: Tn
});
Te.object({
  user_id: Te.string().nonempty(),
  public_key: Te.string().nonempty(),
  private_key: Te.string().nonempty()
});
Te.object({
  id: Te.string().nonempty(),
  path: Te.string().nonempty().catch("/"),
  method: Te.string().nonempty().catch("post")
});
const If = Te.object({
  n: Te.string().optional(),
  c: Te.string(),
  s: Te.string(),
  pk: Te.string()
}), b3 = Te.object({
  module_id: Te.string().nonempty(),
  method_id: Te.string().nonempty()
}), G2 = Te.object({
  id: Te.string().nonempty(),
  call: b3,
  multiplier: Te.number().nonnegative().optional(),
  sig: If
}), K2 = Te.object({
  max_spent: Te.number().nonnegative(),
  signature: If
}), ty = Te.object({
  id: Te.string().nonempty(),
  meta: Te.object({
    user_id: Te.string().nonempty()
  }),
  auth: If,
  offer: G2,
  params: Te.any().optional(),
  signed_transaction: K2.optional(),
  abort: Te.boolean().optional()
});
ty.merge(
  Te.object({
    auth: If
  })
);
const Y2 = Te.object({
  input: Te.object({
    tokens: Te.number(),
    bytes: Te.number()
  }),
  output: Te.object({
    tokens: Te.number(),
    bytes: Te.number()
  })
}), og = Te.object({
  id: Te.string(),
  user_id: Te.string(),
  details: Y2,
  total_bytes: Te.number(),
  total_tokens: Te.number(),
  offer: G2,
  sig: Te.string()
}), jf = Te.object({
  request_id: Te.string().nonempty(),
  msg: Te.any().optional(),
  code: Te.string().optional(),
  data: Te.any().optional()
});
jf.merge(
  Te.object({
    status: Te.literal("ready")
  })
);
jf.merge(
  Te.object({
    status: Te.literal("data")
  })
);
jf.merge(
  Te.object({
    receipt: og,
    costs: Y2,
    status: Te.literal("complete")
  })
);
jf.merge(
  Te.object({
    status: Te.literal("challenge"),
    data: Te.object({
      challenge: Te.string()
    })
  })
);
const Iu = Te.lazy(
  () => Te.object({
    type: Te.string(),
    properties: Te.union([Te.record(Iu), Iu]).optional(),
    required: Te.array(Te.string()).optional()
  })
), _3 = Te.object({
  summary: Te.string(),
  operationId: Te.string(),
  tags: Te.array(Te.string()).optional(),
  requestBody: Te.object({
    required: Te.boolean(),
    content: Te.record(
      Te.object({
        schema: Iu
      })
    ).optional()
  }),
  responses: Te.record(
    Te.object({
      description: Te.string(),
      content: Te.record(
        Te.object({
          schema: Iu
        })
      )
    })
  )
}), n1 = Te.object({
  id: Te.string().nonempty(),
  fns: Te.record(Te.any()),
  // TODO: specify this (tired of trying to make zod work with functions)
  schema: Te.object({
    info: Te.object({
      title: Te.string().optional().describe("filled in by the server"),
      description: Te.string().nonempty(),
      version: Te.string().nonempty()
    }),
    paths: Te.record(Te.record(_3)),
    components: Te.object({ schemas: Te.record(Iu) }).optional()
  })
});
function lu(e) {
  if (!Number.isSafeInteger(e) || e < 0)
    throw new Error(`Wrong positive integer: ${e}`);
}
function J2(e, ...t) {
  if (!(e instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (t.length > 0 && !t.includes(e.length))
    throw new Error(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
function ry(e, t = !0) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function X2(e, t) {
  J2(e);
  const r = t.outputLen;
  if (e.length < r)
    throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
const Qc = /* @__PURE__ */ BigInt(2 ** 32 - 1), i1 = /* @__PURE__ */ BigInt(32);
function s1(e, t = !1) {
  return t ? { h: Number(e & Qc), l: Number(e >> i1 & Qc) } : { h: Number(e >> i1 & Qc) | 0, l: Number(e & Qc) | 0 };
}
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const w3 = (e) => e instanceof Uint8Array, $3 = (e) => new Uint8Array(e.buffer, e.byteOffset, e.byteLength), tf = (e) => new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4)), rf = (e, t) => e << 32 - t | e >>> t, E3 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!E3)
  throw new Error("Non little-endian hardware is not supported");
function x3(e) {
  if (typeof e != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
  return new Uint8Array(new TextEncoder().encode(e));
}
function ug(e) {
  if (typeof e == "string" && (e = x3(e)), !w3(e))
    throw new Error(`expected Uint8Array, got ${typeof e}`);
  return e;
}
class O3 {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
}
function P3(e) {
  const t = (i, n) => e(n).update(ug(i)).digest(), r = e({});
  return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = (i) => e(i), t;
}
class S3 extends O3 {
  constructor(t, r, i = {}, n, s, a) {
    if (super(), this.blockLen = t, this.outputLen = r, this.length = 0, this.pos = 0, this.finished = !1, this.destroyed = !1, lu(t), lu(r), lu(n), r < 0 || r > n)
      throw new Error("outputLen bigger than keyLen");
    if (i.key !== void 0 && (i.key.length < 1 || i.key.length > n))
      throw new Error(`key must be up 1..${n} byte long or undefined`);
    if (i.salt !== void 0 && i.salt.length !== s)
      throw new Error(`salt must be ${s} byte long or undefined`);
    if (i.personalization !== void 0 && i.personalization.length !== a)
      throw new Error(`personalization must be ${a} byte long or undefined`);
    this.buffer32 = tf(this.buffer = new Uint8Array(t));
  }
  update(t) {
    ry(this);
    const { blockLen: r, buffer: i, buffer32: n } = this;
    t = ug(t);
    const s = t.length, a = t.byteOffset, u = t.buffer;
    for (let c = 0; c < s; ) {
      this.pos === r && (this.compress(n, 0, !1), this.pos = 0);
      const l = Math.min(r - this.pos, s - c), d = a + c;
      if (l === r && !(d % 4) && c + l < s) {
        const p = new Uint32Array(u, d, Math.floor((s - c) / 4));
        for (let h = 0; c + r < s; h += n.length, c += r)
          this.length += r, this.compress(p, h, !1);
        continue;
      }
      i.set(t.subarray(c, c + l), this.pos), this.pos += l, this.length += l, c += l;
    }
    return this;
  }
  digestInto(t) {
    ry(this), X2(t, this);
    const { pos: r, buffer32: i } = this;
    this.finished = !0, this.buffer.subarray(r).fill(0), this.compress(i, 0, !0);
    const n = tf(t);
    this.get().forEach((s, a) => n[a] = s);
  }
  digest() {
    const { buffer: t, outputLen: r } = this;
    this.digestInto(t);
    const i = t.slice(0, r);
    return this.destroy(), i;
  }
  _cloneInto(t) {
    const { buffer: r, length: i, finished: n, destroyed: s, outputLen: a, pos: u } = this;
    return t || (t = new this.constructor({ dkLen: a })), t.set(...this.get()), t.length = i, t.finished = n, t.destroyed = s, t.outputLen = a, t.buffer.set(r), t.pos = u, t;
  }
}
const vi = /* @__PURE__ */ new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]);
function Gi(e, t, r, i, n) {
  return e = e + t + n | 0, i = rf(i ^ e, 16), r = r + i | 0, t = rf(t ^ r, 12), { a: e, b: t, c: r, d: i };
}
function Ki(e, t, r, i, n) {
  return e = e + t + n | 0, i = rf(i ^ e, 8), r = r + i | 0, t = rf(t ^ r, 7), { a: e, b: t, c: r, d: i };
}
function a1(e, t, r, i, n, s, a, u, c, l, d, p, h, v, y, g, _, m, w, $) {
  let E = 0;
  for (let A = 0; A < i; A++)
    ({ a: n, b: c, c: h, d: _ } = Gi(n, c, h, _, r[t + e[E++]])), { a: n, b: c, c: h, d: _ } = Ki(n, c, h, _, r[t + e[E++]]), { a: s, b: l, c: v, d: m } = Gi(s, l, v, m, r[t + e[E++]]), { a: s, b: l, c: v, d: m } = Ki(s, l, v, m, r[t + e[E++]]), { a, b: d, c: y, d: w } = Gi(a, d, y, w, r[t + e[E++]]), { a, b: d, c: y, d: w } = Ki(a, d, y, w, r[t + e[E++]]), { a: u, b: p, c: g, d: $ } = Gi(u, p, g, $, r[t + e[E++]]), { a: u, b: p, c: g, d: $ } = Ki(u, p, g, $, r[t + e[E++]]), { a: n, b: l, c: y, d: $ } = Gi(n, l, y, $, r[t + e[E++]]), { a: n, b: l, c: y, d: $ } = Ki(n, l, y, $, r[t + e[E++]]), { a: s, b: d, c: g, d: _ } = Gi(s, d, g, _, r[t + e[E++]]), { a: s, b: d, c: g, d: _ } = Ki(s, d, g, _, r[t + e[E++]]), { a, b: p, c: h, d: m } = Gi(a, p, h, m, r[t + e[E++]]), { a, b: p, c: h, d: m } = Ki(a, p, h, m, r[t + e[E++]]), { a: u, b: c, c: v, d: w } = Gi(u, c, v, w, r[t + e[E++]]), { a: u, b: c, c: v, d: w } = Ki(u, c, v, w, r[t + e[E++]]);
  return { v0: n, v1: s, v2: a, v3: u, v4: c, v5: l, v6: d, v7: p, v8: h, v9: v, v10: y, v11: g, v12: _, v13: m, v14: w, v15: $ };
}
const o1 = /* @__PURE__ */ (() => {
  const e = Array.from({ length: 16 }, (i, n) => n), t = (i) => [2, 6, 3, 10, 7, 0, 4, 13, 1, 11, 12, 5, 9, 14, 15, 8].map((n) => i[n]), r = [];
  for (let i = 0, n = e; i < 7; i++, n = t(n))
    r.push(...n);
  return Uint8Array.from(r);
})();
class cg extends S3 {
  constructor(t = {}, r = 0) {
    if (super(64, t.dkLen === void 0 ? 32 : t.dkLen, {}, Number.MAX_SAFE_INTEGER, 0, 0), this.flags = 0, this.chunkPos = 0, this.chunksDone = 0, this.stack = [], this.posOut = 0, this.bufferOut32 = new Uint32Array(16), this.chunkOut = 0, this.enableXOF = !0, this.outputLen = t.dkLen === void 0 ? 32 : t.dkLen, lu(this.outputLen), t.key !== void 0 && t.context !== void 0)
      throw new Error("Blake3: only key or context can be specified at same time");
    if (t.key !== void 0) {
      const i = ug(t.key).slice();
      if (i.length !== 32)
        throw new Error("Blake3: key should be 32 byte");
      this.IV = tf(i), this.flags = r | 16;
    } else if (t.context !== void 0) {
      const i = new cg(
        { dkLen: 32 },
        32
        /* Flags.DERIVE_KEY_CONTEXT */
      ).update(t.context).digest();
      this.IV = tf(i), this.flags = r | 64;
    } else
      this.IV = vi.slice(), this.flags = r;
    this.state = this.IV.slice(), this.bufferOut = $3(this.bufferOut32);
  }
  // Unused
  get() {
    return [];
  }
  set() {
  }
  b2Compress(t, r, i, n = 0) {
    const { state: s, pos: a } = this, { h: u, l: c } = s1(BigInt(t), !0), { v0: l, v1: d, v2: p, v3: h, v4: v, v5: y, v6: g, v7: _, v8: m, v9: w, v10: $, v11: E, v12: A, v13: R, v14: I, v15: D } = a1(o1, n, i, 7, s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7], vi[0], vi[1], vi[2], vi[3], u, c, a, r);
    s[0] = l ^ m, s[1] = d ^ w, s[2] = p ^ $, s[3] = h ^ E, s[4] = v ^ A, s[5] = y ^ R, s[6] = g ^ I, s[7] = _ ^ D;
  }
  compress(t, r = 0, i = !1) {
    let n = this.flags;
    if (this.chunkPos || (n |= 1), (this.chunkPos === 15 || i) && (n |= 2), i || (this.pos = this.blockLen), this.b2Compress(this.chunksDone, n, t, r), this.chunkPos += 1, this.chunkPos === 16 || i) {
      let s = this.state;
      this.state = this.IV.slice();
      for (let a, u = this.chunksDone + 1; (i || !(u & 1)) && (a = this.stack.pop()); u >>= 1)
        this.buffer32.set(a, 0), this.buffer32.set(s, 8), this.pos = this.blockLen, this.b2Compress(0, this.flags | 4, this.buffer32, 0), s = this.state, this.state = this.IV.slice();
      this.chunksDone++, this.chunkPos = 0, this.stack.push(s);
    }
    this.pos = 0;
  }
  _cloneInto(t) {
    t = super._cloneInto(t);
    const { IV: r, flags: i, state: n, chunkPos: s, posOut: a, chunkOut: u, stack: c, chunksDone: l } = this;
    return t.state.set(n.slice()), t.stack = c.map((d) => Uint32Array.from(d)), t.IV.set(r), t.flags = i, t.chunkPos = s, t.chunksDone = l, t.posOut = a, t.chunkOut = u, t.enableXOF = this.enableXOF, t.bufferOut32.set(this.bufferOut32), t;
  }
  destroy() {
    this.destroyed = !0, this.state.fill(0), this.buffer32.fill(0), this.IV.fill(0), this.bufferOut32.fill(0);
    for (let t of this.stack)
      t.fill(0);
  }
  // Same as b2Compress, but doesn't modify state and returns 16 u32 array (instead of 8)
  b2CompressOut() {
    const { state: t, pos: r, flags: i, buffer32: n, bufferOut32: s } = this, { h: a, l: u } = s1(BigInt(this.chunkOut++)), { v0: c, v1: l, v2: d, v3: p, v4: h, v5: v, v6: y, v7: g, v8: _, v9: m, v10: w, v11: $, v12: E, v13: A, v14: R, v15: I } = a1(o1, 0, n, 7, t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], vi[0], vi[1], vi[2], vi[3], u, a, r, i);
    s[0] = c ^ _, s[1] = l ^ m, s[2] = d ^ w, s[3] = p ^ $, s[4] = h ^ E, s[5] = v ^ A, s[6] = y ^ R, s[7] = g ^ I, s[8] = t[0] ^ _, s[9] = t[1] ^ m, s[10] = t[2] ^ w, s[11] = t[3] ^ $, s[12] = t[4] ^ E, s[13] = t[5] ^ A, s[14] = t[6] ^ R, s[15] = t[7] ^ I, this.posOut = 0;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0, this.buffer.fill(0, this.pos);
    let t = this.flags | 8;
    this.stack.length ? (t |= 4, this.compress(this.buffer32, 0, !0), this.chunksDone = 0, this.pos = this.blockLen) : t |= (this.chunkPos ? 0 : 1) | 2, this.flags = t, this.b2CompressOut();
  }
  writeInto(t) {
    ry(this, !1), J2(t), this.finish();
    const { blockLen: r, bufferOut: i } = this;
    for (let n = 0, s = t.length; n < s; ) {
      this.posOut >= r && this.b2CompressOut();
      const a = Math.min(r - this.posOut, s - n);
      t.set(i.subarray(this.posOut, this.posOut + a), n), this.posOut += a, n += a;
    }
    return t;
  }
  xofInto(t) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible after digest call");
    return this.writeInto(t);
  }
  xof(t) {
    return lu(t), this.xofInto(new Uint8Array(t));
  }
  digestInto(t) {
    if (X2(t, this), this.finished)
      throw new Error("digest() was already called");
    return this.enableXOF = !1, this.writeInto(t), this.destroy(), t;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
}
const A3 = /* @__PURE__ */ P3((e) => new cg(e));
var rt = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function ta(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function kf(e) {
  if (e.__esModule)
    return e;
  var t = e.default;
  if (typeof t == "function") {
    var r = function i() {
      return this instanceof i ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    r.prototype = t.prototype;
  } else
    r = {};
  return Object.defineProperty(r, "__esModule", { value: !0 }), Object.keys(e).forEach(function(i) {
    var n = Object.getOwnPropertyDescriptor(e, i);
    Object.defineProperty(r, i, n.get ? n : {
      enumerable: !0,
      get: function() {
        return e[i];
      }
    });
  }), r;
}
var ny = { exports: {} };
function Q2(e) {
  return e.length;
}
function C3(e) {
  const t = e.byteLength;
  let r = "";
  for (let i = 0; i < t; i++)
    r += String.fromCharCode(e[i]);
  return r;
}
function R3(e, t, r = 0, i = Q2(t)) {
  const n = Math.min(i, e.byteLength - r);
  for (let s = 0; s < n; s++)
    e[r + s] = t.charCodeAt(s);
  return n;
}
var T3 = {
  byteLength: Q2,
  toString: C3,
  write: R3
};
const Ua = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", Vs = new Uint8Array(256);
for (let e = 0; e < Ua.length; e++)
  Vs[Ua.charCodeAt(e)] = e;
Vs[
  /* - */
  45
] = 62;
Vs[
  /* _ */
  95
] = 63;
function eE(e) {
  let t = e.length;
  return e.charCodeAt(t - 1) === 61 && t--, t > 1 && e.charCodeAt(t - 1) === 61 && t--, t * 3 >>> 2;
}
function I3(e) {
  const t = e.byteLength;
  let r = "";
  for (let i = 0; i < t; i += 3)
    r += Ua[e[i] >> 2] + Ua[(e[i] & 3) << 4 | e[i + 1] >> 4] + Ua[(e[i + 1] & 15) << 2 | e[i + 2] >> 6] + Ua[e[i + 2] & 63];
  return t % 3 === 2 ? r = r.substring(0, r.length - 1) + "=" : t % 3 === 1 && (r = r.substring(0, r.length - 2) + "=="), r;
}
function j3(e, t, r = 0, i = eE(t)) {
  const n = Math.min(i, e.byteLength - r);
  for (let s = 0, a = 0; a < n; s += 4) {
    const u = Vs[t.charCodeAt(s)], c = Vs[t.charCodeAt(s + 1)], l = Vs[t.charCodeAt(s + 2)], d = Vs[t.charCodeAt(s + 3)];
    e[a++] = u << 2 | c >> 4, e[a++] = (c & 15) << 4 | l >> 2, e[a++] = (l & 3) << 6 | d & 63;
  }
  return n;
}
var k3 = {
  byteLength: eE,
  toString: I3,
  write: j3
};
function tE(e) {
  return e.length >>> 1;
}
function M3(e) {
  const t = e.byteLength;
  e = new DataView(e.buffer, e.byteOffset, t);
  let r = "", i = 0;
  for (let n = t - t % 4; i < n; i += 4)
    r += e.getUint32(i).toString(16).padStart(8, "0");
  for (; i < t; i++)
    r += e.getUint8(i).toString(16).padStart(2, "0");
  return r;
}
function N3(e, t, r = 0, i = tE(t)) {
  const n = Math.min(i, e.byteLength - r);
  for (let s = 0; s < n; s++) {
    const a = u1(t.charCodeAt(s * 2)), u = u1(t.charCodeAt(s * 2 + 1));
    if (a === void 0 || u === void 0)
      return e.subarray(0, s);
    e[r + s] = a << 4 | u;
  }
  return n;
}
var D3 = {
  byteLength: tE,
  toString: M3,
  write: N3
};
function u1(e) {
  if (e >= 48 && e <= 57)
    return e - 48;
  if (e >= 65 && e <= 70)
    return e - 65 + 10;
  if (e >= 97 && e <= 102)
    return e - 97 + 10;
}
function iy(e) {
  let t = 0;
  for (let r = 0, i = e.length; r < i; r++) {
    const n = e.charCodeAt(r);
    if (n >= 55296 && n <= 56319 && r + 1 < i) {
      const s = e.charCodeAt(r + 1);
      if (s >= 56320 && s <= 57343) {
        t += 4, r++;
        continue;
      }
    }
    n <= 127 ? t += 1 : n <= 2047 ? t += 2 : t += 3;
  }
  return t;
}
let sy;
if (typeof TextDecoder < "u") {
  const e = new TextDecoder();
  sy = function(r) {
    return e.decode(r);
  };
} else
  sy = function(t) {
    const r = t.byteLength;
    let i = "", n = 0;
    for (; n < r; ) {
      let s = t[n];
      if (s <= 127) {
        i += String.fromCharCode(s), n++;
        continue;
      }
      let a = 0, u = 0;
      if (s <= 223 ? (a = 1, u = s & 31) : s <= 239 ? (a = 2, u = s & 15) : s <= 244 && (a = 3, u = s & 7), r - n - a > 0) {
        let c = 0;
        for (; c < a; )
          s = t[n + c + 1], u = u << 6 | s & 63, c += 1;
      } else
        u = 65533, a = r - n;
      i += String.fromCodePoint(u), n += a + 1;
    }
    return i;
  };
let ay;
if (typeof TextEncoder < "u") {
  const e = new TextEncoder();
  ay = function(r, i, n = 0, s = iy(i)) {
    const a = Math.min(s, r.byteLength - n);
    return e.encodeInto(i, r.subarray(n, n + a)), a;
  };
} else
  ay = function(t, r, i = 0, n = iy(r)) {
    const s = Math.min(n, t.byteLength - i);
    t = t.subarray(i, i + s);
    let a = 0, u = 0;
    for (; a < r.length; ) {
      const c = r.codePointAt(a);
      if (c <= 127) {
        t[u++] = c, a++;
        continue;
      }
      let l = 0, d = 0;
      for (c <= 2047 ? (l = 6, d = 192) : c <= 65535 ? (l = 12, d = 224) : c <= 2097151 && (l = 18, d = 240), t[u++] = d | c >> l, l -= 6; l >= 0; )
        t[u++] = 128 | c >> l & 63, l -= 6;
      a += c >= 65536 ? 2 : 1;
    }
    return s;
  };
var L3 = {
  byteLength: iy,
  toString: sy,
  write: ay
};
function rE(e) {
  return e.length * 2;
}
function q3(e) {
  const t = e.byteLength;
  let r = "";
  for (let i = 0; i < t - 1; i += 2)
    r += String.fromCharCode(e[i] + e[i + 1] * 256);
  return r;
}
function F3(e, t, r = 0, i = rE(t)) {
  const n = Math.min(i, e.byteLength - r);
  let s = n;
  for (let a = 0; a < t.length && !((s -= 2) < 0); ++a) {
    const u = t.charCodeAt(a), c = u >> 8, l = u % 256;
    e[r + a * 2] = l, e[r + a * 2 + 1] = c;
  }
  return n;
}
var U3 = {
  byteLength: rE,
  toString: q3,
  write: F3
};
(function(e, t) {
  const r = T3, i = k3, n = D3, s = L3, a = U3, u = new Uint8Array(Uint16Array.of(255).buffer)[0] === 255;
  function c(T) {
    switch (T) {
      case "ascii":
        return r;
      case "base64":
        return i;
      case "hex":
        return n;
      case "utf8":
      case "utf-8":
      case void 0:
        return s;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return a;
      default:
        throw new Error(`Unknown encoding: ${T}`);
    }
  }
  function l(T) {
    return T instanceof Uint8Array;
  }
  function d(T) {
    try {
      return c(T), !0;
    } catch {
      return !1;
    }
  }
  function p(T, Z, Y) {
    const k = new Uint8Array(T);
    return Z !== void 0 && t.fill(k, Z, 0, k.byteLength, Y), k;
  }
  function h(T) {
    return new Uint8Array(T);
  }
  function v(T) {
    return new Uint8Array(T);
  }
  function y(T, Z) {
    return c(Z).byteLength(T);
  }
  function g(T, Z) {
    if (T === Z)
      return 0;
    const Y = Math.min(T.byteLength, Z.byteLength);
    T = new DataView(T.buffer, T.byteOffset, T.byteLength), Z = new DataView(Z.buffer, Z.byteOffset, Z.byteLength);
    let k = 0;
    for (let U = Y - Y % 4; k < U; k += 4) {
      const pe = T.getUint32(k, u), we = Z.getUint32(k, u);
      if (pe !== we)
        break;
    }
    for (; k < Y; k++) {
      const U = T.getUint8(k), pe = Z.getUint8(k);
      if (U < pe)
        return -1;
      if (U > pe)
        return 1;
    }
    return T.byteLength > Z.byteLength ? 1 : T.byteLength < Z.byteLength ? -1 : 0;
  }
  function _(T, Z) {
    Z === void 0 && (Z = T.reduce((U, pe) => U + pe.byteLength, 0));
    const Y = new Uint8Array(Z);
    let k = 0;
    for (const U of T) {
      if (k + U.byteLength > Y.byteLength) {
        const pe = U.subarray(0, Y.byteLength - k);
        return Y.set(pe, k), Y;
      }
      Y.set(U, k), k += U.byteLength;
    }
    return Y;
  }
  function m(T, Z, Y = 0, k = 0, U = T.byteLength) {
    if (U > 0 && U < k || U === k || T.byteLength === 0 || Z.byteLength === 0)
      return 0;
    if (Y < 0)
      throw new RangeError("targetStart is out of range");
    if (k < 0 || k >= T.byteLength)
      throw new RangeError("sourceStart is out of range");
    if (U < 0)
      throw new RangeError("sourceEnd is out of range");
    Y >= Z.byteLength && (Y = Z.byteLength), U > T.byteLength && (U = T.byteLength), Z.byteLength - Y < U - k && (U = Z.length - Y + k);
    const pe = U - k;
    return T === Z ? Z.copyWithin(Y, k, U) : Z.set(T.subarray(k, U), Y), pe;
  }
  function w(T, Z) {
    if (T === Z)
      return !0;
    if (T.byteLength !== Z.byteLength)
      return !1;
    const Y = T.byteLength;
    T = new DataView(T.buffer, T.byteOffset, T.byteLength), Z = new DataView(Z.buffer, Z.byteOffset, Z.byteLength);
    let k = 0;
    for (let U = Y - Y % 4; k < U; k += 4)
      if (T.getUint32(k, u) !== Z.getUint32(k, u))
        return !1;
    for (; k < Y; k++)
      if (T.getUint8(k) !== Z.getUint8(k))
        return !1;
    return !0;
  }
  function $(T, Z, Y, k, U) {
    if (typeof Z == "string" ? typeof Y == "string" ? (U = Y, Y = 0, k = T.byteLength) : typeof k == "string" && (U = k, k = T.byteLength) : typeof Z == "number" ? Z = Z & 255 : typeof Z == "boolean" && (Z = +Z), Y < 0 || T.byteLength < Y || T.byteLength < k)
      throw new RangeError("Out of range index");
    if (Y === void 0 && (Y = 0), k === void 0 && (k = T.byteLength), k <= Y)
      return T;
    if (Z || (Z = 0), typeof Z == "number")
      for (let pe = Y; pe < k; ++pe)
        T[pe] = Z;
    else {
      Z = l(Z) ? Z : E(Z, U);
      const pe = Z.byteLength;
      for (let we = 0; we < k - Y; ++we)
        T[we + Y] = Z[we % pe];
    }
    return T;
  }
  function E(T, Z, Y) {
    return typeof T == "string" ? A(T, Z) : Array.isArray(T) ? R(T) : ArrayBuffer.isView(T) ? I(T) : D(T, Z, Y);
  }
  function A(T, Z) {
    const Y = c(Z), k = new Uint8Array(Y.byteLength(T));
    return Y.write(k, T, 0, k.byteLength), k;
  }
  function R(T) {
    const Z = new Uint8Array(T.length);
    return Z.set(T), Z;
  }
  function I(T) {
    const Z = new Uint8Array(T.byteLength);
    return Z.set(T), Z;
  }
  function D(T, Z, Y) {
    return new Uint8Array(T, Z, Y);
  }
  function J(T, Z, Y, k) {
    return ye(T, Z, Y, k) !== -1;
  }
  function ae(T, Z, Y, k, U) {
    if (T.byteLength === 0)
      return -1;
    if (typeof Y == "string" ? (k = Y, Y = 0) : Y === void 0 ? Y = U ? 0 : T.length - 1 : Y < 0 && (Y += T.byteLength), Y >= T.byteLength) {
      if (U)
        return -1;
      Y = T.byteLength - 1;
    } else if (Y < 0)
      if (U)
        Y = 0;
      else
        return -1;
    if (typeof Z == "string")
      Z = E(Z, k);
    else if (typeof Z == "number")
      return Z = Z & 255, U ? T.indexOf(Z, Y) : T.lastIndexOf(Z, Y);
    if (Z.byteLength === 0)
      return -1;
    if (U) {
      let pe = -1;
      for (let we = Y; we < T.byteLength; we++)
        if (T[we] === Z[pe === -1 ? 0 : we - pe]) {
          if (pe === -1 && (pe = we), we - pe + 1 === Z.byteLength)
            return pe;
        } else
          pe !== -1 && (we -= we - pe), pe = -1;
    } else {
      Y + Z.byteLength > T.byteLength && (Y = T.byteLength - Z.byteLength);
      for (let pe = Y; pe >= 0; pe--) {
        let we = !0;
        for (let He = 0; He < Z.byteLength; He++)
          if (T[pe + He] !== Z[He]) {
            we = !1;
            break;
          }
        if (we)
          return pe;
      }
    }
    return -1;
  }
  function ye(T, Z, Y, k) {
    return ae(
      T,
      Z,
      Y,
      k,
      !0
      /* first */
    );
  }
  function xe(T, Z, Y, k) {
    return ae(
      T,
      Z,
      Y,
      k,
      !1
      /* last */
    );
  }
  function je(T, Z, Y) {
    const k = T[Z];
    T[Z] = T[Y], T[Y] = k;
  }
  function re(T) {
    const Z = T.byteLength;
    if (Z % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let Y = 0; Y < Z; Y += 2)
      je(T, Y, Y + 1);
    return T;
  }
  function fe(T) {
    const Z = T.byteLength;
    if (Z % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let Y = 0; Y < Z; Y += 4)
      je(T, Y, Y + 3), je(T, Y + 1, Y + 2);
    return T;
  }
  function le(T) {
    const Z = T.byteLength;
    if (Z % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let Y = 0; Y < Z; Y += 8)
      je(T, Y, Y + 7), je(T, Y + 1, Y + 6), je(T, Y + 2, Y + 5), je(T, Y + 3, Y + 4);
    return T;
  }
  function $e(T) {
    return T;
  }
  function Ae(T, Z, Y = 0, k = T.byteLength) {
    const U = T.byteLength;
    return Y >= U || k <= Y ? "" : (Y < 0 && (Y = 0), k > U && (k = U), (Y !== 0 || k < U) && (T = T.subarray(Y, k)), c(Z).toString(T));
  }
  function _e(T, Z, Y, k, U) {
    return Y === void 0 ? U = "utf8" : k === void 0 && typeof Y == "string" ? (U = Y, Y = void 0) : U === void 0 && typeof k == "string" && (U = k, k = void 0), c(U).write(T, Z, Y, k);
  }
  function ie(T, Z, Y) {
    return Y === void 0 && (Y = 0), new DataView(T.buffer, T.byteOffset, T.byteLength).setFloat64(Y, Z, !0), Y + 8;
  }
  function K(T, Z, Y) {
    return Y === void 0 && (Y = 0), new DataView(T.buffer, T.byteOffset, T.byteLength).setFloat32(Y, Z, !0), Y + 4;
  }
  function V(T, Z, Y) {
    return Y === void 0 && (Y = 0), new DataView(T.buffer, T.byteOffset, T.byteLength).setUint32(Y, Z, !0), Y + 4;
  }
  function z(T, Z, Y) {
    return Y === void 0 && (Y = 0), new DataView(T.buffer, T.byteOffset, T.byteLength).setInt32(Y, Z, !0), Y + 4;
  }
  function C(T, Z) {
    return Z === void 0 && (Z = 0), new DataView(T.buffer, T.byteOffset, T.byteLength).getFloat64(Z, !0);
  }
  function q(T, Z) {
    return Z === void 0 && (Z = 0), new DataView(T.buffer, T.byteOffset, T.byteLength).getFloat32(Z, !0);
  }
  function N(T, Z) {
    return Z === void 0 && (Z = 0), new DataView(T.buffer, T.byteOffset, T.byteLength).getUint32(Z, !0);
  }
  function F(T, Z) {
    return Z === void 0 && (Z = 0), new DataView(T.buffer, T.byteOffset, T.byteLength).getInt32(Z, !0);
  }
  e.exports = t = {
    isBuffer: l,
    isEncoding: d,
    alloc: p,
    allocUnsafe: h,
    allocUnsafeSlow: v,
    byteLength: y,
    compare: g,
    concat: _,
    copy: m,
    equals: w,
    fill: $,
    from: E,
    includes: J,
    indexOf: ye,
    lastIndexOf: xe,
    swap16: re,
    swap32: fe,
    swap64: le,
    toBuffer: $e,
    toString: Ae,
    write: _e,
    writeDoubleLE: ie,
    writeFloatLE: K,
    writeUInt32LE: V,
    writeInt32LE: z,
    readDoubleLE: C,
    readFloatLE: q,
    readUInt32LE: N,
    readInt32LE: F
  };
})(ny, ny.exports);
var B3 = ny.exports;
const yn = /* @__PURE__ */ ta(B3);
/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
const lg = 2n ** 256n, as = lg - 0x1000003d1n, fr = lg - 0x14551231950b75fc4402da1732fc9bebfn, nE = 0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798n, iE = 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8n, sE = { p: as, n: fr, a: 0n, b: 7n, Gx: nE, Gy: iE }, Sr = 32, c1 = (e) => Be(Be(e * e) * e + sE.b), Bt = (e = "") => {
  throw new Error(e);
}, Mf = (e) => typeof e == "bigint", aE = (e) => typeof e == "string", Ap = (e) => Mf(e) && 0n < e && e < as, ju = (e) => Mf(e) && 0n < e && e < fr, oE = (e, t) => (
  // is Uint8Array (of specific length)
  !(e instanceof Uint8Array) || typeof t == "number" && t > 0 && e.length !== t ? Bt("Uint8Array expected") : e
), tn = (e) => new Uint8Array(e), Ci = (e, t) => oE(aE(e) ? Hu(e) : tn(e), t), Be = (e, t = as) => {
  let r = e % t;
  return r >= 0n ? r : t + r;
}, l1 = (e) => e instanceof Pr ? e : Bt("Point expected");
let f1;
class Pr {
  constructor(t, r, i) {
    this.px = t, this.py = r, this.pz = i;
  }
  //3d=less inversions
  static fromAffine(t) {
    return new Pr(t.x, t.y, 1n);
  }
  static fromHex(t) {
    t = Ci(t);
    let r;
    const i = t[0], n = t.subarray(1), s = nf(n, 0, Sr), a = t.length;
    if (a === 33 && [2, 3].includes(i)) {
      Ap(s) || Bt("Point hex invalid: x not FE");
      let u = V3(c1(s));
      const c = (u & 1n) === 1n;
      (i & 1) === 1 !== c && (u = Be(-u)), r = new Pr(s, u, 1n);
    }
    return a === 65 && i === 4 && (r = new Pr(s, nf(n, Sr, 2 * Sr), 1n)), r ? r.ok() : Bt("Point is not on curve");
  }
  static fromPrivateKey(t) {
    return xi.mul(sf(t));
  }
  // Create point from a private key.
  get x() {
    return this.aff().x;
  }
  // .x, .y will call expensive toAffine:
  get y() {
    return this.aff().y;
  }
  // should be used with care.
  equals(t) {
    const { px: r, py: i, pz: n } = this, { px: s, py: a, pz: u } = l1(t), c = Be(r * u), l = Be(s * n), d = Be(i * u), p = Be(a * n);
    return c === l && d === p;
  }
  negate() {
    return new Pr(this.px, Be(-this.py), this.pz);
  }
  // Flip point over y coord
  double() {
    return this.add(this);
  }
  // Point doubling: P+P, complete formula.
  add(t) {
    const { px: r, py: i, pz: n } = this, { px: s, py: a, pz: u } = l1(t), { a: c, b: l } = sE;
    let d = 0n, p = 0n, h = 0n;
    const v = Be(l * 3n);
    let y = Be(r * s), g = Be(i * a), _ = Be(n * u), m = Be(r + i), w = Be(s + a);
    m = Be(m * w), w = Be(y + g), m = Be(m - w), w = Be(r + n);
    let $ = Be(s + u);
    return w = Be(w * $), $ = Be(y + _), w = Be(w - $), $ = Be(i + n), d = Be(a + u), $ = Be($ * d), d = Be(g + _), $ = Be($ - d), h = Be(c * w), d = Be(v * _), h = Be(d + h), d = Be(g - h), h = Be(g + h), p = Be(d * h), g = Be(y + y), g = Be(g + y), _ = Be(c * _), w = Be(v * w), g = Be(g + _), _ = Be(y - _), _ = Be(c * _), w = Be(w + _), y = Be(g * w), p = Be(p + y), y = Be($ * w), d = Be(m * d), d = Be(d - y), y = Be(m * g), h = Be($ * h), h = Be(h + y), new Pr(d, p, h);
  }
  mul(t, r = !0) {
    if (!r && t === 0n)
      return xl;
    if (ju(t) || Bt("invalid scalar"), this.equals(xi))
      return J3(t).p;
    let i = xl, n = xi;
    for (let s = this; t > 0n; s = s.double(), t >>= 1n)
      t & 1n ? i = i.add(s) : r && (n = n.add(s));
    return i;
  }
  mulAddQUns(t, r, i) {
    return this.mul(r, !1).add(t.mul(i, !1)).ok();
  }
  // to private keys. Doesn't use Shamir trick
  toAffine() {
    const { px: t, py: r, pz: i } = this;
    if (this.equals(xl))
      return { x: 0n, y: 0n };
    if (i === 1n)
      return { x: t, y: r };
    const n = Ku(i);
    return Be(i * n) !== 1n && Bt("invalid inverse"), { x: Be(t * n), y: Be(r * n) };
  }
  assertValidity() {
    const { x: t, y: r } = this.aff();
    return (!Ap(t) || !Ap(r)) && Bt("Point invalid: x or y"), Be(r * r) === c1(t) ? (
      // y² = x³ + ax + b, must be equal
      this
    ) : Bt("Point invalid: not on curve");
  }
  multiply(t) {
    return this.mul(t);
  }
  // Aliases to compress code
  aff() {
    return this.toAffine();
  }
  ok() {
    return this.assertValidity();
  }
  toHex(t = !0) {
    const { x: r, y: i } = this.aff();
    return (t ? (i & 1n) === 0n ? "02" : "03" : "04") + fu(r) + (t ? "" : fu(i));
  }
  toRawBytes(t = !0) {
    return Hu(this.toHex(t));
  }
}
Pr.BASE = new Pr(nE, iE, 1n);
Pr.ZERO = new Pr(0n, 1n, 0n);
const { BASE: xi, ZERO: xl } = Pr, uE = (e, t) => e.toString(16).padStart(t, "0"), fg = (e) => Array.from(e).map((t) => uE(t, 2)).join(""), Hu = (e) => {
  const t = e.length;
  (!aE(e) || t % 2) && Bt("hex invalid 1");
  const r = tn(t / 2);
  for (let i = 0; i < r.length; i++) {
    const n = i * 2, s = e.slice(n, n + 2), a = Number.parseInt(s, 16);
    (Number.isNaN(a) || a < 0) && Bt("hex invalid 2"), r[i] = a;
  }
  return r;
}, Gu = (e) => BigInt("0x" + (fg(e) || "0")), nf = (e, t, r) => Gu(e.slice(t, r)), Nf = (e) => Mf(e) && e >= 0n && e < lg ? Hu(uE(e, 2 * Sr)) : Bt("bigint expected"), fu = (e) => fg(Nf(e)), oy = (...e) => {
  const t = tn(e.reduce((i, n) => i + oE(n).length, 0));
  let r = 0;
  return e.forEach((i) => {
    t.set(i, r), r += i.length;
  }), t;
}, Ku = (e, t = as) => {
  (e === 0n || t <= 0n) && Bt("no inverse n=" + e + " mod=" + t);
  let r = Be(e, t), i = t, n = 0n, s = 1n;
  for (; r !== 0n; ) {
    const a = i / r, u = i % r, c = n - s * a;
    i = r, r = u, n = s, s = c;
  }
  return i === 1n ? Be(n, t) : Bt("no inverse");
}, V3 = (e) => {
  let t = 1n;
  for (let r = e, i = (as + 1n) / 4n; i > 0n; i >>= 1n)
    i & 1n && (t = t * r % as), r = r * r % as;
  return Be(t * t) === e ? t : Bt("sqrt invalid");
}, sf = (e) => (Mf(e) || (e = Gu(Ci(e, Sr))), ju(e) ? e : Bt("private key out of range")), dg = (e) => e > fr >> 1n;
function cE(e, t = !0) {
  return Pr.fromPrivateKey(e).toRawBytes(t);
}
class no {
  constructor(t, r, i) {
    this.r = t, this.s = r, this.recovery = i, this.assertValidity();
  }
  // constructed outside.
  static fromCompact(t) {
    return t = Ci(t, 64), new no(nf(t, 0, Sr), nf(t, Sr, 2 * Sr));
  }
  assertValidity() {
    return ju(this.r) && ju(this.s) ? this : Bt();
  }
  // 0 < r or s < CURVE.n
  addRecoveryBit(t) {
    return new no(this.r, this.s, t);
  }
  hasHighS() {
    return dg(this.s);
  }
  recoverPublicKey(t) {
    const { r, s: i, recovery: n } = this;
    [0, 1, 2, 3].includes(n) || Bt("recovery id invalid");
    const s = pg(Ci(t, 32)), a = n === 2 || n === 3 ? r + fr : r;
    a >= as && Bt("q.x invalid");
    const u = n & 1 ? "03" : "02", c = Pr.fromHex(u + fu(a)), l = Ku(a, fr), d = Be(-s * l, fr), p = Be(i * l, fr);
    return xi.mulAddQUns(c, d, p);
  }
  toCompactRawBytes() {
    return Hu(this.toCompactHex());
  }
  // Uint8Array 64b compact repr
  toCompactHex() {
    return fu(this.r) + fu(this.s);
  }
  // hex 64b compact repr
}
const lE = (e) => {
  const t = e.length * 8 - 256, r = Gu(e);
  return t > 0 ? r >> BigInt(t) : r;
}, pg = (e) => Be(lE(e), fr), d1 = (e) => Nf(e), p1 = () => (
  // We support: 1) browsers 2) node.js 19+ 3) deno, other envs with crypto
  typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0
);
let du;
const fE = { lowS: !0 }, Z3 = { lowS: !0 };
function z3(e, t, r = fE) {
  ["der", "recovered", "canonical"].some((p) => p in r) && Bt("sign() legacy options not supported");
  let { lowS: i } = r;
  i == null && (i = !0);
  const n = pg(Ci(e)), s = d1(n), a = sf(t), u = [d1(a), s];
  let c = r.extraEntropy;
  if (c) {
    c === !0 && (c = Df.randomBytes(Sr));
    const p = Ci(c);
    p.length !== Sr && Bt(), u.push(p);
  }
  const l = n, d = (p) => {
    const h = lE(p);
    if (!ju(h))
      return;
    const v = Ku(h, fr), y = xi.mul(h).aff(), g = Be(y.x, fr);
    if (g === 0n)
      return;
    const _ = Be(v * Be(l + Be(a * g, fr), fr), fr);
    if (_ === 0n)
      return;
    let m = _, w = (y.x === g ? 0 : 2) | Number(y.y & 1n);
    return i && dg(_) && (m = Be(-_, fr), w ^= 1), new no(g, m, w);
  };
  return { seed: oy(...u), k2sig: d };
}
function W3(e) {
  let t = tn(Sr), r = tn(Sr), i = 0;
  const n = () => {
    t.fill(1), r.fill(0), i = 0;
  }, s = "drbg: tried 1000 values";
  if (e) {
    const a = (...l) => Df.hmacSha256Async(r, t, ...l), u = async (l = tn()) => {
      r = await a(tn([0]), l), t = await a(), l.length !== 0 && (r = await a(tn([1]), l), t = await a());
    }, c = async () => (i++ >= 1e3 && Bt(s), t = await a(), t);
    return async (l, d) => {
      n(), await u(l);
      let p;
      for (; !(p = d(await c())); )
        await u();
      return n(), p;
    };
  } else {
    const a = (...l) => {
      const d = du;
      return d || Bt("etc.hmacSha256Sync not set"), d(r, t, ...l);
    }, u = (l = tn()) => {
      r = a(tn([0]), l), t = a(), l.length !== 0 && (r = a(tn([1]), l), t = a());
    }, c = () => (i++ >= 1e3 && Bt(s), t = a(), t);
    return (l, d) => {
      n(), u(l);
      let p;
      for (; !(p = d(c())); )
        u();
      return n(), p;
    };
  }
}
async function H3(e, t, r = fE) {
  const { seed: i, k2sig: n } = z3(e, t, r);
  return W3(!0)(i, n);
}
function G3(e, t, r, i = Z3) {
  let { lowS: n } = i;
  n == null && (n = !0), "strict" in i && Bt("verify() legacy options not supported");
  let s, a, u;
  const c = e && typeof e == "object" && "r" in e;
  !c && Ci(e).length !== 2 * Sr && Bt("signature must be 64 bytes");
  try {
    s = c ? new no(e.r, e.s).assertValidity() : no.fromCompact(e), a = pg(Ci(t, Sr)), u = r instanceof Pr ? r.ok() : Pr.fromHex(r);
  } catch {
    return !1;
  }
  if (!s)
    return !1;
  const { r: l, s: d } = s;
  if (n && dg(d))
    return !1;
  let p;
  try {
    const v = Ku(d, fr), y = Be(a * v, fr), g = Be(l * v, fr);
    p = xi.mulAddQUns(u, y, g).aff();
  } catch {
    return !1;
  }
  return p ? Be(p.x, fr) === l : !1;
}
function dE(e) {
  e = Ci(e);
  const t = Sr + 8;
  (e.length < t || e.length > 1024) && Bt("expected proper params");
  const r = Be(Gu(e), fr - 1n) + 1n;
  return Nf(r);
}
const Df = {
  hexToBytes: Hu,
  bytesToHex: fg,
  concatBytes: oy,
  bytesToNumberBE: Gu,
  numberToBytesBE: Nf,
  mod: Be,
  invert: Ku,
  hmacSha256Async: async (e, ...t) => {
    const r = p1();
    if (!r)
      return Bt("etc.hmacSha256Async not set");
    const i = r.subtle, n = await i.importKey("raw", e, { name: "HMAC", hash: { name: "SHA-256" } }, !1, ["sign"]);
    return tn(await i.sign("HMAC", n, oy(...t)));
  },
  hmacSha256Sync: du,
  hashToPrivateKey: dE,
  randomBytes: (e) => {
    const t = p1();
    return t || Bt("crypto.getRandomValues must be defined"), t.getRandomValues(tn(e));
  }
}, K3 = {
  normPrivateKeyToScalar: sf,
  isValidPrivateKey: (e) => {
    try {
      return !!sf(e);
    } catch {
      return !1;
    }
  },
  randomPrivateKey: () => dE(Df.randomBytes(Sr + 8)),
  precompute(e = 8, t = xi) {
    return t.multiply(3n), t;
  }
  // no-op
};
Object.defineProperties(Df, { hmacSha256Sync: {
  configurable: !1,
  get() {
    return du;
  },
  set(e) {
    du || (du = e);
  }
} });
const Ds = 8, Y3 = () => {
  const e = [], t = 256 / Ds + 1;
  let r = xi, i = r;
  for (let n = 0; n < t; n++) {
    i = r, e.push(i);
    for (let s = 1; s < 2 ** (Ds - 1); s++)
      i = i.add(r), e.push(i);
    r = i.double();
  }
  return e;
}, J3 = (e) => {
  const t = f1 || (f1 = Y3()), r = (d, p) => {
    let h = p.negate();
    return d ? h : p;
  };
  let i = xl, n = xi;
  const s = 1 + 256 / Ds, a = 2 ** (Ds - 1), u = BigInt(2 ** Ds - 1), c = 2 ** Ds, l = BigInt(Ds);
  for (let d = 0; d < s; d++) {
    const p = d * a;
    let h = Number(e & u);
    e >>= l, h > a && (h -= c, e += 1n);
    const v = p, y = p + Math.abs(h) - 1, g = d % 2 !== 0, _ = h < 0;
    h === 0 ? n = n.add(r(g, t[v])) : i = i.add(r(_, t[y]));
  }
  return { p: i, f: n };
};
var Me = {}, lo = {}, Lf = {};
Lf.byteLength = eM;
Lf.toByteArray = rM;
Lf.fromByteArray = sM;
var Kn = [], pn = [], X3 = typeof Uint8Array < "u" ? Uint8Array : Array, Cp = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var Sa = 0, Q3 = Cp.length; Sa < Q3; ++Sa)
  Kn[Sa] = Cp[Sa], pn[Cp.charCodeAt(Sa)] = Sa;
pn["-".charCodeAt(0)] = 62;
pn["_".charCodeAt(0)] = 63;
function pE(e) {
  var t = e.length;
  if (t % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var r = e.indexOf("=");
  r === -1 && (r = t);
  var i = r === t ? 0 : 4 - r % 4;
  return [r, i];
}
function eM(e) {
  var t = pE(e), r = t[0], i = t[1];
  return (r + i) * 3 / 4 - i;
}
function tM(e, t, r) {
  return (t + r) * 3 / 4 - r;
}
function rM(e) {
  var t, r = pE(e), i = r[0], n = r[1], s = new X3(tM(e, i, n)), a = 0, u = n > 0 ? i - 4 : i, c;
  for (c = 0; c < u; c += 4)
    t = pn[e.charCodeAt(c)] << 18 | pn[e.charCodeAt(c + 1)] << 12 | pn[e.charCodeAt(c + 2)] << 6 | pn[e.charCodeAt(c + 3)], s[a++] = t >> 16 & 255, s[a++] = t >> 8 & 255, s[a++] = t & 255;
  return n === 2 && (t = pn[e.charCodeAt(c)] << 2 | pn[e.charCodeAt(c + 1)] >> 4, s[a++] = t & 255), n === 1 && (t = pn[e.charCodeAt(c)] << 10 | pn[e.charCodeAt(c + 1)] << 4 | pn[e.charCodeAt(c + 2)] >> 2, s[a++] = t >> 8 & 255, s[a++] = t & 255), s;
}
function nM(e) {
  return Kn[e >> 18 & 63] + Kn[e >> 12 & 63] + Kn[e >> 6 & 63] + Kn[e & 63];
}
function iM(e, t, r) {
  for (var i, n = [], s = t; s < r; s += 3)
    i = (e[s] << 16 & 16711680) + (e[s + 1] << 8 & 65280) + (e[s + 2] & 255), n.push(nM(i));
  return n.join("");
}
function sM(e) {
  for (var t, r = e.length, i = r % 3, n = [], s = 16383, a = 0, u = r - i; a < u; a += s)
    n.push(iM(e, a, a + s > u ? u : a + s));
  return i === 1 ? (t = e[r - 1], n.push(
    Kn[t >> 2] + Kn[t << 4 & 63] + "=="
  )) : i === 2 && (t = (e[r - 2] << 8) + e[r - 1], n.push(
    Kn[t >> 10] + Kn[t >> 4 & 63] + Kn[t << 2 & 63] + "="
  )), n.join("");
}
var hg = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
hg.read = function(e, t, r, i, n) {
  var s, a, u = n * 8 - i - 1, c = (1 << u) - 1, l = c >> 1, d = -7, p = r ? n - 1 : 0, h = r ? -1 : 1, v = e[t + p];
  for (p += h, s = v & (1 << -d) - 1, v >>= -d, d += u; d > 0; s = s * 256 + e[t + p], p += h, d -= 8)
    ;
  for (a = s & (1 << -d) - 1, s >>= -d, d += i; d > 0; a = a * 256 + e[t + p], p += h, d -= 8)
    ;
  if (s === 0)
    s = 1 - l;
  else {
    if (s === c)
      return a ? NaN : (v ? -1 : 1) * (1 / 0);
    a = a + Math.pow(2, i), s = s - l;
  }
  return (v ? -1 : 1) * a * Math.pow(2, s - i);
};
hg.write = function(e, t, r, i, n, s) {
  var a, u, c, l = s * 8 - n - 1, d = (1 << l) - 1, p = d >> 1, h = n === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, v = i ? 0 : s - 1, y = i ? 1 : -1, g = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
  for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (u = isNaN(t) ? 1 : 0, a = d) : (a = Math.floor(Math.log(t) / Math.LN2), t * (c = Math.pow(2, -a)) < 1 && (a--, c *= 2), a + p >= 1 ? t += h / c : t += h * Math.pow(2, 1 - p), t * c >= 2 && (a++, c /= 2), a + p >= d ? (u = 0, a = d) : a + p >= 1 ? (u = (t * c - 1) * Math.pow(2, n), a = a + p) : (u = t * Math.pow(2, p - 1) * Math.pow(2, n), a = 0)); n >= 8; e[r + v] = u & 255, v += y, u /= 256, n -= 8)
    ;
  for (a = a << n | u, l += n; l > 0; e[r + v] = a & 255, v += y, a /= 256, l -= 8)
    ;
  e[r + v - y] |= g * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(e) {
  const t = Lf, r = hg, i = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  e.Buffer = u, e.SlowBuffer = w, e.INSPECT_MAX_BYTES = 50;
  const n = 2147483647;
  e.kMaxLength = n, u.TYPED_ARRAY_SUPPORT = s(), !u.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function s() {
    try {
      const L = new Uint8Array(1), x = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(x, Uint8Array.prototype), Object.setPrototypeOf(L, x), L.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(u.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (u.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(u.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (u.isBuffer(this))
        return this.byteOffset;
    }
  });
  function a(L) {
    if (L > n)
      throw new RangeError('The value "' + L + '" is invalid for option "size"');
    const x = new Uint8Array(L);
    return Object.setPrototypeOf(x, u.prototype), x;
  }
  function u(L, x, S) {
    if (typeof L == "number") {
      if (typeof x == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return p(L);
    }
    return c(L, x, S);
  }
  u.poolSize = 8192;
  function c(L, x, S) {
    if (typeof L == "string")
      return h(L, x);
    if (ArrayBuffer.isView(L))
      return y(L);
    if (L == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof L
      );
    if (Ne(L, ArrayBuffer) || L && Ne(L.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (Ne(L, SharedArrayBuffer) || L && Ne(L.buffer, SharedArrayBuffer)))
      return g(L, x, S);
    if (typeof L == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const G = L.valueOf && L.valueOf();
    if (G != null && G !== L)
      return u.from(G, x, S);
    const ce = _(L);
    if (ce)
      return ce;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof L[Symbol.toPrimitive] == "function")
      return u.from(L[Symbol.toPrimitive]("string"), x, S);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof L
    );
  }
  u.from = function(L, x, S) {
    return c(L, x, S);
  }, Object.setPrototypeOf(u.prototype, Uint8Array.prototype), Object.setPrototypeOf(u, Uint8Array);
  function l(L) {
    if (typeof L != "number")
      throw new TypeError('"size" argument must be of type number');
    if (L < 0)
      throw new RangeError('The value "' + L + '" is invalid for option "size"');
  }
  function d(L, x, S) {
    return l(L), L <= 0 ? a(L) : x !== void 0 ? typeof S == "string" ? a(L).fill(x, S) : a(L).fill(x) : a(L);
  }
  u.alloc = function(L, x, S) {
    return d(L, x, S);
  };
  function p(L) {
    return l(L), a(L < 0 ? 0 : m(L) | 0);
  }
  u.allocUnsafe = function(L) {
    return p(L);
  }, u.allocUnsafeSlow = function(L) {
    return p(L);
  };
  function h(L, x) {
    if ((typeof x != "string" || x === "") && (x = "utf8"), !u.isEncoding(x))
      throw new TypeError("Unknown encoding: " + x);
    const S = $(L, x) | 0;
    let G = a(S);
    const ce = G.write(L, x);
    return ce !== S && (G = G.slice(0, ce)), G;
  }
  function v(L) {
    const x = L.length < 0 ? 0 : m(L.length) | 0, S = a(x);
    for (let G = 0; G < x; G += 1)
      S[G] = L[G] & 255;
    return S;
  }
  function y(L) {
    if (Ne(L, Uint8Array)) {
      const x = new Uint8Array(L);
      return g(x.buffer, x.byteOffset, x.byteLength);
    }
    return v(L);
  }
  function g(L, x, S) {
    if (x < 0 || L.byteLength < x)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (L.byteLength < x + (S || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let G;
    return x === void 0 && S === void 0 ? G = new Uint8Array(L) : S === void 0 ? G = new Uint8Array(L, x) : G = new Uint8Array(L, x, S), Object.setPrototypeOf(G, u.prototype), G;
  }
  function _(L) {
    if (u.isBuffer(L)) {
      const x = m(L.length) | 0, S = a(x);
      return S.length === 0 || L.copy(S, 0, 0, x), S;
    }
    if (L.length !== void 0)
      return typeof L.length != "number" || Le(L.length) ? a(0) : v(L);
    if (L.type === "Buffer" && Array.isArray(L.data))
      return v(L.data);
  }
  function m(L) {
    if (L >= n)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + n.toString(16) + " bytes");
    return L | 0;
  }
  function w(L) {
    return +L != L && (L = 0), u.alloc(+L);
  }
  u.isBuffer = function(x) {
    return x != null && x._isBuffer === !0 && x !== u.prototype;
  }, u.compare = function(x, S) {
    if (Ne(x, Uint8Array) && (x = u.from(x, x.offset, x.byteLength)), Ne(S, Uint8Array) && (S = u.from(S, S.offset, S.byteLength)), !u.isBuffer(x) || !u.isBuffer(S))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (x === S)
      return 0;
    let G = x.length, ce = S.length;
    for (let me = 0, Oe = Math.min(G, ce); me < Oe; ++me)
      if (x[me] !== S[me]) {
        G = x[me], ce = S[me];
        break;
      }
    return G < ce ? -1 : ce < G ? 1 : 0;
  }, u.isEncoding = function(x) {
    switch (String(x).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, u.concat = function(x, S) {
    if (!Array.isArray(x))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (x.length === 0)
      return u.alloc(0);
    let G;
    if (S === void 0)
      for (S = 0, G = 0; G < x.length; ++G)
        S += x[G].length;
    const ce = u.allocUnsafe(S);
    let me = 0;
    for (G = 0; G < x.length; ++G) {
      let Oe = x[G];
      if (Ne(Oe, Uint8Array))
        me + Oe.length > ce.length ? (u.isBuffer(Oe) || (Oe = u.from(Oe)), Oe.copy(ce, me)) : Uint8Array.prototype.set.call(
          ce,
          Oe,
          me
        );
      else if (u.isBuffer(Oe))
        Oe.copy(ce, me);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      me += Oe.length;
    }
    return ce;
  };
  function $(L, x) {
    if (u.isBuffer(L))
      return L.length;
    if (ArrayBuffer.isView(L) || Ne(L, ArrayBuffer))
      return L.byteLength;
    if (typeof L != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof L
      );
    const S = L.length, G = arguments.length > 2 && arguments[2] === !0;
    if (!G && S === 0)
      return 0;
    let ce = !1;
    for (; ; )
      switch (x) {
        case "ascii":
        case "latin1":
        case "binary":
          return S;
        case "utf8":
        case "utf-8":
          return Ge(L).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return S * 2;
        case "hex":
          return S >>> 1;
        case "base64":
          return Mt(L).length;
        default:
          if (ce)
            return G ? -1 : Ge(L).length;
          x = ("" + x).toLowerCase(), ce = !0;
      }
  }
  u.byteLength = $;
  function E(L, x, S) {
    let G = !1;
    if ((x === void 0 || x < 0) && (x = 0), x > this.length || ((S === void 0 || S > this.length) && (S = this.length), S <= 0) || (S >>>= 0, x >>>= 0, S <= x))
      return "";
    for (L || (L = "utf8"); ; )
      switch (L) {
        case "hex":
          return _e(this, x, S);
        case "utf8":
        case "utf-8":
          return re(this, x, S);
        case "ascii":
          return $e(this, x, S);
        case "latin1":
        case "binary":
          return Ae(this, x, S);
        case "base64":
          return je(this, x, S);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ie(this, x, S);
        default:
          if (G)
            throw new TypeError("Unknown encoding: " + L);
          L = (L + "").toLowerCase(), G = !0;
      }
  }
  u.prototype._isBuffer = !0;
  function A(L, x, S) {
    const G = L[x];
    L[x] = L[S], L[S] = G;
  }
  u.prototype.swap16 = function() {
    const x = this.length;
    if (x % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let S = 0; S < x; S += 2)
      A(this, S, S + 1);
    return this;
  }, u.prototype.swap32 = function() {
    const x = this.length;
    if (x % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let S = 0; S < x; S += 4)
      A(this, S, S + 3), A(this, S + 1, S + 2);
    return this;
  }, u.prototype.swap64 = function() {
    const x = this.length;
    if (x % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let S = 0; S < x; S += 8)
      A(this, S, S + 7), A(this, S + 1, S + 6), A(this, S + 2, S + 5), A(this, S + 3, S + 4);
    return this;
  }, u.prototype.toString = function() {
    const x = this.length;
    return x === 0 ? "" : arguments.length === 0 ? re(this, 0, x) : E.apply(this, arguments);
  }, u.prototype.toLocaleString = u.prototype.toString, u.prototype.equals = function(x) {
    if (!u.isBuffer(x))
      throw new TypeError("Argument must be a Buffer");
    return this === x ? !0 : u.compare(this, x) === 0;
  }, u.prototype.inspect = function() {
    let x = "";
    const S = e.INSPECT_MAX_BYTES;
    return x = this.toString("hex", 0, S).replace(/(.{2})/g, "$1 ").trim(), this.length > S && (x += " ... "), "<Buffer " + x + ">";
  }, i && (u.prototype[i] = u.prototype.inspect), u.prototype.compare = function(x, S, G, ce, me) {
    if (Ne(x, Uint8Array) && (x = u.from(x, x.offset, x.byteLength)), !u.isBuffer(x))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof x
      );
    if (S === void 0 && (S = 0), G === void 0 && (G = x ? x.length : 0), ce === void 0 && (ce = 0), me === void 0 && (me = this.length), S < 0 || G > x.length || ce < 0 || me > this.length)
      throw new RangeError("out of range index");
    if (ce >= me && S >= G)
      return 0;
    if (ce >= me)
      return -1;
    if (S >= G)
      return 1;
    if (S >>>= 0, G >>>= 0, ce >>>= 0, me >>>= 0, this === x)
      return 0;
    let Oe = me - ce, ut = G - S;
    const Dt = Math.min(Oe, ut), Tt = this.slice(ce, me), wt = x.slice(S, G);
    for (let It = 0; It < Dt; ++It)
      if (Tt[It] !== wt[It]) {
        Oe = Tt[It], ut = wt[It];
        break;
      }
    return Oe < ut ? -1 : ut < Oe ? 1 : 0;
  };
  function R(L, x, S, G, ce) {
    if (L.length === 0)
      return -1;
    if (typeof S == "string" ? (G = S, S = 0) : S > 2147483647 ? S = 2147483647 : S < -2147483648 && (S = -2147483648), S = +S, Le(S) && (S = ce ? 0 : L.length - 1), S < 0 && (S = L.length + S), S >= L.length) {
      if (ce)
        return -1;
      S = L.length - 1;
    } else if (S < 0)
      if (ce)
        S = 0;
      else
        return -1;
    if (typeof x == "string" && (x = u.from(x, G)), u.isBuffer(x))
      return x.length === 0 ? -1 : I(L, x, S, G, ce);
    if (typeof x == "number")
      return x = x & 255, typeof Uint8Array.prototype.indexOf == "function" ? ce ? Uint8Array.prototype.indexOf.call(L, x, S) : Uint8Array.prototype.lastIndexOf.call(L, x, S) : I(L, [x], S, G, ce);
    throw new TypeError("val must be string, number or Buffer");
  }
  function I(L, x, S, G, ce) {
    let me = 1, Oe = L.length, ut = x.length;
    if (G !== void 0 && (G = String(G).toLowerCase(), G === "ucs2" || G === "ucs-2" || G === "utf16le" || G === "utf-16le")) {
      if (L.length < 2 || x.length < 2)
        return -1;
      me = 2, Oe /= 2, ut /= 2, S /= 2;
    }
    function Dt(wt, It) {
      return me === 1 ? wt[It] : wt.readUInt16BE(It * me);
    }
    let Tt;
    if (ce) {
      let wt = -1;
      for (Tt = S; Tt < Oe; Tt++)
        if (Dt(L, Tt) === Dt(x, wt === -1 ? 0 : Tt - wt)) {
          if (wt === -1 && (wt = Tt), Tt - wt + 1 === ut)
            return wt * me;
        } else
          wt !== -1 && (Tt -= Tt - wt), wt = -1;
    } else
      for (S + ut > Oe && (S = Oe - ut), Tt = S; Tt >= 0; Tt--) {
        let wt = !0;
        for (let It = 0; It < ut; It++)
          if (Dt(L, Tt + It) !== Dt(x, It)) {
            wt = !1;
            break;
          }
        if (wt)
          return Tt;
      }
    return -1;
  }
  u.prototype.includes = function(x, S, G) {
    return this.indexOf(x, S, G) !== -1;
  }, u.prototype.indexOf = function(x, S, G) {
    return R(this, x, S, G, !0);
  }, u.prototype.lastIndexOf = function(x, S, G) {
    return R(this, x, S, G, !1);
  };
  function D(L, x, S, G) {
    S = Number(S) || 0;
    const ce = L.length - S;
    G ? (G = Number(G), G > ce && (G = ce)) : G = ce;
    const me = x.length;
    G > me / 2 && (G = me / 2);
    let Oe;
    for (Oe = 0; Oe < G; ++Oe) {
      const ut = parseInt(x.substr(Oe * 2, 2), 16);
      if (Le(ut))
        return Oe;
      L[S + Oe] = ut;
    }
    return Oe;
  }
  function J(L, x, S, G) {
    return St(Ge(x, L.length - S), L, S, G);
  }
  function ae(L, x, S, G) {
    return St(jt(x), L, S, G);
  }
  function ye(L, x, S, G) {
    return St(Mt(x), L, S, G);
  }
  function xe(L, x, S, G) {
    return St(Ee(x, L.length - S), L, S, G);
  }
  u.prototype.write = function(x, S, G, ce) {
    if (S === void 0)
      ce = "utf8", G = this.length, S = 0;
    else if (G === void 0 && typeof S == "string")
      ce = S, G = this.length, S = 0;
    else if (isFinite(S))
      S = S >>> 0, isFinite(G) ? (G = G >>> 0, ce === void 0 && (ce = "utf8")) : (ce = G, G = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const me = this.length - S;
    if ((G === void 0 || G > me) && (G = me), x.length > 0 && (G < 0 || S < 0) || S > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    ce || (ce = "utf8");
    let Oe = !1;
    for (; ; )
      switch (ce) {
        case "hex":
          return D(this, x, S, G);
        case "utf8":
        case "utf-8":
          return J(this, x, S, G);
        case "ascii":
        case "latin1":
        case "binary":
          return ae(this, x, S, G);
        case "base64":
          return ye(this, x, S, G);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return xe(this, x, S, G);
        default:
          if (Oe)
            throw new TypeError("Unknown encoding: " + ce);
          ce = ("" + ce).toLowerCase(), Oe = !0;
      }
  }, u.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function je(L, x, S) {
    return x === 0 && S === L.length ? t.fromByteArray(L) : t.fromByteArray(L.slice(x, S));
  }
  function re(L, x, S) {
    S = Math.min(L.length, S);
    const G = [];
    let ce = x;
    for (; ce < S; ) {
      const me = L[ce];
      let Oe = null, ut = me > 239 ? 4 : me > 223 ? 3 : me > 191 ? 2 : 1;
      if (ce + ut <= S) {
        let Dt, Tt, wt, It;
        switch (ut) {
          case 1:
            me < 128 && (Oe = me);
            break;
          case 2:
            Dt = L[ce + 1], (Dt & 192) === 128 && (It = (me & 31) << 6 | Dt & 63, It > 127 && (Oe = It));
            break;
          case 3:
            Dt = L[ce + 1], Tt = L[ce + 2], (Dt & 192) === 128 && (Tt & 192) === 128 && (It = (me & 15) << 12 | (Dt & 63) << 6 | Tt & 63, It > 2047 && (It < 55296 || It > 57343) && (Oe = It));
            break;
          case 4:
            Dt = L[ce + 1], Tt = L[ce + 2], wt = L[ce + 3], (Dt & 192) === 128 && (Tt & 192) === 128 && (wt & 192) === 128 && (It = (me & 15) << 18 | (Dt & 63) << 12 | (Tt & 63) << 6 | wt & 63, It > 65535 && It < 1114112 && (Oe = It));
        }
      }
      Oe === null ? (Oe = 65533, ut = 1) : Oe > 65535 && (Oe -= 65536, G.push(Oe >>> 10 & 1023 | 55296), Oe = 56320 | Oe & 1023), G.push(Oe), ce += ut;
    }
    return le(G);
  }
  const fe = 4096;
  function le(L) {
    const x = L.length;
    if (x <= fe)
      return String.fromCharCode.apply(String, L);
    let S = "", G = 0;
    for (; G < x; )
      S += String.fromCharCode.apply(
        String,
        L.slice(G, G += fe)
      );
    return S;
  }
  function $e(L, x, S) {
    let G = "";
    S = Math.min(L.length, S);
    for (let ce = x; ce < S; ++ce)
      G += String.fromCharCode(L[ce] & 127);
    return G;
  }
  function Ae(L, x, S) {
    let G = "";
    S = Math.min(L.length, S);
    for (let ce = x; ce < S; ++ce)
      G += String.fromCharCode(L[ce]);
    return G;
  }
  function _e(L, x, S) {
    const G = L.length;
    (!x || x < 0) && (x = 0), (!S || S < 0 || S > G) && (S = G);
    let ce = "";
    for (let me = x; me < S; ++me)
      ce += at[L[me]];
    return ce;
  }
  function ie(L, x, S) {
    const G = L.slice(x, S);
    let ce = "";
    for (let me = 0; me < G.length - 1; me += 2)
      ce += String.fromCharCode(G[me] + G[me + 1] * 256);
    return ce;
  }
  u.prototype.slice = function(x, S) {
    const G = this.length;
    x = ~~x, S = S === void 0 ? G : ~~S, x < 0 ? (x += G, x < 0 && (x = 0)) : x > G && (x = G), S < 0 ? (S += G, S < 0 && (S = 0)) : S > G && (S = G), S < x && (S = x);
    const ce = this.subarray(x, S);
    return Object.setPrototypeOf(ce, u.prototype), ce;
  };
  function K(L, x, S) {
    if (L % 1 !== 0 || L < 0)
      throw new RangeError("offset is not uint");
    if (L + x > S)
      throw new RangeError("Trying to access beyond buffer length");
  }
  u.prototype.readUintLE = u.prototype.readUIntLE = function(x, S, G) {
    x = x >>> 0, S = S >>> 0, G || K(x, S, this.length);
    let ce = this[x], me = 1, Oe = 0;
    for (; ++Oe < S && (me *= 256); )
      ce += this[x + Oe] * me;
    return ce;
  }, u.prototype.readUintBE = u.prototype.readUIntBE = function(x, S, G) {
    x = x >>> 0, S = S >>> 0, G || K(x, S, this.length);
    let ce = this[x + --S], me = 1;
    for (; S > 0 && (me *= 256); )
      ce += this[x + --S] * me;
    return ce;
  }, u.prototype.readUint8 = u.prototype.readUInt8 = function(x, S) {
    return x = x >>> 0, S || K(x, 1, this.length), this[x];
  }, u.prototype.readUint16LE = u.prototype.readUInt16LE = function(x, S) {
    return x = x >>> 0, S || K(x, 2, this.length), this[x] | this[x + 1] << 8;
  }, u.prototype.readUint16BE = u.prototype.readUInt16BE = function(x, S) {
    return x = x >>> 0, S || K(x, 2, this.length), this[x] << 8 | this[x + 1];
  }, u.prototype.readUint32LE = u.prototype.readUInt32LE = function(x, S) {
    return x = x >>> 0, S || K(x, 4, this.length), (this[x] | this[x + 1] << 8 | this[x + 2] << 16) + this[x + 3] * 16777216;
  }, u.prototype.readUint32BE = u.prototype.readUInt32BE = function(x, S) {
    return x = x >>> 0, S || K(x, 4, this.length), this[x] * 16777216 + (this[x + 1] << 16 | this[x + 2] << 8 | this[x + 3]);
  }, u.prototype.readBigUInt64LE = mt(function(x) {
    x = x >>> 0, pe(x, "offset");
    const S = this[x], G = this[x + 7];
    (S === void 0 || G === void 0) && we(x, this.length - 8);
    const ce = S + this[++x] * 2 ** 8 + this[++x] * 2 ** 16 + this[++x] * 2 ** 24, me = this[++x] + this[++x] * 2 ** 8 + this[++x] * 2 ** 16 + G * 2 ** 24;
    return BigInt(ce) + (BigInt(me) << BigInt(32));
  }), u.prototype.readBigUInt64BE = mt(function(x) {
    x = x >>> 0, pe(x, "offset");
    const S = this[x], G = this[x + 7];
    (S === void 0 || G === void 0) && we(x, this.length - 8);
    const ce = S * 2 ** 24 + this[++x] * 2 ** 16 + this[++x] * 2 ** 8 + this[++x], me = this[++x] * 2 ** 24 + this[++x] * 2 ** 16 + this[++x] * 2 ** 8 + G;
    return (BigInt(ce) << BigInt(32)) + BigInt(me);
  }), u.prototype.readIntLE = function(x, S, G) {
    x = x >>> 0, S = S >>> 0, G || K(x, S, this.length);
    let ce = this[x], me = 1, Oe = 0;
    for (; ++Oe < S && (me *= 256); )
      ce += this[x + Oe] * me;
    return me *= 128, ce >= me && (ce -= Math.pow(2, 8 * S)), ce;
  }, u.prototype.readIntBE = function(x, S, G) {
    x = x >>> 0, S = S >>> 0, G || K(x, S, this.length);
    let ce = S, me = 1, Oe = this[x + --ce];
    for (; ce > 0 && (me *= 256); )
      Oe += this[x + --ce] * me;
    return me *= 128, Oe >= me && (Oe -= Math.pow(2, 8 * S)), Oe;
  }, u.prototype.readInt8 = function(x, S) {
    return x = x >>> 0, S || K(x, 1, this.length), this[x] & 128 ? (255 - this[x] + 1) * -1 : this[x];
  }, u.prototype.readInt16LE = function(x, S) {
    x = x >>> 0, S || K(x, 2, this.length);
    const G = this[x] | this[x + 1] << 8;
    return G & 32768 ? G | 4294901760 : G;
  }, u.prototype.readInt16BE = function(x, S) {
    x = x >>> 0, S || K(x, 2, this.length);
    const G = this[x + 1] | this[x] << 8;
    return G & 32768 ? G | 4294901760 : G;
  }, u.prototype.readInt32LE = function(x, S) {
    return x = x >>> 0, S || K(x, 4, this.length), this[x] | this[x + 1] << 8 | this[x + 2] << 16 | this[x + 3] << 24;
  }, u.prototype.readInt32BE = function(x, S) {
    return x = x >>> 0, S || K(x, 4, this.length), this[x] << 24 | this[x + 1] << 16 | this[x + 2] << 8 | this[x + 3];
  }, u.prototype.readBigInt64LE = mt(function(x) {
    x = x >>> 0, pe(x, "offset");
    const S = this[x], G = this[x + 7];
    (S === void 0 || G === void 0) && we(x, this.length - 8);
    const ce = this[x + 4] + this[x + 5] * 2 ** 8 + this[x + 6] * 2 ** 16 + (G << 24);
    return (BigInt(ce) << BigInt(32)) + BigInt(S + this[++x] * 2 ** 8 + this[++x] * 2 ** 16 + this[++x] * 2 ** 24);
  }), u.prototype.readBigInt64BE = mt(function(x) {
    x = x >>> 0, pe(x, "offset");
    const S = this[x], G = this[x + 7];
    (S === void 0 || G === void 0) && we(x, this.length - 8);
    const ce = (S << 24) + // Overflow
    this[++x] * 2 ** 16 + this[++x] * 2 ** 8 + this[++x];
    return (BigInt(ce) << BigInt(32)) + BigInt(this[++x] * 2 ** 24 + this[++x] * 2 ** 16 + this[++x] * 2 ** 8 + G);
  }), u.prototype.readFloatLE = function(x, S) {
    return x = x >>> 0, S || K(x, 4, this.length), r.read(this, x, !0, 23, 4);
  }, u.prototype.readFloatBE = function(x, S) {
    return x = x >>> 0, S || K(x, 4, this.length), r.read(this, x, !1, 23, 4);
  }, u.prototype.readDoubleLE = function(x, S) {
    return x = x >>> 0, S || K(x, 8, this.length), r.read(this, x, !0, 52, 8);
  }, u.prototype.readDoubleBE = function(x, S) {
    return x = x >>> 0, S || K(x, 8, this.length), r.read(this, x, !1, 52, 8);
  };
  function V(L, x, S, G, ce, me) {
    if (!u.isBuffer(L))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (x > ce || x < me)
      throw new RangeError('"value" argument is out of bounds');
    if (S + G > L.length)
      throw new RangeError("Index out of range");
  }
  u.prototype.writeUintLE = u.prototype.writeUIntLE = function(x, S, G, ce) {
    if (x = +x, S = S >>> 0, G = G >>> 0, !ce) {
      const ut = Math.pow(2, 8 * G) - 1;
      V(this, x, S, G, ut, 0);
    }
    let me = 1, Oe = 0;
    for (this[S] = x & 255; ++Oe < G && (me *= 256); )
      this[S + Oe] = x / me & 255;
    return S + G;
  }, u.prototype.writeUintBE = u.prototype.writeUIntBE = function(x, S, G, ce) {
    if (x = +x, S = S >>> 0, G = G >>> 0, !ce) {
      const ut = Math.pow(2, 8 * G) - 1;
      V(this, x, S, G, ut, 0);
    }
    let me = G - 1, Oe = 1;
    for (this[S + me] = x & 255; --me >= 0 && (Oe *= 256); )
      this[S + me] = x / Oe & 255;
    return S + G;
  }, u.prototype.writeUint8 = u.prototype.writeUInt8 = function(x, S, G) {
    return x = +x, S = S >>> 0, G || V(this, x, S, 1, 255, 0), this[S] = x & 255, S + 1;
  }, u.prototype.writeUint16LE = u.prototype.writeUInt16LE = function(x, S, G) {
    return x = +x, S = S >>> 0, G || V(this, x, S, 2, 65535, 0), this[S] = x & 255, this[S + 1] = x >>> 8, S + 2;
  }, u.prototype.writeUint16BE = u.prototype.writeUInt16BE = function(x, S, G) {
    return x = +x, S = S >>> 0, G || V(this, x, S, 2, 65535, 0), this[S] = x >>> 8, this[S + 1] = x & 255, S + 2;
  }, u.prototype.writeUint32LE = u.prototype.writeUInt32LE = function(x, S, G) {
    return x = +x, S = S >>> 0, G || V(this, x, S, 4, 4294967295, 0), this[S + 3] = x >>> 24, this[S + 2] = x >>> 16, this[S + 1] = x >>> 8, this[S] = x & 255, S + 4;
  }, u.prototype.writeUint32BE = u.prototype.writeUInt32BE = function(x, S, G) {
    return x = +x, S = S >>> 0, G || V(this, x, S, 4, 4294967295, 0), this[S] = x >>> 24, this[S + 1] = x >>> 16, this[S + 2] = x >>> 8, this[S + 3] = x & 255, S + 4;
  };
  function z(L, x, S, G, ce) {
    U(x, G, ce, L, S, 7);
    let me = Number(x & BigInt(4294967295));
    L[S++] = me, me = me >> 8, L[S++] = me, me = me >> 8, L[S++] = me, me = me >> 8, L[S++] = me;
    let Oe = Number(x >> BigInt(32) & BigInt(4294967295));
    return L[S++] = Oe, Oe = Oe >> 8, L[S++] = Oe, Oe = Oe >> 8, L[S++] = Oe, Oe = Oe >> 8, L[S++] = Oe, S;
  }
  function C(L, x, S, G, ce) {
    U(x, G, ce, L, S, 7);
    let me = Number(x & BigInt(4294967295));
    L[S + 7] = me, me = me >> 8, L[S + 6] = me, me = me >> 8, L[S + 5] = me, me = me >> 8, L[S + 4] = me;
    let Oe = Number(x >> BigInt(32) & BigInt(4294967295));
    return L[S + 3] = Oe, Oe = Oe >> 8, L[S + 2] = Oe, Oe = Oe >> 8, L[S + 1] = Oe, Oe = Oe >> 8, L[S] = Oe, S + 8;
  }
  u.prototype.writeBigUInt64LE = mt(function(x, S = 0) {
    return z(this, x, S, BigInt(0), BigInt("0xffffffffffffffff"));
  }), u.prototype.writeBigUInt64BE = mt(function(x, S = 0) {
    return C(this, x, S, BigInt(0), BigInt("0xffffffffffffffff"));
  }), u.prototype.writeIntLE = function(x, S, G, ce) {
    if (x = +x, S = S >>> 0, !ce) {
      const Dt = Math.pow(2, 8 * G - 1);
      V(this, x, S, G, Dt - 1, -Dt);
    }
    let me = 0, Oe = 1, ut = 0;
    for (this[S] = x & 255; ++me < G && (Oe *= 256); )
      x < 0 && ut === 0 && this[S + me - 1] !== 0 && (ut = 1), this[S + me] = (x / Oe >> 0) - ut & 255;
    return S + G;
  }, u.prototype.writeIntBE = function(x, S, G, ce) {
    if (x = +x, S = S >>> 0, !ce) {
      const Dt = Math.pow(2, 8 * G - 1);
      V(this, x, S, G, Dt - 1, -Dt);
    }
    let me = G - 1, Oe = 1, ut = 0;
    for (this[S + me] = x & 255; --me >= 0 && (Oe *= 256); )
      x < 0 && ut === 0 && this[S + me + 1] !== 0 && (ut = 1), this[S + me] = (x / Oe >> 0) - ut & 255;
    return S + G;
  }, u.prototype.writeInt8 = function(x, S, G) {
    return x = +x, S = S >>> 0, G || V(this, x, S, 1, 127, -128), x < 0 && (x = 255 + x + 1), this[S] = x & 255, S + 1;
  }, u.prototype.writeInt16LE = function(x, S, G) {
    return x = +x, S = S >>> 0, G || V(this, x, S, 2, 32767, -32768), this[S] = x & 255, this[S + 1] = x >>> 8, S + 2;
  }, u.prototype.writeInt16BE = function(x, S, G) {
    return x = +x, S = S >>> 0, G || V(this, x, S, 2, 32767, -32768), this[S] = x >>> 8, this[S + 1] = x & 255, S + 2;
  }, u.prototype.writeInt32LE = function(x, S, G) {
    return x = +x, S = S >>> 0, G || V(this, x, S, 4, 2147483647, -2147483648), this[S] = x & 255, this[S + 1] = x >>> 8, this[S + 2] = x >>> 16, this[S + 3] = x >>> 24, S + 4;
  }, u.prototype.writeInt32BE = function(x, S, G) {
    return x = +x, S = S >>> 0, G || V(this, x, S, 4, 2147483647, -2147483648), x < 0 && (x = 4294967295 + x + 1), this[S] = x >>> 24, this[S + 1] = x >>> 16, this[S + 2] = x >>> 8, this[S + 3] = x & 255, S + 4;
  }, u.prototype.writeBigInt64LE = mt(function(x, S = 0) {
    return z(this, x, S, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), u.prototype.writeBigInt64BE = mt(function(x, S = 0) {
    return C(this, x, S, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function q(L, x, S, G, ce, me) {
    if (S + G > L.length)
      throw new RangeError("Index out of range");
    if (S < 0)
      throw new RangeError("Index out of range");
  }
  function N(L, x, S, G, ce) {
    return x = +x, S = S >>> 0, ce || q(L, x, S, 4), r.write(L, x, S, G, 23, 4), S + 4;
  }
  u.prototype.writeFloatLE = function(x, S, G) {
    return N(this, x, S, !0, G);
  }, u.prototype.writeFloatBE = function(x, S, G) {
    return N(this, x, S, !1, G);
  };
  function F(L, x, S, G, ce) {
    return x = +x, S = S >>> 0, ce || q(L, x, S, 8), r.write(L, x, S, G, 52, 8), S + 8;
  }
  u.prototype.writeDoubleLE = function(x, S, G) {
    return F(this, x, S, !0, G);
  }, u.prototype.writeDoubleBE = function(x, S, G) {
    return F(this, x, S, !1, G);
  }, u.prototype.copy = function(x, S, G, ce) {
    if (!u.isBuffer(x))
      throw new TypeError("argument should be a Buffer");
    if (G || (G = 0), !ce && ce !== 0 && (ce = this.length), S >= x.length && (S = x.length), S || (S = 0), ce > 0 && ce < G && (ce = G), ce === G || x.length === 0 || this.length === 0)
      return 0;
    if (S < 0)
      throw new RangeError("targetStart out of bounds");
    if (G < 0 || G >= this.length)
      throw new RangeError("Index out of range");
    if (ce < 0)
      throw new RangeError("sourceEnd out of bounds");
    ce > this.length && (ce = this.length), x.length - S < ce - G && (ce = x.length - S + G);
    const me = ce - G;
    return this === x && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(S, G, ce) : Uint8Array.prototype.set.call(
      x,
      this.subarray(G, ce),
      S
    ), me;
  }, u.prototype.fill = function(x, S, G, ce) {
    if (typeof x == "string") {
      if (typeof S == "string" ? (ce = S, S = 0, G = this.length) : typeof G == "string" && (ce = G, G = this.length), ce !== void 0 && typeof ce != "string")
        throw new TypeError("encoding must be a string");
      if (typeof ce == "string" && !u.isEncoding(ce))
        throw new TypeError("Unknown encoding: " + ce);
      if (x.length === 1) {
        const Oe = x.charCodeAt(0);
        (ce === "utf8" && Oe < 128 || ce === "latin1") && (x = Oe);
      }
    } else
      typeof x == "number" ? x = x & 255 : typeof x == "boolean" && (x = Number(x));
    if (S < 0 || this.length < S || this.length < G)
      throw new RangeError("Out of range index");
    if (G <= S)
      return this;
    S = S >>> 0, G = G === void 0 ? this.length : G >>> 0, x || (x = 0);
    let me;
    if (typeof x == "number")
      for (me = S; me < G; ++me)
        this[me] = x;
    else {
      const Oe = u.isBuffer(x) ? x : u.from(x, ce), ut = Oe.length;
      if (ut === 0)
        throw new TypeError('The value "' + x + '" is invalid for argument "value"');
      for (me = 0; me < G - S; ++me)
        this[me + S] = Oe[me % ut];
    }
    return this;
  };
  const T = {};
  function Z(L, x, S) {
    T[L] = class extends S {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: x.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${L}]`, this.stack, delete this.name;
      }
      get code() {
        return L;
      }
      set code(ce) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: ce,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${L}]: ${this.message}`;
      }
    };
  }
  Z(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(L) {
      return L ? `${L} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), Z(
    "ERR_INVALID_ARG_TYPE",
    function(L, x) {
      return `The "${L}" argument must be of type number. Received type ${typeof x}`;
    },
    TypeError
  ), Z(
    "ERR_OUT_OF_RANGE",
    function(L, x, S) {
      let G = `The value of "${L}" is out of range.`, ce = S;
      return Number.isInteger(S) && Math.abs(S) > 2 ** 32 ? ce = Y(String(S)) : typeof S == "bigint" && (ce = String(S), (S > BigInt(2) ** BigInt(32) || S < -(BigInt(2) ** BigInt(32))) && (ce = Y(ce)), ce += "n"), G += ` It must be ${x}. Received ${ce}`, G;
    },
    RangeError
  );
  function Y(L) {
    let x = "", S = L.length;
    const G = L[0] === "-" ? 1 : 0;
    for (; S >= G + 4; S -= 3)
      x = `_${L.slice(S - 3, S)}${x}`;
    return `${L.slice(0, S)}${x}`;
  }
  function k(L, x, S) {
    pe(x, "offset"), (L[x] === void 0 || L[x + S] === void 0) && we(x, L.length - (S + 1));
  }
  function U(L, x, S, G, ce, me) {
    if (L > S || L < x) {
      const Oe = typeof x == "bigint" ? "n" : "";
      let ut;
      throw me > 3 ? x === 0 || x === BigInt(0) ? ut = `>= 0${Oe} and < 2${Oe} ** ${(me + 1) * 8}${Oe}` : ut = `>= -(2${Oe} ** ${(me + 1) * 8 - 1}${Oe}) and < 2 ** ${(me + 1) * 8 - 1}${Oe}` : ut = `>= ${x}${Oe} and <= ${S}${Oe}`, new T.ERR_OUT_OF_RANGE("value", ut, L);
    }
    k(G, ce, me);
  }
  function pe(L, x) {
    if (typeof L != "number")
      throw new T.ERR_INVALID_ARG_TYPE(x, "number", L);
  }
  function we(L, x, S) {
    throw Math.floor(L) !== L ? (pe(L, S), new T.ERR_OUT_OF_RANGE(S || "offset", "an integer", L)) : x < 0 ? new T.ERR_BUFFER_OUT_OF_BOUNDS() : new T.ERR_OUT_OF_RANGE(
      S || "offset",
      `>= ${S ? 1 : 0} and <= ${x}`,
      L
    );
  }
  const He = /[^+/0-9A-Za-z-_]/g;
  function Fe(L) {
    if (L = L.split("=")[0], L = L.trim().replace(He, ""), L.length < 2)
      return "";
    for (; L.length % 4 !== 0; )
      L = L + "=";
    return L;
  }
  function Ge(L, x) {
    x = x || 1 / 0;
    let S;
    const G = L.length;
    let ce = null;
    const me = [];
    for (let Oe = 0; Oe < G; ++Oe) {
      if (S = L.charCodeAt(Oe), S > 55295 && S < 57344) {
        if (!ce) {
          if (S > 56319) {
            (x -= 3) > -1 && me.push(239, 191, 189);
            continue;
          } else if (Oe + 1 === G) {
            (x -= 3) > -1 && me.push(239, 191, 189);
            continue;
          }
          ce = S;
          continue;
        }
        if (S < 56320) {
          (x -= 3) > -1 && me.push(239, 191, 189), ce = S;
          continue;
        }
        S = (ce - 55296 << 10 | S - 56320) + 65536;
      } else
        ce && (x -= 3) > -1 && me.push(239, 191, 189);
      if (ce = null, S < 128) {
        if ((x -= 1) < 0)
          break;
        me.push(S);
      } else if (S < 2048) {
        if ((x -= 2) < 0)
          break;
        me.push(
          S >> 6 | 192,
          S & 63 | 128
        );
      } else if (S < 65536) {
        if ((x -= 3) < 0)
          break;
        me.push(
          S >> 12 | 224,
          S >> 6 & 63 | 128,
          S & 63 | 128
        );
      } else if (S < 1114112) {
        if ((x -= 4) < 0)
          break;
        me.push(
          S >> 18 | 240,
          S >> 12 & 63 | 128,
          S >> 6 & 63 | 128,
          S & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return me;
  }
  function jt(L) {
    const x = [];
    for (let S = 0; S < L.length; ++S)
      x.push(L.charCodeAt(S) & 255);
    return x;
  }
  function Ee(L, x) {
    let S, G, ce;
    const me = [];
    for (let Oe = 0; Oe < L.length && !((x -= 2) < 0); ++Oe)
      S = L.charCodeAt(Oe), G = S >> 8, ce = S % 256, me.push(ce), me.push(G);
    return me;
  }
  function Mt(L) {
    return t.toByteArray(Fe(L));
  }
  function St(L, x, S, G) {
    let ce;
    for (ce = 0; ce < G && !(ce + S >= x.length || ce >= L.length); ++ce)
      x[ce + S] = L[ce];
    return ce;
  }
  function Ne(L, x) {
    return L instanceof x || L != null && L.constructor != null && L.constructor.name != null && L.constructor.name === x.name;
  }
  function Le(L) {
    return L !== L;
  }
  const at = function() {
    const L = "0123456789abcdef", x = new Array(256);
    for (let S = 0; S < 16; ++S) {
      const G = S * 16;
      for (let ce = 0; ce < 16; ++ce)
        x[G + ce] = L[S] + L[ce];
    }
    return x;
  }();
  function mt(L) {
    return typeof BigInt > "u" ? qe : L;
  }
  function qe() {
    throw new Error("BigInt not supported");
  }
})(lo);
var hE = { exports: {} }, ir = hE.exports = {}, Wn, Hn;
function uy() {
  throw new Error("setTimeout has not been defined");
}
function cy() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? Wn = setTimeout : Wn = uy;
  } catch {
    Wn = uy;
  }
  try {
    typeof clearTimeout == "function" ? Hn = clearTimeout : Hn = cy;
  } catch {
    Hn = cy;
  }
})();
function mE(e) {
  if (Wn === setTimeout)
    return setTimeout(e, 0);
  if ((Wn === uy || !Wn) && setTimeout)
    return Wn = setTimeout, setTimeout(e, 0);
  try {
    return Wn(e, 0);
  } catch {
    try {
      return Wn.call(null, e, 0);
    } catch {
      return Wn.call(this, e, 0);
    }
  }
}
function aM(e) {
  if (Hn === clearTimeout)
    return clearTimeout(e);
  if ((Hn === cy || !Hn) && clearTimeout)
    return Hn = clearTimeout, clearTimeout(e);
  try {
    return Hn(e);
  } catch {
    try {
      return Hn.call(null, e);
    } catch {
      return Hn.call(this, e);
    }
  }
}
var $i = [], Ga = !1, Zs, Ol = -1;
function oM() {
  !Ga || !Zs || (Ga = !1, Zs.length ? $i = Zs.concat($i) : Ol = -1, $i.length && yE());
}
function yE() {
  if (!Ga) {
    var e = mE(oM);
    Ga = !0;
    for (var t = $i.length; t; ) {
      for (Zs = $i, $i = []; ++Ol < t; )
        Zs && Zs[Ol].run();
      Ol = -1, t = $i.length;
    }
    Zs = null, Ga = !1, aM(e);
  }
}
ir.nextTick = function(e) {
  var t = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var r = 1; r < arguments.length; r++)
      t[r - 1] = arguments[r];
  $i.push(new gE(e, t)), $i.length === 1 && !Ga && mE(yE);
};
function gE(e, t) {
  this.fun = e, this.array = t;
}
gE.prototype.run = function() {
  this.fun.apply(null, this.array);
};
ir.title = "browser";
ir.browser = !0;
ir.env = {};
ir.argv = [];
ir.version = "";
ir.versions = {};
function Ii() {
}
ir.on = Ii;
ir.addListener = Ii;
ir.once = Ii;
ir.off = Ii;
ir.removeListener = Ii;
ir.removeAllListeners = Ii;
ir.emit = Ii;
ir.prependListener = Ii;
ir.prependOnceListener = Ii;
ir.listeners = function(e) {
  return [];
};
ir.binding = function(e) {
  throw new Error("process.binding is not supported");
};
ir.cwd = function() {
  return "/";
};
ir.chdir = function(e) {
  throw new Error("process.chdir is not supported");
};
ir.umask = function() {
  return 0;
};
var uM = hE.exports;
(function(e) {
  Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
  const t = lo, r = uM, i = (a) => a && a.__esModule ? a : { default: a }, n = i(r), s = globalThis || void 0 || self;
  Object.defineProperty(e, "Buffer", { enumerable: !0, get: () => t.Buffer }), Object.defineProperty(e, "process", { enumerable: !0, get: () => n.default }), e.global = s;
})(Me);
var fo = {}, vE = {}, bE = function() {
  if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
    return !1;
  if (typeof Symbol.iterator == "symbol")
    return !0;
  var t = {}, r = Symbol("test"), i = Object(r);
  if (typeof r == "string" || Object.prototype.toString.call(r) !== "[object Symbol]" || Object.prototype.toString.call(i) !== "[object Symbol]")
    return !1;
  var n = 42;
  t[r] = n;
  for (r in t)
    return !1;
  if (typeof Object.keys == "function" && Object.keys(t).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(t).length !== 0)
    return !1;
  var s = Object.getOwnPropertySymbols(t);
  if (s.length !== 1 || s[0] !== r || !Object.prototype.propertyIsEnumerable.call(t, r))
    return !1;
  if (typeof Object.getOwnPropertyDescriptor == "function") {
    var a = Object.getOwnPropertyDescriptor(t, r);
    if (a.value !== n || a.enumerable !== !0)
      return !1;
  }
  return !0;
}, cM = bE, mg = function() {
  return cM() && !!Symbol.toStringTag;
}, h1 = typeof Symbol < "u" && Symbol, lM = bE, fM = function() {
  return typeof h1 != "function" || typeof Symbol != "function" || typeof h1("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : lM();
}, m1 = {
  foo: {}
}, dM = Object, pM = function() {
  return { __proto__: m1 }.foo === m1.foo && !({ __proto__: null } instanceof dM);
}, hM = "Function.prototype.bind called on incompatible ", Rp = Array.prototype.slice, mM = Object.prototype.toString, yM = "[object Function]", gM = function(t) {
  var r = this;
  if (typeof r != "function" || mM.call(r) !== yM)
    throw new TypeError(hM + r);
  for (var i = Rp.call(arguments, 1), n, s = function() {
    if (this instanceof n) {
      var d = r.apply(
        this,
        i.concat(Rp.call(arguments))
      );
      return Object(d) === d ? d : this;
    } else
      return r.apply(
        t,
        i.concat(Rp.call(arguments))
      );
  }, a = Math.max(0, r.length - i.length), u = [], c = 0; c < a; c++)
    u.push("$" + c);
  if (n = Function("binder", "return function (" + u.join(",") + "){ return binder.apply(this,arguments); }")(s), r.prototype) {
    var l = function() {
    };
    l.prototype = r.prototype, n.prototype = new l(), l.prototype = null;
  }
  return n;
}, vM = gM, yg = Function.prototype.bind || vM, bM = yg, _M = bM.call(Function.call, Object.prototype.hasOwnProperty), Ct, io = SyntaxError, _E = Function, Ka = TypeError, Tp = function(e) {
  try {
    return _E('"use strict"; return (' + e + ").constructor;")();
  } catch {
  }
}, Hs = Object.getOwnPropertyDescriptor;
if (Hs)
  try {
    Hs({}, "");
  } catch {
    Hs = null;
  }
var Ip = function() {
  throw new Ka();
}, wM = Hs ? function() {
  try {
    return arguments.callee, Ip;
  } catch {
    try {
      return Hs(arguments, "callee").get;
    } catch {
      return Ip;
    }
  }
}() : Ip, Aa = fM(), $M = pM(), pr = Object.getPrototypeOf || ($M ? function(e) {
  return e.__proto__;
} : null), La = {}, EM = typeof Uint8Array > "u" || !pr ? Ct : pr(Uint8Array), Gs = {
  "%AggregateError%": typeof AggregateError > "u" ? Ct : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer > "u" ? Ct : ArrayBuffer,
  "%ArrayIteratorPrototype%": Aa && pr ? pr([][Symbol.iterator]()) : Ct,
  "%AsyncFromSyncIteratorPrototype%": Ct,
  "%AsyncFunction%": La,
  "%AsyncGenerator%": La,
  "%AsyncGeneratorFunction%": La,
  "%AsyncIteratorPrototype%": La,
  "%Atomics%": typeof Atomics > "u" ? Ct : Atomics,
  "%BigInt%": typeof BigInt > "u" ? Ct : BigInt,
  "%BigInt64Array%": typeof BigInt64Array > "u" ? Ct : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array > "u" ? Ct : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView > "u" ? Ct : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": Error,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": EvalError,
  "%Float32Array%": typeof Float32Array > "u" ? Ct : Float32Array,
  "%Float64Array%": typeof Float64Array > "u" ? Ct : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? Ct : FinalizationRegistry,
  "%Function%": _E,
  "%GeneratorFunction%": La,
  "%Int8Array%": typeof Int8Array > "u" ? Ct : Int8Array,
  "%Int16Array%": typeof Int16Array > "u" ? Ct : Int16Array,
  "%Int32Array%": typeof Int32Array > "u" ? Ct : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": Aa && pr ? pr(pr([][Symbol.iterator]())) : Ct,
  "%JSON%": typeof JSON == "object" ? JSON : Ct,
  "%Map%": typeof Map > "u" ? Ct : Map,
  "%MapIteratorPrototype%": typeof Map > "u" || !Aa || !pr ? Ct : pr((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise > "u" ? Ct : Promise,
  "%Proxy%": typeof Proxy > "u" ? Ct : Proxy,
  "%RangeError%": RangeError,
  "%ReferenceError%": ReferenceError,
  "%Reflect%": typeof Reflect > "u" ? Ct : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set > "u" ? Ct : Set,
  "%SetIteratorPrototype%": typeof Set > "u" || !Aa || !pr ? Ct : pr((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? Ct : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": Aa && pr ? pr(""[Symbol.iterator]()) : Ct,
  "%Symbol%": Aa ? Symbol : Ct,
  "%SyntaxError%": io,
  "%ThrowTypeError%": wM,
  "%TypedArray%": EM,
  "%TypeError%": Ka,
  "%Uint8Array%": typeof Uint8Array > "u" ? Ct : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? Ct : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array > "u" ? Ct : Uint16Array,
  "%Uint32Array%": typeof Uint32Array > "u" ? Ct : Uint32Array,
  "%URIError%": URIError,
  "%WeakMap%": typeof WeakMap > "u" ? Ct : WeakMap,
  "%WeakRef%": typeof WeakRef > "u" ? Ct : WeakRef,
  "%WeakSet%": typeof WeakSet > "u" ? Ct : WeakSet
};
if (pr)
  try {
    null.error;
  } catch (e) {
    var xM = pr(pr(e));
    Gs["%Error.prototype%"] = xM;
  }
var OM = function e(t) {
  var r;
  if (t === "%AsyncFunction%")
    r = Tp("async function () {}");
  else if (t === "%GeneratorFunction%")
    r = Tp("function* () {}");
  else if (t === "%AsyncGeneratorFunction%")
    r = Tp("async function* () {}");
  else if (t === "%AsyncGenerator%") {
    var i = e("%AsyncGeneratorFunction%");
    i && (r = i.prototype);
  } else if (t === "%AsyncIteratorPrototype%") {
    var n = e("%AsyncGenerator%");
    n && pr && (r = pr(n.prototype));
  }
  return Gs[t] = r, r;
}, y1 = {
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
}, Yu = yg, af = _M, PM = Yu.call(Function.call, Array.prototype.concat), SM = Yu.call(Function.apply, Array.prototype.splice), g1 = Yu.call(Function.call, String.prototype.replace), of = Yu.call(Function.call, String.prototype.slice), AM = Yu.call(Function.call, RegExp.prototype.exec), CM = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, RM = /\\(\\)?/g, TM = function(t) {
  var r = of(t, 0, 1), i = of(t, -1);
  if (r === "%" && i !== "%")
    throw new io("invalid intrinsic syntax, expected closing `%`");
  if (i === "%" && r !== "%")
    throw new io("invalid intrinsic syntax, expected opening `%`");
  var n = [];
  return g1(t, CM, function(s, a, u, c) {
    n[n.length] = u ? g1(c, RM, "$1") : a || s;
  }), n;
}, IM = function(t, r) {
  var i = t, n;
  if (af(y1, i) && (n = y1[i], i = "%" + n[0] + "%"), af(Gs, i)) {
    var s = Gs[i];
    if (s === La && (s = OM(i)), typeof s > "u" && !r)
      throw new Ka("intrinsic " + t + " exists, but is not available. Please file an issue!");
    return {
      alias: n,
      name: i,
      value: s
    };
  }
  throw new io("intrinsic " + t + " does not exist!");
}, gg = function(t, r) {
  if (typeof t != "string" || t.length === 0)
    throw new Ka("intrinsic name must be a non-empty string");
  if (arguments.length > 1 && typeof r != "boolean")
    throw new Ka('"allowMissing" argument must be a boolean');
  if (AM(/^%?[^%]*%?$/, t) === null)
    throw new io("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  var i = TM(t), n = i.length > 0 ? i[0] : "", s = IM("%" + n + "%", r), a = s.name, u = s.value, c = !1, l = s.alias;
  l && (n = l[0], SM(i, PM([0, 1], l)));
  for (var d = 1, p = !0; d < i.length; d += 1) {
    var h = i[d], v = of(h, 0, 1), y = of(h, -1);
    if ((v === '"' || v === "'" || v === "`" || y === '"' || y === "'" || y === "`") && v !== y)
      throw new io("property names with quotes must have matching quotes");
    if ((h === "constructor" || !p) && (c = !0), n += "." + h, a = "%" + n + "%", af(Gs, a))
      u = Gs[a];
    else if (u != null) {
      if (!(h in u)) {
        if (!r)
          throw new Ka("base intrinsic for " + t + " exists, but the property is not available.");
        return;
      }
      if (Hs && d + 1 >= i.length) {
        var g = Hs(u, h);
        p = !!g, p && "get" in g && !("originalValue" in g.get) ? u = g.get : u = u[h];
      } else
        p = af(u, h), u = u[h];
      p && !c && (Gs[a] = u);
    }
  }
  return u;
}, wE = { exports: {} };
(function(e) {
  var t = yg, r = gg, i = r("%Function.prototype.apply%"), n = r("%Function.prototype.call%"), s = r("%Reflect.apply%", !0) || t.call(n, i), a = r("%Object.getOwnPropertyDescriptor%", !0), u = r("%Object.defineProperty%", !0), c = r("%Math.max%");
  if (u)
    try {
      u({}, "a", { value: 1 });
    } catch {
      u = null;
    }
  e.exports = function(p) {
    var h = s(t, n, arguments);
    if (a && u) {
      var v = a(h, "length");
      v.configurable && u(
        h,
        "length",
        { value: 1 + c(0, p.length - (arguments.length - 1)) }
      );
    }
    return h;
  };
  var l = function() {
    return s(t, i, arguments);
  };
  u ? u(e.exports, "apply", { value: l }) : e.exports.apply = l;
})(wE);
var $E = wE.exports, EE = gg, xE = $E, jM = xE(EE("String.prototype.indexOf")), OE = function(t, r) {
  var i = EE(t, !!r);
  return typeof i == "function" && jM(t, ".prototype.") > -1 ? xE(i) : i;
}, kM = mg(), MM = OE, ly = MM("Object.prototype.toString"), qf = function(t) {
  return kM && t && typeof t == "object" && Symbol.toStringTag in t ? !1 : ly(t) === "[object Arguments]";
}, PE = function(t) {
  return qf(t) ? !0 : t !== null && typeof t == "object" && typeof t.length == "number" && t.length >= 0 && ly(t) !== "[object Array]" && ly(t.callee) === "[object Function]";
}, NM = function() {
  return qf(arguments);
}();
qf.isLegacyArguments = PE;
var DM = NM ? qf : PE, LM = Object.prototype.toString, qM = Function.prototype.toString, FM = /^\s*(?:function)?\*/, SE = mg(), jp = Object.getPrototypeOf, UM = function() {
  if (!SE)
    return !1;
  try {
    return Function("return function*() {}")();
  } catch {
  }
}, kp, BM = function(t) {
  if (typeof t != "function")
    return !1;
  if (FM.test(qM.call(t)))
    return !0;
  if (!SE) {
    var r = LM.call(t);
    return r === "[object GeneratorFunction]";
  }
  if (!jp)
    return !1;
  if (typeof kp > "u") {
    var i = UM();
    kp = i ? jp(i) : !1;
  }
  return jp(t) === kp;
}, AE = Function.prototype.toString, Ba = typeof Reflect == "object" && Reflect !== null && Reflect.apply, fy, Pl;
if (typeof Ba == "function" && typeof Object.defineProperty == "function")
  try {
    fy = Object.defineProperty({}, "length", {
      get: function() {
        throw Pl;
      }
    }), Pl = {}, Ba(function() {
      throw 42;
    }, null, fy);
  } catch (e) {
    e !== Pl && (Ba = null);
  }
else
  Ba = null;
var VM = /^\s*class\b/, dy = function(t) {
  try {
    var r = AE.call(t);
    return VM.test(r);
  } catch {
    return !1;
  }
}, Mp = function(t) {
  try {
    return dy(t) ? !1 : (AE.call(t), !0);
  } catch {
    return !1;
  }
}, Sl = Object.prototype.toString, ZM = "[object Object]", zM = "[object Function]", WM = "[object GeneratorFunction]", HM = "[object HTMLAllCollection]", GM = "[object HTML document.all class]", KM = "[object HTMLCollection]", YM = typeof Symbol == "function" && !!Symbol.toStringTag, JM = !(0 in [,]), py = function() {
  return !1;
};
if (typeof document == "object") {
  var XM = document.all;
  Sl.call(XM) === Sl.call(document.all) && (py = function(t) {
    if ((JM || !t) && (typeof t > "u" || typeof t == "object"))
      try {
        var r = Sl.call(t);
        return (r === HM || r === GM || r === KM || r === ZM) && t("") == null;
      } catch {
      }
    return !1;
  });
}
var QM = Ba ? function(t) {
  if (py(t))
    return !0;
  if (!t || typeof t != "function" && typeof t != "object")
    return !1;
  try {
    Ba(t, null, fy);
  } catch (r) {
    if (r !== Pl)
      return !1;
  }
  return !dy(t) && Mp(t);
} : function(t) {
  if (py(t))
    return !0;
  if (!t || typeof t != "function" && typeof t != "object")
    return !1;
  if (YM)
    return Mp(t);
  if (dy(t))
    return !1;
  var r = Sl.call(t);
  return r !== zM && r !== WM && !/^\[object HTML/.test(r) ? !1 : Mp(t);
}, eN = QM, tN = Object.prototype.toString, CE = Object.prototype.hasOwnProperty, rN = function(t, r, i) {
  for (var n = 0, s = t.length; n < s; n++)
    CE.call(t, n) && (i == null ? r(t[n], n, t) : r.call(i, t[n], n, t));
}, nN = function(t, r, i) {
  for (var n = 0, s = t.length; n < s; n++)
    i == null ? r(t.charAt(n), n, t) : r.call(i, t.charAt(n), n, t);
}, iN = function(t, r, i) {
  for (var n in t)
    CE.call(t, n) && (i == null ? r(t[n], n, t) : r.call(i, t[n], n, t));
}, sN = function(t, r, i) {
  if (!eN(r))
    throw new TypeError("iterator must be a function");
  var n;
  arguments.length >= 3 && (n = i), tN.call(t) === "[object Array]" ? rN(t, r, n) : typeof t == "string" ? nN(t, r, n) : iN(t, r, n);
}, aN = sN, Np = [
  "BigInt64Array",
  "BigUint64Array",
  "Float32Array",
  "Float64Array",
  "Int16Array",
  "Int32Array",
  "Int8Array",
  "Uint16Array",
  "Uint32Array",
  "Uint8Array",
  "Uint8ClampedArray"
], oN = typeof globalThis > "u" ? rt : globalThis, uN = function() {
  for (var t = [], r = 0; r < Np.length; r++)
    typeof oN[Np[r]] == "function" && (t[t.length] = Np[r]);
  return t;
}, cN = gg, Al = cN("%Object.getOwnPropertyDescriptor%", !0);
if (Al)
  try {
    Al([], "length");
  } catch {
    Al = null;
  }
var lN = Al, uf = aN, fN = uN, v1 = $E, vg = OE, Cl = lN, dN = vg("Object.prototype.toString"), RE = mg(), b1 = typeof globalThis > "u" ? rt : globalThis, hy = fN(), bg = vg("String.prototype.slice"), Dp = Object.getPrototypeOf, pN = vg("Array.prototype.indexOf", !0) || function(t, r) {
  for (var i = 0; i < t.length; i += 1)
    if (t[i] === r)
      return i;
  return -1;
}, cf = { __proto__: null };
RE && Cl && Dp ? uf(hy, function(e) {
  var t = new b1[e]();
  if (Symbol.toStringTag in t) {
    var r = Dp(t), i = Cl(r, Symbol.toStringTag);
    if (!i) {
      var n = Dp(r);
      i = Cl(n, Symbol.toStringTag);
    }
    cf["$" + e] = v1(i.get);
  }
}) : uf(hy, function(e) {
  var t = new b1[e]();
  cf["$" + e] = v1(t.slice);
});
var hN = function(t) {
  var r = !1;
  return uf(cf, function(i, n) {
    if (!r)
      try {
        "$" + i(t) === n && (r = bg(n, 1));
      } catch {
      }
  }), r;
}, mN = function(t) {
  var r = !1;
  return uf(cf, function(i, n) {
    if (!r)
      try {
        i(t), r = bg(n, 1);
      } catch {
      }
  }), r;
}, TE = function(t) {
  if (!t || typeof t != "object")
    return !1;
  if (!RE) {
    var r = bg(dN(t), 8, -1);
    return pN(hy, r) > -1 ? r : r !== "Object" ? !1 : mN(t);
  }
  return Cl ? hN(t) : null;
}, yN = TE, gN = function(t) {
  return !!yN(t);
};
(function(e) {
  var t = DM, r = BM, i = TE, n = gN;
  function s(Ee) {
    return Ee.call.bind(Ee);
  }
  var a = typeof BigInt < "u", u = typeof Symbol < "u", c = s(Object.prototype.toString), l = s(Number.prototype.valueOf), d = s(String.prototype.valueOf), p = s(Boolean.prototype.valueOf);
  if (a)
    var h = s(BigInt.prototype.valueOf);
  if (u)
    var v = s(Symbol.prototype.valueOf);
  function y(Ee, Mt) {
    if (typeof Ee != "object")
      return !1;
    try {
      return Mt(Ee), !0;
    } catch {
      return !1;
    }
  }
  e.isArgumentsObject = t, e.isGeneratorFunction = r, e.isTypedArray = n;
  function g(Ee) {
    return typeof Promise < "u" && Ee instanceof Promise || Ee !== null && typeof Ee == "object" && typeof Ee.then == "function" && typeof Ee.catch == "function";
  }
  e.isPromise = g;
  function _(Ee) {
    return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(Ee) : n(Ee) || z(Ee);
  }
  e.isArrayBufferView = _;
  function m(Ee) {
    return i(Ee) === "Uint8Array";
  }
  e.isUint8Array = m;
  function w(Ee) {
    return i(Ee) === "Uint8ClampedArray";
  }
  e.isUint8ClampedArray = w;
  function $(Ee) {
    return i(Ee) === "Uint16Array";
  }
  e.isUint16Array = $;
  function E(Ee) {
    return i(Ee) === "Uint32Array";
  }
  e.isUint32Array = E;
  function A(Ee) {
    return i(Ee) === "Int8Array";
  }
  e.isInt8Array = A;
  function R(Ee) {
    return i(Ee) === "Int16Array";
  }
  e.isInt16Array = R;
  function I(Ee) {
    return i(Ee) === "Int32Array";
  }
  e.isInt32Array = I;
  function D(Ee) {
    return i(Ee) === "Float32Array";
  }
  e.isFloat32Array = D;
  function J(Ee) {
    return i(Ee) === "Float64Array";
  }
  e.isFloat64Array = J;
  function ae(Ee) {
    return i(Ee) === "BigInt64Array";
  }
  e.isBigInt64Array = ae;
  function ye(Ee) {
    return i(Ee) === "BigUint64Array";
  }
  e.isBigUint64Array = ye;
  function xe(Ee) {
    return c(Ee) === "[object Map]";
  }
  xe.working = typeof Map < "u" && xe(/* @__PURE__ */ new Map());
  function je(Ee) {
    return typeof Map > "u" ? !1 : xe.working ? xe(Ee) : Ee instanceof Map;
  }
  e.isMap = je;
  function re(Ee) {
    return c(Ee) === "[object Set]";
  }
  re.working = typeof Set < "u" && re(/* @__PURE__ */ new Set());
  function fe(Ee) {
    return typeof Set > "u" ? !1 : re.working ? re(Ee) : Ee instanceof Set;
  }
  e.isSet = fe;
  function le(Ee) {
    return c(Ee) === "[object WeakMap]";
  }
  le.working = typeof WeakMap < "u" && le(/* @__PURE__ */ new WeakMap());
  function $e(Ee) {
    return typeof WeakMap > "u" ? !1 : le.working ? le(Ee) : Ee instanceof WeakMap;
  }
  e.isWeakMap = $e;
  function Ae(Ee) {
    return c(Ee) === "[object WeakSet]";
  }
  Ae.working = typeof WeakSet < "u" && Ae(/* @__PURE__ */ new WeakSet());
  function _e(Ee) {
    return Ae(Ee);
  }
  e.isWeakSet = _e;
  function ie(Ee) {
    return c(Ee) === "[object ArrayBuffer]";
  }
  ie.working = typeof ArrayBuffer < "u" && ie(new ArrayBuffer());
  function K(Ee) {
    return typeof ArrayBuffer > "u" ? !1 : ie.working ? ie(Ee) : Ee instanceof ArrayBuffer;
  }
  e.isArrayBuffer = K;
  function V(Ee) {
    return c(Ee) === "[object DataView]";
  }
  V.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && V(new DataView(new ArrayBuffer(1), 0, 1));
  function z(Ee) {
    return typeof DataView > "u" ? !1 : V.working ? V(Ee) : Ee instanceof DataView;
  }
  e.isDataView = z;
  var C = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
  function q(Ee) {
    return c(Ee) === "[object SharedArrayBuffer]";
  }
  function N(Ee) {
    return typeof C > "u" ? !1 : (typeof q.working > "u" && (q.working = q(new C())), q.working ? q(Ee) : Ee instanceof C);
  }
  e.isSharedArrayBuffer = N;
  function F(Ee) {
    return c(Ee) === "[object AsyncFunction]";
  }
  e.isAsyncFunction = F;
  function T(Ee) {
    return c(Ee) === "[object Map Iterator]";
  }
  e.isMapIterator = T;
  function Z(Ee) {
    return c(Ee) === "[object Set Iterator]";
  }
  e.isSetIterator = Z;
  function Y(Ee) {
    return c(Ee) === "[object Generator]";
  }
  e.isGeneratorObject = Y;
  function k(Ee) {
    return c(Ee) === "[object WebAssembly.Module]";
  }
  e.isWebAssemblyCompiledModule = k;
  function U(Ee) {
    return y(Ee, l);
  }
  e.isNumberObject = U;
  function pe(Ee) {
    return y(Ee, d);
  }
  e.isStringObject = pe;
  function we(Ee) {
    return y(Ee, p);
  }
  e.isBooleanObject = we;
  function He(Ee) {
    return a && y(Ee, h);
  }
  e.isBigIntObject = He;
  function Fe(Ee) {
    return u && y(Ee, v);
  }
  e.isSymbolObject = Fe;
  function Ge(Ee) {
    return U(Ee) || pe(Ee) || we(Ee) || He(Ee) || Fe(Ee);
  }
  e.isBoxedPrimitive = Ge;
  function jt(Ee) {
    return typeof Uint8Array < "u" && (K(Ee) || N(Ee));
  }
  e.isAnyArrayBuffer = jt, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(Ee) {
    Object.defineProperty(e, Ee, {
      enumerable: !1,
      value: function() {
        throw new Error(Ee + " is not supported in userland");
      }
    });
  });
})(vE);
var vN = function(t) {
  return t && typeof t == "object" && typeof t.copy == "function" && typeof t.fill == "function" && typeof t.readUInt8 == "function";
}, my = { exports: {} };
typeof Object.create == "function" ? my.exports = function(t, r) {
  r && (t.super_ = r, t.prototype = Object.create(r.prototype, {
    constructor: {
      value: t,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }));
} : my.exports = function(t, r) {
  if (r) {
    t.super_ = r;
    var i = function() {
    };
    i.prototype = r.prototype, t.prototype = new i(), t.prototype.constructor = t;
  }
};
var ys = my.exports;
(function(e) {
  var t = Object.getOwnPropertyDescriptors || function(z) {
    for (var C = Object.keys(z), q = {}, N = 0; N < C.length; N++)
      q[C[N]] = Object.getOwnPropertyDescriptor(z, C[N]);
    return q;
  }, r = /%[sdj%]/g;
  e.format = function(V) {
    if (!A(V)) {
      for (var z = [], C = 0; C < arguments.length; C++)
        z.push(a(arguments[C]));
      return z.join(" ");
    }
    for (var C = 1, q = arguments, N = q.length, F = String(V).replace(r, function(Z) {
      if (Z === "%%")
        return "%";
      if (C >= N)
        return Z;
      switch (Z) {
        case "%s":
          return String(q[C++]);
        case "%d":
          return Number(q[C++]);
        case "%j":
          try {
            return JSON.stringify(q[C++]);
          } catch {
            return "[Circular]";
          }
        default:
          return Z;
      }
    }), T = q[C]; C < N; T = q[++C])
      w(T) || !J(T) ? F += " " + T : F += " " + a(T);
    return F;
  }, e.deprecate = function(V, z) {
    if (typeof Me.process < "u" && Me.process.noDeprecation === !0)
      return V;
    if (typeof Me.process > "u")
      return function() {
        return e.deprecate(V, z).apply(this, arguments);
      };
    var C = !1;
    function q() {
      if (!C) {
        if (Me.process.throwDeprecation)
          throw new Error(z);
        Me.process.traceDeprecation ? console.trace(z) : console.error(z), C = !0;
      }
      return V.apply(this, arguments);
    }
    return q;
  };
  var i = {}, n = /^$/;
  if (Me.process.env.NODE_DEBUG) {
    var s = Me.process.env.NODE_DEBUG;
    s = s.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), n = new RegExp("^" + s + "$", "i");
  }
  e.debuglog = function(V) {
    if (V = V.toUpperCase(), !i[V])
      if (n.test(V)) {
        var z = Me.process.pid;
        i[V] = function() {
          var C = e.format.apply(e, arguments);
          console.error("%s %d: %s", V, z, C);
        };
      } else
        i[V] = function() {
        };
    return i[V];
  };
  function a(V, z) {
    var C = {
      seen: [],
      stylize: c
    };
    return arguments.length >= 3 && (C.depth = arguments[2]), arguments.length >= 4 && (C.colors = arguments[3]), m(z) ? C.showHidden = z : z && e._extend(C, z), I(C.showHidden) && (C.showHidden = !1), I(C.depth) && (C.depth = 2), I(C.colors) && (C.colors = !1), I(C.customInspect) && (C.customInspect = !0), C.colors && (C.stylize = u), d(C, V, C.depth);
  }
  e.inspect = a, a.colors = {
    bold: [1, 22],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    white: [37, 39],
    grey: [90, 39],
    black: [30, 39],
    blue: [34, 39],
    cyan: [36, 39],
    green: [32, 39],
    magenta: [35, 39],
    red: [31, 39],
    yellow: [33, 39]
  }, a.styles = {
    special: "cyan",
    number: "yellow",
    boolean: "yellow",
    undefined: "grey",
    null: "bold",
    string: "green",
    date: "magenta",
    // "name": intentionally not styling
    regexp: "red"
  };
  function u(V, z) {
    var C = a.styles[z];
    return C ? "\x1B[" + a.colors[C][0] + "m" + V + "\x1B[" + a.colors[C][1] + "m" : V;
  }
  function c(V, z) {
    return V;
  }
  function l(V) {
    var z = {};
    return V.forEach(function(C, q) {
      z[C] = !0;
    }), z;
  }
  function d(V, z, C) {
    if (V.customInspect && z && xe(z.inspect) && // Filter out the util module, it's inspect function is special
    z.inspect !== e.inspect && // Also filter out any prototype objects using the circular check.
    !(z.constructor && z.constructor.prototype === z)) {
      var q = z.inspect(C, V);
      return A(q) || (q = d(V, q, C)), q;
    }
    var N = p(V, z);
    if (N)
      return N;
    var F = Object.keys(z), T = l(F);
    if (V.showHidden && (F = Object.getOwnPropertyNames(z)), ye(z) && (F.indexOf("message") >= 0 || F.indexOf("description") >= 0))
      return h(z);
    if (F.length === 0) {
      if (xe(z)) {
        var Z = z.name ? ": " + z.name : "";
        return V.stylize("[Function" + Z + "]", "special");
      }
      if (D(z))
        return V.stylize(RegExp.prototype.toString.call(z), "regexp");
      if (ae(z))
        return V.stylize(Date.prototype.toString.call(z), "date");
      if (ye(z))
        return h(z);
    }
    var Y = "", k = !1, U = ["{", "}"];
    if (_(z) && (k = !0, U = ["[", "]"]), xe(z)) {
      var pe = z.name ? ": " + z.name : "";
      Y = " [Function" + pe + "]";
    }
    if (D(z) && (Y = " " + RegExp.prototype.toString.call(z)), ae(z) && (Y = " " + Date.prototype.toUTCString.call(z)), ye(z) && (Y = " " + h(z)), F.length === 0 && (!k || z.length == 0))
      return U[0] + Y + U[1];
    if (C < 0)
      return D(z) ? V.stylize(RegExp.prototype.toString.call(z), "regexp") : V.stylize("[Object]", "special");
    V.seen.push(z);
    var we;
    return k ? we = v(V, z, C, T, F) : we = F.map(function(He) {
      return y(V, z, C, T, He, k);
    }), V.seen.pop(), g(we, Y, U);
  }
  function p(V, z) {
    if (I(z))
      return V.stylize("undefined", "undefined");
    if (A(z)) {
      var C = "'" + JSON.stringify(z).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return V.stylize(C, "string");
    }
    if (E(z))
      return V.stylize("" + z, "number");
    if (m(z))
      return V.stylize("" + z, "boolean");
    if (w(z))
      return V.stylize("null", "null");
  }
  function h(V) {
    return "[" + Error.prototype.toString.call(V) + "]";
  }
  function v(V, z, C, q, N) {
    for (var F = [], T = 0, Z = z.length; T < Z; ++T)
      Ae(z, String(T)) ? F.push(y(
        V,
        z,
        C,
        q,
        String(T),
        !0
      )) : F.push("");
    return N.forEach(function(Y) {
      Y.match(/^\d+$/) || F.push(y(
        V,
        z,
        C,
        q,
        Y,
        !0
      ));
    }), F;
  }
  function y(V, z, C, q, N, F) {
    var T, Z, Y;
    if (Y = Object.getOwnPropertyDescriptor(z, N) || { value: z[N] }, Y.get ? Y.set ? Z = V.stylize("[Getter/Setter]", "special") : Z = V.stylize("[Getter]", "special") : Y.set && (Z = V.stylize("[Setter]", "special")), Ae(q, N) || (T = "[" + N + "]"), Z || (V.seen.indexOf(Y.value) < 0 ? (w(C) ? Z = d(V, Y.value, null) : Z = d(V, Y.value, C - 1), Z.indexOf(`
`) > -1 && (F ? Z = Z.split(`
`).map(function(k) {
      return "  " + k;
    }).join(`
`).slice(2) : Z = `
` + Z.split(`
`).map(function(k) {
      return "   " + k;
    }).join(`
`))) : Z = V.stylize("[Circular]", "special")), I(T)) {
      if (F && N.match(/^\d+$/))
        return Z;
      T = JSON.stringify("" + N), T.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (T = T.slice(1, -1), T = V.stylize(T, "name")) : (T = T.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), T = V.stylize(T, "string"));
    }
    return T + ": " + Z;
  }
  function g(V, z, C) {
    var q = V.reduce(function(N, F) {
      return F.indexOf(`
`) >= 0, N + F.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    return q > 60 ? C[0] + (z === "" ? "" : z + `
 `) + " " + V.join(`,
  `) + " " + C[1] : C[0] + z + " " + V.join(", ") + " " + C[1];
  }
  e.types = vE;
  function _(V) {
    return Array.isArray(V);
  }
  e.isArray = _;
  function m(V) {
    return typeof V == "boolean";
  }
  e.isBoolean = m;
  function w(V) {
    return V === null;
  }
  e.isNull = w;
  function $(V) {
    return V == null;
  }
  e.isNullOrUndefined = $;
  function E(V) {
    return typeof V == "number";
  }
  e.isNumber = E;
  function A(V) {
    return typeof V == "string";
  }
  e.isString = A;
  function R(V) {
    return typeof V == "symbol";
  }
  e.isSymbol = R;
  function I(V) {
    return V === void 0;
  }
  e.isUndefined = I;
  function D(V) {
    return J(V) && re(V) === "[object RegExp]";
  }
  e.isRegExp = D, e.types.isRegExp = D;
  function J(V) {
    return typeof V == "object" && V !== null;
  }
  e.isObject = J;
  function ae(V) {
    return J(V) && re(V) === "[object Date]";
  }
  e.isDate = ae, e.types.isDate = ae;
  function ye(V) {
    return J(V) && (re(V) === "[object Error]" || V instanceof Error);
  }
  e.isError = ye, e.types.isNativeError = ye;
  function xe(V) {
    return typeof V == "function";
  }
  e.isFunction = xe;
  function je(V) {
    return V === null || typeof V == "boolean" || typeof V == "number" || typeof V == "string" || typeof V == "symbol" || // ES6 symbol
    typeof V > "u";
  }
  e.isPrimitive = je, e.isBuffer = vN;
  function re(V) {
    return Object.prototype.toString.call(V);
  }
  function fe(V) {
    return V < 10 ? "0" + V.toString(10) : V.toString(10);
  }
  var le = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ];
  function $e() {
    var V = /* @__PURE__ */ new Date(), z = [
      fe(V.getHours()),
      fe(V.getMinutes()),
      fe(V.getSeconds())
    ].join(":");
    return [V.getDate(), le[V.getMonth()], z].join(" ");
  }
  e.log = function() {
    console.log("%s - %s", $e(), e.format.apply(e, arguments));
  }, e.inherits = ys, e._extend = function(V, z) {
    if (!z || !J(z))
      return V;
    for (var C = Object.keys(z), q = C.length; q--; )
      V[C[q]] = z[C[q]];
    return V;
  };
  function Ae(V, z) {
    return Object.prototype.hasOwnProperty.call(V, z);
  }
  var _e = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
  e.promisify = function(z) {
    if (typeof z != "function")
      throw new TypeError('The "original" argument must be of type Function');
    if (_e && z[_e]) {
      var C = z[_e];
      if (typeof C != "function")
        throw new TypeError('The "util.promisify.custom" argument must be of type Function');
      return Object.defineProperty(C, _e, {
        value: C,
        enumerable: !1,
        writable: !1,
        configurable: !0
      }), C;
    }
    function C() {
      for (var q, N, F = new Promise(function(Y, k) {
        q = Y, N = k;
      }), T = [], Z = 0; Z < arguments.length; Z++)
        T.push(arguments[Z]);
      T.push(function(Y, k) {
        Y ? N(Y) : q(k);
      });
      try {
        z.apply(this, T);
      } catch (Y) {
        N(Y);
      }
      return F;
    }
    return Object.setPrototypeOf(C, Object.getPrototypeOf(z)), _e && Object.defineProperty(C, _e, {
      value: C,
      enumerable: !1,
      writable: !1,
      configurable: !0
    }), Object.defineProperties(
      C,
      t(z)
    );
  }, e.promisify.custom = _e;
  function ie(V, z) {
    if (!V) {
      var C = new Error("Promise was rejected with a falsy value");
      C.reason = V, V = C;
    }
    return z(V);
  }
  function K(V) {
    if (typeof V != "function")
      throw new TypeError('The "original" argument must be of type Function');
    function z() {
      for (var C = [], q = 0; q < arguments.length; q++)
        C.push(arguments[q]);
      var N = C.pop();
      if (typeof N != "function")
        throw new TypeError("The last argument must be of type Function");
      var F = this, T = function() {
        return N.apply(F, arguments);
      };
      V.apply(this, C).then(
        function(Z) {
          Me.process.nextTick(T.bind(null, null, Z));
        },
        function(Z) {
          Me.process.nextTick(ie.bind(null, Z, T));
        }
      );
    }
    return Object.setPrototypeOf(z, Object.getPrototypeOf(V)), Object.defineProperties(
      z,
      t(V)
    ), z;
  }
  e.callbackify = K;
})(fo);
var _g = { exports: {} }, Ya = typeof Reflect == "object" ? Reflect : null, _1 = Ya && typeof Ya.apply == "function" ? Ya.apply : function(t, r, i) {
  return Function.prototype.apply.call(t, r, i);
}, Rl;
Ya && typeof Ya.ownKeys == "function" ? Rl = Ya.ownKeys : Object.getOwnPropertySymbols ? Rl = function(t) {
  return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t));
} : Rl = function(t) {
  return Object.getOwnPropertyNames(t);
};
function bN(e) {
  console && console.warn && console.warn(e);
}
var IE = Number.isNaN || function(t) {
  return t !== t;
};
function Vt() {
  Vt.init.call(this);
}
_g.exports = Vt;
_g.exports.once = EN;
Vt.EventEmitter = Vt;
Vt.prototype._events = void 0;
Vt.prototype._eventsCount = 0;
Vt.prototype._maxListeners = void 0;
var w1 = 10;
function Ff(e) {
  if (typeof e != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e);
}
Object.defineProperty(Vt, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return w1;
  },
  set: function(e) {
    if (typeof e != "number" || e < 0 || IE(e))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e + ".");
    w1 = e;
  }
});
Vt.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
Vt.prototype.setMaxListeners = function(t) {
  if (typeof t != "number" || t < 0 || IE(t))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
  return this._maxListeners = t, this;
};
function jE(e) {
  return e._maxListeners === void 0 ? Vt.defaultMaxListeners : e._maxListeners;
}
Vt.prototype.getMaxListeners = function() {
  return jE(this);
};
Vt.prototype.emit = function(t) {
  for (var r = [], i = 1; i < arguments.length; i++)
    r.push(arguments[i]);
  var n = t === "error", s = this._events;
  if (s !== void 0)
    n = n && s.error === void 0;
  else if (!n)
    return !1;
  if (n) {
    var a;
    if (r.length > 0 && (a = r[0]), a instanceof Error)
      throw a;
    var u = new Error("Unhandled error." + (a ? " (" + a.message + ")" : ""));
    throw u.context = a, u;
  }
  var c = s[t];
  if (c === void 0)
    return !1;
  if (typeof c == "function")
    _1(c, this, r);
  else
    for (var l = c.length, d = LE(c, l), i = 0; i < l; ++i)
      _1(d[i], this, r);
  return !0;
};
function kE(e, t, r, i) {
  var n, s, a;
  if (Ff(r), s = e._events, s === void 0 ? (s = e._events = /* @__PURE__ */ Object.create(null), e._eventsCount = 0) : (s.newListener !== void 0 && (e.emit(
    "newListener",
    t,
    r.listener ? r.listener : r
  ), s = e._events), a = s[t]), a === void 0)
    a = s[t] = r, ++e._eventsCount;
  else if (typeof a == "function" ? a = s[t] = i ? [r, a] : [a, r] : i ? a.unshift(r) : a.push(r), n = jE(e), n > 0 && a.length > n && !a.warned) {
    a.warned = !0;
    var u = new Error("Possible EventEmitter memory leak detected. " + a.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    u.name = "MaxListenersExceededWarning", u.emitter = e, u.type = t, u.count = a.length, bN(u);
  }
  return e;
}
Vt.prototype.addListener = function(t, r) {
  return kE(this, t, r, !1);
};
Vt.prototype.on = Vt.prototype.addListener;
Vt.prototype.prependListener = function(t, r) {
  return kE(this, t, r, !0);
};
function _N() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function ME(e, t, r) {
  var i = { fired: !1, wrapFn: void 0, target: e, type: t, listener: r }, n = _N.bind(i);
  return n.listener = r, i.wrapFn = n, n;
}
Vt.prototype.once = function(t, r) {
  return Ff(r), this.on(t, ME(this, t, r)), this;
};
Vt.prototype.prependOnceListener = function(t, r) {
  return Ff(r), this.prependListener(t, ME(this, t, r)), this;
};
Vt.prototype.removeListener = function(t, r) {
  var i, n, s, a, u;
  if (Ff(r), n = this._events, n === void 0)
    return this;
  if (i = n[t], i === void 0)
    return this;
  if (i === r || i.listener === r)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete n[t], n.removeListener && this.emit("removeListener", t, i.listener || r));
  else if (typeof i != "function") {
    for (s = -1, a = i.length - 1; a >= 0; a--)
      if (i[a] === r || i[a].listener === r) {
        u = i[a].listener, s = a;
        break;
      }
    if (s < 0)
      return this;
    s === 0 ? i.shift() : wN(i, s), i.length === 1 && (n[t] = i[0]), n.removeListener !== void 0 && this.emit("removeListener", t, u || r);
  }
  return this;
};
Vt.prototype.off = Vt.prototype.removeListener;
Vt.prototype.removeAllListeners = function(t) {
  var r, i, n;
  if (i = this._events, i === void 0)
    return this;
  if (i.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : i[t] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete i[t]), this;
  if (arguments.length === 0) {
    var s = Object.keys(i), a;
    for (n = 0; n < s.length; ++n)
      a = s[n], a !== "removeListener" && this.removeAllListeners(a);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (r = i[t], typeof r == "function")
    this.removeListener(t, r);
  else if (r !== void 0)
    for (n = r.length - 1; n >= 0; n--)
      this.removeListener(t, r[n]);
  return this;
};
function NE(e, t, r) {
  var i = e._events;
  if (i === void 0)
    return [];
  var n = i[t];
  return n === void 0 ? [] : typeof n == "function" ? r ? [n.listener || n] : [n] : r ? $N(n) : LE(n, n.length);
}
Vt.prototype.listeners = function(t) {
  return NE(this, t, !0);
};
Vt.prototype.rawListeners = function(t) {
  return NE(this, t, !1);
};
Vt.listenerCount = function(e, t) {
  return typeof e.listenerCount == "function" ? e.listenerCount(t) : DE.call(e, t);
};
Vt.prototype.listenerCount = DE;
function DE(e) {
  var t = this._events;
  if (t !== void 0) {
    var r = t[e];
    if (typeof r == "function")
      return 1;
    if (r !== void 0)
      return r.length;
  }
  return 0;
}
Vt.prototype.eventNames = function() {
  return this._eventsCount > 0 ? Rl(this._events) : [];
};
function LE(e, t) {
  for (var r = new Array(t), i = 0; i < t; ++i)
    r[i] = e[i];
  return r;
}
function wN(e, t) {
  for (; t + 1 < e.length; t++)
    e[t] = e[t + 1];
  e.pop();
}
function $N(e) {
  for (var t = new Array(e.length), r = 0; r < t.length; ++r)
    t[r] = e[r].listener || e[r];
  return t;
}
function EN(e, t) {
  return new Promise(function(r, i) {
    function n(a) {
      e.removeListener(t, s), i(a);
    }
    function s() {
      typeof e.removeListener == "function" && e.removeListener("error", n), r([].slice.call(arguments));
    }
    qE(e, t, s, { once: !0 }), t !== "error" && xN(e, n, { once: !0 });
  });
}
function xN(e, t, r) {
  typeof e.on == "function" && qE(e, "error", t, r);
}
function qE(e, t, r, i) {
  if (typeof e.on == "function")
    i.once ? e.once(t, r) : e.on(t, r);
  else if (typeof e.addEventListener == "function")
    e.addEventListener(t, function n(s) {
      i.once && e.removeEventListener(t, n), r(s);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e);
}
var wg = _g.exports, ON = fo, PN = wg;
function gs(e) {
  e = e || {}, this._store = {}, this._size = 0, this._ttl = Number(e.ttl), this._capacity = 1 / 0, this.setCapacity(e.capacity);
}
ON.inherits(gs, PN.EventEmitter);
gs.prototype.put = function(e, t, r) {
  if (!(e === void 0 || t === void 0)) {
    if (!this._store[e] && this.size() >= this._capacity) {
      this.emit("drop", e, t, r);
      return;
    }
    r = r === void 0 ? this._ttl : Number(r), this.del(e), this._store[e] = {
      val: t,
      expire: FE() + r,
      timeout: setTimeout((function() {
        this.del(e);
      }).bind(this), r)
    }, this._store[e].timeout.unref(), this._size += 1, this.emit("put", e, t, r);
  }
};
gs.prototype.get = function(e) {
  var t = this._store[e];
  return t ? t.expire && t.expire > FE() ? this.emit("hit", e, t.val) : (this.del(e), this.emit("miss", e), t = void 0) : this.emit("miss", e), t && t.val;
};
gs.prototype.del = function(e) {
  if (this._store[e]) {
    var t = this._store[e].val;
    return clearTimeout(this._store[e].timeout), delete this._store[e], this._size -= 1, this.emit("del", e, t), t;
  }
};
gs.prototype.clear = function() {
  Object.keys(this._store).forEach((function(e) {
    this.del(e);
  }).bind(this));
};
gs.prototype.size = function(e) {
  return e ? Object.keys(this._store).reduce((function(t, r) {
    return t + (this.get(r) !== void 0 ? 1 : 0);
  }).bind(this), 0) : this._size;
};
gs.prototype.setCapacity = function(e) {
  typeof e == "number" && e >= 0 && (this._capacity = e);
};
function FE() {
  return Date.now();
}
var SN = gs;
const Ju = /* @__PURE__ */ ta(SN);
let Uf = (e = 21) => crypto.getRandomValues(new Uint8Array(e)).reduce((t, r) => (r &= 63, r < 36 ? t += r.toString(36) : r < 62 ? t += (r - 26).toString(36).toUpperCase() : r > 62 ? t += "-" : t += "_", t), "");
var UE = {}, Qs = {}, $g = {};
Object.defineProperty($g, "__esModule", { value: !0 });
const $1 = (e) => {
  if (typeof e == "object" && e !== null) {
    if (typeof Object.getPrototypeOf == "function") {
      const t = Object.getPrototypeOf(e);
      return t === Object.prototype || t === null;
    }
    return Object.prototype.toString.call(e) === "[object Object]";
  }
  return !1;
}, Jn = (...e) => e.reduce((t, r) => {
  if (Array.isArray(r))
    throw new TypeError("Arguments provided to ts-deepmerge must be objects, not arrays.");
  return Object.keys(r).forEach((i) => {
    ["__proto__", "constructor", "prototype"].includes(i) || (Array.isArray(t[i]) && Array.isArray(r[i]) ? t[i] = Jn.options.mergeArrays ? Jn.options.uniqueArrayItems ? Array.from(new Set(t[i].concat(r[i]))) : [...t[i], ...r[i]] : r[i] : $1(t[i]) && $1(r[i]) ? t[i] = Jn(t[i], r[i]) : t[i] = r[i] === void 0 ? Jn.options.allowUndefinedOverrides ? r[i] : t[i] : r[i]);
  }), t;
}, {}), yy = {
  allowUndefinedOverrides: !0,
  mergeArrays: !0,
  uniqueArrayItems: !0
};
Jn.options = yy;
Jn.withOptions = (e, ...t) => {
  Jn.options = Object.assign(Object.assign({}, yy), e);
  const r = Jn(...t);
  return Jn.options = yy, r;
};
$g.default = Jn;
var BE = {}, gy = {}, Qn = {}, Bf = {}, Xu = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.getParsedType = e.ZodParsedType = e.objectUtil = e.util = void 0;
  var t;
  (function(i) {
    i.assertEqual = (u) => u;
    function n(u) {
    }
    i.assertIs = n;
    function s(u) {
      throw new Error();
    }
    i.assertNever = s, i.arrayToEnum = (u) => {
      const c = {};
      for (const l of u)
        c[l] = l;
      return c;
    }, i.getValidEnumValues = (u) => {
      const c = i.objectKeys(u).filter((d) => typeof u[u[d]] != "number"), l = {};
      for (const d of c)
        l[d] = u[d];
      return i.objectValues(l);
    }, i.objectValues = (u) => i.objectKeys(u).map(function(c) {
      return u[c];
    }), i.objectKeys = typeof Object.keys == "function" ? (u) => Object.keys(u) : (u) => {
      const c = [];
      for (const l in u)
        Object.prototype.hasOwnProperty.call(u, l) && c.push(l);
      return c;
    }, i.find = (u, c) => {
      for (const l of u)
        if (c(l))
          return l;
    }, i.isInteger = typeof Number.isInteger == "function" ? (u) => Number.isInteger(u) : (u) => typeof u == "number" && isFinite(u) && Math.floor(u) === u;
    function a(u, c = " | ") {
      return u.map((l) => typeof l == "string" ? `'${l}'` : l).join(c);
    }
    i.joinValues = a, i.jsonStringifyReplacer = (u, c) => typeof c == "bigint" ? c.toString() : c;
  })(t = e.util || (e.util = {})), function(i) {
    i.mergeShapes = (n, s) => ({
      ...n,
      ...s
    });
  }(e.objectUtil || (e.objectUtil = {})), e.ZodParsedType = t.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set"
  ]);
  const r = (i) => {
    switch (typeof i) {
      case "undefined":
        return e.ZodParsedType.undefined;
      case "string":
        return e.ZodParsedType.string;
      case "number":
        return isNaN(i) ? e.ZodParsedType.nan : e.ZodParsedType.number;
      case "boolean":
        return e.ZodParsedType.boolean;
      case "function":
        return e.ZodParsedType.function;
      case "bigint":
        return e.ZodParsedType.bigint;
      case "symbol":
        return e.ZodParsedType.symbol;
      case "object":
        return Array.isArray(i) ? e.ZodParsedType.array : i === null ? e.ZodParsedType.null : i.then && typeof i.then == "function" && i.catch && typeof i.catch == "function" ? e.ZodParsedType.promise : typeof Map < "u" && i instanceof Map ? e.ZodParsedType.map : typeof Set < "u" && i instanceof Set ? e.ZodParsedType.set : typeof Date < "u" && i instanceof Date ? e.ZodParsedType.date : e.ZodParsedType.object;
      default:
        return e.ZodParsedType.unknown;
    }
  };
  e.getParsedType = r;
})(Xu);
var ei = {};
Object.defineProperty(ei, "__esModule", { value: !0 });
ei.ZodError = ei.quotelessJson = ei.ZodIssueCode = void 0;
const VE = Xu;
ei.ZodIssueCode = VE.util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
const AN = (e) => JSON.stringify(e, null, 2).replace(/"([^"]+)":/g, "$1:");
ei.quotelessJson = AN;
class vy extends Error {
  constructor(t) {
    super(), this.issues = [], this.addIssue = (i) => {
      this.issues = [...this.issues, i];
    }, this.addIssues = (i = []) => {
      this.issues = [...this.issues, ...i];
    };
    const r = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, r) : this.__proto__ = r, this.name = "ZodError", this.issues = t;
  }
  get errors() {
    return this.issues;
  }
  format(t) {
    const r = t || function(s) {
      return s.message;
    }, i = { _errors: [] }, n = (s) => {
      for (const a of s.issues)
        if (a.code === "invalid_union")
          a.unionErrors.map(n);
        else if (a.code === "invalid_return_type")
          n(a.returnTypeError);
        else if (a.code === "invalid_arguments")
          n(a.argumentsError);
        else if (a.path.length === 0)
          i._errors.push(r(a));
        else {
          let u = i, c = 0;
          for (; c < a.path.length; ) {
            const l = a.path[c];
            c === a.path.length - 1 ? (u[l] = u[l] || { _errors: [] }, u[l]._errors.push(r(a))) : u[l] = u[l] || { _errors: [] }, u = u[l], c++;
          }
        }
    };
    return n(this), i;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, VE.util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(t = (r) => r.message) {
    const r = {}, i = [];
    for (const n of this.issues)
      n.path.length > 0 ? (r[n.path[0]] = r[n.path[0]] || [], r[n.path[0]].push(t(n))) : i.push(t(n));
    return { formErrors: i, fieldErrors: r };
  }
  get formErrors() {
    return this.flatten();
  }
}
ei.ZodError = vy;
vy.create = (e) => new vy(e);
Object.defineProperty(Bf, "__esModule", { value: !0 });
const Ms = Xu, Er = ei, CN = (e, t) => {
  let r;
  switch (e.code) {
    case Er.ZodIssueCode.invalid_type:
      e.received === Ms.ZodParsedType.undefined ? r = "Required" : r = `Expected ${e.expected}, received ${e.received}`;
      break;
    case Er.ZodIssueCode.invalid_literal:
      r = `Invalid literal value, expected ${JSON.stringify(e.expected, Ms.util.jsonStringifyReplacer)}`;
      break;
    case Er.ZodIssueCode.unrecognized_keys:
      r = `Unrecognized key(s) in object: ${Ms.util.joinValues(e.keys, ", ")}`;
      break;
    case Er.ZodIssueCode.invalid_union:
      r = "Invalid input";
      break;
    case Er.ZodIssueCode.invalid_union_discriminator:
      r = `Invalid discriminator value. Expected ${Ms.util.joinValues(e.options)}`;
      break;
    case Er.ZodIssueCode.invalid_enum_value:
      r = `Invalid enum value. Expected ${Ms.util.joinValues(e.options)}, received '${e.received}'`;
      break;
    case Er.ZodIssueCode.invalid_arguments:
      r = "Invalid function arguments";
      break;
    case Er.ZodIssueCode.invalid_return_type:
      r = "Invalid function return type";
      break;
    case Er.ZodIssueCode.invalid_date:
      r = "Invalid date";
      break;
    case Er.ZodIssueCode.invalid_string:
      typeof e.validation == "object" ? "includes" in e.validation ? (r = `Invalid input: must include "${e.validation.includes}"`, typeof e.validation.position == "number" && (r = `${r} at one or more positions greater than or equal to ${e.validation.position}`)) : "startsWith" in e.validation ? r = `Invalid input: must start with "${e.validation.startsWith}"` : "endsWith" in e.validation ? r = `Invalid input: must end with "${e.validation.endsWith}"` : Ms.util.assertNever(e.validation) : e.validation !== "regex" ? r = `Invalid ${e.validation}` : r = "Invalid";
      break;
    case Er.ZodIssueCode.too_small:
      e.type === "array" ? r = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "more than"} ${e.minimum} element(s)` : e.type === "string" ? r = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "over"} ${e.minimum} character(s)` : e.type === "number" ? r = `Number must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${e.minimum}` : e.type === "date" ? r = `Date must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(e.minimum))}` : r = "Invalid input";
      break;
    case Er.ZodIssueCode.too_big:
      e.type === "array" ? r = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "less than"} ${e.maximum} element(s)` : e.type === "string" ? r = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "under"} ${e.maximum} character(s)` : e.type === "number" ? r = `Number must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "bigint" ? r = `BigInt must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "date" ? r = `Date must be ${e.exact ? "exactly" : e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(e.maximum))}` : r = "Invalid input";
      break;
    case Er.ZodIssueCode.custom:
      r = "Invalid input";
      break;
    case Er.ZodIssueCode.invalid_intersection_types:
      r = "Intersection results could not be merged";
      break;
    case Er.ZodIssueCode.not_multiple_of:
      r = `Number must be a multiple of ${e.multipleOf}`;
      break;
    case Er.ZodIssueCode.not_finite:
      r = "Number must be finite";
      break;
    default:
      r = t.defaultError, Ms.util.assertNever(e);
  }
  return { message: r };
};
Bf.default = CN;
var RN = rt && rt.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Qn, "__esModule", { value: !0 });
Qn.getErrorMap = Qn.setErrorMap = Qn.defaultErrorMap = void 0;
const ZE = RN(Bf);
Qn.defaultErrorMap = ZE.default;
let zE = ZE.default;
function TN(e) {
  zE = e;
}
Qn.setErrorMap = TN;
function IN() {
  return zE;
}
Qn.getErrorMap = IN;
var Eg = {};
(function(e) {
  var t = rt && rt.__importDefault || function(v) {
    return v && v.__esModule ? v : { default: v };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.isAsync = e.isValid = e.isDirty = e.isAborted = e.OK = e.DIRTY = e.INVALID = e.ParseStatus = e.addIssueToContext = e.EMPTY_PATH = e.makeIssue = void 0;
  const r = Qn, i = t(Bf), n = (v) => {
    const { data: y, path: g, errorMaps: _, issueData: m } = v, w = [...g, ...m.path || []], $ = {
      ...m,
      path: w
    };
    let E = "";
    const A = _.filter((R) => !!R).slice().reverse();
    for (const R of A)
      E = R($, { data: y, defaultError: E }).message;
    return {
      ...m,
      path: w,
      message: m.message || E
    };
  };
  e.makeIssue = n, e.EMPTY_PATH = [];
  function s(v, y) {
    const g = (0, e.makeIssue)({
      issueData: y,
      data: v.data,
      path: v.path,
      errorMaps: [
        v.common.contextualErrorMap,
        v.schemaErrorMap,
        (0, r.getErrorMap)(),
        i.default
      ].filter((_) => !!_)
    });
    v.common.issues.push(g);
  }
  e.addIssueToContext = s;
  class a {
    constructor() {
      this.value = "valid";
    }
    dirty() {
      this.value === "valid" && (this.value = "dirty");
    }
    abort() {
      this.value !== "aborted" && (this.value = "aborted");
    }
    static mergeArray(y, g) {
      const _ = [];
      for (const m of g) {
        if (m.status === "aborted")
          return e.INVALID;
        m.status === "dirty" && y.dirty(), _.push(m.value);
      }
      return { status: y.value, value: _ };
    }
    static async mergeObjectAsync(y, g) {
      const _ = [];
      for (const m of g)
        _.push({
          key: await m.key,
          value: await m.value
        });
      return a.mergeObjectSync(y, _);
    }
    static mergeObjectSync(y, g) {
      const _ = {};
      for (const m of g) {
        const { key: w, value: $ } = m;
        if (w.status === "aborted" || $.status === "aborted")
          return e.INVALID;
        w.status === "dirty" && y.dirty(), $.status === "dirty" && y.dirty(), w.value !== "__proto__" && (typeof $.value < "u" || m.alwaysSet) && (_[w.value] = $.value);
      }
      return { status: y.value, value: _ };
    }
  }
  e.ParseStatus = a, e.INVALID = Object.freeze({
    status: "aborted"
  });
  const u = (v) => ({ status: "dirty", value: v });
  e.DIRTY = u;
  const c = (v) => ({ status: "valid", value: v });
  e.OK = c;
  const l = (v) => v.status === "aborted";
  e.isAborted = l;
  const d = (v) => v.status === "dirty";
  e.isDirty = d;
  const p = (v) => v.status === "valid";
  e.isValid = p;
  const h = (v) => typeof Promise < "u" && v instanceof Promise;
  e.isAsync = h;
})(Eg);
var WE = {};
Object.defineProperty(WE, "__esModule", { value: !0 });
var HE = {}, GE = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.errorUtil = void 0, function(t) {
    t.errToObj = (r) => typeof r == "string" ? { message: r } : r || {}, t.toString = (r) => typeof r == "string" ? r : r == null ? void 0 : r.message;
  }(e.errorUtil || (e.errorUtil = {}));
})(GE);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.date = e.boolean = e.bigint = e.array = e.any = e.coerce = e.ZodFirstPartyTypeKind = e.late = e.ZodSchema = e.Schema = e.custom = e.ZodReadonly = e.ZodPipeline = e.ZodBranded = e.BRAND = e.ZodNaN = e.ZodCatch = e.ZodDefault = e.ZodNullable = e.ZodOptional = e.ZodTransformer = e.ZodEffects = e.ZodPromise = e.ZodNativeEnum = e.ZodEnum = e.ZodLiteral = e.ZodLazy = e.ZodFunction = e.ZodSet = e.ZodMap = e.ZodRecord = e.ZodTuple = e.ZodIntersection = e.ZodDiscriminatedUnion = e.ZodUnion = e.ZodObject = e.ZodArray = e.ZodVoid = e.ZodNever = e.ZodUnknown = e.ZodAny = e.ZodNull = e.ZodUndefined = e.ZodSymbol = e.ZodDate = e.ZodBoolean = e.ZodBigInt = e.ZodNumber = e.ZodString = e.ZodType = void 0, e.NEVER = e.void = e.unknown = e.union = e.undefined = e.tuple = e.transformer = e.symbol = e.string = e.strictObject = e.set = e.record = e.promise = e.preprocess = e.pipeline = e.ostring = e.optional = e.onumber = e.oboolean = e.object = e.number = e.nullable = e.null = e.never = e.nativeEnum = e.nan = e.map = e.literal = e.lazy = e.intersection = e.instanceof = e.function = e.enum = e.effect = e.discriminatedUnion = void 0;
  const t = Qn, r = GE, i = Eg, n = Xu, s = ei;
  class a {
    constructor(O, j, W, ne) {
      this._cachedPath = [], this.parent = O, this.data = j, this._path = W, this._key = ne;
    }
    get path() {
      return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
    }
  }
  const u = (Q, O) => {
    if ((0, i.isValid)(O))
      return { success: !0, data: O.value };
    if (!Q.common.issues.length)
      throw new Error("Validation failed but no issues detected.");
    return {
      success: !1,
      get error() {
        if (this._error)
          return this._error;
        const j = new s.ZodError(Q.common.issues);
        return this._error = j, this._error;
      }
    };
  };
  function c(Q) {
    if (!Q)
      return {};
    const { errorMap: O, invalid_type_error: j, required_error: W, description: ne } = Q;
    if (O && (j || W))
      throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    return O ? { errorMap: O, description: ne } : { errorMap: (Ie, Se) => Ie.code !== "invalid_type" ? { message: Se.defaultError } : typeof Se.data > "u" ? { message: W ?? Se.defaultError } : { message: j ?? Se.defaultError }, description: ne };
  }
  class l {
    constructor(O) {
      this.spa = this.safeParseAsync, this._def = O, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
    }
    get description() {
      return this._def.description;
    }
    _getType(O) {
      return (0, n.getParsedType)(O.data);
    }
    _getOrReturnCtx(O, j) {
      return j || {
        common: O.parent.common,
        data: O.data,
        parsedType: (0, n.getParsedType)(O.data),
        schemaErrorMap: this._def.errorMap,
        path: O.path,
        parent: O.parent
      };
    }
    _processInputParams(O) {
      return {
        status: new i.ParseStatus(),
        ctx: {
          common: O.parent.common,
          data: O.data,
          parsedType: (0, n.getParsedType)(O.data),
          schemaErrorMap: this._def.errorMap,
          path: O.path,
          parent: O.parent
        }
      };
    }
    _parseSync(O) {
      const j = this._parse(O);
      if ((0, i.isAsync)(j))
        throw new Error("Synchronous parse encountered promise.");
      return j;
    }
    _parseAsync(O) {
      const j = this._parse(O);
      return Promise.resolve(j);
    }
    parse(O, j) {
      const W = this.safeParse(O, j);
      if (W.success)
        return W.data;
      throw W.error;
    }
    safeParse(O, j) {
      var W;
      const ne = {
        common: {
          issues: [],
          async: (W = j == null ? void 0 : j.async) !== null && W !== void 0 ? W : !1,
          contextualErrorMap: j == null ? void 0 : j.errorMap
        },
        path: (j == null ? void 0 : j.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: O,
        parsedType: (0, n.getParsedType)(O)
      }, te = this._parseSync({ data: O, path: ne.path, parent: ne });
      return u(ne, te);
    }
    async parseAsync(O, j) {
      const W = await this.safeParseAsync(O, j);
      if (W.success)
        return W.data;
      throw W.error;
    }
    async safeParseAsync(O, j) {
      const W = {
        common: {
          issues: [],
          contextualErrorMap: j == null ? void 0 : j.errorMap,
          async: !0
        },
        path: (j == null ? void 0 : j.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: O,
        parsedType: (0, n.getParsedType)(O)
      }, ne = this._parse({ data: O, path: W.path, parent: W }), te = await ((0, i.isAsync)(ne) ? ne : Promise.resolve(ne));
      return u(W, te);
    }
    refine(O, j) {
      const W = (ne) => typeof j == "string" || typeof j > "u" ? { message: j } : typeof j == "function" ? j(ne) : j;
      return this._refinement((ne, te) => {
        const Ie = O(ne), Se = () => te.addIssue({
          code: s.ZodIssueCode.custom,
          ...W(ne)
        });
        return typeof Promise < "u" && Ie instanceof Promise ? Ie.then((Ke) => Ke ? !0 : (Se(), !1)) : Ie ? !0 : (Se(), !1);
      });
    }
    refinement(O, j) {
      return this._refinement((W, ne) => O(W) ? !0 : (ne.addIssue(typeof j == "function" ? j(W, ne) : j), !1));
    }
    _refinement(O) {
      return new Fe({
        schema: this,
        typeName: qe.ZodEffects,
        effect: { type: "refinement", refinement: O }
      });
    }
    superRefine(O) {
      return this._refinement(O);
    }
    optional() {
      return Ge.create(this, this._def);
    }
    nullable() {
      return jt.create(this, this._def);
    }
    nullish() {
      return this.nullable().optional();
    }
    array() {
      return $e.create(this, this._def);
    }
    promise() {
      return He.create(this, this._def);
    }
    or(O) {
      return ie.create([this, O], this._def);
    }
    and(O) {
      return C.create(this, O, this._def);
    }
    transform(O) {
      return new Fe({
        ...c(this._def),
        schema: this,
        typeName: qe.ZodEffects,
        effect: { type: "transform", transform: O }
      });
    }
    default(O) {
      const j = typeof O == "function" ? O : () => O;
      return new Ee({
        ...c(this._def),
        innerType: this,
        defaultValue: j,
        typeName: qe.ZodDefault
      });
    }
    brand() {
      return new Ne({
        typeName: qe.ZodBranded,
        type: this,
        ...c(this._def)
      });
    }
    catch(O) {
      const j = typeof O == "function" ? O : () => O;
      return new Mt({
        ...c(this._def),
        innerType: this,
        catchValue: j,
        typeName: qe.ZodCatch
      });
    }
    describe(O) {
      const j = this.constructor;
      return new j({
        ...this._def,
        description: O
      });
    }
    pipe(O) {
      return Le.create(this, O);
    }
    readonly() {
      return at.create(this);
    }
    isOptional() {
      return this.safeParse(void 0).success;
    }
    isNullable() {
      return this.safeParse(null).success;
    }
  }
  e.ZodType = l, e.Schema = l, e.ZodSchema = l;
  const d = /^c[^\s-]{8,}$/i, p = /^[a-z][a-z0-9]*$/, h = /[0-9A-HJKMNP-TV-Z]{26}/, v = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, y = /^([A-Z0-9_+-]+\.?)*[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, g = /^(\p{Extended_Pictographic}|\p{Emoji_Component})+$/u, _ = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/, m = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/, w = (Q) => Q.precision ? Q.offset ? new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${Q.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`) : new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${Q.precision}}Z$`) : Q.precision === 0 ? Q.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$") : Q.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");
  function $(Q, O) {
    return !!((O === "v4" || !O) && _.test(Q) || (O === "v6" || !O) && m.test(Q));
  }
  class E extends l {
    constructor() {
      super(...arguments), this._regex = (O, j, W) => this.refinement((ne) => O.test(ne), {
        validation: j,
        code: s.ZodIssueCode.invalid_string,
        ...r.errorUtil.errToObj(W)
      }), this.nonempty = (O) => this.min(1, r.errorUtil.errToObj(O)), this.trim = () => new E({
        ...this._def,
        checks: [...this._def.checks, { kind: "trim" }]
      }), this.toLowerCase = () => new E({
        ...this._def,
        checks: [...this._def.checks, { kind: "toLowerCase" }]
      }), this.toUpperCase = () => new E({
        ...this._def,
        checks: [...this._def.checks, { kind: "toUpperCase" }]
      });
    }
    _parse(O) {
      if (this._def.coerce && (O.data = String(O.data)), this._getType(O) !== n.ZodParsedType.string) {
        const te = this._getOrReturnCtx(O);
        return (0, i.addIssueToContext)(te, {
          code: s.ZodIssueCode.invalid_type,
          expected: n.ZodParsedType.string,
          received: te.parsedType
        }), i.INVALID;
      }
      const W = new i.ParseStatus();
      let ne;
      for (const te of this._def.checks)
        if (te.kind === "min")
          O.data.length < te.value && (ne = this._getOrReturnCtx(O, ne), (0, i.addIssueToContext)(ne, {
            code: s.ZodIssueCode.too_small,
            minimum: te.value,
            type: "string",
            inclusive: !0,
            exact: !1,
            message: te.message
          }), W.dirty());
        else if (te.kind === "max")
          O.data.length > te.value && (ne = this._getOrReturnCtx(O, ne), (0, i.addIssueToContext)(ne, {
            code: s.ZodIssueCode.too_big,
            maximum: te.value,
            type: "string",
            inclusive: !0,
            exact: !1,
            message: te.message
          }), W.dirty());
        else if (te.kind === "length") {
          const Ie = O.data.length > te.value, Se = O.data.length < te.value;
          (Ie || Se) && (ne = this._getOrReturnCtx(O, ne), Ie ? (0, i.addIssueToContext)(ne, {
            code: s.ZodIssueCode.too_big,
            maximum: te.value,
            type: "string",
            inclusive: !0,
            exact: !0,
            message: te.message
          }) : Se && (0, i.addIssueToContext)(ne, {
            code: s.ZodIssueCode.too_small,
            minimum: te.value,
            type: "string",
            inclusive: !0,
            exact: !0,
            message: te.message
          }), W.dirty());
        } else if (te.kind === "email")
          y.test(O.data) || (ne = this._getOrReturnCtx(O, ne), (0, i.addIssueToContext)(ne, {
            validation: "email",
            code: s.ZodIssueCode.invalid_string,
            message: te.message
          }), W.dirty());
        else if (te.kind === "emoji")
          g.test(O.data) || (ne = this._getOrReturnCtx(O, ne), (0, i.addIssueToContext)(ne, {
            validation: "emoji",
            code: s.ZodIssueCode.invalid_string,
            message: te.message
          }), W.dirty());
        else if (te.kind === "uuid")
          v.test(O.data) || (ne = this._getOrReturnCtx(O, ne), (0, i.addIssueToContext)(ne, {
            validation: "uuid",
            code: s.ZodIssueCode.invalid_string,
            message: te.message
          }), W.dirty());
        else if (te.kind === "cuid")
          d.test(O.data) || (ne = this._getOrReturnCtx(O, ne), (0, i.addIssueToContext)(ne, {
            validation: "cuid",
            code: s.ZodIssueCode.invalid_string,
            message: te.message
          }), W.dirty());
        else if (te.kind === "cuid2")
          p.test(O.data) || (ne = this._getOrReturnCtx(O, ne), (0, i.addIssueToContext)(ne, {
            validation: "cuid2",
            code: s.ZodIssueCode.invalid_string,
            message: te.message
          }), W.dirty());
        else if (te.kind === "ulid")
          h.test(O.data) || (ne = this._getOrReturnCtx(O, ne), (0, i.addIssueToContext)(ne, {
            validation: "ulid",
            code: s.ZodIssueCode.invalid_string,
            message: te.message
          }), W.dirty());
        else if (te.kind === "url")
          try {
            new URL(O.data);
          } catch {
            ne = this._getOrReturnCtx(O, ne), (0, i.addIssueToContext)(ne, {
              validation: "url",
              code: s.ZodIssueCode.invalid_string,
              message: te.message
            }), W.dirty();
          }
        else
          te.kind === "regex" ? (te.regex.lastIndex = 0, te.regex.test(O.data) || (ne = this._getOrReturnCtx(O, ne), (0, i.addIssueToContext)(ne, {
            validation: "regex",
            code: s.ZodIssueCode.invalid_string,
            message: te.message
          }), W.dirty())) : te.kind === "trim" ? O.data = O.data.trim() : te.kind === "includes" ? O.data.includes(te.value, te.position) || (ne = this._getOrReturnCtx(O, ne), (0, i.addIssueToContext)(ne, {
            code: s.ZodIssueCode.invalid_string,
            validation: { includes: te.value, position: te.position },
            message: te.message
          }), W.dirty()) : te.kind === "toLowerCase" ? O.data = O.data.toLowerCase() : te.kind === "toUpperCase" ? O.data = O.data.toUpperCase() : te.kind === "startsWith" ? O.data.startsWith(te.value) || (ne = this._getOrReturnCtx(O, ne), (0, i.addIssueToContext)(ne, {
            code: s.ZodIssueCode.invalid_string,
            validation: { startsWith: te.value },
            message: te.message
          }), W.dirty()) : te.kind === "endsWith" ? O.data.endsWith(te.value) || (ne = this._getOrReturnCtx(O, ne), (0, i.addIssueToContext)(ne, {
            code: s.ZodIssueCode.invalid_string,
            validation: { endsWith: te.value },
            message: te.message
          }), W.dirty()) : te.kind === "datetime" ? w(te).test(O.data) || (ne = this._getOrReturnCtx(O, ne), (0, i.addIssueToContext)(ne, {
            code: s.ZodIssueCode.invalid_string,
            validation: "datetime",
            message: te.message
          }), W.dirty()) : te.kind === "ip" ? $(O.data, te.version) || (ne = this._getOrReturnCtx(O, ne), (0, i.addIssueToContext)(ne, {
            validation: "ip",
            code: s.ZodIssueCode.invalid_string,
            message: te.message
          }), W.dirty()) : n.util.assertNever(te);
      return { status: W.value, value: O.data };
    }
    _addCheck(O) {
      return new E({
        ...this._def,
        checks: [...this._def.checks, O]
      });
    }
    email(O) {
      return this._addCheck({ kind: "email", ...r.errorUtil.errToObj(O) });
    }
    url(O) {
      return this._addCheck({ kind: "url", ...r.errorUtil.errToObj(O) });
    }
    emoji(O) {
      return this._addCheck({ kind: "emoji", ...r.errorUtil.errToObj(O) });
    }
    uuid(O) {
      return this._addCheck({ kind: "uuid", ...r.errorUtil.errToObj(O) });
    }
    cuid(O) {
      return this._addCheck({ kind: "cuid", ...r.errorUtil.errToObj(O) });
    }
    cuid2(O) {
      return this._addCheck({ kind: "cuid2", ...r.errorUtil.errToObj(O) });
    }
    ulid(O) {
      return this._addCheck({ kind: "ulid", ...r.errorUtil.errToObj(O) });
    }
    ip(O) {
      return this._addCheck({ kind: "ip", ...r.errorUtil.errToObj(O) });
    }
    datetime(O) {
      var j;
      return typeof O == "string" ? this._addCheck({
        kind: "datetime",
        precision: null,
        offset: !1,
        message: O
      }) : this._addCheck({
        kind: "datetime",
        precision: typeof (O == null ? void 0 : O.precision) > "u" ? null : O == null ? void 0 : O.precision,
        offset: (j = O == null ? void 0 : O.offset) !== null && j !== void 0 ? j : !1,
        ...r.errorUtil.errToObj(O == null ? void 0 : O.message)
      });
    }
    regex(O, j) {
      return this._addCheck({
        kind: "regex",
        regex: O,
        ...r.errorUtil.errToObj(j)
      });
    }
    includes(O, j) {
      return this._addCheck({
        kind: "includes",
        value: O,
        position: j == null ? void 0 : j.position,
        ...r.errorUtil.errToObj(j == null ? void 0 : j.message)
      });
    }
    startsWith(O, j) {
      return this._addCheck({
        kind: "startsWith",
        value: O,
        ...r.errorUtil.errToObj(j)
      });
    }
    endsWith(O, j) {
      return this._addCheck({
        kind: "endsWith",
        value: O,
        ...r.errorUtil.errToObj(j)
      });
    }
    min(O, j) {
      return this._addCheck({
        kind: "min",
        value: O,
        ...r.errorUtil.errToObj(j)
      });
    }
    max(O, j) {
      return this._addCheck({
        kind: "max",
        value: O,
        ...r.errorUtil.errToObj(j)
      });
    }
    length(O, j) {
      return this._addCheck({
        kind: "length",
        value: O,
        ...r.errorUtil.errToObj(j)
      });
    }
    get isDatetime() {
      return !!this._def.checks.find((O) => O.kind === "datetime");
    }
    get isEmail() {
      return !!this._def.checks.find((O) => O.kind === "email");
    }
    get isURL() {
      return !!this._def.checks.find((O) => O.kind === "url");
    }
    get isEmoji() {
      return !!this._def.checks.find((O) => O.kind === "emoji");
    }
    get isUUID() {
      return !!this._def.checks.find((O) => O.kind === "uuid");
    }
    get isCUID() {
      return !!this._def.checks.find((O) => O.kind === "cuid");
    }
    get isCUID2() {
      return !!this._def.checks.find((O) => O.kind === "cuid2");
    }
    get isULID() {
      return !!this._def.checks.find((O) => O.kind === "ulid");
    }
    get isIP() {
      return !!this._def.checks.find((O) => O.kind === "ip");
    }
    get minLength() {
      let O = null;
      for (const j of this._def.checks)
        j.kind === "min" && (O === null || j.value > O) && (O = j.value);
      return O;
    }
    get maxLength() {
      let O = null;
      for (const j of this._def.checks)
        j.kind === "max" && (O === null || j.value < O) && (O = j.value);
      return O;
    }
  }
  e.ZodString = E, E.create = (Q) => {
    var O;
    return new E({
      checks: [],
      typeName: qe.ZodString,
      coerce: (O = Q == null ? void 0 : Q.coerce) !== null && O !== void 0 ? O : !1,
      ...c(Q)
    });
  };
  function A(Q, O) {
    const j = (Q.toString().split(".")[1] || "").length, W = (O.toString().split(".")[1] || "").length, ne = j > W ? j : W, te = parseInt(Q.toFixed(ne).replace(".", "")), Ie = parseInt(O.toFixed(ne).replace(".", ""));
    return te % Ie / Math.pow(10, ne);
  }
  class R extends l {
    constructor() {
      super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
    }
    _parse(O) {
      if (this._def.coerce && (O.data = Number(O.data)), this._getType(O) !== n.ZodParsedType.number) {
        const te = this._getOrReturnCtx(O);
        return (0, i.addIssueToContext)(te, {
          code: s.ZodIssueCode.invalid_type,
          expected: n.ZodParsedType.number,
          received: te.parsedType
        }), i.INVALID;
      }
      let W;
      const ne = new i.ParseStatus();
      for (const te of this._def.checks)
        te.kind === "int" ? n.util.isInteger(O.data) || (W = this._getOrReturnCtx(O, W), (0, i.addIssueToContext)(W, {
          code: s.ZodIssueCode.invalid_type,
          expected: "integer",
          received: "float",
          message: te.message
        }), ne.dirty()) : te.kind === "min" ? (te.inclusive ? O.data < te.value : O.data <= te.value) && (W = this._getOrReturnCtx(O, W), (0, i.addIssueToContext)(W, {
          code: s.ZodIssueCode.too_small,
          minimum: te.value,
          type: "number",
          inclusive: te.inclusive,
          exact: !1,
          message: te.message
        }), ne.dirty()) : te.kind === "max" ? (te.inclusive ? O.data > te.value : O.data >= te.value) && (W = this._getOrReturnCtx(O, W), (0, i.addIssueToContext)(W, {
          code: s.ZodIssueCode.too_big,
          maximum: te.value,
          type: "number",
          inclusive: te.inclusive,
          exact: !1,
          message: te.message
        }), ne.dirty()) : te.kind === "multipleOf" ? A(O.data, te.value) !== 0 && (W = this._getOrReturnCtx(O, W), (0, i.addIssueToContext)(W, {
          code: s.ZodIssueCode.not_multiple_of,
          multipleOf: te.value,
          message: te.message
        }), ne.dirty()) : te.kind === "finite" ? Number.isFinite(O.data) || (W = this._getOrReturnCtx(O, W), (0, i.addIssueToContext)(W, {
          code: s.ZodIssueCode.not_finite,
          message: te.message
        }), ne.dirty()) : n.util.assertNever(te);
      return { status: ne.value, value: O.data };
    }
    gte(O, j) {
      return this.setLimit("min", O, !0, r.errorUtil.toString(j));
    }
    gt(O, j) {
      return this.setLimit("min", O, !1, r.errorUtil.toString(j));
    }
    lte(O, j) {
      return this.setLimit("max", O, !0, r.errorUtil.toString(j));
    }
    lt(O, j) {
      return this.setLimit("max", O, !1, r.errorUtil.toString(j));
    }
    setLimit(O, j, W, ne) {
      return new R({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind: O,
            value: j,
            inclusive: W,
            message: r.errorUtil.toString(ne)
          }
        ]
      });
    }
    _addCheck(O) {
      return new R({
        ...this._def,
        checks: [...this._def.checks, O]
      });
    }
    int(O) {
      return this._addCheck({
        kind: "int",
        message: r.errorUtil.toString(O)
      });
    }
    positive(O) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: !1,
        message: r.errorUtil.toString(O)
      });
    }
    negative(O) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: !1,
        message: r.errorUtil.toString(O)
      });
    }
    nonpositive(O) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: !0,
        message: r.errorUtil.toString(O)
      });
    }
    nonnegative(O) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: !0,
        message: r.errorUtil.toString(O)
      });
    }
    multipleOf(O, j) {
      return this._addCheck({
        kind: "multipleOf",
        value: O,
        message: r.errorUtil.toString(j)
      });
    }
    finite(O) {
      return this._addCheck({
        kind: "finite",
        message: r.errorUtil.toString(O)
      });
    }
    safe(O) {
      return this._addCheck({
        kind: "min",
        inclusive: !0,
        value: Number.MIN_SAFE_INTEGER,
        message: r.errorUtil.toString(O)
      })._addCheck({
        kind: "max",
        inclusive: !0,
        value: Number.MAX_SAFE_INTEGER,
        message: r.errorUtil.toString(O)
      });
    }
    get minValue() {
      let O = null;
      for (const j of this._def.checks)
        j.kind === "min" && (O === null || j.value > O) && (O = j.value);
      return O;
    }
    get maxValue() {
      let O = null;
      for (const j of this._def.checks)
        j.kind === "max" && (O === null || j.value < O) && (O = j.value);
      return O;
    }
    get isInt() {
      return !!this._def.checks.find((O) => O.kind === "int" || O.kind === "multipleOf" && n.util.isInteger(O.value));
    }
    get isFinite() {
      let O = null, j = null;
      for (const W of this._def.checks) {
        if (W.kind === "finite" || W.kind === "int" || W.kind === "multipleOf")
          return !0;
        W.kind === "min" ? (j === null || W.value > j) && (j = W.value) : W.kind === "max" && (O === null || W.value < O) && (O = W.value);
      }
      return Number.isFinite(j) && Number.isFinite(O);
    }
  }
  e.ZodNumber = R, R.create = (Q) => new R({
    checks: [],
    typeName: qe.ZodNumber,
    coerce: (Q == null ? void 0 : Q.coerce) || !1,
    ...c(Q)
  });
  class I extends l {
    constructor() {
      super(...arguments), this.min = this.gte, this.max = this.lte;
    }
    _parse(O) {
      if (this._def.coerce && (O.data = BigInt(O.data)), this._getType(O) !== n.ZodParsedType.bigint) {
        const te = this._getOrReturnCtx(O);
        return (0, i.addIssueToContext)(te, {
          code: s.ZodIssueCode.invalid_type,
          expected: n.ZodParsedType.bigint,
          received: te.parsedType
        }), i.INVALID;
      }
      let W;
      const ne = new i.ParseStatus();
      for (const te of this._def.checks)
        te.kind === "min" ? (te.inclusive ? O.data < te.value : O.data <= te.value) && (W = this._getOrReturnCtx(O, W), (0, i.addIssueToContext)(W, {
          code: s.ZodIssueCode.too_small,
          type: "bigint",
          minimum: te.value,
          inclusive: te.inclusive,
          message: te.message
        }), ne.dirty()) : te.kind === "max" ? (te.inclusive ? O.data > te.value : O.data >= te.value) && (W = this._getOrReturnCtx(O, W), (0, i.addIssueToContext)(W, {
          code: s.ZodIssueCode.too_big,
          type: "bigint",
          maximum: te.value,
          inclusive: te.inclusive,
          message: te.message
        }), ne.dirty()) : te.kind === "multipleOf" ? O.data % te.value !== BigInt(0) && (W = this._getOrReturnCtx(O, W), (0, i.addIssueToContext)(W, {
          code: s.ZodIssueCode.not_multiple_of,
          multipleOf: te.value,
          message: te.message
        }), ne.dirty()) : n.util.assertNever(te);
      return { status: ne.value, value: O.data };
    }
    gte(O, j) {
      return this.setLimit("min", O, !0, r.errorUtil.toString(j));
    }
    gt(O, j) {
      return this.setLimit("min", O, !1, r.errorUtil.toString(j));
    }
    lte(O, j) {
      return this.setLimit("max", O, !0, r.errorUtil.toString(j));
    }
    lt(O, j) {
      return this.setLimit("max", O, !1, r.errorUtil.toString(j));
    }
    setLimit(O, j, W, ne) {
      return new I({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind: O,
            value: j,
            inclusive: W,
            message: r.errorUtil.toString(ne)
          }
        ]
      });
    }
    _addCheck(O) {
      return new I({
        ...this._def,
        checks: [...this._def.checks, O]
      });
    }
    positive(O) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: !1,
        message: r.errorUtil.toString(O)
      });
    }
    negative(O) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: !1,
        message: r.errorUtil.toString(O)
      });
    }
    nonpositive(O) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: !0,
        message: r.errorUtil.toString(O)
      });
    }
    nonnegative(O) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: !0,
        message: r.errorUtil.toString(O)
      });
    }
    multipleOf(O, j) {
      return this._addCheck({
        kind: "multipleOf",
        value: O,
        message: r.errorUtil.toString(j)
      });
    }
    get minValue() {
      let O = null;
      for (const j of this._def.checks)
        j.kind === "min" && (O === null || j.value > O) && (O = j.value);
      return O;
    }
    get maxValue() {
      let O = null;
      for (const j of this._def.checks)
        j.kind === "max" && (O === null || j.value < O) && (O = j.value);
      return O;
    }
  }
  e.ZodBigInt = I, I.create = (Q) => {
    var O;
    return new I({
      checks: [],
      typeName: qe.ZodBigInt,
      coerce: (O = Q == null ? void 0 : Q.coerce) !== null && O !== void 0 ? O : !1,
      ...c(Q)
    });
  };
  class D extends l {
    _parse(O) {
      if (this._def.coerce && (O.data = !!O.data), this._getType(O) !== n.ZodParsedType.boolean) {
        const W = this._getOrReturnCtx(O);
        return (0, i.addIssueToContext)(W, {
          code: s.ZodIssueCode.invalid_type,
          expected: n.ZodParsedType.boolean,
          received: W.parsedType
        }), i.INVALID;
      }
      return (0, i.OK)(O.data);
    }
  }
  e.ZodBoolean = D, D.create = (Q) => new D({
    typeName: qe.ZodBoolean,
    coerce: (Q == null ? void 0 : Q.coerce) || !1,
    ...c(Q)
  });
  class J extends l {
    _parse(O) {
      if (this._def.coerce && (O.data = new Date(O.data)), this._getType(O) !== n.ZodParsedType.date) {
        const te = this._getOrReturnCtx(O);
        return (0, i.addIssueToContext)(te, {
          code: s.ZodIssueCode.invalid_type,
          expected: n.ZodParsedType.date,
          received: te.parsedType
        }), i.INVALID;
      }
      if (isNaN(O.data.getTime())) {
        const te = this._getOrReturnCtx(O);
        return (0, i.addIssueToContext)(te, {
          code: s.ZodIssueCode.invalid_date
        }), i.INVALID;
      }
      const W = new i.ParseStatus();
      let ne;
      for (const te of this._def.checks)
        te.kind === "min" ? O.data.getTime() < te.value && (ne = this._getOrReturnCtx(O, ne), (0, i.addIssueToContext)(ne, {
          code: s.ZodIssueCode.too_small,
          message: te.message,
          inclusive: !0,
          exact: !1,
          minimum: te.value,
          type: "date"
        }), W.dirty()) : te.kind === "max" ? O.data.getTime() > te.value && (ne = this._getOrReturnCtx(O, ne), (0, i.addIssueToContext)(ne, {
          code: s.ZodIssueCode.too_big,
          message: te.message,
          inclusive: !0,
          exact: !1,
          maximum: te.value,
          type: "date"
        }), W.dirty()) : n.util.assertNever(te);
      return {
        status: W.value,
        value: new Date(O.data.getTime())
      };
    }
    _addCheck(O) {
      return new J({
        ...this._def,
        checks: [...this._def.checks, O]
      });
    }
    min(O, j) {
      return this._addCheck({
        kind: "min",
        value: O.getTime(),
        message: r.errorUtil.toString(j)
      });
    }
    max(O, j) {
      return this._addCheck({
        kind: "max",
        value: O.getTime(),
        message: r.errorUtil.toString(j)
      });
    }
    get minDate() {
      let O = null;
      for (const j of this._def.checks)
        j.kind === "min" && (O === null || j.value > O) && (O = j.value);
      return O != null ? new Date(O) : null;
    }
    get maxDate() {
      let O = null;
      for (const j of this._def.checks)
        j.kind === "max" && (O === null || j.value < O) && (O = j.value);
      return O != null ? new Date(O) : null;
    }
  }
  e.ZodDate = J, J.create = (Q) => new J({
    checks: [],
    coerce: (Q == null ? void 0 : Q.coerce) || !1,
    typeName: qe.ZodDate,
    ...c(Q)
  });
  class ae extends l {
    _parse(O) {
      if (this._getType(O) !== n.ZodParsedType.symbol) {
        const W = this._getOrReturnCtx(O);
        return (0, i.addIssueToContext)(W, {
          code: s.ZodIssueCode.invalid_type,
          expected: n.ZodParsedType.symbol,
          received: W.parsedType
        }), i.INVALID;
      }
      return (0, i.OK)(O.data);
    }
  }
  e.ZodSymbol = ae, ae.create = (Q) => new ae({
    typeName: qe.ZodSymbol,
    ...c(Q)
  });
  class ye extends l {
    _parse(O) {
      if (this._getType(O) !== n.ZodParsedType.undefined) {
        const W = this._getOrReturnCtx(O);
        return (0, i.addIssueToContext)(W, {
          code: s.ZodIssueCode.invalid_type,
          expected: n.ZodParsedType.undefined,
          received: W.parsedType
        }), i.INVALID;
      }
      return (0, i.OK)(O.data);
    }
  }
  e.ZodUndefined = ye, ye.create = (Q) => new ye({
    typeName: qe.ZodUndefined,
    ...c(Q)
  });
  class xe extends l {
    _parse(O) {
      if (this._getType(O) !== n.ZodParsedType.null) {
        const W = this._getOrReturnCtx(O);
        return (0, i.addIssueToContext)(W, {
          code: s.ZodIssueCode.invalid_type,
          expected: n.ZodParsedType.null,
          received: W.parsedType
        }), i.INVALID;
      }
      return (0, i.OK)(O.data);
    }
  }
  e.ZodNull = xe, xe.create = (Q) => new xe({
    typeName: qe.ZodNull,
    ...c(Q)
  });
  class je extends l {
    constructor() {
      super(...arguments), this._any = !0;
    }
    _parse(O) {
      return (0, i.OK)(O.data);
    }
  }
  e.ZodAny = je, je.create = (Q) => new je({
    typeName: qe.ZodAny,
    ...c(Q)
  });
  class re extends l {
    constructor() {
      super(...arguments), this._unknown = !0;
    }
    _parse(O) {
      return (0, i.OK)(O.data);
    }
  }
  e.ZodUnknown = re, re.create = (Q) => new re({
    typeName: qe.ZodUnknown,
    ...c(Q)
  });
  class fe extends l {
    _parse(O) {
      const j = this._getOrReturnCtx(O);
      return (0, i.addIssueToContext)(j, {
        code: s.ZodIssueCode.invalid_type,
        expected: n.ZodParsedType.never,
        received: j.parsedType
      }), i.INVALID;
    }
  }
  e.ZodNever = fe, fe.create = (Q) => new fe({
    typeName: qe.ZodNever,
    ...c(Q)
  });
  class le extends l {
    _parse(O) {
      if (this._getType(O) !== n.ZodParsedType.undefined) {
        const W = this._getOrReturnCtx(O);
        return (0, i.addIssueToContext)(W, {
          code: s.ZodIssueCode.invalid_type,
          expected: n.ZodParsedType.void,
          received: W.parsedType
        }), i.INVALID;
      }
      return (0, i.OK)(O.data);
    }
  }
  e.ZodVoid = le, le.create = (Q) => new le({
    typeName: qe.ZodVoid,
    ...c(Q)
  });
  class $e extends l {
    _parse(O) {
      const { ctx: j, status: W } = this._processInputParams(O), ne = this._def;
      if (j.parsedType !== n.ZodParsedType.array)
        return (0, i.addIssueToContext)(j, {
          code: s.ZodIssueCode.invalid_type,
          expected: n.ZodParsedType.array,
          received: j.parsedType
        }), i.INVALID;
      if (ne.exactLength !== null) {
        const Ie = j.data.length > ne.exactLength.value, Se = j.data.length < ne.exactLength.value;
        (Ie || Se) && ((0, i.addIssueToContext)(j, {
          code: Ie ? s.ZodIssueCode.too_big : s.ZodIssueCode.too_small,
          minimum: Se ? ne.exactLength.value : void 0,
          maximum: Ie ? ne.exactLength.value : void 0,
          type: "array",
          inclusive: !0,
          exact: !0,
          message: ne.exactLength.message
        }), W.dirty());
      }
      if (ne.minLength !== null && j.data.length < ne.minLength.value && ((0, i.addIssueToContext)(j, {
        code: s.ZodIssueCode.too_small,
        minimum: ne.minLength.value,
        type: "array",
        inclusive: !0,
        exact: !1,
        message: ne.minLength.message
      }), W.dirty()), ne.maxLength !== null && j.data.length > ne.maxLength.value && ((0, i.addIssueToContext)(j, {
        code: s.ZodIssueCode.too_big,
        maximum: ne.maxLength.value,
        type: "array",
        inclusive: !0,
        exact: !1,
        message: ne.maxLength.message
      }), W.dirty()), j.common.async)
        return Promise.all([...j.data].map((Ie, Se) => ne.type._parseAsync(new a(j, Ie, j.path, Se)))).then((Ie) => i.ParseStatus.mergeArray(W, Ie));
      const te = [...j.data].map((Ie, Se) => ne.type._parseSync(new a(j, Ie, j.path, Se)));
      return i.ParseStatus.mergeArray(W, te);
    }
    get element() {
      return this._def.type;
    }
    min(O, j) {
      return new $e({
        ...this._def,
        minLength: { value: O, message: r.errorUtil.toString(j) }
      });
    }
    max(O, j) {
      return new $e({
        ...this._def,
        maxLength: { value: O, message: r.errorUtil.toString(j) }
      });
    }
    length(O, j) {
      return new $e({
        ...this._def,
        exactLength: { value: O, message: r.errorUtil.toString(j) }
      });
    }
    nonempty(O) {
      return this.min(1, O);
    }
  }
  e.ZodArray = $e, $e.create = (Q, O) => new $e({
    type: Q,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: qe.ZodArray,
    ...c(O)
  });
  function Ae(Q) {
    if (Q instanceof _e) {
      const O = {};
      for (const j in Q.shape) {
        const W = Q.shape[j];
        O[j] = Ge.create(Ae(W));
      }
      return new _e({
        ...Q._def,
        shape: () => O
      });
    } else
      return Q instanceof $e ? new $e({
        ...Q._def,
        type: Ae(Q.element)
      }) : Q instanceof Ge ? Ge.create(Ae(Q.unwrap())) : Q instanceof jt ? jt.create(Ae(Q.unwrap())) : Q instanceof q ? q.create(Q.items.map((O) => Ae(O))) : Q;
  }
  class _e extends l {
    constructor() {
      super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
    }
    _getCached() {
      if (this._cached !== null)
        return this._cached;
      const O = this._def.shape(), j = n.util.objectKeys(O);
      return this._cached = { shape: O, keys: j };
    }
    _parse(O) {
      if (this._getType(O) !== n.ZodParsedType.object) {
        const Ze = this._getOrReturnCtx(O);
        return (0, i.addIssueToContext)(Ze, {
          code: s.ZodIssueCode.invalid_type,
          expected: n.ZodParsedType.object,
          received: Ze.parsedType
        }), i.INVALID;
      }
      const { status: W, ctx: ne } = this._processInputParams(O), { shape: te, keys: Ie } = this._getCached(), Se = [];
      if (!(this._def.catchall instanceof fe && this._def.unknownKeys === "strip"))
        for (const Ze in ne.data)
          Ie.includes(Ze) || Se.push(Ze);
      const Ke = [];
      for (const Ze of Ie) {
        const ct = te[Ze], Ut = ne.data[Ze];
        Ke.push({
          key: { status: "valid", value: Ze },
          value: ct._parse(new a(ne, Ut, ne.path, Ze)),
          alwaysSet: Ze in ne.data
        });
      }
      if (this._def.catchall instanceof fe) {
        const Ze = this._def.unknownKeys;
        if (Ze === "passthrough")
          for (const ct of Se)
            Ke.push({
              key: { status: "valid", value: ct },
              value: { status: "valid", value: ne.data[ct] }
            });
        else if (Ze === "strict")
          Se.length > 0 && ((0, i.addIssueToContext)(ne, {
            code: s.ZodIssueCode.unrecognized_keys,
            keys: Se
          }), W.dirty());
        else if (Ze !== "strip")
          throw new Error("Internal ZodObject error: invalid unknownKeys value.");
      } else {
        const Ze = this._def.catchall;
        for (const ct of Se) {
          const Ut = ne.data[ct];
          Ke.push({
            key: { status: "valid", value: ct },
            value: Ze._parse(new a(ne, Ut, ne.path, ct)),
            alwaysSet: ct in ne.data
          });
        }
      }
      return ne.common.async ? Promise.resolve().then(async () => {
        const Ze = [];
        for (const ct of Ke) {
          const Ut = await ct.key;
          Ze.push({
            key: Ut,
            value: await ct.value,
            alwaysSet: ct.alwaysSet
          });
        }
        return Ze;
      }).then((Ze) => i.ParseStatus.mergeObjectSync(W, Ze)) : i.ParseStatus.mergeObjectSync(W, Ke);
    }
    get shape() {
      return this._def.shape();
    }
    strict(O) {
      return r.errorUtil.errToObj, new _e({
        ...this._def,
        unknownKeys: "strict",
        ...O !== void 0 ? {
          errorMap: (j, W) => {
            var ne, te, Ie, Se;
            const Ke = (Ie = (te = (ne = this._def).errorMap) === null || te === void 0 ? void 0 : te.call(ne, j, W).message) !== null && Ie !== void 0 ? Ie : W.defaultError;
            return j.code === "unrecognized_keys" ? {
              message: (Se = r.errorUtil.errToObj(O).message) !== null && Se !== void 0 ? Se : Ke
            } : {
              message: Ke
            };
          }
        } : {}
      });
    }
    strip() {
      return new _e({
        ...this._def,
        unknownKeys: "strip"
      });
    }
    passthrough() {
      return new _e({
        ...this._def,
        unknownKeys: "passthrough"
      });
    }
    extend(O) {
      return new _e({
        ...this._def,
        shape: () => ({
          ...this._def.shape(),
          ...O
        })
      });
    }
    merge(O) {
      return new _e({
        unknownKeys: O._def.unknownKeys,
        catchall: O._def.catchall,
        shape: () => ({
          ...this._def.shape(),
          ...O._def.shape()
        }),
        typeName: qe.ZodObject
      });
    }
    setKey(O, j) {
      return this.augment({ [O]: j });
    }
    catchall(O) {
      return new _e({
        ...this._def,
        catchall: O
      });
    }
    pick(O) {
      const j = {};
      return n.util.objectKeys(O).forEach((W) => {
        O[W] && this.shape[W] && (j[W] = this.shape[W]);
      }), new _e({
        ...this._def,
        shape: () => j
      });
    }
    omit(O) {
      const j = {};
      return n.util.objectKeys(this.shape).forEach((W) => {
        O[W] || (j[W] = this.shape[W]);
      }), new _e({
        ...this._def,
        shape: () => j
      });
    }
    deepPartial() {
      return Ae(this);
    }
    partial(O) {
      const j = {};
      return n.util.objectKeys(this.shape).forEach((W) => {
        const ne = this.shape[W];
        O && !O[W] ? j[W] = ne : j[W] = ne.optional();
      }), new _e({
        ...this._def,
        shape: () => j
      });
    }
    required(O) {
      const j = {};
      return n.util.objectKeys(this.shape).forEach((W) => {
        if (O && !O[W])
          j[W] = this.shape[W];
        else {
          let te = this.shape[W];
          for (; te instanceof Ge; )
            te = te._def.innerType;
          j[W] = te;
        }
      }), new _e({
        ...this._def,
        shape: () => j
      });
    }
    keyof() {
      return U(n.util.objectKeys(this.shape));
    }
  }
  e.ZodObject = _e, _e.create = (Q, O) => new _e({
    shape: () => Q,
    unknownKeys: "strip",
    catchall: fe.create(),
    typeName: qe.ZodObject,
    ...c(O)
  }), _e.strictCreate = (Q, O) => new _e({
    shape: () => Q,
    unknownKeys: "strict",
    catchall: fe.create(),
    typeName: qe.ZodObject,
    ...c(O)
  }), _e.lazycreate = (Q, O) => new _e({
    shape: Q,
    unknownKeys: "strip",
    catchall: fe.create(),
    typeName: qe.ZodObject,
    ...c(O)
  });
  class ie extends l {
    _parse(O) {
      const { ctx: j } = this._processInputParams(O), W = this._def.options;
      function ne(te) {
        for (const Se of te)
          if (Se.result.status === "valid")
            return Se.result;
        for (const Se of te)
          if (Se.result.status === "dirty")
            return j.common.issues.push(...Se.ctx.common.issues), Se.result;
        const Ie = te.map((Se) => new s.ZodError(Se.ctx.common.issues));
        return (0, i.addIssueToContext)(j, {
          code: s.ZodIssueCode.invalid_union,
          unionErrors: Ie
        }), i.INVALID;
      }
      if (j.common.async)
        return Promise.all(W.map(async (te) => {
          const Ie = {
            ...j,
            common: {
              ...j.common,
              issues: []
            },
            parent: null
          };
          return {
            result: await te._parseAsync({
              data: j.data,
              path: j.path,
              parent: Ie
            }),
            ctx: Ie
          };
        })).then(ne);
      {
        let te;
        const Ie = [];
        for (const Ke of W) {
          const Ze = {
            ...j,
            common: {
              ...j.common,
              issues: []
            },
            parent: null
          }, ct = Ke._parseSync({
            data: j.data,
            path: j.path,
            parent: Ze
          });
          if (ct.status === "valid")
            return ct;
          ct.status === "dirty" && !te && (te = { result: ct, ctx: Ze }), Ze.common.issues.length && Ie.push(Ze.common.issues);
        }
        if (te)
          return j.common.issues.push(...te.ctx.common.issues), te.result;
        const Se = Ie.map((Ke) => new s.ZodError(Ke));
        return (0, i.addIssueToContext)(j, {
          code: s.ZodIssueCode.invalid_union,
          unionErrors: Se
        }), i.INVALID;
      }
    }
    get options() {
      return this._def.options;
    }
  }
  e.ZodUnion = ie, ie.create = (Q, O) => new ie({
    options: Q,
    typeName: qe.ZodUnion,
    ...c(O)
  });
  const K = (Q) => Q instanceof Y ? K(Q.schema) : Q instanceof Fe ? K(Q.innerType()) : Q instanceof k ? [Q.value] : Q instanceof pe ? Q.options : Q instanceof we ? Object.keys(Q.enum) : Q instanceof Ee ? K(Q._def.innerType) : Q instanceof ye ? [void 0] : Q instanceof xe ? [null] : null;
  class V extends l {
    _parse(O) {
      const { ctx: j } = this._processInputParams(O);
      if (j.parsedType !== n.ZodParsedType.object)
        return (0, i.addIssueToContext)(j, {
          code: s.ZodIssueCode.invalid_type,
          expected: n.ZodParsedType.object,
          received: j.parsedType
        }), i.INVALID;
      const W = this.discriminator, ne = j.data[W], te = this.optionsMap.get(ne);
      return te ? j.common.async ? te._parseAsync({
        data: j.data,
        path: j.path,
        parent: j
      }) : te._parseSync({
        data: j.data,
        path: j.path,
        parent: j
      }) : ((0, i.addIssueToContext)(j, {
        code: s.ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [W]
      }), i.INVALID);
    }
    get discriminator() {
      return this._def.discriminator;
    }
    get options() {
      return this._def.options;
    }
    get optionsMap() {
      return this._def.optionsMap;
    }
    static create(O, j, W) {
      const ne = /* @__PURE__ */ new Map();
      for (const te of j) {
        const Ie = K(te.shape[O]);
        if (!Ie)
          throw new Error(`A discriminator value for key \`${O}\` could not be extracted from all schema options`);
        for (const Se of Ie) {
          if (ne.has(Se))
            throw new Error(`Discriminator property ${String(O)} has duplicate value ${String(Se)}`);
          ne.set(Se, te);
        }
      }
      return new V({
        typeName: qe.ZodDiscriminatedUnion,
        discriminator: O,
        options: j,
        optionsMap: ne,
        ...c(W)
      });
    }
  }
  e.ZodDiscriminatedUnion = V;
  function z(Q, O) {
    const j = (0, n.getParsedType)(Q), W = (0, n.getParsedType)(O);
    if (Q === O)
      return { valid: !0, data: Q };
    if (j === n.ZodParsedType.object && W === n.ZodParsedType.object) {
      const ne = n.util.objectKeys(O), te = n.util.objectKeys(Q).filter((Se) => ne.indexOf(Se) !== -1), Ie = { ...Q, ...O };
      for (const Se of te) {
        const Ke = z(Q[Se], O[Se]);
        if (!Ke.valid)
          return { valid: !1 };
        Ie[Se] = Ke.data;
      }
      return { valid: !0, data: Ie };
    } else if (j === n.ZodParsedType.array && W === n.ZodParsedType.array) {
      if (Q.length !== O.length)
        return { valid: !1 };
      const ne = [];
      for (let te = 0; te < Q.length; te++) {
        const Ie = Q[te], Se = O[te], Ke = z(Ie, Se);
        if (!Ke.valid)
          return { valid: !1 };
        ne.push(Ke.data);
      }
      return { valid: !0, data: ne };
    } else
      return j === n.ZodParsedType.date && W === n.ZodParsedType.date && +Q == +O ? { valid: !0, data: Q } : { valid: !1 };
  }
  class C extends l {
    _parse(O) {
      const { status: j, ctx: W } = this._processInputParams(O), ne = (te, Ie) => {
        if ((0, i.isAborted)(te) || (0, i.isAborted)(Ie))
          return i.INVALID;
        const Se = z(te.value, Ie.value);
        return Se.valid ? (((0, i.isDirty)(te) || (0, i.isDirty)(Ie)) && j.dirty(), { status: j.value, value: Se.data }) : ((0, i.addIssueToContext)(W, {
          code: s.ZodIssueCode.invalid_intersection_types
        }), i.INVALID);
      };
      return W.common.async ? Promise.all([
        this._def.left._parseAsync({
          data: W.data,
          path: W.path,
          parent: W
        }),
        this._def.right._parseAsync({
          data: W.data,
          path: W.path,
          parent: W
        })
      ]).then(([te, Ie]) => ne(te, Ie)) : ne(this._def.left._parseSync({
        data: W.data,
        path: W.path,
        parent: W
      }), this._def.right._parseSync({
        data: W.data,
        path: W.path,
        parent: W
      }));
    }
  }
  e.ZodIntersection = C, C.create = (Q, O, j) => new C({
    left: Q,
    right: O,
    typeName: qe.ZodIntersection,
    ...c(j)
  });
  class q extends l {
    _parse(O) {
      const { status: j, ctx: W } = this._processInputParams(O);
      if (W.parsedType !== n.ZodParsedType.array)
        return (0, i.addIssueToContext)(W, {
          code: s.ZodIssueCode.invalid_type,
          expected: n.ZodParsedType.array,
          received: W.parsedType
        }), i.INVALID;
      if (W.data.length < this._def.items.length)
        return (0, i.addIssueToContext)(W, {
          code: s.ZodIssueCode.too_small,
          minimum: this._def.items.length,
          inclusive: !0,
          exact: !1,
          type: "array"
        }), i.INVALID;
      !this._def.rest && W.data.length > this._def.items.length && ((0, i.addIssueToContext)(W, {
        code: s.ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), j.dirty());
      const te = [...W.data].map((Ie, Se) => {
        const Ke = this._def.items[Se] || this._def.rest;
        return Ke ? Ke._parse(new a(W, Ie, W.path, Se)) : null;
      }).filter((Ie) => !!Ie);
      return W.common.async ? Promise.all(te).then((Ie) => i.ParseStatus.mergeArray(j, Ie)) : i.ParseStatus.mergeArray(j, te);
    }
    get items() {
      return this._def.items;
    }
    rest(O) {
      return new q({
        ...this._def,
        rest: O
      });
    }
  }
  e.ZodTuple = q, q.create = (Q, O) => {
    if (!Array.isArray(Q))
      throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    return new q({
      items: Q,
      typeName: qe.ZodTuple,
      rest: null,
      ...c(O)
    });
  };
  class N extends l {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(O) {
      const { status: j, ctx: W } = this._processInputParams(O);
      if (W.parsedType !== n.ZodParsedType.object)
        return (0, i.addIssueToContext)(W, {
          code: s.ZodIssueCode.invalid_type,
          expected: n.ZodParsedType.object,
          received: W.parsedType
        }), i.INVALID;
      const ne = [], te = this._def.keyType, Ie = this._def.valueType;
      for (const Se in W.data)
        ne.push({
          key: te._parse(new a(W, Se, W.path, Se)),
          value: Ie._parse(new a(W, W.data[Se], W.path, Se))
        });
      return W.common.async ? i.ParseStatus.mergeObjectAsync(j, ne) : i.ParseStatus.mergeObjectSync(j, ne);
    }
    get element() {
      return this._def.valueType;
    }
    static create(O, j, W) {
      return j instanceof l ? new N({
        keyType: O,
        valueType: j,
        typeName: qe.ZodRecord,
        ...c(W)
      }) : new N({
        keyType: E.create(),
        valueType: O,
        typeName: qe.ZodRecord,
        ...c(j)
      });
    }
  }
  e.ZodRecord = N;
  class F extends l {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(O) {
      const { status: j, ctx: W } = this._processInputParams(O);
      if (W.parsedType !== n.ZodParsedType.map)
        return (0, i.addIssueToContext)(W, {
          code: s.ZodIssueCode.invalid_type,
          expected: n.ZodParsedType.map,
          received: W.parsedType
        }), i.INVALID;
      const ne = this._def.keyType, te = this._def.valueType, Ie = [...W.data.entries()].map(([Se, Ke], Ze) => ({
        key: ne._parse(new a(W, Se, W.path, [Ze, "key"])),
        value: te._parse(new a(W, Ke, W.path, [Ze, "value"]))
      }));
      if (W.common.async) {
        const Se = /* @__PURE__ */ new Map();
        return Promise.resolve().then(async () => {
          for (const Ke of Ie) {
            const Ze = await Ke.key, ct = await Ke.value;
            if (Ze.status === "aborted" || ct.status === "aborted")
              return i.INVALID;
            (Ze.status === "dirty" || ct.status === "dirty") && j.dirty(), Se.set(Ze.value, ct.value);
          }
          return { status: j.value, value: Se };
        });
      } else {
        const Se = /* @__PURE__ */ new Map();
        for (const Ke of Ie) {
          const Ze = Ke.key, ct = Ke.value;
          if (Ze.status === "aborted" || ct.status === "aborted")
            return i.INVALID;
          (Ze.status === "dirty" || ct.status === "dirty") && j.dirty(), Se.set(Ze.value, ct.value);
        }
        return { status: j.value, value: Se };
      }
    }
  }
  e.ZodMap = F, F.create = (Q, O, j) => new F({
    valueType: O,
    keyType: Q,
    typeName: qe.ZodMap,
    ...c(j)
  });
  class T extends l {
    _parse(O) {
      const { status: j, ctx: W } = this._processInputParams(O);
      if (W.parsedType !== n.ZodParsedType.set)
        return (0, i.addIssueToContext)(W, {
          code: s.ZodIssueCode.invalid_type,
          expected: n.ZodParsedType.set,
          received: W.parsedType
        }), i.INVALID;
      const ne = this._def;
      ne.minSize !== null && W.data.size < ne.minSize.value && ((0, i.addIssueToContext)(W, {
        code: s.ZodIssueCode.too_small,
        minimum: ne.minSize.value,
        type: "set",
        inclusive: !0,
        exact: !1,
        message: ne.minSize.message
      }), j.dirty()), ne.maxSize !== null && W.data.size > ne.maxSize.value && ((0, i.addIssueToContext)(W, {
        code: s.ZodIssueCode.too_big,
        maximum: ne.maxSize.value,
        type: "set",
        inclusive: !0,
        exact: !1,
        message: ne.maxSize.message
      }), j.dirty());
      const te = this._def.valueType;
      function Ie(Ke) {
        const Ze = /* @__PURE__ */ new Set();
        for (const ct of Ke) {
          if (ct.status === "aborted")
            return i.INVALID;
          ct.status === "dirty" && j.dirty(), Ze.add(ct.value);
        }
        return { status: j.value, value: Ze };
      }
      const Se = [...W.data.values()].map((Ke, Ze) => te._parse(new a(W, Ke, W.path, Ze)));
      return W.common.async ? Promise.all(Se).then((Ke) => Ie(Ke)) : Ie(Se);
    }
    min(O, j) {
      return new T({
        ...this._def,
        minSize: { value: O, message: r.errorUtil.toString(j) }
      });
    }
    max(O, j) {
      return new T({
        ...this._def,
        maxSize: { value: O, message: r.errorUtil.toString(j) }
      });
    }
    size(O, j) {
      return this.min(O, j).max(O, j);
    }
    nonempty(O) {
      return this.min(1, O);
    }
  }
  e.ZodSet = T, T.create = (Q, O) => new T({
    valueType: Q,
    minSize: null,
    maxSize: null,
    typeName: qe.ZodSet,
    ...c(O)
  });
  class Z extends l {
    constructor() {
      super(...arguments), this.validate = this.implement;
    }
    _parse(O) {
      const { ctx: j } = this._processInputParams(O);
      if (j.parsedType !== n.ZodParsedType.function)
        return (0, i.addIssueToContext)(j, {
          code: s.ZodIssueCode.invalid_type,
          expected: n.ZodParsedType.function,
          received: j.parsedType
        }), i.INVALID;
      function W(Se, Ke) {
        return (0, i.makeIssue)({
          data: Se,
          path: j.path,
          errorMaps: [
            j.common.contextualErrorMap,
            j.schemaErrorMap,
            (0, t.getErrorMap)(),
            t.defaultErrorMap
          ].filter((Ze) => !!Ze),
          issueData: {
            code: s.ZodIssueCode.invalid_arguments,
            argumentsError: Ke
          }
        });
      }
      function ne(Se, Ke) {
        return (0, i.makeIssue)({
          data: Se,
          path: j.path,
          errorMaps: [
            j.common.contextualErrorMap,
            j.schemaErrorMap,
            (0, t.getErrorMap)(),
            t.defaultErrorMap
          ].filter((Ze) => !!Ze),
          issueData: {
            code: s.ZodIssueCode.invalid_return_type,
            returnTypeError: Ke
          }
        });
      }
      const te = { errorMap: j.common.contextualErrorMap }, Ie = j.data;
      if (this._def.returns instanceof He) {
        const Se = this;
        return (0, i.OK)(async function(...Ke) {
          const Ze = new s.ZodError([]), ct = await Se._def.args.parseAsync(Ke, te).catch((Gr) => {
            throw Ze.addIssue(W(Ke, Gr)), Ze;
          }), Ut = await Reflect.apply(Ie, this, ct);
          return await Se._def.returns._def.type.parseAsync(Ut, te).catch((Gr) => {
            throw Ze.addIssue(ne(Ut, Gr)), Ze;
          });
        });
      } else {
        const Se = this;
        return (0, i.OK)(function(...Ke) {
          const Ze = Se._def.args.safeParse(Ke, te);
          if (!Ze.success)
            throw new s.ZodError([W(Ke, Ze.error)]);
          const ct = Reflect.apply(Ie, this, Ze.data), Ut = Se._def.returns.safeParse(ct, te);
          if (!Ut.success)
            throw new s.ZodError([ne(ct, Ut.error)]);
          return Ut.data;
        });
      }
    }
    parameters() {
      return this._def.args;
    }
    returnType() {
      return this._def.returns;
    }
    args(...O) {
      return new Z({
        ...this._def,
        args: q.create(O).rest(re.create())
      });
    }
    returns(O) {
      return new Z({
        ...this._def,
        returns: O
      });
    }
    implement(O) {
      return this.parse(O);
    }
    strictImplement(O) {
      return this.parse(O);
    }
    static create(O, j, W) {
      return new Z({
        args: O || q.create([]).rest(re.create()),
        returns: j || re.create(),
        typeName: qe.ZodFunction,
        ...c(W)
      });
    }
  }
  e.ZodFunction = Z;
  class Y extends l {
    get schema() {
      return this._def.getter();
    }
    _parse(O) {
      const { ctx: j } = this._processInputParams(O);
      return this._def.getter()._parse({ data: j.data, path: j.path, parent: j });
    }
  }
  e.ZodLazy = Y, Y.create = (Q, O) => new Y({
    getter: Q,
    typeName: qe.ZodLazy,
    ...c(O)
  });
  class k extends l {
    _parse(O) {
      if (O.data !== this._def.value) {
        const j = this._getOrReturnCtx(O);
        return (0, i.addIssueToContext)(j, {
          received: j.data,
          code: s.ZodIssueCode.invalid_literal,
          expected: this._def.value
        }), i.INVALID;
      }
      return { status: "valid", value: O.data };
    }
    get value() {
      return this._def.value;
    }
  }
  e.ZodLiteral = k, k.create = (Q, O) => new k({
    value: Q,
    typeName: qe.ZodLiteral,
    ...c(O)
  });
  function U(Q, O) {
    return new pe({
      values: Q,
      typeName: qe.ZodEnum,
      ...c(O)
    });
  }
  class pe extends l {
    _parse(O) {
      if (typeof O.data != "string") {
        const j = this._getOrReturnCtx(O), W = this._def.values;
        return (0, i.addIssueToContext)(j, {
          expected: n.util.joinValues(W),
          received: j.parsedType,
          code: s.ZodIssueCode.invalid_type
        }), i.INVALID;
      }
      if (this._def.values.indexOf(O.data) === -1) {
        const j = this._getOrReturnCtx(O), W = this._def.values;
        return (0, i.addIssueToContext)(j, {
          received: j.data,
          code: s.ZodIssueCode.invalid_enum_value,
          options: W
        }), i.INVALID;
      }
      return (0, i.OK)(O.data);
    }
    get options() {
      return this._def.values;
    }
    get enum() {
      const O = {};
      for (const j of this._def.values)
        O[j] = j;
      return O;
    }
    get Values() {
      const O = {};
      for (const j of this._def.values)
        O[j] = j;
      return O;
    }
    get Enum() {
      const O = {};
      for (const j of this._def.values)
        O[j] = j;
      return O;
    }
    extract(O) {
      return pe.create(O);
    }
    exclude(O) {
      return pe.create(this.options.filter((j) => !O.includes(j)));
    }
  }
  e.ZodEnum = pe, pe.create = U;
  class we extends l {
    _parse(O) {
      const j = n.util.getValidEnumValues(this._def.values), W = this._getOrReturnCtx(O);
      if (W.parsedType !== n.ZodParsedType.string && W.parsedType !== n.ZodParsedType.number) {
        const ne = n.util.objectValues(j);
        return (0, i.addIssueToContext)(W, {
          expected: n.util.joinValues(ne),
          received: W.parsedType,
          code: s.ZodIssueCode.invalid_type
        }), i.INVALID;
      }
      if (j.indexOf(O.data) === -1) {
        const ne = n.util.objectValues(j);
        return (0, i.addIssueToContext)(W, {
          received: W.data,
          code: s.ZodIssueCode.invalid_enum_value,
          options: ne
        }), i.INVALID;
      }
      return (0, i.OK)(O.data);
    }
    get enum() {
      return this._def.values;
    }
  }
  e.ZodNativeEnum = we, we.create = (Q, O) => new we({
    values: Q,
    typeName: qe.ZodNativeEnum,
    ...c(O)
  });
  class He extends l {
    unwrap() {
      return this._def.type;
    }
    _parse(O) {
      const { ctx: j } = this._processInputParams(O);
      if (j.parsedType !== n.ZodParsedType.promise && j.common.async === !1)
        return (0, i.addIssueToContext)(j, {
          code: s.ZodIssueCode.invalid_type,
          expected: n.ZodParsedType.promise,
          received: j.parsedType
        }), i.INVALID;
      const W = j.parsedType === n.ZodParsedType.promise ? j.data : Promise.resolve(j.data);
      return (0, i.OK)(W.then((ne) => this._def.type.parseAsync(ne, {
        path: j.path,
        errorMap: j.common.contextualErrorMap
      })));
    }
  }
  e.ZodPromise = He, He.create = (Q, O) => new He({
    type: Q,
    typeName: qe.ZodPromise,
    ...c(O)
  });
  class Fe extends l {
    innerType() {
      return this._def.schema;
    }
    sourceType() {
      return this._def.schema._def.typeName === qe.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(O) {
      const { status: j, ctx: W } = this._processInputParams(O), ne = this._def.effect || null, te = {
        addIssue: (Ie) => {
          (0, i.addIssueToContext)(W, Ie), Ie.fatal ? j.abort() : j.dirty();
        },
        get path() {
          return W.path;
        }
      };
      if (te.addIssue = te.addIssue.bind(te), ne.type === "preprocess") {
        const Ie = ne.transform(W.data, te);
        return W.common.issues.length ? {
          status: "dirty",
          value: W.data
        } : W.common.async ? Promise.resolve(Ie).then((Se) => this._def.schema._parseAsync({
          data: Se,
          path: W.path,
          parent: W
        })) : this._def.schema._parseSync({
          data: Ie,
          path: W.path,
          parent: W
        });
      }
      if (ne.type === "refinement") {
        const Ie = (Se) => {
          const Ke = ne.refinement(Se, te);
          if (W.common.async)
            return Promise.resolve(Ke);
          if (Ke instanceof Promise)
            throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
          return Se;
        };
        if (W.common.async === !1) {
          const Se = this._def.schema._parseSync({
            data: W.data,
            path: W.path,
            parent: W
          });
          return Se.status === "aborted" ? i.INVALID : (Se.status === "dirty" && j.dirty(), Ie(Se.value), { status: j.value, value: Se.value });
        } else
          return this._def.schema._parseAsync({ data: W.data, path: W.path, parent: W }).then((Se) => Se.status === "aborted" ? i.INVALID : (Se.status === "dirty" && j.dirty(), Ie(Se.value).then(() => ({ status: j.value, value: Se.value }))));
      }
      if (ne.type === "transform")
        if (W.common.async === !1) {
          const Ie = this._def.schema._parseSync({
            data: W.data,
            path: W.path,
            parent: W
          });
          if (!(0, i.isValid)(Ie))
            return Ie;
          const Se = ne.transform(Ie.value, te);
          if (Se instanceof Promise)
            throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
          return { status: j.value, value: Se };
        } else
          return this._def.schema._parseAsync({ data: W.data, path: W.path, parent: W }).then((Ie) => (0, i.isValid)(Ie) ? Promise.resolve(ne.transform(Ie.value, te)).then((Se) => ({ status: j.value, value: Se })) : Ie);
      n.util.assertNever(ne);
    }
  }
  e.ZodEffects = Fe, e.ZodTransformer = Fe, Fe.create = (Q, O, j) => new Fe({
    schema: Q,
    typeName: qe.ZodEffects,
    effect: O,
    ...c(j)
  }), Fe.createWithPreprocess = (Q, O, j) => new Fe({
    schema: O,
    effect: { type: "preprocess", transform: Q },
    typeName: qe.ZodEffects,
    ...c(j)
  });
  class Ge extends l {
    _parse(O) {
      return this._getType(O) === n.ZodParsedType.undefined ? (0, i.OK)(void 0) : this._def.innerType._parse(O);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  e.ZodOptional = Ge, Ge.create = (Q, O) => new Ge({
    innerType: Q,
    typeName: qe.ZodOptional,
    ...c(O)
  });
  class jt extends l {
    _parse(O) {
      return this._getType(O) === n.ZodParsedType.null ? (0, i.OK)(null) : this._def.innerType._parse(O);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  e.ZodNullable = jt, jt.create = (Q, O) => new jt({
    innerType: Q,
    typeName: qe.ZodNullable,
    ...c(O)
  });
  class Ee extends l {
    _parse(O) {
      const { ctx: j } = this._processInputParams(O);
      let W = j.data;
      return j.parsedType === n.ZodParsedType.undefined && (W = this._def.defaultValue()), this._def.innerType._parse({
        data: W,
        path: j.path,
        parent: j
      });
    }
    removeDefault() {
      return this._def.innerType;
    }
  }
  e.ZodDefault = Ee, Ee.create = (Q, O) => new Ee({
    innerType: Q,
    typeName: qe.ZodDefault,
    defaultValue: typeof O.default == "function" ? O.default : () => O.default,
    ...c(O)
  });
  class Mt extends l {
    _parse(O) {
      const { ctx: j } = this._processInputParams(O), W = {
        ...j,
        common: {
          ...j.common,
          issues: []
        }
      }, ne = this._def.innerType._parse({
        data: W.data,
        path: W.path,
        parent: {
          ...W
        }
      });
      return (0, i.isAsync)(ne) ? ne.then((te) => ({
        status: "valid",
        value: te.status === "valid" ? te.value : this._def.catchValue({
          get error() {
            return new s.ZodError(W.common.issues);
          },
          input: W.data
        })
      })) : {
        status: "valid",
        value: ne.status === "valid" ? ne.value : this._def.catchValue({
          get error() {
            return new s.ZodError(W.common.issues);
          },
          input: W.data
        })
      };
    }
    removeCatch() {
      return this._def.innerType;
    }
  }
  e.ZodCatch = Mt, Mt.create = (Q, O) => new Mt({
    innerType: Q,
    typeName: qe.ZodCatch,
    catchValue: typeof O.catch == "function" ? O.catch : () => O.catch,
    ...c(O)
  });
  class St extends l {
    _parse(O) {
      if (this._getType(O) !== n.ZodParsedType.nan) {
        const W = this._getOrReturnCtx(O);
        return (0, i.addIssueToContext)(W, {
          code: s.ZodIssueCode.invalid_type,
          expected: n.ZodParsedType.nan,
          received: W.parsedType
        }), i.INVALID;
      }
      return { status: "valid", value: O.data };
    }
  }
  e.ZodNaN = St, St.create = (Q) => new St({
    typeName: qe.ZodNaN,
    ...c(Q)
  }), e.BRAND = Symbol("zod_brand");
  class Ne extends l {
    _parse(O) {
      const { ctx: j } = this._processInputParams(O), W = j.data;
      return this._def.type._parse({
        data: W,
        path: j.path,
        parent: j
      });
    }
    unwrap() {
      return this._def.type;
    }
  }
  e.ZodBranded = Ne;
  class Le extends l {
    _parse(O) {
      const { status: j, ctx: W } = this._processInputParams(O);
      if (W.common.async)
        return (async () => {
          const te = await this._def.in._parseAsync({
            data: W.data,
            path: W.path,
            parent: W
          });
          return te.status === "aborted" ? i.INVALID : te.status === "dirty" ? (j.dirty(), (0, i.DIRTY)(te.value)) : this._def.out._parseAsync({
            data: te.value,
            path: W.path,
            parent: W
          });
        })();
      {
        const ne = this._def.in._parseSync({
          data: W.data,
          path: W.path,
          parent: W
        });
        return ne.status === "aborted" ? i.INVALID : ne.status === "dirty" ? (j.dirty(), {
          status: "dirty",
          value: ne.value
        }) : this._def.out._parseSync({
          data: ne.value,
          path: W.path,
          parent: W
        });
      }
    }
    static create(O, j) {
      return new Le({
        in: O,
        out: j,
        typeName: qe.ZodPipeline
      });
    }
  }
  e.ZodPipeline = Le;
  class at extends l {
    _parse(O) {
      const j = this._def.innerType._parse(O);
      return (0, i.isValid)(j) && (j.value = Object.freeze(j.value)), j;
    }
  }
  e.ZodReadonly = at, at.create = (Q, O) => new at({
    innerType: Q,
    typeName: qe.ZodReadonly,
    ...c(O)
  });
  const mt = (Q, O = {}, j) => Q ? je.create().superRefine((W, ne) => {
    var te, Ie;
    if (!Q(W)) {
      const Se = typeof O == "function" ? O(W) : typeof O == "string" ? { message: O } : O, Ke = (Ie = (te = Se.fatal) !== null && te !== void 0 ? te : j) !== null && Ie !== void 0 ? Ie : !0, Ze = typeof Se == "string" ? { message: Se } : Se;
      ne.addIssue({ code: "custom", ...Ze, fatal: Ke });
    }
  }) : je.create();
  e.custom = mt, e.late = {
    object: _e.lazycreate
  };
  var qe;
  (function(Q) {
    Q.ZodString = "ZodString", Q.ZodNumber = "ZodNumber", Q.ZodNaN = "ZodNaN", Q.ZodBigInt = "ZodBigInt", Q.ZodBoolean = "ZodBoolean", Q.ZodDate = "ZodDate", Q.ZodSymbol = "ZodSymbol", Q.ZodUndefined = "ZodUndefined", Q.ZodNull = "ZodNull", Q.ZodAny = "ZodAny", Q.ZodUnknown = "ZodUnknown", Q.ZodNever = "ZodNever", Q.ZodVoid = "ZodVoid", Q.ZodArray = "ZodArray", Q.ZodObject = "ZodObject", Q.ZodUnion = "ZodUnion", Q.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", Q.ZodIntersection = "ZodIntersection", Q.ZodTuple = "ZodTuple", Q.ZodRecord = "ZodRecord", Q.ZodMap = "ZodMap", Q.ZodSet = "ZodSet", Q.ZodFunction = "ZodFunction", Q.ZodLazy = "ZodLazy", Q.ZodLiteral = "ZodLiteral", Q.ZodEnum = "ZodEnum", Q.ZodEffects = "ZodEffects", Q.ZodNativeEnum = "ZodNativeEnum", Q.ZodOptional = "ZodOptional", Q.ZodNullable = "ZodNullable", Q.ZodDefault = "ZodDefault", Q.ZodCatch = "ZodCatch", Q.ZodPromise = "ZodPromise", Q.ZodBranded = "ZodBranded", Q.ZodPipeline = "ZodPipeline", Q.ZodReadonly = "ZodReadonly";
  })(qe = e.ZodFirstPartyTypeKind || (e.ZodFirstPartyTypeKind = {}));
  const L = (Q, O = {
    message: `Input not instance of ${Q.name}`
  }) => (0, e.custom)((j) => j instanceof Q, O);
  e.instanceof = L;
  const x = E.create;
  e.string = x;
  const S = R.create;
  e.number = S;
  const G = St.create;
  e.nan = G;
  const ce = I.create;
  e.bigint = ce;
  const me = D.create;
  e.boolean = me;
  const Oe = J.create;
  e.date = Oe;
  const ut = ae.create;
  e.symbol = ut;
  const Dt = ye.create;
  e.undefined = Dt;
  const Tt = xe.create;
  e.null = Tt;
  const wt = je.create;
  e.any = wt;
  const It = re.create;
  e.unknown = It;
  const $o = fe.create;
  e.never = $o;
  const Eo = le.create;
  e.void = Eo;
  const ua = $e.create;
  e.array = ua;
  const ca = _e.create;
  e.object = ca;
  const xo = _e.strictCreate;
  e.strictObject = xo;
  const Fn = ie.create;
  e.union = Fn;
  const Oo = V.create;
  e.discriminatedUnion = Oo;
  const la = C.create;
  e.intersection = la;
  const fa = q.create;
  e.tuple = fa;
  const $s = N.create;
  e.record = $s;
  const da = F.create;
  e.map = da;
  const Po = T.create;
  e.set = Po;
  const Ni = Z.create;
  e.function = Ni;
  const So = Y.create;
  e.lazy = So;
  const Di = k.create;
  e.literal = Di;
  const se = pe.create;
  e.enum = se;
  const X = we.create;
  e.nativeEnum = X;
  const ue = He.create;
  e.promise = ue;
  const ve = Fe.create;
  e.effect = ve, e.transformer = ve;
  const ge = Ge.create;
  e.optional = ge;
  const Ye = jt.create;
  e.nullable = Ye;
  const Xe = Fe.createWithPreprocess;
  e.preprocess = Xe;
  const Et = Le.create;
  e.pipeline = Et;
  const Lt = () => x().optional();
  e.ostring = Lt;
  const Wt = () => S().optional();
  e.onumber = Wt;
  const vt = () => me().optional();
  e.oboolean = vt, e.coerce = {
    string: (Q) => E.create({ ...Q, coerce: !0 }),
    number: (Q) => R.create({ ...Q, coerce: !0 }),
    boolean: (Q) => D.create({
      ...Q,
      coerce: !0
    }),
    bigint: (Q) => I.create({ ...Q, coerce: !0 }),
    date: (Q) => J.create({ ...Q, coerce: !0 })
  }, e.NEVER = i.INVALID;
})(HE);
(function(e) {
  var t = rt && rt.__createBinding || (Object.create ? function(i, n, s, a) {
    a === void 0 && (a = s), Object.defineProperty(i, a, { enumerable: !0, get: function() {
      return n[s];
    } });
  } : function(i, n, s, a) {
    a === void 0 && (a = s), i[a] = n[s];
  }), r = rt && rt.__exportStar || function(i, n) {
    for (var s in i)
      s !== "default" && !Object.prototype.hasOwnProperty.call(n, s) && t(n, i, s);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), r(Qn, e), r(Eg, e), r(WE, e), r(Xu, e), r(HE, e), r(ei, e);
})(gy);
(function(e) {
  var t = rt && rt.__createBinding || (Object.create ? function(a, u, c, l) {
    l === void 0 && (l = c), Object.defineProperty(a, l, { enumerable: !0, get: function() {
      return u[c];
    } });
  } : function(a, u, c, l) {
    l === void 0 && (l = c), a[l] = u[c];
  }), r = rt && rt.__setModuleDefault || (Object.create ? function(a, u) {
    Object.defineProperty(a, "default", { enumerable: !0, value: u });
  } : function(a, u) {
    a.default = u;
  }), i = rt && rt.__importStar || function(a) {
    if (a && a.__esModule)
      return a;
    var u = {};
    if (a != null)
      for (var c in a)
        c !== "default" && Object.prototype.hasOwnProperty.call(a, c) && t(u, a, c);
    return r(u, a), u;
  }, n = rt && rt.__exportStar || function(a, u) {
    for (var c in a)
      c !== "default" && !Object.prototype.hasOwnProperty.call(u, c) && t(u, a, c);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.z = void 0;
  const s = i(gy);
  e.z = s, n(gy, e), e.default = s;
})(BE);
Object.defineProperty(Qs, "__esModule", { value: !0 });
Qs.generateSchema = Qs.extendApi = void 0;
const nr = $g, Tl = BE;
function jN(e, t = {}) {
  return e.metaOpenApi = Object.assign(e.metaOpenApi || {}, t), e;
}
Qs.extendApi = jN;
function kN({ zodRef: e, useOutput: t, hideDefinitions: r }) {
  return Object.keys(e.shape).filter((n) => (r == null ? void 0 : r.includes(n)) === !1).reduce((n, s) => Object.assign(Object.assign({}, n), { [s]: Lr(e.shape[s], t) }), {});
}
function E1({ zodRef: e, schemas: t, useOutput: r }) {
  const i = Lr(e._def.schema, r);
  let n = "undefined";
  if (r && e._def.effect) {
    const s = e._def.effect.type === "transform" ? e._def.effect : null;
    if (s && "transform" in s)
      try {
        n = typeof s.transform(
          ["integer", "number"].includes(`${i.type}`) ? 0 : i.type === "string" ? "" : i.type === "boolean" ? !1 : i.type === "object" ? {} : i.type === "null" ? null : i.type === "array" ? [] : void 0,
          { addIssue: () => {
          }, path: [] }
          // TODO: Discover if context is necessary here
        );
      } catch {
      }
  }
  return (0, nr.default)(Object.assign(Object.assign(Object.assign({}, e.description ? { description: e.description } : {}), i), ["number", "string", "boolean", "null"].includes(n) ? {
    type: n
  } : {}), ...t);
}
function MN({ zodRef: e, schemas: t }) {
  const r = {
    type: "string"
  }, { checks: i = [] } = e._def;
  return i.forEach((n) => {
    switch (n.kind) {
      case "email":
        r.format = "email";
        break;
      case "uuid":
        r.format = "uuid";
        break;
      case "cuid":
        r.format = "cuid";
        break;
      case "url":
        r.format = "uri";
        break;
      case "datetime":
        r.format = "date-time";
        break;
      case "length":
        r.minLength = n.value, r.maxLength = n.value;
        break;
      case "max":
        r.maxLength = n.value;
        break;
      case "min":
        r.minLength = n.value;
        break;
      case "regex":
        r.pattern = n.regex.source;
        break;
    }
  }), (0, nr.default)(r, e.description ? { description: e.description } : {}, ...t);
}
function NN({ zodRef: e, schemas: t }) {
  const r = {
    type: "number"
  }, { checks: i = [] } = e._def;
  return i.forEach((n) => {
    switch (n.kind) {
      case "max":
        r.maximum = n.value, n.inclusive || (r.exclusiveMaximum = n.value);
        break;
      case "min":
        r.minimum = n.value, n.inclusive || (r.exclusiveMinimum = n.value);
        break;
      case "int":
        r.type = "integer";
        break;
      case "multipleOf":
        r.multipleOf = n.value;
    }
  }), (0, nr.default)(r, e.description ? { description: e.description } : {}, ...t);
}
function DN(e) {
  const t = [];
  for (const r of e)
    Array.isArray(r.hideDefinitions) && t.push(...r.hideDefinitions);
  return t;
}
function LN({ zodRef: e, schemas: t, useOutput: r, hideDefinitions: i }) {
  var n;
  let s;
  e._def.catchall instanceof Tl.z.ZodNever || ((n = e._def.catchall) === null || n === void 0 ? void 0 : n._def.typeName) === "ZodNever" ? e._def.unknownKeys === "passthrough" ? s = !0 : e._def.unknownKeys === "strict" && (s = !1) : s = Lr(e._def.catchall, r), s = s != null ? { additionalProperties: s } : {};
  const a = Object.keys(e.shape).filter((c) => {
    const l = e.shape[c];
    return !(l.isOptional() || l instanceof Tl.z.ZodDefault || l._def.typeName === "ZodDefault") && !(l instanceof Tl.z.ZodNever || l._def.typeName === "ZodDefault");
  }), u = a.length > 0 ? { required: a } : {};
  return (0, nr.default)(Object.assign(Object.assign(Object.assign({ type: "object", properties: kN({
    zodRef: e,
    schemas: t,
    useOutput: r,
    hideDefinitions: DN(t)
  }) }, u), s), i), e.description ? { description: e.description, hideDefinitions: i } : {}, ...t);
}
function qN({ zodRef: e, schemas: t, useOutput: r }) {
  return (0, nr.default)({
    type: "object",
    additionalProperties: e._def.valueType instanceof Tl.z.ZodUnknown ? {} : Lr(e._def.valueType, r)
  }, e.description ? { description: e.description } : {}, ...t);
}
function FN({ zodRef: e, schemas: t }) {
  return (0, nr.default)({ type: "integer", format: "int64" }, e.description ? { description: e.description } : {}, ...t);
}
function UN({ zodRef: e, schemas: t }) {
  return (0, nr.default)({ type: "boolean" }, e.description ? { description: e.description } : {}, ...t);
}
function BN({ zodRef: e, schemas: t }) {
  return (0, nr.default)({ type: "string", format: "date-time" }, e.description ? { description: e.description } : {}, ...t);
}
function VN({ zodRef: e, schemas: t }) {
  return (0, nr.default)({
    type: "string",
    format: "null",
    nullable: !0
  }, e.description ? { description: e.description } : {}, ...t);
}
function x1({ schemas: e, zodRef: t, useOutput: r }) {
  return (0, nr.default)(Lr(t.unwrap(), r), t.description ? { description: t.description } : {}, ...e);
}
function ZN({ schemas: e, zodRef: t, useOutput: r }) {
  return (0, nr.default)(Object.assign({ default: t._def.defaultValue() }, Lr(t._def.innerType, r)), t.description ? { description: t.description } : {}, ...e);
}
function zN({ schemas: e, zodRef: t, useOutput: r }) {
  const i = {};
  return t._def.exactLength != null && (i.minItems = t._def.exactLength.value, i.maxItems = t._def.exactLength.value), t._def.minLength != null && (i.minItems = t._def.minLength.value), t._def.maxLength != null && (i.maxItems = t._def.maxLength.value), (0, nr.default)(Object.assign({ type: "array", items: Lr(t.element, r) }, i), t.description ? { description: t.description } : {}, ...e);
}
function WN({ schemas: e, zodRef: t }) {
  return (0, nr.default)({
    type: typeof t._def.value,
    enum: [t._def.value]
  }, t.description ? { description: t.description } : {}, ...e);
}
function O1({ schemas: e, zodRef: t }) {
  return (0, nr.default)({
    type: typeof Object.values(t._def.values)[0],
    enum: Object.values(t._def.values)
  }, t.description ? { description: t.description } : {}, ...e);
}
function HN({ schemas: e, zodRef: t, useOutput: r }) {
  return (0, nr.default)({
    allOf: [
      Lr(t._def.left, r),
      Lr(t._def.right, r)
    ]
  }, t.description ? { description: t.description } : {}, ...e);
}
function GN({ schemas: e, zodRef: t, useOutput: r }) {
  const i = t._def.options;
  if (i.reduce((n, s) => n && s._def.typeName === "ZodLiteral", !0)) {
    const n = i, s = n.reduce((a, u) => !a || a === typeof u._def.value ? typeof u._def.value : null, null);
    if (s)
      return (0, nr.default)({
        type: s,
        enum: n.map((a) => a._def.value)
      }, t.description ? { description: t.description } : {}, ...e);
  }
  return (0, nr.default)({
    oneOf: i.map((n) => Lr(n, r))
  }, t.description ? { description: t.description } : {}, ...e);
}
function KN({ schemas: e, zodRef: t, useOutput: r }) {
  return (0, nr.default)({
    discriminator: {
      propertyName: t._def.discriminator
    },
    oneOf: Array.from(t._def.options.values()).map((i) => Lr(i, r))
  }, t.description ? { description: t.description } : {}, ...e);
}
function YN({ zodRef: e, schemas: t }) {
  return (0, nr.default)({ readOnly: !0 }, e.description ? { description: e.description } : {}, ...t);
}
function JN({ schemas: e, zodRef: t }) {
  return (0, nr.default)(Lr(t._def.type), ...e);
}
function Sn({ zodRef: e, schemas: t }) {
  return (0, nr.default)(e.description ? { description: e.description } : {}, ...t);
}
function XN({ zodRef: e, useOutput: t }) {
  return Lr(t ? e._def.out : e._def.in, t);
}
const P1 = {
  ZodObject: LN,
  ZodRecord: qN,
  ZodString: MN,
  ZodNumber: NN,
  ZodBigInt: FN,
  ZodBoolean: UN,
  ZodDate: BN,
  ZodNull: VN,
  ZodOptional: x1,
  ZodNullable: x1,
  ZodDefault: ZN,
  ZodArray: zN,
  ZodLiteral: WN,
  ZodEnum: O1,
  ZodNativeEnum: O1,
  ZodTransformer: E1,
  ZodEffects: E1,
  ZodIntersection: HN,
  ZodUnion: GN,
  ZodDiscriminatedUnion: KN,
  ZodNever: YN,
  ZodBranded: JN,
  // TODO Transform the rest to schemas
  ZodUndefined: Sn,
  // TODO: `prefixItems` is allowed in OpenAPI 3.1 which can be used to create tuples
  ZodTuple: Sn,
  ZodMap: Sn,
  ZodFunction: Sn,
  ZodLazy: Sn,
  ZodPromise: Sn,
  ZodAny: Sn,
  ZodUnknown: Sn,
  ZodVoid: Sn,
  ZodPipeline: XN
};
function Lr(e, t) {
  const { metaOpenApi: r = {} } = e, i = [
    e.isNullable && e.isNullable() ? { nullable: !0 } : {},
    ...Array.isArray(r) ? r : [r]
  ];
  try {
    const n = e._def.typeName;
    return n in P1 ? P1[n]({
      zodRef: e,
      schemas: i,
      useOutput: t
    }) : Sn({ zodRef: e, schemas: i });
  } catch (n) {
    return console.error(n), Sn({ zodRef: e, schemas: i });
  }
}
Qs.generateSchema = Lr;
var Vf = {};
Object.defineProperty(Vf, "__esModule", { value: !0 });
Vf.extendZodWithOpenApi = void 0;
const QN = Qs;
function e5(e, t = !1) {
  !t && typeof e.ZodSchema.prototype.openapi < "u" || (e.ZodSchema.prototype.openapi = function(r) {
    return (0, QN.extendApi)(this, r);
  });
}
Vf.extendZodWithOpenApi = e5;
(function(e) {
  var t = rt && rt.__createBinding || (Object.create ? function(i, n, s, a) {
    a === void 0 && (a = s);
    var u = Object.getOwnPropertyDescriptor(n, s);
    (!u || ("get" in u ? !n.__esModule : u.writable || u.configurable)) && (u = { enumerable: !0, get: function() {
      return n[s];
    } }), Object.defineProperty(i, a, u);
  } : function(i, n, s, a) {
    a === void 0 && (a = s), i[a] = n[s];
  }), r = rt && rt.__exportStar || function(i, n) {
    for (var s in i)
      s !== "default" && !Object.prototype.hasOwnProperty.call(n, s) && t(n, i, s);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), r(Qs, e), r(Vf, e);
})(UE);
const t5 = !1, r5 = /\r?\n/, n5 = /\bono[ @]/;
function i5(e) {
  return !!(e && e.configurable && typeof e.get == "function");
}
function s5(e) {
  return !!// If there is no stack property, then it's writable, since assigning it will create it
  (!e || e.writable || typeof e.set == "function");
}
function KE(e, t) {
  let r = YE(e.stack), i = t ? t.stack : void 0;
  return r && i ? r + `

` + i : r || i;
}
function a5(e, t, r) {
  r ? Object.defineProperty(t, "stack", {
    get: () => {
      let i = e.get.apply(t);
      return KE({ stack: i }, r);
    },
    enumerable: !1,
    configurable: !0
  }) : o5(t, e);
}
function YE(e) {
  if (e) {
    let t = e.split(r5), r;
    for (let i = 0; i < t.length; i++) {
      let n = t[i];
      if (n5.test(n))
        r === void 0 && (r = i);
      else if (r !== void 0) {
        t.splice(r, i - r);
        break;
      }
    }
    if (t.length > 0)
      return t.join(`
`);
  }
  return e;
}
function o5(e, t) {
  Object.defineProperty(e, "stack", {
    get: () => YE(t.get.apply(e)),
    enumerable: !1,
    configurable: !0
  });
}
const u5 = ["function", "symbol", "undefined"], c5 = ["constructor", "prototype", "__proto__"], l5 = Object.getPrototypeOf({});
function JE() {
  let e = {}, t = this;
  for (let r of XE(t))
    if (typeof r == "string") {
      let i = t[r], n = typeof i;
      u5.includes(n) || (e[r] = i);
    }
  return e;
}
function XE(e, t = []) {
  let r = [];
  for (; e && e !== l5; )
    r = r.concat(Object.getOwnPropertyNames(e), Object.getOwnPropertySymbols(e)), e = Object.getPrototypeOf(e);
  let i = new Set(r);
  for (let n of t.concat(c5))
    i.delete(n);
  return i;
}
const f5 = ["name", "message", "stack"];
function Il(e, t, r) {
  let i = e;
  return d5(i, t), t && typeof t == "object" && p5(i, t), i.toJSON = JE, r && typeof r == "object" && Object.assign(i, r), i;
}
function d5(e, t) {
  let r = Object.getOwnPropertyDescriptor(e, "stack");
  i5(r) ? a5(r, e, t) : s5(r) && (e.stack = KE(e, t));
}
function p5(e, t) {
  let r = XE(t, f5), i = e, n = t;
  for (let s of r)
    if (i[s] === void 0)
      try {
        i[s] = n[s];
      } catch {
      }
}
function h5(e) {
  return e = e || {}, {
    concatMessages: e.concatMessages === void 0 ? !0 : !!e.concatMessages,
    format: e.format === void 0 ? t5 : typeof e.format == "function" ? e.format : !1
  };
}
function m5(e, t) {
  let r, i, n, s = "";
  return typeof e[0] == "string" ? n = e : typeof e[1] == "string" ? (e[0] instanceof Error ? r = e[0] : i = e[0], n = e.slice(1)) : (r = e[0], i = e[1], n = e.slice(2)), n.length > 0 && (t.format ? s = t.format.apply(void 0, n) : s = n.join(" ")), t.concatMessages && r && r.message && (s += (s ? ` 
` : "") + r.message), { originalError: r, props: i, message: s };
}
const vs = xg;
function xg(e, t) {
  t = h5(t);
  function r(...i) {
    let { originalError: n, props: s, message: a } = m5(i, t), u = new e(a);
    return Il(u, n, s);
  }
  return r[Symbol.species] = e, r;
}
xg.toJSON = function(t) {
  return JE.call(t);
};
xg.extend = function(t, r, i) {
  return i || r instanceof Error ? Il(t, r, i) : r ? Il(t, void 0, r) : Il(t);
};
const S1 = si;
si.error = new vs(Error);
si.eval = new vs(EvalError);
si.range = new vs(RangeError);
si.reference = new vs(ReferenceError);
si.syntax = new vs(SyntaxError);
si.type = new vs(TypeError);
si.uri = new vs(URIError);
const y5 = si;
function si(...e) {
  let t = e[0];
  if (typeof t == "object" && typeof t.name == "string") {
    for (let r of Object.values(y5))
      if (typeof r == "function" && r.name === "ono") {
        let i = r[Symbol.species];
        if (i && i !== Error && (t instanceof i || t.name === i.name))
          return r.apply(void 0, e);
      }
  }
  return si.error.apply(void 0, e);
}
typeof module == "object" && typeof module.exports == "object" && (module.exports = Object.assign(module.exports.default, module.exports));
const g5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Ono: vs,
  default: S1,
  ono: S1
}, Symbol.toStringTag, { value: "Module" })), Nn = /* @__PURE__ */ kf(g5);
var ai = { exports: {} };
function v5() {
  return typeof Me.process == "object" && typeof Me.process.nextTick == "function" ? Me.process.nextTick : typeof setImmediate == "function" ? setImmediate : function(t) {
    setTimeout(t, 0);
  };
}
var b5 = v5(), A1 = b5, QE = function(t, r) {
  if (t) {
    r.then(function(i) {
      A1(function() {
        t(null, i);
      });
    }, function(i) {
      A1(function() {
        t(i);
      });
    });
    return;
  } else
    return r;
}, or = {}, by = { exports: {} }, lf = { exports: {} };
/*! https://mths.be/punycode v1.4.1 by @mathias */
lf.exports;
(function(e, t) {
  (function(r) {
    var i = t && !t.nodeType && t, n = e && !e.nodeType && e, s = typeof rt == "object" && rt;
    (s.global === s || s.window === s || s.self === s) && (r = s);
    var a, u = 2147483647, c = 36, l = 1, d = 26, p = 38, h = 700, v = 72, y = 128, g = "-", _ = /^xn--/, m = /[^\x20-\x7E]/, w = /[\x2E\u3002\uFF0E\uFF61]/g, $ = {
      overflow: "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    }, E = c - l, A = Math.floor, R = String.fromCharCode, I;
    function D(ie) {
      throw new RangeError($[ie]);
    }
    function J(ie, K) {
      for (var V = ie.length, z = []; V--; )
        z[V] = K(ie[V]);
      return z;
    }
    function ae(ie, K) {
      var V = ie.split("@"), z = "";
      V.length > 1 && (z = V[0] + "@", ie = V[1]), ie = ie.replace(w, ".");
      var C = ie.split("."), q = J(C, K).join(".");
      return z + q;
    }
    function ye(ie) {
      for (var K = [], V = 0, z = ie.length, C, q; V < z; )
        C = ie.charCodeAt(V++), C >= 55296 && C <= 56319 && V < z ? (q = ie.charCodeAt(V++), (q & 64512) == 56320 ? K.push(((C & 1023) << 10) + (q & 1023) + 65536) : (K.push(C), V--)) : K.push(C);
      return K;
    }
    function xe(ie) {
      return J(ie, function(K) {
        var V = "";
        return K > 65535 && (K -= 65536, V += R(K >>> 10 & 1023 | 55296), K = 56320 | K & 1023), V += R(K), V;
      }).join("");
    }
    function je(ie) {
      return ie - 48 < 10 ? ie - 22 : ie - 65 < 26 ? ie - 65 : ie - 97 < 26 ? ie - 97 : c;
    }
    function re(ie, K) {
      return ie + 22 + 75 * (ie < 26) - ((K != 0) << 5);
    }
    function fe(ie, K, V) {
      var z = 0;
      for (ie = V ? A(ie / h) : ie >> 1, ie += A(ie / K); ie > E * d >> 1; z += c)
        ie = A(ie / E);
      return A(z + (E + 1) * ie / (ie + p));
    }
    function le(ie) {
      var K = [], V = ie.length, z, C = 0, q = y, N = v, F, T, Z, Y, k, U, pe, we, He;
      for (F = ie.lastIndexOf(g), F < 0 && (F = 0), T = 0; T < F; ++T)
        ie.charCodeAt(T) >= 128 && D("not-basic"), K.push(ie.charCodeAt(T));
      for (Z = F > 0 ? F + 1 : 0; Z < V; ) {
        for (Y = C, k = 1, U = c; Z >= V && D("invalid-input"), pe = je(ie.charCodeAt(Z++)), (pe >= c || pe > A((u - C) / k)) && D("overflow"), C += pe * k, we = U <= N ? l : U >= N + d ? d : U - N, !(pe < we); U += c)
          He = c - we, k > A(u / He) && D("overflow"), k *= He;
        z = K.length + 1, N = fe(C - Y, z, Y == 0), A(C / z) > u - q && D("overflow"), q += A(C / z), C %= z, K.splice(C++, 0, q);
      }
      return xe(K);
    }
    function $e(ie) {
      var K, V, z, C, q, N, F, T, Z, Y, k, U = [], pe, we, He, Fe;
      for (ie = ye(ie), pe = ie.length, K = y, V = 0, q = v, N = 0; N < pe; ++N)
        k = ie[N], k < 128 && U.push(R(k));
      for (z = C = U.length, C && U.push(g); z < pe; ) {
        for (F = u, N = 0; N < pe; ++N)
          k = ie[N], k >= K && k < F && (F = k);
        for (we = z + 1, F - K > A((u - V) / we) && D("overflow"), V += (F - K) * we, K = F, N = 0; N < pe; ++N)
          if (k = ie[N], k < K && ++V > u && D("overflow"), k == K) {
            for (T = V, Z = c; Y = Z <= q ? l : Z >= q + d ? d : Z - q, !(T < Y); Z += c)
              Fe = T - Y, He = c - Y, U.push(
                R(re(Y + Fe % He, 0))
              ), T = A(Fe / He);
            U.push(R(re(T, 0))), q = fe(V, we, z == C), V = 0, ++z;
          }
        ++V, ++K;
      }
      return U.join("");
    }
    function Ae(ie) {
      return ae(ie, function(K) {
        return _.test(K) ? le(K.slice(4).toLowerCase()) : K;
      });
    }
    function _e(ie) {
      return ae(ie, function(K) {
        return m.test(K) ? "xn--" + $e(K) : K;
      });
    }
    if (a = {
      /**
       * A string representing the current Punycode.js version number.
       * @memberOf punycode
       * @type String
       */
      version: "1.4.1",
      /**
       * An object of methods to convert from JavaScript's internal character
       * representation (UCS-2) to Unicode code points, and back.
       * @see <https://mathiasbynens.be/notes/javascript-encoding>
       * @memberOf punycode
       * @type Object
       */
      ucs2: {
        decode: ye,
        encode: xe
      },
      decode: le,
      encode: $e,
      toASCII: _e,
      toUnicode: Ae
    }, i && n)
      if (e.exports == i)
        n.exports = a;
      else
        for (I in a)
          a.hasOwnProperty(I) && (i[I] = a[I]);
    else
      r.punycode = a;
  })(rt);
})(lf, lf.exports);
var _5 = lf.exports;
const w5 = /* @__PURE__ */ ta(_5);
function $5(e, t) {
  return Object.prototype.hasOwnProperty.call(e, t);
}
var E5 = function(e, t, r, i) {
  t = t || "&", r = r || "=";
  var n = {};
  if (typeof e != "string" || e.length === 0)
    return n;
  var s = /\+/g;
  e = e.split(t);
  var a = 1e3;
  i && typeof i.maxKeys == "number" && (a = i.maxKeys);
  var u = e.length;
  a > 0 && u > a && (u = a);
  for (var c = 0; c < u; ++c) {
    var l = e[c].replace(s, "%20"), d = l.indexOf(r), p, h, v, y;
    d >= 0 ? (p = l.substr(0, d), h = l.substr(d + 1)) : (p = l, h = ""), v = decodeURIComponent(p), y = decodeURIComponent(h), $5(n, v) ? x5(n[v]) ? n[v].push(y) : n[v] = [n[v], y] : n[v] = y;
  }
  return n;
}, x5 = Array.isArray || function(e) {
  return Object.prototype.toString.call(e) === "[object Array]";
}, zo = function(e) {
  switch (typeof e) {
    case "string":
      return e;
    case "boolean":
      return e ? "true" : "false";
    case "number":
      return isFinite(e) ? e : "";
    default:
      return "";
  }
}, O5 = function(e, t, r, i) {
  return t = t || "&", r = r || "=", e === null && (e = void 0), typeof e == "object" ? C1(S5(e), function(n) {
    var s = encodeURIComponent(zo(n)) + r;
    return P5(e[n]) ? C1(e[n], function(a) {
      return s + encodeURIComponent(zo(a));
    }).join(t) : s + encodeURIComponent(zo(e[n]));
  }).join(t) : i ? encodeURIComponent(zo(i)) + r + encodeURIComponent(zo(e)) : "";
}, P5 = Array.isArray || function(e) {
  return Object.prototype.toString.call(e) === "[object Array]";
};
function C1(e, t) {
  if (e.map)
    return e.map(t);
  for (var r = [], i = 0; i < e.length; i++)
    r.push(t(e[i], i));
  return r;
}
var S5 = Object.keys || function(e) {
  var t = [];
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.push(r);
  return t;
}, Og, Pg, ex = Pg = E5, tx = Og = O5;
function rx(e) {
  return encodeURIComponent(e);
}
function nx(e) {
  return decodeURIComponent(e);
}
var ix = {
  decode: ex,
  encode: tx,
  parse: Pg,
  stringify: Og,
  escape: rx,
  unescape: nx
};
const A5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: ex,
  default: ix,
  encode: tx,
  escape: rx,
  get parse() {
    return Pg;
  },
  get stringify() {
    return Og;
  },
  unescape: nx
}, Symbol.toStringTag, { value: "Module" }));
var C5 = {
  isString: function(e) {
    return typeof e == "string";
  },
  isObject: function(e) {
    return typeof e == "object" && e !== null;
  },
  isNull: function(e) {
    return e === null;
  },
  isNullOrUndefined: function(e) {
    return e == null;
  }
}, R5 = w5, Gn = C5, T5 = Qu, I5 = Z5, sx = z5, j5 = V5, k5 = mn;
function mn() {
  this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
}
var M5 = /^([a-z0-9.+-]+:)/i, N5 = /:[0-9]*$/, D5 = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, L5 = ["<", ">", '"', "`", " ", "\r", `
`, "	"], q5 = ["{", "}", "|", "\\", "^", "`"].concat(L5), _y = ["'"].concat(q5), R1 = ["%", "/", "?", ";", "#"].concat(_y), T1 = ["/", "?", "#"], F5 = 255, I1 = /^[+a-z0-9A-Z_-]{0,63}$/, U5 = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, B5 = {
  javascript: !0,
  "javascript:": !0
}, wy = {
  javascript: !0,
  "javascript:": !0
}, Ja = {
  http: !0,
  https: !0,
  ftp: !0,
  gopher: !0,
  file: !0,
  "http:": !0,
  "https:": !0,
  "ftp:": !0,
  "gopher:": !0,
  "file:": !0
}, $y = ix;
function Qu(e, t, r) {
  if (e && Gn.isObject(e) && e instanceof mn)
    return e;
  var i = new mn();
  return i.parse(e, t, r), i;
}
mn.prototype.parse = function(e, t, r) {
  if (!Gn.isString(e))
    throw new TypeError("Parameter 'url' must be a string, not " + typeof e);
  var i = e.indexOf("?"), n = i !== -1 && i < e.indexOf("#") ? "?" : "#", s = e.split(n), a = /\\/g;
  s[0] = s[0].replace(a, "/"), e = s.join(n);
  var u = e;
  if (u = u.trim(), !r && e.split("#").length === 1) {
    var c = D5.exec(u);
    if (c)
      return this.path = u, this.href = u, this.pathname = c[1], c[2] ? (this.search = c[2], t ? this.query = $y.parse(this.search.substr(1)) : this.query = this.search.substr(1)) : t && (this.search = "", this.query = {}), this;
  }
  var l = M5.exec(u);
  if (l) {
    l = l[0];
    var d = l.toLowerCase();
    this.protocol = d, u = u.substr(l.length);
  }
  if (r || l || u.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var p = u.substr(0, 2) === "//";
    p && !(l && wy[l]) && (u = u.substr(2), this.slashes = !0);
  }
  if (!wy[l] && (p || l && !Ja[l])) {
    for (var h = -1, v = 0; v < T1.length; v++) {
      var y = u.indexOf(T1[v]);
      y !== -1 && (h === -1 || y < h) && (h = y);
    }
    var g, _;
    h === -1 ? _ = u.lastIndexOf("@") : _ = u.lastIndexOf("@", h), _ !== -1 && (g = u.slice(0, _), u = u.slice(_ + 1), this.auth = decodeURIComponent(g)), h = -1;
    for (var v = 0; v < R1.length; v++) {
      var y = u.indexOf(R1[v]);
      y !== -1 && (h === -1 || y < h) && (h = y);
    }
    h === -1 && (h = u.length), this.host = u.slice(0, h), u = u.slice(h), this.parseHost(), this.hostname = this.hostname || "";
    var m = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!m)
      for (var w = this.hostname.split(/\./), v = 0, $ = w.length; v < $; v++) {
        var E = w[v];
        if (E && !E.match(I1)) {
          for (var A = "", R = 0, I = E.length; R < I; R++)
            E.charCodeAt(R) > 127 ? A += "x" : A += E[R];
          if (!A.match(I1)) {
            var D = w.slice(0, v), J = w.slice(v + 1), ae = E.match(U5);
            ae && (D.push(ae[1]), J.unshift(ae[2])), J.length && (u = "/" + J.join(".") + u), this.hostname = D.join(".");
            break;
          }
        }
      }
    this.hostname.length > F5 ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), m || (this.hostname = R5.toASCII(this.hostname));
    var ye = this.port ? ":" + this.port : "", xe = this.hostname || "";
    this.host = xe + ye, this.href += this.host, m && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), u[0] !== "/" && (u = "/" + u));
  }
  if (!B5[d])
    for (var v = 0, $ = _y.length; v < $; v++) {
      var je = _y[v];
      if (u.indexOf(je) !== -1) {
        var re = encodeURIComponent(je);
        re === je && (re = escape(je)), u = u.split(je).join(re);
      }
    }
  var fe = u.indexOf("#");
  fe !== -1 && (this.hash = u.substr(fe), u = u.slice(0, fe));
  var le = u.indexOf("?");
  if (le !== -1 ? (this.search = u.substr(le), this.query = u.substr(le + 1), t && (this.query = $y.parse(this.query)), u = u.slice(0, le)) : t && (this.search = "", this.query = {}), u && (this.pathname = u), Ja[d] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
    var ye = this.pathname || "", $e = this.search || "";
    this.path = ye + $e;
  }
  return this.href = this.format(), this;
};
function V5(e) {
  return Gn.isString(e) && (e = Qu(e)), e instanceof mn ? e.format() : mn.prototype.format.call(e);
}
mn.prototype.format = function() {
  var e = this.auth || "";
  e && (e = encodeURIComponent(e), e = e.replace(/%3A/i, ":"), e += "@");
  var t = this.protocol || "", r = this.pathname || "", i = this.hash || "", n = !1, s = "";
  this.host ? n = e + this.host : this.hostname && (n = e + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"), this.port && (n += ":" + this.port)), this.query && Gn.isObject(this.query) && Object.keys(this.query).length && (s = $y.stringify(this.query));
  var a = this.search || s && "?" + s || "";
  return t && t.substr(-1) !== ":" && (t += ":"), this.slashes || (!t || Ja[t]) && n !== !1 ? (n = "//" + (n || ""), r && r.charAt(0) !== "/" && (r = "/" + r)) : n || (n = ""), i && i.charAt(0) !== "#" && (i = "#" + i), a && a.charAt(0) !== "?" && (a = "?" + a), r = r.replace(/[?#]/g, function(u) {
    return encodeURIComponent(u);
  }), a = a.replace("#", "%23"), t + n + r + a + i;
};
function Z5(e, t) {
  return Qu(e, !1, !0).resolve(t);
}
mn.prototype.resolve = function(e) {
  return this.resolveObject(Qu(e, !1, !0)).format();
};
function z5(e, t) {
  return e ? Qu(e, !1, !0).resolveObject(t) : t;
}
mn.prototype.resolveObject = function(e) {
  if (Gn.isString(e)) {
    var t = new mn();
    t.parse(e, !1, !0), e = t;
  }
  for (var r = new mn(), i = Object.keys(this), n = 0; n < i.length; n++) {
    var s = i[n];
    r[s] = this[s];
  }
  if (r.hash = e.hash, e.href === "")
    return r.href = r.format(), r;
  if (e.slashes && !e.protocol) {
    for (var a = Object.keys(e), u = 0; u < a.length; u++) {
      var c = a[u];
      c !== "protocol" && (r[c] = e[c]);
    }
    return Ja[r.protocol] && r.hostname && !r.pathname && (r.path = r.pathname = "/"), r.href = r.format(), r;
  }
  if (e.protocol && e.protocol !== r.protocol) {
    if (!Ja[e.protocol]) {
      for (var l = Object.keys(e), d = 0; d < l.length; d++) {
        var p = l[d];
        r[p] = e[p];
      }
      return r.href = r.format(), r;
    }
    if (r.protocol = e.protocol, !e.host && !wy[e.protocol]) {
      for (var $ = (e.pathname || "").split("/"); $.length && !(e.host = $.shift()); )
        ;
      e.host || (e.host = ""), e.hostname || (e.hostname = ""), $[0] !== "" && $.unshift(""), $.length < 2 && $.unshift(""), r.pathname = $.join("/");
    } else
      r.pathname = e.pathname;
    if (r.search = e.search, r.query = e.query, r.host = e.host || "", r.auth = e.auth, r.hostname = e.hostname || e.host, r.port = e.port, r.pathname || r.search) {
      var h = r.pathname || "", v = r.search || "";
      r.path = h + v;
    }
    return r.slashes = r.slashes || e.slashes, r.href = r.format(), r;
  }
  var y = r.pathname && r.pathname.charAt(0) === "/", g = e.host || e.pathname && e.pathname.charAt(0) === "/", _ = g || y || r.host && e.pathname, m = _, w = r.pathname && r.pathname.split("/") || [], $ = e.pathname && e.pathname.split("/") || [], E = r.protocol && !Ja[r.protocol];
  if (E && (r.hostname = "", r.port = null, r.host && (w[0] === "" ? w[0] = r.host : w.unshift(r.host)), r.host = "", e.protocol && (e.hostname = null, e.port = null, e.host && ($[0] === "" ? $[0] = e.host : $.unshift(e.host)), e.host = null), _ = _ && ($[0] === "" || w[0] === "")), g)
    r.host = e.host || e.host === "" ? e.host : r.host, r.hostname = e.hostname || e.hostname === "" ? e.hostname : r.hostname, r.search = e.search, r.query = e.query, w = $;
  else if ($.length)
    w || (w = []), w.pop(), w = w.concat($), r.search = e.search, r.query = e.query;
  else if (!Gn.isNullOrUndefined(e.search)) {
    if (E) {
      r.hostname = r.host = w.shift();
      var A = r.host && r.host.indexOf("@") > 0 ? r.host.split("@") : !1;
      A && (r.auth = A.shift(), r.host = r.hostname = A.shift());
    }
    return r.search = e.search, r.query = e.query, (!Gn.isNull(r.pathname) || !Gn.isNull(r.search)) && (r.path = (r.pathname ? r.pathname : "") + (r.search ? r.search : "")), r.href = r.format(), r;
  }
  if (!w.length)
    return r.pathname = null, r.search ? r.path = "/" + r.search : r.path = null, r.href = r.format(), r;
  for (var R = w.slice(-1)[0], I = (r.host || e.host || w.length > 1) && (R === "." || R === "..") || R === "", D = 0, J = w.length; J >= 0; J--)
    R = w[J], R === "." ? w.splice(J, 1) : R === ".." ? (w.splice(J, 1), D++) : D && (w.splice(J, 1), D--);
  if (!_ && !m)
    for (; D--; D)
      w.unshift("..");
  _ && w[0] !== "" && (!w[0] || w[0].charAt(0) !== "/") && w.unshift(""), I && w.join("/").substr(-1) !== "/" && w.push("");
  var ae = w[0] === "" || w[0] && w[0].charAt(0) === "/";
  if (E) {
    r.hostname = r.host = ae ? "" : w.length ? w.shift() : "";
    var A = r.host && r.host.indexOf("@") > 0 ? r.host.split("@") : !1;
    A && (r.auth = A.shift(), r.host = r.hostname = A.shift());
  }
  return _ = _ || r.host && w.length, _ && !ae && w.unshift(""), w.length ? r.pathname = w.join("/") : (r.pathname = null, r.path = null), (!Gn.isNull(r.pathname) || !Gn.isNull(r.search)) && (r.path = (r.pathname ? r.pathname : "") + (r.search ? r.search : "")), r.auth = e.auth || r.auth, r.slashes = r.slashes || e.slashes, r.href = r.format(), r;
};
mn.prototype.parseHost = function() {
  var e = this.host, t = N5.exec(e);
  t && (t = t[0], t !== ":" && (this.port = t.substr(1)), e = e.substr(0, e.length - t.length)), e && (this.hostname = e);
};
function W5(e, t) {
  for (var r = 0, i = e.length - 1; i >= 0; i--) {
    var n = e[i];
    n === "." ? e.splice(i, 1) : n === ".." ? (e.splice(i, 1), r++) : r && (e.splice(i, 1), r--);
  }
  if (t)
    for (; r--; r)
      e.unshift("..");
  return e;
}
function H5() {
  for (var e = "", t = !1, r = arguments.length - 1; r >= -1 && !t; r--) {
    var i = r >= 0 ? arguments[r] : "/";
    if (typeof i != "string")
      throw new TypeError("Arguments to path.resolve must be strings");
    if (!i)
      continue;
    e = i + "/" + e, t = i.charAt(0) === "/";
  }
  return e = W5(G5(e.split("/"), function(n) {
    return !!n;
  }), !t).join("/"), (t ? "/" : "") + e || ".";
}
function G5(e, t) {
  if (e.filter)
    return e.filter(t);
  for (var r = [], i = 0; i < e.length; i++)
    t(e[i], i, e) && r.push(e[i]);
  return r;
}
var ax = function(e) {
  function t() {
    var i = this || self;
    return delete e.prototype.__magic__, i;
  }
  if (typeof globalThis == "object")
    return globalThis;
  if (this)
    return t();
  e.defineProperty(e.prototype, "__magic__", {
    configurable: !0,
    get: t
  });
  var r = __magic__;
  return r;
}(Object), K5 = (
  /** @type {formatImport}*/
  j5
), ox = (
  /** @type {parseImport}*/
  T5
), ux = (
  /** @type {resolveImport}*/
  I5
), cx = (
  /** @type {UrlImport}*/
  k5
), ps = ax.URL, lx = ax.URLSearchParams, Y5 = /%/g, J5 = /\\/g, X5 = /\n/g, Q5 = /\r/g, eD = /\t/g, tD = 47;
function rD(e) {
  var t = (
    /** @type {URL|null} */
    e ?? null
  );
  return !!(t !== null && (t != null && t.href) && (t != null && t.origin));
}
function nD(e) {
  if (e.hostname !== "")
    throw new TypeError('File URL host must be "localhost" or empty on browser');
  for (var t = e.pathname, r = 0; r < t.length; r++)
    if (t[r] === "%") {
      var i = t.codePointAt(r + 2) | 32;
      if (t[r + 1] === "2" && i === 102)
        throw new TypeError("File URL path must not include encoded / characters");
    }
  return decodeURIComponent(t);
}
function iD(e) {
  return e.includes("%") && (e = e.replace(Y5, "%25")), e.includes("\\") && (e = e.replace(J5, "%5C")), e.includes(`
`) && (e = e.replace(X5, "%0A")), e.includes("\r") && (e = e.replace(Q5, "%0D")), e.includes("	") && (e = e.replace(eD, "%09")), e;
}
var fx = (
  /**
   * @type {domainToASCII}
   */
  function(t) {
    if (typeof t > "u")
      throw new TypeError('The "domain" argument must be specified');
    return new ps("http://" + t).hostname;
  }
), dx = (
  /**
   * @type {domainToUnicode}
   */
  function(t) {
    if (typeof t > "u")
      throw new TypeError('The "domain" argument must be specified');
    return new ps("http://" + t).hostname;
  }
), px = (
  /**
   * @type {(url: string) => URL}
   */
  function(t) {
    var r = new ps("file://"), i = H5(t), n = t.charCodeAt(t.length - 1);
    return n === tD && i[i.length - 1] !== "/" && (i += "/"), r.pathname = iD(i), r;
  }
), hx = (
  /**
   * @type {fileURLToPath & ((path: string | URL) => string)}
   */
  function(t) {
    if (!rD(t) && typeof t != "string")
      throw new TypeError('The "path" argument must be of type string or an instance of URL. Received type ' + typeof t + " (" + t + ")");
    var r = new ps(t);
    if (r.protocol !== "file:")
      throw new TypeError("The URL must be of scheme file");
    return nD(r);
  }
), mx = (
  /**
   * @type {(
   *   ((urlObject: URL, options?: URLFormatOptions) => string) &
   *   ((urlObject: UrlObject | string, options?: never) => string)
   * )}
   */
  function(t, r) {
    var i, n, s;
    if (r === void 0 && (r = {}), !(t instanceof ps))
      return K5(t);
    if (typeof r != "object" || r === null)
      throw new TypeError('The "options" argument must be of type object.');
    var a = (i = r.auth) != null ? i : !0, u = (n = r.fragment) != null ? n : !0, c = (s = r.search) != null ? s : !0, l = new ps(t.toString());
    return a || (l.username = "", l.password = ""), u || (l.hash = ""), c || (l.search = ""), l.toString();
  }
), sD = {
  format: mx,
  parse: ox,
  resolve: ux,
  resolveObject: sx,
  Url: cx,
  URL: ps,
  URLSearchParams: lx,
  domainToASCII: fx,
  domainToUnicode: dx,
  pathToFileURL: px,
  fileURLToPath: hx
};
const aD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  URL: ps,
  URLSearchParams: lx,
  Url: cx,
  default: sD,
  domainToASCII: fx,
  domainToUnicode: dx,
  fileURLToPath: hx,
  format: mx,
  parse: ox,
  pathToFileURL: px,
  resolve: ux,
  resolveObject: sx
}, Symbol.toStringTag, { value: "Module" })), ku = /* @__PURE__ */ kf(aD);
(function(e, t) {
  const r = /^win/.test(Me.process.platform), i = /\//g, n = /^(\w{2,}):\/\//i, s = e.exports, a = /~1/g, u = /~0/g, c = [
    /\?/g,
    "%3F",
    /#/g,
    "%23"
  ], l = [
    /%23/g,
    "#",
    /%24/g,
    "$",
    /%26/g,
    "&",
    /%2C/g,
    ",",
    /%40/g,
    "@"
  ];
  t.parse = ku.parse, t.resolve = ku.resolve, t.cwd = function() {
    if (Me.process.browser)
      return location.href;
    const p = Me.process.cwd(), h = p.slice(-1);
    return h === "/" || h === "\\" ? p : `${p}/`;
  }, t.getProtocol = function(p) {
    const h = n.exec(p);
    if (h)
      return h[1].toLowerCase();
  }, t.getExtension = function(p) {
    const h = p.lastIndexOf(".");
    return h >= 0 ? s.stripQuery(p.substr(h).toLowerCase()) : "";
  }, t.stripQuery = function(p) {
    const h = p.indexOf("?");
    return h >= 0 && (p = p.substr(0, h)), p;
  }, t.getHash = function(p) {
    const h = p.indexOf("#");
    return h >= 0 ? p.substr(h) : "#";
  }, t.stripHash = function(p) {
    const h = p.indexOf("#");
    return h >= 0 ? p.substr(0, h) : p;
  }, t.isHttp = function(p) {
    const h = s.getProtocol(p);
    return h === "http" || h === "https" ? !0 : h === void 0 ? Me.process.browser : !1;
  }, t.isFileSystemPath = function(p) {
    if (Me.process.browser)
      return !1;
    const h = s.getProtocol(p);
    return h === void 0 || h === "file";
  }, t.fromFileSystemPath = function(p) {
    r && (p = p.replace(/\\/g, "/")), p = encodeURI(p);
    for (let h = 0; h < c.length; h += 2)
      p = p.replace(c[h], c[h + 1]);
    return p;
  }, t.toFileSystemPath = function(p, h) {
    p = decodeURI(p);
    for (let y = 0; y < l.length; y += 2)
      p = p.replace(l[y], l[y + 1]);
    let v = p.substr(0, 7).toLowerCase() === "file://";
    return v && (p = p[7] === "/" ? p.substr(8) : p.substr(7), r && p[1] === "/" && (p = `${p[0]}:${p.substr(1)}`), h ? p = `file:///${p}` : (v = !1, p = r ? p : `/${p}`)), r && !v && (p = p.replace(i, "\\"), p.substr(1, 2) === ":\\" && (p = p[0].toUpperCase() + p.substr(1))), p;
  }, t.safePointerToPath = function(p) {
    return p.length <= 1 || p[0] !== "#" || p[1] !== "/" ? [] : p.slice(2).split("/").map((h) => decodeURIComponent(h).replace(a, "/").replace(u, "~"));
  };
})(by, by.exports);
var gn = by.exports;
const { Ono: yx } = Nn, { stripHash: gx, toFileSystemPath: oD } = gn;
function bs(e) {
  Object.defineProperty(e.prototype, "name", {
    value: e.name,
    enumerable: !0
  });
}
const ji = class extends Error {
  constructor(t, r) {
    super(), this.code = "EUNKNOWN", this.message = t, this.source = r, this.path = null, yx.extend(this);
  }
  get footprint() {
    return `${this.path}+${this.source}+${this.code}+${this.message}`;
  }
};
or.JSONParserError = ji;
bs(ji);
const Sg = class vx extends Error {
  constructor(t) {
    super(), this.files = t, this.message = `${this.errors.length} error${this.errors.length > 1 ? "s" : ""} occurred while reading '${oD(t.$refs._root$Ref.path)}'`, yx.extend(this);
  }
  static getParserErrors(t) {
    const r = [];
    for (const i of Object.values(t.$refs._$refs))
      i.errors && r.push(...i.errors);
    return r;
  }
  get errors() {
    return vx.getParserErrors(this.files);
  }
};
or.JSONParserErrorGroup = Sg;
bs(Sg);
const bx = class extends ji {
  constructor(t, r) {
    super(`Error parsing ${r}: ${t}`, r), this.code = "EPARSER";
  }
};
or.ParserError = bx;
bs(bx);
const _x = class extends ji {
  constructor(t) {
    super(`Could not find parser for "${t}"`, t), this.code = "EUNMATCHEDPARSER";
  }
};
or.UnmatchedParserError = _x;
bs(_x);
const wx = class extends ji {
  constructor(t, r) {
    super(t.message || `Error reading file "${r}"`, r), this.code = "ERESOLVER", "code" in t && (this.ioErrorCode = String(t.code));
  }
};
or.ResolverError = wx;
bs(wx);
const $x = class extends ji {
  constructor(t) {
    super(`Could not find resolver for "${t}"`, t), this.code = "EUNMATCHEDRESOLVER";
  }
};
or.UnmatchedResolverError = $x;
bs($x);
const Ex = class extends ji {
  constructor(t, r) {
    super(`Token "${t}" does not exist.`, gx(r)), this.code = "EMISSINGPOINTER";
  }
};
or.MissingPointerError = Ex;
bs(Ex);
const xx = class extends ji {
  constructor(t, r) {
    super(`Invalid $ref pointer "${t}". Pointers must begin with "#/"`, gx(r)), this.code = "EINVALIDPOINTER";
  }
};
or.InvalidPointerError = xx;
bs(xx);
or.isHandledError = function(e) {
  return e instanceof ji || e instanceof Sg;
};
or.normalizeError = function(e) {
  return e.path === null && (e.path = []), e;
};
var Lp, j1;
function Zf() {
  if (j1)
    return Lp;
  j1 = 1;
  const e = ec(), { JSONParserError: t, InvalidPointerError: r, MissingPointerError: i, isHandledError: n } = or, s = gn, a = /\//g, u = /~/g, c = /~1/g, l = /~0/g;
  Lp = d;
  function d(y, g, _) {
    this.$ref = y, this.path = g, this.originalPath = _ || g, this.value = void 0, this.circular = !1, this.indirections = 0;
  }
  d.prototype.resolve = function(y, g, _) {
    const m = d.parse(this.path, this.originalPath);
    this.value = v(y);
    for (let w = 0; w < m.length; w++) {
      if (p(this, g) && (this.path = d.join(this.path, m.slice(w))), typeof this.value == "object" && this.value !== null && "$ref" in this.value)
        return this;
      const $ = m[w];
      if (this.value[$] === void 0 || this.value[$] === null)
        throw this.value = null, new i($, this.originalPath);
      this.value = this.value[$];
    }
    return (!this.value || this.value.$ref && s.resolve(this.path, this.value.$ref) !== _) && p(this, g), this;
  }, d.prototype.set = function(y, g, _) {
    const m = d.parse(this.path);
    let w;
    if (m.length === 0)
      return this.value = g, g;
    this.value = v(y);
    for (let $ = 0; $ < m.length - 1; $++)
      p(this, _), w = m[$], this.value && this.value[w] !== void 0 ? this.value = this.value[w] : this.value = h(this, w, {});
    return p(this, _), w = m[m.length - 1], h(this, w, g), y;
  }, d.parse = function(y, g) {
    let _ = s.getHash(y).substr(1);
    if (!_)
      return [];
    _ = _.split("/");
    for (let m = 0; m < _.length; m++)
      _[m] = decodeURIComponent(_[m].replace(c, "/").replace(l, "~"));
    if (_[0] !== "")
      throw new r(_, g === void 0 ? y : g);
    return _.slice(1);
  }, d.join = function(y, g) {
    y.indexOf("#") === -1 && (y += "#"), g = Array.isArray(g) ? g : [g];
    for (let _ = 0; _ < g.length; _++) {
      const m = g[_];
      y += `/${encodeURIComponent(m.replace(u, "~0").replace(a, "~1"))}`;
    }
    return y;
  };
  function p(y, g) {
    if (e.isAllowed$Ref(y.value, g)) {
      const _ = s.resolve(y.path, y.value.$ref);
      if (_ === y.path)
        y.circular = !0;
      else {
        const m = y.$ref.$refs._resolve(_, y.path, g);
        return m === null ? !1 : (y.indirections += m.indirections + 1, e.isExtended$Ref(y.value) ? (y.value = e.dereference(y.value, m.value), !1) : (y.$ref = m.$ref, y.path = m.path, y.value = m.value, !0));
      }
    }
  }
  function h(y, g, _) {
    if (y.value && typeof y.value == "object")
      g === "-" && Array.isArray(y.value) ? y.value.push(_) : y.value[g] = _;
    else
      throw new t(
        `Error assigning $ref pointer "${y.path}". 
Cannot set "${g}" of a non-object.`
      );
    return _;
  }
  function v(y) {
    if (n(y))
      throw y;
    return y;
  }
  return Lp;
}
var qp, k1;
function ec() {
  if (k1)
    return qp;
  k1 = 1, qp = u;
  const e = Zf(), { InvalidPointerError: t, isHandledError: r, normalizeError: i } = or, { safePointerToPath: n, stripHash: s, getHash: a } = gn;
  function u() {
    this.path = void 0, this.value = void 0, this.$refs = void 0, this.pathType = void 0, this.errors = void 0;
  }
  return u.prototype.addError = function(c) {
    this.errors === void 0 && (this.errors = []);
    const l = this.errors.map(({ footprint: d }) => d);
    Array.isArray(c.errors) ? this.errors.push(...c.errors.map(i).filter(({ footprint: d }) => !l.includes(d))) : l.includes(c.footprint) || this.errors.push(i(c));
  }, u.prototype.exists = function(c, l) {
    try {
      return this.resolve(c, l), !0;
    } catch {
      return !1;
    }
  }, u.prototype.get = function(c, l) {
    return this.resolve(c, l).value;
  }, u.prototype.resolve = function(c, l, d, p) {
    const h = new e(this, c, d);
    try {
      return h.resolve(this.value, l, p);
    } catch (v) {
      if (!l || !l.continueOnError || !r(v))
        throw v;
      return v.path === null && (v.path = n(a(p))), v instanceof t && (v.source = s(p)), this.addError(v), null;
    }
  }, u.prototype.set = function(c, l) {
    const d = new e(this, c);
    this.value = d.set(this.value, l);
  }, u.is$Ref = function(c) {
    return c && typeof c == "object" && typeof c.$ref == "string" && c.$ref.length > 0;
  }, u.isExternal$Ref = function(c) {
    return u.is$Ref(c) && c.$ref[0] !== "#";
  }, u.isAllowed$Ref = function(c, l) {
    if (u.is$Ref(c)) {
      if (c.$ref.substr(0, 2) === "#/" || c.$ref === "#")
        return !0;
      if (c.$ref[0] !== "#" && (!l || l.resolve.external))
        return !0;
    }
  }, u.isExtended$Ref = function(c) {
    return u.is$Ref(c) && Object.keys(c).length > 1;
  }, u.dereference = function(c, l) {
    if (l && typeof l == "object" && u.isExtended$Ref(c)) {
      const d = {};
      for (const p of Object.keys(c))
        p !== "$ref" && (d[p] = c[p]);
      for (const p of Object.keys(l))
        p in d || (d[p] = l[p]);
      return d;
    }
    return l;
  }, qp;
}
const ff = ec(), Mu = Zf(), Fp = gn;
var uD = function(t, r) {
  const i = [];
  Ag(t, "schema", `${t.$refs._root$Ref.path}#`, "#", 0, i, t.$refs, r), cD(i);
};
function Ag(e, t, r, i, n, s, a, u) {
  const c = t === null ? e : e[t];
  if (c && typeof c == "object" && !ArrayBuffer.isView(c))
    if (ff.isAllowed$Ref(c))
      M1(e, t, r, i, n, s, a, u);
    else {
      const l = Object.keys(c).sort((d, p) => d === "definitions" ? -1 : p === "definitions" ? 1 : d.length - p.length);
      for (const d of l) {
        const p = Mu.join(r, d), h = Mu.join(i, d), v = c[d];
        ff.isAllowed$Ref(v) ? M1(c, d, r, h, n, s, a, u) : Ag(c, d, p, h, n, s, a, u);
      }
    }
}
function M1(e, t, r, i, n, s, a, u) {
  const c = t === null ? e : e[t], l = Fp.resolve(r, c.$ref), d = a._resolve(l, i, u);
  if (d === null)
    return;
  const p = Mu.parse(i).length, h = Fp.stripHash(d.path), v = Fp.getHash(d.path), y = h !== a._root$Ref.path, g = ff.isExtended$Ref(c);
  n += d.indirections;
  const _ = lD(s, e, t);
  if (_)
    if (p < _.depth || n < _.indirections)
      fD(s, _);
    else
      return;
  s.push({
    $ref: c,
    // The JSON Reference (e.g. {$ref: string})
    parent: e,
    // The object that contains this $ref pointer
    key: t,
    // The key in `parent` that is the $ref pointer
    pathFromRoot: i,
    // The path to the $ref pointer, from the JSON Schema root
    depth: p,
    // How far from the JSON Schema root is this $ref pointer?
    file: h,
    // The file that the $ref pointer resolves to
    hash: v,
    // The hash within `file` that the $ref pointer resolves to
    value: d.value,
    // The resolved value of the $ref pointer
    circular: d.circular,
    // Is this $ref pointer DIRECTLY circular? (i.e. it references itself)
    extended: g,
    // Does this $ref extend its resolved value? (i.e. it has extra properties, in addition to "$ref")
    external: y,
    // Does this $ref pointer point to a file other than the main JSON Schema file?
    indirections: n
    // The number of indirect references that were traversed to resolve the value
  }), _ || Ag(d.value, null, d.path, i, n + 1, s, a, u);
}
function cD(e) {
  e.sort((n, s) => {
    if (n.file !== s.file)
      return n.file < s.file ? -1 : 1;
    if (n.hash !== s.hash)
      return n.hash < s.hash ? -1 : 1;
    if (n.circular !== s.circular)
      return n.circular ? -1 : 1;
    if (n.extended !== s.extended)
      return n.extended ? 1 : -1;
    if (n.indirections !== s.indirections)
      return n.indirections - s.indirections;
    if (n.depth !== s.depth)
      return n.depth - s.depth;
    const a = n.pathFromRoot.lastIndexOf("/definitions"), u = s.pathFromRoot.lastIndexOf("/definitions");
    return a !== u ? u - a : n.pathFromRoot.length - s.pathFromRoot.length;
  });
  let t, r, i;
  for (const n of e)
    n.external ? n.file === t && n.hash === r ? n.$ref.$ref = i : n.file === t && n.hash.indexOf(`${r}/`) === 0 ? n.$ref.$ref = Mu.join(i, Mu.parse(n.hash.replace(r, "#"))) : (t = n.file, r = n.hash, i = n.pathFromRoot, n.parent[n.key] = ff.dereference(n.$ref, n.value), n.$ref = n.parent[n.key], n.circular && (n.$ref.$ref = n.pathFromRoot)) : n.$ref.$ref = n.hash;
}
function lD(e, t, r) {
  for (let i = 0; i < e.length; i++) {
    const n = e[i];
    if (n.parent === t && n.key === r)
      return n;
  }
}
function fD(e, t) {
  const r = e.indexOf(t);
  e.splice(r, 1);
}
const { ono: dD } = Nn, N1 = Zf(), Ey = ec(), pD = gn;
var Ox = function(t, r) {
  const i = Cg(
    t.schema,
    t.$refs._root$Ref.path,
    "#",
    /* @__PURE__ */ new Set(),
    /* @__PURE__ */ new Set(),
    /* @__PURE__ */ new Map(),
    t.$refs,
    r
  );
  t.$refs.circular = i.circular, t.schema = i.value;
};
function Cg(e, t, r, i, n, s, a, u) {
  let c;
  const l = {
    value: e,
    circular: !1
  };
  if ((u.dereference.circular === "ignore" || !n.has(e)) && e && typeof e == "object" && !ArrayBuffer.isView(e)) {
    if (i.add(e), n.add(e), Ey.isAllowed$Ref(e, u))
      c = D1(
        e,
        t,
        r,
        i,
        n,
        s,
        a,
        u
      ), l.circular = c.circular, l.value = c.value, e.description && (l.value.description = e.description), e.summary && (l.value.summary = e.summary);
    else
      for (const d of Object.keys(e)) {
        const p = N1.join(t, d), h = N1.join(r, d), v = e[d];
        let y = !1;
        Ey.isAllowed$Ref(v, u) ? (c = D1(
          v,
          p,
          h,
          i,
          n,
          s,
          a,
          u
        ), y = c.circular, e[d] !== c.value && (e[d] = c.value, v.description && (e[d].description = v.description), v.summary && (e[d].summary = v.summary))) : i.has(v) ? y = Px(p, a, u) : (c = Cg(
          v,
          p,
          h,
          i,
          n,
          s,
          a,
          u
        ), y = c.circular, e[d] !== c.value && (e[d] = c.value)), l.circular = l.circular || y;
      }
    i.delete(e);
  }
  return l;
}
function D1(e, t, r, i, n, s, a, u) {
  const c = pD.resolve(t, e.$ref), l = s.get(c);
  if (l) {
    const g = Object.keys(e);
    if (g.length > 1) {
      const _ = {};
      for (const m of g)
        m !== "$ref" && !(m in l.value) && (_[m] = e[m]);
      return {
        circular: l.circular,
        value: { ...l.value, ..._ }
      };
    }
    return l;
  }
  const d = a._resolve(c, t, u);
  if (d === null)
    return {
      circular: !1,
      value: null
    };
  const p = d.circular;
  let h = p || i.has(d.value);
  h && Px(t, a, u);
  let v = Ey.dereference(e, d.value);
  if (!h) {
    const g = Cg(
      v,
      d.path,
      r,
      i,
      n,
      s,
      a,
      u
    );
    h = g.circular, v = g.value;
  }
  h && !p && u.dereference.circular === "ignore" && (v = e), p && (v.$ref = r);
  const y = {
    circular: h,
    value: v
  };
  return Object.keys(e).length === 1 && s.set(c, y), y;
}
function Px(e, t, r) {
  if (t.circular = !0, t.circularRefs.push(e), !r.dereference.circular)
    throw dD.reference(`Circular $ref pointer found at ${e}`);
  return !0;
}
const hD = /\.(jpeg|jpg|gif|png|bmp|ico)$/i;
var mD = {
  /**
   * The order that this parser will run, in relation to other parsers.
   *
   * @type {number}
   */
  order: 400,
  /**
   * Whether to allow "empty" files (zero bytes).
   *
   * @type {boolean}
   */
  allowEmpty: !0,
  /**
   * Determines whether this parser can parse a given file reference.
   * Parsers that return true will be tried, in order, until one successfully parses the file.
   * Parsers that return false will be skipped, UNLESS all parsers returned false, in which case
   * every parser will be tried.
   *
   * @param {object} file           - An object containing information about the referenced file
   * @param {string} file.url       - The full URL of the referenced file
   * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
   * @returns {boolean}
   */
  canParse(e) {
    return Me.Buffer.isBuffer(e.data) && hD.test(e.url);
  },
  /**
   * Parses the given data as a Buffer (byte array).
   *
   * @param {object} file           - An object containing information about the referenced file
   * @param {string} file.url       - The full URL of the referenced file
   * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
   * @returns {Buffer}
   */
  parse(e) {
    return Me.Buffer.isBuffer(e.data) ? e.data : Me.Buffer.from(e.data);
  }
};
const { ParserError: yD } = or;
var gD = {
  /**
   * The order that this parser will run, in relation to other parsers.
   *
   * @type {number}
   */
  order: 100,
  /**
   * Whether to allow "empty" files. This includes zero-byte files, as well as empty JSON objects.
   *
   * @type {boolean}
   */
  allowEmpty: !0,
  /**
   * Determines whether this parser can parse a given file reference.
   * Parsers that match will be tried, in order, until one successfully parses the file.
   * Parsers that don't match will be skipped, UNLESS none of the parsers match, in which case
   * every parser will be tried.
   *
   * @type {RegExp|string|string[]|function}
   */
  canParse: ".json",
  /**
   * Parses the given file as JSON
   *
   * @param {object} file           - An object containing information about the referenced file
   * @param {string} file.url       - The full URL of the referenced file
   * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
   * @returns {Promise}
   */
  // eslint-disable-next-line require-await
  async parse(e) {
    let t = e.data;
    if (Me.Buffer.isBuffer(t) && (t = t.toString()), typeof t == "string") {
      if (t.trim().length === 0)
        return;
      try {
        return JSON.parse(t);
      } catch (r) {
        throw new yD(r.message, e.url);
      }
    }
    return t;
  }
};
const { ParserError: vD } = or, bD = /\.(txt|htm|html|md|xml|js|min|map|css|scss|less|svg)$/i;
var _D = {
  /**
   * The order that this parser will run, in relation to other parsers.
   *
   * @type {number}
   */
  order: 300,
  /**
   * Whether to allow "empty" files (zero bytes).
   *
   * @type {boolean}
   */
  allowEmpty: !0,
  /**
   * The encoding that the text is expected to be in.
   *
   * @type {string}
   */
  encoding: "utf8",
  /**
   * Determines whether this parser can parse a given file reference.
   * Parsers that return true will be tried, in order, until one successfully parses the file.
   * Parsers that return false will be skipped, UNLESS all parsers returned false, in which case
   * every parser will be tried.
   *
   * @param {object} file           - An object containing information about the referenced file
   * @param {string} file.url       - The full URL of the referenced file
   * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
   * @returns {boolean}
   */
  canParse(e) {
    return (typeof e.data == "string" || Me.Buffer.isBuffer(e.data)) && bD.test(e.url);
  },
  /**
   * Parses the given file as text
   *
   * @param {object} file           - An object containing information about the referenced file
   * @param {string} file.url       - The full URL of the referenced file
   * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
   * @returns {string}
   */
  parse(e) {
    if (typeof e.data == "string")
      return e.data;
    if (Me.Buffer.isBuffer(e.data))
      return e.data.toString(this.encoding);
    throw new vD("data is not text", e.url);
  }
}, _r = {}, Rg = {}, Dn = {};
function Sx(e) {
  return typeof e > "u" || e === null;
}
function wD(e) {
  return typeof e == "object" && e !== null;
}
function $D(e) {
  return Array.isArray(e) ? e : Sx(e) ? [] : [e];
}
function ED(e, t) {
  var r, i, n, s;
  if (t)
    for (s = Object.keys(t), r = 0, i = s.length; r < i; r += 1)
      n = s[r], e[n] = t[n];
  return e;
}
function xD(e, t) {
  var r = "", i;
  for (i = 0; i < t; i += 1)
    r += e;
  return r;
}
function OD(e) {
  return e === 0 && Number.NEGATIVE_INFINITY === 1 / e;
}
Dn.isNothing = Sx;
Dn.isObject = wD;
Dn.toArray = $D;
Dn.repeat = xD;
Dn.isNegativeZero = OD;
Dn.extend = ED;
function Ax(e, t) {
  var r = "", i = e.reason || "(unknown reason)";
  return e.mark ? (e.mark.name && (r += 'in "' + e.mark.name + '" '), r += "(" + (e.mark.line + 1) + ":" + (e.mark.column + 1) + ")", !t && e.mark.snippet && (r += `

` + e.mark.snippet), i + " " + r) : i;
}
function Nu(e, t) {
  Error.call(this), this.name = "YAMLException", this.reason = e, this.mark = t, this.message = Ax(this, !1), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack || "";
}
Nu.prototype = Object.create(Error.prototype);
Nu.prototype.constructor = Nu;
Nu.prototype.toString = function(t) {
  return this.name + ": " + Ax(this, t);
};
var tc = Nu, iu = Dn;
function Up(e, t, r, i, n) {
  var s = "", a = "", u = Math.floor(n / 2) - 1;
  return i - t > u && (s = " ... ", t = i - u + s.length), r - i > u && (a = " ...", r = i + u - a.length), {
    str: s + e.slice(t, r).replace(/\t/g, "→") + a,
    pos: i - t + s.length
    // relative position
  };
}
function Bp(e, t) {
  return iu.repeat(" ", t - e.length) + e;
}
function PD(e, t) {
  if (t = Object.create(t || null), !e.buffer)
    return null;
  t.maxLength || (t.maxLength = 79), typeof t.indent != "number" && (t.indent = 1), typeof t.linesBefore != "number" && (t.linesBefore = 3), typeof t.linesAfter != "number" && (t.linesAfter = 2);
  for (var r = /\r?\n|\r|\0/g, i = [0], n = [], s, a = -1; s = r.exec(e.buffer); )
    n.push(s.index), i.push(s.index + s[0].length), e.position <= s.index && a < 0 && (a = i.length - 2);
  a < 0 && (a = i.length - 1);
  var u = "", c, l, d = Math.min(e.line + t.linesAfter, n.length).toString().length, p = t.maxLength - (t.indent + d + 3);
  for (c = 1; c <= t.linesBefore && !(a - c < 0); c++)
    l = Up(
      e.buffer,
      i[a - c],
      n[a - c],
      e.position - (i[a] - i[a - c]),
      p
    ), u = iu.repeat(" ", t.indent) + Bp((e.line - c + 1).toString(), d) + " | " + l.str + `
` + u;
  for (l = Up(e.buffer, i[a], n[a], e.position, p), u += iu.repeat(" ", t.indent) + Bp((e.line + 1).toString(), d) + " | " + l.str + `
`, u += iu.repeat("-", t.indent + d + 3 + l.pos) + `^
`, c = 1; c <= t.linesAfter && !(a + c >= n.length); c++)
    l = Up(
      e.buffer,
      i[a + c],
      n[a + c],
      e.position - (i[a] - i[a + c]),
      p
    ), u += iu.repeat(" ", t.indent) + Bp((e.line + c + 1).toString(), d) + " | " + l.str + `
`;
  return u.replace(/\n$/, "");
}
var SD = PD, L1 = tc, AD = [
  "kind",
  "multi",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "representName",
  "defaultStyle",
  "styleAliases"
], CD = [
  "scalar",
  "sequence",
  "mapping"
];
function RD(e) {
  var t = {};
  return e !== null && Object.keys(e).forEach(function(r) {
    e[r].forEach(function(i) {
      t[String(i)] = r;
    });
  }), t;
}
function TD(e, t) {
  if (t = t || {}, Object.keys(t).forEach(function(r) {
    if (AD.indexOf(r) === -1)
      throw new L1('Unknown option "' + r + '" is met in definition of "' + e + '" YAML type.');
  }), this.options = t, this.tag = e, this.kind = t.kind || null, this.resolve = t.resolve || function() {
    return !0;
  }, this.construct = t.construct || function(r) {
    return r;
  }, this.instanceOf = t.instanceOf || null, this.predicate = t.predicate || null, this.represent = t.represent || null, this.representName = t.representName || null, this.defaultStyle = t.defaultStyle || null, this.multi = t.multi || !1, this.styleAliases = RD(t.styleAliases || null), CD.indexOf(this.kind) === -1)
    throw new L1('Unknown kind "' + this.kind + '" is specified for "' + e + '" YAML type.');
}
var Fr = TD, Wo = tc, Vp = Fr;
function q1(e, t) {
  var r = [];
  return e[t].forEach(function(i) {
    var n = r.length;
    r.forEach(function(s, a) {
      s.tag === i.tag && s.kind === i.kind && s.multi === i.multi && (n = a);
    }), r[n] = i;
  }), r;
}
function ID() {
  var e = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, t, r;
  function i(n) {
    n.multi ? (e.multi[n.kind].push(n), e.multi.fallback.push(n)) : e[n.kind][n.tag] = e.fallback[n.tag] = n;
  }
  for (t = 0, r = arguments.length; t < r; t += 1)
    arguments[t].forEach(i);
  return e;
}
function xy(e) {
  return this.extend(e);
}
xy.prototype.extend = function(t) {
  var r = [], i = [];
  if (t instanceof Vp)
    i.push(t);
  else if (Array.isArray(t))
    i = i.concat(t);
  else if (t && (Array.isArray(t.implicit) || Array.isArray(t.explicit)))
    t.implicit && (r = r.concat(t.implicit)), t.explicit && (i = i.concat(t.explicit));
  else
    throw new Wo("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  r.forEach(function(s) {
    if (!(s instanceof Vp))
      throw new Wo("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    if (s.loadKind && s.loadKind !== "scalar")
      throw new Wo("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    if (s.multi)
      throw new Wo("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
  }), i.forEach(function(s) {
    if (!(s instanceof Vp))
      throw new Wo("Specified list of YAML types (or a single Type object) contains a non-Type object.");
  });
  var n = Object.create(xy.prototype);
  return n.implicit = (this.implicit || []).concat(r), n.explicit = (this.explicit || []).concat(i), n.compiledImplicit = q1(n, "implicit"), n.compiledExplicit = q1(n, "explicit"), n.compiledTypeMap = ID(n.compiledImplicit, n.compiledExplicit), n;
};
var Cx = xy, jD = Fr, Rx = new jD("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: function(e) {
    return e !== null ? e : "";
  }
}), kD = Fr, Tx = new kD("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: function(e) {
    return e !== null ? e : [];
  }
}), MD = Fr, Ix = new MD("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: function(e) {
    return e !== null ? e : {};
  }
}), ND = Cx, jx = new ND({
  explicit: [
    Rx,
    Tx,
    Ix
  ]
}), DD = Fr;
function LD(e) {
  if (e === null)
    return !0;
  var t = e.length;
  return t === 1 && e === "~" || t === 4 && (e === "null" || e === "Null" || e === "NULL");
}
function qD() {
  return null;
}
function FD(e) {
  return e === null;
}
var kx = new DD("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: LD,
  construct: qD,
  predicate: FD,
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    },
    empty: function() {
      return "";
    }
  },
  defaultStyle: "lowercase"
}), UD = Fr;
function BD(e) {
  if (e === null)
    return !1;
  var t = e.length;
  return t === 4 && (e === "true" || e === "True" || e === "TRUE") || t === 5 && (e === "false" || e === "False" || e === "FALSE");
}
function VD(e) {
  return e === "true" || e === "True" || e === "TRUE";
}
function ZD(e) {
  return Object.prototype.toString.call(e) === "[object Boolean]";
}
var Mx = new UD("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: BD,
  construct: VD,
  predicate: ZD,
  represent: {
    lowercase: function(e) {
      return e ? "true" : "false";
    },
    uppercase: function(e) {
      return e ? "TRUE" : "FALSE";
    },
    camelcase: function(e) {
      return e ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
}), zD = Dn, WD = Fr;
function HD(e) {
  return 48 <= e && e <= 57 || 65 <= e && e <= 70 || 97 <= e && e <= 102;
}
function GD(e) {
  return 48 <= e && e <= 55;
}
function KD(e) {
  return 48 <= e && e <= 57;
}
function YD(e) {
  if (e === null)
    return !1;
  var t = e.length, r = 0, i = !1, n;
  if (!t)
    return !1;
  if (n = e[r], (n === "-" || n === "+") && (n = e[++r]), n === "0") {
    if (r + 1 === t)
      return !0;
    if (n = e[++r], n === "b") {
      for (r++; r < t; r++)
        if (n = e[r], n !== "_") {
          if (n !== "0" && n !== "1")
            return !1;
          i = !0;
        }
      return i && n !== "_";
    }
    if (n === "x") {
      for (r++; r < t; r++)
        if (n = e[r], n !== "_") {
          if (!HD(e.charCodeAt(r)))
            return !1;
          i = !0;
        }
      return i && n !== "_";
    }
    if (n === "o") {
      for (r++; r < t; r++)
        if (n = e[r], n !== "_") {
          if (!GD(e.charCodeAt(r)))
            return !1;
          i = !0;
        }
      return i && n !== "_";
    }
  }
  if (n === "_")
    return !1;
  for (; r < t; r++)
    if (n = e[r], n !== "_") {
      if (!KD(e.charCodeAt(r)))
        return !1;
      i = !0;
    }
  return !(!i || n === "_");
}
function JD(e) {
  var t = e, r = 1, i;
  if (t.indexOf("_") !== -1 && (t = t.replace(/_/g, "")), i = t[0], (i === "-" || i === "+") && (i === "-" && (r = -1), t = t.slice(1), i = t[0]), t === "0")
    return 0;
  if (i === "0") {
    if (t[1] === "b")
      return r * parseInt(t.slice(2), 2);
    if (t[1] === "x")
      return r * parseInt(t.slice(2), 16);
    if (t[1] === "o")
      return r * parseInt(t.slice(2), 8);
  }
  return r * parseInt(t, 10);
}
function XD(e) {
  return Object.prototype.toString.call(e) === "[object Number]" && e % 1 === 0 && !zD.isNegativeZero(e);
}
var Nx = new WD("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: YD,
  construct: JD,
  predicate: XD,
  represent: {
    binary: function(e) {
      return e >= 0 ? "0b" + e.toString(2) : "-0b" + e.toString(2).slice(1);
    },
    octal: function(e) {
      return e >= 0 ? "0o" + e.toString(8) : "-0o" + e.toString(8).slice(1);
    },
    decimal: function(e) {
      return e.toString(10);
    },
    /* eslint-disable max-len */
    hexadecimal: function(e) {
      return e >= 0 ? "0x" + e.toString(16).toUpperCase() : "-0x" + e.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
}), Dx = Dn, QD = Fr, eL = new RegExp(
  // 2.5e4, 2.5 and integers
  "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function tL(e) {
  return !(e === null || !eL.test(e) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  e[e.length - 1] === "_");
}
function rL(e) {
  var t, r;
  return t = e.replace(/_/g, "").toLowerCase(), r = t[0] === "-" ? -1 : 1, "+-".indexOf(t[0]) >= 0 && (t = t.slice(1)), t === ".inf" ? r === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY : t === ".nan" ? NaN : r * parseFloat(t, 10);
}
var nL = /^[-+]?[0-9]+e/;
function iL(e, t) {
  var r;
  if (isNaN(e))
    switch (t) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  else if (Number.POSITIVE_INFINITY === e)
    switch (t) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  else if (Number.NEGATIVE_INFINITY === e)
    switch (t) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  else if (Dx.isNegativeZero(e))
    return "-0.0";
  return r = e.toString(10), nL.test(r) ? r.replace("e", ".e") : r;
}
function sL(e) {
  return Object.prototype.toString.call(e) === "[object Number]" && (e % 1 !== 0 || Dx.isNegativeZero(e));
}
var Lx = new QD("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: tL,
  construct: rL,
  predicate: sL,
  represent: iL,
  defaultStyle: "lowercase"
}), qx = jx.extend({
  implicit: [
    kx,
    Mx,
    Nx,
    Lx
  ]
}), Fx = qx, aL = Fr, Ux = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
), Bx = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
);
function oL(e) {
  return e === null ? !1 : Ux.exec(e) !== null || Bx.exec(e) !== null;
}
function uL(e) {
  var t, r, i, n, s, a, u, c = 0, l = null, d, p, h;
  if (t = Ux.exec(e), t === null && (t = Bx.exec(e)), t === null)
    throw new Error("Date resolve error");
  if (r = +t[1], i = +t[2] - 1, n = +t[3], !t[4])
    return new Date(Date.UTC(r, i, n));
  if (s = +t[4], a = +t[5], u = +t[6], t[7]) {
    for (c = t[7].slice(0, 3); c.length < 3; )
      c += "0";
    c = +c;
  }
  return t[9] && (d = +t[10], p = +(t[11] || 0), l = (d * 60 + p) * 6e4, t[9] === "-" && (l = -l)), h = new Date(Date.UTC(r, i, n, s, a, u, c)), l && h.setTime(h.getTime() - l), h;
}
function cL(e) {
  return e.toISOString();
}
var Vx = new aL("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: oL,
  construct: uL,
  instanceOf: Date,
  represent: cL
}), lL = Fr;
function fL(e) {
  return e === "<<" || e === null;
}
var Zx = new lL("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: fL
}), dL = Fr, Tg = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`;
function pL(e) {
  if (e === null)
    return !1;
  var t, r, i = 0, n = e.length, s = Tg;
  for (r = 0; r < n; r++)
    if (t = s.indexOf(e.charAt(r)), !(t > 64)) {
      if (t < 0)
        return !1;
      i += 6;
    }
  return i % 8 === 0;
}
function hL(e) {
  var t, r, i = e.replace(/[\r\n=]/g, ""), n = i.length, s = Tg, a = 0, u = [];
  for (t = 0; t < n; t++)
    t % 4 === 0 && t && (u.push(a >> 16 & 255), u.push(a >> 8 & 255), u.push(a & 255)), a = a << 6 | s.indexOf(i.charAt(t));
  return r = n % 4 * 6, r === 0 ? (u.push(a >> 16 & 255), u.push(a >> 8 & 255), u.push(a & 255)) : r === 18 ? (u.push(a >> 10 & 255), u.push(a >> 2 & 255)) : r === 12 && u.push(a >> 4 & 255), new Uint8Array(u);
}
function mL(e) {
  var t = "", r = 0, i, n, s = e.length, a = Tg;
  for (i = 0; i < s; i++)
    i % 3 === 0 && i && (t += a[r >> 18 & 63], t += a[r >> 12 & 63], t += a[r >> 6 & 63], t += a[r & 63]), r = (r << 8) + e[i];
  return n = s % 3, n === 0 ? (t += a[r >> 18 & 63], t += a[r >> 12 & 63], t += a[r >> 6 & 63], t += a[r & 63]) : n === 2 ? (t += a[r >> 10 & 63], t += a[r >> 4 & 63], t += a[r << 2 & 63], t += a[64]) : n === 1 && (t += a[r >> 2 & 63], t += a[r << 4 & 63], t += a[64], t += a[64]), t;
}
function yL(e) {
  return Object.prototype.toString.call(e) === "[object Uint8Array]";
}
var zx = new dL("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: pL,
  construct: hL,
  predicate: yL,
  represent: mL
}), gL = Fr, vL = Object.prototype.hasOwnProperty, bL = Object.prototype.toString;
function _L(e) {
  if (e === null)
    return !0;
  var t = [], r, i, n, s, a, u = e;
  for (r = 0, i = u.length; r < i; r += 1) {
    if (n = u[r], a = !1, bL.call(n) !== "[object Object]")
      return !1;
    for (s in n)
      if (vL.call(n, s))
        if (!a)
          a = !0;
        else
          return !1;
    if (!a)
      return !1;
    if (t.indexOf(s) === -1)
      t.push(s);
    else
      return !1;
  }
  return !0;
}
function wL(e) {
  return e !== null ? e : [];
}
var Wx = new gL("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: _L,
  construct: wL
}), $L = Fr, EL = Object.prototype.toString;
function xL(e) {
  if (e === null)
    return !0;
  var t, r, i, n, s, a = e;
  for (s = new Array(a.length), t = 0, r = a.length; t < r; t += 1) {
    if (i = a[t], EL.call(i) !== "[object Object]" || (n = Object.keys(i), n.length !== 1))
      return !1;
    s[t] = [n[0], i[n[0]]];
  }
  return !0;
}
function OL(e) {
  if (e === null)
    return [];
  var t, r, i, n, s, a = e;
  for (s = new Array(a.length), t = 0, r = a.length; t < r; t += 1)
    i = a[t], n = Object.keys(i), s[t] = [n[0], i[n[0]]];
  return s;
}
var Hx = new $L("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: xL,
  construct: OL
}), PL = Fr, SL = Object.prototype.hasOwnProperty;
function AL(e) {
  if (e === null)
    return !0;
  var t, r = e;
  for (t in r)
    if (SL.call(r, t) && r[t] !== null)
      return !1;
  return !0;
}
function CL(e) {
  return e !== null ? e : {};
}
var Gx = new PL("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: AL,
  construct: CL
}), Ig = Fx.extend({
  implicit: [
    Vx,
    Zx
  ],
  explicit: [
    zx,
    Wx,
    Hx,
    Gx
  ]
}), Ls = Dn, Kx = tc, RL = SD, TL = Ig, hs = Object.prototype.hasOwnProperty, df = 1, Yx = 2, Jx = 3, pf = 4, Zp = 1, IL = 2, F1 = 3, jL = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, kL = /[\x85\u2028\u2029]/, ML = /[,\[\]\{\}]/, Xx = /^(?:!|!!|![a-z\-]+!)$/i, Qx = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function U1(e) {
  return Object.prototype.toString.call(e);
}
function ti(e) {
  return e === 10 || e === 13;
}
function Ks(e) {
  return e === 9 || e === 32;
}
function Hr(e) {
  return e === 9 || e === 32 || e === 10 || e === 13;
}
function Va(e) {
  return e === 44 || e === 91 || e === 93 || e === 123 || e === 125;
}
function NL(e) {
  var t;
  return 48 <= e && e <= 57 ? e - 48 : (t = e | 32, 97 <= t && t <= 102 ? t - 97 + 10 : -1);
}
function DL(e) {
  return e === 120 ? 2 : e === 117 ? 4 : e === 85 ? 8 : 0;
}
function LL(e) {
  return 48 <= e && e <= 57 ? e - 48 : -1;
}
function B1(e) {
  return e === 48 ? "\0" : e === 97 ? "\x07" : e === 98 ? "\b" : e === 116 || e === 9 ? "	" : e === 110 ? `
` : e === 118 ? "\v" : e === 102 ? "\f" : e === 114 ? "\r" : e === 101 ? "\x1B" : e === 32 ? " " : e === 34 ? '"' : e === 47 ? "/" : e === 92 ? "\\" : e === 78 ? "" : e === 95 ? " " : e === 76 ? "\u2028" : e === 80 ? "\u2029" : "";
}
function qL(e) {
  return e <= 65535 ? String.fromCharCode(e) : String.fromCharCode(
    (e - 65536 >> 10) + 55296,
    (e - 65536 & 1023) + 56320
  );
}
var eO = new Array(256), tO = new Array(256);
for (var Ca = 0; Ca < 256; Ca++)
  eO[Ca] = B1(Ca) ? 1 : 0, tO[Ca] = B1(Ca);
function FL(e, t) {
  this.input = e, this.filename = t.filename || null, this.schema = t.schema || TL, this.onWarning = t.onWarning || null, this.legacy = t.legacy || !1, this.json = t.json || !1, this.listener = t.listener || null, this.implicitTypes = this.schema.compiledImplicit, this.typeMap = this.schema.compiledTypeMap, this.length = e.length, this.position = 0, this.line = 0, this.lineStart = 0, this.lineIndent = 0, this.firstTabInLine = -1, this.documents = [];
}
function rO(e, t) {
  var r = {
    name: e.filename,
    buffer: e.input.slice(0, -1),
    // omit trailing \0
    position: e.position,
    line: e.line,
    column: e.position - e.lineStart
  };
  return r.snippet = RL(r), new Kx(t, r);
}
function et(e, t) {
  throw rO(e, t);
}
function hf(e, t) {
  e.onWarning && e.onWarning.call(null, rO(e, t));
}
var V1 = {
  YAML: function(t, r, i) {
    var n, s, a;
    t.version !== null && et(t, "duplication of %YAML directive"), i.length !== 1 && et(t, "YAML directive accepts exactly one argument"), n = /^([0-9]+)\.([0-9]+)$/.exec(i[0]), n === null && et(t, "ill-formed argument of the YAML directive"), s = parseInt(n[1], 10), a = parseInt(n[2], 10), s !== 1 && et(t, "unacceptable YAML version of the document"), t.version = i[0], t.checkLineBreaks = a < 2, a !== 1 && a !== 2 && hf(t, "unsupported YAML version of the document");
  },
  TAG: function(t, r, i) {
    var n, s;
    i.length !== 2 && et(t, "TAG directive accepts exactly two arguments"), n = i[0], s = i[1], Xx.test(n) || et(t, "ill-formed tag handle (first argument) of the TAG directive"), hs.call(t.tagMap, n) && et(t, 'there is a previously declared suffix for "' + n + '" tag handle'), Qx.test(s) || et(t, "ill-formed tag prefix (second argument) of the TAG directive");
    try {
      s = decodeURIComponent(s);
    } catch {
      et(t, "tag prefix is malformed: " + s);
    }
    t.tagMap[n] = s;
  }
};
function os(e, t, r, i) {
  var n, s, a, u;
  if (t < r) {
    if (u = e.input.slice(t, r), i)
      for (n = 0, s = u.length; n < s; n += 1)
        a = u.charCodeAt(n), a === 9 || 32 <= a && a <= 1114111 || et(e, "expected valid JSON character");
    else
      jL.test(u) && et(e, "the stream contains non-printable characters");
    e.result += u;
  }
}
function Z1(e, t, r, i) {
  var n, s, a, u;
  for (Ls.isObject(r) || et(e, "cannot merge mappings; the provided source object is unacceptable"), n = Object.keys(r), a = 0, u = n.length; a < u; a += 1)
    s = n[a], hs.call(t, s) || (t[s] = r[s], i[s] = !0);
}
function Za(e, t, r, i, n, s, a, u, c) {
  var l, d;
  if (Array.isArray(n))
    for (n = Array.prototype.slice.call(n), l = 0, d = n.length; l < d; l += 1)
      Array.isArray(n[l]) && et(e, "nested arrays are not supported inside keys"), typeof n == "object" && U1(n[l]) === "[object Object]" && (n[l] = "[object Object]");
  if (typeof n == "object" && U1(n) === "[object Object]" && (n = "[object Object]"), n = String(n), t === null && (t = {}), i === "tag:yaml.org,2002:merge")
    if (Array.isArray(s))
      for (l = 0, d = s.length; l < d; l += 1)
        Z1(e, t, s[l], r);
    else
      Z1(e, t, s, r);
  else
    !e.json && !hs.call(r, n) && hs.call(t, n) && (e.line = a || e.line, e.lineStart = u || e.lineStart, e.position = c || e.position, et(e, "duplicated mapping key")), n === "__proto__" ? Object.defineProperty(t, n, {
      configurable: !0,
      enumerable: !0,
      writable: !0,
      value: s
    }) : t[n] = s, delete r[n];
  return t;
}
function jg(e) {
  var t;
  t = e.input.charCodeAt(e.position), t === 10 ? e.position++ : t === 13 ? (e.position++, e.input.charCodeAt(e.position) === 10 && e.position++) : et(e, "a line break is expected"), e.line += 1, e.lineStart = e.position, e.firstTabInLine = -1;
}
function ar(e, t, r) {
  for (var i = 0, n = e.input.charCodeAt(e.position); n !== 0; ) {
    for (; Ks(n); )
      n === 9 && e.firstTabInLine === -1 && (e.firstTabInLine = e.position), n = e.input.charCodeAt(++e.position);
    if (t && n === 35)
      do
        n = e.input.charCodeAt(++e.position);
      while (n !== 10 && n !== 13 && n !== 0);
    if (ti(n))
      for (jg(e), n = e.input.charCodeAt(e.position), i++, e.lineIndent = 0; n === 32; )
        e.lineIndent++, n = e.input.charCodeAt(++e.position);
    else
      break;
  }
  return r !== -1 && i !== 0 && e.lineIndent < r && hf(e, "deficient indentation"), i;
}
function zf(e) {
  var t = e.position, r;
  return r = e.input.charCodeAt(t), !!((r === 45 || r === 46) && r === e.input.charCodeAt(t + 1) && r === e.input.charCodeAt(t + 2) && (t += 3, r = e.input.charCodeAt(t), r === 0 || Hr(r)));
}
function kg(e, t) {
  t === 1 ? e.result += " " : t > 1 && (e.result += Ls.repeat(`
`, t - 1));
}
function UL(e, t, r) {
  var i, n, s, a, u, c, l, d, p = e.kind, h = e.result, v;
  if (v = e.input.charCodeAt(e.position), Hr(v) || Va(v) || v === 35 || v === 38 || v === 42 || v === 33 || v === 124 || v === 62 || v === 39 || v === 34 || v === 37 || v === 64 || v === 96 || (v === 63 || v === 45) && (n = e.input.charCodeAt(e.position + 1), Hr(n) || r && Va(n)))
    return !1;
  for (e.kind = "scalar", e.result = "", s = a = e.position, u = !1; v !== 0; ) {
    if (v === 58) {
      if (n = e.input.charCodeAt(e.position + 1), Hr(n) || r && Va(n))
        break;
    } else if (v === 35) {
      if (i = e.input.charCodeAt(e.position - 1), Hr(i))
        break;
    } else {
      if (e.position === e.lineStart && zf(e) || r && Va(v))
        break;
      if (ti(v))
        if (c = e.line, l = e.lineStart, d = e.lineIndent, ar(e, !1, -1), e.lineIndent >= t) {
          u = !0, v = e.input.charCodeAt(e.position);
          continue;
        } else {
          e.position = a, e.line = c, e.lineStart = l, e.lineIndent = d;
          break;
        }
    }
    u && (os(e, s, a, !1), kg(e, e.line - c), s = a = e.position, u = !1), Ks(v) || (a = e.position + 1), v = e.input.charCodeAt(++e.position);
  }
  return os(e, s, a, !1), e.result ? !0 : (e.kind = p, e.result = h, !1);
}
function BL(e, t) {
  var r, i, n;
  if (r = e.input.charCodeAt(e.position), r !== 39)
    return !1;
  for (e.kind = "scalar", e.result = "", e.position++, i = n = e.position; (r = e.input.charCodeAt(e.position)) !== 0; )
    if (r === 39)
      if (os(e, i, e.position, !0), r = e.input.charCodeAt(++e.position), r === 39)
        i = e.position, e.position++, n = e.position;
      else
        return !0;
    else
      ti(r) ? (os(e, i, n, !0), kg(e, ar(e, !1, t)), i = n = e.position) : e.position === e.lineStart && zf(e) ? et(e, "unexpected end of the document within a single quoted scalar") : (e.position++, n = e.position);
  et(e, "unexpected end of the stream within a single quoted scalar");
}
function VL(e, t) {
  var r, i, n, s, a, u;
  if (u = e.input.charCodeAt(e.position), u !== 34)
    return !1;
  for (e.kind = "scalar", e.result = "", e.position++, r = i = e.position; (u = e.input.charCodeAt(e.position)) !== 0; ) {
    if (u === 34)
      return os(e, r, e.position, !0), e.position++, !0;
    if (u === 92) {
      if (os(e, r, e.position, !0), u = e.input.charCodeAt(++e.position), ti(u))
        ar(e, !1, t);
      else if (u < 256 && eO[u])
        e.result += tO[u], e.position++;
      else if ((a = DL(u)) > 0) {
        for (n = a, s = 0; n > 0; n--)
          u = e.input.charCodeAt(++e.position), (a = NL(u)) >= 0 ? s = (s << 4) + a : et(e, "expected hexadecimal character");
        e.result += qL(s), e.position++;
      } else
        et(e, "unknown escape sequence");
      r = i = e.position;
    } else
      ti(u) ? (os(e, r, i, !0), kg(e, ar(e, !1, t)), r = i = e.position) : e.position === e.lineStart && zf(e) ? et(e, "unexpected end of the document within a double quoted scalar") : (e.position++, i = e.position);
  }
  et(e, "unexpected end of the stream within a double quoted scalar");
}
function ZL(e, t) {
  var r = !0, i, n, s, a = e.tag, u, c = e.anchor, l, d, p, h, v, y = /* @__PURE__ */ Object.create(null), g, _, m, w;
  if (w = e.input.charCodeAt(e.position), w === 91)
    d = 93, v = !1, u = [];
  else if (w === 123)
    d = 125, v = !0, u = {};
  else
    return !1;
  for (e.anchor !== null && (e.anchorMap[e.anchor] = u), w = e.input.charCodeAt(++e.position); w !== 0; ) {
    if (ar(e, !0, t), w = e.input.charCodeAt(e.position), w === d)
      return e.position++, e.tag = a, e.anchor = c, e.kind = v ? "mapping" : "sequence", e.result = u, !0;
    r ? w === 44 && et(e, "expected the node content, but found ','") : et(e, "missed comma between flow collection entries"), _ = g = m = null, p = h = !1, w === 63 && (l = e.input.charCodeAt(e.position + 1), Hr(l) && (p = h = !0, e.position++, ar(e, !0, t))), i = e.line, n = e.lineStart, s = e.position, so(e, t, df, !1, !0), _ = e.tag, g = e.result, ar(e, !0, t), w = e.input.charCodeAt(e.position), (h || e.line === i) && w === 58 && (p = !0, w = e.input.charCodeAt(++e.position), ar(e, !0, t), so(e, t, df, !1, !0), m = e.result), v ? Za(e, u, y, _, g, m, i, n, s) : p ? u.push(Za(e, null, y, _, g, m, i, n, s)) : u.push(g), ar(e, !0, t), w = e.input.charCodeAt(e.position), w === 44 ? (r = !0, w = e.input.charCodeAt(++e.position)) : r = !1;
  }
  et(e, "unexpected end of the stream within a flow collection");
}
function zL(e, t) {
  var r, i, n = Zp, s = !1, a = !1, u = t, c = 0, l = !1, d, p;
  if (p = e.input.charCodeAt(e.position), p === 124)
    i = !1;
  else if (p === 62)
    i = !0;
  else
    return !1;
  for (e.kind = "scalar", e.result = ""; p !== 0; )
    if (p = e.input.charCodeAt(++e.position), p === 43 || p === 45)
      Zp === n ? n = p === 43 ? F1 : IL : et(e, "repeat of a chomping mode identifier");
    else if ((d = LL(p)) >= 0)
      d === 0 ? et(e, "bad explicit indentation width of a block scalar; it cannot be less than one") : a ? et(e, "repeat of an indentation width identifier") : (u = t + d - 1, a = !0);
    else
      break;
  if (Ks(p)) {
    do
      p = e.input.charCodeAt(++e.position);
    while (Ks(p));
    if (p === 35)
      do
        p = e.input.charCodeAt(++e.position);
      while (!ti(p) && p !== 0);
  }
  for (; p !== 0; ) {
    for (jg(e), e.lineIndent = 0, p = e.input.charCodeAt(e.position); (!a || e.lineIndent < u) && p === 32; )
      e.lineIndent++, p = e.input.charCodeAt(++e.position);
    if (!a && e.lineIndent > u && (u = e.lineIndent), ti(p)) {
      c++;
      continue;
    }
    if (e.lineIndent < u) {
      n === F1 ? e.result += Ls.repeat(`
`, s ? 1 + c : c) : n === Zp && s && (e.result += `
`);
      break;
    }
    for (i ? Ks(p) ? (l = !0, e.result += Ls.repeat(`
`, s ? 1 + c : c)) : l ? (l = !1, e.result += Ls.repeat(`
`, c + 1)) : c === 0 ? s && (e.result += " ") : e.result += Ls.repeat(`
`, c) : e.result += Ls.repeat(`
`, s ? 1 + c : c), s = !0, a = !0, c = 0, r = e.position; !ti(p) && p !== 0; )
      p = e.input.charCodeAt(++e.position);
    os(e, r, e.position, !1);
  }
  return !0;
}
function z1(e, t) {
  var r, i = e.tag, n = e.anchor, s = [], a, u = !1, c;
  if (e.firstTabInLine !== -1)
    return !1;
  for (e.anchor !== null && (e.anchorMap[e.anchor] = s), c = e.input.charCodeAt(e.position); c !== 0 && (e.firstTabInLine !== -1 && (e.position = e.firstTabInLine, et(e, "tab characters must not be used in indentation")), !(c !== 45 || (a = e.input.charCodeAt(e.position + 1), !Hr(a)))); ) {
    if (u = !0, e.position++, ar(e, !0, -1) && e.lineIndent <= t) {
      s.push(null), c = e.input.charCodeAt(e.position);
      continue;
    }
    if (r = e.line, so(e, t, Jx, !1, !0), s.push(e.result), ar(e, !0, -1), c = e.input.charCodeAt(e.position), (e.line === r || e.lineIndent > t) && c !== 0)
      et(e, "bad indentation of a sequence entry");
    else if (e.lineIndent < t)
      break;
  }
  return u ? (e.tag = i, e.anchor = n, e.kind = "sequence", e.result = s, !0) : !1;
}
function WL(e, t, r) {
  var i, n, s, a, u, c, l = e.tag, d = e.anchor, p = {}, h = /* @__PURE__ */ Object.create(null), v = null, y = null, g = null, _ = !1, m = !1, w;
  if (e.firstTabInLine !== -1)
    return !1;
  for (e.anchor !== null && (e.anchorMap[e.anchor] = p), w = e.input.charCodeAt(e.position); w !== 0; ) {
    if (!_ && e.firstTabInLine !== -1 && (e.position = e.firstTabInLine, et(e, "tab characters must not be used in indentation")), i = e.input.charCodeAt(e.position + 1), s = e.line, (w === 63 || w === 58) && Hr(i))
      w === 63 ? (_ && (Za(e, p, h, v, y, null, a, u, c), v = y = g = null), m = !0, _ = !0, n = !0) : _ ? (_ = !1, n = !0) : et(e, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"), e.position += 1, w = i;
    else {
      if (a = e.line, u = e.lineStart, c = e.position, !so(e, r, Yx, !1, !0))
        break;
      if (e.line === s) {
        for (w = e.input.charCodeAt(e.position); Ks(w); )
          w = e.input.charCodeAt(++e.position);
        if (w === 58)
          w = e.input.charCodeAt(++e.position), Hr(w) || et(e, "a whitespace character is expected after the key-value separator within a block mapping"), _ && (Za(e, p, h, v, y, null, a, u, c), v = y = g = null), m = !0, _ = !1, n = !1, v = e.tag, y = e.result;
        else if (m)
          et(e, "can not read an implicit mapping pair; a colon is missed");
        else
          return e.tag = l, e.anchor = d, !0;
      } else if (m)
        et(e, "can not read a block mapping entry; a multiline key may not be an implicit key");
      else
        return e.tag = l, e.anchor = d, !0;
    }
    if ((e.line === s || e.lineIndent > t) && (_ && (a = e.line, u = e.lineStart, c = e.position), so(e, t, pf, !0, n) && (_ ? y = e.result : g = e.result), _ || (Za(e, p, h, v, y, g, a, u, c), v = y = g = null), ar(e, !0, -1), w = e.input.charCodeAt(e.position)), (e.line === s || e.lineIndent > t) && w !== 0)
      et(e, "bad indentation of a mapping entry");
    else if (e.lineIndent < t)
      break;
  }
  return _ && Za(e, p, h, v, y, null, a, u, c), m && (e.tag = l, e.anchor = d, e.kind = "mapping", e.result = p), m;
}
function HL(e) {
  var t, r = !1, i = !1, n, s, a;
  if (a = e.input.charCodeAt(e.position), a !== 33)
    return !1;
  if (e.tag !== null && et(e, "duplication of a tag property"), a = e.input.charCodeAt(++e.position), a === 60 ? (r = !0, a = e.input.charCodeAt(++e.position)) : a === 33 ? (i = !0, n = "!!", a = e.input.charCodeAt(++e.position)) : n = "!", t = e.position, r) {
    do
      a = e.input.charCodeAt(++e.position);
    while (a !== 0 && a !== 62);
    e.position < e.length ? (s = e.input.slice(t, e.position), a = e.input.charCodeAt(++e.position)) : et(e, "unexpected end of the stream within a verbatim tag");
  } else {
    for (; a !== 0 && !Hr(a); )
      a === 33 && (i ? et(e, "tag suffix cannot contain exclamation marks") : (n = e.input.slice(t - 1, e.position + 1), Xx.test(n) || et(e, "named tag handle cannot contain such characters"), i = !0, t = e.position + 1)), a = e.input.charCodeAt(++e.position);
    s = e.input.slice(t, e.position), ML.test(s) && et(e, "tag suffix cannot contain flow indicator characters");
  }
  s && !Qx.test(s) && et(e, "tag name cannot contain such characters: " + s);
  try {
    s = decodeURIComponent(s);
  } catch {
    et(e, "tag name is malformed: " + s);
  }
  return r ? e.tag = s : hs.call(e.tagMap, n) ? e.tag = e.tagMap[n] + s : n === "!" ? e.tag = "!" + s : n === "!!" ? e.tag = "tag:yaml.org,2002:" + s : et(e, 'undeclared tag handle "' + n + '"'), !0;
}
function GL(e) {
  var t, r;
  if (r = e.input.charCodeAt(e.position), r !== 38)
    return !1;
  for (e.anchor !== null && et(e, "duplication of an anchor property"), r = e.input.charCodeAt(++e.position), t = e.position; r !== 0 && !Hr(r) && !Va(r); )
    r = e.input.charCodeAt(++e.position);
  return e.position === t && et(e, "name of an anchor node must contain at least one character"), e.anchor = e.input.slice(t, e.position), !0;
}
function KL(e) {
  var t, r, i;
  if (i = e.input.charCodeAt(e.position), i !== 42)
    return !1;
  for (i = e.input.charCodeAt(++e.position), t = e.position; i !== 0 && !Hr(i) && !Va(i); )
    i = e.input.charCodeAt(++e.position);
  return e.position === t && et(e, "name of an alias node must contain at least one character"), r = e.input.slice(t, e.position), hs.call(e.anchorMap, r) || et(e, 'unidentified alias "' + r + '"'), e.result = e.anchorMap[r], ar(e, !0, -1), !0;
}
function so(e, t, r, i, n) {
  var s, a, u, c = 1, l = !1, d = !1, p, h, v, y, g, _;
  if (e.listener !== null && e.listener("open", e), e.tag = null, e.anchor = null, e.kind = null, e.result = null, s = a = u = pf === r || Jx === r, i && ar(e, !0, -1) && (l = !0, e.lineIndent > t ? c = 1 : e.lineIndent === t ? c = 0 : e.lineIndent < t && (c = -1)), c === 1)
    for (; HL(e) || GL(e); )
      ar(e, !0, -1) ? (l = !0, u = s, e.lineIndent > t ? c = 1 : e.lineIndent === t ? c = 0 : e.lineIndent < t && (c = -1)) : u = !1;
  if (u && (u = l || n), (c === 1 || pf === r) && (df === r || Yx === r ? g = t : g = t + 1, _ = e.position - e.lineStart, c === 1 ? u && (z1(e, _) || WL(e, _, g)) || ZL(e, g) ? d = !0 : (a && zL(e, g) || BL(e, g) || VL(e, g) ? d = !0 : KL(e) ? (d = !0, (e.tag !== null || e.anchor !== null) && et(e, "alias node should not have any properties")) : UL(e, g, df === r) && (d = !0, e.tag === null && (e.tag = "?")), e.anchor !== null && (e.anchorMap[e.anchor] = e.result)) : c === 0 && (d = u && z1(e, _))), e.tag === null)
    e.anchor !== null && (e.anchorMap[e.anchor] = e.result);
  else if (e.tag === "?") {
    for (e.result !== null && e.kind !== "scalar" && et(e, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + e.kind + '"'), p = 0, h = e.implicitTypes.length; p < h; p += 1)
      if (y = e.implicitTypes[p], y.resolve(e.result)) {
        e.result = y.construct(e.result), e.tag = y.tag, e.anchor !== null && (e.anchorMap[e.anchor] = e.result);
        break;
      }
  } else if (e.tag !== "!") {
    if (hs.call(e.typeMap[e.kind || "fallback"], e.tag))
      y = e.typeMap[e.kind || "fallback"][e.tag];
    else
      for (y = null, v = e.typeMap.multi[e.kind || "fallback"], p = 0, h = v.length; p < h; p += 1)
        if (e.tag.slice(0, v[p].tag.length) === v[p].tag) {
          y = v[p];
          break;
        }
    y || et(e, "unknown tag !<" + e.tag + ">"), e.result !== null && y.kind !== e.kind && et(e, "unacceptable node kind for !<" + e.tag + '> tag; it should be "' + y.kind + '", not "' + e.kind + '"'), y.resolve(e.result, e.tag) ? (e.result = y.construct(e.result, e.tag), e.anchor !== null && (e.anchorMap[e.anchor] = e.result)) : et(e, "cannot resolve a node with !<" + e.tag + "> explicit tag");
  }
  return e.listener !== null && e.listener("close", e), e.tag !== null || e.anchor !== null || d;
}
function YL(e) {
  var t = e.position, r, i, n, s = !1, a;
  for (e.version = null, e.checkLineBreaks = e.legacy, e.tagMap = /* @__PURE__ */ Object.create(null), e.anchorMap = /* @__PURE__ */ Object.create(null); (a = e.input.charCodeAt(e.position)) !== 0 && (ar(e, !0, -1), a = e.input.charCodeAt(e.position), !(e.lineIndent > 0 || a !== 37)); ) {
    for (s = !0, a = e.input.charCodeAt(++e.position), r = e.position; a !== 0 && !Hr(a); )
      a = e.input.charCodeAt(++e.position);
    for (i = e.input.slice(r, e.position), n = [], i.length < 1 && et(e, "directive name must not be less than one character in length"); a !== 0; ) {
      for (; Ks(a); )
        a = e.input.charCodeAt(++e.position);
      if (a === 35) {
        do
          a = e.input.charCodeAt(++e.position);
        while (a !== 0 && !ti(a));
        break;
      }
      if (ti(a))
        break;
      for (r = e.position; a !== 0 && !Hr(a); )
        a = e.input.charCodeAt(++e.position);
      n.push(e.input.slice(r, e.position));
    }
    a !== 0 && jg(e), hs.call(V1, i) ? V1[i](e, i, n) : hf(e, 'unknown document directive "' + i + '"');
  }
  if (ar(e, !0, -1), e.lineIndent === 0 && e.input.charCodeAt(e.position) === 45 && e.input.charCodeAt(e.position + 1) === 45 && e.input.charCodeAt(e.position + 2) === 45 ? (e.position += 3, ar(e, !0, -1)) : s && et(e, "directives end mark is expected"), so(e, e.lineIndent - 1, pf, !1, !0), ar(e, !0, -1), e.checkLineBreaks && kL.test(e.input.slice(t, e.position)) && hf(e, "non-ASCII line breaks are interpreted as content"), e.documents.push(e.result), e.position === e.lineStart && zf(e)) {
    e.input.charCodeAt(e.position) === 46 && (e.position += 3, ar(e, !0, -1));
    return;
  }
  if (e.position < e.length - 1)
    et(e, "end of the stream or a document separator is expected");
  else
    return;
}
function nO(e, t) {
  e = String(e), t = t || {}, e.length !== 0 && (e.charCodeAt(e.length - 1) !== 10 && e.charCodeAt(e.length - 1) !== 13 && (e += `
`), e.charCodeAt(0) === 65279 && (e = e.slice(1)));
  var r = new FL(e, t), i = e.indexOf("\0");
  for (i !== -1 && (r.position = i, et(r, "null byte is not allowed in input")), r.input += "\0"; r.input.charCodeAt(r.position) === 32; )
    r.lineIndent += 1, r.position += 1;
  for (; r.position < r.length - 1; )
    YL(r);
  return r.documents;
}
function JL(e, t, r) {
  t !== null && typeof t == "object" && typeof r > "u" && (r = t, t = null);
  var i = nO(e, r);
  if (typeof t != "function")
    return i;
  for (var n = 0, s = i.length; n < s; n += 1)
    t(i[n]);
}
function XL(e, t) {
  var r = nO(e, t);
  if (r.length !== 0) {
    if (r.length === 1)
      return r[0];
    throw new Kx("expected a single document in the stream, but found more");
  }
}
Rg.loadAll = JL;
Rg.load = XL;
var iO = {}, Wf = Dn, rc = tc, QL = Ig, sO = Object.prototype.toString, aO = Object.prototype.hasOwnProperty, Mg = 65279, e6 = 9, Du = 10, t6 = 13, r6 = 32, n6 = 33, i6 = 34, Oy = 35, s6 = 37, a6 = 38, o6 = 39, u6 = 42, oO = 44, c6 = 45, mf = 58, l6 = 61, f6 = 62, d6 = 63, p6 = 64, uO = 91, cO = 93, h6 = 96, lO = 123, m6 = 124, fO = 125, Rr = {};
Rr[0] = "\\0";
Rr[7] = "\\a";
Rr[8] = "\\b";
Rr[9] = "\\t";
Rr[10] = "\\n";
Rr[11] = "\\v";
Rr[12] = "\\f";
Rr[13] = "\\r";
Rr[27] = "\\e";
Rr[34] = '\\"';
Rr[92] = "\\\\";
Rr[133] = "\\N";
Rr[160] = "\\_";
Rr[8232] = "\\L";
Rr[8233] = "\\P";
var y6 = [
  "y",
  "Y",
  "yes",
  "Yes",
  "YES",
  "on",
  "On",
  "ON",
  "n",
  "N",
  "no",
  "No",
  "NO",
  "off",
  "Off",
  "OFF"
], g6 = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function v6(e, t) {
  var r, i, n, s, a, u, c;
  if (t === null)
    return {};
  for (r = {}, i = Object.keys(t), n = 0, s = i.length; n < s; n += 1)
    a = i[n], u = String(t[a]), a.slice(0, 2) === "!!" && (a = "tag:yaml.org,2002:" + a.slice(2)), c = e.compiledTypeMap.fallback[a], c && aO.call(c.styleAliases, u) && (u = c.styleAliases[u]), r[a] = u;
  return r;
}
function b6(e) {
  var t, r, i;
  if (t = e.toString(16).toUpperCase(), e <= 255)
    r = "x", i = 2;
  else if (e <= 65535)
    r = "u", i = 4;
  else if (e <= 4294967295)
    r = "U", i = 8;
  else
    throw new rc("code point within a string may not be greater than 0xFFFFFFFF");
  return "\\" + r + Wf.repeat("0", i - t.length) + t;
}
var _6 = 1, Lu = 2;
function w6(e) {
  this.schema = e.schema || QL, this.indent = Math.max(1, e.indent || 2), this.noArrayIndent = e.noArrayIndent || !1, this.skipInvalid = e.skipInvalid || !1, this.flowLevel = Wf.isNothing(e.flowLevel) ? -1 : e.flowLevel, this.styleMap = v6(this.schema, e.styles || null), this.sortKeys = e.sortKeys || !1, this.lineWidth = e.lineWidth || 80, this.noRefs = e.noRefs || !1, this.noCompatMode = e.noCompatMode || !1, this.condenseFlow = e.condenseFlow || !1, this.quotingType = e.quotingType === '"' ? Lu : _6, this.forceQuotes = e.forceQuotes || !1, this.replacer = typeof e.replacer == "function" ? e.replacer : null, this.implicitTypes = this.schema.compiledImplicit, this.explicitTypes = this.schema.compiledExplicit, this.tag = null, this.result = "", this.duplicates = [], this.usedDuplicates = null;
}
function W1(e, t) {
  for (var r = Wf.repeat(" ", t), i = 0, n = -1, s = "", a, u = e.length; i < u; )
    n = e.indexOf(`
`, i), n === -1 ? (a = e.slice(i), i = u) : (a = e.slice(i, n + 1), i = n + 1), a.length && a !== `
` && (s += r), s += a;
  return s;
}
function Py(e, t) {
  return `
` + Wf.repeat(" ", e.indent * t);
}
function $6(e, t) {
  var r, i, n;
  for (r = 0, i = e.implicitTypes.length; r < i; r += 1)
    if (n = e.implicitTypes[r], n.resolve(t))
      return !0;
  return !1;
}
function yf(e) {
  return e === r6 || e === e6;
}
function qu(e) {
  return 32 <= e && e <= 126 || 161 <= e && e <= 55295 && e !== 8232 && e !== 8233 || 57344 <= e && e <= 65533 && e !== Mg || 65536 <= e && e <= 1114111;
}
function H1(e) {
  return qu(e) && e !== Mg && e !== t6 && e !== Du;
}
function G1(e, t, r) {
  var i = H1(e), n = i && !yf(e);
  return (
    // ns-plain-safe
    (r ? (
      // c = flow-in
      i
    ) : i && e !== oO && e !== uO && e !== cO && e !== lO && e !== fO) && e !== Oy && !(t === mf && !n) || H1(t) && !yf(t) && e === Oy || t === mf && n
  );
}
function E6(e) {
  return qu(e) && e !== Mg && !yf(e) && e !== c6 && e !== d6 && e !== mf && e !== oO && e !== uO && e !== cO && e !== lO && e !== fO && e !== Oy && e !== a6 && e !== u6 && e !== n6 && e !== m6 && e !== l6 && e !== f6 && e !== o6 && e !== i6 && e !== s6 && e !== p6 && e !== h6;
}
function x6(e) {
  return !yf(e) && e !== mf;
}
function su(e, t) {
  var r = e.charCodeAt(t), i;
  return r >= 55296 && r <= 56319 && t + 1 < e.length && (i = e.charCodeAt(t + 1), i >= 56320 && i <= 57343) ? (r - 55296) * 1024 + i - 56320 + 65536 : r;
}
function dO(e) {
  var t = /^\n* /;
  return t.test(e);
}
var pO = 1, Sy = 2, hO = 3, mO = 4, qa = 5;
function O6(e, t, r, i, n, s, a, u) {
  var c, l = 0, d = null, p = !1, h = !1, v = i !== -1, y = -1, g = E6(su(e, 0)) && x6(su(e, e.length - 1));
  if (t || a)
    for (c = 0; c < e.length; l >= 65536 ? c += 2 : c++) {
      if (l = su(e, c), !qu(l))
        return qa;
      g = g && G1(l, d, u), d = l;
    }
  else {
    for (c = 0; c < e.length; l >= 65536 ? c += 2 : c++) {
      if (l = su(e, c), l === Du)
        p = !0, v && (h = h || // Foldable line = too long, and not more-indented.
        c - y - 1 > i && e[y + 1] !== " ", y = c);
      else if (!qu(l))
        return qa;
      g = g && G1(l, d, u), d = l;
    }
    h = h || v && c - y - 1 > i && e[y + 1] !== " ";
  }
  return !p && !h ? g && !a && !n(e) ? pO : s === Lu ? qa : Sy : r > 9 && dO(e) ? qa : a ? s === Lu ? qa : Sy : h ? mO : hO;
}
function P6(e, t, r, i, n) {
  e.dump = function() {
    if (t.length === 0)
      return e.quotingType === Lu ? '""' : "''";
    if (!e.noCompatMode && (y6.indexOf(t) !== -1 || g6.test(t)))
      return e.quotingType === Lu ? '"' + t + '"' : "'" + t + "'";
    var s = e.indent * Math.max(1, r), a = e.lineWidth === -1 ? -1 : Math.max(Math.min(e.lineWidth, 40), e.lineWidth - s), u = i || e.flowLevel > -1 && r >= e.flowLevel;
    function c(l) {
      return $6(e, l);
    }
    switch (O6(
      t,
      u,
      e.indent,
      a,
      c,
      e.quotingType,
      e.forceQuotes && !i,
      n
    )) {
      case pO:
        return t;
      case Sy:
        return "'" + t.replace(/'/g, "''") + "'";
      case hO:
        return "|" + K1(t, e.indent) + Y1(W1(t, s));
      case mO:
        return ">" + K1(t, e.indent) + Y1(W1(S6(t, a), s));
      case qa:
        return '"' + A6(t) + '"';
      default:
        throw new rc("impossible error: invalid scalar style");
    }
  }();
}
function K1(e, t) {
  var r = dO(e) ? String(t) : "", i = e[e.length - 1] === `
`, n = i && (e[e.length - 2] === `
` || e === `
`), s = n ? "+" : i ? "" : "-";
  return r + s + `
`;
}
function Y1(e) {
  return e[e.length - 1] === `
` ? e.slice(0, -1) : e;
}
function S6(e, t) {
  for (var r = /(\n+)([^\n]*)/g, i = function() {
    var l = e.indexOf(`
`);
    return l = l !== -1 ? l : e.length, r.lastIndex = l, J1(e.slice(0, l), t);
  }(), n = e[0] === `
` || e[0] === " ", s, a; a = r.exec(e); ) {
    var u = a[1], c = a[2];
    s = c[0] === " ", i += u + (!n && !s && c !== "" ? `
` : "") + J1(c, t), n = s;
  }
  return i;
}
function J1(e, t) {
  if (e === "" || e[0] === " ")
    return e;
  for (var r = / [^ ]/g, i, n = 0, s, a = 0, u = 0, c = ""; i = r.exec(e); )
    u = i.index, u - n > t && (s = a > n ? a : u, c += `
` + e.slice(n, s), n = s + 1), a = u;
  return c += `
`, e.length - n > t && a > n ? c += e.slice(n, a) + `
` + e.slice(a + 1) : c += e.slice(n), c.slice(1);
}
function A6(e) {
  for (var t = "", r = 0, i, n = 0; n < e.length; r >= 65536 ? n += 2 : n++)
    r = su(e, n), i = Rr[r], !i && qu(r) ? (t += e[n], r >= 65536 && (t += e[n + 1])) : t += i || b6(r);
  return t;
}
function C6(e, t, r) {
  var i = "", n = e.tag, s, a, u;
  for (s = 0, a = r.length; s < a; s += 1)
    u = r[s], e.replacer && (u = e.replacer.call(r, String(s), u)), (Ri(e, t, u, !1, !1) || typeof u > "u" && Ri(e, t, null, !1, !1)) && (i !== "" && (i += "," + (e.condenseFlow ? "" : " ")), i += e.dump);
  e.tag = n, e.dump = "[" + i + "]";
}
function X1(e, t, r, i) {
  var n = "", s = e.tag, a, u, c;
  for (a = 0, u = r.length; a < u; a += 1)
    c = r[a], e.replacer && (c = e.replacer.call(r, String(a), c)), (Ri(e, t + 1, c, !0, !0, !1, !0) || typeof c > "u" && Ri(e, t + 1, null, !0, !0, !1, !0)) && ((!i || n !== "") && (n += Py(e, t)), e.dump && Du === e.dump.charCodeAt(0) ? n += "-" : n += "- ", n += e.dump);
  e.tag = s, e.dump = n || "[]";
}
function R6(e, t, r) {
  var i = "", n = e.tag, s = Object.keys(r), a, u, c, l, d;
  for (a = 0, u = s.length; a < u; a += 1)
    d = "", i !== "" && (d += ", "), e.condenseFlow && (d += '"'), c = s[a], l = r[c], e.replacer && (l = e.replacer.call(r, c, l)), Ri(e, t, c, !1, !1) && (e.dump.length > 1024 && (d += "? "), d += e.dump + (e.condenseFlow ? '"' : "") + ":" + (e.condenseFlow ? "" : " "), Ri(e, t, l, !1, !1) && (d += e.dump, i += d));
  e.tag = n, e.dump = "{" + i + "}";
}
function T6(e, t, r, i) {
  var n = "", s = e.tag, a = Object.keys(r), u, c, l, d, p, h;
  if (e.sortKeys === !0)
    a.sort();
  else if (typeof e.sortKeys == "function")
    a.sort(e.sortKeys);
  else if (e.sortKeys)
    throw new rc("sortKeys must be a boolean or a function");
  for (u = 0, c = a.length; u < c; u += 1)
    h = "", (!i || n !== "") && (h += Py(e, t)), l = a[u], d = r[l], e.replacer && (d = e.replacer.call(r, l, d)), Ri(e, t + 1, l, !0, !0, !0) && (p = e.tag !== null && e.tag !== "?" || e.dump && e.dump.length > 1024, p && (e.dump && Du === e.dump.charCodeAt(0) ? h += "?" : h += "? "), h += e.dump, p && (h += Py(e, t)), Ri(e, t + 1, d, !0, p) && (e.dump && Du === e.dump.charCodeAt(0) ? h += ":" : h += ": ", h += e.dump, n += h));
  e.tag = s, e.dump = n || "{}";
}
function Q1(e, t, r) {
  var i, n, s, a, u, c;
  for (n = r ? e.explicitTypes : e.implicitTypes, s = 0, a = n.length; s < a; s += 1)
    if (u = n[s], (u.instanceOf || u.predicate) && (!u.instanceOf || typeof t == "object" && t instanceof u.instanceOf) && (!u.predicate || u.predicate(t))) {
      if (r ? u.multi && u.representName ? e.tag = u.representName(t) : e.tag = u.tag : e.tag = "?", u.represent) {
        if (c = e.styleMap[u.tag] || u.defaultStyle, sO.call(u.represent) === "[object Function]")
          i = u.represent(t, c);
        else if (aO.call(u.represent, c))
          i = u.represent[c](t, c);
        else
          throw new rc("!<" + u.tag + '> tag resolver accepts not "' + c + '" style');
        e.dump = i;
      }
      return !0;
    }
  return !1;
}
function Ri(e, t, r, i, n, s, a) {
  e.tag = null, e.dump = r, Q1(e, r, !1) || Q1(e, r, !0);
  var u = sO.call(e.dump), c = i, l;
  i && (i = e.flowLevel < 0 || e.flowLevel > t);
  var d = u === "[object Object]" || u === "[object Array]", p, h;
  if (d && (p = e.duplicates.indexOf(r), h = p !== -1), (e.tag !== null && e.tag !== "?" || h || e.indent !== 2 && t > 0) && (n = !1), h && e.usedDuplicates[p])
    e.dump = "*ref_" + p;
  else {
    if (d && h && !e.usedDuplicates[p] && (e.usedDuplicates[p] = !0), u === "[object Object]")
      i && Object.keys(e.dump).length !== 0 ? (T6(e, t, e.dump, n), h && (e.dump = "&ref_" + p + e.dump)) : (R6(e, t, e.dump), h && (e.dump = "&ref_" + p + " " + e.dump));
    else if (u === "[object Array]")
      i && e.dump.length !== 0 ? (e.noArrayIndent && !a && t > 0 ? X1(e, t - 1, e.dump, n) : X1(e, t, e.dump, n), h && (e.dump = "&ref_" + p + e.dump)) : (C6(e, t, e.dump), h && (e.dump = "&ref_" + p + " " + e.dump));
    else if (u === "[object String]")
      e.tag !== "?" && P6(e, e.dump, t, s, c);
    else {
      if (u === "[object Undefined]")
        return !1;
      if (e.skipInvalid)
        return !1;
      throw new rc("unacceptable kind of an object to dump " + u);
    }
    e.tag !== null && e.tag !== "?" && (l = encodeURI(
      e.tag[0] === "!" ? e.tag.slice(1) : e.tag
    ).replace(/!/g, "%21"), e.tag[0] === "!" ? l = "!" + l : l.slice(0, 18) === "tag:yaml.org,2002:" ? l = "!!" + l.slice(18) : l = "!<" + l + ">", e.dump = l + " " + e.dump);
  }
  return !0;
}
function I6(e, t) {
  var r = [], i = [], n, s;
  for (Ay(e, r, i), n = 0, s = i.length; n < s; n += 1)
    t.duplicates.push(r[i[n]]);
  t.usedDuplicates = new Array(s);
}
function Ay(e, t, r) {
  var i, n, s;
  if (e !== null && typeof e == "object")
    if (n = t.indexOf(e), n !== -1)
      r.indexOf(n) === -1 && r.push(n);
    else if (t.push(e), Array.isArray(e))
      for (n = 0, s = e.length; n < s; n += 1)
        Ay(e[n], t, r);
    else
      for (i = Object.keys(e), n = 0, s = i.length; n < s; n += 1)
        Ay(e[i[n]], t, r);
}
function j6(e, t) {
  t = t || {};
  var r = new w6(t);
  r.noRefs || I6(e, r);
  var i = e;
  return r.replacer && (i = r.replacer.call({ "": i }, "", i)), Ri(r, 0, i, !0, !0) ? r.dump + `
` : "";
}
iO.dump = j6;
var yO = Rg, k6 = iO;
function Ng(e, t) {
  return function() {
    throw new Error("Function yaml." + e + " is removed in js-yaml 4. Use yaml." + t + " instead, which is now safe by default.");
  };
}
_r.Type = Fr;
_r.Schema = Cx;
_r.FAILSAFE_SCHEMA = jx;
_r.JSON_SCHEMA = qx;
_r.CORE_SCHEMA = Fx;
_r.DEFAULT_SCHEMA = Ig;
_r.load = yO.load;
_r.loadAll = yO.loadAll;
_r.dump = k6.dump;
_r.YAMLException = tc;
_r.types = {
  binary: zx,
  float: Lx,
  map: Ix,
  null: kx,
  pairs: Hx,
  set: Gx,
  timestamp: Vx,
  bool: Mx,
  int: Nx,
  merge: Zx,
  omap: Wx,
  seq: Tx,
  str: Rx
};
_r.safeLoad = Ng("safeLoad", "load");
_r.safeLoadAll = Ng("safeLoadAll", "loadAll");
_r.safeDump = Ng("safeDump", "dump");
const M6 = _r, { JSON_SCHEMA: N6 } = _r, { ParserError: D6 } = or;
var L6 = {
  /**
   * The order that this parser will run, in relation to other parsers.
   *
   * @type {number}
   */
  order: 200,
  /**
   * Whether to allow "empty" files. This includes zero-byte files, as well as empty JSON objects.
   *
   * @type {boolean}
   */
  allowEmpty: !0,
  /**
   * Determines whether this parser can parse a given file reference.
   * Parsers that match will be tried, in order, until one successfully parses the file.
   * Parsers that don't match will be skipped, UNLESS none of the parsers match, in which case
   * every parser will be tried.
   *
   * @type {RegExp|string[]|function}
   */
  canParse: [".yaml", ".yml", ".json"],
  // JSON is valid YAML
  /**
   * Parses the given file as YAML
   *
   * @param {object} file           - An object containing information about the referenced file
   * @param {string} file.url       - The full URL of the referenced file
   * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
   * @returns {Promise}
   */
  // eslint-disable-next-line require-await
  async parse(e) {
    let t = e.data;
    if (Me.Buffer.isBuffer(t) && (t = t.toString()), typeof t == "string")
      try {
        return M6.load(t, { schema: N6 });
      } catch (r) {
        throw new D6(r.message, e.url);
      }
    return t;
  }
}, q6 = null;
const F6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: q6
}, Symbol.toStringTag, { value: "Module" })), gO = /* @__PURE__ */ kf(F6), U6 = gO, { ono: zp } = Nn, { ResolverError: Wp } = or, e_ = gn;
var B6 = {
  /**
   * The order that this resolver will run, in relation to other resolvers.
   *
   * @type {number}
   */
  order: 100,
  /**
   * Determines whether this resolver can read a given file reference.
   * Resolvers that return true will be tried, in order, until one successfully resolves the file.
   * Resolvers that return false will not be given a chance to resolve the file.
   *
   * @param {object} file           - An object containing information about the referenced file
   * @param {string} file.url       - The full URL of the referenced file
   * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
   * @returns {boolean}
   */
  canRead(e) {
    return e_.isFileSystemPath(e.url);
  },
  /**
   * Reads the given file and returns its raw contents as a Buffer.
   *
   * @param {object} file           - An object containing information about the referenced file
   * @param {string} file.url       - The full URL of the referenced file
   * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
   * @returns {Promise<Buffer>}
   */
  read(e) {
    return new Promise((t, r) => {
      let i;
      try {
        i = e_.toFileSystemPath(e.url);
      } catch (n) {
        r(new Wp(zp.uri(n, `Malformed URI: ${e.url}`), e.url));
      }
      try {
        U6.readFile(i, (n, s) => {
          n ? r(new Wp(zp(n, `Error opening file "${i}"`), i)) : t(s);
        });
      } catch (n) {
        r(new Wp(zp(n, `Error opening file "${i}"`), i));
      }
    });
  }
}, Hf = {}, vO = { exports: {} }, Dg = {};
(function(e) {
  e.fetch = n(rt.fetch) && n(rt.ReadableStream), e.writableStream = n(rt.WritableStream), e.abortController = n(rt.AbortController);
  var t;
  function r() {
    if (t !== void 0)
      return t;
    if (rt.XMLHttpRequest) {
      t = new rt.XMLHttpRequest();
      try {
        t.open("GET", rt.XDomainRequest ? "/" : "https://example.com");
      } catch {
        t = null;
      }
    } else
      t = null;
    return t;
  }
  function i(s) {
    var a = r();
    if (!a)
      return !1;
    try {
      return a.responseType = s, a.responseType === s;
    } catch {
    }
    return !1;
  }
  e.arraybuffer = e.fetch || i("arraybuffer"), e.msstream = !e.fetch && i("ms-stream"), e.mozchunkedarraybuffer = !e.fetch && i("moz-chunked-arraybuffer"), e.overrideMimeType = e.fetch || (r() ? n(r().overrideMimeType) : !1);
  function n(s) {
    return typeof s == "function";
  }
  t = null;
})(Dg);
var Gf = {}, Cy = { exports: {} }, bO = wg.EventEmitter, Hp, t_;
function V6() {
  if (t_)
    return Hp;
  t_ = 1;
  function e(y, g) {
    var _ = Object.keys(y);
    if (Object.getOwnPropertySymbols) {
      var m = Object.getOwnPropertySymbols(y);
      g && (m = m.filter(function(w) {
        return Object.getOwnPropertyDescriptor(y, w).enumerable;
      })), _.push.apply(_, m);
    }
    return _;
  }
  function t(y) {
    for (var g = 1; g < arguments.length; g++) {
      var _ = arguments[g] != null ? arguments[g] : {};
      g % 2 ? e(Object(_), !0).forEach(function(m) {
        r(y, m, _[m]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(y, Object.getOwnPropertyDescriptors(_)) : e(Object(_)).forEach(function(m) {
        Object.defineProperty(y, m, Object.getOwnPropertyDescriptor(_, m));
      });
    }
    return y;
  }
  function r(y, g, _) {
    return g = a(g), g in y ? Object.defineProperty(y, g, { value: _, enumerable: !0, configurable: !0, writable: !0 }) : y[g] = _, y;
  }
  function i(y, g) {
    if (!(y instanceof g))
      throw new TypeError("Cannot call a class as a function");
  }
  function n(y, g) {
    for (var _ = 0; _ < g.length; _++) {
      var m = g[_];
      m.enumerable = m.enumerable || !1, m.configurable = !0, "value" in m && (m.writable = !0), Object.defineProperty(y, a(m.key), m);
    }
  }
  function s(y, g, _) {
    return g && n(y.prototype, g), _ && n(y, _), Object.defineProperty(y, "prototype", { writable: !1 }), y;
  }
  function a(y) {
    var g = u(y, "string");
    return typeof g == "symbol" ? g : String(g);
  }
  function u(y, g) {
    if (typeof y != "object" || y === null)
      return y;
    var _ = y[Symbol.toPrimitive];
    if (_ !== void 0) {
      var m = _.call(y, g || "default");
      if (typeof m != "object")
        return m;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (g === "string" ? String : Number)(y);
  }
  var c = lo, l = c.Buffer, d = fo, p = d.inspect, h = p && p.custom || "inspect";
  function v(y, g, _) {
    l.prototype.copy.call(y, g, _);
  }
  return Hp = /* @__PURE__ */ function() {
    function y() {
      i(this, y), this.head = null, this.tail = null, this.length = 0;
    }
    return s(y, [{
      key: "push",
      value: function(_) {
        var m = {
          data: _,
          next: null
        };
        this.length > 0 ? this.tail.next = m : this.head = m, this.tail = m, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(_) {
        var m = {
          data: _,
          next: this.head
        };
        this.length === 0 && (this.tail = m), this.head = m, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var _ = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, _;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(_) {
        if (this.length === 0)
          return "";
        for (var m = this.head, w = "" + m.data; m = m.next; )
          w += _ + m.data;
        return w;
      }
    }, {
      key: "concat",
      value: function(_) {
        if (this.length === 0)
          return l.alloc(0);
        for (var m = l.allocUnsafe(_ >>> 0), w = this.head, $ = 0; w; )
          v(w.data, m, $), $ += w.data.length, w = w.next;
        return m;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(_, m) {
        var w;
        return _ < this.head.data.length ? (w = this.head.data.slice(0, _), this.head.data = this.head.data.slice(_)) : _ === this.head.data.length ? w = this.shift() : w = m ? this._getString(_) : this._getBuffer(_), w;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(_) {
        var m = this.head, w = 1, $ = m.data;
        for (_ -= $.length; m = m.next; ) {
          var E = m.data, A = _ > E.length ? E.length : _;
          if (A === E.length ? $ += E : $ += E.slice(0, _), _ -= A, _ === 0) {
            A === E.length ? (++w, m.next ? this.head = m.next : this.head = this.tail = null) : (this.head = m, m.data = E.slice(A));
            break;
          }
          ++w;
        }
        return this.length -= w, $;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(_) {
        var m = l.allocUnsafe(_), w = this.head, $ = 1;
        for (w.data.copy(m), _ -= w.data.length; w = w.next; ) {
          var E = w.data, A = _ > E.length ? E.length : _;
          if (E.copy(m, m.length - _, 0, A), _ -= A, _ === 0) {
            A === E.length ? (++$, w.next ? this.head = w.next : this.head = this.tail = null) : (this.head = w, w.data = E.slice(A));
            break;
          }
          ++$;
        }
        return this.length -= $, m;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: h,
      value: function(_, m) {
        return p(this, t(t({}, m), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), y;
  }(), Hp;
}
function Z6(e, t) {
  var r = this, i = this._readableState && this._readableState.destroyed, n = this._writableState && this._writableState.destroyed;
  return i || n ? (t ? t(e) : e && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, Me.process.nextTick(Ry, this, e)) : Me.process.nextTick(Ry, this, e)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(e || null, function(s) {
    !t && s ? r._writableState ? r._writableState.errorEmitted ? Me.process.nextTick(jl, r) : (r._writableState.errorEmitted = !0, Me.process.nextTick(r_, r, s)) : Me.process.nextTick(r_, r, s) : t ? (Me.process.nextTick(jl, r), t(s)) : Me.process.nextTick(jl, r);
  }), this);
}
function r_(e, t) {
  Ry(e, t), jl(e);
}
function jl(e) {
  e._writableState && !e._writableState.emitClose || e._readableState && !e._readableState.emitClose || e.emit("close");
}
function z6() {
  this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
}
function Ry(e, t) {
  e.emit("error", t);
}
function W6(e, t) {
  var r = e._readableState, i = e._writableState;
  r && r.autoDestroy || i && i.autoDestroy ? e.destroy(t) : e.emit("error", t);
}
var _O = {
  destroy: Z6,
  undestroy: z6,
  errorOrDestroy: W6
}, ra = {};
function H6(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e.__proto__ = t;
}
var wO = {};
function vn(e, t, r) {
  r || (r = Error);
  function i(s, a, u) {
    return typeof t == "string" ? t : t(s, a, u);
  }
  var n = /* @__PURE__ */ function(s) {
    H6(a, s);
    function a(u, c, l) {
      return s.call(this, i(u, c, l)) || this;
    }
    return a;
  }(r);
  n.prototype.name = r.name, n.prototype.code = e, wO[e] = n;
}
function n_(e, t) {
  if (Array.isArray(e)) {
    var r = e.length;
    return e = e.map(function(i) {
      return String(i);
    }), r > 2 ? "one of ".concat(t, " ").concat(e.slice(0, r - 1).join(", "), ", or ") + e[r - 1] : r === 2 ? "one of ".concat(t, " ").concat(e[0], " or ").concat(e[1]) : "of ".concat(t, " ").concat(e[0]);
  } else
    return "of ".concat(t, " ").concat(String(e));
}
function G6(e, t, r) {
  return e.substr(!r || r < 0 ? 0 : +r, t.length) === t;
}
function K6(e, t, r) {
  return (r === void 0 || r > e.length) && (r = e.length), e.substring(r - t.length, r) === t;
}
function Y6(e, t, r) {
  return typeof r != "number" && (r = 0), r + t.length > e.length ? !1 : e.indexOf(t, r) !== -1;
}
vn("ERR_INVALID_OPT_VALUE", function(e, t) {
  return 'The value "' + t + '" is invalid for option "' + e + '"';
}, TypeError);
vn("ERR_INVALID_ARG_TYPE", function(e, t, r) {
  var i;
  typeof t == "string" && G6(t, "not ") ? (i = "must not be", t = t.replace(/^not /, "")) : i = "must be";
  var n;
  if (K6(e, " argument"))
    n = "The ".concat(e, " ").concat(i, " ").concat(n_(t, "type"));
  else {
    var s = Y6(e, ".") ? "property" : "argument";
    n = 'The "'.concat(e, '" ').concat(s, " ").concat(i, " ").concat(n_(t, "type"));
  }
  return n += ". Received type ".concat(typeof r), n;
}, TypeError);
vn("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
vn("ERR_METHOD_NOT_IMPLEMENTED", function(e) {
  return "The " + e + " method is not implemented";
});
vn("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
vn("ERR_STREAM_DESTROYED", function(e) {
  return "Cannot call " + e + " after a stream was destroyed";
});
vn("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
vn("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
vn("ERR_STREAM_WRITE_AFTER_END", "write after end");
vn("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
vn("ERR_UNKNOWN_ENCODING", function(e) {
  return "Unknown encoding: " + e;
}, TypeError);
vn("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
ra.codes = wO;
var J6 = ra.codes.ERR_INVALID_OPT_VALUE;
function X6(e, t, r) {
  return e.highWaterMark != null ? e.highWaterMark : t ? e[r] : null;
}
function Q6(e, t, r, i) {
  var n = X6(t, i, r);
  if (n != null) {
    if (!(isFinite(n) && Math.floor(n) === n) || n < 0) {
      var s = i ? r : "highWaterMark";
      throw new J6(s, n);
    }
    return Math.floor(n);
  }
  return e.objectMode ? 16 : 16 * 1024;
}
var $O = {
  getHighWaterMark: Q6
}, e4 = t4;
function t4(e, t) {
  if (Gp("noDeprecation"))
    return e;
  var r = !1;
  function i() {
    if (!r) {
      if (Gp("throwDeprecation"))
        throw new Error(t);
      Gp("traceDeprecation") ? console.trace(t) : console.warn(t), r = !0;
    }
    return e.apply(this, arguments);
  }
  return i;
}
function Gp(e) {
  try {
    if (!rt.localStorage)
      return !1;
  } catch {
    return !1;
  }
  var t = rt.localStorage[e];
  return t == null ? !1 : String(t).toLowerCase() === "true";
}
var Kp, i_;
function EO() {
  if (i_)
    return Kp;
  i_ = 1, Kp = D;
  function e(N) {
    var F = this;
    this.next = null, this.entry = null, this.finish = function() {
      q(F, N);
    };
  }
  var t;
  D.WritableState = R;
  var r = {
    deprecate: e4
  }, i = bO, n = lo.Buffer, s = (typeof rt < "u" ? rt : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function a(N) {
    return n.from(N);
  }
  function u(N) {
    return n.isBuffer(N) || N instanceof s;
  }
  var c = _O, l = $O, d = l.getHighWaterMark, p = ra.codes, h = p.ERR_INVALID_ARG_TYPE, v = p.ERR_METHOD_NOT_IMPLEMENTED, y = p.ERR_MULTIPLE_CALLBACK, g = p.ERR_STREAM_CANNOT_PIPE, _ = p.ERR_STREAM_DESTROYED, m = p.ERR_STREAM_NULL_VALUES, w = p.ERR_STREAM_WRITE_AFTER_END, $ = p.ERR_UNKNOWN_ENCODING, E = c.errorOrDestroy;
  ys(D, i);
  function A() {
  }
  function R(N, F, T) {
    t = t || ao(), N = N || {}, typeof T != "boolean" && (T = F instanceof t), this.objectMode = !!N.objectMode, T && (this.objectMode = this.objectMode || !!N.writableObjectMode), this.highWaterMark = d(this, N, "writableHighWaterMark", T), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var Z = N.decodeStrings === !1;
    this.decodeStrings = !Z, this.defaultEncoding = N.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(Y) {
      le(F, Y);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = N.emitClose !== !1, this.autoDestroy = !!N.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new e(this);
  }
  R.prototype.getBuffer = function() {
    for (var F = this.bufferedRequest, T = []; F; )
      T.push(F), F = F.next;
    return T;
  }, function() {
    try {
      Object.defineProperty(R.prototype, "buffer", {
        get: r.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var I;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (I = Function.prototype[Symbol.hasInstance], Object.defineProperty(D, Symbol.hasInstance, {
    value: function(F) {
      return I.call(this, F) ? !0 : this !== D ? !1 : F && F._writableState instanceof R;
    }
  })) : I = function(F) {
    return F instanceof this;
  };
  function D(N) {
    t = t || ao();
    var F = this instanceof t;
    if (!F && !I.call(D, this))
      return new D(N);
    this._writableState = new R(N, this, F), this.writable = !0, N && (typeof N.write == "function" && (this._write = N.write), typeof N.writev == "function" && (this._writev = N.writev), typeof N.destroy == "function" && (this._destroy = N.destroy), typeof N.final == "function" && (this._final = N.final)), i.call(this);
  }
  D.prototype.pipe = function() {
    E(this, new g());
  };
  function J(N, F) {
    var T = new w();
    E(N, T), Me.process.nextTick(F, T);
  }
  function ae(N, F, T, Z) {
    var Y;
    return T === null ? Y = new m() : typeof T != "string" && !F.objectMode && (Y = new h("chunk", ["string", "Buffer"], T)), Y ? (E(N, Y), Me.process.nextTick(Z, Y), !1) : !0;
  }
  D.prototype.write = function(N, F, T) {
    var Z = this._writableState, Y = !1, k = !Z.objectMode && u(N);
    return k && !n.isBuffer(N) && (N = a(N)), typeof F == "function" && (T = F, F = null), k ? F = "buffer" : F || (F = Z.defaultEncoding), typeof T != "function" && (T = A), Z.ending ? J(this, T) : (k || ae(this, Z, N, T)) && (Z.pendingcb++, Y = xe(this, Z, k, N, F, T)), Y;
  }, D.prototype.cork = function() {
    this._writableState.corked++;
  }, D.prototype.uncork = function() {
    var N = this._writableState;
    N.corked && (N.corked--, !N.writing && !N.corked && !N.bufferProcessing && N.bufferedRequest && _e(this, N));
  }, D.prototype.setDefaultEncoding = function(F) {
    if (typeof F == "string" && (F = F.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((F + "").toLowerCase()) > -1))
      throw new $(F);
    return this._writableState.defaultEncoding = F, this;
  }, Object.defineProperty(D.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function ye(N, F, T) {
    return !N.objectMode && N.decodeStrings !== !1 && typeof F == "string" && (F = n.from(F, T)), F;
  }
  Object.defineProperty(D.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function xe(N, F, T, Z, Y, k) {
    if (!T) {
      var U = ye(F, Z, Y);
      Z !== U && (T = !0, Y = "buffer", Z = U);
    }
    var pe = F.objectMode ? 1 : Z.length;
    F.length += pe;
    var we = F.length < F.highWaterMark;
    if (we || (F.needDrain = !0), F.writing || F.corked) {
      var He = F.lastBufferedRequest;
      F.lastBufferedRequest = {
        chunk: Z,
        encoding: Y,
        isBuf: T,
        callback: k,
        next: null
      }, He ? He.next = F.lastBufferedRequest : F.bufferedRequest = F.lastBufferedRequest, F.bufferedRequestCount += 1;
    } else
      je(N, F, !1, pe, Z, Y, k);
    return we;
  }
  function je(N, F, T, Z, Y, k, U) {
    F.writelen = Z, F.writecb = U, F.writing = !0, F.sync = !0, F.destroyed ? F.onwrite(new _("write")) : T ? N._writev(Y, F.onwrite) : N._write(Y, k, F.onwrite), F.sync = !1;
  }
  function re(N, F, T, Z, Y) {
    --F.pendingcb, T ? (Me.process.nextTick(Y, Z), Me.process.nextTick(z, N, F), N._writableState.errorEmitted = !0, E(N, Z)) : (Y(Z), N._writableState.errorEmitted = !0, E(N, Z), z(N, F));
  }
  function fe(N) {
    N.writing = !1, N.writecb = null, N.length -= N.writelen, N.writelen = 0;
  }
  function le(N, F) {
    var T = N._writableState, Z = T.sync, Y = T.writecb;
    if (typeof Y != "function")
      throw new y();
    if (fe(T), F)
      re(N, T, Z, F, Y);
    else {
      var k = ie(T) || N.destroyed;
      !k && !T.corked && !T.bufferProcessing && T.bufferedRequest && _e(N, T), Z ? Me.process.nextTick($e, N, T, k, Y) : $e(N, T, k, Y);
    }
  }
  function $e(N, F, T, Z) {
    T || Ae(N, F), F.pendingcb--, Z(), z(N, F);
  }
  function Ae(N, F) {
    F.length === 0 && F.needDrain && (F.needDrain = !1, N.emit("drain"));
  }
  function _e(N, F) {
    F.bufferProcessing = !0;
    var T = F.bufferedRequest;
    if (N._writev && T && T.next) {
      var Z = F.bufferedRequestCount, Y = new Array(Z), k = F.corkedRequestsFree;
      k.entry = T;
      for (var U = 0, pe = !0; T; )
        Y[U] = T, T.isBuf || (pe = !1), T = T.next, U += 1;
      Y.allBuffers = pe, je(N, F, !0, F.length, Y, "", k.finish), F.pendingcb++, F.lastBufferedRequest = null, k.next ? (F.corkedRequestsFree = k.next, k.next = null) : F.corkedRequestsFree = new e(F), F.bufferedRequestCount = 0;
    } else {
      for (; T; ) {
        var we = T.chunk, He = T.encoding, Fe = T.callback, Ge = F.objectMode ? 1 : we.length;
        if (je(N, F, !1, Ge, we, He, Fe), T = T.next, F.bufferedRequestCount--, F.writing)
          break;
      }
      T === null && (F.lastBufferedRequest = null);
    }
    F.bufferedRequest = T, F.bufferProcessing = !1;
  }
  D.prototype._write = function(N, F, T) {
    T(new v("_write()"));
  }, D.prototype._writev = null, D.prototype.end = function(N, F, T) {
    var Z = this._writableState;
    return typeof N == "function" ? (T = N, N = null, F = null) : typeof F == "function" && (T = F, F = null), N != null && this.write(N, F), Z.corked && (Z.corked = 1, this.uncork()), Z.ending || C(this, Z, T), this;
  }, Object.defineProperty(D.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function ie(N) {
    return N.ending && N.length === 0 && N.bufferedRequest === null && !N.finished && !N.writing;
  }
  function K(N, F) {
    N._final(function(T) {
      F.pendingcb--, T && E(N, T), F.prefinished = !0, N.emit("prefinish"), z(N, F);
    });
  }
  function V(N, F) {
    !F.prefinished && !F.finalCalled && (typeof N._final == "function" && !F.destroyed ? (F.pendingcb++, F.finalCalled = !0, Me.process.nextTick(K, N, F)) : (F.prefinished = !0, N.emit("prefinish")));
  }
  function z(N, F) {
    var T = ie(F);
    if (T && (V(N, F), F.pendingcb === 0 && (F.finished = !0, N.emit("finish"), F.autoDestroy))) {
      var Z = N._readableState;
      (!Z || Z.autoDestroy && Z.endEmitted) && N.destroy();
    }
    return T;
  }
  function C(N, F, T) {
    F.ending = !0, z(N, F), T && (F.finished ? Me.process.nextTick(T) : N.once("finish", T)), F.ended = !0, N.writable = !1;
  }
  function q(N, F, T) {
    var Z = N.entry;
    for (N.entry = null; Z; ) {
      var Y = Z.callback;
      F.pendingcb--, Y(T), Z = Z.next;
    }
    F.corkedRequestsFree.next = N;
  }
  return Object.defineProperty(D.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(F) {
      this._writableState && (this._writableState.destroyed = F);
    }
  }), D.prototype.destroy = c.destroy, D.prototype._undestroy = c.undestroy, D.prototype._destroy = function(N, F) {
    F(N);
  }, Kp;
}
var Yp, s_;
function ao() {
  if (s_)
    return Yp;
  s_ = 1;
  var e = Object.keys || function(l) {
    var d = [];
    for (var p in l)
      d.push(p);
    return d;
  };
  Yp = a;
  var t = OO(), r = EO();
  ys(a, t);
  for (var i = e(r.prototype), n = 0; n < i.length; n++) {
    var s = i[n];
    a.prototype[s] || (a.prototype[s] = r.prototype[s]);
  }
  function a(l) {
    if (!(this instanceof a))
      return new a(l);
    t.call(this, l), r.call(this, l), this.allowHalfOpen = !0, l && (l.readable === !1 && (this.readable = !1), l.writable === !1 && (this.writable = !1), l.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", u)));
  }
  Object.defineProperty(a.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(a.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(a.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function u() {
    this._writableState.ended || Me.process.nextTick(c, this);
  }
  function c(l) {
    l.end();
  }
  return Object.defineProperty(a.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(d) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = d, this._writableState.destroyed = d);
    }
  }), Yp;
}
var Jp = {}, el = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var a_;
function r4() {
  return a_ || (a_ = 1, function(e, t) {
    var r = lo, i = r.Buffer;
    function n(a, u) {
      for (var c in a)
        u[c] = a[c];
    }
    i.from && i.alloc && i.allocUnsafe && i.allocUnsafeSlow ? e.exports = r : (n(r, t), t.Buffer = s);
    function s(a, u, c) {
      return i(a, u, c);
    }
    s.prototype = Object.create(i.prototype), n(i, s), s.from = function(a, u, c) {
      if (typeof a == "number")
        throw new TypeError("Argument must not be a number");
      return i(a, u, c);
    }, s.alloc = function(a, u, c) {
      if (typeof a != "number")
        throw new TypeError("Argument must be a number");
      var l = i(a);
      return u !== void 0 ? typeof c == "string" ? l.fill(u, c) : l.fill(u) : l.fill(0), l;
    }, s.allocUnsafe = function(a) {
      if (typeof a != "number")
        throw new TypeError("Argument must be a number");
      return i(a);
    }, s.allocUnsafeSlow = function(a) {
      if (typeof a != "number")
        throw new TypeError("Argument must be a number");
      return r.SlowBuffer(a);
    };
  }(el, el.exports)), el.exports;
}
var o_;
function u_() {
  if (o_)
    return Jp;
  o_ = 1;
  var e = r4().Buffer, t = e.isEncoding || function(m) {
    switch (m = "" + m, m && m.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return !0;
      default:
        return !1;
    }
  };
  function r(m) {
    if (!m)
      return "utf8";
    for (var w; ; )
      switch (m) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return m;
        default:
          if (w)
            return;
          m = ("" + m).toLowerCase(), w = !0;
      }
  }
  function i(m) {
    var w = r(m);
    if (typeof w != "string" && (e.isEncoding === t || !t(m)))
      throw new Error("Unknown encoding: " + m);
    return w || m;
  }
  Jp.StringDecoder = n;
  function n(m) {
    this.encoding = i(m);
    var w;
    switch (this.encoding) {
      case "utf16le":
        this.text = p, this.end = h, w = 4;
        break;
      case "utf8":
        this.fillLast = c, w = 4;
        break;
      case "base64":
        this.text = v, this.end = y, w = 3;
        break;
      default:
        this.write = g, this.end = _;
        return;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = e.allocUnsafe(w);
  }
  n.prototype.write = function(m) {
    if (m.length === 0)
      return "";
    var w, $;
    if (this.lastNeed) {
      if (w = this.fillLast(m), w === void 0)
        return "";
      $ = this.lastNeed, this.lastNeed = 0;
    } else
      $ = 0;
    return $ < m.length ? w ? w + this.text(m, $) : this.text(m, $) : w || "";
  }, n.prototype.end = d, n.prototype.text = l, n.prototype.fillLast = function(m) {
    if (this.lastNeed <= m.length)
      return m.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    m.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, m.length), this.lastNeed -= m.length;
  };
  function s(m) {
    return m <= 127 ? 0 : m >> 5 === 6 ? 2 : m >> 4 === 14 ? 3 : m >> 3 === 30 ? 4 : m >> 6 === 2 ? -1 : -2;
  }
  function a(m, w, $) {
    var E = w.length - 1;
    if (E < $)
      return 0;
    var A = s(w[E]);
    return A >= 0 ? (A > 0 && (m.lastNeed = A - 1), A) : --E < $ || A === -2 ? 0 : (A = s(w[E]), A >= 0 ? (A > 0 && (m.lastNeed = A - 2), A) : --E < $ || A === -2 ? 0 : (A = s(w[E]), A >= 0 ? (A > 0 && (A === 2 ? A = 0 : m.lastNeed = A - 3), A) : 0));
  }
  function u(m, w, $) {
    if ((w[0] & 192) !== 128)
      return m.lastNeed = 0, "�";
    if (m.lastNeed > 1 && w.length > 1) {
      if ((w[1] & 192) !== 128)
        return m.lastNeed = 1, "�";
      if (m.lastNeed > 2 && w.length > 2 && (w[2] & 192) !== 128)
        return m.lastNeed = 2, "�";
    }
  }
  function c(m) {
    var w = this.lastTotal - this.lastNeed, $ = u(this, m);
    if ($ !== void 0)
      return $;
    if (this.lastNeed <= m.length)
      return m.copy(this.lastChar, w, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    m.copy(this.lastChar, w, 0, m.length), this.lastNeed -= m.length;
  }
  function l(m, w) {
    var $ = a(this, m, w);
    if (!this.lastNeed)
      return m.toString("utf8", w);
    this.lastTotal = $;
    var E = m.length - ($ - this.lastNeed);
    return m.copy(this.lastChar, 0, E), m.toString("utf8", w, E);
  }
  function d(m) {
    var w = m && m.length ? this.write(m) : "";
    return this.lastNeed ? w + "�" : w;
  }
  function p(m, w) {
    if ((m.length - w) % 2 === 0) {
      var $ = m.toString("utf16le", w);
      if ($) {
        var E = $.charCodeAt($.length - 1);
        if (E >= 55296 && E <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = m[m.length - 2], this.lastChar[1] = m[m.length - 1], $.slice(0, -1);
      }
      return $;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = m[m.length - 1], m.toString("utf16le", w, m.length - 1);
  }
  function h(m) {
    var w = m && m.length ? this.write(m) : "";
    if (this.lastNeed) {
      var $ = this.lastTotal - this.lastNeed;
      return w + this.lastChar.toString("utf16le", 0, $);
    }
    return w;
  }
  function v(m, w) {
    var $ = (m.length - w) % 3;
    return $ === 0 ? m.toString("base64", w) : (this.lastNeed = 3 - $, this.lastTotal = 3, $ === 1 ? this.lastChar[0] = m[m.length - 1] : (this.lastChar[0] = m[m.length - 2], this.lastChar[1] = m[m.length - 1]), m.toString("base64", w, m.length - $));
  }
  function y(m) {
    var w = m && m.length ? this.write(m) : "";
    return this.lastNeed ? w + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : w;
  }
  function g(m) {
    return m.toString(this.encoding);
  }
  function _(m) {
    return m && m.length ? this.write(m) : "";
  }
  return Jp;
}
var c_ = ra.codes.ERR_STREAM_PREMATURE_CLOSE;
function n4(e) {
  var t = !1;
  return function() {
    if (!t) {
      t = !0;
      for (var r = arguments.length, i = new Array(r), n = 0; n < r; n++)
        i[n] = arguments[n];
      e.apply(this, i);
    }
  };
}
function i4() {
}
function s4(e) {
  return e.setHeader && typeof e.abort == "function";
}
function xO(e, t, r) {
  if (typeof t == "function")
    return xO(e, null, t);
  t || (t = {}), r = n4(r || i4);
  var i = t.readable || t.readable !== !1 && e.readable, n = t.writable || t.writable !== !1 && e.writable, s = function() {
    e.writable || u();
  }, a = e._writableState && e._writableState.finished, u = function() {
    n = !1, a = !0, i || r.call(e);
  }, c = e._readableState && e._readableState.endEmitted, l = function() {
    i = !1, c = !0, n || r.call(e);
  }, d = function(y) {
    r.call(e, y);
  }, p = function() {
    var y;
    if (i && !c)
      return (!e._readableState || !e._readableState.ended) && (y = new c_()), r.call(e, y);
    if (n && !a)
      return (!e._writableState || !e._writableState.ended) && (y = new c_()), r.call(e, y);
  }, h = function() {
    e.req.on("finish", u);
  };
  return s4(e) ? (e.on("complete", u), e.on("abort", p), e.req ? h() : e.on("request", h)) : n && !e._writableState && (e.on("end", s), e.on("close", s)), e.on("end", l), e.on("finish", u), t.error !== !1 && e.on("error", d), e.on("close", p), function() {
    e.removeListener("complete", u), e.removeListener("abort", p), e.removeListener("request", h), e.req && e.req.removeListener("finish", u), e.removeListener("end", s), e.removeListener("close", s), e.removeListener("finish", u), e.removeListener("end", l), e.removeListener("error", d), e.removeListener("close", p);
  };
}
var Lg = xO, Xp, l_;
function a4() {
  if (l_)
    return Xp;
  l_ = 1;
  var e;
  function t($, E, A) {
    return E = r(E), E in $ ? Object.defineProperty($, E, { value: A, enumerable: !0, configurable: !0, writable: !0 }) : $[E] = A, $;
  }
  function r($) {
    var E = i($, "string");
    return typeof E == "symbol" ? E : String(E);
  }
  function i($, E) {
    if (typeof $ != "object" || $ === null)
      return $;
    var A = $[Symbol.toPrimitive];
    if (A !== void 0) {
      var R = A.call($, E || "default");
      if (typeof R != "object")
        return R;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (E === "string" ? String : Number)($);
  }
  var n = Lg, s = Symbol("lastResolve"), a = Symbol("lastReject"), u = Symbol("error"), c = Symbol("ended"), l = Symbol("lastPromise"), d = Symbol("handlePromise"), p = Symbol("stream");
  function h($, E) {
    return {
      value: $,
      done: E
    };
  }
  function v($) {
    var E = $[s];
    if (E !== null) {
      var A = $[p].read();
      A !== null && ($[l] = null, $[s] = null, $[a] = null, E(h(A, !1)));
    }
  }
  function y($) {
    Me.process.nextTick(v, $);
  }
  function g($, E) {
    return function(A, R) {
      $.then(function() {
        if (E[c]) {
          A(h(void 0, !0));
          return;
        }
        E[d](A, R);
      }, R);
    };
  }
  var _ = Object.getPrototypeOf(function() {
  }), m = Object.setPrototypeOf((e = {
    get stream() {
      return this[p];
    },
    next: function() {
      var E = this, A = this[u];
      if (A !== null)
        return Promise.reject(A);
      if (this[c])
        return Promise.resolve(h(void 0, !0));
      if (this[p].destroyed)
        return new Promise(function(J, ae) {
          Me.process.nextTick(function() {
            E[u] ? ae(E[u]) : J(h(void 0, !0));
          });
        });
      var R = this[l], I;
      if (R)
        I = new Promise(g(R, this));
      else {
        var D = this[p].read();
        if (D !== null)
          return Promise.resolve(h(D, !1));
        I = new Promise(this[d]);
      }
      return this[l] = I, I;
    }
  }, t(e, Symbol.asyncIterator, function() {
    return this;
  }), t(e, "return", function() {
    var E = this;
    return new Promise(function(A, R) {
      E[p].destroy(null, function(I) {
        if (I) {
          R(I);
          return;
        }
        A(h(void 0, !0));
      });
    });
  }), e), _), w = function(E) {
    var A, R = Object.create(m, (A = {}, t(A, p, {
      value: E,
      writable: !0
    }), t(A, s, {
      value: null,
      writable: !0
    }), t(A, a, {
      value: null,
      writable: !0
    }), t(A, u, {
      value: null,
      writable: !0
    }), t(A, c, {
      value: E._readableState.endEmitted,
      writable: !0
    }), t(A, d, {
      value: function(D, J) {
        var ae = R[p].read();
        ae ? (R[l] = null, R[s] = null, R[a] = null, D(h(ae, !1))) : (R[s] = D, R[a] = J);
      },
      writable: !0
    }), A));
    return R[l] = null, n(E, function(I) {
      if (I && I.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var D = R[a];
        D !== null && (R[l] = null, R[s] = null, R[a] = null, D(I)), R[u] = I;
        return;
      }
      var J = R[s];
      J !== null && (R[l] = null, R[s] = null, R[a] = null, J(h(void 0, !0))), R[c] = !0;
    }), E.on("readable", y.bind(null, R)), R;
  };
  return Xp = w, Xp;
}
var Qp, f_;
function o4() {
  return f_ || (f_ = 1, Qp = function() {
    throw new Error("Readable.from is not available in the browser");
  }), Qp;
}
var eh, d_;
function OO() {
  if (d_)
    return eh;
  d_ = 1, eh = J;
  var e;
  J.ReadableState = D, wg.EventEmitter;
  var t = function(U, pe) {
    return U.listeners(pe).length;
  }, r = bO, i = lo.Buffer, n = (typeof rt < "u" ? rt : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function s(k) {
    return i.from(k);
  }
  function a(k) {
    return i.isBuffer(k) || k instanceof n;
  }
  var u = fo, c;
  u && u.debuglog ? c = u.debuglog("stream") : c = function() {
  };
  var l = V6(), d = _O, p = $O, h = p.getHighWaterMark, v = ra.codes, y = v.ERR_INVALID_ARG_TYPE, g = v.ERR_STREAM_PUSH_AFTER_EOF, _ = v.ERR_METHOD_NOT_IMPLEMENTED, m = v.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, w, $, E;
  ys(J, r);
  var A = d.errorOrDestroy, R = ["error", "close", "destroy", "pause", "resume"];
  function I(k, U, pe) {
    if (typeof k.prependListener == "function")
      return k.prependListener(U, pe);
    !k._events || !k._events[U] ? k.on(U, pe) : Array.isArray(k._events[U]) ? k._events[U].unshift(pe) : k._events[U] = [pe, k._events[U]];
  }
  function D(k, U, pe) {
    e = e || ao(), k = k || {}, typeof pe != "boolean" && (pe = U instanceof e), this.objectMode = !!k.objectMode, pe && (this.objectMode = this.objectMode || !!k.readableObjectMode), this.highWaterMark = h(this, k, "readableHighWaterMark", pe), this.buffer = new l(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = k.emitClose !== !1, this.autoDestroy = !!k.autoDestroy, this.destroyed = !1, this.defaultEncoding = k.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, k.encoding && (w || (w = u_().StringDecoder), this.decoder = new w(k.encoding), this.encoding = k.encoding);
  }
  function J(k) {
    if (e = e || ao(), !(this instanceof J))
      return new J(k);
    var U = this instanceof e;
    this._readableState = new D(k, this, U), this.readable = !0, k && (typeof k.read == "function" && (this._read = k.read), typeof k.destroy == "function" && (this._destroy = k.destroy)), r.call(this);
  }
  Object.defineProperty(J.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(U) {
      this._readableState && (this._readableState.destroyed = U);
    }
  }), J.prototype.destroy = d.destroy, J.prototype._undestroy = d.undestroy, J.prototype._destroy = function(k, U) {
    U(k);
  }, J.prototype.push = function(k, U) {
    var pe = this._readableState, we;
    return pe.objectMode ? we = !0 : typeof k == "string" && (U = U || pe.defaultEncoding, U !== pe.encoding && (k = i.from(k, U), U = ""), we = !0), ae(this, k, U, !1, we);
  }, J.prototype.unshift = function(k) {
    return ae(this, k, null, !0, !1);
  };
  function ae(k, U, pe, we, He) {
    c("readableAddChunk", U);
    var Fe = k._readableState;
    if (U === null)
      Fe.reading = !1, le(k, Fe);
    else {
      var Ge;
      if (He || (Ge = xe(Fe, U)), Ge)
        A(k, Ge);
      else if (Fe.objectMode || U && U.length > 0)
        if (typeof U != "string" && !Fe.objectMode && Object.getPrototypeOf(U) !== i.prototype && (U = s(U)), we)
          Fe.endEmitted ? A(k, new m()) : ye(k, Fe, U, !0);
        else if (Fe.ended)
          A(k, new g());
        else {
          if (Fe.destroyed)
            return !1;
          Fe.reading = !1, Fe.decoder && !pe ? (U = Fe.decoder.write(U), Fe.objectMode || U.length !== 0 ? ye(k, Fe, U, !1) : _e(k, Fe)) : ye(k, Fe, U, !1);
        }
      else
        we || (Fe.reading = !1, _e(k, Fe));
    }
    return !Fe.ended && (Fe.length < Fe.highWaterMark || Fe.length === 0);
  }
  function ye(k, U, pe, we) {
    U.flowing && U.length === 0 && !U.sync ? (U.awaitDrain = 0, k.emit("data", pe)) : (U.length += U.objectMode ? 1 : pe.length, we ? U.buffer.unshift(pe) : U.buffer.push(pe), U.needReadable && $e(k)), _e(k, U);
  }
  function xe(k, U) {
    var pe;
    return !a(U) && typeof U != "string" && U !== void 0 && !k.objectMode && (pe = new y("chunk", ["string", "Buffer", "Uint8Array"], U)), pe;
  }
  J.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, J.prototype.setEncoding = function(k) {
    w || (w = u_().StringDecoder);
    var U = new w(k);
    this._readableState.decoder = U, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var pe = this._readableState.buffer.head, we = ""; pe !== null; )
      we += U.write(pe.data), pe = pe.next;
    return this._readableState.buffer.clear(), we !== "" && this._readableState.buffer.push(we), this._readableState.length = we.length, this;
  };
  var je = 1073741824;
  function re(k) {
    return k >= je ? k = je : (k--, k |= k >>> 1, k |= k >>> 2, k |= k >>> 4, k |= k >>> 8, k |= k >>> 16, k++), k;
  }
  function fe(k, U) {
    return k <= 0 || U.length === 0 && U.ended ? 0 : U.objectMode ? 1 : k !== k ? U.flowing && U.length ? U.buffer.head.data.length : U.length : (k > U.highWaterMark && (U.highWaterMark = re(k)), k <= U.length ? k : U.ended ? U.length : (U.needReadable = !0, 0));
  }
  J.prototype.read = function(k) {
    c("read", k), k = parseInt(k, 10);
    var U = this._readableState, pe = k;
    if (k !== 0 && (U.emittedReadable = !1), k === 0 && U.needReadable && ((U.highWaterMark !== 0 ? U.length >= U.highWaterMark : U.length > 0) || U.ended))
      return c("read: emitReadable", U.length, U.ended), U.length === 0 && U.ended ? T(this) : $e(this), null;
    if (k = fe(k, U), k === 0 && U.ended)
      return U.length === 0 && T(this), null;
    var we = U.needReadable;
    c("need readable", we), (U.length === 0 || U.length - k < U.highWaterMark) && (we = !0, c("length less than watermark", we)), U.ended || U.reading ? (we = !1, c("reading or ended", we)) : we && (c("do read"), U.reading = !0, U.sync = !0, U.length === 0 && (U.needReadable = !0), this._read(U.highWaterMark), U.sync = !1, U.reading || (k = fe(pe, U)));
    var He;
    return k > 0 ? He = F(k, U) : He = null, He === null ? (U.needReadable = U.length <= U.highWaterMark, k = 0) : (U.length -= k, U.awaitDrain = 0), U.length === 0 && (U.ended || (U.needReadable = !0), pe !== k && U.ended && T(this)), He !== null && this.emit("data", He), He;
  };
  function le(k, U) {
    if (c("onEofChunk"), !U.ended) {
      if (U.decoder) {
        var pe = U.decoder.end();
        pe && pe.length && (U.buffer.push(pe), U.length += U.objectMode ? 1 : pe.length);
      }
      U.ended = !0, U.sync ? $e(k) : (U.needReadable = !1, U.emittedReadable || (U.emittedReadable = !0, Ae(k)));
    }
  }
  function $e(k) {
    var U = k._readableState;
    c("emitReadable", U.needReadable, U.emittedReadable), U.needReadable = !1, U.emittedReadable || (c("emitReadable", U.flowing), U.emittedReadable = !0, Me.process.nextTick(Ae, k));
  }
  function Ae(k) {
    var U = k._readableState;
    c("emitReadable_", U.destroyed, U.length, U.ended), !U.destroyed && (U.length || U.ended) && (k.emit("readable"), U.emittedReadable = !1), U.needReadable = !U.flowing && !U.ended && U.length <= U.highWaterMark, N(k);
  }
  function _e(k, U) {
    U.readingMore || (U.readingMore = !0, Me.process.nextTick(ie, k, U));
  }
  function ie(k, U) {
    for (; !U.reading && !U.ended && (U.length < U.highWaterMark || U.flowing && U.length === 0); ) {
      var pe = U.length;
      if (c("maybeReadMore read 0"), k.read(0), pe === U.length)
        break;
    }
    U.readingMore = !1;
  }
  J.prototype._read = function(k) {
    A(this, new _("_read()"));
  }, J.prototype.pipe = function(k, U) {
    var pe = this, we = this._readableState;
    switch (we.pipesCount) {
      case 0:
        we.pipes = k;
        break;
      case 1:
        we.pipes = [we.pipes, k];
        break;
      default:
        we.pipes.push(k);
        break;
    }
    we.pipesCount += 1, c("pipe count=%d opts=%j", we.pipesCount, U);
    var He = (!U || U.end !== !1) && k !== Me.process.stdout && k !== Me.process.stderr, Fe = He ? jt : qe;
    we.endEmitted ? Me.process.nextTick(Fe) : pe.once("end", Fe), k.on("unpipe", Ge);
    function Ge(L, x) {
      c("onunpipe"), L === pe && x && x.hasUnpiped === !1 && (x.hasUnpiped = !0, St());
    }
    function jt() {
      c("onend"), k.end();
    }
    var Ee = K(pe);
    k.on("drain", Ee);
    var Mt = !1;
    function St() {
      c("cleanup"), k.removeListener("close", at), k.removeListener("finish", mt), k.removeListener("drain", Ee), k.removeListener("error", Le), k.removeListener("unpipe", Ge), pe.removeListener("end", jt), pe.removeListener("end", qe), pe.removeListener("data", Ne), Mt = !0, we.awaitDrain && (!k._writableState || k._writableState.needDrain) && Ee();
    }
    pe.on("data", Ne);
    function Ne(L) {
      c("ondata");
      var x = k.write(L);
      c("dest.write", x), x === !1 && ((we.pipesCount === 1 && we.pipes === k || we.pipesCount > 1 && Y(we.pipes, k) !== -1) && !Mt && (c("false write response, pause", we.awaitDrain), we.awaitDrain++), pe.pause());
    }
    function Le(L) {
      c("onerror", L), qe(), k.removeListener("error", Le), t(k, "error") === 0 && A(k, L);
    }
    I(k, "error", Le);
    function at() {
      k.removeListener("finish", mt), qe();
    }
    k.once("close", at);
    function mt() {
      c("onfinish"), k.removeListener("close", at), qe();
    }
    k.once("finish", mt);
    function qe() {
      c("unpipe"), pe.unpipe(k);
    }
    return k.emit("pipe", pe), we.flowing || (c("pipe resume"), pe.resume()), k;
  };
  function K(k) {
    return function() {
      var pe = k._readableState;
      c("pipeOnDrain", pe.awaitDrain), pe.awaitDrain && pe.awaitDrain--, pe.awaitDrain === 0 && t(k, "data") && (pe.flowing = !0, N(k));
    };
  }
  J.prototype.unpipe = function(k) {
    var U = this._readableState, pe = {
      hasUnpiped: !1
    };
    if (U.pipesCount === 0)
      return this;
    if (U.pipesCount === 1)
      return k && k !== U.pipes ? this : (k || (k = U.pipes), U.pipes = null, U.pipesCount = 0, U.flowing = !1, k && k.emit("unpipe", this, pe), this);
    if (!k) {
      var we = U.pipes, He = U.pipesCount;
      U.pipes = null, U.pipesCount = 0, U.flowing = !1;
      for (var Fe = 0; Fe < He; Fe++)
        we[Fe].emit("unpipe", this, {
          hasUnpiped: !1
        });
      return this;
    }
    var Ge = Y(U.pipes, k);
    return Ge === -1 ? this : (U.pipes.splice(Ge, 1), U.pipesCount -= 1, U.pipesCount === 1 && (U.pipes = U.pipes[0]), k.emit("unpipe", this, pe), this);
  }, J.prototype.on = function(k, U) {
    var pe = r.prototype.on.call(this, k, U), we = this._readableState;
    return k === "data" ? (we.readableListening = this.listenerCount("readable") > 0, we.flowing !== !1 && this.resume()) : k === "readable" && !we.endEmitted && !we.readableListening && (we.readableListening = we.needReadable = !0, we.flowing = !1, we.emittedReadable = !1, c("on readable", we.length, we.reading), we.length ? $e(this) : we.reading || Me.process.nextTick(z, this)), pe;
  }, J.prototype.addListener = J.prototype.on, J.prototype.removeListener = function(k, U) {
    var pe = r.prototype.removeListener.call(this, k, U);
    return k === "readable" && Me.process.nextTick(V, this), pe;
  }, J.prototype.removeAllListeners = function(k) {
    var U = r.prototype.removeAllListeners.apply(this, arguments);
    return (k === "readable" || k === void 0) && Me.process.nextTick(V, this), U;
  };
  function V(k) {
    var U = k._readableState;
    U.readableListening = k.listenerCount("readable") > 0, U.resumeScheduled && !U.paused ? U.flowing = !0 : k.listenerCount("data") > 0 && k.resume();
  }
  function z(k) {
    c("readable nexttick read 0"), k.read(0);
  }
  J.prototype.resume = function() {
    var k = this._readableState;
    return k.flowing || (c("resume"), k.flowing = !k.readableListening, C(this, k)), k.paused = !1, this;
  };
  function C(k, U) {
    U.resumeScheduled || (U.resumeScheduled = !0, Me.process.nextTick(q, k, U));
  }
  function q(k, U) {
    c("resume", U.reading), U.reading || k.read(0), U.resumeScheduled = !1, k.emit("resume"), N(k), U.flowing && !U.reading && k.read(0);
  }
  J.prototype.pause = function() {
    return c("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (c("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function N(k) {
    var U = k._readableState;
    for (c("flow", U.flowing); U.flowing && k.read() !== null; )
      ;
  }
  J.prototype.wrap = function(k) {
    var U = this, pe = this._readableState, we = !1;
    k.on("end", function() {
      if (c("wrapped end"), pe.decoder && !pe.ended) {
        var Ge = pe.decoder.end();
        Ge && Ge.length && U.push(Ge);
      }
      U.push(null);
    }), k.on("data", function(Ge) {
      if (c("wrapped data"), pe.decoder && (Ge = pe.decoder.write(Ge)), !(pe.objectMode && Ge == null) && !(!pe.objectMode && (!Ge || !Ge.length))) {
        var jt = U.push(Ge);
        jt || (we = !0, k.pause());
      }
    });
    for (var He in k)
      this[He] === void 0 && typeof k[He] == "function" && (this[He] = function(jt) {
        return function() {
          return k[jt].apply(k, arguments);
        };
      }(He));
    for (var Fe = 0; Fe < R.length; Fe++)
      k.on(R[Fe], this.emit.bind(this, R[Fe]));
    return this._read = function(Ge) {
      c("wrapped _read", Ge), we && (we = !1, k.resume());
    }, this;
  }, typeof Symbol == "function" && (J.prototype[Symbol.asyncIterator] = function() {
    return $ === void 0 && ($ = a4()), $(this);
  }), Object.defineProperty(J.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(J.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(J.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(U) {
      this._readableState && (this._readableState.flowing = U);
    }
  }), J._fromList = F, Object.defineProperty(J.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function F(k, U) {
    if (U.length === 0)
      return null;
    var pe;
    return U.objectMode ? pe = U.buffer.shift() : !k || k >= U.length ? (U.decoder ? pe = U.buffer.join("") : U.buffer.length === 1 ? pe = U.buffer.first() : pe = U.buffer.concat(U.length), U.buffer.clear()) : pe = U.buffer.consume(k, U.decoder), pe;
  }
  function T(k) {
    var U = k._readableState;
    c("endReadable", U.endEmitted), U.endEmitted || (U.ended = !0, Me.process.nextTick(Z, U, k));
  }
  function Z(k, U) {
    if (c("endReadableNT", k.endEmitted, k.length), !k.endEmitted && k.length === 0 && (k.endEmitted = !0, U.readable = !1, U.emit("end"), k.autoDestroy)) {
      var pe = U._writableState;
      (!pe || pe.autoDestroy && pe.finished) && U.destroy();
    }
  }
  typeof Symbol == "function" && (J.from = function(k, U) {
    return E === void 0 && (E = o4()), E(J, k, U);
  });
  function Y(k, U) {
    for (var pe = 0, we = k.length; pe < we; pe++)
      if (k[pe] === U)
        return pe;
    return -1;
  }
  return eh;
}
var PO = Ti, Kf = ra.codes, u4 = Kf.ERR_METHOD_NOT_IMPLEMENTED, c4 = Kf.ERR_MULTIPLE_CALLBACK, l4 = Kf.ERR_TRANSFORM_ALREADY_TRANSFORMING, f4 = Kf.ERR_TRANSFORM_WITH_LENGTH_0, Yf = ao();
ys(Ti, Yf);
function d4(e, t) {
  var r = this._transformState;
  r.transforming = !1;
  var i = r.writecb;
  if (i === null)
    return this.emit("error", new c4());
  r.writechunk = null, r.writecb = null, t != null && this.push(t), i(e);
  var n = this._readableState;
  n.reading = !1, (n.needReadable || n.length < n.highWaterMark) && this._read(n.highWaterMark);
}
function Ti(e) {
  if (!(this instanceof Ti))
    return new Ti(e);
  Yf.call(this, e), this._transformState = {
    afterTransform: d4.bind(this),
    needTransform: !1,
    transforming: !1,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }, this._readableState.needReadable = !0, this._readableState.sync = !1, e && (typeof e.transform == "function" && (this._transform = e.transform), typeof e.flush == "function" && (this._flush = e.flush)), this.on("prefinish", p4);
}
function p4() {
  var e = this;
  typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(t, r) {
    p_(e, t, r);
  }) : p_(this, null, null);
}
Ti.prototype.push = function(e, t) {
  return this._transformState.needTransform = !1, Yf.prototype.push.call(this, e, t);
};
Ti.prototype._transform = function(e, t, r) {
  r(new u4("_transform()"));
};
Ti.prototype._write = function(e, t, r) {
  var i = this._transformState;
  if (i.writecb = r, i.writechunk = e, i.writeencoding = t, !i.transforming) {
    var n = this._readableState;
    (i.needTransform || n.needReadable || n.length < n.highWaterMark) && this._read(n.highWaterMark);
  }
};
Ti.prototype._read = function(e) {
  var t = this._transformState;
  t.writechunk !== null && !t.transforming ? (t.transforming = !0, this._transform(t.writechunk, t.writeencoding, t.afterTransform)) : t.needTransform = !0;
};
Ti.prototype._destroy = function(e, t) {
  Yf.prototype._destroy.call(this, e, function(r) {
    t(r);
  });
};
function p_(e, t, r) {
  if (t)
    return e.emit("error", t);
  if (r != null && e.push(r), e._writableState.length)
    throw new f4();
  if (e._transformState.transforming)
    throw new l4();
  return e.push(null);
}
var h4 = Fu, SO = PO;
ys(Fu, SO);
function Fu(e) {
  if (!(this instanceof Fu))
    return new Fu(e);
  SO.call(this, e);
}
Fu.prototype._transform = function(e, t, r) {
  r(null, e);
};
var th;
function m4(e) {
  var t = !1;
  return function() {
    t || (t = !0, e.apply(void 0, arguments));
  };
}
var AO = ra.codes, y4 = AO.ERR_MISSING_ARGS, g4 = AO.ERR_STREAM_DESTROYED;
function h_(e) {
  if (e)
    throw e;
}
function v4(e) {
  return e.setHeader && typeof e.abort == "function";
}
function b4(e, t, r, i) {
  i = m4(i);
  var n = !1;
  e.on("close", function() {
    n = !0;
  }), th === void 0 && (th = Lg), th(e, {
    readable: t,
    writable: r
  }, function(a) {
    if (a)
      return i(a);
    n = !0, i();
  });
  var s = !1;
  return function(a) {
    if (!n && !s) {
      if (s = !0, v4(e))
        return e.abort();
      if (typeof e.destroy == "function")
        return e.destroy();
      i(a || new g4("pipe"));
    }
  };
}
function m_(e) {
  e();
}
function _4(e, t) {
  return e.pipe(t);
}
function w4(e) {
  return !e.length || typeof e[e.length - 1] != "function" ? h_ : e.pop();
}
function $4() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  var i = w4(t);
  if (Array.isArray(t[0]) && (t = t[0]), t.length < 2)
    throw new y4("streams");
  var n, s = t.map(function(a, u) {
    var c = u < t.length - 1, l = u > 0;
    return b4(a, c, l, function(d) {
      n || (n = d), d && s.forEach(m_), !c && (s.forEach(m_), i(n));
    });
  });
  return t.reduce(_4);
}
var E4 = $4;
(function(e, t) {
  t = e.exports = OO(), t.Stream = t, t.Readable = t, t.Writable = EO(), t.Duplex = ao(), t.Transform = PO, t.PassThrough = h4, t.finished = Lg, t.pipeline = E4;
})(Cy, Cy.exports);
var CO = Cy.exports, y_ = Dg, x4 = ys, RO = CO, tl = Gf.readyStates = {
  UNSENT: 0,
  OPENED: 1,
  HEADERS_RECEIVED: 2,
  LOADING: 3,
  DONE: 4
}, qg = Gf.IncomingMessage = function(e, t, r, i) {
  var n = this;
  if (RO.Readable.call(n), n._mode = r, n.headers = {}, n.rawHeaders = [], n.trailers = {}, n.rawTrailers = [], n.on("end", function() {
    Me.process.nextTick(function() {
      n.emit("close");
    });
  }), r === "fetch") {
    let d = function() {
      a.read().then(function(p) {
        if (!n._destroyed) {
          if (i(p.done), p.done) {
            n.push(null);
            return;
          }
          n.push(Me.Buffer.from(p.value)), d();
        }
      }).catch(function(p) {
        i(!0), n._destroyed || n.emit("error", p);
      });
    };
    if (n._fetchResponse = t, n.url = t.url, n.statusCode = t.status, n.statusMessage = t.statusText, t.headers.forEach(function(p, h) {
      n.headers[h.toLowerCase()] = p, n.rawHeaders.push(h, p);
    }), y_.writableStream) {
      var s = new WritableStream({
        write: function(p) {
          return i(!1), new Promise(function(h, v) {
            n._destroyed ? v() : n.push(Me.Buffer.from(p)) ? h() : n._resumeFetch = h;
          });
        },
        close: function() {
          i(!0), n._destroyed || n.push(null);
        },
        abort: function(p) {
          i(!0), n._destroyed || n.emit("error", p);
        }
      });
      try {
        t.body.pipeTo(s).catch(function(p) {
          i(!0), n._destroyed || n.emit("error", p);
        });
        return;
      } catch {
      }
    }
    var a = t.body.getReader();
    d();
  } else {
    n._xhr = e, n._pos = 0, n.url = e.responseURL, n.statusCode = e.status, n.statusMessage = e.statusText;
    var u = e.getAllResponseHeaders().split(/\r?\n/);
    if (u.forEach(function(d) {
      var p = d.match(/^([^:]+):\s*(.*)/);
      if (p) {
        var h = p[1].toLowerCase();
        h === "set-cookie" ? (n.headers[h] === void 0 && (n.headers[h] = []), n.headers[h].push(p[2])) : n.headers[h] !== void 0 ? n.headers[h] += ", " + p[2] : n.headers[h] = p[2], n.rawHeaders.push(p[1], p[2]);
      }
    }), n._charset = "x-user-defined", !y_.overrideMimeType) {
      var c = n.rawHeaders["mime-type"];
      if (c) {
        var l = c.match(/;\s*charset=([^;])(;|$)/);
        l && (n._charset = l[1].toLowerCase());
      }
      n._charset || (n._charset = "utf-8");
    }
  }
};
x4(qg, RO.Readable);
qg.prototype._read = function() {
  var e = this, t = e._resumeFetch;
  t && (e._resumeFetch = null, t());
};
qg.prototype._onXHRProgress = function(e) {
  var t = this, r = t._xhr, i = null;
  switch (t._mode) {
    case "text":
      if (i = r.responseText, i.length > t._pos) {
        var n = i.substr(t._pos);
        if (t._charset === "x-user-defined") {
          for (var s = Me.Buffer.alloc(n.length), a = 0; a < n.length; a++)
            s[a] = n.charCodeAt(a) & 255;
          t.push(s);
        } else
          t.push(n, t._charset);
        t._pos = i.length;
      }
      break;
    case "arraybuffer":
      if (r.readyState !== tl.DONE || !r.response)
        break;
      i = r.response, t.push(Me.Buffer.from(new Uint8Array(i)));
      break;
    case "moz-chunked-arraybuffer":
      if (i = r.response, r.readyState !== tl.LOADING || !i)
        break;
      t.push(Me.Buffer.from(new Uint8Array(i)));
      break;
    case "ms-stream":
      if (i = r.response, r.readyState !== tl.LOADING)
        break;
      var u = new rt.MSStreamReader();
      u.onprogress = function() {
        u.result.byteLength > t._pos && (t.push(Me.Buffer.from(new Uint8Array(u.result.slice(t._pos)))), t._pos = u.result.byteLength);
      }, u.onload = function() {
        e(!0), t.push(null);
      }, u.readAsArrayBuffer(i);
      break;
  }
  t._xhr.readyState === tl.DONE && t._mode !== "ms-stream" && (e(!0), t.push(null));
};
var zs = Dg, O4 = ys, TO = Gf, Fg = CO, P4 = TO.IncomingMessage, g_ = TO.readyStates;
function S4(e, t) {
  return zs.fetch && t ? "fetch" : zs.mozchunkedarraybuffer ? "moz-chunked-arraybuffer" : zs.msstream ? "ms-stream" : zs.arraybuffer && e ? "arraybuffer" : "text";
}
var Cr = vO.exports = function(e) {
  var t = this;
  Fg.Writable.call(t), t._opts = e, t._body = [], t._headers = {}, e.auth && t.setHeader("Authorization", "Basic " + Me.Buffer.from(e.auth).toString("base64")), Object.keys(e.headers).forEach(function(n) {
    t.setHeader(n, e.headers[n]);
  });
  var r, i = !0;
  if (e.mode === "disable-fetch" || "requestTimeout" in e && !zs.abortController)
    i = !1, r = !0;
  else if (e.mode === "prefer-streaming")
    r = !1;
  else if (e.mode === "allow-wrong-content-type")
    r = !zs.overrideMimeType;
  else if (!e.mode || e.mode === "default" || e.mode === "prefer-fast")
    r = !0;
  else
    throw new Error("Invalid value for opts.mode");
  t._mode = S4(r, i), t._fetchTimer = null, t._socketTimeout = null, t._socketTimer = null, t.on("finish", function() {
    t._onFinish();
  });
};
O4(Cr, Fg.Writable);
Cr.prototype.setHeader = function(e, t) {
  var r = this, i = e.toLowerCase();
  C4.indexOf(i) === -1 && (r._headers[i] = {
    name: e,
    value: t
  });
};
Cr.prototype.getHeader = function(e) {
  var t = this._headers[e.toLowerCase()];
  return t ? t.value : null;
};
Cr.prototype.removeHeader = function(e) {
  var t = this;
  delete t._headers[e.toLowerCase()];
};
Cr.prototype._onFinish = function() {
  var e = this;
  if (!e._destroyed) {
    var t = e._opts;
    "timeout" in t && t.timeout !== 0 && e.setTimeout(t.timeout);
    var r = e._headers, i = null;
    t.method !== "GET" && t.method !== "HEAD" && (i = new Blob(e._body, {
      type: (r["content-type"] || {}).value || ""
    }));
    var n = [];
    if (Object.keys(r).forEach(function(c) {
      var l = r[c].name, d = r[c].value;
      Array.isArray(d) ? d.forEach(function(p) {
        n.push([l, p]);
      }) : n.push([l, d]);
    }), e._mode === "fetch") {
      var s = null;
      if (zs.abortController) {
        var a = new AbortController();
        s = a.signal, e._fetchAbortController = a, "requestTimeout" in t && t.requestTimeout !== 0 && (e._fetchTimer = rt.setTimeout(function() {
          e.emit("requestTimeout"), e._fetchAbortController && e._fetchAbortController.abort();
        }, t.requestTimeout));
      }
      rt.fetch(e._opts.url, {
        method: e._opts.method,
        headers: n,
        body: i || void 0,
        mode: "cors",
        credentials: t.withCredentials ? "include" : "same-origin",
        signal: s
      }).then(function(c) {
        e._fetchResponse = c, e._resetTimers(!1), e._connect();
      }, function(c) {
        e._resetTimers(!0), e._destroyed || e.emit("error", c);
      });
    } else {
      var u = e._xhr = new rt.XMLHttpRequest();
      try {
        u.open(e._opts.method, e._opts.url, !0);
      } catch (c) {
        Me.process.nextTick(function() {
          e.emit("error", c);
        });
        return;
      }
      "responseType" in u && (u.responseType = e._mode), "withCredentials" in u && (u.withCredentials = !!t.withCredentials), e._mode === "text" && "overrideMimeType" in u && u.overrideMimeType("text/plain; charset=x-user-defined"), "requestTimeout" in t && (u.timeout = t.requestTimeout, u.ontimeout = function() {
        e.emit("requestTimeout");
      }), n.forEach(function(c) {
        u.setRequestHeader(c[0], c[1]);
      }), e._response = null, u.onreadystatechange = function() {
        switch (u.readyState) {
          case g_.LOADING:
          case g_.DONE:
            e._onXHRProgress();
            break;
        }
      }, e._mode === "moz-chunked-arraybuffer" && (u.onprogress = function() {
        e._onXHRProgress();
      }), u.onerror = function() {
        e._destroyed || (e._resetTimers(!0), e.emit("error", new Error("XHR error")));
      };
      try {
        u.send(i);
      } catch (c) {
        Me.process.nextTick(function() {
          e.emit("error", c);
        });
        return;
      }
    }
  }
};
function A4(e) {
  try {
    var t = e.status;
    return t !== null && t !== 0;
  } catch {
    return !1;
  }
}
Cr.prototype._onXHRProgress = function() {
  var e = this;
  e._resetTimers(!1), !(!A4(e._xhr) || e._destroyed) && (e._response || e._connect(), e._response._onXHRProgress(e._resetTimers.bind(e)));
};
Cr.prototype._connect = function() {
  var e = this;
  e._destroyed || (e._response = new P4(e._xhr, e._fetchResponse, e._mode, e._resetTimers.bind(e)), e._response.on("error", function(t) {
    e.emit("error", t);
  }), e.emit("response", e._response));
};
Cr.prototype._write = function(e, t, r) {
  var i = this;
  i._body.push(e), r();
};
Cr.prototype._resetTimers = function(e) {
  var t = this;
  rt.clearTimeout(t._socketTimer), t._socketTimer = null, e ? (rt.clearTimeout(t._fetchTimer), t._fetchTimer = null) : t._socketTimeout && (t._socketTimer = rt.setTimeout(function() {
    t.emit("timeout");
  }, t._socketTimeout));
};
Cr.prototype.abort = Cr.prototype.destroy = function(e) {
  var t = this;
  t._destroyed = !0, t._resetTimers(!0), t._response && (t._response._destroyed = !0), t._xhr ? t._xhr.abort() : t._fetchAbortController && t._fetchAbortController.abort(), e && t.emit("error", e);
};
Cr.prototype.end = function(e, t, r) {
  var i = this;
  typeof e == "function" && (r = e, e = void 0), Fg.Writable.prototype.end.call(i, e, t, r);
};
Cr.prototype.setTimeout = function(e, t) {
  var r = this;
  t && r.once("timeout", t), r._socketTimeout = e, r._resetTimers(!1);
};
Cr.prototype.flushHeaders = function() {
};
Cr.prototype.setNoDelay = function() {
};
Cr.prototype.setSocketKeepAlive = function() {
};
var C4 = [
  "accept-charset",
  "accept-encoding",
  "access-control-request-headers",
  "access-control-request-method",
  "connection",
  "content-length",
  "cookie",
  "cookie2",
  "date",
  "dnt",
  "expect",
  "host",
  "keep-alive",
  "origin",
  "referer",
  "te",
  "trailer",
  "transfer-encoding",
  "upgrade",
  "via"
], R4 = vO.exports, T4 = j4, I4 = Object.prototype.hasOwnProperty;
function j4() {
  for (var e = {}, t = 0; t < arguments.length; t++) {
    var r = arguments[t];
    for (var i in r)
      I4.call(r, i) && (e[i] = r[i]);
  }
  return e;
}
var k4 = {
  100: "Continue",
  101: "Switching Protocols",
  102: "Processing",
  200: "OK",
  201: "Created",
  202: "Accepted",
  203: "Non-Authoritative Information",
  204: "No Content",
  205: "Reset Content",
  206: "Partial Content",
  207: "Multi-Status",
  208: "Already Reported",
  226: "IM Used",
  300: "Multiple Choices",
  301: "Moved Permanently",
  302: "Found",
  303: "See Other",
  304: "Not Modified",
  305: "Use Proxy",
  307: "Temporary Redirect",
  308: "Permanent Redirect",
  400: "Bad Request",
  401: "Unauthorized",
  402: "Payment Required",
  403: "Forbidden",
  404: "Not Found",
  405: "Method Not Allowed",
  406: "Not Acceptable",
  407: "Proxy Authentication Required",
  408: "Request Timeout",
  409: "Conflict",
  410: "Gone",
  411: "Length Required",
  412: "Precondition Failed",
  413: "Payload Too Large",
  414: "URI Too Long",
  415: "Unsupported Media Type",
  416: "Range Not Satisfiable",
  417: "Expectation Failed",
  418: "I'm a teapot",
  421: "Misdirected Request",
  422: "Unprocessable Entity",
  423: "Locked",
  424: "Failed Dependency",
  425: "Unordered Collection",
  426: "Upgrade Required",
  428: "Precondition Required",
  429: "Too Many Requests",
  431: "Request Header Fields Too Large",
  451: "Unavailable For Legal Reasons",
  500: "Internal Server Error",
  501: "Not Implemented",
  502: "Bad Gateway",
  503: "Service Unavailable",
  504: "Gateway Timeout",
  505: "HTTP Version Not Supported",
  506: "Variant Also Negotiates",
  507: "Insufficient Storage",
  508: "Loop Detected",
  509: "Bandwidth Limit Exceeded",
  510: "Not Extended",
  511: "Network Authentication Required"
};
(function(e) {
  var t = R4, r = Gf, i = T4, n = k4, s = ku, a = e;
  a.request = function(u, c) {
    typeof u == "string" ? u = s.parse(u) : u = i(u);
    var l = rt.location.protocol.search(/^https?:$/) === -1 ? "http:" : "", d = u.protocol || l, p = u.hostname || u.host, h = u.port, v = u.path || "/";
    p && p.indexOf(":") !== -1 && (p = "[" + p + "]"), u.url = (p ? d + "//" + p : "") + (h ? ":" + h : "") + v, u.method = (u.method || "GET").toUpperCase(), u.headers = u.headers || {};
    var y = new t(u);
    return c && y.on("response", c), y;
  }, a.get = function(c, l) {
    var d = a.request(c, l);
    return d.end(), d;
  }, a.ClientRequest = t, a.IncomingMessage = r.IncomingMessage, a.Agent = function() {
  }, a.Agent.defaultMaxSockets = 4, a.globalAgent = new a.Agent(), a.STATUS_CODES = n, a.METHODS = [
    "CHECKOUT",
    "CONNECT",
    "COPY",
    "DELETE",
    "GET",
    "HEAD",
    "LOCK",
    "M-SEARCH",
    "MERGE",
    "MKACTIVITY",
    "MKCOL",
    "MOVE",
    "NOTIFY",
    "OPTIONS",
    "PATCH",
    "POST",
    "PROPFIND",
    "PROPPATCH",
    "PURGE",
    "PUT",
    "REPORT",
    "SEARCH",
    "SUBSCRIBE",
    "TRACE",
    "UNLOCK",
    "UNSUBSCRIBE"
  ];
})(Hf);
var IO = { exports: {} };
(function(e) {
  var t = Hf, r = ku, i = e.exports;
  for (var n in t)
    t.hasOwnProperty(n) && (i[n] = t[n]);
  i.request = function(a, u) {
    return a = s(a), t.request.call(this, a, u);
  }, i.get = function(a, u) {
    return a = s(a), t.get.call(this, a, u);
  };
  function s(a) {
    if (typeof a == "string" && (a = r.parse(a)), a.protocol || (a.protocol = "https:"), a.protocol !== "https:")
      throw new Error('Protocol "' + a.protocol + '" not supported. Expected "https:"');
    return a;
  }
})(IO);
var jO = IO.exports;
const M4 = Hf, N4 = jO, { ono: rl } = Nn, { ResolverError: v_ } = or, pu = gn;
function D4(e, t) {
  return new Promise((r, i) => {
    const s = (e.protocol === "https:" ? N4 : M4).get({
      hostname: e.hostname,
      port: e.port,
      path: e.path,
      auth: e.auth,
      protocol: e.protocol,
      headers: t.headers || {},
      withCredentials: t.withCredentials
    });
    typeof s.setTimeout == "function" && s.setTimeout(t.timeout), s.on("timeout", () => {
      s.abort();
    }), s.on("error", i), s.once("response", (a) => {
      a.body = Me.Buffer.alloc(0), a.on("data", (u) => {
        a.body = Me.Buffer.concat([a.body, Me.Buffer.from(u)]);
      }), a.on("error", i), a.on("end", () => {
        r(a);
      });
    });
  });
}
function kO(e, t, r) {
  return new Promise((i, n) => {
    e = pu.parse(e), r = r || [], r.push(e.href), D4(e, t).then((s) => {
      if (s.statusCode >= 400)
        throw rl({ status: s.statusCode }, `HTTP ERROR ${s.statusCode}`);
      if (s.statusCode >= 300)
        if (r.length > t.redirects)
          n(
            new v_(
              rl(
                { status: s.statusCode },
                `Error downloading ${r[0]}. 
Too many redirects: 
  ${r.join(` 
  `)}`
              )
            )
          );
        else if (s.headers.location) {
          const a = pu.resolve(e, s.headers.location);
          kO(a, t, r).then(i, n);
        } else
          throw rl({ status: s.statusCode }, `HTTP ${s.statusCode} redirect with no location header`);
      else
        i(s.body || Me.Buffer.alloc(0));
    }).catch((s) => {
      n(new v_(rl(s, `Error downloading ${e.href}`), e.href));
    });
  });
}
var L4 = {
  /**
   * The order that this resolver will run, in relation to other resolvers.
   *
   * @type {number}
   */
  order: 200,
  /**
   * HTTP headers to send when downloading files.
   *
   * @example:
   * {
   *   "User-Agent": "JSON Schema $Ref Parser",
   *   Accept: "application/json"
   * }
   *
   * @type {object}
   */
  headers: null,
  /**
   * HTTP request timeout (in milliseconds).
   *
   * @type {number}
   */
  timeout: 5e3,
  // 5 seconds
  /**
   * The maximum number of HTTP redirects to follow.
   * To disable automatic following of redirects, set this to zero.
   *
   * @type {number}
   */
  redirects: 5,
  /**
   * The `withCredentials` option of XMLHttpRequest.
   * Set this to `true` if you're downloading files from a CORS-enabled server that requires authentication
   *
   * @type {boolean}
   */
  withCredentials: !1,
  /**
   * Determines whether this resolver can read a given file reference.
   * Resolvers that return true will be tried in order, until one successfully resolves the file.
   * Resolvers that return false will not be given a chance to resolve the file.
   *
   * @param {object} file           - An object containing information about the referenced file
   * @param {string} file.url       - The full URL of the referenced file
   * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
   * @returns {boolean}
   */
  canRead(e) {
    return pu.isHttp(e.url);
  },
  /**
   * Reads the given URL and returns its raw contents as a Buffer.
   *
   * @param {object} file           - An object containing information about the referenced file
   * @param {string} file.url       - The full URL of the referenced file
   * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
   * @returns {Promise<Buffer>}
   */
  read(e) {
    const t = pu.parse(e.url);
    return Me.process.browser && !t.protocol && (t.protocol = pu.parse(location.href).protocol), kO(t, this);
  }
};
const q4 = mD, F4 = gD, U4 = _D, B4 = L6, V4 = B6, Z4 = L4;
var MO = Ug;
function Ug(e) {
  Ty(this, Ug.defaults), Ty(this, e);
}
Ug.defaults = {
  /**
   * Determines how different types of files will be parsed.
   *
   * You can add additional parsers of your own, replace an existing one with
   * your own implementation, or disable any parser by setting it to false.
   */
  parse: {
    json: F4,
    yaml: B4,
    text: U4,
    binary: q4
  },
  /**
   * Determines how JSON References will be resolved.
   *
   * You can add additional resolvers of your own, replace an existing one with
   * your own implementation, or disable any resolver by setting it to false.
   */
  resolve: {
    file: V4,
    http: Z4,
    /**
     * Determines whether external $ref pointers will be resolved.
     * If this option is disabled, then none of above resolvers will be called.
     * Instead, external $ref pointers will simply be ignored.
     *
     * @type {boolean}
     */
    external: !0
  },
  /**
   * By default, JSON Schema $Ref Parser throws the first error it encounters. Setting `continueOnError` to `true`
   * causes it to keep processing as much as possible and then throw a single error that contains all errors
   * that were encountered.
   */
  continueOnError: !1,
  /**
   * Determines the types of JSON references that are allowed.
   */
  dereference: {
    /**
     * Dereference circular (recursive) JSON references?
     * If false, then a {@link ReferenceError} will be thrown if a circular reference is found.
     * If "ignore", then circular references will not be dereferenced.
     *
     * @type {boolean|string}
     */
    circular: !0
  }
};
function Ty(e, t) {
  if (b_(t)) {
    const r = Object.keys(t);
    for (let i = 0; i < r.length; i++) {
      const n = r[i], s = t[n], a = e[n];
      b_(s) ? e[n] = Ty(a || {}, s) : s !== void 0 && (e[n] = s);
    }
  }
  return e;
}
function b_(e) {
  return e && typeof e == "object" && !Array.isArray(e) && !(e instanceof RegExp) && !(e instanceof Date);
}
const __ = MO;
var NO = function(t) {
  let r, i, n, s;
  return t = Array.prototype.slice.call(t), typeof t[t.length - 1] == "function" && (s = t.pop()), typeof t[0] == "string" ? (r = t[0], typeof t[2] == "object" ? (i = t[1], n = t[2]) : (i = void 0, n = t[1])) : (r = "", i = t[0], n = t[1]), n instanceof __ || (n = new __(n)), {
    path: r,
    schema: i,
    options: n,
    callback: s
  };
}, nc = {};
nc.all = function(e) {
  return Object.keys(e).filter((t) => typeof e[t] == "object").map((t) => (e[t].name = t, e[t]));
};
nc.filter = function(e, t, r) {
  return e.filter((i) => !!DO(i, t, r));
};
nc.sort = function(e) {
  for (const t of e)
    t.order = t.order || Number.MAX_SAFE_INTEGER;
  return e.sort((t, r) => t.order - r.order);
};
nc.run = function(e, t, r, i) {
  let n, s, a = 0;
  return new Promise((u, c) => {
    l();
    function l() {
      if (n = e[a++], !n)
        return c(s);
      try {
        const v = DO(n, t, r, d, i);
        if (v && typeof v.then == "function")
          v.then(p, h);
        else if (v !== void 0)
          p(v);
        else if (a === e.length)
          throw new Error("No promise has been returned or callback has been called.");
      } catch (v) {
        h(v);
      }
    }
    function d(v, y) {
      v ? h(v) : p(y);
    }
    function p(v) {
      u({
        plugin: n,
        result: v
      });
    }
    function h(v) {
      s = {
        plugin: n,
        error: v
      }, l();
    }
  });
};
function DO(e, t, r, i, n) {
  const s = e[t];
  if (typeof s == "function")
    return s.apply(e, [r, i, n]);
  if (!i) {
    if (s instanceof RegExp)
      return s.test(r.url);
    if (typeof s == "string")
      return s === r.extension;
    if (Array.isArray(s))
      return s.indexOf(r.extension) !== -1;
  }
  return s;
}
const { ono: Iy } = Nn, {
  ResolverError: w_,
  ParserError: $_,
  UnmatchedParserError: z4,
  UnmatchedResolverError: W4,
  isHandledError: H4
} = or, is = nc, E_ = gn;
var LO = async function(t, r, i) {
  t = E_.stripHash(t);
  const n = r._add(t), s = {
    url: t,
    extension: E_.getExtension(t)
  };
  try {
    const a = await G4(s, i, r);
    n.pathType = a.plugin.name, s.data = a.result;
    const u = await K4(s, i, r);
    return n.value = u.result, u.result;
  } catch (a) {
    throw H4(a) && (n.value = a), a;
  }
};
function G4(e, t, r) {
  return new Promise((i, n) => {
    let s = is.all(t.resolve);
    s = is.filter(s, "canRead", e), is.sort(s), is.run(s, "read", e, r).then(i, a);
    function a(u) {
      !u && t.continueOnError ? n(new W4(e.url)) : !u || !("error" in u) ? n(Iy.syntax(`Unable to resolve $ref pointer "${e.url}"`)) : u.error instanceof w_ ? n(u.error) : n(new w_(u, e.url));
    }
  });
}
function K4(e, t, r) {
  return new Promise((i, n) => {
    const s = is.all(t.parse), a = is.filter(s, "canParse", e), u = a.length > 0 ? a : s;
    is.sort(u), is.run(u, "parse", e, r).then(c, l);
    function c(d) {
      !d.plugin.allowEmpty && Y4(d.result) ? n(Iy.syntax(`Error parsing "${e.url}" as ${d.plugin.name}. 
Parsed value is empty`)) : i(d);
    }
    function l(d) {
      !d && t.continueOnError ? n(new z4(e.url)) : !d || !("error" in d) ? n(Iy.syntax(`Unable to parse ${e.url}`)) : d.error instanceof $_ ? n(d.error) : n(new $_(d.error.message, e.url));
    }
  });
}
function Y4(e) {
  return e === void 0 || typeof e == "object" && Object.keys(e).length === 0 || typeof e == "string" && e.trim().length === 0 || Me.Buffer.isBuffer(e) && e.length === 0;
}
const { ono: qO } = Nn, J4 = ec(), ms = gn;
var X4 = Mn;
function Mn() {
  this.circular = !1, this.circularRefs = [], this._$refs = {}, this._root$Ref = null;
}
Mn.prototype.paths = function(e) {
  return FO(this._$refs, arguments).map((r) => r.decoded);
};
Mn.prototype.values = function(e) {
  const t = this._$refs;
  return FO(t, arguments).reduce((i, n) => (i[n.decoded] = t[n.encoded].value, i), {});
};
Mn.prototype.toJSON = Mn.prototype.values;
Mn.prototype.exists = function(e, t) {
  try {
    return this._resolve(e, "", t), !0;
  } catch {
    return !1;
  }
};
Mn.prototype.get = function(e, t) {
  return this._resolve(e, "", t).value;
};
Mn.prototype.set = function(e, t) {
  const r = ms.resolve(this._root$Ref.path, e), i = ms.stripHash(r), n = this._$refs[i];
  if (!n)
    throw qO(`Error resolving $ref pointer "${e}". 
"${i}" not found.`);
  n.set(r, t);
};
Mn.prototype._add = function(e) {
  const t = ms.stripHash(e), r = new J4();
  return r.path = t, r.$refs = this, this._$refs[t] = r, this._root$Ref = this._root$Ref || r, r;
};
Mn.prototype._resolve = function(e, t, r) {
  const i = ms.resolve(this._root$Ref.path, e), n = ms.stripHash(i), s = this._$refs[n];
  if (!s)
    throw qO(`Error resolving $ref pointer "${e}". 
"${n}" not found.`);
  return s.resolve(i, r, e, t);
};
Mn.prototype._get$Ref = function(e) {
  e = ms.resolve(this._root$Ref.path, e);
  const t = ms.stripHash(e);
  return this._$refs[t];
};
function FO(e, t) {
  let r = Object.keys(e);
  return t = Array.isArray(t[0]) ? t[0] : Array.prototype.slice.call(t), t.length > 0 && t[0] && (r = r.filter((i) => t.indexOf(e[i].pathType) !== -1)), r.map((i) => ({
    encoded: i,
    decoded: e[i].pathType === "file" ? ms.toFileSystemPath(i, !0) : i
  }));
}
const Q4 = LO, eq = Zf(), x_ = ec(), { isHandledError: tq } = or, Ho = gn;
var rq = nq;
function nq(e, t) {
  if (!t.resolve.external)
    return Promise.resolve();
  try {
    const r = Bg(e.schema, `${e.$refs._root$Ref.path}#`, e.$refs, t);
    return Promise.all(r);
  } catch (r) {
    return Promise.reject(r);
  }
}
function Bg(e, t, r, i, n) {
  n = n || /* @__PURE__ */ new Set();
  let s = [];
  if (e && typeof e == "object" && !ArrayBuffer.isView(e) && !n.has(e))
    if (n.add(e), x_.isExternal$Ref(e))
      s.push(O_(e, t, r, i));
    else
      for (const a of Object.keys(e)) {
        const u = eq.join(t, a), c = e[a];
        x_.isExternal$Ref(c) ? s.push(O_(c, u, r, i)) : s = s.concat(Bg(c, u, r, i, n));
      }
  return s;
}
async function O_(e, t, r, i) {
  const n = Ho.resolve(t, e.$ref), s = Ho.stripHash(n);
  if (e = r._$refs[s], e)
    return Promise.resolve(e.value);
  try {
    const a = await Q4(n, r, i), u = Bg(a, `${s}#`, r, i);
    return Promise.all(u);
  } catch (a) {
    if (!i.continueOnError || !tq(a))
      throw a;
    return r._$refs[s] && (a.source = Ho.stripHash(t), a.path = Ho.safePointerToPath(Ho.getHash(t))), [];
  }
}
const { ono: P_ } = Nn, An = QE, iq = uD, sq = Ox, Jf = NO, aq = LO, UO = X4, oq = rq, {
  JSONParserError: uq,
  InvalidPointerError: cq,
  MissingPointerError: lq,
  ResolverError: fq,
  ParserError: dq,
  UnmatchedParserError: pq,
  UnmatchedResolverError: hq,
  isHandledError: mq,
  JSONParserErrorGroup: S_
} = or, Ra = gn;
ai.exports = oi;
ai.exports.default = oi;
ai.exports.JSONParserError = uq;
ai.exports.InvalidPointerError = cq;
ai.exports.MissingPointerError = lq;
ai.exports.ResolverError = fq;
ai.exports.ParserError = dq;
ai.exports.UnmatchedParserError = pq;
ai.exports.UnmatchedResolverError = hq;
function oi() {
  this.schema = null, this.$refs = new UO();
}
oi.parse = function(t, r, i, n) {
  const s = this, a = new s();
  return a.parse.apply(a, arguments);
};
oi.prototype.parse = async function(t, r, i, n) {
  const s = Jf(arguments);
  let a;
  if (!s.path && !s.schema) {
    const l = P_(`Expected a file path, URL, or object. Got ${s.path || s.schema}`);
    return An(s.callback, Promise.reject(l));
  }
  this.schema = null, this.$refs = new UO();
  let u = "http";
  if (Ra.isFileSystemPath(s.path) && (s.path = Ra.fromFileSystemPath(s.path), u = "file"), s.path = Ra.resolve(Ra.cwd(), s.path), s.schema && typeof s.schema == "object") {
    const l = this.$refs._add(s.path);
    l.value = s.schema, l.pathType = u, a = Promise.resolve(s.schema);
  } else
    a = aq(s.path, this.$refs, s.options);
  const c = this;
  try {
    const l = await a;
    if (l !== null && typeof l == "object" && !Me.Buffer.isBuffer(l))
      return c.schema = l, An(s.callback, Promise.resolve(c.schema));
    if (s.options.continueOnError)
      return c.schema = null, An(s.callback, Promise.resolve(c.schema));
    throw P_.syntax(`"${c.$refs._root$Ref.path || l}" is not a valid JSON Schema`);
  } catch (l) {
    return !s.options.continueOnError || !mq(l) ? An(s.callback, Promise.reject(l)) : (this.$refs._$refs[Ra.stripHash(s.path)] && this.$refs._$refs[Ra.stripHash(s.path)].addError(l), An(s.callback, Promise.resolve(null)));
  }
};
oi.resolve = function(t, r, i, n) {
  const s = this, a = new s();
  return a.resolve.apply(a, arguments);
};
oi.prototype.resolve = async function(t, r, i, n) {
  const s = this, a = Jf(arguments);
  try {
    return await this.parse(a.path, a.schema, a.options), await oq(s, a.options), Vg(s), An(a.callback, Promise.resolve(s.$refs));
  } catch (u) {
    return An(a.callback, Promise.reject(u));
  }
};
oi.bundle = function(t, r, i, n) {
  const s = this, a = new s();
  return a.bundle.apply(a, arguments);
};
oi.prototype.bundle = async function(t, r, i, n) {
  const s = this, a = Jf(arguments);
  try {
    return await this.resolve(a.path, a.schema, a.options), iq(s, a.options), Vg(s), An(a.callback, Promise.resolve(s.schema));
  } catch (u) {
    return An(a.callback, Promise.reject(u));
  }
};
oi.dereference = function(t, r, i, n) {
  const s = this, a = new s();
  return a.dereference.apply(a, arguments);
};
oi.prototype.dereference = async function(t, r, i, n) {
  const s = this, a = Jf(arguments);
  try {
    return await this.resolve(a.path, a.schema, a.options), sq(s, a.options), Vg(s), An(a.callback, Promise.resolve(s.schema));
  } catch (u) {
    return An(a.callback, Promise.reject(u));
  }
};
function Vg(e) {
  if (S_.getParserErrors(e).length > 0)
    throw new S_(e);
}
var yq = ai.exports, ui = {};
const BO = fo, gq = gn;
ui.format = BO.format;
ui.inherits = BO.inherits;
ui.swaggerParamRegExp = /\{([^/}]+)}/g;
const vq = ["get", "post", "put", "delete", "patch", "options", "head", "trace"];
function rh(e, t) {
  if (e.url && e.url.startsWith("/")) {
    const r = gq.parse(t), i = `${r.protocol}//${r.hostname}${e.url}`;
    e.url = i;
  }
  return e;
}
function bq(e, t) {
  e.openapi && t && (t.startsWith("http:") || t.startsWith("https:")) && (e.servers && e.servers.map((r) => rh(r, t)), ["paths", "webhooks"].forEach((r) => {
    Object.keys(e[r] || []).forEach((i) => {
      const n = e[r][i];
      Object.keys(n).forEach((s) => {
        s === "servers" ? n[s].map((a) => rh(a, t)) : vq.includes(s) && n[s].servers && n[s].servers.map((a) => rh(a, t));
      });
    });
  }));
}
function _q(e) {
  return e.swagger ? "Swagger" : "OpenAPI";
}
ui.fixOasRelativeServers = bq;
ui.getSpecificationName = _q;
var jy = { exports: {} };
const wq = "https://raw.githubusercontent.com/OAI/OpenAPI-Specification/master/schemas/v1.2/apiDeclaration.json#", $q = "http://json-schema.org/draft-04/schema#", Eq = "object", xq = [
  "swaggerVersion",
  "basePath",
  "apis"
], Oq = {
  swaggerVersion: {
    enum: [
      "1.2"
    ]
  },
  apiVersion: {
    type: "string"
  },
  basePath: {
    type: "string",
    format: "uri",
    pattern: "^https?://"
  },
  resourcePath: {
    type: "string",
    format: "uri",
    pattern: "^/"
  },
  apis: {
    type: "array",
    items: {
      $ref: "#/definitions/apiObject"
    }
  },
  models: {
    type: "object",
    additionalProperties: {
      $ref: "modelsObject.json#"
    }
  },
  produces: {
    $ref: "#/definitions/mimeTypeArray"
  },
  consumes: {
    $ref: "#/definitions/mimeTypeArray"
  },
  authorizations: {
    $ref: "authorizationObject.json#"
  }
}, Pq = !1, Sq = {
  apiObject: {
    type: "object",
    required: [
      "path",
      "operations"
    ],
    properties: {
      path: {
        type: "string",
        format: "uri-template",
        pattern: "^/"
      },
      description: {
        type: "string"
      },
      operations: {
        type: "array",
        items: {
          $ref: "operationObject.json#"
        }
      }
    },
    additionalProperties: !1
  },
  mimeTypeArray: {
    type: "array",
    items: {
      type: "string",
      format: "mime-type"
    },
    uniqueItems: !0
  }
}, Aq = {
  id: wq,
  $schema: $q,
  type: Eq,
  required: xq,
  properties: Oq,
  additionalProperties: Pq,
  definitions: Sq
}, Cq = "A JSON Schema for Swagger 2.0 API.", Rq = "http://swagger.io/v2/schema.json#", Tq = "http://json-schema.org/draft-04/schema#", Iq = "object", jq = [
  "swagger",
  "info",
  "paths"
], kq = !1, Mq = {
  "^x-": {
    $ref: "#/definitions/vendorExtension"
  }
}, Nq = {
  swagger: {
    type: "string",
    enum: [
      "2.0"
    ],
    description: "The Swagger version of this document."
  },
  info: {
    $ref: "#/definitions/info"
  },
  host: {
    type: "string",
    pattern: "^[^{}/ :\\\\]+(?::\\d+)?$",
    description: "The host (name or ip) of the API. Example: 'swagger.io'"
  },
  basePath: {
    type: "string",
    pattern: "^/",
    description: "The base path to the API. Example: '/api'."
  },
  schemes: {
    $ref: "#/definitions/schemesList"
  },
  consumes: {
    description: "A list of MIME types accepted by the API.",
    allOf: [
      {
        $ref: "#/definitions/mediaTypeList"
      }
    ]
  },
  produces: {
    description: "A list of MIME types the API can produce.",
    allOf: [
      {
        $ref: "#/definitions/mediaTypeList"
      }
    ]
  },
  paths: {
    $ref: "#/definitions/paths"
  },
  definitions: {
    $ref: "#/definitions/definitions"
  },
  parameters: {
    $ref: "#/definitions/parameterDefinitions"
  },
  responses: {
    $ref: "#/definitions/responseDefinitions"
  },
  security: {
    $ref: "#/definitions/security"
  },
  securityDefinitions: {
    $ref: "#/definitions/securityDefinitions"
  },
  tags: {
    type: "array",
    items: {
      $ref: "#/definitions/tag"
    },
    uniqueItems: !0
  },
  externalDocs: {
    $ref: "#/definitions/externalDocs"
  }
}, Dq = {
  info: {
    type: "object",
    description: "General information about the API.",
    required: [
      "version",
      "title"
    ],
    additionalProperties: !1,
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    },
    properties: {
      title: {
        type: "string",
        description: "A unique and precise title of the API."
      },
      version: {
        type: "string",
        description: "A semantic version number of the API."
      },
      description: {
        type: "string",
        description: "A longer description of the API. Should be different from the title.  GitHub Flavored Markdown is allowed."
      },
      termsOfService: {
        type: "string",
        description: "The terms of service for the API."
      },
      contact: {
        $ref: "#/definitions/contact"
      },
      license: {
        $ref: "#/definitions/license"
      }
    }
  },
  contact: {
    type: "object",
    description: "Contact information for the owners of the API.",
    additionalProperties: !1,
    properties: {
      name: {
        type: "string",
        description: "The identifying name of the contact person/organization."
      },
      url: {
        type: "string",
        description: "The URL pointing to the contact information.",
        format: "uri"
      },
      email: {
        type: "string",
        description: "The email address of the contact person/organization.",
        format: "email"
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  license: {
    type: "object",
    required: [
      "name"
    ],
    additionalProperties: !1,
    properties: {
      name: {
        type: "string",
        description: "The name of the license type. It's encouraged to use an OSI compatible license."
      },
      url: {
        type: "string",
        description: "The URL pointing to the license.",
        format: "uri"
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  paths: {
    type: "object",
    description: "Relative paths to the individual endpoints. They must be relative to the 'basePath'.",
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      },
      "^/": {
        $ref: "#/definitions/pathItem"
      }
    },
    additionalProperties: !1
  },
  definitions: {
    type: "object",
    additionalProperties: {
      $ref: "#/definitions/schema"
    },
    description: "One or more JSON objects describing the schemas being consumed and produced by the API."
  },
  parameterDefinitions: {
    type: "object",
    additionalProperties: {
      $ref: "#/definitions/parameter"
    },
    description: "One or more JSON representations for parameters"
  },
  responseDefinitions: {
    type: "object",
    additionalProperties: {
      $ref: "#/definitions/response"
    },
    description: "One or more JSON representations for responses"
  },
  externalDocs: {
    type: "object",
    additionalProperties: !1,
    description: "information about external documentation",
    required: [
      "url"
    ],
    properties: {
      description: {
        type: "string"
      },
      url: {
        type: "string",
        format: "uri"
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  examples: {
    type: "object",
    additionalProperties: !0
  },
  mimeType: {
    type: "string",
    description: "The MIME type of the HTTP message."
  },
  operation: {
    type: "object",
    required: [
      "responses"
    ],
    additionalProperties: !1,
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    },
    properties: {
      tags: {
        type: "array",
        items: {
          type: "string"
        },
        uniqueItems: !0
      },
      summary: {
        type: "string",
        description: "A brief summary of the operation."
      },
      description: {
        type: "string",
        description: "A longer description of the operation, GitHub Flavored Markdown is allowed."
      },
      externalDocs: {
        $ref: "#/definitions/externalDocs"
      },
      operationId: {
        type: "string",
        description: "A unique identifier of the operation."
      },
      produces: {
        description: "A list of MIME types the API can produce.",
        allOf: [
          {
            $ref: "#/definitions/mediaTypeList"
          }
        ]
      },
      consumes: {
        description: "A list of MIME types the API can consume.",
        allOf: [
          {
            $ref: "#/definitions/mediaTypeList"
          }
        ]
      },
      parameters: {
        $ref: "#/definitions/parametersList"
      },
      responses: {
        $ref: "#/definitions/responses"
      },
      schemes: {
        $ref: "#/definitions/schemesList"
      },
      deprecated: {
        type: "boolean",
        default: !1
      },
      security: {
        $ref: "#/definitions/security"
      }
    }
  },
  pathItem: {
    type: "object",
    additionalProperties: !1,
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    },
    properties: {
      $ref: {
        type: "string"
      },
      get: {
        $ref: "#/definitions/operation"
      },
      put: {
        $ref: "#/definitions/operation"
      },
      post: {
        $ref: "#/definitions/operation"
      },
      delete: {
        $ref: "#/definitions/operation"
      },
      options: {
        $ref: "#/definitions/operation"
      },
      head: {
        $ref: "#/definitions/operation"
      },
      patch: {
        $ref: "#/definitions/operation"
      },
      parameters: {
        $ref: "#/definitions/parametersList"
      }
    }
  },
  responses: {
    type: "object",
    description: "Response objects names can either be any valid HTTP status code or 'default'.",
    minProperties: 1,
    additionalProperties: !1,
    patternProperties: {
      "^([0-9]{3})$|^(default)$": {
        $ref: "#/definitions/responseValue"
      },
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    },
    not: {
      type: "object",
      additionalProperties: !1,
      patternProperties: {
        "^x-": {
          $ref: "#/definitions/vendorExtension"
        }
      }
    }
  },
  responseValue: {
    oneOf: [
      {
        $ref: "#/definitions/response"
      },
      {
        $ref: "#/definitions/jsonReference"
      }
    ]
  },
  response: {
    type: "object",
    required: [
      "description"
    ],
    properties: {
      description: {
        type: "string"
      },
      schema: {
        oneOf: [
          {
            $ref: "#/definitions/schema"
          },
          {
            $ref: "#/definitions/fileSchema"
          }
        ]
      },
      headers: {
        $ref: "#/definitions/headers"
      },
      examples: {
        $ref: "#/definitions/examples"
      }
    },
    additionalProperties: !1,
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  headers: {
    type: "object",
    additionalProperties: {
      $ref: "#/definitions/header"
    }
  },
  header: {
    type: "object",
    additionalProperties: !1,
    required: [
      "type"
    ],
    properties: {
      type: {
        type: "string",
        enum: [
          "string",
          "number",
          "integer",
          "boolean",
          "array"
        ]
      },
      format: {
        type: "string"
      },
      items: {
        $ref: "#/definitions/primitivesItems"
      },
      collectionFormat: {
        $ref: "#/definitions/collectionFormat"
      },
      default: {
        $ref: "#/definitions/default"
      },
      maximum: {
        $ref: "#/definitions/maximum"
      },
      exclusiveMaximum: {
        $ref: "#/definitions/exclusiveMaximum"
      },
      minimum: {
        $ref: "#/definitions/minimum"
      },
      exclusiveMinimum: {
        $ref: "#/definitions/exclusiveMinimum"
      },
      maxLength: {
        $ref: "#/definitions/maxLength"
      },
      minLength: {
        $ref: "#/definitions/minLength"
      },
      pattern: {
        $ref: "#/definitions/pattern"
      },
      maxItems: {
        $ref: "#/definitions/maxItems"
      },
      minItems: {
        $ref: "#/definitions/minItems"
      },
      uniqueItems: {
        $ref: "#/definitions/uniqueItems"
      },
      enum: {
        $ref: "#/definitions/enum"
      },
      multipleOf: {
        $ref: "#/definitions/multipleOf"
      },
      description: {
        type: "string"
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  vendorExtension: {
    description: "Any property starting with x- is valid.",
    additionalProperties: !0,
    additionalItems: !0
  },
  bodyParameter: {
    type: "object",
    required: [
      "name",
      "in",
      "schema"
    ],
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    },
    properties: {
      description: {
        type: "string",
        description: "A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed."
      },
      name: {
        type: "string",
        description: "The name of the parameter."
      },
      in: {
        type: "string",
        description: "Determines the location of the parameter.",
        enum: [
          "body"
        ]
      },
      required: {
        type: "boolean",
        description: "Determines whether or not this parameter is required or optional.",
        default: !1
      },
      schema: {
        $ref: "#/definitions/schema"
      }
    },
    additionalProperties: !1
  },
  headerParameterSubSchema: {
    additionalProperties: !1,
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    },
    properties: {
      required: {
        type: "boolean",
        description: "Determines whether or not this parameter is required or optional.",
        default: !1
      },
      in: {
        type: "string",
        description: "Determines the location of the parameter.",
        enum: [
          "header"
        ]
      },
      description: {
        type: "string",
        description: "A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed."
      },
      name: {
        type: "string",
        description: "The name of the parameter."
      },
      type: {
        type: "string",
        enum: [
          "string",
          "number",
          "boolean",
          "integer",
          "array"
        ]
      },
      format: {
        type: "string"
      },
      items: {
        $ref: "#/definitions/primitivesItems"
      },
      collectionFormat: {
        $ref: "#/definitions/collectionFormat"
      },
      default: {
        $ref: "#/definitions/default"
      },
      maximum: {
        $ref: "#/definitions/maximum"
      },
      exclusiveMaximum: {
        $ref: "#/definitions/exclusiveMaximum"
      },
      minimum: {
        $ref: "#/definitions/minimum"
      },
      exclusiveMinimum: {
        $ref: "#/definitions/exclusiveMinimum"
      },
      maxLength: {
        $ref: "#/definitions/maxLength"
      },
      minLength: {
        $ref: "#/definitions/minLength"
      },
      pattern: {
        $ref: "#/definitions/pattern"
      },
      maxItems: {
        $ref: "#/definitions/maxItems"
      },
      minItems: {
        $ref: "#/definitions/minItems"
      },
      uniqueItems: {
        $ref: "#/definitions/uniqueItems"
      },
      enum: {
        $ref: "#/definitions/enum"
      },
      multipleOf: {
        $ref: "#/definitions/multipleOf"
      }
    }
  },
  queryParameterSubSchema: {
    additionalProperties: !1,
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    },
    properties: {
      required: {
        type: "boolean",
        description: "Determines whether or not this parameter is required or optional.",
        default: !1
      },
      in: {
        type: "string",
        description: "Determines the location of the parameter.",
        enum: [
          "query"
        ]
      },
      description: {
        type: "string",
        description: "A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed."
      },
      name: {
        type: "string",
        description: "The name of the parameter."
      },
      allowEmptyValue: {
        type: "boolean",
        default: !1,
        description: "allows sending a parameter by name only or with an empty value."
      },
      type: {
        type: "string",
        enum: [
          "string",
          "number",
          "boolean",
          "integer",
          "array"
        ]
      },
      format: {
        type: "string"
      },
      items: {
        $ref: "#/definitions/primitivesItems"
      },
      collectionFormat: {
        $ref: "#/definitions/collectionFormatWithMulti"
      },
      default: {
        $ref: "#/definitions/default"
      },
      maximum: {
        $ref: "#/definitions/maximum"
      },
      exclusiveMaximum: {
        $ref: "#/definitions/exclusiveMaximum"
      },
      minimum: {
        $ref: "#/definitions/minimum"
      },
      exclusiveMinimum: {
        $ref: "#/definitions/exclusiveMinimum"
      },
      maxLength: {
        $ref: "#/definitions/maxLength"
      },
      minLength: {
        $ref: "#/definitions/minLength"
      },
      pattern: {
        $ref: "#/definitions/pattern"
      },
      maxItems: {
        $ref: "#/definitions/maxItems"
      },
      minItems: {
        $ref: "#/definitions/minItems"
      },
      uniqueItems: {
        $ref: "#/definitions/uniqueItems"
      },
      enum: {
        $ref: "#/definitions/enum"
      },
      multipleOf: {
        $ref: "#/definitions/multipleOf"
      }
    }
  },
  formDataParameterSubSchema: {
    additionalProperties: !1,
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    },
    properties: {
      required: {
        type: "boolean",
        description: "Determines whether or not this parameter is required or optional.",
        default: !1
      },
      in: {
        type: "string",
        description: "Determines the location of the parameter.",
        enum: [
          "formData"
        ]
      },
      description: {
        type: "string",
        description: "A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed."
      },
      name: {
        type: "string",
        description: "The name of the parameter."
      },
      allowEmptyValue: {
        type: "boolean",
        default: !1,
        description: "allows sending a parameter by name only or with an empty value."
      },
      type: {
        type: "string",
        enum: [
          "string",
          "number",
          "boolean",
          "integer",
          "array",
          "file"
        ]
      },
      format: {
        type: "string"
      },
      items: {
        $ref: "#/definitions/primitivesItems"
      },
      collectionFormat: {
        $ref: "#/definitions/collectionFormatWithMulti"
      },
      default: {
        $ref: "#/definitions/default"
      },
      maximum: {
        $ref: "#/definitions/maximum"
      },
      exclusiveMaximum: {
        $ref: "#/definitions/exclusiveMaximum"
      },
      minimum: {
        $ref: "#/definitions/minimum"
      },
      exclusiveMinimum: {
        $ref: "#/definitions/exclusiveMinimum"
      },
      maxLength: {
        $ref: "#/definitions/maxLength"
      },
      minLength: {
        $ref: "#/definitions/minLength"
      },
      pattern: {
        $ref: "#/definitions/pattern"
      },
      maxItems: {
        $ref: "#/definitions/maxItems"
      },
      minItems: {
        $ref: "#/definitions/minItems"
      },
      uniqueItems: {
        $ref: "#/definitions/uniqueItems"
      },
      enum: {
        $ref: "#/definitions/enum"
      },
      multipleOf: {
        $ref: "#/definitions/multipleOf"
      }
    }
  },
  pathParameterSubSchema: {
    additionalProperties: !1,
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    },
    required: [
      "required"
    ],
    properties: {
      required: {
        type: "boolean",
        enum: [
          !0
        ],
        description: "Determines whether or not this parameter is required or optional."
      },
      in: {
        type: "string",
        description: "Determines the location of the parameter.",
        enum: [
          "path"
        ]
      },
      description: {
        type: "string",
        description: "A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed."
      },
      name: {
        type: "string",
        description: "The name of the parameter."
      },
      type: {
        type: "string",
        enum: [
          "string",
          "number",
          "boolean",
          "integer",
          "array"
        ]
      },
      format: {
        type: "string"
      },
      items: {
        $ref: "#/definitions/primitivesItems"
      },
      collectionFormat: {
        $ref: "#/definitions/collectionFormat"
      },
      default: {
        $ref: "#/definitions/default"
      },
      maximum: {
        $ref: "#/definitions/maximum"
      },
      exclusiveMaximum: {
        $ref: "#/definitions/exclusiveMaximum"
      },
      minimum: {
        $ref: "#/definitions/minimum"
      },
      exclusiveMinimum: {
        $ref: "#/definitions/exclusiveMinimum"
      },
      maxLength: {
        $ref: "#/definitions/maxLength"
      },
      minLength: {
        $ref: "#/definitions/minLength"
      },
      pattern: {
        $ref: "#/definitions/pattern"
      },
      maxItems: {
        $ref: "#/definitions/maxItems"
      },
      minItems: {
        $ref: "#/definitions/minItems"
      },
      uniqueItems: {
        $ref: "#/definitions/uniqueItems"
      },
      enum: {
        $ref: "#/definitions/enum"
      },
      multipleOf: {
        $ref: "#/definitions/multipleOf"
      }
    }
  },
  nonBodyParameter: {
    type: "object",
    required: [
      "name",
      "in",
      "type"
    ],
    oneOf: [
      {
        $ref: "#/definitions/headerParameterSubSchema"
      },
      {
        $ref: "#/definitions/formDataParameterSubSchema"
      },
      {
        $ref: "#/definitions/queryParameterSubSchema"
      },
      {
        $ref: "#/definitions/pathParameterSubSchema"
      }
    ]
  },
  parameter: {
    oneOf: [
      {
        $ref: "#/definitions/bodyParameter"
      },
      {
        $ref: "#/definitions/nonBodyParameter"
      }
    ]
  },
  schema: {
    type: "object",
    description: "A deterministic version of a JSON Schema object.",
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    },
    properties: {
      $ref: {
        type: "string"
      },
      format: {
        type: "string"
      },
      title: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/title"
      },
      description: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/description"
      },
      default: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/default"
      },
      multipleOf: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/multipleOf"
      },
      maximum: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/maximum"
      },
      exclusiveMaximum: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/exclusiveMaximum"
      },
      minimum: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/minimum"
      },
      exclusiveMinimum: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/exclusiveMinimum"
      },
      maxLength: {
        $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveInteger"
      },
      minLength: {
        $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0"
      },
      pattern: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/pattern"
      },
      maxItems: {
        $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveInteger"
      },
      minItems: {
        $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0"
      },
      uniqueItems: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/uniqueItems"
      },
      maxProperties: {
        $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveInteger"
      },
      minProperties: {
        $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0"
      },
      required: {
        $ref: "http://json-schema.org/draft-04/schema#/definitions/stringArray"
      },
      enum: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/enum"
      },
      additionalProperties: {
        anyOf: [
          {
            $ref: "#/definitions/schema"
          },
          {
            type: "boolean"
          }
        ],
        default: {}
      },
      type: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/type"
      },
      items: {
        anyOf: [
          {
            $ref: "#/definitions/schema"
          },
          {
            type: "array",
            minItems: 1,
            items: {
              $ref: "#/definitions/schema"
            }
          }
        ],
        default: {}
      },
      allOf: {
        type: "array",
        minItems: 1,
        items: {
          $ref: "#/definitions/schema"
        }
      },
      properties: {
        type: "object",
        additionalProperties: {
          $ref: "#/definitions/schema"
        },
        default: {}
      },
      discriminator: {
        type: "string"
      },
      readOnly: {
        type: "boolean",
        default: !1
      },
      xml: {
        $ref: "#/definitions/xml"
      },
      externalDocs: {
        $ref: "#/definitions/externalDocs"
      },
      example: {}
    },
    additionalProperties: !1
  },
  fileSchema: {
    type: "object",
    description: "A deterministic version of a JSON Schema object.",
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    },
    required: [
      "type"
    ],
    properties: {
      format: {
        type: "string"
      },
      title: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/title"
      },
      description: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/description"
      },
      default: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/default"
      },
      required: {
        $ref: "http://json-schema.org/draft-04/schema#/definitions/stringArray"
      },
      type: {
        type: "string",
        enum: [
          "file"
        ]
      },
      readOnly: {
        type: "boolean",
        default: !1
      },
      externalDocs: {
        $ref: "#/definitions/externalDocs"
      },
      example: {}
    },
    additionalProperties: !1
  },
  primitivesItems: {
    type: "object",
    additionalProperties: !1,
    properties: {
      type: {
        type: "string",
        enum: [
          "string",
          "number",
          "integer",
          "boolean",
          "array"
        ]
      },
      format: {
        type: "string"
      },
      items: {
        $ref: "#/definitions/primitivesItems"
      },
      collectionFormat: {
        $ref: "#/definitions/collectionFormat"
      },
      default: {
        $ref: "#/definitions/default"
      },
      maximum: {
        $ref: "#/definitions/maximum"
      },
      exclusiveMaximum: {
        $ref: "#/definitions/exclusiveMaximum"
      },
      minimum: {
        $ref: "#/definitions/minimum"
      },
      exclusiveMinimum: {
        $ref: "#/definitions/exclusiveMinimum"
      },
      maxLength: {
        $ref: "#/definitions/maxLength"
      },
      minLength: {
        $ref: "#/definitions/minLength"
      },
      pattern: {
        $ref: "#/definitions/pattern"
      },
      maxItems: {
        $ref: "#/definitions/maxItems"
      },
      minItems: {
        $ref: "#/definitions/minItems"
      },
      uniqueItems: {
        $ref: "#/definitions/uniqueItems"
      },
      enum: {
        $ref: "#/definitions/enum"
      },
      multipleOf: {
        $ref: "#/definitions/multipleOf"
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  security: {
    type: "array",
    items: {
      $ref: "#/definitions/securityRequirement"
    },
    uniqueItems: !0
  },
  securityRequirement: {
    type: "object",
    additionalProperties: {
      type: "array",
      items: {
        type: "string"
      },
      uniqueItems: !0
    }
  },
  xml: {
    type: "object",
    additionalProperties: !1,
    properties: {
      name: {
        type: "string"
      },
      namespace: {
        type: "string"
      },
      prefix: {
        type: "string"
      },
      attribute: {
        type: "boolean",
        default: !1
      },
      wrapped: {
        type: "boolean",
        default: !1
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  tag: {
    type: "object",
    additionalProperties: !1,
    required: [
      "name"
    ],
    properties: {
      name: {
        type: "string"
      },
      description: {
        type: "string"
      },
      externalDocs: {
        $ref: "#/definitions/externalDocs"
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  securityDefinitions: {
    type: "object",
    additionalProperties: {
      oneOf: [
        {
          $ref: "#/definitions/basicAuthenticationSecurity"
        },
        {
          $ref: "#/definitions/apiKeySecurity"
        },
        {
          $ref: "#/definitions/oauth2ImplicitSecurity"
        },
        {
          $ref: "#/definitions/oauth2PasswordSecurity"
        },
        {
          $ref: "#/definitions/oauth2ApplicationSecurity"
        },
        {
          $ref: "#/definitions/oauth2AccessCodeSecurity"
        }
      ]
    }
  },
  basicAuthenticationSecurity: {
    type: "object",
    additionalProperties: !1,
    required: [
      "type"
    ],
    properties: {
      type: {
        type: "string",
        enum: [
          "basic"
        ]
      },
      description: {
        type: "string"
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  apiKeySecurity: {
    type: "object",
    additionalProperties: !1,
    required: [
      "type",
      "name",
      "in"
    ],
    properties: {
      type: {
        type: "string",
        enum: [
          "apiKey"
        ]
      },
      name: {
        type: "string"
      },
      in: {
        type: "string",
        enum: [
          "header",
          "query"
        ]
      },
      description: {
        type: "string"
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  oauth2ImplicitSecurity: {
    type: "object",
    additionalProperties: !1,
    required: [
      "type",
      "flow",
      "authorizationUrl"
    ],
    properties: {
      type: {
        type: "string",
        enum: [
          "oauth2"
        ]
      },
      flow: {
        type: "string",
        enum: [
          "implicit"
        ]
      },
      scopes: {
        $ref: "#/definitions/oauth2Scopes"
      },
      authorizationUrl: {
        type: "string",
        format: "uri"
      },
      description: {
        type: "string"
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  oauth2PasswordSecurity: {
    type: "object",
    additionalProperties: !1,
    required: [
      "type",
      "flow",
      "tokenUrl"
    ],
    properties: {
      type: {
        type: "string",
        enum: [
          "oauth2"
        ]
      },
      flow: {
        type: "string",
        enum: [
          "password"
        ]
      },
      scopes: {
        $ref: "#/definitions/oauth2Scopes"
      },
      tokenUrl: {
        type: "string",
        format: "uri"
      },
      description: {
        type: "string"
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  oauth2ApplicationSecurity: {
    type: "object",
    additionalProperties: !1,
    required: [
      "type",
      "flow",
      "tokenUrl"
    ],
    properties: {
      type: {
        type: "string",
        enum: [
          "oauth2"
        ]
      },
      flow: {
        type: "string",
        enum: [
          "application"
        ]
      },
      scopes: {
        $ref: "#/definitions/oauth2Scopes"
      },
      tokenUrl: {
        type: "string",
        format: "uri"
      },
      description: {
        type: "string"
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  oauth2AccessCodeSecurity: {
    type: "object",
    additionalProperties: !1,
    required: [
      "type",
      "flow",
      "authorizationUrl",
      "tokenUrl"
    ],
    properties: {
      type: {
        type: "string",
        enum: [
          "oauth2"
        ]
      },
      flow: {
        type: "string",
        enum: [
          "accessCode"
        ]
      },
      scopes: {
        $ref: "#/definitions/oauth2Scopes"
      },
      authorizationUrl: {
        type: "string",
        format: "uri"
      },
      tokenUrl: {
        type: "string",
        format: "uri"
      },
      description: {
        type: "string"
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  oauth2Scopes: {
    type: "object",
    additionalProperties: {
      type: "string"
    }
  },
  mediaTypeList: {
    type: "array",
    items: {
      $ref: "#/definitions/mimeType"
    },
    uniqueItems: !0
  },
  parametersList: {
    type: "array",
    description: "The parameters needed to send a valid API call.",
    additionalItems: !1,
    items: {
      oneOf: [
        {
          $ref: "#/definitions/parameter"
        },
        {
          $ref: "#/definitions/jsonReference"
        }
      ]
    },
    uniqueItems: !0
  },
  schemesList: {
    type: "array",
    description: "The transfer protocol of the API.",
    items: {
      type: "string",
      enum: [
        "http",
        "https",
        "ws",
        "wss"
      ]
    },
    uniqueItems: !0
  },
  collectionFormat: {
    type: "string",
    enum: [
      "csv",
      "ssv",
      "tsv",
      "pipes"
    ],
    default: "csv"
  },
  collectionFormatWithMulti: {
    type: "string",
    enum: [
      "csv",
      "ssv",
      "tsv",
      "pipes",
      "multi"
    ],
    default: "csv"
  },
  title: {
    $ref: "http://json-schema.org/draft-04/schema#/properties/title"
  },
  description: {
    $ref: "http://json-schema.org/draft-04/schema#/properties/description"
  },
  default: {
    $ref: "http://json-schema.org/draft-04/schema#/properties/default"
  },
  multipleOf: {
    $ref: "http://json-schema.org/draft-04/schema#/properties/multipleOf"
  },
  maximum: {
    $ref: "http://json-schema.org/draft-04/schema#/properties/maximum"
  },
  exclusiveMaximum: {
    $ref: "http://json-schema.org/draft-04/schema#/properties/exclusiveMaximum"
  },
  minimum: {
    $ref: "http://json-schema.org/draft-04/schema#/properties/minimum"
  },
  exclusiveMinimum: {
    $ref: "http://json-schema.org/draft-04/schema#/properties/exclusiveMinimum"
  },
  maxLength: {
    $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveInteger"
  },
  minLength: {
    $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0"
  },
  pattern: {
    $ref: "http://json-schema.org/draft-04/schema#/properties/pattern"
  },
  maxItems: {
    $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveInteger"
  },
  minItems: {
    $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0"
  },
  uniqueItems: {
    $ref: "http://json-schema.org/draft-04/schema#/properties/uniqueItems"
  },
  enum: {
    $ref: "http://json-schema.org/draft-04/schema#/properties/enum"
  },
  jsonReference: {
    type: "object",
    required: [
      "$ref"
    ],
    additionalProperties: !1,
    properties: {
      $ref: {
        type: "string"
      }
    }
  }
}, Lq = {
  title: Cq,
  id: Rq,
  $schema: Tq,
  type: Iq,
  required: jq,
  additionalProperties: kq,
  patternProperties: Mq,
  properties: Nq,
  definitions: Dq
}, qq = "https://spec.openapis.org/oas/3.0/schema/2019-04-02", Fq = "http://json-schema.org/draft-04/schema#", Uq = "Validation schema for OpenAPI Specification 3.0.X.", Bq = "object", Vq = [
  "openapi",
  "info",
  "paths"
], Zq = {
  openapi: {
    type: "string",
    pattern: "^3\\.0\\.\\d(-.+)?$"
  },
  info: {
    $ref: "#/definitions/Info"
  },
  externalDocs: {
    $ref: "#/definitions/ExternalDocumentation"
  },
  servers: {
    type: "array",
    items: {
      $ref: "#/definitions/Server"
    }
  },
  security: {
    type: "array",
    items: {
      $ref: "#/definitions/SecurityRequirement"
    }
  },
  tags: {
    type: "array",
    items: {
      $ref: "#/definitions/Tag"
    },
    uniqueItems: !0
  },
  paths: {
    $ref: "#/definitions/Paths"
  },
  components: {
    $ref: "#/definitions/Components"
  }
}, zq = {
  "^x-": {}
}, Wq = !1, Hq = {
  Reference: {
    type: "object",
    required: [
      "$ref"
    ],
    patternProperties: {
      "^\\$ref$": {
        type: "string",
        format: "uri-reference"
      }
    }
  },
  Info: {
    type: "object",
    required: [
      "title",
      "version"
    ],
    properties: {
      title: {
        type: "string"
      },
      description: {
        type: "string"
      },
      termsOfService: {
        type: "string",
        format: "uri-reference"
      },
      contact: {
        $ref: "#/definitions/Contact"
      },
      license: {
        $ref: "#/definitions/License"
      },
      version: {
        type: "string"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  Contact: {
    type: "object",
    properties: {
      name: {
        type: "string"
      },
      url: {
        type: "string",
        format: "uri-reference"
      },
      email: {
        type: "string",
        format: "email"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  License: {
    type: "object",
    required: [
      "name"
    ],
    properties: {
      name: {
        type: "string"
      },
      url: {
        type: "string",
        format: "uri-reference"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  Server: {
    type: "object",
    required: [
      "url"
    ],
    properties: {
      url: {
        type: "string"
      },
      description: {
        type: "string"
      },
      variables: {
        type: "object",
        additionalProperties: {
          $ref: "#/definitions/ServerVariable"
        }
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  ServerVariable: {
    type: "object",
    required: [
      "default"
    ],
    properties: {
      enum: {
        type: "array",
        items: {
          type: "string"
        }
      },
      default: {
        type: "string"
      },
      description: {
        type: "string"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  Components: {
    type: "object",
    properties: {
      schemas: {
        type: "object",
        patternProperties: {
          "^[a-zA-Z0-9\\.\\-_]+$": {
            oneOf: [
              {
                $ref: "#/definitions/Schema"
              },
              {
                $ref: "#/definitions/Reference"
              }
            ]
          }
        }
      },
      responses: {
        type: "object",
        patternProperties: {
          "^[a-zA-Z0-9\\.\\-_]+$": {
            oneOf: [
              {
                $ref: "#/definitions/Reference"
              },
              {
                $ref: "#/definitions/Response"
              }
            ]
          }
        }
      },
      parameters: {
        type: "object",
        patternProperties: {
          "^[a-zA-Z0-9\\.\\-_]+$": {
            oneOf: [
              {
                $ref: "#/definitions/Reference"
              },
              {
                $ref: "#/definitions/Parameter"
              }
            ]
          }
        }
      },
      examples: {
        type: "object",
        patternProperties: {
          "^[a-zA-Z0-9\\.\\-_]+$": {
            oneOf: [
              {
                $ref: "#/definitions/Reference"
              },
              {
                $ref: "#/definitions/Example"
              }
            ]
          }
        }
      },
      requestBodies: {
        type: "object",
        patternProperties: {
          "^[a-zA-Z0-9\\.\\-_]+$": {
            oneOf: [
              {
                $ref: "#/definitions/Reference"
              },
              {
                $ref: "#/definitions/RequestBody"
              }
            ]
          }
        }
      },
      headers: {
        type: "object",
        patternProperties: {
          "^[a-zA-Z0-9\\.\\-_]+$": {
            oneOf: [
              {
                $ref: "#/definitions/Reference"
              },
              {
                $ref: "#/definitions/Header"
              }
            ]
          }
        }
      },
      securitySchemes: {
        type: "object",
        patternProperties: {
          "^[a-zA-Z0-9\\.\\-_]+$": {
            oneOf: [
              {
                $ref: "#/definitions/Reference"
              },
              {
                $ref: "#/definitions/SecurityScheme"
              }
            ]
          }
        }
      },
      links: {
        type: "object",
        patternProperties: {
          "^[a-zA-Z0-9\\.\\-_]+$": {
            oneOf: [
              {
                $ref: "#/definitions/Reference"
              },
              {
                $ref: "#/definitions/Link"
              }
            ]
          }
        }
      },
      callbacks: {
        type: "object",
        patternProperties: {
          "^[a-zA-Z0-9\\.\\-_]+$": {
            oneOf: [
              {
                $ref: "#/definitions/Reference"
              },
              {
                $ref: "#/definitions/Callback"
              }
            ]
          }
        }
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  Schema: {
    type: "object",
    properties: {
      title: {
        type: "string"
      },
      multipleOf: {
        type: "number",
        minimum: 0,
        exclusiveMinimum: !0
      },
      maximum: {
        type: "number"
      },
      exclusiveMaximum: {
        type: "boolean",
        default: !1
      },
      minimum: {
        type: "number"
      },
      exclusiveMinimum: {
        type: "boolean",
        default: !1
      },
      maxLength: {
        type: "integer",
        minimum: 0
      },
      minLength: {
        type: "integer",
        minimum: 0,
        default: 0
      },
      pattern: {
        type: "string",
        format: "regex"
      },
      maxItems: {
        type: "integer",
        minimum: 0
      },
      minItems: {
        type: "integer",
        minimum: 0,
        default: 0
      },
      uniqueItems: {
        type: "boolean",
        default: !1
      },
      maxProperties: {
        type: "integer",
        minimum: 0
      },
      minProperties: {
        type: "integer",
        minimum: 0,
        default: 0
      },
      required: {
        type: "array",
        items: {
          type: "string"
        },
        minItems: 1,
        uniqueItems: !0
      },
      enum: {
        type: "array",
        items: {},
        minItems: 1,
        uniqueItems: !1
      },
      type: {
        type: "string",
        enum: [
          "array",
          "boolean",
          "integer",
          "number",
          "object",
          "string"
        ]
      },
      not: {
        oneOf: [
          {
            $ref: "#/definitions/Schema"
          },
          {
            $ref: "#/definitions/Reference"
          }
        ]
      },
      allOf: {
        type: "array",
        items: {
          oneOf: [
            {
              $ref: "#/definitions/Schema"
            },
            {
              $ref: "#/definitions/Reference"
            }
          ]
        }
      },
      oneOf: {
        type: "array",
        items: {
          oneOf: [
            {
              $ref: "#/definitions/Schema"
            },
            {
              $ref: "#/definitions/Reference"
            }
          ]
        }
      },
      anyOf: {
        type: "array",
        items: {
          oneOf: [
            {
              $ref: "#/definitions/Schema"
            },
            {
              $ref: "#/definitions/Reference"
            }
          ]
        }
      },
      items: {
        oneOf: [
          {
            $ref: "#/definitions/Schema"
          },
          {
            $ref: "#/definitions/Reference"
          }
        ]
      },
      properties: {
        type: "object",
        additionalProperties: {
          oneOf: [
            {
              $ref: "#/definitions/Schema"
            },
            {
              $ref: "#/definitions/Reference"
            }
          ]
        }
      },
      additionalProperties: {
        oneOf: [
          {
            $ref: "#/definitions/Schema"
          },
          {
            $ref: "#/definitions/Reference"
          },
          {
            type: "boolean"
          }
        ],
        default: !0
      },
      description: {
        type: "string"
      },
      format: {
        type: "string"
      },
      default: {},
      nullable: {
        type: "boolean",
        default: !1
      },
      discriminator: {
        $ref: "#/definitions/Discriminator"
      },
      readOnly: {
        type: "boolean",
        default: !1
      },
      writeOnly: {
        type: "boolean",
        default: !1
      },
      example: {},
      externalDocs: {
        $ref: "#/definitions/ExternalDocumentation"
      },
      deprecated: {
        type: "boolean",
        default: !1
      },
      xml: {
        $ref: "#/definitions/XML"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  Discriminator: {
    type: "object",
    required: [
      "propertyName"
    ],
    properties: {
      propertyName: {
        type: "string"
      },
      mapping: {
        type: "object",
        additionalProperties: {
          type: "string"
        }
      }
    }
  },
  XML: {
    type: "object",
    properties: {
      name: {
        type: "string"
      },
      namespace: {
        type: "string",
        format: "uri"
      },
      prefix: {
        type: "string"
      },
      attribute: {
        type: "boolean",
        default: !1
      },
      wrapped: {
        type: "boolean",
        default: !1
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  Response: {
    type: "object",
    required: [
      "description"
    ],
    properties: {
      description: {
        type: "string"
      },
      headers: {
        type: "object",
        additionalProperties: {
          oneOf: [
            {
              $ref: "#/definitions/Header"
            },
            {
              $ref: "#/definitions/Reference"
            }
          ]
        }
      },
      content: {
        type: "object",
        additionalProperties: {
          $ref: "#/definitions/MediaType"
        }
      },
      links: {
        type: "object",
        additionalProperties: {
          oneOf: [
            {
              $ref: "#/definitions/Link"
            },
            {
              $ref: "#/definitions/Reference"
            }
          ]
        }
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  MediaType: {
    type: "object",
    properties: {
      schema: {
        oneOf: [
          {
            $ref: "#/definitions/Schema"
          },
          {
            $ref: "#/definitions/Reference"
          }
        ]
      },
      example: {},
      examples: {
        type: "object",
        additionalProperties: {
          oneOf: [
            {
              $ref: "#/definitions/Example"
            },
            {
              $ref: "#/definitions/Reference"
            }
          ]
        }
      },
      encoding: {
        type: "object",
        additionalProperties: {
          $ref: "#/definitions/Encoding"
        }
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1,
    allOf: [
      {
        $ref: "#/definitions/ExampleXORExamples"
      }
    ]
  },
  Example: {
    type: "object",
    properties: {
      summary: {
        type: "string"
      },
      description: {
        type: "string"
      },
      value: {},
      externalValue: {
        type: "string",
        format: "uri-reference"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  Header: {
    type: "object",
    properties: {
      description: {
        type: "string"
      },
      required: {
        type: "boolean",
        default: !1
      },
      deprecated: {
        type: "boolean",
        default: !1
      },
      allowEmptyValue: {
        type: "boolean",
        default: !1
      },
      style: {
        type: "string",
        enum: [
          "simple"
        ],
        default: "simple"
      },
      explode: {
        type: "boolean"
      },
      allowReserved: {
        type: "boolean",
        default: !1
      },
      schema: {
        oneOf: [
          {
            $ref: "#/definitions/Schema"
          },
          {
            $ref: "#/definitions/Reference"
          }
        ]
      },
      content: {
        type: "object",
        additionalProperties: {
          $ref: "#/definitions/MediaType"
        },
        minProperties: 1,
        maxProperties: 1
      },
      example: {},
      examples: {
        type: "object",
        additionalProperties: {
          oneOf: [
            {
              $ref: "#/definitions/Example"
            },
            {
              $ref: "#/definitions/Reference"
            }
          ]
        }
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1,
    allOf: [
      {
        $ref: "#/definitions/ExampleXORExamples"
      },
      {
        $ref: "#/definitions/SchemaXORContent"
      }
    ]
  },
  Paths: {
    type: "object",
    patternProperties: {
      "^\\/": {
        $ref: "#/definitions/PathItem"
      },
      "^x-": {}
    },
    additionalProperties: !1
  },
  PathItem: {
    type: "object",
    properties: {
      $ref: {
        type: "string"
      },
      summary: {
        type: "string"
      },
      description: {
        type: "string"
      },
      servers: {
        type: "array",
        items: {
          $ref: "#/definitions/Server"
        }
      },
      parameters: {
        type: "array",
        items: {
          oneOf: [
            {
              $ref: "#/definitions/Parameter"
            },
            {
              $ref: "#/definitions/Reference"
            }
          ]
        },
        uniqueItems: !0
      }
    },
    patternProperties: {
      "^(get|put|post|delete|options|head|patch|trace)$": {
        $ref: "#/definitions/Operation"
      },
      "^x-": {}
    },
    additionalProperties: !1
  },
  Operation: {
    type: "object",
    required: [
      "responses"
    ],
    properties: {
      tags: {
        type: "array",
        items: {
          type: "string"
        }
      },
      summary: {
        type: "string"
      },
      description: {
        type: "string"
      },
      externalDocs: {
        $ref: "#/definitions/ExternalDocumentation"
      },
      operationId: {
        type: "string"
      },
      parameters: {
        type: "array",
        items: {
          oneOf: [
            {
              $ref: "#/definitions/Parameter"
            },
            {
              $ref: "#/definitions/Reference"
            }
          ]
        },
        uniqueItems: !0
      },
      requestBody: {
        oneOf: [
          {
            $ref: "#/definitions/RequestBody"
          },
          {
            $ref: "#/definitions/Reference"
          }
        ]
      },
      responses: {
        $ref: "#/definitions/Responses"
      },
      callbacks: {
        type: "object",
        additionalProperties: {
          oneOf: [
            {
              $ref: "#/definitions/Callback"
            },
            {
              $ref: "#/definitions/Reference"
            }
          ]
        }
      },
      deprecated: {
        type: "boolean",
        default: !1
      },
      security: {
        type: "array",
        items: {
          $ref: "#/definitions/SecurityRequirement"
        }
      },
      servers: {
        type: "array",
        items: {
          $ref: "#/definitions/Server"
        }
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  Responses: {
    type: "object",
    properties: {
      default: {
        oneOf: [
          {
            $ref: "#/definitions/Response"
          },
          {
            $ref: "#/definitions/Reference"
          }
        ]
      }
    },
    patternProperties: {
      "^[1-5](?:\\d{2}|XX)$": {
        oneOf: [
          {
            $ref: "#/definitions/Response"
          },
          {
            $ref: "#/definitions/Reference"
          }
        ]
      },
      "^x-": {}
    },
    minProperties: 1,
    additionalProperties: !1
  },
  SecurityRequirement: {
    type: "object",
    additionalProperties: {
      type: "array",
      items: {
        type: "string"
      }
    }
  },
  Tag: {
    type: "object",
    required: [
      "name"
    ],
    properties: {
      name: {
        type: "string"
      },
      description: {
        type: "string"
      },
      externalDocs: {
        $ref: "#/definitions/ExternalDocumentation"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  ExternalDocumentation: {
    type: "object",
    required: [
      "url"
    ],
    properties: {
      description: {
        type: "string"
      },
      url: {
        type: "string",
        format: "uri-reference"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  ExampleXORExamples: {
    description: "Example and examples are mutually exclusive",
    not: {
      required: [
        "example",
        "examples"
      ]
    }
  },
  SchemaXORContent: {
    description: "Schema and content are mutually exclusive, at least one is required",
    not: {
      required: [
        "schema",
        "content"
      ]
    },
    oneOf: [
      {
        required: [
          "schema"
        ]
      },
      {
        required: [
          "content"
        ],
        description: "Some properties are not allowed if content is present",
        allOf: [
          {
            not: {
              required: [
                "style"
              ]
            }
          },
          {
            not: {
              required: [
                "explode"
              ]
            }
          },
          {
            not: {
              required: [
                "allowReserved"
              ]
            }
          },
          {
            not: {
              required: [
                "example"
              ]
            }
          },
          {
            not: {
              required: [
                "examples"
              ]
            }
          }
        ]
      }
    ]
  },
  Parameter: {
    type: "object",
    properties: {
      name: {
        type: "string"
      },
      in: {
        type: "string"
      },
      description: {
        type: "string"
      },
      required: {
        type: "boolean",
        default: !1
      },
      deprecated: {
        type: "boolean",
        default: !1
      },
      allowEmptyValue: {
        type: "boolean",
        default: !1
      },
      style: {
        type: "string"
      },
      explode: {
        type: "boolean"
      },
      allowReserved: {
        type: "boolean",
        default: !1
      },
      schema: {
        oneOf: [
          {
            $ref: "#/definitions/Schema"
          },
          {
            $ref: "#/definitions/Reference"
          }
        ]
      },
      content: {
        type: "object",
        additionalProperties: {
          $ref: "#/definitions/MediaType"
        },
        minProperties: 1,
        maxProperties: 1
      },
      example: {},
      examples: {
        type: "object",
        additionalProperties: {
          oneOf: [
            {
              $ref: "#/definitions/Example"
            },
            {
              $ref: "#/definitions/Reference"
            }
          ]
        }
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1,
    required: [
      "name",
      "in"
    ],
    allOf: [
      {
        $ref: "#/definitions/ExampleXORExamples"
      },
      {
        $ref: "#/definitions/SchemaXORContent"
      },
      {
        $ref: "#/definitions/ParameterLocation"
      }
    ]
  },
  ParameterLocation: {
    description: "Parameter location",
    oneOf: [
      {
        description: "Parameter in path",
        required: [
          "required"
        ],
        properties: {
          in: {
            enum: [
              "path"
            ]
          },
          style: {
            enum: [
              "matrix",
              "label",
              "simple"
            ],
            default: "simple"
          },
          required: {
            enum: [
              !0
            ]
          }
        }
      },
      {
        description: "Parameter in query",
        properties: {
          in: {
            enum: [
              "query"
            ]
          },
          style: {
            enum: [
              "form",
              "spaceDelimited",
              "pipeDelimited",
              "deepObject"
            ],
            default: "form"
          }
        }
      },
      {
        description: "Parameter in header",
        properties: {
          in: {
            enum: [
              "header"
            ]
          },
          style: {
            enum: [
              "simple"
            ],
            default: "simple"
          }
        }
      },
      {
        description: "Parameter in cookie",
        properties: {
          in: {
            enum: [
              "cookie"
            ]
          },
          style: {
            enum: [
              "form"
            ],
            default: "form"
          }
        }
      }
    ]
  },
  RequestBody: {
    type: "object",
    required: [
      "content"
    ],
    properties: {
      description: {
        type: "string"
      },
      content: {
        type: "object",
        additionalProperties: {
          $ref: "#/definitions/MediaType"
        }
      },
      required: {
        type: "boolean",
        default: !1
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  SecurityScheme: {
    oneOf: [
      {
        $ref: "#/definitions/APIKeySecurityScheme"
      },
      {
        $ref: "#/definitions/HTTPSecurityScheme"
      },
      {
        $ref: "#/definitions/OAuth2SecurityScheme"
      },
      {
        $ref: "#/definitions/OpenIdConnectSecurityScheme"
      }
    ]
  },
  APIKeySecurityScheme: {
    type: "object",
    required: [
      "type",
      "name",
      "in"
    ],
    properties: {
      type: {
        type: "string",
        enum: [
          "apiKey"
        ]
      },
      name: {
        type: "string"
      },
      in: {
        type: "string",
        enum: [
          "header",
          "query",
          "cookie"
        ]
      },
      description: {
        type: "string"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  HTTPSecurityScheme: {
    type: "object",
    required: [
      "scheme",
      "type"
    ],
    properties: {
      scheme: {
        type: "string"
      },
      bearerFormat: {
        type: "string"
      },
      description: {
        type: "string"
      },
      type: {
        type: "string",
        enum: [
          "http"
        ]
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1,
    oneOf: [
      {
        description: "Bearer",
        properties: {
          scheme: {
            enum: [
              "bearer"
            ]
          }
        }
      },
      {
        description: "Non Bearer",
        not: {
          required: [
            "bearerFormat"
          ]
        },
        properties: {
          scheme: {
            not: {
              enum: [
                "bearer"
              ]
            }
          }
        }
      }
    ]
  },
  OAuth2SecurityScheme: {
    type: "object",
    required: [
      "type",
      "flows"
    ],
    properties: {
      type: {
        type: "string",
        enum: [
          "oauth2"
        ]
      },
      flows: {
        $ref: "#/definitions/OAuthFlows"
      },
      description: {
        type: "string"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  OpenIdConnectSecurityScheme: {
    type: "object",
    required: [
      "type",
      "openIdConnectUrl"
    ],
    properties: {
      type: {
        type: "string",
        enum: [
          "openIdConnect"
        ]
      },
      openIdConnectUrl: {
        type: "string",
        format: "uri-reference"
      },
      description: {
        type: "string"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  OAuthFlows: {
    type: "object",
    properties: {
      implicit: {
        $ref: "#/definitions/ImplicitOAuthFlow"
      },
      password: {
        $ref: "#/definitions/PasswordOAuthFlow"
      },
      clientCredentials: {
        $ref: "#/definitions/ClientCredentialsFlow"
      },
      authorizationCode: {
        $ref: "#/definitions/AuthorizationCodeOAuthFlow"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  ImplicitOAuthFlow: {
    type: "object",
    required: [
      "authorizationUrl",
      "scopes"
    ],
    properties: {
      authorizationUrl: {
        type: "string",
        format: "uri-reference"
      },
      refreshUrl: {
        type: "string",
        format: "uri-reference"
      },
      scopes: {
        type: "object",
        additionalProperties: {
          type: "string"
        }
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  PasswordOAuthFlow: {
    type: "object",
    required: [
      "tokenUrl"
    ],
    properties: {
      tokenUrl: {
        type: "string",
        format: "uri-reference"
      },
      refreshUrl: {
        type: "string",
        format: "uri-reference"
      },
      scopes: {
        type: "object",
        additionalProperties: {
          type: "string"
        }
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  ClientCredentialsFlow: {
    type: "object",
    required: [
      "tokenUrl"
    ],
    properties: {
      tokenUrl: {
        type: "string",
        format: "uri-reference"
      },
      refreshUrl: {
        type: "string",
        format: "uri-reference"
      },
      scopes: {
        type: "object",
        additionalProperties: {
          type: "string"
        }
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  AuthorizationCodeOAuthFlow: {
    type: "object",
    required: [
      "authorizationUrl",
      "tokenUrl"
    ],
    properties: {
      authorizationUrl: {
        type: "string",
        format: "uri-reference"
      },
      tokenUrl: {
        type: "string",
        format: "uri-reference"
      },
      refreshUrl: {
        type: "string",
        format: "uri-reference"
      },
      scopes: {
        type: "object",
        additionalProperties: {
          type: "string"
        }
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  Link: {
    type: "object",
    properties: {
      operationId: {
        type: "string"
      },
      operationRef: {
        type: "string",
        format: "uri-reference"
      },
      parameters: {
        type: "object",
        additionalProperties: {}
      },
      requestBody: {},
      description: {
        type: "string"
      },
      server: {
        $ref: "#/definitions/Server"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1,
    not: {
      description: "Operation Id and Operation Ref are mutually exclusive",
      required: [
        "operationId",
        "operationRef"
      ]
    }
  },
  Callback: {
    type: "object",
    additionalProperties: {
      $ref: "#/definitions/PathItem"
    },
    patternProperties: {
      "^x-": {}
    }
  },
  Encoding: {
    type: "object",
    properties: {
      contentType: {
        type: "string"
      },
      headers: {
        type: "object",
        additionalProperties: {
          $ref: "#/definitions/Header"
        }
      },
      style: {
        type: "string",
        enum: [
          "form",
          "spaceDelimited",
          "pipeDelimited",
          "deepObject"
        ]
      },
      explode: {
        type: "boolean"
      },
      allowReserved: {
        type: "boolean",
        default: !1
      }
    },
    additionalProperties: !1
  }
}, Gq = {
  id: qq,
  $schema: Fq,
  description: Uq,
  type: Bq,
  required: Vq,
  properties: Zq,
  patternProperties: zq,
  additionalProperties: Wq,
  definitions: Hq
}, Kq = "https://spec.openapis.org/oas/3.1/schema/2021-04-15", Yq = "https://json-schema.org/draft/2020-12/schema", Jq = "object", Xq = {
  openapi: {
    type: "string",
    pattern: "^3\\.1\\.\\d+(-.+)?$"
  },
  info: {
    $ref: "#/$defs/info"
  },
  jsonSchemaDialect: {
    $ref: "#/$defs/uri",
    default: "https://spec.openapis.org/oas/3.1/dialect/base"
  },
  servers: {
    type: "array",
    items: {
      $ref: "#/$defs/server"
    }
  },
  paths: {
    $ref: "#/$defs/paths"
  },
  webhooks: {
    type: "object",
    additionalProperties: {
      $ref: "#/$defs/path-item-or-reference"
    }
  },
  components: {
    $ref: "#/$defs/components"
  },
  security: {
    type: "array",
    items: {
      $ref: "#/$defs/security-requirement"
    }
  },
  tags: {
    type: "array",
    items: {
      $ref: "#/$defs/tag"
    }
  },
  externalDocs: {
    $ref: "#/$defs/external-documentation"
  }
}, Qq = [
  "openapi",
  "info"
], e8 = [
  {
    required: [
      "paths"
    ]
  },
  {
    required: [
      "components"
    ]
  },
  {
    required: [
      "webhooks"
    ]
  }
], t8 = "#/$defs/specification-extensions", r8 = !1, n8 = {
  info: {
    type: "object",
    properties: {
      title: {
        type: "string"
      },
      summary: {
        type: "string"
      },
      description: {
        type: "string"
      },
      termsOfService: {
        type: "string"
      },
      contact: {
        $ref: "#/$defs/contact"
      },
      license: {
        $ref: "#/$defs/license"
      },
      version: {
        type: "string"
      }
    },
    required: [
      "title",
      "version"
    ],
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  contact: {
    type: "object",
    properties: {
      name: {
        type: "string"
      },
      url: {
        type: "string"
      },
      email: {
        type: "string"
      }
    },
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  license: {
    type: "object",
    properties: {
      name: {
        type: "string"
      },
      identifier: {
        type: "string"
      },
      url: {
        $ref: "#/$defs/uri"
      }
    },
    required: [
      "name"
    ],
    oneOf: [
      {
        required: [
          "identifier"
        ]
      },
      {
        required: [
          "url"
        ]
      }
    ],
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  server: {
    type: "object",
    properties: {
      url: {
        $ref: "#/$defs/uri"
      },
      description: {
        type: "string"
      },
      variables: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/server-variable"
        }
      }
    },
    required: [
      "url"
    ],
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  "server-variable": {
    type: "object",
    properties: {
      enum: {
        type: "array",
        items: {
          type: "string"
        },
        minItems: 1
      },
      default: {
        type: "string"
      },
      descriptions: {
        type: "string"
      }
    },
    required: [
      "default"
    ],
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  components: {
    type: "object",
    properties: {
      schemas: {
        type: "object",
        additionalProperties: {
          $dynamicRef: "#meta"
        }
      },
      responses: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/response-or-reference"
        }
      },
      parameters: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/parameter-or-reference"
        }
      },
      examples: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/example-or-reference"
        }
      },
      requestBodies: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/request-body-or-reference"
        }
      },
      headers: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/header-or-reference"
        }
      },
      securitySchemes: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/security-scheme-or-reference"
        }
      },
      links: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/link-or-reference"
        }
      },
      callbacks: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/callbacks-or-reference"
        }
      },
      pathItems: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/path-item-or-reference"
        }
      }
    },
    patternProperties: {
      "^(schemas|responses|parameters|examples|requestBodies|headers|securitySchemes|links|callbacks|pathItems)$": {
        $comment: "Enumerating all of the property names in the regex above is necessary for unevaluatedProperties to work as expected",
        propertyNames: {
          pattern: "^[a-zA-Z0-9._-]+$"
        }
      }
    },
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  paths: {
    type: "object",
    patternProperties: {
      "^/": {
        $ref: "#/$defs/path-item"
      }
    },
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  "path-item": {
    type: "object",
    properties: {
      summary: {
        type: "string"
      },
      description: {
        type: "string"
      },
      servers: {
        type: "array",
        items: {
          $ref: "#/$defs/server"
        }
      },
      parameters: {
        type: "array",
        items: {
          $ref: "#/$defs/parameter-or-reference"
        }
      }
    },
    patternProperties: {
      "^(get|put|post|delete|options|head|patch|trace)$": {
        $ref: "#/$defs/operation"
      }
    },
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  "path-item-or-reference": {
    if: {
      required: [
        "$ref"
      ]
    },
    then: {
      $ref: "#/$defs/reference"
    },
    else: {
      $ref: "#/$defs/path-item"
    }
  },
  operation: {
    type: "object",
    properties: {
      tags: {
        type: "array",
        items: {
          type: "string"
        }
      },
      summary: {
        type: "string"
      },
      description: {
        type: "string"
      },
      externalDocs: {
        $ref: "#/$defs/external-documentation"
      },
      operationId: {
        type: "string"
      },
      parameters: {
        type: "array",
        items: {
          $ref: "#/$defs/parameter-or-reference"
        }
      },
      requestBody: {
        $ref: "#/$defs/request-body-or-reference"
      },
      responses: {
        $ref: "#/$defs/responses"
      },
      callbacks: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/callbacks-or-reference"
        }
      },
      deprecated: {
        default: !1,
        type: "boolean"
      },
      security: {
        type: "array",
        items: {
          $ref: "#/$defs/security-requirement"
        }
      },
      servers: {
        type: "array",
        items: {
          $ref: "#/$defs/server"
        }
      }
    },
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  "external-documentation": {
    type: "object",
    properties: {
      description: {
        type: "string"
      },
      url: {
        $ref: "#/$defs/uri"
      }
    },
    required: [
      "url"
    ],
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  parameter: {
    type: "object",
    properties: {
      name: {
        type: "string"
      },
      in: {
        enum: [
          "query",
          "header",
          "path",
          "cookie"
        ]
      },
      description: {
        type: "string"
      },
      required: {
        default: !1,
        type: "boolean"
      },
      deprecated: {
        default: !1,
        type: "boolean"
      },
      allowEmptyValue: {
        default: !1,
        type: "boolean"
      },
      schema: {
        $dynamicRef: "#meta"
      },
      content: {
        $ref: "#/$defs/content"
      }
    },
    required: [
      "in"
    ],
    oneOf: [
      {
        required: [
          "schema"
        ]
      },
      {
        required: [
          "content"
        ]
      }
    ],
    dependentSchemas: {
      schema: {
        properties: {
          style: {
            type: "string"
          },
          explode: {
            type: "boolean"
          },
          allowReserved: {
            default: !1,
            type: "boolean"
          }
        },
        allOf: [
          {
            $ref: "#/$defs/examples"
          },
          {
            $ref: "#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-path"
          },
          {
            $ref: "#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-header"
          },
          {
            $ref: "#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-query"
          },
          {
            $ref: "#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-cookie"
          },
          {
            $ref: "#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-form"
          }
        ],
        $defs: {
          "styles-for-path": {
            if: {
              properties: {
                in: {
                  const: "path"
                }
              },
              required: [
                "in"
              ]
            },
            then: {
              properties: {
                style: {
                  default: "simple",
                  enum: [
                    "matrix",
                    "label",
                    "simple"
                  ]
                },
                required: {
                  const: !0
                }
              },
              required: [
                "required"
              ]
            }
          },
          "styles-for-header": {
            if: {
              properties: {
                in: {
                  const: "header"
                }
              },
              required: [
                "in"
              ]
            },
            then: {
              properties: {
                style: {
                  default: "simple",
                  enum: [
                    "simple"
                  ]
                }
              }
            }
          },
          "styles-for-query": {
            if: {
              properties: {
                in: {
                  const: "query"
                }
              },
              required: [
                "in"
              ]
            },
            then: {
              properties: {
                style: {
                  default: "form",
                  enum: [
                    "form",
                    "spaceDelimited",
                    "pipeDelimited",
                    "deepObject"
                  ]
                }
              }
            }
          },
          "styles-for-cookie": {
            if: {
              properties: {
                in: {
                  const: "cookie"
                }
              },
              required: [
                "in"
              ]
            },
            then: {
              properties: {
                style: {
                  default: "form",
                  enum: [
                    "form"
                  ]
                }
              }
            }
          },
          "styles-for-form": {
            if: {
              properties: {
                style: {
                  const: "form"
                }
              },
              required: [
                "style"
              ]
            },
            then: {
              properties: {
                explode: {
                  default: !0
                }
              }
            },
            else: {
              properties: {
                explode: {
                  default: !1
                }
              }
            }
          }
        }
      }
    },
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  "parameter-or-reference": {
    if: {
      required: [
        "$ref"
      ]
    },
    then: {
      $ref: "#/$defs/reference"
    },
    else: {
      $ref: "#/$defs/parameter"
    }
  },
  "request-body": {
    type: "object",
    properties: {
      description: {
        type: "string"
      },
      content: {
        $ref: "#/$defs/content"
      },
      required: {
        default: !1,
        type: "boolean"
      }
    },
    required: [
      "content"
    ],
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  "request-body-or-reference": {
    if: {
      required: [
        "$ref"
      ]
    },
    then: {
      $ref: "#/$defs/reference"
    },
    else: {
      $ref: "#/$defs/request-body"
    }
  },
  content: {
    type: "object",
    additionalProperties: {
      $ref: "#/$defs/media-type"
    },
    propertyNames: {
      format: "media-range"
    }
  },
  "media-type": {
    type: "object",
    properties: {
      schema: {
        $dynamicRef: "#meta"
      },
      encoding: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/encoding"
        }
      }
    },
    allOf: [
      {
        $ref: "#/$defs/specification-extensions"
      },
      {
        $ref: "#/$defs/examples"
      }
    ],
    unevaluatedProperties: !1
  },
  encoding: {
    type: "object",
    properties: {
      contentType: {
        type: "string",
        format: "media-range"
      },
      headers: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/header-or-reference"
        }
      },
      style: {
        default: "form",
        enum: [
          "form",
          "spaceDelimited",
          "pipeDelimited",
          "deepObject"
        ]
      },
      explode: {
        type: "boolean"
      },
      allowReserved: {
        default: !1,
        type: "boolean"
      }
    },
    allOf: [
      {
        $ref: "#/$defs/specification-extensions"
      },
      {
        $ref: "#/$defs/encoding/$defs/explode-default"
      }
    ],
    unevaluatedProperties: !1,
    $defs: {
      "explode-default": {
        if: {
          properties: {
            style: {
              const: "form"
            }
          },
          required: [
            "style"
          ]
        },
        then: {
          properties: {
            explode: {
              default: !0
            }
          }
        },
        else: {
          properties: {
            explode: {
              default: !1
            }
          }
        }
      }
    }
  },
  responses: {
    type: "object",
    properties: {
      default: {
        $ref: "#/$defs/response-or-reference"
      }
    },
    patternProperties: {
      "^[1-5][0-9X]{2}$": {
        $ref: "#/$defs/response-or-reference"
      }
    },
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  response: {
    type: "object",
    properties: {
      description: {
        type: "string"
      },
      headers: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/header-or-reference"
        }
      },
      content: {
        $ref: "#/$defs/content"
      },
      links: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/link-or-reference"
        }
      }
    },
    required: [
      "description"
    ],
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  "response-or-reference": {
    if: {
      required: [
        "$ref"
      ]
    },
    then: {
      $ref: "#/$defs/reference"
    },
    else: {
      $ref: "#/$defs/response"
    }
  },
  callbacks: {
    type: "object",
    $ref: "#/$defs/specification-extensions",
    additionalProperties: {
      $ref: "#/$defs/path-item-or-reference"
    }
  },
  "callbacks-or-reference": {
    if: {
      required: [
        "$ref"
      ]
    },
    then: {
      $ref: "#/$defs/reference"
    },
    else: {
      $ref: "#/$defs/callbacks"
    }
  },
  example: {
    type: "object",
    properties: {
      summary: {
        type: "string"
      },
      description: {
        type: "string"
      },
      value: !0,
      externalValue: {
        $ref: "#/$defs/uri"
      }
    },
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  "example-or-reference": {
    if: {
      required: [
        "$ref"
      ]
    },
    then: {
      $ref: "#/$defs/reference"
    },
    else: {
      $ref: "#/$defs/example"
    }
  },
  link: {
    type: "object",
    properties: {
      operationRef: {
        $ref: "#/$defs/uri"
      },
      operationId: !0,
      parameters: {
        $ref: "#/$defs/map-of-strings"
      },
      requestBody: !0,
      description: {
        type: "string"
      },
      body: {
        $ref: "#/$defs/server"
      }
    },
    oneOf: [
      {
        required: [
          "operationRef"
        ]
      },
      {
        required: [
          "operationId"
        ]
      }
    ],
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  "link-or-reference": {
    if: {
      required: [
        "$ref"
      ]
    },
    then: {
      $ref: "#/$defs/reference"
    },
    else: {
      $ref: "#/$defs/link"
    }
  },
  header: {
    type: "object",
    properties: {
      description: {
        type: "string"
      },
      required: {
        default: !1,
        type: "boolean"
      },
      deprecated: {
        default: !1,
        type: "boolean"
      },
      allowEmptyValue: {
        default: !1,
        type: "boolean"
      }
    },
    dependentSchemas: {
      schema: {
        properties: {
          style: {
            default: "simple",
            enum: [
              "simple"
            ]
          },
          explode: {
            default: !1,
            type: "boolean"
          },
          allowReserved: {
            default: !1,
            type: "boolean"
          },
          schema: {
            $dynamicRef: "#meta"
          }
        },
        $ref: "#/$defs/examples"
      },
      content: {
        properties: {
          content: {
            $ref: "#/$defs/content"
          }
        }
      }
    },
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  "header-or-reference": {
    if: {
      required: [
        "$ref"
      ]
    },
    then: {
      $ref: "#/$defs/reference"
    },
    else: {
      $ref: "#/$defs/header"
    }
  },
  tag: {
    type: "object",
    properties: {
      name: {
        type: "string"
      },
      description: {
        type: "string"
      },
      externalDocs: {
        $ref: "#/$defs/external-documentation"
      }
    },
    required: [
      "name"
    ],
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  reference: {
    type: "object",
    properties: {
      $ref: {
        $ref: "#/$defs/uri"
      },
      summary: {
        type: "string"
      },
      description: {
        type: "string"
      }
    },
    unevaluatedProperties: !1
  },
  schema: {
    $dynamicAnchor: "meta",
    type: [
      "object",
      "boolean"
    ]
  },
  "security-scheme": {
    type: "object",
    properties: {
      type: {
        enum: [
          "apiKey",
          "http",
          "mutualTLS",
          "oauth2",
          "openIdConnect"
        ]
      },
      description: {
        type: "string"
      }
    },
    required: [
      "type"
    ],
    allOf: [
      {
        $ref: "#/$defs/specification-extensions"
      },
      {
        $ref: "#/$defs/security-scheme/$defs/type-apikey"
      },
      {
        $ref: "#/$defs/security-scheme/$defs/type-http"
      },
      {
        $ref: "#/$defs/security-scheme/$defs/type-http-bearer"
      },
      {
        $ref: "#/$defs/security-scheme/$defs/type-oauth2"
      },
      {
        $ref: "#/$defs/security-scheme/$defs/type-oidc"
      }
    ],
    unevaluatedProperties: !1,
    $defs: {
      "type-apikey": {
        if: {
          properties: {
            type: {
              const: "apiKey"
            }
          },
          required: [
            "type"
          ]
        },
        then: {
          properties: {
            name: {
              type: "string"
            },
            in: {
              enum: [
                "query",
                "header",
                "cookie"
              ]
            }
          },
          required: [
            "name",
            "in"
          ]
        }
      },
      "type-http": {
        if: {
          properties: {
            type: {
              const: "http"
            }
          },
          required: [
            "type"
          ]
        },
        then: {
          properties: {
            scheme: {
              type: "string"
            }
          },
          required: [
            "scheme"
          ]
        }
      },
      "type-http-bearer": {
        if: {
          properties: {
            type: {
              const: "http"
            },
            scheme: {
              const: "bearer"
            }
          },
          required: [
            "type",
            "scheme"
          ]
        },
        then: {
          properties: {
            bearerFormat: {
              type: "string"
            }
          },
          required: [
            "scheme"
          ]
        }
      },
      "type-oauth2": {
        if: {
          properties: {
            type: {
              const: "oauth2"
            }
          },
          required: [
            "type"
          ]
        },
        then: {
          properties: {
            flows: {
              $ref: "#/$defs/oauth-flows"
            }
          },
          required: [
            "flows"
          ]
        }
      },
      "type-oidc": {
        if: {
          properties: {
            type: {
              const: "openIdConnect"
            }
          },
          required: [
            "type"
          ]
        },
        then: {
          properties: {
            openIdConnectUrl: {
              $ref: "#/$defs/uri"
            }
          },
          required: [
            "openIdConnectUrl"
          ]
        }
      }
    }
  },
  "security-scheme-or-reference": {
    if: {
      required: [
        "$ref"
      ]
    },
    then: {
      $ref: "#/$defs/reference"
    },
    else: {
      $ref: "#/$defs/security-scheme"
    }
  },
  "oauth-flows": {
    type: "object",
    properties: {
      implicit: {
        $ref: "#/$defs/oauth-flows/$defs/implicit"
      },
      password: {
        $ref: "#/$defs/oauth-flows/$defs/password"
      },
      clientCredentials: {
        $ref: "#/$defs/oauth-flows/$defs/client-credentials"
      },
      authorizationCode: {
        $ref: "#/$defs/oauth-flows/$defs/authorization-code"
      }
    },
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1,
    $defs: {
      implicit: {
        type: "object",
        properties: {
          authorizationUrl: {
            type: "string"
          },
          refreshUrl: {
            type: "string"
          },
          scopes: {
            $ref: "#/$defs/map-of-strings"
          }
        },
        required: [
          "authorizationUrl",
          "scopes"
        ],
        $ref: "#/$defs/specification-extensions",
        unevaluatedProperties: !1
      },
      password: {
        type: "object",
        properties: {
          tokenUrl: {
            type: "string"
          },
          refreshUrl: {
            type: "string"
          },
          scopes: {
            $ref: "#/$defs/map-of-strings"
          }
        },
        required: [
          "tokenUrl",
          "scopes"
        ],
        $ref: "#/$defs/specification-extensions",
        unevaluatedProperties: !1
      },
      "client-credentials": {
        type: "object",
        properties: {
          tokenUrl: {
            type: "string"
          },
          refreshUrl: {
            type: "string"
          },
          scopes: {
            $ref: "#/$defs/map-of-strings"
          }
        },
        required: [
          "tokenUrl",
          "scopes"
        ],
        $ref: "#/$defs/specification-extensions",
        unevaluatedProperties: !1
      },
      "authorization-code": {
        type: "object",
        properties: {
          authorizationUrl: {
            type: "string"
          },
          tokenUrl: {
            type: "string"
          },
          refreshUrl: {
            type: "string"
          },
          scopes: {
            $ref: "#/$defs/map-of-strings"
          }
        },
        required: [
          "authorizationUrl",
          "tokenUrl",
          "scopes"
        ],
        $ref: "#/$defs/specification-extensions",
        unevaluatedProperties: !1
      }
    }
  },
  "security-requirement": {
    type: "object",
    additionalProperties: {
      type: "array",
      items: {
        type: "string"
      }
    }
  },
  "specification-extensions": {
    patternProperties: {
      "^x-": !0
    }
  },
  examples: {
    properties: {
      example: !0,
      examples: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/example-or-reference"
        }
      }
    }
  },
  uri: {
    type: "string",
    format: "uri"
  },
  "map-of-strings": {
    type: "object",
    additionalProperties: {
      type: "string"
    }
  }
}, i8 = {
  $id: Kq,
  $schema: Yq,
  type: Jq,
  properties: Xq,
  required: Qq,
  anyOf: e8,
  $ref: t8,
  unevaluatedProperties: r8,
  $defs: n8
};
(function(e, t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.openapi = t.openapiV31 = t.openapiV3 = t.openapiV2 = t.openapiV1 = void 0, t.openapiV1 = Aq, t.openapiV2 = Lq, t.openapiV3 = Gq, t.openapiV31 = i8, t.openapi = {
    v1: t.openapiV1,
    v2: t.openapiV2,
    v3: t.openapiV3,
    v31: t.openapiV31
  }, t.default = t.openapi, e.exports = Object.assign(e.exports.default, e.exports);
})(jy, jy.exports);
var s8 = jy.exports, ky = { exports: {} }, VO = { exports: {} };
(function(e) {
  function t(r) {
    return r && r.__esModule ? r : {
      default: r
    };
  }
  e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports;
})(VO);
var Ln = VO.exports, ki = {};
Object.defineProperty(ki, "__esModule", { value: !0 });
const a8 = "[", o8 = "]", u8 = "{", c8 = "}", l8 = ":", f8 = ",", ZO = "true", zO = "false", WO = "null", A_ = '"', d8 = /* @__PURE__ */ new Map([
  ["t", ZO],
  ["f", zO],
  ["n", WO]
]), My = /* @__PURE__ */ new Map([
  [A_, A_],
  ["\\", "\\"],
  ["/", "/"],
  ["b", "\b"],
  ["n", `
`],
  ["f", "\f"],
  ["r", "\r"],
  ["t", "	"]
]), nh = /* @__PURE__ */ new Map([
  [a8, "Punctuator"],
  [o8, "Punctuator"],
  [u8, "Punctuator"],
  [c8, "Punctuator"],
  [l8, "Punctuator"],
  [f8, "Punctuator"],
  [ZO, "Boolean"],
  [zO, "Boolean"],
  [WO, "Null"]
]);
class Uu extends Error {
  /**
   * 
   * @param {string} message The error message to report. 
   * @param {int} loc.line The line on which the error occurred.
   * @param {int} loc.column The column in the line where the error occurrred.
   * @param {int} loc.index The index in the string where the error occurred.
   */
  constructor(t, { line: r, column: i, index: n }) {
    super(`${t} (${r}:${i})`), this.line = r, this.column = i, this.index = n;
  }
}
class p8 extends Uu {
  /**
   * Creates a new instance.
   * @param {string} unexpected The character that was found.
   * @param {Object} loc The location information for the found character.
   */
  constructor(t, r) {
    super(`Unexpected character ${t} found.`, r);
  }
}
class nl extends Uu {
  /**
   * Creates a new instance.
   * @param {string} expected The character that was expected. 
   * @param {string} unexpected The character that was found.
   * @param {Object} loc The location information for the found character.
   */
  constructor(t) {
    super(`Unexpected token ${t.type}(${t.value}) found.`, t.loc.start);
  }
}
class h8 extends Uu {
  /**
   * Creates a new instance.
   * @param {Object} loc The location information for the found character.
   */
  constructor(t) {
    super("Unexpected end of input found.", t);
  }
}
const C_ = '"', R_ = "/", T_ = "*", m8 = {
  comments: !1,
  ranges: !1
};
function y8(e) {
  return /[\s\n]/.test(e);
}
function ts(e) {
  return e >= "0" && e <= "9";
}
function g8(e) {
  return ts(e) || /[a-f]/i.test(e);
}
function v8(e) {
  return e >= "1" && e <= "9";
}
function b8(e) {
  return /[tfn]/.test(e);
}
function _8(e) {
  return ts(e) || e === "." || e === "-";
}
function HO(e, t) {
  t = Object.freeze({
    ...m8,
    ...t
  });
  let r = -1, i = 1, n = 0, s = !1;
  const a = [];
  function u(m, w, $, E) {
    const A = $.offset + w.length;
    let R = t.ranges ? {
      range: [$.offset, A]
    } : void 0;
    return {
      type: m,
      value: w,
      loc: {
        start: $,
        end: E || {
          line: $.line,
          column: $.column + w.length,
          offset: A
        }
      },
      ...R
    };
  }
  function c() {
    let m = e.charAt(++r);
    return s ? (i++, n = 1, s = !1) : n++, m === "\r" ? (s = !0, e.charAt(r + 1) === `
` && r++) : m === `
` && (s = !0), m;
  }
  function l() {
    return {
      line: i,
      column: n,
      offset: r
    };
  }
  function d(m) {
    let w = d8.get(m);
    if (e.slice(r, r + w.length) === w)
      return r += w.length - 1, n += w.length - 1, { value: w, c: c() };
    for (let $ = 1; $ < w.length; $++)
      w[$] !== e.charAt(r + $) && y(c());
  }
  function p(m) {
    let w = m;
    for (m = c(); m && m !== C_; ) {
      if (m === "\\")
        if (w += m, m = c(), My.has(m))
          w += m;
        else if (m === "u") {
          w += m;
          for (let $ = 0; $ < 4; $++)
            m = c(), g8(m) ? w += m : y(m);
        } else
          y(m);
      else
        w += m;
      m = c();
    }
    return m || g(), w += m, { value: w, c: c() };
  }
  function h(m) {
    let w = "";
    if (m === "-" && (w += m, m = c(), ts(m) || y(m)), m === "0")
      w += m, m = c(), ts(m) && y(m);
    else {
      v8(m) || y(m);
      do
        w += m, m = c();
      while (ts(m));
    }
    if (m === ".")
      do
        w += m, m = c();
      while (ts(m));
    if (m === "e" || m === "E")
      for (w += m, m = c(), (m === "+" || m === "-") && (w += m, m = c()), ts(m) || y(m); ts(m); )
        w += m, m = c();
    return { value: w, c: m };
  }
  function v(m) {
    let w = m;
    if (m = c(), m === "/") {
      do
        w += m, m = c();
      while (m && m !== "\r" && m !== `
`);
      return { value: w, c: m };
    }
    if (m === T_) {
      for (; m; )
        if (w += m, m = c(), m === T_ && (w += m, m = c(), m === R_))
          return w += m, m = c(), { value: w, c: m };
      g();
    }
    y(m);
  }
  function y(m) {
    throw new p8(m, l());
  }
  function g() {
    throw new h8(l());
  }
  let _ = c();
  for (; r < e.length; ) {
    for (; y8(_); )
      _ = c();
    if (!_)
      break;
    const m = l();
    if (nh.has(_))
      a.push(u(nh.get(_), _, m)), _ = c();
    else if (b8(_)) {
      const w = d(_);
      let $ = w.value;
      _ = w.c, a.push(u(nh.get($), $, m));
    } else if (_8(_)) {
      const w = h(_);
      let $ = w.value;
      _ = w.c, a.push(u("Number", $, m));
    } else if (_ === C_) {
      const w = p(_);
      let $ = w.value;
      _ = w.c, a.push(u("String", $, m));
    } else if (_ === R_ && t.comments) {
      const w = v(_);
      let $ = w.value;
      _ = w.c, a.push(u($.startsWith("//") ? "LineComment" : "BlockComment", $, m, l()));
    } else
      y(_);
  }
  return a;
}
const au = {
  document(e, t = {}) {
    return {
      type: "Document",
      body: e,
      ...t
    };
  },
  string(e, t = {}) {
    return {
      type: "String",
      value: e,
      ...t
    };
  },
  number(e, t = {}) {
    return {
      type: "Number",
      value: e,
      ...t
    };
  },
  boolean(e, t = {}) {
    return {
      type: "Boolean",
      value: e,
      ...t
    };
  },
  null(e = {}) {
    return {
      type: "Null",
      value: "null",
      ...e
    };
  },
  array(e, t = {}) {
    return {
      type: "Array",
      elements: e,
      ...t
    };
  },
  object(e, t = {}) {
    return {
      type: "Object",
      members: e,
      ...t
    };
  },
  member(e, t, r = {}) {
    return {
      type: "Member",
      name: e,
      value: t,
      ...r
    };
  }
}, w8 = {
  tokens: !1,
  comments: !1,
  ranges: !1
};
function $8(e) {
  let t = e.value.slice(1, -1), r = "", i = t.indexOf("\\"), n = 0;
  for (; i >= 0; ) {
    r += t.slice(n, i);
    const s = t.charAt(i + 1);
    if (My.has(s))
      r += My.get(s), n = i + 2;
    else if (s === "u") {
      const a = t.slice(i + 2, i + 6);
      if (a.length < 4 || /[^0-9a-f]/i.test(a))
        throw new Uu(
          `Invalid unicode escape \\u${a}.`,
          {
            line: e.loc.start.line,
            column: e.loc.start.column + i,
            offset: e.loc.start.offset + i
          }
        );
      r += String.fromCharCode(parseInt(a, 16)), n = i + 6;
    } else
      throw new Uu(
        `Invalid escape \\${s}.`,
        {
          line: e.loc.start.line,
          column: e.loc.start.column + i,
          offset: e.loc.start.offset + i
        }
      );
    i = t.indexOf("\\", n);
  }
  return r += t.slice(n), r;
}
function E8(e) {
  switch (e.type) {
    case "Boolean":
      return e.value === "true";
    case "Number":
      return Number(e.value);
    case "Null":
      return null;
    case "String":
      return $8(e);
  }
}
function x8(e, t) {
  t = Object.freeze({
    ...w8,
    ...t
  });
  const r = HO(e, {
    comments: !!t.comments,
    ranges: !!t.ranges
  });
  let i = 0;
  function n() {
    return r[i++];
  }
  function s() {
    const w = r[i++];
    return w && w.type.endsWith("Comment") ? s() : w;
  }
  const a = t.comments ? s : n;
  function u(w, $) {
    if (!w || w.value !== $)
      throw new nl(w);
  }
  function c(w, $) {
    if (!w || w.type !== $)
      throw new nl(w);
  }
  function l(w, $) {
    return t.ranges ? {
      range: [w.offset, $.offset]
    } : void 0;
  }
  function d(w) {
    const $ = l(w.loc.start, w.loc.end);
    return {
      type: w.type,
      value: E8(w),
      loc: {
        start: {
          ...w.loc.start
        },
        end: {
          ...w.loc.end
        }
      },
      ...$
    };
  }
  function p(w) {
    c(w, "String");
    const $ = d(w);
    w = a(), u(w, ":");
    const E = y(), A = l($.loc.start, E.loc.end);
    return au.member($, E, {
      loc: {
        start: {
          ...$.loc.start
        },
        end: {
          ...E.loc.end
        }
      },
      ...A
    });
  }
  function h(w) {
    u(w, "{");
    const $ = [];
    let E = a();
    if (E && E.value !== "}")
      do
        if ($.push(p(E)), E = a(), E.value === ",")
          E = a();
        else
          break;
      while (E);
    u(E, "}");
    const A = l(w.loc.start, E.loc.end);
    return au.object($, {
      loc: {
        start: {
          ...w.loc.start
        },
        end: {
          ...E.loc.end
        }
      },
      ...A
    });
  }
  function v(w) {
    u(w, "[");
    const $ = [];
    let E = a();
    if (E && E.value !== "]")
      do
        if ($.push(y(E)), E = a(), E.value === ",")
          E = a();
        else
          break;
      while (E);
    u(E, "]");
    const A = l(w.loc.start, E.loc.end);
    return au.array($, {
      type: "Array",
      elements: $,
      loc: {
        start: {
          ...w.loc.start
        },
        end: {
          ...E.loc.end
        }
      },
      ...A
    });
  }
  function y(w) {
    switch (w = w || a(), w.type) {
      case "String":
      case "Boolean":
      case "Number":
      case "Null":
        return d(w);
      case "Punctuator":
        if (w.value === "{")
          return h(w);
        if (w.value === "[")
          return v(w);
      default:
        throw new nl(w);
    }
  }
  const g = y(), _ = a();
  if (_)
    throw new nl(_);
  const m = {
    loc: {
      start: {
        line: 1,
        column: 1,
        offset: 0
      },
      end: {
        ...g.loc.end
      }
    }
  };
  return t.tokens && (m.tokens = r), t.ranges && (m.range = l(m.loc.start, m.loc.end)), au.document(g, m);
}
const O8 = /* @__PURE__ */ new Map([
  ["Document", ["body"]],
  ["Object", ["members"]],
  ["Member", ["name", "value"]],
  ["Array", ["elements"]],
  ["String", []],
  ["Number", []],
  ["Boolean", []],
  ["Null", []]
]);
function GO(e) {
  return e && typeof e == "object";
}
function P8(e) {
  return GO(e) && typeof e.type == "string";
}
function KO(e, t) {
  function r(i, n) {
    typeof t.enter == "function" && t.enter(i, n);
    for (const s of O8.get(i.type)) {
      const a = i[s];
      GO(a) && (Array.isArray(a) ? a.forEach((u) => r(u, i)) : P8(a) && r(a, i));
    }
    typeof t.exit == "function" && t.exit(i, n);
  }
  r(e);
}
function S8(e, t = () => !0) {
  const r = [];
  return KO(e, {
    enter(i, n) {
      r.push({ node: i, parent: n, phase: "enter" });
    },
    exit(i, n) {
      r.push({ node: i, parent: n, phase: "exit" });
    }
  }), r.filter(t).values();
}
function za(e) {
  switch (e.type) {
    case "String":
    case "Number":
    case "Boolean":
      return e.value;
    case "Null":
      return null;
    case "Array":
      return e.elements.map(za);
    case "Object": {
      const t = {};
      return e.members.forEach((r) => {
        t[za(r.name)] = za(r.value);
      }), t;
    }
    case "Document":
      return za(e.body);
    case "Property":
      throw new Error("Cannot evaluate object property outside of an object.");
    default:
      throw new Error(`Unknown node type ${e.type}.`);
  }
}
function A8(e, { indent: t = 0 } = {}) {
  const r = za(e);
  return JSON.stringify(r, null, t);
}
ki.evaluate = za;
ki.iterator = S8;
ki.parse = x8;
ki.print = A8;
ki.tokenize = HO;
ki.traverse = KO;
ki.types = au;
var ih = {}, sh = { exports: {} }, ah = { exports: {} }, oh = { exports: {} }, I_;
function Zg() {
  return I_ || (I_ = 1, function(e) {
    function t(r) {
      "@babel/helpers - typeof";
      return e.exports = t = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(i) {
        return typeof i;
      } : function(i) {
        return i && typeof Symbol == "function" && i.constructor === Symbol && i !== Symbol.prototype ? "symbol" : typeof i;
      }, e.exports.__esModule = !0, e.exports.default = e.exports, t(r);
    }
    e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(oh)), oh.exports;
}
var uh = { exports: {} }, j_;
function C8() {
  return j_ || (j_ = 1, function(e) {
    var t = Zg().default;
    function r(i, n) {
      if (t(i) !== "object" || i === null)
        return i;
      var s = i[Symbol.toPrimitive];
      if (s !== void 0) {
        var a = s.call(i, n || "default");
        if (t(a) !== "object")
          return a;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (n === "string" ? String : Number)(i);
    }
    e.exports = r, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(uh)), uh.exports;
}
var k_;
function YO() {
  return k_ || (k_ = 1, function(e) {
    var t = Zg().default, r = C8();
    function i(n) {
      var s = r(n, "string");
      return t(s) === "symbol" ? s : String(s);
    }
    e.exports = i, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(ah)), ah.exports;
}
var M_;
function na() {
  return M_ || (M_ = 1, function(e) {
    var t = YO();
    function r(i, n, s) {
      return n = t(n), n in i ? Object.defineProperty(i, n, {
        value: s,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }) : i[n] = s, i;
    }
    e.exports = r, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(sh)), sh.exports;
}
var ch = { exports: {} }, lh = { exports: {} }, fh = { exports: {} }, N_;
function JO() {
  return N_ || (N_ = 1, function(e) {
    function t(r, i) {
      (i == null || i > r.length) && (i = r.length);
      for (var n = 0, s = new Array(i); n < i; n++)
        s[n] = r[n];
      return s;
    }
    e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(fh)), fh.exports;
}
var D_;
function R8() {
  return D_ || (D_ = 1, function(e) {
    var t = JO();
    function r(i) {
      if (Array.isArray(i))
        return t(i);
    }
    e.exports = r, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(lh)), lh.exports;
}
var dh = { exports: {} }, L_;
function T8() {
  return L_ || (L_ = 1, function(e) {
    function t(r) {
      if (typeof Symbol < "u" && r[Symbol.iterator] != null || r["@@iterator"] != null)
        return Array.from(r);
    }
    e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(dh)), dh.exports;
}
var ph = { exports: {} }, q_;
function XO() {
  return q_ || (q_ = 1, function(e) {
    var t = JO();
    function r(i, n) {
      if (i) {
        if (typeof i == "string")
          return t(i, n);
        var s = Object.prototype.toString.call(i).slice(8, -1);
        if (s === "Object" && i.constructor && (s = i.constructor.name), s === "Map" || s === "Set")
          return Array.from(i);
        if (s === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(s))
          return t(i, n);
      }
    }
    e.exports = r, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(ph)), ph.exports;
}
var hh = { exports: {} }, F_;
function I8() {
  return F_ || (F_ = 1, function(e) {
    function t() {
      throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(hh)), hh.exports;
}
var U_;
function j8() {
  return U_ || (U_ = 1, function(e) {
    var t = R8(), r = T8(), i = XO(), n = I8();
    function s(a) {
      return t(a) || r(a) || i(a) || n();
    }
    e.exports = s, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(ch)), ch.exports;
}
var mh = { exports: {} }, yh = { exports: {} }, B_;
function k8() {
  return B_ || (B_ = 1, function(e) {
    function t(r) {
      if (Array.isArray(r))
        return r;
    }
    e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(yh)), yh.exports;
}
var gh = { exports: {} }, V_;
function M8() {
  return V_ || (V_ = 1, function(e) {
    function t(r, i) {
      var n = r == null ? null : typeof Symbol < "u" && r[Symbol.iterator] || r["@@iterator"];
      if (n != null) {
        var s, a, u, c, l = [], d = !0, p = !1;
        try {
          if (u = (n = n.call(r)).next, i === 0) {
            if (Object(n) !== n)
              return;
            d = !1;
          } else
            for (; !(d = (s = u.call(n)).done) && (l.push(s.value), l.length !== i); d = !0)
              ;
        } catch (h) {
          p = !0, a = h;
        } finally {
          try {
            if (!d && n.return != null && (c = n.return(), Object(c) !== c))
              return;
          } finally {
            if (p)
              throw a;
          }
        }
        return l;
      }
    }
    e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(gh)), gh.exports;
}
var vh = { exports: {} }, Z_;
function N8() {
  return Z_ || (Z_ = 1, function(e) {
    function t() {
      throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(vh)), vh.exports;
}
var z_;
function D8() {
  return z_ || (z_ = 1, function(e) {
    var t = k8(), r = M8(), i = XO(), n = N8();
    function s(a, u) {
      return t(a) || r(a, u) || i(a, u) || n();
    }
    e.exports = s, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(mh)), mh.exports;
}
var lr = {}, W_;
function L8() {
  if (W_)
    return lr;
  W_ = 1, Object.defineProperty(lr, "__esModule", {
    value: !0
  }), lr.notUndefined = lr.isRequiredError = lr.isEnumError = lr.isAnyOfError = lr.getSiblings = lr.getErrors = lr.getChildren = lr.concatAll = void 0;
  var e = function(v) {
    return function(y) {
      return v === y;
    };
  }, t = function(v) {
    return function(y) {
      return !v(y);
    };
  }, r = function(v) {
    return Object.values(v);
  }, i = function(v) {
    return v !== void 0;
  };
  lr.notUndefined = i;
  var n = function(v) {
    return function(y) {
      return y.keyword === v;
    };
  }, s = n("required");
  lr.isRequiredError = s;
  var a = n("anyOf");
  lr.isAnyOfError = a;
  var u = n("enum");
  lr.isEnumError = u;
  var c = function(v) {
    return v && v.errors || [];
  };
  lr.getErrors = c;
  var l = function(v) {
    return v && r(v.children) || [];
  };
  lr.getChildren = l;
  var d = function(v) {
    return function(y) {
      return l(v).filter(t(e(y)));
    };
  };
  lr.getSiblings = d;
  var p = (
    /* ::<T> */
    function(v) {
      return function(y) {
        return y.reduce(function(g, _) {
          return g.concat(_);
        }, v);
      };
    }
  );
  return lr.concatAll = p, lr;
}
var bh = {}, il = { exports: {} }, _h = { exports: {} }, H_;
function po() {
  return H_ || (H_ = 1, function(e) {
    function t(r, i) {
      return i || (i = r.slice(0)), Object.freeze(Object.defineProperties(r, {
        raw: {
          value: Object.freeze(i)
        }
      }));
    }
    e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(_h)), _h.exports;
}
var wh = { exports: {} }, G_;
function ia() {
  return G_ || (G_ = 1, function(e) {
    function t(r, i) {
      if (!(r instanceof i))
        throw new TypeError("Cannot call a class as a function");
    }
    e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(wh)), wh.exports;
}
var $h = { exports: {} }, K_;
function sa() {
  return K_ || (K_ = 1, function(e) {
    var t = YO();
    function r(n, s) {
      for (var a = 0; a < s.length; a++) {
        var u = s[a];
        u.enumerable = u.enumerable || !1, u.configurable = !0, "value" in u && (u.writable = !0), Object.defineProperty(n, t(u.key), u);
      }
    }
    function i(n, s, a) {
      return s && r(n.prototype, s), a && r(n, a), Object.defineProperty(n, "prototype", {
        writable: !1
      }), n;
    }
    e.exports = i, e.exports.__esModule = !0, e.exports.default = e.exports;
  }($h)), $h.exports;
}
var Eh = { exports: {} }, xh = { exports: {} }, Y_;
function q8() {
  return Y_ || (Y_ = 1, function(e) {
    function t(r, i) {
      return e.exports = t = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(s, a) {
        return s.__proto__ = a, s;
      }, e.exports.__esModule = !0, e.exports.default = e.exports, t(r, i);
    }
    e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(xh)), xh.exports;
}
var J_;
function ho() {
  return J_ || (J_ = 1, function(e) {
    var t = q8();
    function r(i, n) {
      if (typeof n != "function" && n !== null)
        throw new TypeError("Super expression must either be null or a function");
      i.prototype = Object.create(n && n.prototype, {
        constructor: {
          value: i,
          writable: !0,
          configurable: !0
        }
      }), Object.defineProperty(i, "prototype", {
        writable: !1
      }), n && t(i, n);
    }
    e.exports = r, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(Eh)), Eh.exports;
}
var Oh = { exports: {} }, Ph = { exports: {} }, X_;
function F8() {
  return X_ || (X_ = 1, function(e) {
    function t(r) {
      if (r === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return r;
    }
    e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(Ph)), Ph.exports;
}
var Q_;
function mo() {
  return Q_ || (Q_ = 1, function(e) {
    var t = Zg().default, r = F8();
    function i(n, s) {
      if (s && (t(s) === "object" || typeof s == "function"))
        return s;
      if (s !== void 0)
        throw new TypeError("Derived constructors may only return object or undefined");
      return r(n);
    }
    e.exports = i, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(Oh)), Oh.exports;
}
var Sh = { exports: {} }, ew;
function aa() {
  return ew || (ew = 1, function(e) {
    function t(r) {
      return e.exports = t = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {
        return n.__proto__ || Object.getPrototypeOf(n);
      }, e.exports.__esModule = !0, e.exports.default = e.exports, t(r);
    }
    e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(Sh)), Sh.exports;
}
var sl = { exports: {} }, Go = {}, Ta = {}, Ko = {}, tw;
function U8() {
  return tw || (tw = 1, Object.defineProperty(Ko, "__esModule", {
    value: !0
  }), Ko.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g, Ko.matchToToken = function(e) {
    var t = { type: "invalid", value: e[0], closed: void 0 };
    return e[1] ? (t.type = "string", t.closed = !!(e[3] || e[4])) : e[5] ? t.type = "comment" : e[6] ? (t.type = "comment", t.closed = !!e[7]) : e[8] ? t.type = "regex" : e[9] ? t.type = "number" : e[10] ? t.type = "name" : e[11] ? t.type = "punctuator" : e[12] && (t.type = "whitespace"), t;
  }), Ko;
}
var Ah = {}, Ia = {}, rw;
function B8() {
  if (rw)
    return Ia;
  rw = 1, Object.defineProperty(Ia, "__esModule", {
    value: !0
  }), Ia.isIdentifierChar = c, Ia.isIdentifierName = l, Ia.isIdentifierStart = u;
  let e = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ", t = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿";
  const r = new RegExp("[" + e + "]"), i = new RegExp("[" + e + t + "]");
  e = t = null;
  const n = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938, 6, 4191], s = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function a(d, p) {
    let h = 65536;
    for (let v = 0, y = p.length; v < y; v += 2) {
      if (h += p[v], h > d)
        return !1;
      if (h += p[v + 1], h >= d)
        return !0;
    }
    return !1;
  }
  function u(d) {
    return d < 65 ? d === 36 : d <= 90 ? !0 : d < 97 ? d === 95 : d <= 122 ? !0 : d <= 65535 ? d >= 170 && r.test(String.fromCharCode(d)) : a(d, n);
  }
  function c(d) {
    return d < 48 ? d === 36 : d < 58 ? !0 : d < 65 ? !1 : d <= 90 ? !0 : d < 97 ? d === 95 : d <= 122 ? !0 : d <= 65535 ? d >= 170 && i.test(String.fromCharCode(d)) : a(d, n) || a(d, s);
  }
  function l(d) {
    let p = !0;
    for (let h = 0; h < d.length; h++) {
      let v = d.charCodeAt(h);
      if ((v & 64512) === 55296 && h + 1 < d.length) {
        const y = d.charCodeAt(++h);
        (y & 64512) === 56320 && (v = 65536 + ((v & 1023) << 10) + (y & 1023));
      }
      if (p) {
        if (p = !1, !u(v))
          return !1;
      } else if (!c(v))
        return !1;
    }
    return !p;
  }
  return Ia;
}
var Yi = {}, nw;
function V8() {
  if (nw)
    return Yi;
  nw = 1, Object.defineProperty(Yi, "__esModule", {
    value: !0
  }), Yi.isKeyword = c, Yi.isReservedWord = n, Yi.isStrictBindOnlyReservedWord = a, Yi.isStrictBindReservedWord = u, Yi.isStrictReservedWord = s;
  const e = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  }, t = new Set(e.keyword), r = new Set(e.strict), i = new Set(e.strictBind);
  function n(l, d) {
    return d && l === "await" || l === "enum";
  }
  function s(l, d) {
    return n(l, d) || r.has(l);
  }
  function a(l) {
    return i.has(l);
  }
  function u(l, d) {
    return s(l, d) || a(l);
  }
  function c(l) {
    return t.has(l);
  }
  return Yi;
}
var iw;
function Z8() {
  return iw || (iw = 1, function(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), Object.defineProperty(e, "isIdentifierChar", {
      enumerable: !0,
      get: function() {
        return t.isIdentifierChar;
      }
    }), Object.defineProperty(e, "isIdentifierName", {
      enumerable: !0,
      get: function() {
        return t.isIdentifierName;
      }
    }), Object.defineProperty(e, "isIdentifierStart", {
      enumerable: !0,
      get: function() {
        return t.isIdentifierStart;
      }
    }), Object.defineProperty(e, "isKeyword", {
      enumerable: !0,
      get: function() {
        return r.isKeyword;
      }
    }), Object.defineProperty(e, "isReservedWord", {
      enumerable: !0,
      get: function() {
        return r.isReservedWord;
      }
    }), Object.defineProperty(e, "isStrictBindOnlyReservedWord", {
      enumerable: !0,
      get: function() {
        return r.isStrictBindOnlyReservedWord;
      }
    }), Object.defineProperty(e, "isStrictBindReservedWord", {
      enumerable: !0,
      get: function() {
        return r.isStrictBindReservedWord;
      }
    }), Object.defineProperty(e, "isStrictReservedWord", {
      enumerable: !0,
      get: function() {
        return r.isStrictReservedWord;
      }
    });
    var t = B8(), r = V8();
  }(Ah)), Ah;
}
var Ch = { exports: {} }, Rh, sw;
function z8() {
  if (sw)
    return Rh;
  sw = 1;
  var e = /[|\\{}()[\]^$+*?.]/g;
  return Rh = function(t) {
    if (typeof t != "string")
      throw new TypeError("Expected a string");
    return t.replace(e, "\\$&");
  }, Rh;
}
var kl = { exports: {} }, Th = { exports: {} }, Ih, aw;
function W8() {
  return aw || (aw = 1, Ih = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  }), Ih;
}
var ow;
function QO() {
  if (ow)
    return Th.exports;
  ow = 1;
  var e = W8(), t = {};
  for (var r in e)
    e.hasOwnProperty(r) && (t[e[r]] = r);
  var i = Th.exports = {
    rgb: { channels: 3, labels: "rgb" },
    hsl: { channels: 3, labels: "hsl" },
    hsv: { channels: 3, labels: "hsv" },
    hwb: { channels: 3, labels: "hwb" },
    cmyk: { channels: 4, labels: "cmyk" },
    xyz: { channels: 3, labels: "xyz" },
    lab: { channels: 3, labels: "lab" },
    lch: { channels: 3, labels: "lch" },
    hex: { channels: 1, labels: ["hex"] },
    keyword: { channels: 1, labels: ["keyword"] },
    ansi16: { channels: 1, labels: ["ansi16"] },
    ansi256: { channels: 1, labels: ["ansi256"] },
    hcg: { channels: 3, labels: ["h", "c", "g"] },
    apple: { channels: 3, labels: ["r16", "g16", "b16"] },
    gray: { channels: 1, labels: ["gray"] }
  };
  for (var n in i)
    if (i.hasOwnProperty(n)) {
      if (!("channels" in i[n]))
        throw new Error("missing channels property: " + n);
      if (!("labels" in i[n]))
        throw new Error("missing channel labels property: " + n);
      if (i[n].labels.length !== i[n].channels)
        throw new Error("channel and label counts mismatch: " + n);
      var s = i[n].channels, a = i[n].labels;
      delete i[n].channels, delete i[n].labels, Object.defineProperty(i[n], "channels", { value: s }), Object.defineProperty(i[n], "labels", { value: a });
    }
  i.rgb.hsl = function(c) {
    var l = c[0] / 255, d = c[1] / 255, p = c[2] / 255, h = Math.min(l, d, p), v = Math.max(l, d, p), y = v - h, g, _, m;
    return v === h ? g = 0 : l === v ? g = (d - p) / y : d === v ? g = 2 + (p - l) / y : p === v && (g = 4 + (l - d) / y), g = Math.min(g * 60, 360), g < 0 && (g += 360), m = (h + v) / 2, v === h ? _ = 0 : m <= 0.5 ? _ = y / (v + h) : _ = y / (2 - v - h), [g, _ * 100, m * 100];
  }, i.rgb.hsv = function(c) {
    var l, d, p, h, v, y = c[0] / 255, g = c[1] / 255, _ = c[2] / 255, m = Math.max(y, g, _), w = m - Math.min(y, g, _), $ = function(E) {
      return (m - E) / 6 / w + 1 / 2;
    };
    return w === 0 ? h = v = 0 : (v = w / m, l = $(y), d = $(g), p = $(_), y === m ? h = p - d : g === m ? h = 1 / 3 + l - p : _ === m && (h = 2 / 3 + d - l), h < 0 ? h += 1 : h > 1 && (h -= 1)), [
      h * 360,
      v * 100,
      m * 100
    ];
  }, i.rgb.hwb = function(c) {
    var l = c[0], d = c[1], p = c[2], h = i.rgb.hsl(c)[0], v = 1 / 255 * Math.min(l, Math.min(d, p));
    return p = 1 - 1 / 255 * Math.max(l, Math.max(d, p)), [h, v * 100, p * 100];
  }, i.rgb.cmyk = function(c) {
    var l = c[0] / 255, d = c[1] / 255, p = c[2] / 255, h, v, y, g;
    return g = Math.min(1 - l, 1 - d, 1 - p), h = (1 - l - g) / (1 - g) || 0, v = (1 - d - g) / (1 - g) || 0, y = (1 - p - g) / (1 - g) || 0, [h * 100, v * 100, y * 100, g * 100];
  };
  function u(c, l) {
    return Math.pow(c[0] - l[0], 2) + Math.pow(c[1] - l[1], 2) + Math.pow(c[2] - l[2], 2);
  }
  return i.rgb.keyword = function(c) {
    var l = t[c];
    if (l)
      return l;
    var d = 1 / 0, p;
    for (var h in e)
      if (e.hasOwnProperty(h)) {
        var v = e[h], y = u(c, v);
        y < d && (d = y, p = h);
      }
    return p;
  }, i.keyword.rgb = function(c) {
    return e[c];
  }, i.rgb.xyz = function(c) {
    var l = c[0] / 255, d = c[1] / 255, p = c[2] / 255;
    l = l > 0.04045 ? Math.pow((l + 0.055) / 1.055, 2.4) : l / 12.92, d = d > 0.04045 ? Math.pow((d + 0.055) / 1.055, 2.4) : d / 12.92, p = p > 0.04045 ? Math.pow((p + 0.055) / 1.055, 2.4) : p / 12.92;
    var h = l * 0.4124 + d * 0.3576 + p * 0.1805, v = l * 0.2126 + d * 0.7152 + p * 0.0722, y = l * 0.0193 + d * 0.1192 + p * 0.9505;
    return [h * 100, v * 100, y * 100];
  }, i.rgb.lab = function(c) {
    var l = i.rgb.xyz(c), d = l[0], p = l[1], h = l[2], v, y, g;
    return d /= 95.047, p /= 100, h /= 108.883, d = d > 8856e-6 ? Math.pow(d, 1 / 3) : 7.787 * d + 16 / 116, p = p > 8856e-6 ? Math.pow(p, 1 / 3) : 7.787 * p + 16 / 116, h = h > 8856e-6 ? Math.pow(h, 1 / 3) : 7.787 * h + 16 / 116, v = 116 * p - 16, y = 500 * (d - p), g = 200 * (p - h), [v, y, g];
  }, i.hsl.rgb = function(c) {
    var l = c[0] / 360, d = c[1] / 100, p = c[2] / 100, h, v, y, g, _;
    if (d === 0)
      return _ = p * 255, [_, _, _];
    p < 0.5 ? v = p * (1 + d) : v = p + d - p * d, h = 2 * p - v, g = [0, 0, 0];
    for (var m = 0; m < 3; m++)
      y = l + 1 / 3 * -(m - 1), y < 0 && y++, y > 1 && y--, 6 * y < 1 ? _ = h + (v - h) * 6 * y : 2 * y < 1 ? _ = v : 3 * y < 2 ? _ = h + (v - h) * (2 / 3 - y) * 6 : _ = h, g[m] = _ * 255;
    return g;
  }, i.hsl.hsv = function(c) {
    var l = c[0], d = c[1] / 100, p = c[2] / 100, h = d, v = Math.max(p, 0.01), y, g;
    return p *= 2, d *= p <= 1 ? p : 2 - p, h *= v <= 1 ? v : 2 - v, g = (p + d) / 2, y = p === 0 ? 2 * h / (v + h) : 2 * d / (p + d), [l, y * 100, g * 100];
  }, i.hsv.rgb = function(c) {
    var l = c[0] / 60, d = c[1] / 100, p = c[2] / 100, h = Math.floor(l) % 6, v = l - Math.floor(l), y = 255 * p * (1 - d), g = 255 * p * (1 - d * v), _ = 255 * p * (1 - d * (1 - v));
    switch (p *= 255, h) {
      case 0:
        return [p, _, y];
      case 1:
        return [g, p, y];
      case 2:
        return [y, p, _];
      case 3:
        return [y, g, p];
      case 4:
        return [_, y, p];
      case 5:
        return [p, y, g];
    }
  }, i.hsv.hsl = function(c) {
    var l = c[0], d = c[1] / 100, p = c[2] / 100, h = Math.max(p, 0.01), v, y, g;
    return g = (2 - d) * p, v = (2 - d) * h, y = d * h, y /= v <= 1 ? v : 2 - v, y = y || 0, g /= 2, [l, y * 100, g * 100];
  }, i.hwb.rgb = function(c) {
    var l = c[0] / 360, d = c[1] / 100, p = c[2] / 100, h = d + p, v, y, g, _;
    h > 1 && (d /= h, p /= h), v = Math.floor(6 * l), y = 1 - p, g = 6 * l - v, v & 1 && (g = 1 - g), _ = d + g * (y - d);
    var m, w, $;
    switch (v) {
      default:
      case 6:
      case 0:
        m = y, w = _, $ = d;
        break;
      case 1:
        m = _, w = y, $ = d;
        break;
      case 2:
        m = d, w = y, $ = _;
        break;
      case 3:
        m = d, w = _, $ = y;
        break;
      case 4:
        m = _, w = d, $ = y;
        break;
      case 5:
        m = y, w = d, $ = _;
        break;
    }
    return [m * 255, w * 255, $ * 255];
  }, i.cmyk.rgb = function(c) {
    var l = c[0] / 100, d = c[1] / 100, p = c[2] / 100, h = c[3] / 100, v, y, g;
    return v = 1 - Math.min(1, l * (1 - h) + h), y = 1 - Math.min(1, d * (1 - h) + h), g = 1 - Math.min(1, p * (1 - h) + h), [v * 255, y * 255, g * 255];
  }, i.xyz.rgb = function(c) {
    var l = c[0] / 100, d = c[1] / 100, p = c[2] / 100, h, v, y;
    return h = l * 3.2406 + d * -1.5372 + p * -0.4986, v = l * -0.9689 + d * 1.8758 + p * 0.0415, y = l * 0.0557 + d * -0.204 + p * 1.057, h = h > 31308e-7 ? 1.055 * Math.pow(h, 1 / 2.4) - 0.055 : h * 12.92, v = v > 31308e-7 ? 1.055 * Math.pow(v, 1 / 2.4) - 0.055 : v * 12.92, y = y > 31308e-7 ? 1.055 * Math.pow(y, 1 / 2.4) - 0.055 : y * 12.92, h = Math.min(Math.max(0, h), 1), v = Math.min(Math.max(0, v), 1), y = Math.min(Math.max(0, y), 1), [h * 255, v * 255, y * 255];
  }, i.xyz.lab = function(c) {
    var l = c[0], d = c[1], p = c[2], h, v, y;
    return l /= 95.047, d /= 100, p /= 108.883, l = l > 8856e-6 ? Math.pow(l, 1 / 3) : 7.787 * l + 16 / 116, d = d > 8856e-6 ? Math.pow(d, 1 / 3) : 7.787 * d + 16 / 116, p = p > 8856e-6 ? Math.pow(p, 1 / 3) : 7.787 * p + 16 / 116, h = 116 * d - 16, v = 500 * (l - d), y = 200 * (d - p), [h, v, y];
  }, i.lab.xyz = function(c) {
    var l = c[0], d = c[1], p = c[2], h, v, y;
    v = (l + 16) / 116, h = d / 500 + v, y = v - p / 200;
    var g = Math.pow(v, 3), _ = Math.pow(h, 3), m = Math.pow(y, 3);
    return v = g > 8856e-6 ? g : (v - 16 / 116) / 7.787, h = _ > 8856e-6 ? _ : (h - 16 / 116) / 7.787, y = m > 8856e-6 ? m : (y - 16 / 116) / 7.787, h *= 95.047, v *= 100, y *= 108.883, [h, v, y];
  }, i.lab.lch = function(c) {
    var l = c[0], d = c[1], p = c[2], h, v, y;
    return h = Math.atan2(p, d), v = h * 360 / 2 / Math.PI, v < 0 && (v += 360), y = Math.sqrt(d * d + p * p), [l, y, v];
  }, i.lch.lab = function(c) {
    var l = c[0], d = c[1], p = c[2], h, v, y;
    return y = p / 360 * 2 * Math.PI, h = d * Math.cos(y), v = d * Math.sin(y), [l, h, v];
  }, i.rgb.ansi16 = function(c) {
    var l = c[0], d = c[1], p = c[2], h = 1 in arguments ? arguments[1] : i.rgb.hsv(c)[2];
    if (h = Math.round(h / 50), h === 0)
      return 30;
    var v = 30 + (Math.round(p / 255) << 2 | Math.round(d / 255) << 1 | Math.round(l / 255));
    return h === 2 && (v += 60), v;
  }, i.hsv.ansi16 = function(c) {
    return i.rgb.ansi16(i.hsv.rgb(c), c[2]);
  }, i.rgb.ansi256 = function(c) {
    var l = c[0], d = c[1], p = c[2];
    if (l === d && d === p)
      return l < 8 ? 16 : l > 248 ? 231 : Math.round((l - 8) / 247 * 24) + 232;
    var h = 16 + 36 * Math.round(l / 255 * 5) + 6 * Math.round(d / 255 * 5) + Math.round(p / 255 * 5);
    return h;
  }, i.ansi16.rgb = function(c) {
    var l = c % 10;
    if (l === 0 || l === 7)
      return c > 50 && (l += 3.5), l = l / 10.5 * 255, [l, l, l];
    var d = (~~(c > 50) + 1) * 0.5, p = (l & 1) * d * 255, h = (l >> 1 & 1) * d * 255, v = (l >> 2 & 1) * d * 255;
    return [p, h, v];
  }, i.ansi256.rgb = function(c) {
    if (c >= 232) {
      var l = (c - 232) * 10 + 8;
      return [l, l, l];
    }
    c -= 16;
    var d, p = Math.floor(c / 36) / 5 * 255, h = Math.floor((d = c % 36) / 6) / 5 * 255, v = d % 6 / 5 * 255;
    return [p, h, v];
  }, i.rgb.hex = function(c) {
    var l = ((Math.round(c[0]) & 255) << 16) + ((Math.round(c[1]) & 255) << 8) + (Math.round(c[2]) & 255), d = l.toString(16).toUpperCase();
    return "000000".substring(d.length) + d;
  }, i.hex.rgb = function(c) {
    var l = c.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!l)
      return [0, 0, 0];
    var d = l[0];
    l[0].length === 3 && (d = d.split("").map(function(g) {
      return g + g;
    }).join(""));
    var p = parseInt(d, 16), h = p >> 16 & 255, v = p >> 8 & 255, y = p & 255;
    return [h, v, y];
  }, i.rgb.hcg = function(c) {
    var l = c[0] / 255, d = c[1] / 255, p = c[2] / 255, h = Math.max(Math.max(l, d), p), v = Math.min(Math.min(l, d), p), y = h - v, g, _;
    return y < 1 ? g = v / (1 - y) : g = 0, y <= 0 ? _ = 0 : h === l ? _ = (d - p) / y % 6 : h === d ? _ = 2 + (p - l) / y : _ = 4 + (l - d) / y + 4, _ /= 6, _ %= 1, [_ * 360, y * 100, g * 100];
  }, i.hsl.hcg = function(c) {
    var l = c[1] / 100, d = c[2] / 100, p = 1, h = 0;
    return d < 0.5 ? p = 2 * l * d : p = 2 * l * (1 - d), p < 1 && (h = (d - 0.5 * p) / (1 - p)), [c[0], p * 100, h * 100];
  }, i.hsv.hcg = function(c) {
    var l = c[1] / 100, d = c[2] / 100, p = l * d, h = 0;
    return p < 1 && (h = (d - p) / (1 - p)), [c[0], p * 100, h * 100];
  }, i.hcg.rgb = function(c) {
    var l = c[0] / 360, d = c[1] / 100, p = c[2] / 100;
    if (d === 0)
      return [p * 255, p * 255, p * 255];
    var h = [0, 0, 0], v = l % 1 * 6, y = v % 1, g = 1 - y, _ = 0;
    switch (Math.floor(v)) {
      case 0:
        h[0] = 1, h[1] = y, h[2] = 0;
        break;
      case 1:
        h[0] = g, h[1] = 1, h[2] = 0;
        break;
      case 2:
        h[0] = 0, h[1] = 1, h[2] = y;
        break;
      case 3:
        h[0] = 0, h[1] = g, h[2] = 1;
        break;
      case 4:
        h[0] = y, h[1] = 0, h[2] = 1;
        break;
      default:
        h[0] = 1, h[1] = 0, h[2] = g;
    }
    return _ = (1 - d) * p, [
      (d * h[0] + _) * 255,
      (d * h[1] + _) * 255,
      (d * h[2] + _) * 255
    ];
  }, i.hcg.hsv = function(c) {
    var l = c[1] / 100, d = c[2] / 100, p = l + d * (1 - l), h = 0;
    return p > 0 && (h = l / p), [c[0], h * 100, p * 100];
  }, i.hcg.hsl = function(c) {
    var l = c[1] / 100, d = c[2] / 100, p = d * (1 - l) + 0.5 * l, h = 0;
    return p > 0 && p < 0.5 ? h = l / (2 * p) : p >= 0.5 && p < 1 && (h = l / (2 * (1 - p))), [c[0], h * 100, p * 100];
  }, i.hcg.hwb = function(c) {
    var l = c[1] / 100, d = c[2] / 100, p = l + d * (1 - l);
    return [c[0], (p - l) * 100, (1 - p) * 100];
  }, i.hwb.hcg = function(c) {
    var l = c[1] / 100, d = c[2] / 100, p = 1 - d, h = p - l, v = 0;
    return h < 1 && (v = (p - h) / (1 - h)), [c[0], h * 100, v * 100];
  }, i.apple.rgb = function(c) {
    return [c[0] / 65535 * 255, c[1] / 65535 * 255, c[2] / 65535 * 255];
  }, i.rgb.apple = function(c) {
    return [c[0] / 255 * 65535, c[1] / 255 * 65535, c[2] / 255 * 65535];
  }, i.gray.rgb = function(c) {
    return [c[0] / 100 * 255, c[0] / 100 * 255, c[0] / 100 * 255];
  }, i.gray.hsl = i.gray.hsv = function(c) {
    return [0, 0, c[0]];
  }, i.gray.hwb = function(c) {
    return [0, 100, c[0]];
  }, i.gray.cmyk = function(c) {
    return [0, 0, 0, c[0]];
  }, i.gray.lab = function(c) {
    return [c[0], 0, 0];
  }, i.gray.hex = function(c) {
    var l = Math.round(c[0] / 100 * 255) & 255, d = (l << 16) + (l << 8) + l, p = d.toString(16).toUpperCase();
    return "000000".substring(p.length) + p;
  }, i.rgb.gray = function(c) {
    var l = (c[0] + c[1] + c[2]) / 3;
    return [l / 255 * 100];
  }, Th.exports;
}
var jh, uw;
function H8() {
  if (uw)
    return jh;
  uw = 1;
  var e = QO();
  function t() {
    for (var s = {}, a = Object.keys(e), u = a.length, c = 0; c < u; c++)
      s[a[c]] = {
        // http://jsperf.com/1-vs-infinity
        // micro-opt, but this is simple.
        distance: -1,
        parent: null
      };
    return s;
  }
  function r(s) {
    var a = t(), u = [s];
    for (a[s].distance = 0; u.length; )
      for (var c = u.pop(), l = Object.keys(e[c]), d = l.length, p = 0; p < d; p++) {
        var h = l[p], v = a[h];
        v.distance === -1 && (v.distance = a[c].distance + 1, v.parent = c, u.unshift(h));
      }
    return a;
  }
  function i(s, a) {
    return function(u) {
      return a(s(u));
    };
  }
  function n(s, a) {
    for (var u = [a[s].parent, s], c = e[a[s].parent][s], l = a[s].parent; a[l].parent; )
      u.unshift(a[l].parent), c = i(e[a[l].parent][l], c), l = a[l].parent;
    return c.conversion = u, c;
  }
  return jh = function(s) {
    for (var a = r(s), u = {}, c = Object.keys(a), l = c.length, d = 0; d < l; d++) {
      var p = c[d], h = a[p];
      h.parent !== null && (u[p] = n(p, a));
    }
    return u;
  }, jh;
}
var kh, cw;
function G8() {
  if (cw)
    return kh;
  cw = 1;
  var e = QO(), t = H8(), r = {}, i = Object.keys(e);
  function n(a) {
    var u = function(c) {
      return c == null ? c : (arguments.length > 1 && (c = Array.prototype.slice.call(arguments)), a(c));
    };
    return "conversion" in a && (u.conversion = a.conversion), u;
  }
  function s(a) {
    var u = function(c) {
      if (c == null)
        return c;
      arguments.length > 1 && (c = Array.prototype.slice.call(arguments));
      var l = a(c);
      if (typeof l == "object")
        for (var d = l.length, p = 0; p < d; p++)
          l[p] = Math.round(l[p]);
      return l;
    };
    return "conversion" in a && (u.conversion = a.conversion), u;
  }
  return i.forEach(function(a) {
    r[a] = {}, Object.defineProperty(r[a], "channels", { value: e[a].channels }), Object.defineProperty(r[a], "labels", { value: e[a].labels });
    var u = t(a), c = Object.keys(u);
    c.forEach(function(l) {
      var d = u[l];
      r[a][l] = s(d), r[a][l].raw = n(d);
    });
  }), kh = r, kh;
}
kl.exports;
var lw;
function K8() {
  return lw || (lw = 1, function(e) {
    const t = G8(), r = (a, u) => function() {
      return `\x1B[${a.apply(t, arguments) + u}m`;
    }, i = (a, u) => function() {
      const c = a.apply(t, arguments);
      return `\x1B[${38 + u};5;${c}m`;
    }, n = (a, u) => function() {
      const c = a.apply(t, arguments);
      return `\x1B[${38 + u};2;${c[0]};${c[1]};${c[2]}m`;
    };
    function s() {
      const a = /* @__PURE__ */ new Map(), u = {
        modifier: {
          reset: [0, 0],
          // 21 isn't widely supported and 22 does the same thing
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          gray: [90, 39],
          // Bright color
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          // Bright color
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      u.color.grey = u.color.gray;
      for (const d of Object.keys(u)) {
        const p = u[d];
        for (const h of Object.keys(p)) {
          const v = p[h];
          u[h] = {
            open: `\x1B[${v[0]}m`,
            close: `\x1B[${v[1]}m`
          }, p[h] = u[h], a.set(v[0], v[1]);
        }
        Object.defineProperty(u, d, {
          value: p,
          enumerable: !1
        }), Object.defineProperty(u, "codes", {
          value: a,
          enumerable: !1
        });
      }
      const c = (d) => d, l = (d, p, h) => [d, p, h];
      u.color.close = "\x1B[39m", u.bgColor.close = "\x1B[49m", u.color.ansi = {
        ansi: r(c, 0)
      }, u.color.ansi256 = {
        ansi256: i(c, 0)
      }, u.color.ansi16m = {
        rgb: n(l, 0)
      }, u.bgColor.ansi = {
        ansi: r(c, 10)
      }, u.bgColor.ansi256 = {
        ansi256: i(c, 10)
      }, u.bgColor.ansi16m = {
        rgb: n(l, 10)
      };
      for (let d of Object.keys(t)) {
        if (typeof t[d] != "object")
          continue;
        const p = t[d];
        d === "ansi16" && (d = "ansi"), "ansi16" in p && (u.color.ansi[d] = r(p.ansi16, 0), u.bgColor.ansi[d] = r(p.ansi16, 10)), "ansi256" in p && (u.color.ansi256[d] = i(p.ansi256, 0), u.bgColor.ansi256[d] = i(p.ansi256, 10)), "rgb" in p && (u.color.ansi16m[d] = n(p.rgb, 0), u.bgColor.ansi16m[d] = n(p.rgb, 10));
      }
      return u;
    }
    Object.defineProperty(e, "exports", {
      enumerable: !0,
      get: s
    });
  }(kl)), kl.exports;
}
var Mh, fw;
function Y8() {
  return fw || (fw = 1, Mh = {
    stdout: !1,
    stderr: !1
  }), Mh;
}
var Nh, dw;
function J8() {
  if (dw)
    return Nh;
  dw = 1;
  const e = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi, t = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, r = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, i = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi, n = /* @__PURE__ */ new Map([
    ["n", `
`],
    ["r", "\r"],
    ["t", "	"],
    ["b", "\b"],
    ["f", "\f"],
    ["v", "\v"],
    ["0", "\0"],
    ["\\", "\\"],
    ["e", "\x1B"],
    ["a", "\x07"]
  ]);
  function s(l) {
    return l[0] === "u" && l.length === 5 || l[0] === "x" && l.length === 3 ? String.fromCharCode(parseInt(l.slice(1), 16)) : n.get(l) || l;
  }
  function a(l, d) {
    const p = [], h = d.trim().split(/\s*,\s*/g);
    let v;
    for (const y of h)
      if (!isNaN(y))
        p.push(Number(y));
      else if (v = y.match(r))
        p.push(v[2].replace(i, (g, _, m) => _ ? s(_) : m));
      else
        throw new Error(`Invalid Chalk template style argument: ${y} (in style '${l}')`);
    return p;
  }
  function u(l) {
    t.lastIndex = 0;
    const d = [];
    let p;
    for (; (p = t.exec(l)) !== null; ) {
      const h = p[1];
      if (p[2]) {
        const v = a(h, p[2]);
        d.push([h].concat(v));
      } else
        d.push([h]);
    }
    return d;
  }
  function c(l, d) {
    const p = {};
    for (const v of d)
      for (const y of v.styles)
        p[y[0]] = v.inverse ? null : y.slice(1);
    let h = l;
    for (const v of Object.keys(p))
      if (Array.isArray(p[v])) {
        if (!(v in h))
          throw new Error(`Unknown Chalk style: ${v}`);
        p[v].length > 0 ? h = h[v].apply(h, p[v]) : h = h[v];
      }
    return h;
  }
  return Nh = (l, d) => {
    const p = [], h = [];
    let v = [];
    if (d.replace(e, (y, g, _, m, w, $) => {
      if (g)
        v.push(s(g));
      else if (m) {
        const E = v.join("");
        v = [], h.push(p.length === 0 ? E : c(l, p)(E)), p.push({ inverse: _, styles: u(m) });
      } else if (w) {
        if (p.length === 0)
          throw new Error("Found extraneous } in Chalk template literal");
        h.push(c(l, p)(v.join(""))), v = [], p.pop();
      } else
        v.push($);
    }), h.push(v.join("")), p.length > 0) {
      const y = `Chalk template literal is missing ${p.length} closing bracket${p.length === 1 ? "" : "s"} (\`}\`)`;
      throw new Error(y);
    }
    return h.join("");
  }, Nh;
}
var pw;
function eP() {
  return pw || (pw = 1, function(e) {
    const t = z8(), r = K8(), i = Y8().stdout, n = J8(), s = Me.process.platform === "win32" && !(Me.process.env.TERM || "").toLowerCase().startsWith("xterm"), a = ["ansi", "ansi", "ansi256", "ansi16m"], u = /* @__PURE__ */ new Set(["gray"]), c = /* @__PURE__ */ Object.create(null);
    function l(g, _) {
      _ = _ || {};
      const m = i ? i.level : 0;
      g.level = _.level === void 0 ? m : _.level, g.enabled = "enabled" in _ ? _.enabled : g.level > 0;
    }
    function d(g) {
      if (!this || !(this instanceof d) || this.template) {
        const _ = {};
        return l(_, g), _.template = function() {
          const m = [].slice.call(arguments);
          return y.apply(null, [_.template].concat(m));
        }, Object.setPrototypeOf(_, d.prototype), Object.setPrototypeOf(_.template, _), _.template.constructor = d, _.template;
      }
      l(this, g);
    }
    s && (r.blue.open = "\x1B[94m");
    for (const g of Object.keys(r))
      r[g].closeRe = new RegExp(t(r[g].close), "g"), c[g] = {
        get() {
          const _ = r[g];
          return h.call(this, this._styles ? this._styles.concat(_) : [_], this._empty, g);
        }
      };
    c.visible = {
      get() {
        return h.call(this, this._styles || [], !0, "visible");
      }
    }, r.color.closeRe = new RegExp(t(r.color.close), "g");
    for (const g of Object.keys(r.color.ansi))
      u.has(g) || (c[g] = {
        get() {
          const _ = this.level;
          return function() {
            const w = {
              open: r.color[a[_]][g].apply(null, arguments),
              close: r.color.close,
              closeRe: r.color.closeRe
            };
            return h.call(this, this._styles ? this._styles.concat(w) : [w], this._empty, g);
          };
        }
      });
    r.bgColor.closeRe = new RegExp(t(r.bgColor.close), "g");
    for (const g of Object.keys(r.bgColor.ansi)) {
      if (u.has(g))
        continue;
      const _ = "bg" + g[0].toUpperCase() + g.slice(1);
      c[_] = {
        get() {
          const m = this.level;
          return function() {
            const $ = {
              open: r.bgColor[a[m]][g].apply(null, arguments),
              close: r.bgColor.close,
              closeRe: r.bgColor.closeRe
            };
            return h.call(this, this._styles ? this._styles.concat($) : [$], this._empty, g);
          };
        }
      };
    }
    const p = Object.defineProperties(() => {
    }, c);
    function h(g, _, m) {
      const w = function() {
        return v.apply(w, arguments);
      };
      w._styles = g, w._empty = _;
      const $ = this;
      return Object.defineProperty(w, "level", {
        enumerable: !0,
        get() {
          return $.level;
        },
        set(E) {
          $.level = E;
        }
      }), Object.defineProperty(w, "enabled", {
        enumerable: !0,
        get() {
          return $.enabled;
        },
        set(E) {
          $.enabled = E;
        }
      }), w.hasGrey = this.hasGrey || m === "gray" || m === "grey", w.__proto__ = p, w;
    }
    function v() {
      const g = arguments, _ = g.length;
      let m = String(arguments[0]);
      if (_ === 0)
        return "";
      if (_ > 1)
        for (let $ = 1; $ < _; $++)
          m += " " + g[$];
      if (!this.enabled || this.level <= 0 || !m)
        return this._empty ? "" : m;
      const w = r.dim.open;
      s && this.hasGrey && (r.dim.open = "");
      for (const $ of this._styles.slice().reverse())
        m = $.open + m.replace($.closeRe, $.open) + $.close, m = m.replace(/\r?\n/g, `${$.close}$&${$.open}`);
      return r.dim.open = w, m;
    }
    function y(g, _) {
      if (!Array.isArray(_))
        return [].slice.call(arguments, 1).join(" ");
      const m = [].slice.call(arguments, 2), w = [_.raw[0]];
      for (let $ = 1; $ < _.length; $++)
        w.push(String(m[$ - 1]).replace(/[{}\\]/g, "\\$&")), w.push(String(_.raw[$]));
      return n(g, w.join(""));
    }
    Object.defineProperties(d.prototype, c), e.exports = d(), e.exports.supportsColor = i, e.exports.default = e.exports;
  }(Ch)), Ch.exports;
}
var hw;
function X8() {
  if (hw)
    return Ta;
  hw = 1, Object.defineProperty(Ta, "__esModule", {
    value: !0
  }), Ta.default = y, Ta.shouldHighlight = p;
  var e = U8(), t = Z8(), r = n(eP(), !0);
  function i(g) {
    if (typeof WeakMap != "function")
      return null;
    var _ = /* @__PURE__ */ new WeakMap(), m = /* @__PURE__ */ new WeakMap();
    return (i = function(w) {
      return w ? m : _;
    })(g);
  }
  function n(g, _) {
    if (!_ && g && g.__esModule)
      return g;
    if (g === null || typeof g != "object" && typeof g != "function")
      return { default: g };
    var m = i(_);
    if (m && m.has(g))
      return m.get(g);
    var w = {}, $ = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var E in g)
      if (E !== "default" && Object.prototype.hasOwnProperty.call(g, E)) {
        var A = $ ? Object.getOwnPropertyDescriptor(g, E) : null;
        A && (A.get || A.set) ? Object.defineProperty(w, E, A) : w[E] = g[E];
      }
    return w.default = g, m && m.set(g, w), w;
  }
  const s = /* @__PURE__ */ new Set(["as", "async", "from", "get", "of", "set"]);
  function a(g) {
    return {
      keyword: g.cyan,
      capitalized: g.yellow,
      jsxIdentifier: g.yellow,
      punctuator: g.yellow,
      number: g.magenta,
      string: g.green,
      regex: g.magenta,
      comment: g.grey,
      invalid: g.white.bgRed.bold
    };
  }
  const u = /\r\n|[\n\r\u2028\u2029]/, c = /^[()[\]{}]$/;
  let l;
  {
    const g = /^[a-z][\w-]*$/i, _ = function(m, w, $) {
      if (m.type === "name") {
        if ((0, t.isKeyword)(m.value) || (0, t.isStrictReservedWord)(m.value, !0) || s.has(m.value))
          return "keyword";
        if (g.test(m.value) && ($[w - 1] === "<" || $.slice(w - 2, w) == "</"))
          return "jsxIdentifier";
        if (m.value[0] !== m.value[0].toLowerCase())
          return "capitalized";
      }
      return m.type === "punctuator" && c.test(m.value) ? "bracket" : m.type === "invalid" && (m.value === "@" || m.value === "#") ? "punctuator" : m.type;
    };
    l = function* (m) {
      let w;
      for (; w = e.default.exec(m); ) {
        const $ = e.matchToToken(w);
        yield {
          type: _($, w.index, m),
          value: $.value
        };
      }
    };
  }
  function d(g, _) {
    let m = "";
    for (const {
      type: w,
      value: $
    } of l(_)) {
      const E = g[w];
      E ? m += $.split(u).map((A) => E(A)).join(`
`) : m += $;
    }
    return m;
  }
  function p(g) {
    return r.default.level > 0 || g.forceColor;
  }
  let h;
  function v(g) {
    if (g) {
      var _;
      return (_ = h) != null || (h = new r.default.constructor({
        enabled: !0,
        level: 1
      })), h;
    }
    return r.default;
  }
  Ta.getChalk = (g) => v(g.forceColor);
  function y(g, _ = {}) {
    if (g !== "" && p(_)) {
      const m = a(v(_.forceColor));
      return d(m, g);
    } else
      return g;
  }
  return Ta;
}
var mw;
function Q8() {
  if (mw)
    return Go;
  mw = 1, Object.defineProperty(Go, "__esModule", {
    value: !0
  }), Go.codeFrameColumns = d, Go.default = p;
  var e = X8(), t = i(eP(), !0);
  function r(h) {
    if (typeof WeakMap != "function")
      return null;
    var v = /* @__PURE__ */ new WeakMap(), y = /* @__PURE__ */ new WeakMap();
    return (r = function(g) {
      return g ? y : v;
    })(h);
  }
  function i(h, v) {
    if (!v && h && h.__esModule)
      return h;
    if (h === null || typeof h != "object" && typeof h != "function")
      return { default: h };
    var y = r(v);
    if (y && y.has(h))
      return y.get(h);
    var g = {}, _ = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var m in h)
      if (m !== "default" && Object.prototype.hasOwnProperty.call(h, m)) {
        var w = _ ? Object.getOwnPropertyDescriptor(h, m) : null;
        w && (w.get || w.set) ? Object.defineProperty(g, m, w) : g[m] = h[m];
      }
    return g.default = h, y && y.set(h, g), g;
  }
  let n;
  function s(h) {
    if (h) {
      var v;
      return (v = n) != null || (n = new t.default.constructor({
        enabled: !0,
        level: 1
      })), n;
    }
    return t.default;
  }
  let a = !1;
  function u(h) {
    return {
      gutter: h.grey,
      marker: h.red.bold,
      message: h.red.bold
    };
  }
  const c = /\r\n|[\n\r\u2028\u2029]/;
  function l(h, v, y) {
    const g = Object.assign({
      column: 0,
      line: -1
    }, h.start), _ = Object.assign({}, g, h.end), {
      linesAbove: m = 2,
      linesBelow: w = 3
    } = y || {}, $ = g.line, E = g.column, A = _.line, R = _.column;
    let I = Math.max($ - (m + 1), 0), D = Math.min(v.length, A + w);
    $ === -1 && (I = 0), A === -1 && (D = v.length);
    const J = A - $, ae = {};
    if (J)
      for (let ye = 0; ye <= J; ye++) {
        const xe = ye + $;
        if (!E)
          ae[xe] = !0;
        else if (ye === 0) {
          const je = v[xe - 1].length;
          ae[xe] = [E, je - E + 1];
        } else if (ye === J)
          ae[xe] = [0, R];
        else {
          const je = v[xe - ye].length;
          ae[xe] = [0, je];
        }
      }
    else
      E === R ? E ? ae[$] = [E, 0] : ae[$] = !0 : ae[$] = [E, R - E];
    return {
      start: I,
      end: D,
      markerLines: ae
    };
  }
  function d(h, v, y = {}) {
    const g = (y.highlightCode || y.forceColor) && (0, e.shouldHighlight)(y), _ = s(y.forceColor), m = u(_), w = (ye, xe) => g ? ye(xe) : xe, $ = h.split(c), {
      start: E,
      end: A,
      markerLines: R
    } = l(v, $, y), I = v.start && typeof v.start.column == "number", D = String(A).length;
    let ae = (g ? (0, e.default)(h, y) : h).split(c, A).slice(E, A).map((ye, xe) => {
      const je = E + 1 + xe, fe = ` ${` ${je}`.slice(-D)} |`, le = R[je], $e = !R[je + 1];
      if (le) {
        let Ae = "";
        if (Array.isArray(le)) {
          const _e = ye.slice(0, Math.max(le[0] - 1, 0)).replace(/[^\t]/g, " "), ie = le[1] || 1;
          Ae = [`
 `, w(m.gutter, fe.replace(/\d/g, " ")), " ", _e, w(m.marker, "^").repeat(ie)].join(""), $e && y.message && (Ae += " " + w(m.message, y.message));
        }
        return [w(m.marker, ">"), w(m.gutter, fe), ye.length > 0 ? ` ${ye}` : "", Ae].join("");
      } else
        return ` ${w(m.gutter, fe)}${ye.length > 0 ? ` ${ye}` : ""}`;
    }).join(`
`);
    return y.message && !I && (ae = `${" ".repeat(D + 1)}${y.message}
${ae}`), g ? _.reset(ae) : ae;
  }
  function p(h, v, y, g = {}) {
    if (!a) {
      a = !0;
      const m = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
      if (Me.process.emitWarning)
        Me.process.emitWarning(m, "DeprecationWarning");
      else {
        const w = new Error(m);
        w.name = "DeprecationWarning", console.warn(new Error(m));
      }
    }
    return y = Math.max(y, 0), d(h, {
      start: {
        column: y,
        line: v
      }
    }, g);
  }
  return Go;
}
var Ml = { exports: {} }, Dh, yw;
function eF() {
  return yw || (yw = 1, Dh = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  }), Dh;
}
var Lh, gw;
function tP() {
  if (gw)
    return Lh;
  gw = 1;
  const e = eF(), t = {};
  for (const n of Object.keys(e))
    t[e[n]] = n;
  const r = {
    rgb: { channels: 3, labels: "rgb" },
    hsl: { channels: 3, labels: "hsl" },
    hsv: { channels: 3, labels: "hsv" },
    hwb: { channels: 3, labels: "hwb" },
    cmyk: { channels: 4, labels: "cmyk" },
    xyz: { channels: 3, labels: "xyz" },
    lab: { channels: 3, labels: "lab" },
    lch: { channels: 3, labels: "lch" },
    hex: { channels: 1, labels: ["hex"] },
    keyword: { channels: 1, labels: ["keyword"] },
    ansi16: { channels: 1, labels: ["ansi16"] },
    ansi256: { channels: 1, labels: ["ansi256"] },
    hcg: { channels: 3, labels: ["h", "c", "g"] },
    apple: { channels: 3, labels: ["r16", "g16", "b16"] },
    gray: { channels: 1, labels: ["gray"] }
  };
  Lh = r;
  for (const n of Object.keys(r)) {
    if (!("channels" in r[n]))
      throw new Error("missing channels property: " + n);
    if (!("labels" in r[n]))
      throw new Error("missing channel labels property: " + n);
    if (r[n].labels.length !== r[n].channels)
      throw new Error("channel and label counts mismatch: " + n);
    const { channels: s, labels: a } = r[n];
    delete r[n].channels, delete r[n].labels, Object.defineProperty(r[n], "channels", { value: s }), Object.defineProperty(r[n], "labels", { value: a });
  }
  r.rgb.hsl = function(n) {
    const s = n[0] / 255, a = n[1] / 255, u = n[2] / 255, c = Math.min(s, a, u), l = Math.max(s, a, u), d = l - c;
    let p, h;
    l === c ? p = 0 : s === l ? p = (a - u) / d : a === l ? p = 2 + (u - s) / d : u === l && (p = 4 + (s - a) / d), p = Math.min(p * 60, 360), p < 0 && (p += 360);
    const v = (c + l) / 2;
    return l === c ? h = 0 : v <= 0.5 ? h = d / (l + c) : h = d / (2 - l - c), [p, h * 100, v * 100];
  }, r.rgb.hsv = function(n) {
    let s, a, u, c, l;
    const d = n[0] / 255, p = n[1] / 255, h = n[2] / 255, v = Math.max(d, p, h), y = v - Math.min(d, p, h), g = function(_) {
      return (v - _) / 6 / y + 1 / 2;
    };
    return y === 0 ? (c = 0, l = 0) : (l = y / v, s = g(d), a = g(p), u = g(h), d === v ? c = u - a : p === v ? c = 1 / 3 + s - u : h === v && (c = 2 / 3 + a - s), c < 0 ? c += 1 : c > 1 && (c -= 1)), [
      c * 360,
      l * 100,
      v * 100
    ];
  }, r.rgb.hwb = function(n) {
    const s = n[0], a = n[1];
    let u = n[2];
    const c = r.rgb.hsl(n)[0], l = 1 / 255 * Math.min(s, Math.min(a, u));
    return u = 1 - 1 / 255 * Math.max(s, Math.max(a, u)), [c, l * 100, u * 100];
  }, r.rgb.cmyk = function(n) {
    const s = n[0] / 255, a = n[1] / 255, u = n[2] / 255, c = Math.min(1 - s, 1 - a, 1 - u), l = (1 - s - c) / (1 - c) || 0, d = (1 - a - c) / (1 - c) || 0, p = (1 - u - c) / (1 - c) || 0;
    return [l * 100, d * 100, p * 100, c * 100];
  };
  function i(n, s) {
    return (n[0] - s[0]) ** 2 + (n[1] - s[1]) ** 2 + (n[2] - s[2]) ** 2;
  }
  return r.rgb.keyword = function(n) {
    const s = t[n];
    if (s)
      return s;
    let a = 1 / 0, u;
    for (const c of Object.keys(e)) {
      const l = e[c], d = i(n, l);
      d < a && (a = d, u = c);
    }
    return u;
  }, r.keyword.rgb = function(n) {
    return e[n];
  }, r.rgb.xyz = function(n) {
    let s = n[0] / 255, a = n[1] / 255, u = n[2] / 255;
    s = s > 0.04045 ? ((s + 0.055) / 1.055) ** 2.4 : s / 12.92, a = a > 0.04045 ? ((a + 0.055) / 1.055) ** 2.4 : a / 12.92, u = u > 0.04045 ? ((u + 0.055) / 1.055) ** 2.4 : u / 12.92;
    const c = s * 0.4124 + a * 0.3576 + u * 0.1805, l = s * 0.2126 + a * 0.7152 + u * 0.0722, d = s * 0.0193 + a * 0.1192 + u * 0.9505;
    return [c * 100, l * 100, d * 100];
  }, r.rgb.lab = function(n) {
    const s = r.rgb.xyz(n);
    let a = s[0], u = s[1], c = s[2];
    a /= 95.047, u /= 100, c /= 108.883, a = a > 8856e-6 ? a ** (1 / 3) : 7.787 * a + 16 / 116, u = u > 8856e-6 ? u ** (1 / 3) : 7.787 * u + 16 / 116, c = c > 8856e-6 ? c ** (1 / 3) : 7.787 * c + 16 / 116;
    const l = 116 * u - 16, d = 500 * (a - u), p = 200 * (u - c);
    return [l, d, p];
  }, r.hsl.rgb = function(n) {
    const s = n[0] / 360, a = n[1] / 100, u = n[2] / 100;
    let c, l, d;
    if (a === 0)
      return d = u * 255, [d, d, d];
    u < 0.5 ? c = u * (1 + a) : c = u + a - u * a;
    const p = 2 * u - c, h = [0, 0, 0];
    for (let v = 0; v < 3; v++)
      l = s + 1 / 3 * -(v - 1), l < 0 && l++, l > 1 && l--, 6 * l < 1 ? d = p + (c - p) * 6 * l : 2 * l < 1 ? d = c : 3 * l < 2 ? d = p + (c - p) * (2 / 3 - l) * 6 : d = p, h[v] = d * 255;
    return h;
  }, r.hsl.hsv = function(n) {
    const s = n[0];
    let a = n[1] / 100, u = n[2] / 100, c = a;
    const l = Math.max(u, 0.01);
    u *= 2, a *= u <= 1 ? u : 2 - u, c *= l <= 1 ? l : 2 - l;
    const d = (u + a) / 2, p = u === 0 ? 2 * c / (l + c) : 2 * a / (u + a);
    return [s, p * 100, d * 100];
  }, r.hsv.rgb = function(n) {
    const s = n[0] / 60, a = n[1] / 100;
    let u = n[2] / 100;
    const c = Math.floor(s) % 6, l = s - Math.floor(s), d = 255 * u * (1 - a), p = 255 * u * (1 - a * l), h = 255 * u * (1 - a * (1 - l));
    switch (u *= 255, c) {
      case 0:
        return [u, h, d];
      case 1:
        return [p, u, d];
      case 2:
        return [d, u, h];
      case 3:
        return [d, p, u];
      case 4:
        return [h, d, u];
      case 5:
        return [u, d, p];
    }
  }, r.hsv.hsl = function(n) {
    const s = n[0], a = n[1] / 100, u = n[2] / 100, c = Math.max(u, 0.01);
    let l, d;
    d = (2 - a) * u;
    const p = (2 - a) * c;
    return l = a * c, l /= p <= 1 ? p : 2 - p, l = l || 0, d /= 2, [s, l * 100, d * 100];
  }, r.hwb.rgb = function(n) {
    const s = n[0] / 360;
    let a = n[1] / 100, u = n[2] / 100;
    const c = a + u;
    let l;
    c > 1 && (a /= c, u /= c);
    const d = Math.floor(6 * s), p = 1 - u;
    l = 6 * s - d, d & 1 && (l = 1 - l);
    const h = a + l * (p - a);
    let v, y, g;
    switch (d) {
      default:
      case 6:
      case 0:
        v = p, y = h, g = a;
        break;
      case 1:
        v = h, y = p, g = a;
        break;
      case 2:
        v = a, y = p, g = h;
        break;
      case 3:
        v = a, y = h, g = p;
        break;
      case 4:
        v = h, y = a, g = p;
        break;
      case 5:
        v = p, y = a, g = h;
        break;
    }
    return [v * 255, y * 255, g * 255];
  }, r.cmyk.rgb = function(n) {
    const s = n[0] / 100, a = n[1] / 100, u = n[2] / 100, c = n[3] / 100, l = 1 - Math.min(1, s * (1 - c) + c), d = 1 - Math.min(1, a * (1 - c) + c), p = 1 - Math.min(1, u * (1 - c) + c);
    return [l * 255, d * 255, p * 255];
  }, r.xyz.rgb = function(n) {
    const s = n[0] / 100, a = n[1] / 100, u = n[2] / 100;
    let c, l, d;
    return c = s * 3.2406 + a * -1.5372 + u * -0.4986, l = s * -0.9689 + a * 1.8758 + u * 0.0415, d = s * 0.0557 + a * -0.204 + u * 1.057, c = c > 31308e-7 ? 1.055 * c ** (1 / 2.4) - 0.055 : c * 12.92, l = l > 31308e-7 ? 1.055 * l ** (1 / 2.4) - 0.055 : l * 12.92, d = d > 31308e-7 ? 1.055 * d ** (1 / 2.4) - 0.055 : d * 12.92, c = Math.min(Math.max(0, c), 1), l = Math.min(Math.max(0, l), 1), d = Math.min(Math.max(0, d), 1), [c * 255, l * 255, d * 255];
  }, r.xyz.lab = function(n) {
    let s = n[0], a = n[1], u = n[2];
    s /= 95.047, a /= 100, u /= 108.883, s = s > 8856e-6 ? s ** (1 / 3) : 7.787 * s + 16 / 116, a = a > 8856e-6 ? a ** (1 / 3) : 7.787 * a + 16 / 116, u = u > 8856e-6 ? u ** (1 / 3) : 7.787 * u + 16 / 116;
    const c = 116 * a - 16, l = 500 * (s - a), d = 200 * (a - u);
    return [c, l, d];
  }, r.lab.xyz = function(n) {
    const s = n[0], a = n[1], u = n[2];
    let c, l, d;
    l = (s + 16) / 116, c = a / 500 + l, d = l - u / 200;
    const p = l ** 3, h = c ** 3, v = d ** 3;
    return l = p > 8856e-6 ? p : (l - 16 / 116) / 7.787, c = h > 8856e-6 ? h : (c - 16 / 116) / 7.787, d = v > 8856e-6 ? v : (d - 16 / 116) / 7.787, c *= 95.047, l *= 100, d *= 108.883, [c, l, d];
  }, r.lab.lch = function(n) {
    const s = n[0], a = n[1], u = n[2];
    let c;
    c = Math.atan2(u, a) * 360 / 2 / Math.PI, c < 0 && (c += 360);
    const d = Math.sqrt(a * a + u * u);
    return [s, d, c];
  }, r.lch.lab = function(n) {
    const s = n[0], a = n[1], c = n[2] / 360 * 2 * Math.PI, l = a * Math.cos(c), d = a * Math.sin(c);
    return [s, l, d];
  }, r.rgb.ansi16 = function(n, s = null) {
    const [a, u, c] = n;
    let l = s === null ? r.rgb.hsv(n)[2] : s;
    if (l = Math.round(l / 50), l === 0)
      return 30;
    let d = 30 + (Math.round(c / 255) << 2 | Math.round(u / 255) << 1 | Math.round(a / 255));
    return l === 2 && (d += 60), d;
  }, r.hsv.ansi16 = function(n) {
    return r.rgb.ansi16(r.hsv.rgb(n), n[2]);
  }, r.rgb.ansi256 = function(n) {
    const s = n[0], a = n[1], u = n[2];
    return s === a && a === u ? s < 8 ? 16 : s > 248 ? 231 : Math.round((s - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(s / 255 * 5) + 6 * Math.round(a / 255 * 5) + Math.round(u / 255 * 5);
  }, r.ansi16.rgb = function(n) {
    let s = n % 10;
    if (s === 0 || s === 7)
      return n > 50 && (s += 3.5), s = s / 10.5 * 255, [s, s, s];
    const a = (~~(n > 50) + 1) * 0.5, u = (s & 1) * a * 255, c = (s >> 1 & 1) * a * 255, l = (s >> 2 & 1) * a * 255;
    return [u, c, l];
  }, r.ansi256.rgb = function(n) {
    if (n >= 232) {
      const l = (n - 232) * 10 + 8;
      return [l, l, l];
    }
    n -= 16;
    let s;
    const a = Math.floor(n / 36) / 5 * 255, u = Math.floor((s = n % 36) / 6) / 5 * 255, c = s % 6 / 5 * 255;
    return [a, u, c];
  }, r.rgb.hex = function(n) {
    const a = (((Math.round(n[0]) & 255) << 16) + ((Math.round(n[1]) & 255) << 8) + (Math.round(n[2]) & 255)).toString(16).toUpperCase();
    return "000000".substring(a.length) + a;
  }, r.hex.rgb = function(n) {
    const s = n.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!s)
      return [0, 0, 0];
    let a = s[0];
    s[0].length === 3 && (a = a.split("").map((p) => p + p).join(""));
    const u = parseInt(a, 16), c = u >> 16 & 255, l = u >> 8 & 255, d = u & 255;
    return [c, l, d];
  }, r.rgb.hcg = function(n) {
    const s = n[0] / 255, a = n[1] / 255, u = n[2] / 255, c = Math.max(Math.max(s, a), u), l = Math.min(Math.min(s, a), u), d = c - l;
    let p, h;
    return d < 1 ? p = l / (1 - d) : p = 0, d <= 0 ? h = 0 : c === s ? h = (a - u) / d % 6 : c === a ? h = 2 + (u - s) / d : h = 4 + (s - a) / d, h /= 6, h %= 1, [h * 360, d * 100, p * 100];
  }, r.hsl.hcg = function(n) {
    const s = n[1] / 100, a = n[2] / 100, u = a < 0.5 ? 2 * s * a : 2 * s * (1 - a);
    let c = 0;
    return u < 1 && (c = (a - 0.5 * u) / (1 - u)), [n[0], u * 100, c * 100];
  }, r.hsv.hcg = function(n) {
    const s = n[1] / 100, a = n[2] / 100, u = s * a;
    let c = 0;
    return u < 1 && (c = (a - u) / (1 - u)), [n[0], u * 100, c * 100];
  }, r.hcg.rgb = function(n) {
    const s = n[0] / 360, a = n[1] / 100, u = n[2] / 100;
    if (a === 0)
      return [u * 255, u * 255, u * 255];
    const c = [0, 0, 0], l = s % 1 * 6, d = l % 1, p = 1 - d;
    let h = 0;
    switch (Math.floor(l)) {
      case 0:
        c[0] = 1, c[1] = d, c[2] = 0;
        break;
      case 1:
        c[0] = p, c[1] = 1, c[2] = 0;
        break;
      case 2:
        c[0] = 0, c[1] = 1, c[2] = d;
        break;
      case 3:
        c[0] = 0, c[1] = p, c[2] = 1;
        break;
      case 4:
        c[0] = d, c[1] = 0, c[2] = 1;
        break;
      default:
        c[0] = 1, c[1] = 0, c[2] = p;
    }
    return h = (1 - a) * u, [
      (a * c[0] + h) * 255,
      (a * c[1] + h) * 255,
      (a * c[2] + h) * 255
    ];
  }, r.hcg.hsv = function(n) {
    const s = n[1] / 100, a = n[2] / 100, u = s + a * (1 - s);
    let c = 0;
    return u > 0 && (c = s / u), [n[0], c * 100, u * 100];
  }, r.hcg.hsl = function(n) {
    const s = n[1] / 100, u = n[2] / 100 * (1 - s) + 0.5 * s;
    let c = 0;
    return u > 0 && u < 0.5 ? c = s / (2 * u) : u >= 0.5 && u < 1 && (c = s / (2 * (1 - u))), [n[0], c * 100, u * 100];
  }, r.hcg.hwb = function(n) {
    const s = n[1] / 100, a = n[2] / 100, u = s + a * (1 - s);
    return [n[0], (u - s) * 100, (1 - u) * 100];
  }, r.hwb.hcg = function(n) {
    const s = n[1] / 100, u = 1 - n[2] / 100, c = u - s;
    let l = 0;
    return c < 1 && (l = (u - c) / (1 - c)), [n[0], c * 100, l * 100];
  }, r.apple.rgb = function(n) {
    return [n[0] / 65535 * 255, n[1] / 65535 * 255, n[2] / 65535 * 255];
  }, r.rgb.apple = function(n) {
    return [n[0] / 255 * 65535, n[1] / 255 * 65535, n[2] / 255 * 65535];
  }, r.gray.rgb = function(n) {
    return [n[0] / 100 * 255, n[0] / 100 * 255, n[0] / 100 * 255];
  }, r.gray.hsl = function(n) {
    return [0, 0, n[0]];
  }, r.gray.hsv = r.gray.hsl, r.gray.hwb = function(n) {
    return [0, 100, n[0]];
  }, r.gray.cmyk = function(n) {
    return [0, 0, 0, n[0]];
  }, r.gray.lab = function(n) {
    return [n[0], 0, 0];
  }, r.gray.hex = function(n) {
    const s = Math.round(n[0] / 100 * 255) & 255, u = ((s << 16) + (s << 8) + s).toString(16).toUpperCase();
    return "000000".substring(u.length) + u;
  }, r.rgb.gray = function(n) {
    return [(n[0] + n[1] + n[2]) / 3 / 255 * 100];
  }, Lh;
}
var qh, vw;
function tF() {
  if (vw)
    return qh;
  vw = 1;
  const e = tP();
  function t() {
    const s = {}, a = Object.keys(e);
    for (let u = a.length, c = 0; c < u; c++)
      s[a[c]] = {
        // http://jsperf.com/1-vs-infinity
        // micro-opt, but this is simple.
        distance: -1,
        parent: null
      };
    return s;
  }
  function r(s) {
    const a = t(), u = [s];
    for (a[s].distance = 0; u.length; ) {
      const c = u.pop(), l = Object.keys(e[c]);
      for (let d = l.length, p = 0; p < d; p++) {
        const h = l[p], v = a[h];
        v.distance === -1 && (v.distance = a[c].distance + 1, v.parent = c, u.unshift(h));
      }
    }
    return a;
  }
  function i(s, a) {
    return function(u) {
      return a(s(u));
    };
  }
  function n(s, a) {
    const u = [a[s].parent, s];
    let c = e[a[s].parent][s], l = a[s].parent;
    for (; a[l].parent; )
      u.unshift(a[l].parent), c = i(e[a[l].parent][l], c), l = a[l].parent;
    return c.conversion = u, c;
  }
  return qh = function(s) {
    const a = r(s), u = {}, c = Object.keys(a);
    for (let l = c.length, d = 0; d < l; d++) {
      const p = c[d];
      a[p].parent !== null && (u[p] = n(p, a));
    }
    return u;
  }, qh;
}
var Fh, bw;
function rF() {
  if (bw)
    return Fh;
  bw = 1;
  const e = tP(), t = tF(), r = {}, i = Object.keys(e);
  function n(a) {
    const u = function(...c) {
      const l = c[0];
      return l == null ? l : (l.length > 1 && (c = l), a(c));
    };
    return "conversion" in a && (u.conversion = a.conversion), u;
  }
  function s(a) {
    const u = function(...c) {
      const l = c[0];
      if (l == null)
        return l;
      l.length > 1 && (c = l);
      const d = a(c);
      if (typeof d == "object")
        for (let p = d.length, h = 0; h < p; h++)
          d[h] = Math.round(d[h]);
      return d;
    };
    return "conversion" in a && (u.conversion = a.conversion), u;
  }
  return i.forEach((a) => {
    r[a] = {}, Object.defineProperty(r[a], "channels", { value: e[a].channels }), Object.defineProperty(r[a], "labels", { value: e[a].labels });
    const u = t(a);
    Object.keys(u).forEach((l) => {
      const d = u[l];
      r[a][l] = s(d), r[a][l].raw = n(d);
    });
  }), Fh = r, Fh;
}
Ml.exports;
var _w;
function nF() {
  return _w || (_w = 1, function(e) {
    const t = (d, p) => (...h) => `\x1B[${d(...h) + p}m`, r = (d, p) => (...h) => {
      const v = d(...h);
      return `\x1B[${38 + p};5;${v}m`;
    }, i = (d, p) => (...h) => {
      const v = d(...h);
      return `\x1B[${38 + p};2;${v[0]};${v[1]};${v[2]}m`;
    }, n = (d) => d, s = (d, p, h) => [d, p, h], a = (d, p, h) => {
      Object.defineProperty(d, p, {
        get: () => {
          const v = h();
          return Object.defineProperty(d, p, {
            value: v,
            enumerable: !0,
            configurable: !0
          }), v;
        },
        enumerable: !0,
        configurable: !0
      });
    };
    let u;
    const c = (d, p, h, v) => {
      u === void 0 && (u = rF());
      const y = v ? 10 : 0, g = {};
      for (const [_, m] of Object.entries(u)) {
        const w = _ === "ansi16" ? "ansi" : _;
        _ === p ? g[w] = d(h, y) : typeof m == "object" && (g[w] = d(m[p], y));
      }
      return g;
    };
    function l() {
      const d = /* @__PURE__ */ new Map(), p = {
        modifier: {
          reset: [0, 0],
          // 21 isn't widely supported and 22 does the same thing
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          // Bright color
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          // Bright color
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      p.color.gray = p.color.blackBright, p.bgColor.bgGray = p.bgColor.bgBlackBright, p.color.grey = p.color.blackBright, p.bgColor.bgGrey = p.bgColor.bgBlackBright;
      for (const [h, v] of Object.entries(p)) {
        for (const [y, g] of Object.entries(v))
          p[y] = {
            open: `\x1B[${g[0]}m`,
            close: `\x1B[${g[1]}m`
          }, v[y] = p[y], d.set(g[0], g[1]);
        Object.defineProperty(p, h, {
          value: v,
          enumerable: !1
        });
      }
      return Object.defineProperty(p, "codes", {
        value: d,
        enumerable: !1
      }), p.color.close = "\x1B[39m", p.bgColor.close = "\x1B[49m", a(p.color, "ansi", () => c(t, "ansi16", n, !1)), a(p.color, "ansi256", () => c(r, "ansi256", n, !1)), a(p.color, "ansi16m", () => c(i, "rgb", s, !1)), a(p.bgColor, "ansi", () => c(t, "ansi16", n, !0)), a(p.bgColor, "ansi256", () => c(r, "ansi256", n, !0)), a(p.bgColor, "ansi16m", () => c(i, "rgb", s, !0)), p;
    }
    Object.defineProperty(e, "exports", {
      enumerable: !0,
      get: l
    });
  }(Ml)), Ml.exports;
}
var Uh, ww;
function iF() {
  return ww || (ww = 1, Uh = {
    stdout: !1,
    stderr: !1
  }), Uh;
}
var Bh, $w;
function sF() {
  return $w || ($w = 1, Bh = {
    stringReplaceAll: (r, i, n) => {
      let s = r.indexOf(i);
      if (s === -1)
        return r;
      const a = i.length;
      let u = 0, c = "";
      do
        c += r.substr(u, s - u) + i + n, u = s + a, s = r.indexOf(i, u);
      while (s !== -1);
      return c += r.substr(u), c;
    },
    stringEncaseCRLFWithFirstIndex: (r, i, n, s) => {
      let a = 0, u = "";
      do {
        const c = r[s - 1] === "\r";
        u += r.substr(a, (c ? s - 1 : s) - a) + i + (c ? `\r
` : `
`) + n, a = s + 1, s = r.indexOf(`
`, a);
      } while (s !== -1);
      return u += r.substr(a), u;
    }
  }), Bh;
}
var Vh, Ew;
function aF() {
  if (Ew)
    return Vh;
  Ew = 1;
  const e = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi, t = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, r = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, i = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi, n = /* @__PURE__ */ new Map([
    ["n", `
`],
    ["r", "\r"],
    ["t", "	"],
    ["b", "\b"],
    ["f", "\f"],
    ["v", "\v"],
    ["0", "\0"],
    ["\\", "\\"],
    ["e", "\x1B"],
    ["a", "\x07"]
  ]);
  function s(l) {
    const d = l[0] === "u", p = l[1] === "{";
    return d && !p && l.length === 5 || l[0] === "x" && l.length === 3 ? String.fromCharCode(parseInt(l.slice(1), 16)) : d && p ? String.fromCodePoint(parseInt(l.slice(2, -1), 16)) : n.get(l) || l;
  }
  function a(l, d) {
    const p = [], h = d.trim().split(/\s*,\s*/g);
    let v;
    for (const y of h) {
      const g = Number(y);
      if (!Number.isNaN(g))
        p.push(g);
      else if (v = y.match(r))
        p.push(v[2].replace(i, (_, m, w) => m ? s(m) : w));
      else
        throw new Error(`Invalid Chalk template style argument: ${y} (in style '${l}')`);
    }
    return p;
  }
  function u(l) {
    t.lastIndex = 0;
    const d = [];
    let p;
    for (; (p = t.exec(l)) !== null; ) {
      const h = p[1];
      if (p[2]) {
        const v = a(h, p[2]);
        d.push([h].concat(v));
      } else
        d.push([h]);
    }
    return d;
  }
  function c(l, d) {
    const p = {};
    for (const v of d)
      for (const y of v.styles)
        p[y[0]] = v.inverse ? null : y.slice(1);
    let h = l;
    for (const [v, y] of Object.entries(p))
      if (Array.isArray(y)) {
        if (!(v in h))
          throw new Error(`Unknown Chalk style: ${v}`);
        h = y.length > 0 ? h[v](...y) : h[v];
      }
    return h;
  }
  return Vh = (l, d) => {
    const p = [], h = [];
    let v = [];
    if (d.replace(e, (y, g, _, m, w, $) => {
      if (g)
        v.push(s(g));
      else if (m) {
        const E = v.join("");
        v = [], h.push(p.length === 0 ? E : c(l, p)(E)), p.push({ inverse: _, styles: u(m) });
      } else if (w) {
        if (p.length === 0)
          throw new Error("Found extraneous } in Chalk template literal");
        h.push(c(l, p)(v.join(""))), v = [], p.pop();
      } else
        v.push($);
    }), h.push(v.join("")), p.length > 0) {
      const y = `Chalk template literal is missing ${p.length} closing bracket${p.length === 1 ? "" : "s"} (\`}\`)`;
      throw new Error(y);
    }
    return h.join("");
  }, Vh;
}
var Zh, xw;
function oF() {
  if (xw)
    return Zh;
  xw = 1;
  const e = nF(), { stdout: t, stderr: r } = iF(), {
    stringReplaceAll: i,
    stringEncaseCRLFWithFirstIndex: n
  } = sF(), { isArray: s } = Array, a = [
    "ansi",
    "ansi",
    "ansi256",
    "ansi16m"
  ], u = /* @__PURE__ */ Object.create(null), c = (E, A = {}) => {
    if (A.level && !(Number.isInteger(A.level) && A.level >= 0 && A.level <= 3))
      throw new Error("The `level` option should be an integer from 0 to 3");
    const R = t ? t.level : 0;
    E.level = A.level === void 0 ? R : A.level;
  };
  class l {
    constructor(A) {
      return d(A);
    }
  }
  const d = (E) => {
    const A = {};
    return c(A, E), A.template = (...R) => w(A.template, ...R), Object.setPrototypeOf(A, p.prototype), Object.setPrototypeOf(A.template, A), A.template.constructor = () => {
      throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
    }, A.template.Instance = l, A.template;
  };
  function p(E) {
    return d(E);
  }
  for (const [E, A] of Object.entries(e))
    u[E] = {
      get() {
        const R = g(this, y(A.open, A.close, this._styler), this._isEmpty);
        return Object.defineProperty(this, E, { value: R }), R;
      }
    };
  u.visible = {
    get() {
      const E = g(this, this._styler, !0);
      return Object.defineProperty(this, "visible", { value: E }), E;
    }
  };
  const h = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
  for (const E of h)
    u[E] = {
      get() {
        const { level: A } = this;
        return function(...R) {
          const I = y(e.color[a[A]][E](...R), e.color.close, this._styler);
          return g(this, I, this._isEmpty);
        };
      }
    };
  for (const E of h) {
    const A = "bg" + E[0].toUpperCase() + E.slice(1);
    u[A] = {
      get() {
        const { level: R } = this;
        return function(...I) {
          const D = y(e.bgColor[a[R]][E](...I), e.bgColor.close, this._styler);
          return g(this, D, this._isEmpty);
        };
      }
    };
  }
  const v = Object.defineProperties(() => {
  }, {
    ...u,
    level: {
      enumerable: !0,
      get() {
        return this._generator.level;
      },
      set(E) {
        this._generator.level = E;
      }
    }
  }), y = (E, A, R) => {
    let I, D;
    return R === void 0 ? (I = E, D = A) : (I = R.openAll + E, D = A + R.closeAll), {
      open: E,
      close: A,
      openAll: I,
      closeAll: D,
      parent: R
    };
  }, g = (E, A, R) => {
    const I = (...D) => s(D[0]) && s(D[0].raw) ? _(I, w(I, ...D)) : _(I, D.length === 1 ? "" + D[0] : D.join(" "));
    return Object.setPrototypeOf(I, v), I._generator = E, I._styler = A, I._isEmpty = R, I;
  }, _ = (E, A) => {
    if (E.level <= 0 || !A)
      return E._isEmpty ? "" : A;
    let R = E._styler;
    if (R === void 0)
      return A;
    const { openAll: I, closeAll: D } = R;
    if (A.indexOf("\x1B") !== -1)
      for (; R !== void 0; )
        A = i(A, R.close, R.open), R = R.parent;
    const J = A.indexOf(`
`);
    return J !== -1 && (A = n(A, D, I, J)), I + A + D;
  };
  let m;
  const w = (E, ...A) => {
    const [R] = A;
    if (!s(R) || !s(R.raw))
      return A.join(" ");
    const I = A.slice(1), D = [R.raw[0]];
    for (let J = 1; J < R.length; J++)
      D.push(
        String(I[J - 1]).replace(/[{}\\]/g, "\\$&"),
        String(R.raw[J])
      );
    return m === void 0 && (m = aF()), m(E, D.join(""));
  };
  Object.defineProperties(p.prototype, u);
  const $ = p();
  return $.supportsColor = t, $.stderr = p({ level: r ? r.level : 0 }), $.stderr.supportsColor = r, Zh = $, Zh;
}
var zh = {}, al = { exports: {} }, Yo = {}, Ow;
function rP() {
  if (Ow)
    return Yo;
  Ow = 1, Object.defineProperty(Yo, "__esModule", {
    value: !0
  }), Yo.getPointers = void 0;
  var e = function(r) {
    var i = r.split("/").slice(1);
    for (var n in i)
      i[n] = i[n].split("~1").join("/").split("~0").join("~");
    return i;
  };
  return Yo.getPointers = e, Yo;
}
var Pw;
function uF() {
  return Pw || (Pw = 1, function(e, t) {
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = i;
    var r = rP();
    function i(n, s, a) {
      var u = (0, r.getPointers)(s), c = u.length - 1;
      return u.reduce(function(l, d, p) {
        switch (l.type) {
          case "Object": {
            var h = l.members.filter(function(_) {
              return _.name.value === d;
            });
            if (h.length !== 1)
              throw new Error("Couldn't find property ".concat(d, " of ").concat(s));
            var v = h[0], y = v.name, g = v.value;
            return a && p === c ? y : g;
          }
          case "Array":
            return l.elements[d];
          default:
            console.log(l);
        }
      }, n.body);
    }
    e.exports = t.default;
  }(al, al.exports)), al.exports;
}
var ol = { exports: {} }, Sw;
function cF() {
  return Sw || (Sw = 1, function(e, t) {
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = n;
    var r = rP();
    function i(s) {
      if (!s || !s.elements)
        return "";
      var a = s.elements.filter(function(u) {
        return u && u.name && u.name.value === "type";
      });
      return a.length && a[0].value && ":".concat(a[0].value.value) || "";
    }
    function n(s, a) {
      var u = "";
      return (0, r.getPointers)(a).reduce(function(c, l) {
        switch (c.type) {
          case "Object": {
            u += "/".concat(l);
            var d = c.members.filter(function(p) {
              return p.name.value === l;
            });
            if (d.length !== 1)
              throw new Error("Couldn't find property ".concat(l, " of ").concat(a));
            return d[0].value;
          }
          case "Array":
            return u += "/".concat(l).concat(i(c.elements[l])), c.elements[l];
          default:
            console.log(c);
        }
      }, s.body), u;
    }
    e.exports = t.default;
  }(ol, ol.exports)), ol.exports;
}
var Aw;
function lF() {
  return Aw || (Aw = 1, function(e) {
    var t = Ln;
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), Object.defineProperty(e, "getDecoratedDataPath", {
      enumerable: !0,
      get: function() {
        return i.default;
      }
    }), Object.defineProperty(e, "getMetaFromPath", {
      enumerable: !0,
      get: function() {
        return r.default;
      }
    });
    var r = t(uF()), i = t(cF());
  }(zh)), zh;
}
var Cw;
function yo() {
  return Cw || (Cw = 1, function(e, t) {
    var r = Ln;
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = void 0;
    var i = r(ia()), n = r(sa()), s = Q8(), a = r(oF()), u = lF(), c = /* @__PURE__ */ function() {
      function l() {
        var d = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
          isIdentifierLocation: !1
        }, p = arguments.length > 1 ? arguments[1] : void 0, h = p.colorize, v = p.data, y = p.schema, g = p.jsonAst, _ = p.jsonRaw;
        (0, i.default)(this, l), this.options = d, this.colorize = !!(h || h === void 0), this.data = v, this.schema = y, this.jsonAst = g, this.jsonRaw = _;
      }
      return (0, n.default)(l, [{
        key: "getChalk",
        value: function() {
          return this.colorize ? a.default : new a.default.Instance({
            level: 0
          });
        }
      }, {
        key: "getLocation",
        value: function() {
          var p = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.instancePath, h = this.options, v = h.isIdentifierLocation, y = h.isSkipEndLocation, g = (0, u.getMetaFromPath)(this.jsonAst, p, v), _ = g.loc;
          return {
            start: _.start,
            end: y ? void 0 : _.end
          };
        }
      }, {
        key: "getDecoratedPath",
        value: function() {
          var p = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.instancePath;
          return (0, u.getDecoratedDataPath)(this.jsonAst, p);
        }
      }, {
        key: "getCodeFrame",
        value: function(p) {
          var h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.instancePath;
          return (0, s.codeFrameColumns)(this.jsonRaw, this.getLocation(h), {
            /**
             * `@babel/highlight`, by way of `@babel/code-frame`, highlights out entire block of raw JSON
             * instead of just our `location` block -- so if you have a block of raw JSON that's upwards
             * of 2mb+ and have a lot of errors to generate code frames for then we're re-highlighting
             * the same huge chunk of code over and over and over and over again, all just so
             * `@babel/code-frame` will eventually extract a small <10 line chunk out of it to return to
             * us.
             *
             * Disabling `highlightCode` here will only disable highlighting the code we're showing users;
             * if `options.colorize` is supplied to this library then the error message we're adding will
             * still be highlighted.
             */
            highlightCode: !1,
            message: p
          });
        }
        /**
         * @return {string}
         */
      }, {
        key: "instancePath",
        get: function() {
          return typeof this.options.instancePath < "u" ? this.options.instancePath : this.options.dataPath;
        }
      }, {
        key: "print",
        value: function() {
          throw new Error("Implement the 'print' method inside ".concat(this.constructor.name, "!"));
        }
      }, {
        key: "getError",
        value: function() {
          throw new Error("Implement the 'getError' method inside ".concat(this.constructor.name, "!"));
        }
      }]), l;
    }();
    t.default = c, e.exports = t.default;
  }(sl, sl.exports)), sl.exports;
}
var Rw;
function fF() {
  return Rw || (Rw = 1, function(e, t) {
    var r = Ln;
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = void 0;
    var i = r(na()), n = r(po()), s = r(ia()), a = r(sa()), u = r(ho()), c = r(mo()), l = r(aa()), d = r(yo()), p, h;
    function v(w, $) {
      var E = Object.keys(w);
      if (Object.getOwnPropertySymbols) {
        var A = Object.getOwnPropertySymbols(w);
        $ && (A = A.filter(function(R) {
          return Object.getOwnPropertyDescriptor(w, R).enumerable;
        })), E.push.apply(E, A);
      }
      return E;
    }
    function y(w) {
      for (var $ = 1; $ < arguments.length; $++) {
        var E = arguments[$] != null ? arguments[$] : {};
        $ % 2 ? v(Object(E), !0).forEach(function(A) {
          (0, i.default)(w, A, E[A]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(w, Object.getOwnPropertyDescriptors(E)) : v(Object(E)).forEach(function(A) {
          Object.defineProperty(w, A, Object.getOwnPropertyDescriptor(E, A));
        });
      }
      return w;
    }
    function g(w) {
      var $ = _();
      return function() {
        var A = (0, l.default)(w), R;
        if ($) {
          var I = (0, l.default)(this).constructor;
          R = Reflect.construct(A, arguments, I);
        } else
          R = A.apply(this, arguments);
        return (0, c.default)(this, R);
      };
    }
    function _() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    var m = /* @__PURE__ */ function(w) {
      (0, u.default)(E, w);
      var $ = g(E);
      function E() {
        var A;
        (0, s.default)(this, E);
        for (var R = arguments.length, I = new Array(R), D = 0; D < R; D++)
          I[D] = arguments[D];
        return A = $.call.apply($, [this].concat(I)), A.name = "AdditionalPropValidationError", A.options.isIdentifierLocation = !0, A;
      }
      return (0, a.default)(E, [{
        key: "print",
        value: function() {
          var R = this.options, I = R.message, D = R.params, J = this.getChalk(), ae = [J(p || (p = (0, n.default)(["{red {bold ADDITIONAL PROPERTY} ", `}
`], ["{red {bold ADDITIONAL PROPERTY} ", "}\\n"])), I)];
          return ae.concat(this.getCodeFrame(J(h || (h = (0, n.default)(["😲  {magentaBright ", "} is not expected to be here!"])), D.additionalProperty), "".concat(this.instancePath, "/").concat(D.additionalProperty)));
        }
      }, {
        key: "getError",
        value: function() {
          var R = this.options.params;
          return y(y({}, this.getLocation("".concat(this.instancePath, "/").concat(R.additionalProperty))), {}, {
            error: "".concat(this.getDecoratedPath(), " Property ").concat(R.additionalProperty, " is not expected to be here"),
            path: this.instancePath
          });
        }
      }]), E;
    }(d.default);
    t.default = m, e.exports = t.default;
  }(il, il.exports)), il.exports;
}
var ul = { exports: {} }, Tw;
function dF() {
  return Tw || (Tw = 1, function(e, t) {
    var r = Ln;
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = void 0;
    var i = r(na()), n = r(po()), s = r(ia()), a = r(sa()), u = r(ho()), c = r(mo()), l = r(aa()), d = r(yo()), p, h;
    function v(w, $) {
      var E = Object.keys(w);
      if (Object.getOwnPropertySymbols) {
        var A = Object.getOwnPropertySymbols(w);
        $ && (A = A.filter(function(R) {
          return Object.getOwnPropertyDescriptor(w, R).enumerable;
        })), E.push.apply(E, A);
      }
      return E;
    }
    function y(w) {
      for (var $ = 1; $ < arguments.length; $++) {
        var E = arguments[$] != null ? arguments[$] : {};
        $ % 2 ? v(Object(E), !0).forEach(function(A) {
          (0, i.default)(w, A, E[A]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(w, Object.getOwnPropertyDescriptors(E)) : v(Object(E)).forEach(function(A) {
          Object.defineProperty(w, A, Object.getOwnPropertyDescriptor(E, A));
        });
      }
      return w;
    }
    function g(w) {
      var $ = _();
      return function() {
        var A = (0, l.default)(w), R;
        if ($) {
          var I = (0, l.default)(this).constructor;
          R = Reflect.construct(A, arguments, I);
        } else
          R = A.apply(this, arguments);
        return (0, c.default)(this, R);
      };
    }
    function _() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    var m = /* @__PURE__ */ function(w) {
      (0, u.default)(E, w);
      var $ = g(E);
      function E() {
        var A;
        (0, s.default)(this, E);
        for (var R = arguments.length, I = new Array(R), D = 0; D < R; D++)
          I[D] = arguments[D];
        return A = $.call.apply($, [this].concat(I)), A.name = "DefaultValidationError", A.options.isSkipEndLocation = !0, A;
      }
      return (0, a.default)(E, [{
        key: "print",
        value: function() {
          var R = this.options, I = R.keyword, D = R.message, J = this.getChalk(), ae = [J(p || (p = (0, n.default)(["{red {bold ", "} ", `}
`], ["{red {bold ", "} ", "}\\n"])), I.toUpperCase(), D)];
          return ae.concat(this.getCodeFrame(J(h || (h = (0, n.default)(["👈🏽  {magentaBright ", "} ", ""])), I, D)));
        }
      }, {
        key: "getError",
        value: function() {
          var R = this.options, I = R.keyword, D = R.message;
          return y(y({}, this.getLocation()), {}, {
            error: "".concat(this.getDecoratedPath(), ": ").concat(I, " ").concat(D),
            path: this.instancePath
          });
        }
      }]), E;
    }(d.default);
    t.default = m, e.exports = t.default;
  }(ul, ul.exports)), ul.exports;
}
var cl = { exports: {} }, Jo = {}, Iw;
function pF() {
  if (Iw)
    return Jo;
  Iw = 1;
  var e = /~/, t = /~[01]/g;
  function r(l) {
    switch (l) {
      case "~1":
        return "/";
      case "~0":
        return "~";
    }
    throw new Error("Invalid tilde escape: " + l);
  }
  function i(l) {
    return e.test(l) ? l.replace(t, r) : l;
  }
  function n(l, d, p) {
    for (var h, v, y = 1, g = d.length; y < g; ) {
      if (d[y] === "constructor" || d[y] === "prototype" || d[y] === "__proto__")
        return l;
      if (h = i(d[y++]), v = g > y, typeof l[h] > "u" && (Array.isArray(l) && h === "-" && (h = l.length), v && (d[y] !== "" && d[y] < 1 / 0 || d[y] === "-" ? l[h] = [] : l[h] = {})), !v)
        break;
      l = l[h];
    }
    var _ = l[h];
    return p === void 0 ? delete l[h] : l[h] = p, _;
  }
  function s(l) {
    if (typeof l == "string") {
      if (l = l.split("/"), l[0] === "")
        return l;
      throw new Error("Invalid JSON pointer.");
    } else if (Array.isArray(l)) {
      for (const d of l)
        if (typeof d != "string" && typeof d != "number")
          throw new Error("Invalid JSON pointer. Must be of type string or number.");
      return l;
    }
    throw new Error("Invalid JSON pointer.");
  }
  function a(l, d) {
    if (typeof l != "object")
      throw new Error("Invalid input object.");
    d = s(d);
    var p = d.length;
    if (p === 1)
      return l;
    for (var h = 1; h < p; ) {
      if (l = l[i(d[h++])], p === h)
        return l;
      if (typeof l != "object" || l === null)
        return;
    }
  }
  function u(l, d, p) {
    if (typeof l != "object")
      throw new Error("Invalid input object.");
    if (d = s(d), d.length === 0)
      throw new Error("Invalid JSON pointer for set.");
    return n(l, d, p);
  }
  function c(l) {
    var d = s(l);
    return {
      get: function(p) {
        return a(p, d);
      },
      set: function(p, h) {
        return u(p, d, h);
      }
    };
  }
  return Jo.get = a, Jo.set = u, Jo.compile = c, Jo;
}
var ll = { exports: {} }, jw;
function hF() {
  if (jw)
    return ll.exports;
  jw = 1;
  const e = [], t = [], r = (i, n) => {
    if (i === n)
      return 0;
    const s = i;
    i.length > n.length && (i = n, n = s);
    let a = i.length, u = n.length;
    for (; a > 0 && i.charCodeAt(~-a) === n.charCodeAt(~-u); )
      a--, u--;
    let c = 0;
    for (; c < a && i.charCodeAt(c) === n.charCodeAt(c); )
      c++;
    if (a -= c, u -= c, a === 0)
      return u;
    let l, d, p, h, v = 0, y = 0;
    for (; v < a; )
      t[v] = i.charCodeAt(c + v), e[v] = ++v;
    for (; y < u; )
      for (l = n.charCodeAt(c + y), p = y++, d = y, v = 0; v < a; v++)
        h = l === t[v] ? p : p + 1, p = e[v], d = e[v] = p > d ? h > d ? d + 1 : h : h > p ? p + 1 : h;
    return d;
  };
  return ll.exports = r, ll.exports.default = r, ll.exports;
}
var kw;
function mF() {
  return kw || (kw = 1, function(e, t) {
    var r = Ln;
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = void 0;
    var i = r(na()), n = r(po()), s = r(ia()), a = r(sa()), u = r(ho()), c = r(mo()), l = r(aa()), d = r(pF()), p = r(hF()), h = r(yo()), v, y, g, _;
    function m(R, I) {
      var D = Object.keys(R);
      if (Object.getOwnPropertySymbols) {
        var J = Object.getOwnPropertySymbols(R);
        I && (J = J.filter(function(ae) {
          return Object.getOwnPropertyDescriptor(R, ae).enumerable;
        })), D.push.apply(D, J);
      }
      return D;
    }
    function w(R) {
      for (var I = 1; I < arguments.length; I++) {
        var D = arguments[I] != null ? arguments[I] : {};
        I % 2 ? m(Object(D), !0).forEach(function(J) {
          (0, i.default)(R, J, D[J]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(R, Object.getOwnPropertyDescriptors(D)) : m(Object(D)).forEach(function(J) {
          Object.defineProperty(R, J, Object.getOwnPropertyDescriptor(D, J));
        });
      }
      return R;
    }
    function $(R) {
      var I = E();
      return function() {
        var J = (0, l.default)(R), ae;
        if (I) {
          var ye = (0, l.default)(this).constructor;
          ae = Reflect.construct(J, arguments, ye);
        } else
          ae = J.apply(this, arguments);
        return (0, c.default)(this, ae);
      };
    }
    function E() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    var A = /* @__PURE__ */ function(R) {
      (0, u.default)(D, R);
      var I = $(D);
      function D() {
        var J;
        (0, s.default)(this, D);
        for (var ae = arguments.length, ye = new Array(ae), xe = 0; xe < ae; xe++)
          ye[xe] = arguments[xe];
        return J = I.call.apply(I, [this].concat(ye)), J.name = "EnumValidationError", J;
      }
      return (0, a.default)(D, [{
        key: "print",
        value: function() {
          var ae = this.options, ye = ae.message, xe = ae.params.allowedValues, je = this.getChalk(), re = this.findBestMatch(), fe = [je(v || (v = (0, n.default)(["{red {bold ENUM} ", "}"])), ye), je(y || (y = (0, n.default)(["{red (", `)}
`], ["{red (", ")}\\n"])), xe.join(", "))];
          return fe.concat(this.getCodeFrame(re !== null ? je(g || (g = (0, n.default)(["👈🏽  Did you mean {magentaBright ", "} here?"])), re) : je(_ || (_ = (0, n.default)(["👈🏽  Unexpected value, should be equal to one of the allowed values"])))));
        }
      }, {
        key: "getError",
        value: function() {
          var ae = this.options, ye = ae.message, xe = ae.params, je = this.findBestMatch(), re = xe.allowedValues.join(", "), fe = w(w({}, this.getLocation()), {}, {
            error: "".concat(this.getDecoratedPath(), " ").concat(ye, ": ").concat(re),
            path: this.instancePath
          });
          return je !== null && (fe.suggestion = "Did you mean ".concat(je, "?")), fe;
        }
      }, {
        key: "findBestMatch",
        value: function() {
          var ae = this.options.params.allowedValues, ye = this.instancePath === "" ? this.data : d.default.get(this.data, this.instancePath);
          if (!ye)
            return null;
          var xe = ae.map(function(je) {
            return {
              value: je,
              weight: (0, p.default)(je, ye.toString())
            };
          }).sort(function(je, re) {
            return je.weight > re.weight ? 1 : je.weight < re.weight ? -1 : 0;
          })[0];
          return ae.length === 1 || xe.weight < xe.value.length ? xe.value : null;
        }
      }]), D;
    }(h.default);
    t.default = A, e.exports = t.default;
  }(cl, cl.exports)), cl.exports;
}
var fl = { exports: {} }, Mw;
function yF() {
  return Mw || (Mw = 1, function(e, t) {
    var r = Ln;
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = void 0;
    var i = r(na()), n = r(po()), s = r(ia()), a = r(sa()), u = r(ho()), c = r(mo()), l = r(aa()), d = r(yo()), p, h;
    function v(w, $) {
      var E = Object.keys(w);
      if (Object.getOwnPropertySymbols) {
        var A = Object.getOwnPropertySymbols(w);
        $ && (A = A.filter(function(R) {
          return Object.getOwnPropertyDescriptor(w, R).enumerable;
        })), E.push.apply(E, A);
      }
      return E;
    }
    function y(w) {
      for (var $ = 1; $ < arguments.length; $++) {
        var E = arguments[$] != null ? arguments[$] : {};
        $ % 2 ? v(Object(E), !0).forEach(function(A) {
          (0, i.default)(w, A, E[A]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(w, Object.getOwnPropertyDescriptors(E)) : v(Object(E)).forEach(function(A) {
          Object.defineProperty(w, A, Object.getOwnPropertyDescriptor(E, A));
        });
      }
      return w;
    }
    function g(w) {
      var $ = _();
      return function() {
        var A = (0, l.default)(w), R;
        if ($) {
          var I = (0, l.default)(this).constructor;
          R = Reflect.construct(A, arguments, I);
        } else
          R = A.apply(this, arguments);
        return (0, c.default)(this, R);
      };
    }
    function _() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    var m = /* @__PURE__ */ function(w) {
      (0, u.default)(E, w);
      var $ = g(E);
      function E() {
        var A;
        (0, s.default)(this, E);
        for (var R = arguments.length, I = new Array(R), D = 0; D < R; D++)
          I[D] = arguments[D];
        return A = $.call.apply($, [this].concat(I)), A.name = "PatternValidationError", A.options.isIdentifierLocation = !0, A;
      }
      return (0, a.default)(E, [{
        key: "print",
        value: function() {
          var R = this.options, I = R.message, D = R.params, J = R.propertyName, ae = this.getChalk(), ye = [ae(p || (p = (0, n.default)(["{red {bold PROPERTY} ", `}
`], ["{red {bold PROPERTY} ", "}\\n"])), I)];
          return ye.concat(this.getCodeFrame(ae(h || (h = (0, n.default)(["😲  must match pattern {magentaBright ", "}"])), D.pattern), "".concat(this.instancePath, "/").concat(J)));
        }
      }, {
        key: "getError",
        value: function() {
          var R = this.options, I = R.params, D = R.propertyName;
          return y(y({}, this.getLocation()), {}, {
            error: "".concat(this.getDecoratedPath(), ' Property "').concat(D, '" must match pattern ').concat(I.pattern),
            path: this.instancePath
          });
        }
      }]), E;
    }(d.default);
    t.default = m, e.exports = t.default;
  }(fl, fl.exports)), fl.exports;
}
var dl = { exports: {} }, Wh = { exports: {} }, Hh = { exports: {} }, Nw;
function gF() {
  return Nw || (Nw = 1, function(e) {
    var t = aa();
    function r(i, n) {
      for (; !Object.prototype.hasOwnProperty.call(i, n) && (i = t(i), i !== null); )
        ;
      return i;
    }
    e.exports = r, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(Hh)), Hh.exports;
}
var Dw;
function vF() {
  return Dw || (Dw = 1, function(e) {
    var t = gF();
    function r() {
      return typeof Reflect < "u" && Reflect.get ? (e.exports = r = Reflect.get.bind(), e.exports.__esModule = !0, e.exports.default = e.exports) : (e.exports = r = function(n, s, a) {
        var u = t(n, s);
        if (u) {
          var c = Object.getOwnPropertyDescriptor(u, s);
          return c.get ? c.get.call(arguments.length < 3 ? n : a) : c.value;
        }
      }, e.exports.__esModule = !0, e.exports.default = e.exports), r.apply(this, arguments);
    }
    e.exports = r, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(Wh)), Wh.exports;
}
var Lw;
function bF() {
  return Lw || (Lw = 1, function(e, t) {
    var r = Ln;
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = void 0;
    var i = r(na()), n = r(po()), s = r(ia()), a = r(sa()), u = r(vF()), c = r(ho()), l = r(mo()), d = r(aa()), p = r(yo()), h, v;
    function y($, E) {
      var A = Object.keys($);
      if (Object.getOwnPropertySymbols) {
        var R = Object.getOwnPropertySymbols($);
        E && (R = R.filter(function(I) {
          return Object.getOwnPropertyDescriptor($, I).enumerable;
        })), A.push.apply(A, R);
      }
      return A;
    }
    function g($) {
      for (var E = 1; E < arguments.length; E++) {
        var A = arguments[E] != null ? arguments[E] : {};
        E % 2 ? y(Object(A), !0).forEach(function(R) {
          (0, i.default)($, R, A[R]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties($, Object.getOwnPropertyDescriptors(A)) : y(Object(A)).forEach(function(R) {
          Object.defineProperty($, R, Object.getOwnPropertyDescriptor(A, R));
        });
      }
      return $;
    }
    function _($) {
      var E = m();
      return function() {
        var R = (0, d.default)($), I;
        if (E) {
          var D = (0, d.default)(this).constructor;
          I = Reflect.construct(R, arguments, D);
        } else
          I = R.apply(this, arguments);
        return (0, l.default)(this, I);
      };
    }
    function m() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    var w = /* @__PURE__ */ function($) {
      (0, c.default)(A, $);
      var E = _(A);
      function A() {
        var R;
        (0, s.default)(this, A);
        for (var I = arguments.length, D = new Array(I), J = 0; J < I; J++)
          D[J] = arguments[J];
        return R = E.call.apply(E, [this].concat(D)), R.name = "RequiredValidationError", R;
      }
      return (0, a.default)(A, [{
        key: "getLocation",
        value: function() {
          var I = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.instancePath, D = (0, u.default)((0, d.default)(A.prototype), "getLocation", this).call(this, I), J = D.start;
          return {
            start: J
          };
        }
      }, {
        key: "print",
        value: function() {
          var I = this.options, D = I.message, J = I.params, ae = this.getChalk(), ye = [ae(h || (h = (0, n.default)(["{red {bold REQUIRED} ", `}
`], ["{red {bold REQUIRED} ", "}\\n"])), D)];
          return ye.concat(this.getCodeFrame(ae(v || (v = (0, n.default)(["☹️  {magentaBright ", "} is missing here!"])), J.missingProperty)));
        }
      }, {
        key: "getError",
        value: function() {
          var I = this.options.message;
          return g(g({}, this.getLocation()), {}, {
            error: "".concat(this.getDecoratedPath(), " ").concat(I),
            path: this.instancePath
          });
        }
      }]), A;
    }(p.default);
    t.default = w, e.exports = t.default;
  }(dl, dl.exports)), dl.exports;
}
var pl = { exports: {} }, qw;
function _F() {
  return qw || (qw = 1, function(e, t) {
    var r = Ln;
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = void 0;
    var i = r(na()), n = r(po()), s = r(ia()), a = r(sa()), u = r(ho()), c = r(mo()), l = r(aa()), d = r(yo()), p, h;
    function v(w, $) {
      var E = Object.keys(w);
      if (Object.getOwnPropertySymbols) {
        var A = Object.getOwnPropertySymbols(w);
        $ && (A = A.filter(function(R) {
          return Object.getOwnPropertyDescriptor(w, R).enumerable;
        })), E.push.apply(E, A);
      }
      return E;
    }
    function y(w) {
      for (var $ = 1; $ < arguments.length; $++) {
        var E = arguments[$] != null ? arguments[$] : {};
        $ % 2 ? v(Object(E), !0).forEach(function(A) {
          (0, i.default)(w, A, E[A]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(w, Object.getOwnPropertyDescriptors(E)) : v(Object(E)).forEach(function(A) {
          Object.defineProperty(w, A, Object.getOwnPropertyDescriptor(E, A));
        });
      }
      return w;
    }
    function g(w) {
      var $ = _();
      return function() {
        var A = (0, l.default)(w), R;
        if ($) {
          var I = (0, l.default)(this).constructor;
          R = Reflect.construct(A, arguments, I);
        } else
          R = A.apply(this, arguments);
        return (0, c.default)(this, R);
      };
    }
    function _() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    var m = /* @__PURE__ */ function(w) {
      (0, u.default)(E, w);
      var $ = g(E);
      function E() {
        var A;
        (0, s.default)(this, E);
        for (var R = arguments.length, I = new Array(R), D = 0; D < R; D++)
          I[D] = arguments[D];
        return A = $.call.apply($, [this].concat(I)), A.name = "UnevaluatedPropValidationError", A.options.isIdentifierLocation = !0, A;
      }
      return (0, a.default)(E, [{
        key: "print",
        value: function() {
          var R = this.options, I = R.message, D = R.params, J = this.getChalk(), ae = [J(p || (p = (0, n.default)(["{red {bold UNEVALUATED PROPERTY} ", `}
`], ["{red {bold UNEVALUATED PROPERTY} ", "}\\n"])), I)];
          return ae.concat(this.getCodeFrame(J(h || (h = (0, n.default)(["😲  {magentaBright ", "} is not expected to be here!"])), D.unevaluatedProperty), "".concat(this.instancePath, "/").concat(D.unevaluatedProperty)));
        }
      }, {
        key: "getError",
        value: function() {
          var R = this.options.params;
          return y(y({}, this.getLocation("".concat(this.instancePath, "/").concat(R.unevaluatedProperty))), {}, {
            error: "".concat(this.getDecoratedPath(), " Property ").concat(R.unevaluatedProperty, " is not expected to be here"),
            path: this.instancePath
          });
        }
      }]), E;
    }(d.default);
    t.default = m, e.exports = t.default;
  }(pl, pl.exports)), pl.exports;
}
var Fw;
function wF() {
  return Fw || (Fw = 1, function(e) {
    var t = Ln;
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), Object.defineProperty(e, "AdditionalPropValidationError", {
      enumerable: !0,
      get: function() {
        return r.default;
      }
    }), Object.defineProperty(e, "DefaultValidationError", {
      enumerable: !0,
      get: function() {
        return i.default;
      }
    }), Object.defineProperty(e, "EnumValidationError", {
      enumerable: !0,
      get: function() {
        return n.default;
      }
    }), Object.defineProperty(e, "PatternValidationError", {
      enumerable: !0,
      get: function() {
        return s.default;
      }
    }), Object.defineProperty(e, "RequiredValidationError", {
      enumerable: !0,
      get: function() {
        return a.default;
      }
    }), Object.defineProperty(e, "UnevaluatedPropValidationError", {
      enumerable: !0,
      get: function() {
        return u.default;
      }
    });
    var r = t(fF()), i = t(dF()), n = t(mF()), s = t(yF()), a = t(bF()), u = t(_F());
  }(bh)), bh;
}
var Uw;
function $F() {
  return Uw || (Uw = 1, function(e) {
    var t = Ln;
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.createErrorInstances = h, e.default = v, e.filterRedundantErrors = p, e.makeTree = d;
    var r = t(na()), i = t(j8()), n = t(D8()), s = L8(), a = wF();
    function u(y, g) {
      var _ = Object.keys(y);
      if (Object.getOwnPropertySymbols) {
        var m = Object.getOwnPropertySymbols(y);
        g && (m = m.filter(function(w) {
          return Object.getOwnPropertyDescriptor(y, w).enumerable;
        })), _.push.apply(_, m);
      }
      return _;
    }
    function c(y) {
      for (var g = 1; g < arguments.length; g++) {
        var _ = arguments[g] != null ? arguments[g] : {};
        g % 2 ? u(Object(_), !0).forEach(function(m) {
          (0, r.default)(y, m, _[m]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(y, Object.getOwnPropertyDescriptors(_)) : u(Object(_)).forEach(function(m) {
          Object.defineProperty(y, m, Object.getOwnPropertyDescriptor(_, m));
        });
      }
      return y;
    }
    var l = /\/[\w_-]+(\/\d+)?/g;
    function d() {
      var y = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], g = {
        children: {}
      };
      return y.forEach(function(_) {
        var m = typeof _.instancePath < "u" ? _.instancePath : _.dataPath, w = m === "" ? [""] : m.match(l);
        w && w.reduce(function($, E, A) {
          return $.children[E] = $.children[E] || {
            children: {},
            errors: []
          }, A === w.length - 1 && $.children[E].errors.push(_), $.children[E];
        }, g);
      }), g;
    }
    function p(y, g, _) {
      (0, s.getErrors)(y).forEach(function(m) {
        (0, s.isRequiredError)(m) && (y.errors = [m], y.children = {});
      }), (0, s.getErrors)(y).some(s.isAnyOfError) && Object.keys(y.children).length > 0 && delete y.errors, y.errors && y.errors.length && (0, s.getErrors)(y).every(s.isEnumError) && (0, s.getSiblings)(g)(y).filter(s.notUndefined).some(s.getErrors) && delete g.children[_], Object.entries(y.children).forEach(function(m) {
        var w = (0, n.default)(m, 2), $ = w[0], E = w[1];
        return p(E, y, $);
      });
    }
    function h(y, g) {
      var _ = (0, s.getErrors)(y);
      if (_.length && _.every(s.isEnumError)) {
        var m = new Set((0, s.concatAll)([])(_.map(function(E) {
          return E.params.allowedValues;
        }))), w = (0, i.default)(m), $ = _[0];
        return [new a.EnumValidationError(c(c({}, $), {}, {
          params: {
            allowedValues: w
          }
        }), g)];
      }
      return (0, s.concatAll)(_.reduce(function(E, A) {
        switch (A.keyword) {
          case "additionalProperties":
            return E.concat(new a.AdditionalPropValidationError(A, g));
          case "pattern":
            return E.concat(new a.PatternValidationError(A, g));
          case "required":
            return E.concat(new a.RequiredValidationError(A, g));
          case "unevaluatedProperties":
            return E.concat(new a.UnevaluatedPropValidationError(A, g));
          default:
            return E.concat(new a.DefaultValidationError(A, g));
        }
      }, []))((0, s.getChildren)(y).map(function(E) {
        return h(E, g);
      }));
    }
    function v(y, g) {
      var _ = d(y || []);
      return p(_), h(_, g);
    }
  }(ih)), ih;
}
(function(e, t) {
  var r = Ln;
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.default = s;
  var i = ki, n = r($F());
  function s(a, u, c) {
    var l = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, d = l.colorize, p = d === void 0 ? !0 : d, h = l.format, v = h === void 0 ? "cli" : h, y = l.indent, g = y === void 0 ? null : y, _ = l.json, m = _ === void 0 ? null : _, w = m || JSON.stringify(u, null, g), $ = (0, i.parse)(w), E = function(D) {
      return D.print().join(`
`);
    }, A = function(D) {
      return D.getError();
    }, R = (0, n.default)(c, {
      colorize: p,
      data: u,
      schema: a,
      jsonAst: $,
      jsonRaw: w
    });
    return v === "cli" ? R.map(E).join(`

`) : R.map(A);
  }
  e.exports = t.default;
})(ky, ky.exports);
var EF = ky.exports, Ny = { exports: {} }, Xa = {}, jn = {}, oo = {}, ic = {}, ht = {}, Bu = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.regexpCode = e.getEsmExportName = e.getProperty = e.safeStringify = e.stringify = e.strConcat = e.addCodeArg = e.str = e._ = e.nil = e._Code = e.Name = e.IDENTIFIER = e._CodeOrName = void 0;
  class t {
  }
  e._CodeOrName = t, e.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
  class r extends t {
    constructor(w) {
      if (super(), !e.IDENTIFIER.test(w))
        throw new Error("CodeGen: name must be a valid identifier");
      this.str = w;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      return !1;
    }
    get names() {
      return { [this.str]: 1 };
    }
  }
  e.Name = r;
  class i extends t {
    constructor(w) {
      super(), this._items = typeof w == "string" ? [w] : w;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      if (this._items.length > 1)
        return !1;
      const w = this._items[0];
      return w === "" || w === '""';
    }
    get str() {
      var w;
      return (w = this._str) !== null && w !== void 0 ? w : this._str = this._items.reduce(($, E) => `${$}${E}`, "");
    }
    get names() {
      var w;
      return (w = this._names) !== null && w !== void 0 ? w : this._names = this._items.reduce(($, E) => (E instanceof r && ($[E.str] = ($[E.str] || 0) + 1), $), {});
    }
  }
  e._Code = i, e.nil = new i("");
  function n(m, ...w) {
    const $ = [m[0]];
    let E = 0;
    for (; E < w.length; )
      u($, w[E]), $.push(m[++E]);
    return new i($);
  }
  e._ = n;
  const s = new i("+");
  function a(m, ...w) {
    const $ = [v(m[0])];
    let E = 0;
    for (; E < w.length; )
      $.push(s), u($, w[E]), $.push(s, v(m[++E]));
    return c($), new i($);
  }
  e.str = a;
  function u(m, w) {
    w instanceof i ? m.push(...w._items) : w instanceof r ? m.push(w) : m.push(p(w));
  }
  e.addCodeArg = u;
  function c(m) {
    let w = 1;
    for (; w < m.length - 1; ) {
      if (m[w] === s) {
        const $ = l(m[w - 1], m[w + 1]);
        if ($ !== void 0) {
          m.splice(w - 1, 3, $);
          continue;
        }
        m[w++] = "+";
      }
      w++;
    }
  }
  function l(m, w) {
    if (w === '""')
      return m;
    if (m === '""')
      return w;
    if (typeof m == "string")
      return w instanceof r || m[m.length - 1] !== '"' ? void 0 : typeof w != "string" ? `${m.slice(0, -1)}${w}"` : w[0] === '"' ? m.slice(0, -1) + w.slice(1) : void 0;
    if (typeof w == "string" && w[0] === '"' && !(m instanceof r))
      return `"${m}${w.slice(1)}`;
  }
  function d(m, w) {
    return w.emptyStr() ? m : m.emptyStr() ? w : a`${m}${w}`;
  }
  e.strConcat = d;
  function p(m) {
    return typeof m == "number" || typeof m == "boolean" || m === null ? m : v(Array.isArray(m) ? m.join(",") : m);
  }
  function h(m) {
    return new i(v(m));
  }
  e.stringify = h;
  function v(m) {
    return JSON.stringify(m).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
  }
  e.safeStringify = v;
  function y(m) {
    return typeof m == "string" && e.IDENTIFIER.test(m) ? new i(`.${m}`) : n`[${m}]`;
  }
  e.getProperty = y;
  function g(m) {
    if (typeof m == "string" && e.IDENTIFIER.test(m))
      return new i(`${m}`);
    throw new Error(`CodeGen: invalid export name: ${m}, use explicit $id name mapping`);
  }
  e.getEsmExportName = g;
  function _(m) {
    return new i(m.toString());
  }
  e.regexpCode = _;
})(Bu);
var Dy = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.ValueScope = e.ValueScopeName = e.Scope = e.varKinds = e.UsedValueState = void 0;
  const t = Bu;
  class r extends Error {
    constructor(l) {
      super(`CodeGen: "code" for ${l} not defined`), this.value = l.value;
    }
  }
  var i;
  (function(c) {
    c[c.Started = 0] = "Started", c[c.Completed = 1] = "Completed";
  })(i = e.UsedValueState || (e.UsedValueState = {})), e.varKinds = {
    const: new t.Name("const"),
    let: new t.Name("let"),
    var: new t.Name("var")
  };
  class n {
    constructor({ prefixes: l, parent: d } = {}) {
      this._names = {}, this._prefixes = l, this._parent = d;
    }
    toName(l) {
      return l instanceof t.Name ? l : this.name(l);
    }
    name(l) {
      return new t.Name(this._newName(l));
    }
    _newName(l) {
      const d = this._names[l] || this._nameGroup(l);
      return `${l}${d.index++}`;
    }
    _nameGroup(l) {
      var d, p;
      if (!((p = (d = this._parent) === null || d === void 0 ? void 0 : d._prefixes) === null || p === void 0) && p.has(l) || this._prefixes && !this._prefixes.has(l))
        throw new Error(`CodeGen: prefix "${l}" is not allowed in this scope`);
      return this._names[l] = { prefix: l, index: 0 };
    }
  }
  e.Scope = n;
  class s extends t.Name {
    constructor(l, d) {
      super(d), this.prefix = l;
    }
    setValue(l, { property: d, itemIndex: p }) {
      this.value = l, this.scopePath = (0, t._)`.${new t.Name(d)}[${p}]`;
    }
  }
  e.ValueScopeName = s;
  const a = (0, t._)`\n`;
  class u extends n {
    constructor(l) {
      super(l), this._values = {}, this._scope = l.scope, this.opts = { ...l, _n: l.lines ? a : t.nil };
    }
    get() {
      return this._scope;
    }
    name(l) {
      return new s(l, this._newName(l));
    }
    value(l, d) {
      var p;
      if (d.ref === void 0)
        throw new Error("CodeGen: ref must be passed in value");
      const h = this.toName(l), { prefix: v } = h, y = (p = d.key) !== null && p !== void 0 ? p : d.ref;
      let g = this._values[v];
      if (g) {
        const w = g.get(y);
        if (w)
          return w;
      } else
        g = this._values[v] = /* @__PURE__ */ new Map();
      g.set(y, h);
      const _ = this._scope[v] || (this._scope[v] = []), m = _.length;
      return _[m] = d.ref, h.setValue(d, { property: v, itemIndex: m }), h;
    }
    getValue(l, d) {
      const p = this._values[l];
      if (p)
        return p.get(d);
    }
    scopeRefs(l, d = this._values) {
      return this._reduceValues(d, (p) => {
        if (p.scopePath === void 0)
          throw new Error(`CodeGen: name "${p}" has no value`);
        return (0, t._)`${l}${p.scopePath}`;
      });
    }
    scopeCode(l = this._values, d, p) {
      return this._reduceValues(l, (h) => {
        if (h.value === void 0)
          throw new Error(`CodeGen: name "${h}" has no value`);
        return h.value.code;
      }, d, p);
    }
    _reduceValues(l, d, p = {}, h) {
      let v = t.nil;
      for (const y in l) {
        const g = l[y];
        if (!g)
          continue;
        const _ = p[y] = p[y] || /* @__PURE__ */ new Map();
        g.forEach((m) => {
          if (_.has(m))
            return;
          _.set(m, i.Started);
          let w = d(m);
          if (w) {
            const $ = this.opts.es5 ? e.varKinds.var : e.varKinds.const;
            v = (0, t._)`${v}${$} ${m} = ${w};${this.opts._n}`;
          } else if (w = h == null ? void 0 : h(m))
            v = (0, t._)`${v}${w}${this.opts._n}`;
          else
            throw new r(m);
          _.set(m, i.Completed);
        });
      }
      return v;
    }
  }
  e.ValueScope = u;
})(Dy);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.or = e.and = e.not = e.CodeGen = e.operators = e.varKinds = e.ValueScopeName = e.ValueScope = e.Scope = e.Name = e.regexpCode = e.stringify = e.getProperty = e.nil = e.strConcat = e.str = e._ = void 0;
  const t = Bu, r = Dy;
  var i = Bu;
  Object.defineProperty(e, "_", { enumerable: !0, get: function() {
    return i._;
  } }), Object.defineProperty(e, "str", { enumerable: !0, get: function() {
    return i.str;
  } }), Object.defineProperty(e, "strConcat", { enumerable: !0, get: function() {
    return i.strConcat;
  } }), Object.defineProperty(e, "nil", { enumerable: !0, get: function() {
    return i.nil;
  } }), Object.defineProperty(e, "getProperty", { enumerable: !0, get: function() {
    return i.getProperty;
  } }), Object.defineProperty(e, "stringify", { enumerable: !0, get: function() {
    return i.stringify;
  } }), Object.defineProperty(e, "regexpCode", { enumerable: !0, get: function() {
    return i.regexpCode;
  } }), Object.defineProperty(e, "Name", { enumerable: !0, get: function() {
    return i.Name;
  } });
  var n = Dy;
  Object.defineProperty(e, "Scope", { enumerable: !0, get: function() {
    return n.Scope;
  } }), Object.defineProperty(e, "ValueScope", { enumerable: !0, get: function() {
    return n.ValueScope;
  } }), Object.defineProperty(e, "ValueScopeName", { enumerable: !0, get: function() {
    return n.ValueScopeName;
  } }), Object.defineProperty(e, "varKinds", { enumerable: !0, get: function() {
    return n.varKinds;
  } }), e.operators = {
    GT: new t._Code(">"),
    GTE: new t._Code(">="),
    LT: new t._Code("<"),
    LTE: new t._Code("<="),
    EQ: new t._Code("==="),
    NEQ: new t._Code("!=="),
    NOT: new t._Code("!"),
    OR: new t._Code("||"),
    AND: new t._Code("&&"),
    ADD: new t._Code("+")
  };
  class s {
    optimizeNodes() {
      return this;
    }
    optimizeNames(C, q) {
      return this;
    }
  }
  class a extends s {
    constructor(C, q, N) {
      super(), this.varKind = C, this.name = q, this.rhs = N;
    }
    render({ es5: C, _n: q }) {
      const N = C ? r.varKinds.var : this.varKind, F = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
      return `${N} ${this.name}${F};` + q;
    }
    optimizeNames(C, q) {
      if (C[this.name.str])
        return this.rhs && (this.rhs = re(this.rhs, C, q)), this;
    }
    get names() {
      return this.rhs instanceof t._CodeOrName ? this.rhs.names : {};
    }
  }
  class u extends s {
    constructor(C, q, N) {
      super(), this.lhs = C, this.rhs = q, this.sideEffects = N;
    }
    render({ _n: C }) {
      return `${this.lhs} = ${this.rhs};` + C;
    }
    optimizeNames(C, q) {
      if (!(this.lhs instanceof t.Name && !C[this.lhs.str] && !this.sideEffects))
        return this.rhs = re(this.rhs, C, q), this;
    }
    get names() {
      const C = this.lhs instanceof t.Name ? {} : { ...this.lhs.names };
      return je(C, this.rhs);
    }
  }
  class c extends u {
    constructor(C, q, N, F) {
      super(C, N, F), this.op = q;
    }
    render({ _n: C }) {
      return `${this.lhs} ${this.op}= ${this.rhs};` + C;
    }
  }
  class l extends s {
    constructor(C) {
      super(), this.label = C, this.names = {};
    }
    render({ _n: C }) {
      return `${this.label}:` + C;
    }
  }
  class d extends s {
    constructor(C) {
      super(), this.label = C, this.names = {};
    }
    render({ _n: C }) {
      return `break${this.label ? ` ${this.label}` : ""};` + C;
    }
  }
  class p extends s {
    constructor(C) {
      super(), this.error = C;
    }
    render({ _n: C }) {
      return `throw ${this.error};` + C;
    }
    get names() {
      return this.error.names;
    }
  }
  class h extends s {
    constructor(C) {
      super(), this.code = C;
    }
    render({ _n: C }) {
      return `${this.code};` + C;
    }
    optimizeNodes() {
      return `${this.code}` ? this : void 0;
    }
    optimizeNames(C, q) {
      return this.code = re(this.code, C, q), this;
    }
    get names() {
      return this.code instanceof t._CodeOrName ? this.code.names : {};
    }
  }
  class v extends s {
    constructor(C = []) {
      super(), this.nodes = C;
    }
    render(C) {
      return this.nodes.reduce((q, N) => q + N.render(C), "");
    }
    optimizeNodes() {
      const { nodes: C } = this;
      let q = C.length;
      for (; q--; ) {
        const N = C[q].optimizeNodes();
        Array.isArray(N) ? C.splice(q, 1, ...N) : N ? C[q] = N : C.splice(q, 1);
      }
      return C.length > 0 ? this : void 0;
    }
    optimizeNames(C, q) {
      const { nodes: N } = this;
      let F = N.length;
      for (; F--; ) {
        const T = N[F];
        T.optimizeNames(C, q) || (fe(C, T.names), N.splice(F, 1));
      }
      return N.length > 0 ? this : void 0;
    }
    get names() {
      return this.nodes.reduce((C, q) => xe(C, q.names), {});
    }
  }
  class y extends v {
    render(C) {
      return "{" + C._n + super.render(C) + "}" + C._n;
    }
  }
  class g extends v {
  }
  class _ extends y {
  }
  _.kind = "else";
  class m extends y {
    constructor(C, q) {
      super(q), this.condition = C;
    }
    render(C) {
      let q = `if(${this.condition})` + super.render(C);
      return this.else && (q += "else " + this.else.render(C)), q;
    }
    optimizeNodes() {
      super.optimizeNodes();
      const C = this.condition;
      if (C === !0)
        return this.nodes;
      let q = this.else;
      if (q) {
        const N = q.optimizeNodes();
        q = this.else = Array.isArray(N) ? new _(N) : N;
      }
      if (q)
        return C === !1 ? q instanceof m ? q : q.nodes : this.nodes.length ? this : new m(le(C), q instanceof m ? [q] : q.nodes);
      if (!(C === !1 || !this.nodes.length))
        return this;
    }
    optimizeNames(C, q) {
      var N;
      if (this.else = (N = this.else) === null || N === void 0 ? void 0 : N.optimizeNames(C, q), !!(super.optimizeNames(C, q) || this.else))
        return this.condition = re(this.condition, C, q), this;
    }
    get names() {
      const C = super.names;
      return je(C, this.condition), this.else && xe(C, this.else.names), C;
    }
  }
  m.kind = "if";
  class w extends y {
  }
  w.kind = "for";
  class $ extends w {
    constructor(C) {
      super(), this.iteration = C;
    }
    render(C) {
      return `for(${this.iteration})` + super.render(C);
    }
    optimizeNames(C, q) {
      if (super.optimizeNames(C, q))
        return this.iteration = re(this.iteration, C, q), this;
    }
    get names() {
      return xe(super.names, this.iteration.names);
    }
  }
  class E extends w {
    constructor(C, q, N, F) {
      super(), this.varKind = C, this.name = q, this.from = N, this.to = F;
    }
    render(C) {
      const q = C.es5 ? r.varKinds.var : this.varKind, { name: N, from: F, to: T } = this;
      return `for(${q} ${N}=${F}; ${N}<${T}; ${N}++)` + super.render(C);
    }
    get names() {
      const C = je(super.names, this.from);
      return je(C, this.to);
    }
  }
  class A extends w {
    constructor(C, q, N, F) {
      super(), this.loop = C, this.varKind = q, this.name = N, this.iterable = F;
    }
    render(C) {
      return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(C);
    }
    optimizeNames(C, q) {
      if (super.optimizeNames(C, q))
        return this.iterable = re(this.iterable, C, q), this;
    }
    get names() {
      return xe(super.names, this.iterable.names);
    }
  }
  class R extends y {
    constructor(C, q, N) {
      super(), this.name = C, this.args = q, this.async = N;
    }
    render(C) {
      return `${this.async ? "async " : ""}function ${this.name}(${this.args})` + super.render(C);
    }
  }
  R.kind = "func";
  class I extends v {
    render(C) {
      return "return " + super.render(C);
    }
  }
  I.kind = "return";
  class D extends y {
    render(C) {
      let q = "try" + super.render(C);
      return this.catch && (q += this.catch.render(C)), this.finally && (q += this.finally.render(C)), q;
    }
    optimizeNodes() {
      var C, q;
      return super.optimizeNodes(), (C = this.catch) === null || C === void 0 || C.optimizeNodes(), (q = this.finally) === null || q === void 0 || q.optimizeNodes(), this;
    }
    optimizeNames(C, q) {
      var N, F;
      return super.optimizeNames(C, q), (N = this.catch) === null || N === void 0 || N.optimizeNames(C, q), (F = this.finally) === null || F === void 0 || F.optimizeNames(C, q), this;
    }
    get names() {
      const C = super.names;
      return this.catch && xe(C, this.catch.names), this.finally && xe(C, this.finally.names), C;
    }
  }
  class J extends y {
    constructor(C) {
      super(), this.error = C;
    }
    render(C) {
      return `catch(${this.error})` + super.render(C);
    }
  }
  J.kind = "catch";
  class ae extends y {
    render(C) {
      return "finally" + super.render(C);
    }
  }
  ae.kind = "finally";
  class ye {
    constructor(C, q = {}) {
      this._values = {}, this._blockStarts = [], this._constants = {}, this.opts = { ...q, _n: q.lines ? `
` : "" }, this._extScope = C, this._scope = new r.Scope({ parent: C }), this._nodes = [new g()];
    }
    toString() {
      return this._root.render(this.opts);
    }
    // returns unique name in the internal scope
    name(C) {
      return this._scope.name(C);
    }
    // reserves unique name in the external scope
    scopeName(C) {
      return this._extScope.name(C);
    }
    // reserves unique name in the external scope and assigns value to it
    scopeValue(C, q) {
      const N = this._extScope.value(C, q);
      return (this._values[N.prefix] || (this._values[N.prefix] = /* @__PURE__ */ new Set())).add(N), N;
    }
    getScopeValue(C, q) {
      return this._extScope.getValue(C, q);
    }
    // return code that assigns values in the external scope to the names that are used internally
    // (same names that were returned by gen.scopeName or gen.scopeValue)
    scopeRefs(C) {
      return this._extScope.scopeRefs(C, this._values);
    }
    scopeCode() {
      return this._extScope.scopeCode(this._values);
    }
    _def(C, q, N, F) {
      const T = this._scope.toName(q);
      return N !== void 0 && F && (this._constants[T.str] = N), this._leafNode(new a(C, T, N)), T;
    }
    // `const` declaration (`var` in es5 mode)
    const(C, q, N) {
      return this._def(r.varKinds.const, C, q, N);
    }
    // `let` declaration with optional assignment (`var` in es5 mode)
    let(C, q, N) {
      return this._def(r.varKinds.let, C, q, N);
    }
    // `var` declaration with optional assignment
    var(C, q, N) {
      return this._def(r.varKinds.var, C, q, N);
    }
    // assignment code
    assign(C, q, N) {
      return this._leafNode(new u(C, q, N));
    }
    // `+=` code
    add(C, q) {
      return this._leafNode(new c(C, e.operators.ADD, q));
    }
    // appends passed SafeExpr to code or executes Block
    code(C) {
      return typeof C == "function" ? C() : C !== t.nil && this._leafNode(new h(C)), this;
    }
    // returns code for object literal for the passed argument list of key-value pairs
    object(...C) {
      const q = ["{"];
      for (const [N, F] of C)
        q.length > 1 && q.push(","), q.push(N), (N !== F || this.opts.es5) && (q.push(":"), (0, t.addCodeArg)(q, F));
      return q.push("}"), new t._Code(q);
    }
    // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
    if(C, q, N) {
      if (this._blockNode(new m(C)), q && N)
        this.code(q).else().code(N).endIf();
      else if (q)
        this.code(q).endIf();
      else if (N)
        throw new Error('CodeGen: "else" body without "then" body');
      return this;
    }
    // `else if` clause - invalid without `if` or after `else` clauses
    elseIf(C) {
      return this._elseNode(new m(C));
    }
    // `else` clause - only valid after `if` or `else if` clauses
    else() {
      return this._elseNode(new _());
    }
    // end `if` statement (needed if gen.if was used only with condition)
    endIf() {
      return this._endBlockNode(m, _);
    }
    _for(C, q) {
      return this._blockNode(C), q && this.code(q).endFor(), this;
    }
    // a generic `for` clause (or statement if `forBody` is passed)
    for(C, q) {
      return this._for(new $(C), q);
    }
    // `for` statement for a range of values
    forRange(C, q, N, F, T = this.opts.es5 ? r.varKinds.var : r.varKinds.let) {
      const Z = this._scope.toName(C);
      return this._for(new E(T, Z, q, N), () => F(Z));
    }
    // `for-of` statement (in es5 mode replace with a normal for loop)
    forOf(C, q, N, F = r.varKinds.const) {
      const T = this._scope.toName(C);
      if (this.opts.es5) {
        const Z = q instanceof t.Name ? q : this.var("_arr", q);
        return this.forRange("_i", 0, (0, t._)`${Z}.length`, (Y) => {
          this.var(T, (0, t._)`${Z}[${Y}]`), N(T);
        });
      }
      return this._for(new A("of", F, T, q), () => N(T));
    }
    // `for-in` statement.
    // With option `ownProperties` replaced with a `for-of` loop for object keys
    forIn(C, q, N, F = this.opts.es5 ? r.varKinds.var : r.varKinds.const) {
      if (this.opts.ownProperties)
        return this.forOf(C, (0, t._)`Object.keys(${q})`, N);
      const T = this._scope.toName(C);
      return this._for(new A("in", F, T, q), () => N(T));
    }
    // end `for` loop
    endFor() {
      return this._endBlockNode(w);
    }
    // `label` statement
    label(C) {
      return this._leafNode(new l(C));
    }
    // `break` statement
    break(C) {
      return this._leafNode(new d(C));
    }
    // `return` statement
    return(C) {
      const q = new I();
      if (this._blockNode(q), this.code(C), q.nodes.length !== 1)
        throw new Error('CodeGen: "return" should have one node');
      return this._endBlockNode(I);
    }
    // `try` statement
    try(C, q, N) {
      if (!q && !N)
        throw new Error('CodeGen: "try" without "catch" and "finally"');
      const F = new D();
      if (this._blockNode(F), this.code(C), q) {
        const T = this.name("e");
        this._currNode = F.catch = new J(T), q(T);
      }
      return N && (this._currNode = F.finally = new ae(), this.code(N)), this._endBlockNode(J, ae);
    }
    // `throw` statement
    throw(C) {
      return this._leafNode(new p(C));
    }
    // start self-balancing block
    block(C, q) {
      return this._blockStarts.push(this._nodes.length), C && this.code(C).endBlock(q), this;
    }
    // end the current self-balancing block
    endBlock(C) {
      const q = this._blockStarts.pop();
      if (q === void 0)
        throw new Error("CodeGen: not in self-balancing block");
      const N = this._nodes.length - q;
      if (N < 0 || C !== void 0 && N !== C)
        throw new Error(`CodeGen: wrong number of nodes: ${N} vs ${C} expected`);
      return this._nodes.length = q, this;
    }
    // `function` heading (or definition if funcBody is passed)
    func(C, q = t.nil, N, F) {
      return this._blockNode(new R(C, q, N)), F && this.code(F).endFunc(), this;
    }
    // end function definition
    endFunc() {
      return this._endBlockNode(R);
    }
    optimize(C = 1) {
      for (; C-- > 0; )
        this._root.optimizeNodes(), this._root.optimizeNames(this._root.names, this._constants);
    }
    _leafNode(C) {
      return this._currNode.nodes.push(C), this;
    }
    _blockNode(C) {
      this._currNode.nodes.push(C), this._nodes.push(C);
    }
    _endBlockNode(C, q) {
      const N = this._currNode;
      if (N instanceof C || q && N instanceof q)
        return this._nodes.pop(), this;
      throw new Error(`CodeGen: not in block "${q ? `${C.kind}/${q.kind}` : C.kind}"`);
    }
    _elseNode(C) {
      const q = this._currNode;
      if (!(q instanceof m))
        throw new Error('CodeGen: "else" without "if"');
      return this._currNode = q.else = C, this;
    }
    get _root() {
      return this._nodes[0];
    }
    get _currNode() {
      const C = this._nodes;
      return C[C.length - 1];
    }
    set _currNode(C) {
      const q = this._nodes;
      q[q.length - 1] = C;
    }
  }
  e.CodeGen = ye;
  function xe(z, C) {
    for (const q in C)
      z[q] = (z[q] || 0) + (C[q] || 0);
    return z;
  }
  function je(z, C) {
    return C instanceof t._CodeOrName ? xe(z, C.names) : z;
  }
  function re(z, C, q) {
    if (z instanceof t.Name)
      return N(z);
    if (!F(z))
      return z;
    return new t._Code(z._items.reduce((T, Z) => (Z instanceof t.Name && (Z = N(Z)), Z instanceof t._Code ? T.push(...Z._items) : T.push(Z), T), []));
    function N(T) {
      const Z = q[T.str];
      return Z === void 0 || C[T.str] !== 1 ? T : (delete C[T.str], Z);
    }
    function F(T) {
      return T instanceof t._Code && T._items.some((Z) => Z instanceof t.Name && C[Z.str] === 1 && q[Z.str] !== void 0);
    }
  }
  function fe(z, C) {
    for (const q in C)
      z[q] = (z[q] || 0) - (C[q] || 0);
  }
  function le(z) {
    return typeof z == "boolean" || typeof z == "number" || z === null ? !z : (0, t._)`!${V(z)}`;
  }
  e.not = le;
  const $e = K(e.operators.AND);
  function Ae(...z) {
    return z.reduce($e);
  }
  e.and = Ae;
  const _e = K(e.operators.OR);
  function ie(...z) {
    return z.reduce(_e);
  }
  e.or = ie;
  function K(z) {
    return (C, q) => C === t.nil ? q : q === t.nil ? C : (0, t._)`${V(C)} ${z} ${V(q)}`;
  }
  function V(z) {
    return z instanceof t.Name ? z : (0, t._)`(${z})`;
  }
})(ht);
var Pt = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.checkStrictMode = e.getErrorPath = e.Type = e.useFunc = e.setEvaluated = e.evaluatedPropsToName = e.mergeEvaluated = e.eachItem = e.unescapeJsonPointer = e.escapeJsonPointer = e.escapeFragment = e.unescapeFragment = e.schemaRefOrVal = e.schemaHasRulesButRef = e.schemaHasRules = e.checkUnknownRules = e.alwaysValidSchema = e.toHash = void 0;
  const t = ht, r = Bu;
  function i(R) {
    const I = {};
    for (const D of R)
      I[D] = !0;
    return I;
  }
  e.toHash = i;
  function n(R, I) {
    return typeof I == "boolean" ? I : Object.keys(I).length === 0 ? !0 : (s(R, I), !a(I, R.self.RULES.all));
  }
  e.alwaysValidSchema = n;
  function s(R, I = R.schema) {
    const { opts: D, self: J } = R;
    if (!D.strictSchema || typeof I == "boolean")
      return;
    const ae = J.RULES.keywords;
    for (const ye in I)
      ae[ye] || A(R, `unknown keyword: "${ye}"`);
  }
  e.checkUnknownRules = s;
  function a(R, I) {
    if (typeof R == "boolean")
      return !R;
    for (const D in R)
      if (I[D])
        return !0;
    return !1;
  }
  e.schemaHasRules = a;
  function u(R, I) {
    if (typeof R == "boolean")
      return !R;
    for (const D in R)
      if (D !== "$ref" && I.all[D])
        return !0;
    return !1;
  }
  e.schemaHasRulesButRef = u;
  function c({ topSchemaRef: R, schemaPath: I }, D, J, ae) {
    if (!ae) {
      if (typeof D == "number" || typeof D == "boolean")
        return D;
      if (typeof D == "string")
        return (0, t._)`${D}`;
    }
    return (0, t._)`${R}${I}${(0, t.getProperty)(J)}`;
  }
  e.schemaRefOrVal = c;
  function l(R) {
    return h(decodeURIComponent(R));
  }
  e.unescapeFragment = l;
  function d(R) {
    return encodeURIComponent(p(R));
  }
  e.escapeFragment = d;
  function p(R) {
    return typeof R == "number" ? `${R}` : R.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  e.escapeJsonPointer = p;
  function h(R) {
    return R.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  e.unescapeJsonPointer = h;
  function v(R, I) {
    if (Array.isArray(R))
      for (const D of R)
        I(D);
    else
      I(R);
  }
  e.eachItem = v;
  function y({ mergeNames: R, mergeToName: I, mergeValues: D, resultToName: J }) {
    return (ae, ye, xe, je) => {
      const re = xe === void 0 ? ye : xe instanceof t.Name ? (ye instanceof t.Name ? R(ae, ye, xe) : I(ae, ye, xe), xe) : ye instanceof t.Name ? (I(ae, xe, ye), ye) : D(ye, xe);
      return je === t.Name && !(re instanceof t.Name) ? J(ae, re) : re;
    };
  }
  e.mergeEvaluated = {
    props: y({
      mergeNames: (R, I, D) => R.if((0, t._)`${D} !== true && ${I} !== undefined`, () => {
        R.if((0, t._)`${I} === true`, () => R.assign(D, !0), () => R.assign(D, (0, t._)`${D} || {}`).code((0, t._)`Object.assign(${D}, ${I})`));
      }),
      mergeToName: (R, I, D) => R.if((0, t._)`${D} !== true`, () => {
        I === !0 ? R.assign(D, !0) : (R.assign(D, (0, t._)`${D} || {}`), _(R, D, I));
      }),
      mergeValues: (R, I) => R === !0 ? !0 : { ...R, ...I },
      resultToName: g
    }),
    items: y({
      mergeNames: (R, I, D) => R.if((0, t._)`${D} !== true && ${I} !== undefined`, () => R.assign(D, (0, t._)`${I} === true ? true : ${D} > ${I} ? ${D} : ${I}`)),
      mergeToName: (R, I, D) => R.if((0, t._)`${D} !== true`, () => R.assign(D, I === !0 ? !0 : (0, t._)`${D} > ${I} ? ${D} : ${I}`)),
      mergeValues: (R, I) => R === !0 ? !0 : Math.max(R, I),
      resultToName: (R, I) => R.var("items", I)
    })
  };
  function g(R, I) {
    if (I === !0)
      return R.var("props", !0);
    const D = R.var("props", (0, t._)`{}`);
    return I !== void 0 && _(R, D, I), D;
  }
  e.evaluatedPropsToName = g;
  function _(R, I, D) {
    Object.keys(D).forEach((J) => R.assign((0, t._)`${I}${(0, t.getProperty)(J)}`, !0));
  }
  e.setEvaluated = _;
  const m = {};
  function w(R, I) {
    return R.scopeValue("func", {
      ref: I,
      code: m[I.code] || (m[I.code] = new r._Code(I.code))
    });
  }
  e.useFunc = w;
  var $;
  (function(R) {
    R[R.Num = 0] = "Num", R[R.Str = 1] = "Str";
  })($ = e.Type || (e.Type = {}));
  function E(R, I, D) {
    if (R instanceof t.Name) {
      const J = I === $.Num;
      return D ? J ? (0, t._)`"[" + ${R} + "]"` : (0, t._)`"['" + ${R} + "']"` : J ? (0, t._)`"/" + ${R}` : (0, t._)`"/" + ${R}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
    }
    return D ? (0, t.getProperty)(R).toString() : "/" + p(R);
  }
  e.getErrorPath = E;
  function A(R, I, D = R.opts.strictSchema) {
    if (D) {
      if (I = `strict mode: ${I}`, D === !0)
        throw new Error(I);
      R.self.logger.warn(I);
    }
  }
  e.checkStrictMode = A;
})(Pt);
var nn = {};
Object.defineProperty(nn, "__esModule", { value: !0 });
const xr = ht, xF = {
  // validation function arguments
  data: new xr.Name("data"),
  // args passed from referencing schema
  valCxt: new xr.Name("valCxt"),
  instancePath: new xr.Name("instancePath"),
  parentData: new xr.Name("parentData"),
  parentDataProperty: new xr.Name("parentDataProperty"),
  rootData: new xr.Name("rootData"),
  dynamicAnchors: new xr.Name("dynamicAnchors"),
  // function scoped variables
  vErrors: new xr.Name("vErrors"),
  errors: new xr.Name("errors"),
  this: new xr.Name("this"),
  // "globals"
  self: new xr.Name("self"),
  scope: new xr.Name("scope"),
  // JTD serialize/parse name for JSON string and position
  json: new xr.Name("json"),
  jsonPos: new xr.Name("jsonPos"),
  jsonLen: new xr.Name("jsonLen"),
  jsonPart: new xr.Name("jsonPart")
};
nn.default = xF;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.extendErrors = e.resetErrorsCount = e.reportExtraError = e.reportError = e.keyword$DataError = e.keywordError = void 0;
  const t = ht, r = Pt, i = nn;
  e.keywordError = {
    message: ({ keyword: _ }) => (0, t.str)`must pass "${_}" keyword validation`
  }, e.keyword$DataError = {
    message: ({ keyword: _, schemaType: m }) => m ? (0, t.str)`"${_}" keyword must be ${m} ($data)` : (0, t.str)`"${_}" keyword is invalid ($data)`
  };
  function n(_, m = e.keywordError, w, $) {
    const { it: E } = _, { gen: A, compositeRule: R, allErrors: I } = E, D = p(_, m, w);
    $ ?? (R || I) ? c(A, D) : l(E, (0, t._)`[${D}]`);
  }
  e.reportError = n;
  function s(_, m = e.keywordError, w) {
    const { it: $ } = _, { gen: E, compositeRule: A, allErrors: R } = $, I = p(_, m, w);
    c(E, I), A || R || l($, i.default.vErrors);
  }
  e.reportExtraError = s;
  function a(_, m) {
    _.assign(i.default.errors, m), _.if((0, t._)`${i.default.vErrors} !== null`, () => _.if(m, () => _.assign((0, t._)`${i.default.vErrors}.length`, m), () => _.assign(i.default.vErrors, null)));
  }
  e.resetErrorsCount = a;
  function u({ gen: _, keyword: m, schemaValue: w, data: $, errsCount: E, it: A }) {
    if (E === void 0)
      throw new Error("ajv implementation error");
    const R = _.name("err");
    _.forRange("i", E, i.default.errors, (I) => {
      _.const(R, (0, t._)`${i.default.vErrors}[${I}]`), _.if((0, t._)`${R}.instancePath === undefined`, () => _.assign((0, t._)`${R}.instancePath`, (0, t.strConcat)(i.default.instancePath, A.errorPath))), _.assign((0, t._)`${R}.schemaPath`, (0, t.str)`${A.errSchemaPath}/${m}`), A.opts.verbose && (_.assign((0, t._)`${R}.schema`, w), _.assign((0, t._)`${R}.data`, $));
    });
  }
  e.extendErrors = u;
  function c(_, m) {
    const w = _.const("err", m);
    _.if((0, t._)`${i.default.vErrors} === null`, () => _.assign(i.default.vErrors, (0, t._)`[${w}]`), (0, t._)`${i.default.vErrors}.push(${w})`), _.code((0, t._)`${i.default.errors}++`);
  }
  function l(_, m) {
    const { gen: w, validateName: $, schemaEnv: E } = _;
    E.$async ? w.throw((0, t._)`new ${_.ValidationError}(${m})`) : (w.assign((0, t._)`${$}.errors`, m), w.return(!1));
  }
  const d = {
    keyword: new t.Name("keyword"),
    schemaPath: new t.Name("schemaPath"),
    params: new t.Name("params"),
    propertyName: new t.Name("propertyName"),
    message: new t.Name("message"),
    schema: new t.Name("schema"),
    parentSchema: new t.Name("parentSchema")
  };
  function p(_, m, w) {
    const { createErrors: $ } = _.it;
    return $ === !1 ? (0, t._)`{}` : h(_, m, w);
  }
  function h(_, m, w = {}) {
    const { gen: $, it: E } = _, A = [
      v(E, w),
      y(_, w)
    ];
    return g(_, m, A), $.object(...A);
  }
  function v({ errorPath: _ }, { instancePath: m }) {
    const w = m ? (0, t.str)`${_}${(0, r.getErrorPath)(m, r.Type.Str)}` : _;
    return [i.default.instancePath, (0, t.strConcat)(i.default.instancePath, w)];
  }
  function y({ keyword: _, it: { errSchemaPath: m } }, { schemaPath: w, parentSchema: $ }) {
    let E = $ ? m : (0, t.str)`${m}/${_}`;
    return w && (E = (0, t.str)`${E}${(0, r.getErrorPath)(w, r.Type.Str)}`), [d.schemaPath, E];
  }
  function g(_, { params: m, message: w }, $) {
    const { keyword: E, data: A, schemaValue: R, it: I } = _, { opts: D, propertyName: J, topSchemaRef: ae, schemaPath: ye } = I;
    $.push([d.keyword, E], [d.params, typeof m == "function" ? m(_) : m || (0, t._)`{}`]), D.messages && $.push([d.message, typeof w == "function" ? w(_) : w]), D.verbose && $.push([d.schema, R], [d.parentSchema, (0, t._)`${ae}${ye}`], [i.default.data, A]), J && $.push([d.propertyName, J]);
  }
})(ic);
Object.defineProperty(oo, "__esModule", { value: !0 });
oo.boolOrEmptySchema = oo.topBoolOrEmptySchema = void 0;
const OF = ic, PF = ht, SF = nn, AF = {
  message: "boolean schema is false"
};
function CF(e) {
  const { gen: t, schema: r, validateName: i } = e;
  r === !1 ? nP(e, !1) : typeof r == "object" && r.$async === !0 ? t.return(SF.default.data) : (t.assign((0, PF._)`${i}.errors`, null), t.return(!0));
}
oo.topBoolOrEmptySchema = CF;
function RF(e, t) {
  const { gen: r, schema: i } = e;
  i === !1 ? (r.var(t, !1), nP(e)) : r.var(t, !0);
}
oo.boolOrEmptySchema = RF;
function nP(e, t) {
  const { gen: r, data: i } = e, n = {
    gen: r,
    keyword: "false schema",
    data: i,
    schema: !1,
    schemaCode: !1,
    schemaValue: !1,
    params: {},
    it: e
  };
  (0, OF.reportError)(n, AF, void 0, t);
}
var sc = {}, ea = {};
Object.defineProperty(ea, "__esModule", { value: !0 });
ea.getRules = ea.isJSONType = void 0;
const TF = ["string", "number", "integer", "boolean", "null", "object", "array"], IF = new Set(TF);
function jF(e) {
  return typeof e == "string" && IF.has(e);
}
ea.isJSONType = jF;
function kF() {
  const e = {
    number: { type: "number", rules: [] },
    string: { type: "string", rules: [] },
    array: { type: "array", rules: [] },
    object: { type: "object", rules: [] }
  };
  return {
    types: { ...e, integer: !0, boolean: !0, null: !0 },
    rules: [{ rules: [] }, e.number, e.string, e.array, e.object],
    post: { rules: [] },
    all: {},
    keywords: {}
  };
}
ea.getRules = kF;
var Oi = {};
Object.defineProperty(Oi, "__esModule", { value: !0 });
Oi.shouldUseRule = Oi.shouldUseGroup = Oi.schemaHasRulesForType = void 0;
function MF({ schema: e, self: t }, r) {
  const i = t.RULES.types[r];
  return i && i !== !0 && iP(e, i);
}
Oi.schemaHasRulesForType = MF;
function iP(e, t) {
  return t.rules.some((r) => sP(e, r));
}
Oi.shouldUseGroup = iP;
function sP(e, t) {
  var r;
  return e[t.keyword] !== void 0 || ((r = t.definition.implements) === null || r === void 0 ? void 0 : r.some((i) => e[i] !== void 0));
}
Oi.shouldUseRule = sP;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.reportTypeError = e.checkDataTypes = e.checkDataType = e.coerceAndCheckDataType = e.getJSONTypes = e.getSchemaTypes = e.DataType = void 0;
  const t = ea, r = Oi, i = ic, n = ht, s = Pt;
  var a;
  (function($) {
    $[$.Correct = 0] = "Correct", $[$.Wrong = 1] = "Wrong";
  })(a = e.DataType || (e.DataType = {}));
  function u($) {
    const E = c($.type);
    if (E.includes("null")) {
      if ($.nullable === !1)
        throw new Error("type: null contradicts nullable: false");
    } else {
      if (!E.length && $.nullable !== void 0)
        throw new Error('"nullable" cannot be used without "type"');
      $.nullable === !0 && E.push("null");
    }
    return E;
  }
  e.getSchemaTypes = u;
  function c($) {
    const E = Array.isArray($) ? $ : $ ? [$] : [];
    if (E.every(t.isJSONType))
      return E;
    throw new Error("type must be JSONType or JSONType[]: " + E.join(","));
  }
  e.getJSONTypes = c;
  function l($, E) {
    const { gen: A, data: R, opts: I } = $, D = p(E, I.coerceTypes), J = E.length > 0 && !(D.length === 0 && E.length === 1 && (0, r.schemaHasRulesForType)($, E[0]));
    if (J) {
      const ae = g(E, R, I.strictNumbers, a.Wrong);
      A.if(ae, () => {
        D.length ? h($, E, D) : m($);
      });
    }
    return J;
  }
  e.coerceAndCheckDataType = l;
  const d = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
  function p($, E) {
    return E ? $.filter((A) => d.has(A) || E === "array" && A === "array") : [];
  }
  function h($, E, A) {
    const { gen: R, data: I, opts: D } = $, J = R.let("dataType", (0, n._)`typeof ${I}`), ae = R.let("coerced", (0, n._)`undefined`);
    D.coerceTypes === "array" && R.if((0, n._)`${J} == 'object' && Array.isArray(${I}) && ${I}.length == 1`, () => R.assign(I, (0, n._)`${I}[0]`).assign(J, (0, n._)`typeof ${I}`).if(g(E, I, D.strictNumbers), () => R.assign(ae, I))), R.if((0, n._)`${ae} !== undefined`);
    for (const xe of A)
      (d.has(xe) || xe === "array" && D.coerceTypes === "array") && ye(xe);
    R.else(), m($), R.endIf(), R.if((0, n._)`${ae} !== undefined`, () => {
      R.assign(I, ae), v($, ae);
    });
    function ye(xe) {
      switch (xe) {
        case "string":
          R.elseIf((0, n._)`${J} == "number" || ${J} == "boolean"`).assign(ae, (0, n._)`"" + ${I}`).elseIf((0, n._)`${I} === null`).assign(ae, (0, n._)`""`);
          return;
        case "number":
          R.elseIf((0, n._)`${J} == "boolean" || ${I} === null
              || (${J} == "string" && ${I} && ${I} == +${I})`).assign(ae, (0, n._)`+${I}`);
          return;
        case "integer":
          R.elseIf((0, n._)`${J} === "boolean" || ${I} === null
              || (${J} === "string" && ${I} && ${I} == +${I} && !(${I} % 1))`).assign(ae, (0, n._)`+${I}`);
          return;
        case "boolean":
          R.elseIf((0, n._)`${I} === "false" || ${I} === 0 || ${I} === null`).assign(ae, !1).elseIf((0, n._)`${I} === "true" || ${I} === 1`).assign(ae, !0);
          return;
        case "null":
          R.elseIf((0, n._)`${I} === "" || ${I} === 0 || ${I} === false`), R.assign(ae, null);
          return;
        case "array":
          R.elseIf((0, n._)`${J} === "string" || ${J} === "number"
              || ${J} === "boolean" || ${I} === null`).assign(ae, (0, n._)`[${I}]`);
      }
    }
  }
  function v({ gen: $, parentData: E, parentDataProperty: A }, R) {
    $.if((0, n._)`${E} !== undefined`, () => $.assign((0, n._)`${E}[${A}]`, R));
  }
  function y($, E, A, R = a.Correct) {
    const I = R === a.Correct ? n.operators.EQ : n.operators.NEQ;
    let D;
    switch ($) {
      case "null":
        return (0, n._)`${E} ${I} null`;
      case "array":
        D = (0, n._)`Array.isArray(${E})`;
        break;
      case "object":
        D = (0, n._)`${E} && typeof ${E} == "object" && !Array.isArray(${E})`;
        break;
      case "integer":
        D = J((0, n._)`!(${E} % 1) && !isNaN(${E})`);
        break;
      case "number":
        D = J();
        break;
      default:
        return (0, n._)`typeof ${E} ${I} ${$}`;
    }
    return R === a.Correct ? D : (0, n.not)(D);
    function J(ae = n.nil) {
      return (0, n.and)((0, n._)`typeof ${E} == "number"`, ae, A ? (0, n._)`isFinite(${E})` : n.nil);
    }
  }
  e.checkDataType = y;
  function g($, E, A, R) {
    if ($.length === 1)
      return y($[0], E, A, R);
    let I;
    const D = (0, s.toHash)($);
    if (D.array && D.object) {
      const J = (0, n._)`typeof ${E} != "object"`;
      I = D.null ? J : (0, n._)`!${E} || ${J}`, delete D.null, delete D.array, delete D.object;
    } else
      I = n.nil;
    D.number && delete D.integer;
    for (const J in D)
      I = (0, n.and)(I, y(J, E, A, R));
    return I;
  }
  e.checkDataTypes = g;
  const _ = {
    message: ({ schema: $ }) => `must be ${$}`,
    params: ({ schema: $, schemaValue: E }) => typeof $ == "string" ? (0, n._)`{type: ${$}}` : (0, n._)`{type: ${E}}`
  };
  function m($) {
    const E = w($);
    (0, i.reportError)(E, _);
  }
  e.reportTypeError = m;
  function w($) {
    const { gen: E, data: A, schema: R } = $, I = (0, s.schemaRefOrVal)($, R, "type");
    return {
      gen: E,
      keyword: "type",
      data: A,
      schema: R.type,
      schemaCode: I,
      schemaValue: I,
      parentSchema: R,
      params: {},
      it: $
    };
  }
})(sc);
var Xf = {};
Object.defineProperty(Xf, "__esModule", { value: !0 });
Xf.assignDefaults = void 0;
const ja = ht, NF = Pt;
function DF(e, t) {
  const { properties: r, items: i } = e.schema;
  if (t === "object" && r)
    for (const n in r)
      Bw(e, n, r[n].default);
  else
    t === "array" && Array.isArray(i) && i.forEach((n, s) => Bw(e, s, n.default));
}
Xf.assignDefaults = DF;
function Bw(e, t, r) {
  const { gen: i, compositeRule: n, data: s, opts: a } = e;
  if (r === void 0)
    return;
  const u = (0, ja._)`${s}${(0, ja.getProperty)(t)}`;
  if (n) {
    (0, NF.checkStrictMode)(e, `default is ignored for: ${u}`);
    return;
  }
  let c = (0, ja._)`${u} === undefined`;
  a.useDefaults === "empty" && (c = (0, ja._)`${c} || ${u} === null || ${u} === ""`), i.if(c, (0, ja._)`${u} = ${(0, ja.stringify)(r)}`);
}
var Xn = {}, xt = {};
Object.defineProperty(xt, "__esModule", { value: !0 });
xt.validateUnion = xt.validateArray = xt.usePattern = xt.callValidateCode = xt.schemaProperties = xt.allSchemaProperties = xt.noPropertyInData = xt.propertyInData = xt.isOwnProperty = xt.hasPropFunc = xt.reportMissingProp = xt.checkMissingProp = xt.checkReportMissingProp = void 0;
const Gt = ht, zg = Pt, Ji = nn, LF = Pt;
function qF(e, t) {
  const { gen: r, data: i, it: n } = e;
  r.if(Hg(r, i, t, n.opts.ownProperties), () => {
    e.setParams({ missingProperty: (0, Gt._)`${t}` }, !0), e.error();
  });
}
xt.checkReportMissingProp = qF;
function FF({ gen: e, data: t, it: { opts: r } }, i, n) {
  return (0, Gt.or)(...i.map((s) => (0, Gt.and)(Hg(e, t, s, r.ownProperties), (0, Gt._)`${n} = ${s}`)));
}
xt.checkMissingProp = FF;
function UF(e, t) {
  e.setParams({ missingProperty: t }, !0), e.error();
}
xt.reportMissingProp = UF;
function aP(e) {
  return e.scopeValue("func", {
    // eslint-disable-next-line @typescript-eslint/unbound-method
    ref: Object.prototype.hasOwnProperty,
    code: (0, Gt._)`Object.prototype.hasOwnProperty`
  });
}
xt.hasPropFunc = aP;
function Wg(e, t, r) {
  return (0, Gt._)`${aP(e)}.call(${t}, ${r})`;
}
xt.isOwnProperty = Wg;
function BF(e, t, r, i) {
  const n = (0, Gt._)`${t}${(0, Gt.getProperty)(r)} !== undefined`;
  return i ? (0, Gt._)`${n} && ${Wg(e, t, r)}` : n;
}
xt.propertyInData = BF;
function Hg(e, t, r, i) {
  const n = (0, Gt._)`${t}${(0, Gt.getProperty)(r)} === undefined`;
  return i ? (0, Gt.or)(n, (0, Gt.not)(Wg(e, t, r))) : n;
}
xt.noPropertyInData = Hg;
function oP(e) {
  return e ? Object.keys(e).filter((t) => t !== "__proto__") : [];
}
xt.allSchemaProperties = oP;
function VF(e, t) {
  return oP(t).filter((r) => !(0, zg.alwaysValidSchema)(e, t[r]));
}
xt.schemaProperties = VF;
function ZF({ schemaCode: e, data: t, it: { gen: r, topSchemaRef: i, schemaPath: n, errorPath: s }, it: a }, u, c, l) {
  const d = l ? (0, Gt._)`${e}, ${t}, ${i}${n}` : t, p = [
    [Ji.default.instancePath, (0, Gt.strConcat)(Ji.default.instancePath, s)],
    [Ji.default.parentData, a.parentData],
    [Ji.default.parentDataProperty, a.parentDataProperty],
    [Ji.default.rootData, Ji.default.rootData]
  ];
  a.opts.dynamicRef && p.push([Ji.default.dynamicAnchors, Ji.default.dynamicAnchors]);
  const h = (0, Gt._)`${d}, ${r.object(...p)}`;
  return c !== Gt.nil ? (0, Gt._)`${u}.call(${c}, ${h})` : (0, Gt._)`${u}(${h})`;
}
xt.callValidateCode = ZF;
const zF = (0, Gt._)`new RegExp`;
function WF({ gen: e, it: { opts: t } }, r) {
  const i = t.unicodeRegExp ? "u" : "", { regExp: n } = t.code, s = n(r, i);
  return e.scopeValue("pattern", {
    key: s.toString(),
    ref: s,
    code: (0, Gt._)`${n.code === "new RegExp" ? zF : (0, LF.useFunc)(e, n)}(${r}, ${i})`
  });
}
xt.usePattern = WF;
function HF(e) {
  const { gen: t, data: r, keyword: i, it: n } = e, s = t.name("valid");
  if (n.allErrors) {
    const u = t.let("valid", !0);
    return a(() => t.assign(u, !1)), u;
  }
  return t.var(s, !0), a(() => t.break()), s;
  function a(u) {
    const c = t.const("len", (0, Gt._)`${r}.length`);
    t.forRange("i", 0, c, (l) => {
      e.subschema({
        keyword: i,
        dataProp: l,
        dataPropType: zg.Type.Num
      }, s), t.if((0, Gt.not)(s), u);
    });
  }
}
xt.validateArray = HF;
function GF(e) {
  const { gen: t, schema: r, keyword: i, it: n } = e;
  if (!Array.isArray(r))
    throw new Error("ajv implementation error");
  if (r.some((c) => (0, zg.alwaysValidSchema)(n, c)) && !n.opts.unevaluated)
    return;
  const a = t.let("valid", !1), u = t.name("_valid");
  t.block(() => r.forEach((c, l) => {
    const d = e.subschema({
      keyword: i,
      schemaProp: l,
      compositeRule: !0
    }, u);
    t.assign(a, (0, Gt._)`${a} || ${u}`), e.mergeValidEvaluated(d, u) || t.if((0, Gt.not)(a));
  })), e.result(a, () => e.reset(), () => e.error(!0));
}
xt.validateUnion = GF;
Object.defineProperty(Xn, "__esModule", { value: !0 });
Xn.validateKeywordUsage = Xn.validSchemaType = Xn.funcKeywordCode = Xn.macroKeywordCode = void 0;
const Mr = ht, qs = nn, KF = xt, YF = ic;
function JF(e, t) {
  const { gen: r, keyword: i, schema: n, parentSchema: s, it: a } = e, u = t.macro.call(a.self, n, s, a), c = uP(r, i, u);
  a.opts.validateSchema !== !1 && a.self.validateSchema(u, !0);
  const l = r.name("valid");
  e.subschema({
    schema: u,
    schemaPath: Mr.nil,
    errSchemaPath: `${a.errSchemaPath}/${i}`,
    topSchemaRef: c,
    compositeRule: !0
  }, l), e.pass(l, () => e.error(!0));
}
Xn.macroKeywordCode = JF;
function XF(e, t) {
  var r;
  const { gen: i, keyword: n, schema: s, parentSchema: a, $data: u, it: c } = e;
  eU(c, t);
  const l = !u && t.compile ? t.compile.call(c.self, s, a, c) : t.validate, d = uP(i, n, l), p = i.let("valid");
  e.block$data(p, h), e.ok((r = t.valid) !== null && r !== void 0 ? r : p);
  function h() {
    if (t.errors === !1)
      g(), t.modifying && Vw(e), _(() => e.error());
    else {
      const m = t.async ? v() : y();
      t.modifying && Vw(e), _(() => QF(e, m));
    }
  }
  function v() {
    const m = i.let("ruleErrs", null);
    return i.try(() => g((0, Mr._)`await `), (w) => i.assign(p, !1).if((0, Mr._)`${w} instanceof ${c.ValidationError}`, () => i.assign(m, (0, Mr._)`${w}.errors`), () => i.throw(w))), m;
  }
  function y() {
    const m = (0, Mr._)`${d}.errors`;
    return i.assign(m, null), g(Mr.nil), m;
  }
  function g(m = t.async ? (0, Mr._)`await ` : Mr.nil) {
    const w = c.opts.passContext ? qs.default.this : qs.default.self, $ = !("compile" in t && !u || t.schema === !1);
    i.assign(p, (0, Mr._)`${m}${(0, KF.callValidateCode)(e, d, w, $)}`, t.modifying);
  }
  function _(m) {
    var w;
    i.if((0, Mr.not)((w = t.valid) !== null && w !== void 0 ? w : p), m);
  }
}
Xn.funcKeywordCode = XF;
function Vw(e) {
  const { gen: t, data: r, it: i } = e;
  t.if(i.parentData, () => t.assign(r, (0, Mr._)`${i.parentData}[${i.parentDataProperty}]`));
}
function QF(e, t) {
  const { gen: r } = e;
  r.if((0, Mr._)`Array.isArray(${t})`, () => {
    r.assign(qs.default.vErrors, (0, Mr._)`${qs.default.vErrors} === null ? ${t} : ${qs.default.vErrors}.concat(${t})`).assign(qs.default.errors, (0, Mr._)`${qs.default.vErrors}.length`), (0, YF.extendErrors)(e);
  }, () => e.error());
}
function eU({ schemaEnv: e }, t) {
  if (t.async && !e.$async)
    throw new Error("async keyword in sync schema");
}
function uP(e, t, r) {
  if (r === void 0)
    throw new Error(`keyword "${t}" failed to compile`);
  return e.scopeValue("keyword", typeof r == "function" ? { ref: r } : { ref: r, code: (0, Mr.stringify)(r) });
}
function tU(e, t, r = !1) {
  return !t.length || t.some((i) => i === "array" ? Array.isArray(e) : i === "object" ? e && typeof e == "object" && !Array.isArray(e) : typeof e == i || r && typeof e > "u");
}
Xn.validSchemaType = tU;
function rU({ schema: e, opts: t, self: r, errSchemaPath: i }, n, s) {
  if (Array.isArray(n.keyword) ? !n.keyword.includes(s) : n.keyword !== s)
    throw new Error("ajv implementation error");
  const a = n.dependencies;
  if (a != null && a.some((u) => !Object.prototype.hasOwnProperty.call(e, u)))
    throw new Error(`parent schema must have dependencies of ${s}: ${a.join(",")}`);
  if (n.validateSchema && !n.validateSchema(e[s])) {
    const c = `keyword "${s}" value is invalid at path "${i}": ` + r.errorsText(n.validateSchema.errors);
    if (t.validateSchema === "log")
      r.logger.error(c);
    else
      throw new Error(c);
  }
}
Xn.validateKeywordUsage = rU;
var us = {};
Object.defineProperty(us, "__esModule", { value: !0 });
us.extendSubschemaMode = us.extendSubschemaData = us.getSubschema = void 0;
const Yn = ht, cP = Pt;
function nU(e, { keyword: t, schemaProp: r, schema: i, schemaPath: n, errSchemaPath: s, topSchemaRef: a }) {
  if (t !== void 0 && i !== void 0)
    throw new Error('both "keyword" and "schema" passed, only one allowed');
  if (t !== void 0) {
    const u = e.schema[t];
    return r === void 0 ? {
      schema: u,
      schemaPath: (0, Yn._)`${e.schemaPath}${(0, Yn.getProperty)(t)}`,
      errSchemaPath: `${e.errSchemaPath}/${t}`
    } : {
      schema: u[r],
      schemaPath: (0, Yn._)`${e.schemaPath}${(0, Yn.getProperty)(t)}${(0, Yn.getProperty)(r)}`,
      errSchemaPath: `${e.errSchemaPath}/${t}/${(0, cP.escapeFragment)(r)}`
    };
  }
  if (i !== void 0) {
    if (n === void 0 || s === void 0 || a === void 0)
      throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
    return {
      schema: i,
      schemaPath: n,
      topSchemaRef: a,
      errSchemaPath: s
    };
  }
  throw new Error('either "keyword" or "schema" must be passed');
}
us.getSubschema = nU;
function iU(e, t, { dataProp: r, dataPropType: i, data: n, dataTypes: s, propertyName: a }) {
  if (n !== void 0 && r !== void 0)
    throw new Error('both "data" and "dataProp" passed, only one allowed');
  const { gen: u } = t;
  if (r !== void 0) {
    const { errorPath: l, dataPathArr: d, opts: p } = t, h = u.let("data", (0, Yn._)`${t.data}${(0, Yn.getProperty)(r)}`, !0);
    c(h), e.errorPath = (0, Yn.str)`${l}${(0, cP.getErrorPath)(r, i, p.jsPropertySyntax)}`, e.parentDataProperty = (0, Yn._)`${r}`, e.dataPathArr = [...d, e.parentDataProperty];
  }
  if (n !== void 0) {
    const l = n instanceof Yn.Name ? n : u.let("data", n, !0);
    c(l), a !== void 0 && (e.propertyName = a);
  }
  s && (e.dataTypes = s);
  function c(l) {
    e.data = l, e.dataLevel = t.dataLevel + 1, e.dataTypes = [], t.definedProperties = /* @__PURE__ */ new Set(), e.parentData = t.data, e.dataNames = [...t.dataNames, l];
  }
}
us.extendSubschemaData = iU;
function sU(e, { jtdDiscriminator: t, jtdMetadata: r, compositeRule: i, createErrors: n, allErrors: s }) {
  i !== void 0 && (e.compositeRule = i), n !== void 0 && (e.createErrors = n), s !== void 0 && (e.allErrors = s), e.jtdDiscriminator = t, e.jtdMetadata = r;
}
us.extendSubschemaMode = sU;
var vr = {}, lP = function e(t, r) {
  if (t === r)
    return !0;
  if (t && r && typeof t == "object" && typeof r == "object") {
    if (t.constructor !== r.constructor)
      return !1;
    var i, n, s;
    if (Array.isArray(t)) {
      if (i = t.length, i != r.length)
        return !1;
      for (n = i; n-- !== 0; )
        if (!e(t[n], r[n]))
          return !1;
      return !0;
    }
    if (t.constructor === RegExp)
      return t.source === r.source && t.flags === r.flags;
    if (t.valueOf !== Object.prototype.valueOf)
      return t.valueOf() === r.valueOf();
    if (t.toString !== Object.prototype.toString)
      return t.toString() === r.toString();
    if (s = Object.keys(t), i = s.length, i !== Object.keys(r).length)
      return !1;
    for (n = i; n-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(r, s[n]))
        return !1;
    for (n = i; n-- !== 0; ) {
      var a = s[n];
      if (!e(t[a], r[a]))
        return !1;
    }
    return !0;
  }
  return t !== t && r !== r;
}, fP = { exports: {} }, ss = fP.exports = function(e, t, r) {
  typeof t == "function" && (r = t, t = {}), r = t.cb || r;
  var i = typeof r == "function" ? r : r.pre || function() {
  }, n = r.post || function() {
  };
  Nl(t, i, n, e, "", e);
};
ss.keywords = {
  additionalItems: !0,
  items: !0,
  contains: !0,
  additionalProperties: !0,
  propertyNames: !0,
  not: !0,
  if: !0,
  then: !0,
  else: !0
};
ss.arrayKeywords = {
  items: !0,
  allOf: !0,
  anyOf: !0,
  oneOf: !0
};
ss.propsKeywords = {
  $defs: !0,
  definitions: !0,
  properties: !0,
  patternProperties: !0,
  dependencies: !0
};
ss.skipKeywords = {
  default: !0,
  enum: !0,
  const: !0,
  required: !0,
  maximum: !0,
  minimum: !0,
  exclusiveMaximum: !0,
  exclusiveMinimum: !0,
  multipleOf: !0,
  maxLength: !0,
  minLength: !0,
  pattern: !0,
  format: !0,
  maxItems: !0,
  minItems: !0,
  uniqueItems: !0,
  maxProperties: !0,
  minProperties: !0
};
function Nl(e, t, r, i, n, s, a, u, c, l) {
  if (i && typeof i == "object" && !Array.isArray(i)) {
    t(i, n, s, a, u, c, l);
    for (var d in i) {
      var p = i[d];
      if (Array.isArray(p)) {
        if (d in ss.arrayKeywords)
          for (var h = 0; h < p.length; h++)
            Nl(e, t, r, p[h], n + "/" + d + "/" + h, s, n, d, i, h);
      } else if (d in ss.propsKeywords) {
        if (p && typeof p == "object")
          for (var v in p)
            Nl(e, t, r, p[v], n + "/" + d + "/" + aU(v), s, n, d, i, v);
      } else
        (d in ss.keywords || e.allKeys && !(d in ss.skipKeywords)) && Nl(e, t, r, p, n + "/" + d, s, n, d, i);
    }
    r(i, n, s, a, u, c, l);
  }
}
function aU(e) {
  return e.replace(/~/g, "~0").replace(/\//g, "~1");
}
var oU = fP.exports;
Object.defineProperty(vr, "__esModule", { value: !0 });
vr.getSchemaRefs = vr.resolveUrl = vr.normalizeId = vr._getFullPath = vr.getFullPath = vr.inlineRef = void 0;
const uU = Pt, cU = lP, lU = oU, fU = /* @__PURE__ */ new Set([
  "type",
  "format",
  "pattern",
  "maxLength",
  "minLength",
  "maxProperties",
  "minProperties",
  "maxItems",
  "minItems",
  "maximum",
  "minimum",
  "uniqueItems",
  "multipleOf",
  "required",
  "enum",
  "const"
]);
function dU(e, t = !0) {
  return typeof e == "boolean" ? !0 : t === !0 ? !Ly(e) : t ? dP(e) <= t : !1;
}
vr.inlineRef = dU;
const pU = /* @__PURE__ */ new Set([
  "$ref",
  "$recursiveRef",
  "$recursiveAnchor",
  "$dynamicRef",
  "$dynamicAnchor"
]);
function Ly(e) {
  for (const t in e) {
    if (pU.has(t))
      return !0;
    const r = e[t];
    if (Array.isArray(r) && r.some(Ly) || typeof r == "object" && Ly(r))
      return !0;
  }
  return !1;
}
function dP(e) {
  let t = 0;
  for (const r in e) {
    if (r === "$ref")
      return 1 / 0;
    if (t++, !fU.has(r) && (typeof e[r] == "object" && (0, uU.eachItem)(e[r], (i) => t += dP(i)), t === 1 / 0))
      return 1 / 0;
  }
  return t;
}
function pP(e, t = "", r) {
  r !== !1 && (t = Qa(t));
  const i = e.parse(t);
  return hP(e, i);
}
vr.getFullPath = pP;
function hP(e, t) {
  return e.serialize(t).split("#")[0] + "#";
}
vr._getFullPath = hP;
const hU = /#\/?$/;
function Qa(e) {
  return e ? e.replace(hU, "") : "";
}
vr.normalizeId = Qa;
function mU(e, t, r) {
  return r = Qa(r), e.resolve(t, r);
}
vr.resolveUrl = mU;
const yU = /^[a-z_][-a-z0-9._]*$/i;
function gU(e, t) {
  if (typeof e == "boolean")
    return {};
  const { schemaId: r, uriResolver: i } = this.opts, n = Qa(e[r] || t), s = { "": n }, a = pP(i, n, !1), u = {}, c = /* @__PURE__ */ new Set();
  return lU(e, { allKeys: !0 }, (p, h, v, y) => {
    if (y === void 0)
      return;
    const g = a + h;
    let _ = s[y];
    typeof p[r] == "string" && (_ = m.call(this, p[r])), w.call(this, p.$anchor), w.call(this, p.$dynamicAnchor), s[h] = _;
    function m($) {
      const E = this.opts.uriResolver.resolve;
      if ($ = Qa(_ ? E(_, $) : $), c.has($))
        throw d($);
      c.add($);
      let A = this.refs[$];
      return typeof A == "string" && (A = this.refs[A]), typeof A == "object" ? l(p, A.schema, $) : $ !== Qa(g) && ($[0] === "#" ? (l(p, u[$], $), u[$] = p) : this.refs[$] = g), $;
    }
    function w($) {
      if (typeof $ == "string") {
        if (!yU.test($))
          throw new Error(`invalid anchor "${$}"`);
        m.call(this, `#${$}`);
      }
    }
  }), u;
  function l(p, h, v) {
    if (h !== void 0 && !cU(p, h))
      throw d(v);
  }
  function d(p) {
    return new Error(`reference "${p}" resolves to more than one schema`);
  }
}
vr.getSchemaRefs = gU;
Object.defineProperty(jn, "__esModule", { value: !0 });
jn.getData = jn.KeywordCxt = jn.validateFunctionCode = void 0;
const mP = oo, Zw = sc, Gg = Oi, gf = sc, vU = Xf, hu = Xn, Gh = us, Qe = ht, lt = nn, bU = vr, Pi = Pt, Xo = ic;
function _U(e) {
  if (vP(e) && (bP(e), gP(e))) {
    EU(e);
    return;
  }
  yP(e, () => (0, mP.topBoolOrEmptySchema)(e));
}
jn.validateFunctionCode = _U;
function yP({ gen: e, validateName: t, schema: r, schemaEnv: i, opts: n }, s) {
  n.code.es5 ? e.func(t, (0, Qe._)`${lt.default.data}, ${lt.default.valCxt}`, i.$async, () => {
    e.code((0, Qe._)`"use strict"; ${zw(r, n)}`), $U(e, n), e.code(s);
  }) : e.func(t, (0, Qe._)`${lt.default.data}, ${wU(n)}`, i.$async, () => e.code(zw(r, n)).code(s));
}
function wU(e) {
  return (0, Qe._)`{${lt.default.instancePath}="", ${lt.default.parentData}, ${lt.default.parentDataProperty}, ${lt.default.rootData}=${lt.default.data}${e.dynamicRef ? (0, Qe._)`, ${lt.default.dynamicAnchors}={}` : Qe.nil}}={}`;
}
function $U(e, t) {
  e.if(lt.default.valCxt, () => {
    e.var(lt.default.instancePath, (0, Qe._)`${lt.default.valCxt}.${lt.default.instancePath}`), e.var(lt.default.parentData, (0, Qe._)`${lt.default.valCxt}.${lt.default.parentData}`), e.var(lt.default.parentDataProperty, (0, Qe._)`${lt.default.valCxt}.${lt.default.parentDataProperty}`), e.var(lt.default.rootData, (0, Qe._)`${lt.default.valCxt}.${lt.default.rootData}`), t.dynamicRef && e.var(lt.default.dynamicAnchors, (0, Qe._)`${lt.default.valCxt}.${lt.default.dynamicAnchors}`);
  }, () => {
    e.var(lt.default.instancePath, (0, Qe._)`""`), e.var(lt.default.parentData, (0, Qe._)`undefined`), e.var(lt.default.parentDataProperty, (0, Qe._)`undefined`), e.var(lt.default.rootData, lt.default.data), t.dynamicRef && e.var(lt.default.dynamicAnchors, (0, Qe._)`{}`);
  });
}
function EU(e) {
  const { schema: t, opts: r, gen: i } = e;
  yP(e, () => {
    r.$comment && t.$comment && wP(e), AU(e), i.let(lt.default.vErrors, null), i.let(lt.default.errors, 0), r.unevaluated && xU(e), _P(e), TU(e);
  });
}
function xU(e) {
  const { gen: t, validateName: r } = e;
  e.evaluated = t.const("evaluated", (0, Qe._)`${r}.evaluated`), t.if((0, Qe._)`${e.evaluated}.dynamicProps`, () => t.assign((0, Qe._)`${e.evaluated}.props`, (0, Qe._)`undefined`)), t.if((0, Qe._)`${e.evaluated}.dynamicItems`, () => t.assign((0, Qe._)`${e.evaluated}.items`, (0, Qe._)`undefined`));
}
function zw(e, t) {
  const r = typeof e == "object" && e[t.schemaId];
  return r && (t.code.source || t.code.process) ? (0, Qe._)`/*# sourceURL=${r} */` : Qe.nil;
}
function OU(e, t) {
  if (vP(e) && (bP(e), gP(e))) {
    PU(e, t);
    return;
  }
  (0, mP.boolOrEmptySchema)(e, t);
}
function gP({ schema: e, self: t }) {
  if (typeof e == "boolean")
    return !e;
  for (const r in e)
    if (t.RULES.all[r])
      return !0;
  return !1;
}
function vP(e) {
  return typeof e.schema != "boolean";
}
function PU(e, t) {
  const { schema: r, gen: i, opts: n } = e;
  n.$comment && r.$comment && wP(e), CU(e), RU(e);
  const s = i.const("_errs", lt.default.errors);
  _P(e, s), i.var(t, (0, Qe._)`${s} === ${lt.default.errors}`);
}
function bP(e) {
  (0, Pi.checkUnknownRules)(e), SU(e);
}
function _P(e, t) {
  if (e.opts.jtd)
    return Ww(e, [], !1, t);
  const r = (0, Zw.getSchemaTypes)(e.schema), i = (0, Zw.coerceAndCheckDataType)(e, r);
  Ww(e, r, !i, t);
}
function SU(e) {
  const { schema: t, errSchemaPath: r, opts: i, self: n } = e;
  t.$ref && i.ignoreKeywordsWithRef && (0, Pi.schemaHasRulesButRef)(t, n.RULES) && n.logger.warn(`$ref: keywords ignored in schema at path "${r}"`);
}
function AU(e) {
  const { schema: t, opts: r } = e;
  t.default !== void 0 && r.useDefaults && r.strictSchema && (0, Pi.checkStrictMode)(e, "default is ignored in the schema root");
}
function CU(e) {
  const t = e.schema[e.opts.schemaId];
  t && (e.baseId = (0, bU.resolveUrl)(e.opts.uriResolver, e.baseId, t));
}
function RU(e) {
  if (e.schema.$async && !e.schemaEnv.$async)
    throw new Error("async schema in sync schema");
}
function wP({ gen: e, schemaEnv: t, schema: r, errSchemaPath: i, opts: n }) {
  const s = r.$comment;
  if (n.$comment === !0)
    e.code((0, Qe._)`${lt.default.self}.logger.log(${s})`);
  else if (typeof n.$comment == "function") {
    const a = (0, Qe.str)`${i}/$comment`, u = e.scopeValue("root", { ref: t.root });
    e.code((0, Qe._)`${lt.default.self}.opts.$comment(${s}, ${a}, ${u}.schema)`);
  }
}
function TU(e) {
  const { gen: t, schemaEnv: r, validateName: i, ValidationError: n, opts: s } = e;
  r.$async ? t.if((0, Qe._)`${lt.default.errors} === 0`, () => t.return(lt.default.data), () => t.throw((0, Qe._)`new ${n}(${lt.default.vErrors})`)) : (t.assign((0, Qe._)`${i}.errors`, lt.default.vErrors), s.unevaluated && IU(e), t.return((0, Qe._)`${lt.default.errors} === 0`));
}
function IU({ gen: e, evaluated: t, props: r, items: i }) {
  r instanceof Qe.Name && e.assign((0, Qe._)`${t}.props`, r), i instanceof Qe.Name && e.assign((0, Qe._)`${t}.items`, i);
}
function Ww(e, t, r, i) {
  const { gen: n, schema: s, data: a, allErrors: u, opts: c, self: l } = e, { RULES: d } = l;
  if (s.$ref && (c.ignoreKeywordsWithRef || !(0, Pi.schemaHasRulesButRef)(s, d))) {
    n.block(() => xP(e, "$ref", d.all.$ref.definition));
    return;
  }
  c.jtd || jU(e, t), n.block(() => {
    for (const h of d.rules)
      p(h);
    p(d.post);
  });
  function p(h) {
    (0, Gg.shouldUseGroup)(s, h) && (h.type ? (n.if((0, gf.checkDataType)(h.type, a, c.strictNumbers)), Hw(e, h), t.length === 1 && t[0] === h.type && r && (n.else(), (0, gf.reportTypeError)(e)), n.endIf()) : Hw(e, h), u || n.if((0, Qe._)`${lt.default.errors} === ${i || 0}`));
  }
}
function Hw(e, t) {
  const { gen: r, schema: i, opts: { useDefaults: n } } = e;
  n && (0, vU.assignDefaults)(e, t.type), r.block(() => {
    for (const s of t.rules)
      (0, Gg.shouldUseRule)(i, s) && xP(e, s.keyword, s.definition, t.type);
  });
}
function jU(e, t) {
  e.schemaEnv.meta || !e.opts.strictTypes || (kU(e, t), e.opts.allowUnionTypes || MU(e, t), NU(e, e.dataTypes));
}
function kU(e, t) {
  if (t.length) {
    if (!e.dataTypes.length) {
      e.dataTypes = t;
      return;
    }
    t.forEach((r) => {
      $P(e.dataTypes, r) || Kg(e, `type "${r}" not allowed by context "${e.dataTypes.join(",")}"`);
    }), LU(e, t);
  }
}
function MU(e, t) {
  t.length > 1 && !(t.length === 2 && t.includes("null")) && Kg(e, "use allowUnionTypes to allow union type keyword");
}
function NU(e, t) {
  const r = e.self.RULES.all;
  for (const i in r) {
    const n = r[i];
    if (typeof n == "object" && (0, Gg.shouldUseRule)(e.schema, n)) {
      const { type: s } = n.definition;
      s.length && !s.some((a) => DU(t, a)) && Kg(e, `missing type "${s.join(",")}" for keyword "${i}"`);
    }
  }
}
function DU(e, t) {
  return e.includes(t) || t === "number" && e.includes("integer");
}
function $P(e, t) {
  return e.includes(t) || t === "integer" && e.includes("number");
}
function LU(e, t) {
  const r = [];
  for (const i of e.dataTypes)
    $P(t, i) ? r.push(i) : t.includes("integer") && i === "number" && r.push("integer");
  e.dataTypes = r;
}
function Kg(e, t) {
  const r = e.schemaEnv.baseId + e.errSchemaPath;
  t += ` at "${r}" (strictTypes)`, (0, Pi.checkStrictMode)(e, t, e.opts.strictTypes);
}
class EP {
  constructor(t, r, i) {
    if ((0, hu.validateKeywordUsage)(t, r, i), this.gen = t.gen, this.allErrors = t.allErrors, this.keyword = i, this.data = t.data, this.schema = t.schema[i], this.$data = r.$data && t.opts.$data && this.schema && this.schema.$data, this.schemaValue = (0, Pi.schemaRefOrVal)(t, this.schema, i, this.$data), this.schemaType = r.schemaType, this.parentSchema = t.schema, this.params = {}, this.it = t, this.def = r, this.$data)
      this.schemaCode = t.gen.const("vSchema", OP(this.$data, t));
    else if (this.schemaCode = this.schemaValue, !(0, hu.validSchemaType)(this.schema, r.schemaType, r.allowUndefined))
      throw new Error(`${i} value must be ${JSON.stringify(r.schemaType)}`);
    ("code" in r ? r.trackErrors : r.errors !== !1) && (this.errsCount = t.gen.const("_errs", lt.default.errors));
  }
  result(t, r, i) {
    this.failResult((0, Qe.not)(t), r, i);
  }
  failResult(t, r, i) {
    this.gen.if(t), i ? i() : this.error(), r ? (this.gen.else(), r(), this.allErrors && this.gen.endIf()) : this.allErrors ? this.gen.endIf() : this.gen.else();
  }
  pass(t, r) {
    this.failResult((0, Qe.not)(t), void 0, r);
  }
  fail(t) {
    if (t === void 0) {
      this.error(), this.allErrors || this.gen.if(!1);
      return;
    }
    this.gen.if(t), this.error(), this.allErrors ? this.gen.endIf() : this.gen.else();
  }
  fail$data(t) {
    if (!this.$data)
      return this.fail(t);
    const { schemaCode: r } = this;
    this.fail((0, Qe._)`${r} !== undefined && (${(0, Qe.or)(this.invalid$data(), t)})`);
  }
  error(t, r, i) {
    if (r) {
      this.setParams(r), this._error(t, i), this.setParams({});
      return;
    }
    this._error(t, i);
  }
  _error(t, r) {
    (t ? Xo.reportExtraError : Xo.reportError)(this, this.def.error, r);
  }
  $dataError() {
    (0, Xo.reportError)(this, this.def.$dataError || Xo.keyword$DataError);
  }
  reset() {
    if (this.errsCount === void 0)
      throw new Error('add "trackErrors" to keyword definition');
    (0, Xo.resetErrorsCount)(this.gen, this.errsCount);
  }
  ok(t) {
    this.allErrors || this.gen.if(t);
  }
  setParams(t, r) {
    r ? Object.assign(this.params, t) : this.params = t;
  }
  block$data(t, r, i = Qe.nil) {
    this.gen.block(() => {
      this.check$data(t, i), r();
    });
  }
  check$data(t = Qe.nil, r = Qe.nil) {
    if (!this.$data)
      return;
    const { gen: i, schemaCode: n, schemaType: s, def: a } = this;
    i.if((0, Qe.or)((0, Qe._)`${n} === undefined`, r)), t !== Qe.nil && i.assign(t, !0), (s.length || a.validateSchema) && (i.elseIf(this.invalid$data()), this.$dataError(), t !== Qe.nil && i.assign(t, !1)), i.else();
  }
  invalid$data() {
    const { gen: t, schemaCode: r, schemaType: i, def: n, it: s } = this;
    return (0, Qe.or)(a(), u());
    function a() {
      if (i.length) {
        if (!(r instanceof Qe.Name))
          throw new Error("ajv implementation error");
        const c = Array.isArray(i) ? i : [i];
        return (0, Qe._)`${(0, gf.checkDataTypes)(c, r, s.opts.strictNumbers, gf.DataType.Wrong)}`;
      }
      return Qe.nil;
    }
    function u() {
      if (n.validateSchema) {
        const c = t.scopeValue("validate$data", { ref: n.validateSchema });
        return (0, Qe._)`!${c}(${r})`;
      }
      return Qe.nil;
    }
  }
  subschema(t, r) {
    const i = (0, Gh.getSubschema)(this.it, t);
    (0, Gh.extendSubschemaData)(i, this.it, t), (0, Gh.extendSubschemaMode)(i, t);
    const n = { ...this.it, ...i, items: void 0, props: void 0 };
    return OU(n, r), n;
  }
  mergeEvaluated(t, r) {
    const { it: i, gen: n } = this;
    i.opts.unevaluated && (i.props !== !0 && t.props !== void 0 && (i.props = Pi.mergeEvaluated.props(n, t.props, i.props, r)), i.items !== !0 && t.items !== void 0 && (i.items = Pi.mergeEvaluated.items(n, t.items, i.items, r)));
  }
  mergeValidEvaluated(t, r) {
    const { it: i, gen: n } = this;
    if (i.opts.unevaluated && (i.props !== !0 || i.items !== !0))
      return n.if(r, () => this.mergeEvaluated(t, Qe.Name)), !0;
  }
}
jn.KeywordCxt = EP;
function xP(e, t, r, i) {
  const n = new EP(e, r, t);
  "code" in r ? r.code(n, i) : n.$data && r.validate ? (0, hu.funcKeywordCode)(n, r) : "macro" in r ? (0, hu.macroKeywordCode)(n, r) : (r.compile || r.validate) && (0, hu.funcKeywordCode)(n, r);
}
const qU = /^\/(?:[^~]|~0|~1)*$/, FU = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function OP(e, { dataLevel: t, dataNames: r, dataPathArr: i }) {
  let n, s;
  if (e === "")
    return lt.default.rootData;
  if (e[0] === "/") {
    if (!qU.test(e))
      throw new Error(`Invalid JSON-pointer: ${e}`);
    n = e, s = lt.default.rootData;
  } else {
    const l = FU.exec(e);
    if (!l)
      throw new Error(`Invalid JSON-pointer: ${e}`);
    const d = +l[1];
    if (n = l[2], n === "#") {
      if (d >= t)
        throw new Error(c("property/index", d));
      return i[t - d];
    }
    if (d > t)
      throw new Error(c("data", d));
    if (s = r[t - d], !n)
      return s;
  }
  let a = s;
  const u = n.split("/");
  for (const l of u)
    l && (s = (0, Qe._)`${s}${(0, Qe.getProperty)((0, Pi.unescapeJsonPointer)(l))}`, a = (0, Qe._)`${a} && ${s}`);
  return a;
  function c(l, d) {
    return `Cannot access ${l} ${d} levels up, current level is ${t}`;
  }
}
jn.getData = OP;
var ac = {};
Object.defineProperty(ac, "__esModule", { value: !0 });
class UU extends Error {
  constructor(t) {
    super("validation failed"), this.errors = t, this.ajv = this.validation = !0;
  }
}
ac.default = UU;
var oc = {};
Object.defineProperty(oc, "__esModule", { value: !0 });
const Kh = vr;
class BU extends Error {
  constructor(t, r, i, n) {
    super(n || `can't resolve reference ${i} from id ${r}`), this.missingRef = (0, Kh.resolveUrl)(t, r, i), this.missingSchema = (0, Kh.normalizeId)((0, Kh.getFullPath)(t, this.missingRef));
  }
}
oc.default = BU;
var Nr = {};
Object.defineProperty(Nr, "__esModule", { value: !0 });
Nr.resolveSchema = Nr.getCompilingSchema = Nr.resolveRef = Nr.compileSchema = Nr.SchemaEnv = void 0;
const xn = ht, VU = ac, Ns = nn, Cn = vr, Gw = Pt, ZU = jn;
class Qf {
  constructor(t) {
    var r;
    this.refs = {}, this.dynamicAnchors = {};
    let i;
    typeof t.schema == "object" && (i = t.schema), this.schema = t.schema, this.schemaId = t.schemaId, this.root = t.root || this, this.baseId = (r = t.baseId) !== null && r !== void 0 ? r : (0, Cn.normalizeId)(i == null ? void 0 : i[t.schemaId || "$id"]), this.schemaPath = t.schemaPath, this.localRefs = t.localRefs, this.meta = t.meta, this.$async = i == null ? void 0 : i.$async, this.refs = {};
  }
}
Nr.SchemaEnv = Qf;
function Yg(e) {
  const t = PP.call(this, e);
  if (t)
    return t;
  const r = (0, Cn.getFullPath)(this.opts.uriResolver, e.root.baseId), { es5: i, lines: n } = this.opts.code, { ownProperties: s } = this.opts, a = new xn.CodeGen(this.scope, { es5: i, lines: n, ownProperties: s });
  let u;
  e.$async && (u = a.scopeValue("Error", {
    ref: VU.default,
    code: (0, xn._)`require("ajv/dist/runtime/validation_error").default`
  }));
  const c = a.scopeName("validate");
  e.validateName = c;
  const l = {
    gen: a,
    allErrors: this.opts.allErrors,
    data: Ns.default.data,
    parentData: Ns.default.parentData,
    parentDataProperty: Ns.default.parentDataProperty,
    dataNames: [Ns.default.data],
    dataPathArr: [xn.nil],
    dataLevel: 0,
    dataTypes: [],
    definedProperties: /* @__PURE__ */ new Set(),
    topSchemaRef: a.scopeValue("schema", this.opts.code.source === !0 ? { ref: e.schema, code: (0, xn.stringify)(e.schema) } : { ref: e.schema }),
    validateName: c,
    ValidationError: u,
    schema: e.schema,
    schemaEnv: e,
    rootId: r,
    baseId: e.baseId || r,
    schemaPath: xn.nil,
    errSchemaPath: e.schemaPath || (this.opts.jtd ? "" : "#"),
    errorPath: (0, xn._)`""`,
    opts: this.opts,
    self: this
  };
  let d;
  try {
    this._compilations.add(e), (0, ZU.validateFunctionCode)(l), a.optimize(this.opts.code.optimize);
    const p = a.toString();
    d = `${a.scopeRefs(Ns.default.scope)}return ${p}`, this.opts.code.process && (d = this.opts.code.process(d, e));
    const v = new Function(`${Ns.default.self}`, `${Ns.default.scope}`, d)(this, this.scope.get());
    if (this.scope.value(c, { ref: v }), v.errors = null, v.schema = e.schema, v.schemaEnv = e, e.$async && (v.$async = !0), this.opts.code.source === !0 && (v.source = { validateName: c, validateCode: p, scopeValues: a._values }), this.opts.unevaluated) {
      const { props: y, items: g } = l;
      v.evaluated = {
        props: y instanceof xn.Name ? void 0 : y,
        items: g instanceof xn.Name ? void 0 : g,
        dynamicProps: y instanceof xn.Name,
        dynamicItems: g instanceof xn.Name
      }, v.source && (v.source.evaluated = (0, xn.stringify)(v.evaluated));
    }
    return e.validate = v, e;
  } catch (p) {
    throw delete e.validate, delete e.validateName, d && this.logger.error("Error compiling schema, function code:", d), p;
  } finally {
    this._compilations.delete(e);
  }
}
Nr.compileSchema = Yg;
function zU(e, t, r) {
  var i;
  r = (0, Cn.resolveUrl)(this.opts.uriResolver, t, r);
  const n = e.refs[r];
  if (n)
    return n;
  let s = GU.call(this, e, r);
  if (s === void 0) {
    const a = (i = e.localRefs) === null || i === void 0 ? void 0 : i[r], { schemaId: u } = this.opts;
    a && (s = new Qf({ schema: a, schemaId: u, root: e, baseId: t }));
  }
  if (s !== void 0)
    return e.refs[r] = WU.call(this, s);
}
Nr.resolveRef = zU;
function WU(e) {
  return (0, Cn.inlineRef)(e.schema, this.opts.inlineRefs) ? e.schema : e.validate ? e : Yg.call(this, e);
}
function PP(e) {
  for (const t of this._compilations)
    if (HU(t, e))
      return t;
}
Nr.getCompilingSchema = PP;
function HU(e, t) {
  return e.schema === t.schema && e.root === t.root && e.baseId === t.baseId;
}
function GU(e, t) {
  let r;
  for (; typeof (r = this.refs[t]) == "string"; )
    t = r;
  return r || this.schemas[t] || ed.call(this, e, t);
}
function ed(e, t) {
  const r = this.opts.uriResolver.parse(t), i = (0, Cn._getFullPath)(this.opts.uriResolver, r);
  let n = (0, Cn.getFullPath)(this.opts.uriResolver, e.baseId, void 0);
  if (Object.keys(e.schema).length > 0 && i === n)
    return Yh.call(this, r, e);
  const s = (0, Cn.normalizeId)(i), a = this.refs[s] || this.schemas[s];
  if (typeof a == "string") {
    const u = ed.call(this, e, a);
    return typeof (u == null ? void 0 : u.schema) != "object" ? void 0 : Yh.call(this, r, u);
  }
  if (typeof (a == null ? void 0 : a.schema) == "object") {
    if (a.validate || Yg.call(this, a), s === (0, Cn.normalizeId)(t)) {
      const { schema: u } = a, { schemaId: c } = this.opts, l = u[c];
      return l && (n = (0, Cn.resolveUrl)(this.opts.uriResolver, n, l)), new Qf({ schema: u, schemaId: c, root: e, baseId: n });
    }
    return Yh.call(this, r, a);
  }
}
Nr.resolveSchema = ed;
const KU = /* @__PURE__ */ new Set([
  "properties",
  "patternProperties",
  "enum",
  "dependencies",
  "definitions"
]);
function Yh(e, { baseId: t, schema: r, root: i }) {
  var n;
  if (((n = e.fragment) === null || n === void 0 ? void 0 : n[0]) !== "/")
    return;
  for (const u of e.fragment.slice(1).split("/")) {
    if (typeof r == "boolean")
      return;
    const c = r[(0, Gw.unescapeFragment)(u)];
    if (c === void 0)
      return;
    r = c;
    const l = typeof r == "object" && r[this.opts.schemaId];
    !KU.has(u) && l && (t = (0, Cn.resolveUrl)(this.opts.uriResolver, t, l));
  }
  let s;
  if (typeof r != "boolean" && r.$ref && !(0, Gw.schemaHasRulesButRef)(r, this.RULES)) {
    const u = (0, Cn.resolveUrl)(this.opts.uriResolver, t, r.$ref);
    s = ed.call(this, i, u);
  }
  const { schemaId: a } = this.opts;
  if (s = s || new Qf({ schema: r, schemaId: a, root: i, baseId: t }), s.schema !== s.root.schema)
    return s;
}
const YU = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#", JU = "Meta-schema for $data reference (JSON AnySchema extension proposal)", XU = "object", QU = [
  "$data"
], eB = {
  $data: {
    type: "string",
    anyOf: [
      {
        format: "relative-json-pointer"
      },
      {
        format: "json-pointer"
      }
    ]
  }
}, tB = !1, rB = {
  $id: YU,
  description: JU,
  type: XU,
  required: QU,
  properties: eB,
  additionalProperties: tB
};
var Jg = {}, qy = { exports: {} };
/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
(function(e, t) {
  (function(r, i) {
    i(t);
  })(rt, function(r) {
    function i() {
      for (var se = arguments.length, X = Array(se), ue = 0; ue < se; ue++)
        X[ue] = arguments[ue];
      if (X.length > 1) {
        X[0] = X[0].slice(0, -1);
        for (var ve = X.length - 1, ge = 1; ge < ve; ++ge)
          X[ge] = X[ge].slice(1, -1);
        return X[ve] = X[ve].slice(1), X.join("");
      } else
        return X[0];
    }
    function n(se) {
      return "(?:" + se + ")";
    }
    function s(se) {
      return se === void 0 ? "undefined" : se === null ? "null" : Object.prototype.toString.call(se).split(" ").pop().split("]").shift().toLowerCase();
    }
    function a(se) {
      return se.toUpperCase();
    }
    function u(se) {
      return se != null ? se instanceof Array ? se : typeof se.length != "number" || se.split || se.setInterval || se.call ? [se] : Array.prototype.slice.call(se) : [];
    }
    function c(se, X) {
      var ue = se;
      if (X)
        for (var ve in X)
          ue[ve] = X[ve];
      return ue;
    }
    function l(se) {
      var X = "[A-Za-z]", ue = "[0-9]", ve = i(ue, "[A-Fa-f]"), ge = n(n("%[EFef]" + ve + "%" + ve + ve + "%" + ve + ve) + "|" + n("%[89A-Fa-f]" + ve + "%" + ve + ve) + "|" + n("%" + ve + ve)), Ye = "[\\:\\/\\?\\#\\[\\]\\@]", Xe = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", Et = i(Ye, Xe), Lt = se ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", Wt = se ? "[\\uE000-\\uF8FF]" : "[]", vt = i(X, ue, "[\\-\\.\\_\\~]", Lt);
      n(X + i(X, ue, "[\\+\\-\\.]") + "*"), n(n(ge + "|" + i(vt, Xe, "[\\:]")) + "*");
      var Q = n(n("25[0-5]") + "|" + n("2[0-4]" + ue) + "|" + n("1" + ue + ue) + "|" + n("0?[1-9]" + ue) + "|0?0?" + ue), O = n(Q + "\\." + Q + "\\." + Q + "\\." + Q), j = n(ve + "{1,4}"), W = n(n(j + "\\:" + j) + "|" + O), ne = n(n(j + "\\:") + "{6}" + W), te = n("\\:\\:" + n(j + "\\:") + "{5}" + W), Ie = n(n(j) + "?\\:\\:" + n(j + "\\:") + "{4}" + W), Se = n(n(n(j + "\\:") + "{0,1}" + j) + "?\\:\\:" + n(j + "\\:") + "{3}" + W), Ke = n(n(n(j + "\\:") + "{0,2}" + j) + "?\\:\\:" + n(j + "\\:") + "{2}" + W), Ze = n(n(n(j + "\\:") + "{0,3}" + j) + "?\\:\\:" + j + "\\:" + W), ct = n(n(n(j + "\\:") + "{0,4}" + j) + "?\\:\\:" + W), Ut = n(n(n(j + "\\:") + "{0,5}" + j) + "?\\:\\:" + j), Ur = n(n(n(j + "\\:") + "{0,6}" + j) + "?\\:\\:"), Gr = n([ne, te, Ie, Se, Ke, Ze, ct, Ut, Ur].join("|")), bn = n(n(vt + "|" + ge) + "+");
      n("[vV]" + ve + "+\\." + i(vt, Xe, "[\\:]") + "+"), n(n(ge + "|" + i(vt, Xe)) + "*");
      var Es = n(ge + "|" + i(vt, Xe, "[\\:\\@]"));
      return n(n(ge + "|" + i(vt, Xe, "[\\@]")) + "+"), n(n(Es + "|" + i("[\\/\\?]", Wt)) + "*"), {
        NOT_SCHEME: new RegExp(i("[^]", X, ue, "[\\+\\-\\.]"), "g"),
        NOT_USERINFO: new RegExp(i("[^\\%\\:]", vt, Xe), "g"),
        NOT_HOST: new RegExp(i("[^\\%\\[\\]\\:]", vt, Xe), "g"),
        NOT_PATH: new RegExp(i("[^\\%\\/\\:\\@]", vt, Xe), "g"),
        NOT_PATH_NOSCHEME: new RegExp(i("[^\\%\\/\\@]", vt, Xe), "g"),
        NOT_QUERY: new RegExp(i("[^\\%]", vt, Xe, "[\\:\\@\\/\\?]", Wt), "g"),
        NOT_FRAGMENT: new RegExp(i("[^\\%]", vt, Xe, "[\\:\\@\\/\\?]"), "g"),
        ESCAPE: new RegExp(i("[^]", vt, Xe), "g"),
        UNRESERVED: new RegExp(vt, "g"),
        OTHER_CHARS: new RegExp(i("[^\\%]", vt, Et), "g"),
        PCT_ENCODED: new RegExp(ge, "g"),
        IPV4ADDRESS: new RegExp("^(" + O + ")$"),
        IPV6ADDRESS: new RegExp("^\\[?(" + Gr + ")" + n(n("\\%25|\\%(?!" + ve + "{2})") + "(" + bn + ")") + "?\\]?$")
        //RFC 6874, with relaxed parsing rules
      };
    }
    var d = l(!1), p = l(!0), h = function() {
      function se(X, ue) {
        var ve = [], ge = !0, Ye = !1, Xe = void 0;
        try {
          for (var Et = X[Symbol.iterator](), Lt; !(ge = (Lt = Et.next()).done) && (ve.push(Lt.value), !(ue && ve.length === ue)); ge = !0)
            ;
        } catch (Wt) {
          Ye = !0, Xe = Wt;
        } finally {
          try {
            !ge && Et.return && Et.return();
          } finally {
            if (Ye)
              throw Xe;
          }
        }
        return ve;
      }
      return function(X, ue) {
        if (Array.isArray(X))
          return X;
        if (Symbol.iterator in Object(X))
          return se(X, ue);
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      };
    }(), v = function(se) {
      if (Array.isArray(se)) {
        for (var X = 0, ue = Array(se.length); X < se.length; X++)
          ue[X] = se[X];
        return ue;
      } else
        return Array.from(se);
    }, y = 2147483647, g = 36, _ = 1, m = 26, w = 38, $ = 700, E = 72, A = 128, R = "-", I = /^xn--/, D = /[^\0-\x7E]/, J = /[\x2E\u3002\uFF0E\uFF61]/g, ae = {
      overflow: "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    }, ye = g - _, xe = Math.floor, je = String.fromCharCode;
    function re(se) {
      throw new RangeError(ae[se]);
    }
    function fe(se, X) {
      for (var ue = [], ve = se.length; ve--; )
        ue[ve] = X(se[ve]);
      return ue;
    }
    function le(se, X) {
      var ue = se.split("@"), ve = "";
      ue.length > 1 && (ve = ue[0] + "@", se = ue[1]), se = se.replace(J, ".");
      var ge = se.split("."), Ye = fe(ge, X).join(".");
      return ve + Ye;
    }
    function $e(se) {
      for (var X = [], ue = 0, ve = se.length; ue < ve; ) {
        var ge = se.charCodeAt(ue++);
        if (ge >= 55296 && ge <= 56319 && ue < ve) {
          var Ye = se.charCodeAt(ue++);
          (Ye & 64512) == 56320 ? X.push(((ge & 1023) << 10) + (Ye & 1023) + 65536) : (X.push(ge), ue--);
        } else
          X.push(ge);
      }
      return X;
    }
    var Ae = function(X) {
      return String.fromCodePoint.apply(String, v(X));
    }, _e = function(X) {
      return X - 48 < 10 ? X - 22 : X - 65 < 26 ? X - 65 : X - 97 < 26 ? X - 97 : g;
    }, ie = function(X, ue) {
      return X + 22 + 75 * (X < 26) - ((ue != 0) << 5);
    }, K = function(X, ue, ve) {
      var ge = 0;
      for (
        X = ve ? xe(X / $) : X >> 1, X += xe(X / ue);
        /* no initialization */
        X > ye * m >> 1;
        ge += g
      )
        X = xe(X / ye);
      return xe(ge + (ye + 1) * X / (X + w));
    }, V = function(X) {
      var ue = [], ve = X.length, ge = 0, Ye = A, Xe = E, Et = X.lastIndexOf(R);
      Et < 0 && (Et = 0);
      for (var Lt = 0; Lt < Et; ++Lt)
        X.charCodeAt(Lt) >= 128 && re("not-basic"), ue.push(X.charCodeAt(Lt));
      for (var Wt = Et > 0 ? Et + 1 : 0; Wt < ve; ) {
        for (
          var vt = ge, Q = 1, O = g;
          ;
          /* no condition */
          O += g
        ) {
          Wt >= ve && re("invalid-input");
          var j = _e(X.charCodeAt(Wt++));
          (j >= g || j > xe((y - ge) / Q)) && re("overflow"), ge += j * Q;
          var W = O <= Xe ? _ : O >= Xe + m ? m : O - Xe;
          if (j < W)
            break;
          var ne = g - W;
          Q > xe(y / ne) && re("overflow"), Q *= ne;
        }
        var te = ue.length + 1;
        Xe = K(ge - vt, te, vt == 0), xe(ge / te) > y - Ye && re("overflow"), Ye += xe(ge / te), ge %= te, ue.splice(ge++, 0, Ye);
      }
      return String.fromCodePoint.apply(String, ue);
    }, z = function(X) {
      var ue = [];
      X = $e(X);
      var ve = X.length, ge = A, Ye = 0, Xe = E, Et = !0, Lt = !1, Wt = void 0;
      try {
        for (var vt = X[Symbol.iterator](), Q; !(Et = (Q = vt.next()).done); Et = !0) {
          var O = Q.value;
          O < 128 && ue.push(je(O));
        }
      } catch (Un) {
        Lt = !0, Wt = Un;
      } finally {
        try {
          !Et && vt.return && vt.return();
        } finally {
          if (Lt)
            throw Wt;
        }
      }
      var j = ue.length, W = j;
      for (j && ue.push(R); W < ve; ) {
        var ne = y, te = !0, Ie = !1, Se = void 0;
        try {
          for (var Ke = X[Symbol.iterator](), Ze; !(te = (Ze = Ke.next()).done); te = !0) {
            var ct = Ze.value;
            ct >= ge && ct < ne && (ne = ct);
          }
        } catch (Un) {
          Ie = !0, Se = Un;
        } finally {
          try {
            !te && Ke.return && Ke.return();
          } finally {
            if (Ie)
              throw Se;
          }
        }
        var Ut = W + 1;
        ne - ge > xe((y - Ye) / Ut) && re("overflow"), Ye += (ne - ge) * Ut, ge = ne;
        var Ur = !0, Gr = !1, bn = void 0;
        try {
          for (var Es = X[Symbol.iterator](), dc; !(Ur = (dc = Es.next()).done); Ur = !0) {
            var Ao = dc.value;
            if (Ao < ge && ++Ye > y && re("overflow"), Ao == ge) {
              for (
                var xs = Ye, Os = g;
                ;
                /* no condition */
                Os += g
              ) {
                var Li = Os <= Xe ? _ : Os >= Xe + m ? m : Os - Xe;
                if (xs < Li)
                  break;
                var pc = xs - Li, Co = g - Li;
                ue.push(je(ie(Li + pc % Co, 0))), xs = xe(pc / Co);
              }
              ue.push(je(ie(xs, 0))), Xe = K(Ye, Ut, W == j), Ye = 0, ++W;
            }
          }
        } catch (Un) {
          Gr = !0, bn = Un;
        } finally {
          try {
            !Ur && Es.return && Es.return();
          } finally {
            if (Gr)
              throw bn;
          }
        }
        ++Ye, ++ge;
      }
      return ue.join("");
    }, C = function(X) {
      return le(X, function(ue) {
        return I.test(ue) ? V(ue.slice(4).toLowerCase()) : ue;
      });
    }, q = function(X) {
      return le(X, function(ue) {
        return D.test(ue) ? "xn--" + z(ue) : ue;
      });
    }, N = {
      /**
       * A string representing the current Punycode.js version number.
       * @memberOf punycode
       * @type String
       */
      version: "2.1.0",
      /**
       * An object of methods to convert from JavaScript's internal character
       * representation (UCS-2) to Unicode code points, and back.
       * @see <https://mathiasbynens.be/notes/javascript-encoding>
       * @memberOf punycode
       * @type Object
       */
      ucs2: {
        decode: $e,
        encode: Ae
      },
      decode: V,
      encode: z,
      toASCII: q,
      toUnicode: C
    }, F = {};
    function T(se) {
      var X = se.charCodeAt(0), ue = void 0;
      return X < 16 ? ue = "%0" + X.toString(16).toUpperCase() : X < 128 ? ue = "%" + X.toString(16).toUpperCase() : X < 2048 ? ue = "%" + (X >> 6 | 192).toString(16).toUpperCase() + "%" + (X & 63 | 128).toString(16).toUpperCase() : ue = "%" + (X >> 12 | 224).toString(16).toUpperCase() + "%" + (X >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (X & 63 | 128).toString(16).toUpperCase(), ue;
    }
    function Z(se) {
      for (var X = "", ue = 0, ve = se.length; ue < ve; ) {
        var ge = parseInt(se.substr(ue + 1, 2), 16);
        if (ge < 128)
          X += String.fromCharCode(ge), ue += 3;
        else if (ge >= 194 && ge < 224) {
          if (ve - ue >= 6) {
            var Ye = parseInt(se.substr(ue + 4, 2), 16);
            X += String.fromCharCode((ge & 31) << 6 | Ye & 63);
          } else
            X += se.substr(ue, 6);
          ue += 6;
        } else if (ge >= 224) {
          if (ve - ue >= 9) {
            var Xe = parseInt(se.substr(ue + 4, 2), 16), Et = parseInt(se.substr(ue + 7, 2), 16);
            X += String.fromCharCode((ge & 15) << 12 | (Xe & 63) << 6 | Et & 63);
          } else
            X += se.substr(ue, 9);
          ue += 9;
        } else
          X += se.substr(ue, 3), ue += 3;
      }
      return X;
    }
    function Y(se, X) {
      function ue(ve) {
        var ge = Z(ve);
        return ge.match(X.UNRESERVED) ? ge : ve;
      }
      return se.scheme && (se.scheme = String(se.scheme).replace(X.PCT_ENCODED, ue).toLowerCase().replace(X.NOT_SCHEME, "")), se.userinfo !== void 0 && (se.userinfo = String(se.userinfo).replace(X.PCT_ENCODED, ue).replace(X.NOT_USERINFO, T).replace(X.PCT_ENCODED, a)), se.host !== void 0 && (se.host = String(se.host).replace(X.PCT_ENCODED, ue).toLowerCase().replace(X.NOT_HOST, T).replace(X.PCT_ENCODED, a)), se.path !== void 0 && (se.path = String(se.path).replace(X.PCT_ENCODED, ue).replace(se.scheme ? X.NOT_PATH : X.NOT_PATH_NOSCHEME, T).replace(X.PCT_ENCODED, a)), se.query !== void 0 && (se.query = String(se.query).replace(X.PCT_ENCODED, ue).replace(X.NOT_QUERY, T).replace(X.PCT_ENCODED, a)), se.fragment !== void 0 && (se.fragment = String(se.fragment).replace(X.PCT_ENCODED, ue).replace(X.NOT_FRAGMENT, T).replace(X.PCT_ENCODED, a)), se;
    }
    function k(se) {
      return se.replace(/^0*(.*)/, "$1") || "0";
    }
    function U(se, X) {
      var ue = se.match(X.IPV4ADDRESS) || [], ve = h(ue, 2), ge = ve[1];
      return ge ? ge.split(".").map(k).join(".") : se;
    }
    function pe(se, X) {
      var ue = se.match(X.IPV6ADDRESS) || [], ve = h(ue, 3), ge = ve[1], Ye = ve[2];
      if (ge) {
        for (var Xe = ge.toLowerCase().split("::").reverse(), Et = h(Xe, 2), Lt = Et[0], Wt = Et[1], vt = Wt ? Wt.split(":").map(k) : [], Q = Lt.split(":").map(k), O = X.IPV4ADDRESS.test(Q[Q.length - 1]), j = O ? 7 : 8, W = Q.length - j, ne = Array(j), te = 0; te < j; ++te)
          ne[te] = vt[te] || Q[W + te] || "";
        O && (ne[j - 1] = U(ne[j - 1], X));
        var Ie = ne.reduce(function(Ut, Ur, Gr) {
          if (!Ur || Ur === "0") {
            var bn = Ut[Ut.length - 1];
            bn && bn.index + bn.length === Gr ? bn.length++ : Ut.push({ index: Gr, length: 1 });
          }
          return Ut;
        }, []), Se = Ie.sort(function(Ut, Ur) {
          return Ur.length - Ut.length;
        })[0], Ke = void 0;
        if (Se && Se.length > 1) {
          var Ze = ne.slice(0, Se.index), ct = ne.slice(Se.index + Se.length);
          Ke = Ze.join(":") + "::" + ct.join(":");
        } else
          Ke = ne.join(":");
        return Ye && (Ke += "%" + Ye), Ke;
      } else
        return se;
    }
    var we = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i, He = "".match(/(){0}/)[1] === void 0;
    function Fe(se) {
      var X = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, ue = {}, ve = X.iri !== !1 ? p : d;
      X.reference === "suffix" && (se = (X.scheme ? X.scheme + ":" : "") + "//" + se);
      var ge = se.match(we);
      if (ge) {
        He ? (ue.scheme = ge[1], ue.userinfo = ge[3], ue.host = ge[4], ue.port = parseInt(ge[5], 10), ue.path = ge[6] || "", ue.query = ge[7], ue.fragment = ge[8], isNaN(ue.port) && (ue.port = ge[5])) : (ue.scheme = ge[1] || void 0, ue.userinfo = se.indexOf("@") !== -1 ? ge[3] : void 0, ue.host = se.indexOf("//") !== -1 ? ge[4] : void 0, ue.port = parseInt(ge[5], 10), ue.path = ge[6] || "", ue.query = se.indexOf("?") !== -1 ? ge[7] : void 0, ue.fragment = se.indexOf("#") !== -1 ? ge[8] : void 0, isNaN(ue.port) && (ue.port = se.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? ge[4] : void 0)), ue.host && (ue.host = pe(U(ue.host, ve), ve)), ue.scheme === void 0 && ue.userinfo === void 0 && ue.host === void 0 && ue.port === void 0 && !ue.path && ue.query === void 0 ? ue.reference = "same-document" : ue.scheme === void 0 ? ue.reference = "relative" : ue.fragment === void 0 ? ue.reference = "absolute" : ue.reference = "uri", X.reference && X.reference !== "suffix" && X.reference !== ue.reference && (ue.error = ue.error || "URI is not a " + X.reference + " reference.");
        var Ye = F[(X.scheme || ue.scheme || "").toLowerCase()];
        if (!X.unicodeSupport && (!Ye || !Ye.unicodeSupport)) {
          if (ue.host && (X.domainHost || Ye && Ye.domainHost))
            try {
              ue.host = N.toASCII(ue.host.replace(ve.PCT_ENCODED, Z).toLowerCase());
            } catch (Xe) {
              ue.error = ue.error || "Host's domain name can not be converted to ASCII via punycode: " + Xe;
            }
          Y(ue, d);
        } else
          Y(ue, ve);
        Ye && Ye.parse && Ye.parse(ue, X);
      } else
        ue.error = ue.error || "URI can not be parsed.";
      return ue;
    }
    function Ge(se, X) {
      var ue = X.iri !== !1 ? p : d, ve = [];
      return se.userinfo !== void 0 && (ve.push(se.userinfo), ve.push("@")), se.host !== void 0 && ve.push(pe(U(String(se.host), ue), ue).replace(ue.IPV6ADDRESS, function(ge, Ye, Xe) {
        return "[" + Ye + (Xe ? "%25" + Xe : "") + "]";
      })), (typeof se.port == "number" || typeof se.port == "string") && (ve.push(":"), ve.push(String(se.port))), ve.length ? ve.join("") : void 0;
    }
    var jt = /^\.\.?\//, Ee = /^\/\.(\/|$)/, Mt = /^\/\.\.(\/|$)/, St = /^\/?(?:.|\n)*?(?=\/|$)/;
    function Ne(se) {
      for (var X = []; se.length; )
        if (se.match(jt))
          se = se.replace(jt, "");
        else if (se.match(Ee))
          se = se.replace(Ee, "/");
        else if (se.match(Mt))
          se = se.replace(Mt, "/"), X.pop();
        else if (se === "." || se === "..")
          se = "";
        else {
          var ue = se.match(St);
          if (ue) {
            var ve = ue[0];
            se = se.slice(ve.length), X.push(ve);
          } else
            throw new Error("Unexpected dot segment condition");
        }
      return X.join("");
    }
    function Le(se) {
      var X = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, ue = X.iri ? p : d, ve = [], ge = F[(X.scheme || se.scheme || "").toLowerCase()];
      if (ge && ge.serialize && ge.serialize(se, X), se.host && !ue.IPV6ADDRESS.test(se.host)) {
        if (X.domainHost || ge && ge.domainHost)
          try {
            se.host = X.iri ? N.toUnicode(se.host) : N.toASCII(se.host.replace(ue.PCT_ENCODED, Z).toLowerCase());
          } catch (Et) {
            se.error = se.error || "Host's domain name can not be converted to " + (X.iri ? "Unicode" : "ASCII") + " via punycode: " + Et;
          }
      }
      Y(se, ue), X.reference !== "suffix" && se.scheme && (ve.push(se.scheme), ve.push(":"));
      var Ye = Ge(se, X);
      if (Ye !== void 0 && (X.reference !== "suffix" && ve.push("//"), ve.push(Ye), se.path && se.path.charAt(0) !== "/" && ve.push("/")), se.path !== void 0) {
        var Xe = se.path;
        !X.absolutePath && (!ge || !ge.absolutePath) && (Xe = Ne(Xe)), Ye === void 0 && (Xe = Xe.replace(/^\/\//, "/%2F")), ve.push(Xe);
      }
      return se.query !== void 0 && (ve.push("?"), ve.push(se.query)), se.fragment !== void 0 && (ve.push("#"), ve.push(se.fragment)), ve.join("");
    }
    function at(se, X) {
      var ue = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, ve = arguments[3], ge = {};
      return ve || (se = Fe(Le(se, ue), ue), X = Fe(Le(X, ue), ue)), ue = ue || {}, !ue.tolerant && X.scheme ? (ge.scheme = X.scheme, ge.userinfo = X.userinfo, ge.host = X.host, ge.port = X.port, ge.path = Ne(X.path || ""), ge.query = X.query) : (X.userinfo !== void 0 || X.host !== void 0 || X.port !== void 0 ? (ge.userinfo = X.userinfo, ge.host = X.host, ge.port = X.port, ge.path = Ne(X.path || ""), ge.query = X.query) : (X.path ? (X.path.charAt(0) === "/" ? ge.path = Ne(X.path) : ((se.userinfo !== void 0 || se.host !== void 0 || se.port !== void 0) && !se.path ? ge.path = "/" + X.path : se.path ? ge.path = se.path.slice(0, se.path.lastIndexOf("/") + 1) + X.path : ge.path = X.path, ge.path = Ne(ge.path)), ge.query = X.query) : (ge.path = se.path, X.query !== void 0 ? ge.query = X.query : ge.query = se.query), ge.userinfo = se.userinfo, ge.host = se.host, ge.port = se.port), ge.scheme = se.scheme), ge.fragment = X.fragment, ge;
    }
    function mt(se, X, ue) {
      var ve = c({ scheme: "null" }, ue);
      return Le(at(Fe(se, ve), Fe(X, ve), ve, !0), ve);
    }
    function qe(se, X) {
      return typeof se == "string" ? se = Le(Fe(se, X), X) : s(se) === "object" && (se = Fe(Le(se, X), X)), se;
    }
    function L(se, X, ue) {
      return typeof se == "string" ? se = Le(Fe(se, ue), ue) : s(se) === "object" && (se = Le(se, ue)), typeof X == "string" ? X = Le(Fe(X, ue), ue) : s(X) === "object" && (X = Le(X, ue)), se === X;
    }
    function x(se, X) {
      return se && se.toString().replace(!X || !X.iri ? d.ESCAPE : p.ESCAPE, T);
    }
    function S(se, X) {
      return se && se.toString().replace(!X || !X.iri ? d.PCT_ENCODED : p.PCT_ENCODED, Z);
    }
    var G = {
      scheme: "http",
      domainHost: !0,
      parse: function(X, ue) {
        return X.host || (X.error = X.error || "HTTP URIs must have a host."), X;
      },
      serialize: function(X, ue) {
        var ve = String(X.scheme).toLowerCase() === "https";
        return (X.port === (ve ? 443 : 80) || X.port === "") && (X.port = void 0), X.path || (X.path = "/"), X;
      }
    }, ce = {
      scheme: "https",
      domainHost: G.domainHost,
      parse: G.parse,
      serialize: G.serialize
    };
    function me(se) {
      return typeof se.secure == "boolean" ? se.secure : String(se.scheme).toLowerCase() === "wss";
    }
    var Oe = {
      scheme: "ws",
      domainHost: !0,
      parse: function(X, ue) {
        var ve = X;
        return ve.secure = me(ve), ve.resourceName = (ve.path || "/") + (ve.query ? "?" + ve.query : ""), ve.path = void 0, ve.query = void 0, ve;
      },
      serialize: function(X, ue) {
        if ((X.port === (me(X) ? 443 : 80) || X.port === "") && (X.port = void 0), typeof X.secure == "boolean" && (X.scheme = X.secure ? "wss" : "ws", X.secure = void 0), X.resourceName) {
          var ve = X.resourceName.split("?"), ge = h(ve, 2), Ye = ge[0], Xe = ge[1];
          X.path = Ye && Ye !== "/" ? Ye : void 0, X.query = Xe, X.resourceName = void 0;
        }
        return X.fragment = void 0, X;
      }
    }, ut = {
      scheme: "wss",
      domainHost: Oe.domainHost,
      parse: Oe.parse,
      serialize: Oe.serialize
    }, Dt = {}, Tt = "[A-Za-z0-9\\-\\.\\_\\~\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]", wt = "[0-9A-Fa-f]", It = n(n("%[EFef]" + wt + "%" + wt + wt + "%" + wt + wt) + "|" + n("%[89A-Fa-f]" + wt + "%" + wt + wt) + "|" + n("%" + wt + wt)), $o = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]", Eo = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]", ua = i(Eo, '[\\"\\\\]'), ca = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]", xo = new RegExp(Tt, "g"), Fn = new RegExp(It, "g"), Oo = new RegExp(i("[^]", $o, "[\\.]", '[\\"]', ua), "g"), la = new RegExp(i("[^]", Tt, ca), "g"), fa = la;
    function $s(se) {
      var X = Z(se);
      return X.match(xo) ? X : se;
    }
    var da = {
      scheme: "mailto",
      parse: function(X, ue) {
        var ve = X, ge = ve.to = ve.path ? ve.path.split(",") : [];
        if (ve.path = void 0, ve.query) {
          for (var Ye = !1, Xe = {}, Et = ve.query.split("&"), Lt = 0, Wt = Et.length; Lt < Wt; ++Lt) {
            var vt = Et[Lt].split("=");
            switch (vt[0]) {
              case "to":
                for (var Q = vt[1].split(","), O = 0, j = Q.length; O < j; ++O)
                  ge.push(Q[O]);
                break;
              case "subject":
                ve.subject = S(vt[1], ue);
                break;
              case "body":
                ve.body = S(vt[1], ue);
                break;
              default:
                Ye = !0, Xe[S(vt[0], ue)] = S(vt[1], ue);
                break;
            }
          }
          Ye && (ve.headers = Xe);
        }
        ve.query = void 0;
        for (var W = 0, ne = ge.length; W < ne; ++W) {
          var te = ge[W].split("@");
          if (te[0] = S(te[0]), ue.unicodeSupport)
            te[1] = S(te[1], ue).toLowerCase();
          else
            try {
              te[1] = N.toASCII(S(te[1], ue).toLowerCase());
            } catch (Ie) {
              ve.error = ve.error || "Email address's domain name can not be converted to ASCII via punycode: " + Ie;
            }
          ge[W] = te.join("@");
        }
        return ve;
      },
      serialize: function(X, ue) {
        var ve = X, ge = u(X.to);
        if (ge) {
          for (var Ye = 0, Xe = ge.length; Ye < Xe; ++Ye) {
            var Et = String(ge[Ye]), Lt = Et.lastIndexOf("@"), Wt = Et.slice(0, Lt).replace(Fn, $s).replace(Fn, a).replace(Oo, T), vt = Et.slice(Lt + 1);
            try {
              vt = ue.iri ? N.toUnicode(vt) : N.toASCII(S(vt, ue).toLowerCase());
            } catch (W) {
              ve.error = ve.error || "Email address's domain name can not be converted to " + (ue.iri ? "Unicode" : "ASCII") + " via punycode: " + W;
            }
            ge[Ye] = Wt + "@" + vt;
          }
          ve.path = ge.join(",");
        }
        var Q = X.headers = X.headers || {};
        X.subject && (Q.subject = X.subject), X.body && (Q.body = X.body);
        var O = [];
        for (var j in Q)
          Q[j] !== Dt[j] && O.push(j.replace(Fn, $s).replace(Fn, a).replace(la, T) + "=" + Q[j].replace(Fn, $s).replace(Fn, a).replace(fa, T));
        return O.length && (ve.query = O.join("&")), ve;
      }
    }, Po = /^([^\:]+)\:(.*)/, Ni = {
      scheme: "urn",
      parse: function(X, ue) {
        var ve = X.path && X.path.match(Po), ge = X;
        if (ve) {
          var Ye = ue.scheme || ge.scheme || "urn", Xe = ve[1].toLowerCase(), Et = ve[2], Lt = Ye + ":" + (ue.nid || Xe), Wt = F[Lt];
          ge.nid = Xe, ge.nss = Et, ge.path = void 0, Wt && (ge = Wt.parse(ge, ue));
        } else
          ge.error = ge.error || "URN can not be parsed.";
        return ge;
      },
      serialize: function(X, ue) {
        var ve = ue.scheme || X.scheme || "urn", ge = X.nid, Ye = ve + ":" + (ue.nid || ge), Xe = F[Ye];
        Xe && (X = Xe.serialize(X, ue));
        var Et = X, Lt = X.nss;
        return Et.path = (ge || ue.nid) + ":" + Lt, Et;
      }
    }, So = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/, Di = {
      scheme: "urn:uuid",
      parse: function(X, ue) {
        var ve = X;
        return ve.uuid = ve.nss, ve.nss = void 0, !ue.tolerant && (!ve.uuid || !ve.uuid.match(So)) && (ve.error = ve.error || "UUID is not valid."), ve;
      },
      serialize: function(X, ue) {
        var ve = X;
        return ve.nss = (X.uuid || "").toLowerCase(), ve;
      }
    };
    F[G.scheme] = G, F[ce.scheme] = ce, F[Oe.scheme] = Oe, F[ut.scheme] = ut, F[da.scheme] = da, F[Ni.scheme] = Ni, F[Di.scheme] = Di, r.SCHEMES = F, r.pctEncChar = T, r.pctDecChars = Z, r.parse = Fe, r.removeDotSegments = Ne, r.serialize = Le, r.resolveComponents = at, r.resolve = mt, r.normalize = qe, r.equal = L, r.escapeComponent = x, r.unescapeComponent = S, Object.defineProperty(r, "__esModule", { value: !0 });
  });
})(qy, qy.exports);
var nB = qy.exports;
Object.defineProperty(Jg, "__esModule", { value: !0 });
const SP = nB;
SP.code = 'require("ajv/dist/runtime/uri").default';
Jg.default = SP;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CodeGen = e.Name = e.nil = e.stringify = e.str = e._ = e.KeywordCxt = void 0;
  var t = jn;
  Object.defineProperty(e, "KeywordCxt", { enumerable: !0, get: function() {
    return t.KeywordCxt;
  } });
  var r = ht;
  Object.defineProperty(e, "_", { enumerable: !0, get: function() {
    return r._;
  } }), Object.defineProperty(e, "str", { enumerable: !0, get: function() {
    return r.str;
  } }), Object.defineProperty(e, "stringify", { enumerable: !0, get: function() {
    return r.stringify;
  } }), Object.defineProperty(e, "nil", { enumerable: !0, get: function() {
    return r.nil;
  } }), Object.defineProperty(e, "Name", { enumerable: !0, get: function() {
    return r.Name;
  } }), Object.defineProperty(e, "CodeGen", { enumerable: !0, get: function() {
    return r.CodeGen;
  } });
  const i = ac, n = oc, s = ea, a = Nr, u = ht, c = vr, l = sc, d = Pt, p = rB, h = Jg, v = (ie, K) => new RegExp(ie, K);
  v.code = "new RegExp";
  const y = ["removeAdditional", "useDefaults", "coerceTypes"], g = /* @__PURE__ */ new Set([
    "validate",
    "serialize",
    "parse",
    "wrapper",
    "root",
    "schema",
    "keyword",
    "pattern",
    "formats",
    "validate$data",
    "func",
    "obj",
    "Error"
  ]), _ = {
    errorDataPath: "",
    format: "`validateFormats: false` can be used instead.",
    nullable: '"nullable" keyword is supported by default.',
    jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
    extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
    missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
    processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
    sourceCode: "Use option `code: {source: true}`",
    strictDefaults: "It is default now, see option `strict`.",
    strictKeywords: "It is default now, see option `strict`.",
    uniqueItems: '"uniqueItems" keyword is always validated.',
    unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
    cache: "Map is used as cache, schema object as key.",
    serialize: "Map is used as cache, schema object as key.",
    ajvErrors: "It is default now."
  }, m = {
    ignoreKeywordsWithRef: "",
    jsPropertySyntax: "",
    unicode: '"minLength"/"maxLength" account for unicode characters by default.'
  }, w = 200;
  function $(ie) {
    var K, V, z, C, q, N, F, T, Z, Y, k, U, pe, we, He, Fe, Ge, jt, Ee, Mt, St, Ne, Le, at, mt;
    const qe = ie.strict, L = (K = ie.code) === null || K === void 0 ? void 0 : K.optimize, x = L === !0 || L === void 0 ? 1 : L || 0, S = (z = (V = ie.code) === null || V === void 0 ? void 0 : V.regExp) !== null && z !== void 0 ? z : v, G = (C = ie.uriResolver) !== null && C !== void 0 ? C : h.default;
    return {
      strictSchema: (N = (q = ie.strictSchema) !== null && q !== void 0 ? q : qe) !== null && N !== void 0 ? N : !0,
      strictNumbers: (T = (F = ie.strictNumbers) !== null && F !== void 0 ? F : qe) !== null && T !== void 0 ? T : !0,
      strictTypes: (Y = (Z = ie.strictTypes) !== null && Z !== void 0 ? Z : qe) !== null && Y !== void 0 ? Y : "log",
      strictTuples: (U = (k = ie.strictTuples) !== null && k !== void 0 ? k : qe) !== null && U !== void 0 ? U : "log",
      strictRequired: (we = (pe = ie.strictRequired) !== null && pe !== void 0 ? pe : qe) !== null && we !== void 0 ? we : !1,
      code: ie.code ? { ...ie.code, optimize: x, regExp: S } : { optimize: x, regExp: S },
      loopRequired: (He = ie.loopRequired) !== null && He !== void 0 ? He : w,
      loopEnum: (Fe = ie.loopEnum) !== null && Fe !== void 0 ? Fe : w,
      meta: (Ge = ie.meta) !== null && Ge !== void 0 ? Ge : !0,
      messages: (jt = ie.messages) !== null && jt !== void 0 ? jt : !0,
      inlineRefs: (Ee = ie.inlineRefs) !== null && Ee !== void 0 ? Ee : !0,
      schemaId: (Mt = ie.schemaId) !== null && Mt !== void 0 ? Mt : "$id",
      addUsedSchema: (St = ie.addUsedSchema) !== null && St !== void 0 ? St : !0,
      validateSchema: (Ne = ie.validateSchema) !== null && Ne !== void 0 ? Ne : !0,
      validateFormats: (Le = ie.validateFormats) !== null && Le !== void 0 ? Le : !0,
      unicodeRegExp: (at = ie.unicodeRegExp) !== null && at !== void 0 ? at : !0,
      int32range: (mt = ie.int32range) !== null && mt !== void 0 ? mt : !0,
      uriResolver: G
    };
  }
  class E {
    constructor(K = {}) {
      this.schemas = {}, this.refs = {}, this.formats = {}, this._compilations = /* @__PURE__ */ new Set(), this._loading = {}, this._cache = /* @__PURE__ */ new Map(), K = this.opts = { ...K, ...$(K) };
      const { es5: V, lines: z } = this.opts.code;
      this.scope = new u.ValueScope({ scope: {}, prefixes: g, es5: V, lines: z }), this.logger = xe(K.logger);
      const C = K.validateFormats;
      K.validateFormats = !1, this.RULES = (0, s.getRules)(), A.call(this, _, K, "NOT SUPPORTED"), A.call(this, m, K, "DEPRECATED", "warn"), this._metaOpts = ae.call(this), K.formats && D.call(this), this._addVocabularies(), this._addDefaultMetaSchema(), K.keywords && J.call(this, K.keywords), typeof K.meta == "object" && this.addMetaSchema(K.meta), I.call(this), K.validateFormats = C;
    }
    _addVocabularies() {
      this.addKeyword("$async");
    }
    _addDefaultMetaSchema() {
      const { $data: K, meta: V, schemaId: z } = this.opts;
      let C = p;
      z === "id" && (C = { ...p }, C.id = C.$id, delete C.$id), V && K && this.addMetaSchema(C, C[z], !1);
    }
    defaultMeta() {
      const { meta: K, schemaId: V } = this.opts;
      return this.opts.defaultMeta = typeof K == "object" ? K[V] || K : void 0;
    }
    validate(K, V) {
      let z;
      if (typeof K == "string") {
        if (z = this.getSchema(K), !z)
          throw new Error(`no schema with key or ref "${K}"`);
      } else
        z = this.compile(K);
      const C = z(V);
      return "$async" in z || (this.errors = z.errors), C;
    }
    compile(K, V) {
      const z = this._addSchema(K, V);
      return z.validate || this._compileSchemaEnv(z);
    }
    compileAsync(K, V) {
      if (typeof this.opts.loadSchema != "function")
        throw new Error("options.loadSchema should be a function");
      const { loadSchema: z } = this.opts;
      return C.call(this, K, V);
      async function C(Y, k) {
        await q.call(this, Y.$schema);
        const U = this._addSchema(Y, k);
        return U.validate || N.call(this, U);
      }
      async function q(Y) {
        Y && !this.getSchema(Y) && await C.call(this, { $ref: Y }, !0);
      }
      async function N(Y) {
        try {
          return this._compileSchemaEnv(Y);
        } catch (k) {
          if (!(k instanceof n.default))
            throw k;
          return F.call(this, k), await T.call(this, k.missingSchema), N.call(this, Y);
        }
      }
      function F({ missingSchema: Y, missingRef: k }) {
        if (this.refs[Y])
          throw new Error(`AnySchema ${Y} is loaded but ${k} cannot be resolved`);
      }
      async function T(Y) {
        const k = await Z.call(this, Y);
        this.refs[Y] || await q.call(this, k.$schema), this.refs[Y] || this.addSchema(k, Y, V);
      }
      async function Z(Y) {
        const k = this._loading[Y];
        if (k)
          return k;
        try {
          return await (this._loading[Y] = z(Y));
        } finally {
          delete this._loading[Y];
        }
      }
    }
    // Adds schema to the instance
    addSchema(K, V, z, C = this.opts.validateSchema) {
      if (Array.isArray(K)) {
        for (const N of K)
          this.addSchema(N, void 0, z, C);
        return this;
      }
      let q;
      if (typeof K == "object") {
        const { schemaId: N } = this.opts;
        if (q = K[N], q !== void 0 && typeof q != "string")
          throw new Error(`schema ${N} must be string`);
      }
      return V = (0, c.normalizeId)(V || q), this._checkUnique(V), this.schemas[V] = this._addSchema(K, z, V, C, !0), this;
    }
    // Add schema that will be used to validate other schemas
    // options in META_IGNORE_OPTIONS are alway set to false
    addMetaSchema(K, V, z = this.opts.validateSchema) {
      return this.addSchema(K, V, !0, z), this;
    }
    //  Validate schema against its meta-schema
    validateSchema(K, V) {
      if (typeof K == "boolean")
        return !0;
      let z;
      if (z = K.$schema, z !== void 0 && typeof z != "string")
        throw new Error("$schema must be a string");
      if (z = z || this.opts.defaultMeta || this.defaultMeta(), !z)
        return this.logger.warn("meta-schema not available"), this.errors = null, !0;
      const C = this.validate(z, K);
      if (!C && V) {
        const q = "schema is invalid: " + this.errorsText();
        if (this.opts.validateSchema === "log")
          this.logger.error(q);
        else
          throw new Error(q);
      }
      return C;
    }
    // Get compiled schema by `key` or `ref`.
    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
    getSchema(K) {
      let V;
      for (; typeof (V = R.call(this, K)) == "string"; )
        K = V;
      if (V === void 0) {
        const { schemaId: z } = this.opts, C = new a.SchemaEnv({ schema: {}, schemaId: z });
        if (V = a.resolveSchema.call(this, C, K), !V)
          return;
        this.refs[K] = V;
      }
      return V.validate || this._compileSchemaEnv(V);
    }
    // Remove cached schema(s).
    // If no parameter is passed all schemas but meta-schemas are removed.
    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
    removeSchema(K) {
      if (K instanceof RegExp)
        return this._removeAllSchemas(this.schemas, K), this._removeAllSchemas(this.refs, K), this;
      switch (typeof K) {
        case "undefined":
          return this._removeAllSchemas(this.schemas), this._removeAllSchemas(this.refs), this._cache.clear(), this;
        case "string": {
          const V = R.call(this, K);
          return typeof V == "object" && this._cache.delete(V.schema), delete this.schemas[K], delete this.refs[K], this;
        }
        case "object": {
          const V = K;
          this._cache.delete(V);
          let z = K[this.opts.schemaId];
          return z && (z = (0, c.normalizeId)(z), delete this.schemas[z], delete this.refs[z]), this;
        }
        default:
          throw new Error("ajv.removeSchema: invalid parameter");
      }
    }
    // add "vocabulary" - a collection of keywords
    addVocabulary(K) {
      for (const V of K)
        this.addKeyword(V);
      return this;
    }
    addKeyword(K, V) {
      let z;
      if (typeof K == "string")
        z = K, typeof V == "object" && (this.logger.warn("these parameters are deprecated, see docs for addKeyword"), V.keyword = z);
      else if (typeof K == "object" && V === void 0) {
        if (V = K, z = V.keyword, Array.isArray(z) && !z.length)
          throw new Error("addKeywords: keyword must be string or non-empty array");
      } else
        throw new Error("invalid addKeywords parameters");
      if (re.call(this, z, V), !V)
        return (0, d.eachItem)(z, (q) => fe.call(this, q)), this;
      $e.call(this, V);
      const C = {
        ...V,
        type: (0, l.getJSONTypes)(V.type),
        schemaType: (0, l.getJSONTypes)(V.schemaType)
      };
      return (0, d.eachItem)(z, C.type.length === 0 ? (q) => fe.call(this, q, C) : (q) => C.type.forEach((N) => fe.call(this, q, C, N))), this;
    }
    getKeyword(K) {
      const V = this.RULES.all[K];
      return typeof V == "object" ? V.definition : !!V;
    }
    // Remove keyword
    removeKeyword(K) {
      const { RULES: V } = this;
      delete V.keywords[K], delete V.all[K];
      for (const z of V.rules) {
        const C = z.rules.findIndex((q) => q.keyword === K);
        C >= 0 && z.rules.splice(C, 1);
      }
      return this;
    }
    // Add format
    addFormat(K, V) {
      return typeof V == "string" && (V = new RegExp(V)), this.formats[K] = V, this;
    }
    errorsText(K = this.errors, { separator: V = ", ", dataVar: z = "data" } = {}) {
      return !K || K.length === 0 ? "No errors" : K.map((C) => `${z}${C.instancePath} ${C.message}`).reduce((C, q) => C + V + q);
    }
    $dataMetaSchema(K, V) {
      const z = this.RULES.all;
      K = JSON.parse(JSON.stringify(K));
      for (const C of V) {
        const q = C.split("/").slice(1);
        let N = K;
        for (const F of q)
          N = N[F];
        for (const F in z) {
          const T = z[F];
          if (typeof T != "object")
            continue;
          const { $data: Z } = T.definition, Y = N[F];
          Z && Y && (N[F] = _e(Y));
        }
      }
      return K;
    }
    _removeAllSchemas(K, V) {
      for (const z in K) {
        const C = K[z];
        (!V || V.test(z)) && (typeof C == "string" ? delete K[z] : C && !C.meta && (this._cache.delete(C.schema), delete K[z]));
      }
    }
    _addSchema(K, V, z, C = this.opts.validateSchema, q = this.opts.addUsedSchema) {
      let N;
      const { schemaId: F } = this.opts;
      if (typeof K == "object")
        N = K[F];
      else {
        if (this.opts.jtd)
          throw new Error("schema must be object");
        if (typeof K != "boolean")
          throw new Error("schema must be object or boolean");
      }
      let T = this._cache.get(K);
      if (T !== void 0)
        return T;
      z = (0, c.normalizeId)(N || z);
      const Z = c.getSchemaRefs.call(this, K, z);
      return T = new a.SchemaEnv({ schema: K, schemaId: F, meta: V, baseId: z, localRefs: Z }), this._cache.set(T.schema, T), q && !z.startsWith("#") && (z && this._checkUnique(z), this.refs[z] = T), C && this.validateSchema(K, !0), T;
    }
    _checkUnique(K) {
      if (this.schemas[K] || this.refs[K])
        throw new Error(`schema with key or id "${K}" already exists`);
    }
    _compileSchemaEnv(K) {
      if (K.meta ? this._compileMetaSchema(K) : a.compileSchema.call(this, K), !K.validate)
        throw new Error("ajv implementation error");
      return K.validate;
    }
    _compileMetaSchema(K) {
      const V = this.opts;
      this.opts = this._metaOpts;
      try {
        a.compileSchema.call(this, K);
      } finally {
        this.opts = V;
      }
    }
  }
  e.default = E, E.ValidationError = i.default, E.MissingRefError = n.default;
  function A(ie, K, V, z = "error") {
    for (const C in ie) {
      const q = C;
      q in K && this.logger[z](`${V}: option ${C}. ${ie[q]}`);
    }
  }
  function R(ie) {
    return ie = (0, c.normalizeId)(ie), this.schemas[ie] || this.refs[ie];
  }
  function I() {
    const ie = this.opts.schemas;
    if (ie)
      if (Array.isArray(ie))
        this.addSchema(ie);
      else
        for (const K in ie)
          this.addSchema(ie[K], K);
  }
  function D() {
    for (const ie in this.opts.formats) {
      const K = this.opts.formats[ie];
      K && this.addFormat(ie, K);
    }
  }
  function J(ie) {
    if (Array.isArray(ie)) {
      this.addVocabulary(ie);
      return;
    }
    this.logger.warn("keywords option as map is deprecated, pass array");
    for (const K in ie) {
      const V = ie[K];
      V.keyword || (V.keyword = K), this.addKeyword(V);
    }
  }
  function ae() {
    const ie = { ...this.opts };
    for (const K of y)
      delete ie[K];
    return ie;
  }
  const ye = { log() {
  }, warn() {
  }, error() {
  } };
  function xe(ie) {
    if (ie === !1)
      return ye;
    if (ie === void 0)
      return console;
    if (ie.log && ie.warn && ie.error)
      return ie;
    throw new Error("logger must implement log, warn and error methods");
  }
  const je = /^[a-z_$][a-z0-9_$:-]*$/i;
  function re(ie, K) {
    const { RULES: V } = this;
    if ((0, d.eachItem)(ie, (z) => {
      if (V.keywords[z])
        throw new Error(`Keyword ${z} is already defined`);
      if (!je.test(z))
        throw new Error(`Keyword ${z} has invalid name`);
    }), !!K && K.$data && !("code" in K || "validate" in K))
      throw new Error('$data keyword must have "code" or "validate" function');
  }
  function fe(ie, K, V) {
    var z;
    const C = K == null ? void 0 : K.post;
    if (V && C)
      throw new Error('keyword with "post" flag cannot have "type"');
    const { RULES: q } = this;
    let N = C ? q.post : q.rules.find(({ type: T }) => T === V);
    if (N || (N = { type: V, rules: [] }, q.rules.push(N)), q.keywords[ie] = !0, !K)
      return;
    const F = {
      keyword: ie,
      definition: {
        ...K,
        type: (0, l.getJSONTypes)(K.type),
        schemaType: (0, l.getJSONTypes)(K.schemaType)
      }
    };
    K.before ? le.call(this, N, F, K.before) : N.rules.push(F), q.all[ie] = F, (z = K.implements) === null || z === void 0 || z.forEach((T) => this.addKeyword(T));
  }
  function le(ie, K, V) {
    const z = ie.rules.findIndex((C) => C.keyword === V);
    z >= 0 ? ie.rules.splice(z, 0, K) : (ie.rules.push(K), this.logger.warn(`rule ${V} is not defined`));
  }
  function $e(ie) {
    let { metaSchema: K } = ie;
    K !== void 0 && (ie.$data && this.opts.$data && (K = _e(K)), ie.validateSchema = this.compile(K, !0));
  }
  const Ae = {
    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
  };
  function _e(ie) {
    return { anyOf: [ie, Ae] };
  }
})(Xa);
var Xg = {}, Qg = {}, e0 = {};
Object.defineProperty(e0, "__esModule", { value: !0 });
const iB = {
  keyword: "id",
  code() {
    throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
  }
};
e0.default = iB;
var ii = {};
Object.defineProperty(ii, "__esModule", { value: !0 });
ii.callRef = ii.getValidate = void 0;
const sB = oc, Kw = xt, Wr = ht, ka = nn, Yw = Nr, hl = Pt, aB = {
  keyword: "$ref",
  schemaType: "string",
  code(e) {
    const { gen: t, schema: r, it: i } = e, { baseId: n, schemaEnv: s, validateName: a, opts: u, self: c } = i, { root: l } = s;
    if ((r === "#" || r === "#/") && n === l.baseId)
      return p();
    const d = Yw.resolveRef.call(c, l, n, r);
    if (d === void 0)
      throw new sB.default(i.opts.uriResolver, n, r);
    if (d instanceof Yw.SchemaEnv)
      return h(d);
    return v(d);
    function p() {
      if (s === l)
        return Dl(e, a, s, s.$async);
      const y = t.scopeValue("root", { ref: l });
      return Dl(e, (0, Wr._)`${y}.validate`, l, l.$async);
    }
    function h(y) {
      const g = AP(e, y);
      Dl(e, g, y, y.$async);
    }
    function v(y) {
      const g = t.scopeValue("schema", u.code.source === !0 ? { ref: y, code: (0, Wr.stringify)(y) } : { ref: y }), _ = t.name("valid"), m = e.subschema({
        schema: y,
        dataTypes: [],
        schemaPath: Wr.nil,
        topSchemaRef: g,
        errSchemaPath: r
      }, _);
      e.mergeEvaluated(m), e.ok(_);
    }
  }
};
function AP(e, t) {
  const { gen: r } = e;
  return t.validate ? r.scopeValue("validate", { ref: t.validate }) : (0, Wr._)`${r.scopeValue("wrapper", { ref: t })}.validate`;
}
ii.getValidate = AP;
function Dl(e, t, r, i) {
  const { gen: n, it: s } = e, { allErrors: a, schemaEnv: u, opts: c } = s, l = c.passContext ? ka.default.this : Wr.nil;
  i ? d() : p();
  function d() {
    if (!u.$async)
      throw new Error("async schema referenced by sync schema");
    const y = n.let("valid");
    n.try(() => {
      n.code((0, Wr._)`await ${(0, Kw.callValidateCode)(e, t, l)}`), v(t), a || n.assign(y, !0);
    }, (g) => {
      n.if((0, Wr._)`!(${g} instanceof ${s.ValidationError})`, () => n.throw(g)), h(g), a || n.assign(y, !1);
    }), e.ok(y);
  }
  function p() {
    e.result((0, Kw.callValidateCode)(e, t, l), () => v(t), () => h(t));
  }
  function h(y) {
    const g = (0, Wr._)`${y}.errors`;
    n.assign(ka.default.vErrors, (0, Wr._)`${ka.default.vErrors} === null ? ${g} : ${ka.default.vErrors}.concat(${g})`), n.assign(ka.default.errors, (0, Wr._)`${ka.default.vErrors}.length`);
  }
  function v(y) {
    var g;
    if (!s.opts.unevaluated)
      return;
    const _ = (g = r == null ? void 0 : r.validate) === null || g === void 0 ? void 0 : g.evaluated;
    if (s.props !== !0)
      if (_ && !_.dynamicProps)
        _.props !== void 0 && (s.props = hl.mergeEvaluated.props(n, _.props, s.props));
      else {
        const m = n.var("props", (0, Wr._)`${y}.evaluated.props`);
        s.props = hl.mergeEvaluated.props(n, m, s.props, Wr.Name);
      }
    if (s.items !== !0)
      if (_ && !_.dynamicItems)
        _.items !== void 0 && (s.items = hl.mergeEvaluated.items(n, _.items, s.items));
      else {
        const m = n.var("items", (0, Wr._)`${y}.evaluated.items`);
        s.items = hl.mergeEvaluated.items(n, m, s.items, Wr.Name);
      }
  }
}
ii.callRef = Dl;
ii.default = aB;
Object.defineProperty(Qg, "__esModule", { value: !0 });
const oB = e0, uB = ii, cB = [
  "$schema",
  "$id",
  "$defs",
  "$vocabulary",
  { keyword: "$comment" },
  "definitions",
  oB.default,
  uB.default
];
Qg.default = cB;
var t0 = {}, r0 = {};
Object.defineProperty(r0, "__esModule", { value: !0 });
const vf = ht, Xi = vf.operators, bf = {
  maximum: { okStr: "<=", ok: Xi.LTE, fail: Xi.GT },
  minimum: { okStr: ">=", ok: Xi.GTE, fail: Xi.LT },
  exclusiveMaximum: { okStr: "<", ok: Xi.LT, fail: Xi.GTE },
  exclusiveMinimum: { okStr: ">", ok: Xi.GT, fail: Xi.LTE }
}, lB = {
  message: ({ keyword: e, schemaCode: t }) => (0, vf.str)`must be ${bf[e].okStr} ${t}`,
  params: ({ keyword: e, schemaCode: t }) => (0, vf._)`{comparison: ${bf[e].okStr}, limit: ${t}}`
}, fB = {
  keyword: Object.keys(bf),
  type: "number",
  schemaType: "number",
  $data: !0,
  error: lB,
  code(e) {
    const { keyword: t, data: r, schemaCode: i } = e;
    e.fail$data((0, vf._)`${r} ${bf[t].fail} ${i} || isNaN(${r})`);
  }
};
r0.default = fB;
var td = {};
Object.defineProperty(td, "__esModule", { value: !0 });
const mu = ht, dB = {
  message: ({ schemaCode: e }) => (0, mu.str)`must be multiple of ${e}`,
  params: ({ schemaCode: e }) => (0, mu._)`{multipleOf: ${e}}`
}, pB = {
  keyword: "multipleOf",
  type: "number",
  schemaType: "number",
  $data: !0,
  error: dB,
  code(e) {
    const { gen: t, data: r, schemaCode: i, it: n } = e, s = n.opts.multipleOfPrecision, a = t.let("res"), u = s ? (0, mu._)`Math.abs(Math.round(${a}) - ${a}) > 1e-${s}` : (0, mu._)`${a} !== parseInt(${a})`;
    e.fail$data((0, mu._)`(${i} === 0 || (${a} = ${r}/${i}, ${u}))`);
  }
};
td.default = pB;
var rd = {}, n0 = {};
Object.defineProperty(n0, "__esModule", { value: !0 });
function CP(e) {
  const t = e.length;
  let r = 0, i = 0, n;
  for (; i < t; )
    r++, n = e.charCodeAt(i++), n >= 55296 && n <= 56319 && i < t && (n = e.charCodeAt(i), (n & 64512) === 56320 && i++);
  return r;
}
n0.default = CP;
CP.code = 'require("ajv/dist/runtime/ucs2length").default';
Object.defineProperty(rd, "__esModule", { value: !0 });
const Fs = ht, hB = Pt, mB = n0, yB = {
  message({ keyword: e, schemaCode: t }) {
    const r = e === "maxLength" ? "more" : "fewer";
    return (0, Fs.str)`must NOT have ${r} than ${t} characters`;
  },
  params: ({ schemaCode: e }) => (0, Fs._)`{limit: ${e}}`
}, gB = {
  keyword: ["maxLength", "minLength"],
  type: "string",
  schemaType: "number",
  $data: !0,
  error: yB,
  code(e) {
    const { keyword: t, data: r, schemaCode: i, it: n } = e, s = t === "maxLength" ? Fs.operators.GT : Fs.operators.LT, a = n.opts.unicode === !1 ? (0, Fs._)`${r}.length` : (0, Fs._)`${(0, hB.useFunc)(e.gen, mB.default)}(${r})`;
    e.fail$data((0, Fs._)`${a} ${s} ${i}`);
  }
};
rd.default = gB;
var nd = {};
Object.defineProperty(nd, "__esModule", { value: !0 });
const vB = xt, _f = ht, bB = {
  message: ({ schemaCode: e }) => (0, _f.str)`must match pattern "${e}"`,
  params: ({ schemaCode: e }) => (0, _f._)`{pattern: ${e}}`
}, _B = {
  keyword: "pattern",
  type: "string",
  schemaType: "string",
  $data: !0,
  error: bB,
  code(e) {
    const { data: t, $data: r, schema: i, schemaCode: n, it: s } = e, a = s.opts.unicodeRegExp ? "u" : "", u = r ? (0, _f._)`(new RegExp(${n}, ${a}))` : (0, vB.usePattern)(e, i);
    e.fail$data((0, _f._)`!${u}.test(${t})`);
  }
};
nd.default = _B;
var id = {};
Object.defineProperty(id, "__esModule", { value: !0 });
const yu = ht, wB = {
  message({ keyword: e, schemaCode: t }) {
    const r = e === "maxProperties" ? "more" : "fewer";
    return (0, yu.str)`must NOT have ${r} than ${t} properties`;
  },
  params: ({ schemaCode: e }) => (0, yu._)`{limit: ${e}}`
}, $B = {
  keyword: ["maxProperties", "minProperties"],
  type: "object",
  schemaType: "number",
  $data: !0,
  error: wB,
  code(e) {
    const { keyword: t, data: r, schemaCode: i } = e, n = t === "maxProperties" ? yu.operators.GT : yu.operators.LT;
    e.fail$data((0, yu._)`Object.keys(${r}).length ${n} ${i}`);
  }
};
id.default = $B;
var sd = {};
Object.defineProperty(sd, "__esModule", { value: !0 });
const Qo = xt, gu = ht, EB = Pt, xB = {
  message: ({ params: { missingProperty: e } }) => (0, gu.str)`must have required property '${e}'`,
  params: ({ params: { missingProperty: e } }) => (0, gu._)`{missingProperty: ${e}}`
}, OB = {
  keyword: "required",
  type: "object",
  schemaType: "array",
  $data: !0,
  error: xB,
  code(e) {
    const { gen: t, schema: r, schemaCode: i, data: n, $data: s, it: a } = e, { opts: u } = a;
    if (!s && r.length === 0)
      return;
    const c = r.length >= u.loopRequired;
    if (a.allErrors ? l() : d(), u.strictRequired) {
      const v = e.parentSchema.properties, { definedProperties: y } = e.it;
      for (const g of r)
        if ((v == null ? void 0 : v[g]) === void 0 && !y.has(g)) {
          const _ = a.schemaEnv.baseId + a.errSchemaPath, m = `required property "${g}" is not defined at "${_}" (strictRequired)`;
          (0, EB.checkStrictMode)(a, m, a.opts.strictRequired);
        }
    }
    function l() {
      if (c || s)
        e.block$data(gu.nil, p);
      else
        for (const v of r)
          (0, Qo.checkReportMissingProp)(e, v);
    }
    function d() {
      const v = t.let("missing");
      if (c || s) {
        const y = t.let("valid", !0);
        e.block$data(y, () => h(v, y)), e.ok(y);
      } else
        t.if((0, Qo.checkMissingProp)(e, r, v)), (0, Qo.reportMissingProp)(e, v), t.else();
    }
    function p() {
      t.forOf("prop", i, (v) => {
        e.setParams({ missingProperty: v }), t.if((0, Qo.noPropertyInData)(t, n, v, u.ownProperties), () => e.error());
      });
    }
    function h(v, y) {
      e.setParams({ missingProperty: v }), t.forOf(v, i, () => {
        t.assign(y, (0, Qo.propertyInData)(t, n, v, u.ownProperties)), t.if((0, gu.not)(y), () => {
          e.error(), t.break();
        });
      }, gu.nil);
    }
  }
};
sd.default = OB;
var ad = {};
Object.defineProperty(ad, "__esModule", { value: !0 });
const vu = ht, PB = {
  message({ keyword: e, schemaCode: t }) {
    const r = e === "maxItems" ? "more" : "fewer";
    return (0, vu.str)`must NOT have ${r} than ${t} items`;
  },
  params: ({ schemaCode: e }) => (0, vu._)`{limit: ${e}}`
}, SB = {
  keyword: ["maxItems", "minItems"],
  type: "array",
  schemaType: "number",
  $data: !0,
  error: PB,
  code(e) {
    const { keyword: t, data: r, schemaCode: i } = e, n = t === "maxItems" ? vu.operators.GT : vu.operators.LT;
    e.fail$data((0, vu._)`${r}.length ${n} ${i}`);
  }
};
ad.default = SB;
var od = {}, uc = {};
Object.defineProperty(uc, "__esModule", { value: !0 });
const RP = lP;
RP.code = 'require("ajv/dist/runtime/equal").default';
uc.default = RP;
Object.defineProperty(od, "__esModule", { value: !0 });
const Jh = sc, gr = ht, AB = Pt, CB = uc, RB = {
  message: ({ params: { i: e, j: t } }) => (0, gr.str)`must NOT have duplicate items (items ## ${t} and ${e} are identical)`,
  params: ({ params: { i: e, j: t } }) => (0, gr._)`{i: ${e}, j: ${t}}`
}, TB = {
  keyword: "uniqueItems",
  type: "array",
  schemaType: "boolean",
  $data: !0,
  error: RB,
  code(e) {
    const { gen: t, data: r, $data: i, schema: n, parentSchema: s, schemaCode: a, it: u } = e;
    if (!i && !n)
      return;
    const c = t.let("valid"), l = s.items ? (0, Jh.getSchemaTypes)(s.items) : [];
    e.block$data(c, d, (0, gr._)`${a} === false`), e.ok(c);
    function d() {
      const y = t.let("i", (0, gr._)`${r}.length`), g = t.let("j");
      e.setParams({ i: y, j: g }), t.assign(c, !0), t.if((0, gr._)`${y} > 1`, () => (p() ? h : v)(y, g));
    }
    function p() {
      return l.length > 0 && !l.some((y) => y === "object" || y === "array");
    }
    function h(y, g) {
      const _ = t.name("item"), m = (0, Jh.checkDataTypes)(l, _, u.opts.strictNumbers, Jh.DataType.Wrong), w = t.const("indices", (0, gr._)`{}`);
      t.for((0, gr._)`;${y}--;`, () => {
        t.let(_, (0, gr._)`${r}[${y}]`), t.if(m, (0, gr._)`continue`), l.length > 1 && t.if((0, gr._)`typeof ${_} == "string"`, (0, gr._)`${_} += "_"`), t.if((0, gr._)`typeof ${w}[${_}] == "number"`, () => {
          t.assign(g, (0, gr._)`${w}[${_}]`), e.error(), t.assign(c, !1).break();
        }).code((0, gr._)`${w}[${_}] = ${y}`);
      });
    }
    function v(y, g) {
      const _ = (0, AB.useFunc)(t, CB.default), m = t.name("outer");
      t.label(m).for((0, gr._)`;${y}--;`, () => t.for((0, gr._)`${g} = ${y}; ${g}--;`, () => t.if((0, gr._)`${_}(${r}[${y}], ${r}[${g}])`, () => {
        e.error(), t.assign(c, !1).break(m);
      })));
    }
  }
};
od.default = TB;
var ud = {};
Object.defineProperty(ud, "__esModule", { value: !0 });
const Fy = ht, IB = Pt, jB = uc, kB = {
  message: "must be equal to constant",
  params: ({ schemaCode: e }) => (0, Fy._)`{allowedValue: ${e}}`
}, MB = {
  keyword: "const",
  $data: !0,
  error: kB,
  code(e) {
    const { gen: t, data: r, $data: i, schemaCode: n, schema: s } = e;
    i || s && typeof s == "object" ? e.fail$data((0, Fy._)`!${(0, IB.useFunc)(t, jB.default)}(${r}, ${n})`) : e.fail((0, Fy._)`${s} !== ${r}`);
  }
};
ud.default = MB;
var cd = {};
Object.defineProperty(cd, "__esModule", { value: !0 });
const ou = ht, NB = Pt, DB = uc, LB = {
  message: "must be equal to one of the allowed values",
  params: ({ schemaCode: e }) => (0, ou._)`{allowedValues: ${e}}`
}, qB = {
  keyword: "enum",
  schemaType: "array",
  $data: !0,
  error: LB,
  code(e) {
    const { gen: t, data: r, $data: i, schema: n, schemaCode: s, it: a } = e;
    if (!i && n.length === 0)
      throw new Error("enum must have non-empty array");
    const u = n.length >= a.opts.loopEnum;
    let c;
    const l = () => c ?? (c = (0, NB.useFunc)(t, DB.default));
    let d;
    if (u || i)
      d = t.let("valid"), e.block$data(d, p);
    else {
      if (!Array.isArray(n))
        throw new Error("ajv implementation error");
      const v = t.const("vSchema", s);
      d = (0, ou.or)(...n.map((y, g) => h(v, g)));
    }
    e.pass(d);
    function p() {
      t.assign(d, !1), t.forOf("v", s, (v) => t.if((0, ou._)`${l()}(${r}, ${v})`, () => t.assign(d, !0).break()));
    }
    function h(v, y) {
      const g = n[y];
      return typeof g == "object" && g !== null ? (0, ou._)`${l()}(${r}, ${v}[${y}])` : (0, ou._)`${r} === ${g}`;
    }
  }
};
cd.default = qB;
Object.defineProperty(t0, "__esModule", { value: !0 });
const FB = r0, UB = td, BB = rd, VB = nd, ZB = id, zB = sd, WB = ad, HB = od, GB = ud, KB = cd, YB = [
  // number
  FB.default,
  UB.default,
  // string
  BB.default,
  VB.default,
  // object
  ZB.default,
  zB.default,
  // array
  WB.default,
  HB.default,
  // any
  { keyword: "type", schemaType: ["string", "array"] },
  { keyword: "nullable", schemaType: "boolean" },
  GB.default,
  KB.default
];
t0.default = YB;
var ld = {}, go = {};
Object.defineProperty(go, "__esModule", { value: !0 });
go.validateAdditionalItems = void 0;
const Us = ht, Uy = Pt, JB = {
  message: ({ params: { len: e } }) => (0, Us.str)`must NOT have more than ${e} items`,
  params: ({ params: { len: e } }) => (0, Us._)`{limit: ${e}}`
}, XB = {
  keyword: "additionalItems",
  type: "array",
  schemaType: ["boolean", "object"],
  before: "uniqueItems",
  error: JB,
  code(e) {
    const { parentSchema: t, it: r } = e, { items: i } = t;
    if (!Array.isArray(i)) {
      (0, Uy.checkStrictMode)(r, '"additionalItems" is ignored when "items" is not an array of schemas');
      return;
    }
    TP(e, i);
  }
};
function TP(e, t) {
  const { gen: r, schema: i, data: n, keyword: s, it: a } = e;
  a.items = !0;
  const u = r.const("len", (0, Us._)`${n}.length`);
  if (i === !1)
    e.setParams({ len: t.length }), e.pass((0, Us._)`${u} <= ${t.length}`);
  else if (typeof i == "object" && !(0, Uy.alwaysValidSchema)(a, i)) {
    const l = r.var("valid", (0, Us._)`${u} <= ${t.length}`);
    r.if((0, Us.not)(l), () => c(l)), e.ok(l);
  }
  function c(l) {
    r.forRange("i", t.length, u, (d) => {
      e.subschema({ keyword: s, dataProp: d, dataPropType: Uy.Type.Num }, l), a.allErrors || r.if((0, Us.not)(l), () => r.break());
    });
  }
}
go.validateAdditionalItems = TP;
go.default = XB;
var i0 = {}, vo = {};
Object.defineProperty(vo, "__esModule", { value: !0 });
vo.validateTuple = void 0;
const Jw = ht, Ll = Pt, QB = xt, e9 = {
  keyword: "items",
  type: "array",
  schemaType: ["object", "array", "boolean"],
  before: "uniqueItems",
  code(e) {
    const { schema: t, it: r } = e;
    if (Array.isArray(t))
      return IP(e, "additionalItems", t);
    r.items = !0, !(0, Ll.alwaysValidSchema)(r, t) && e.ok((0, QB.validateArray)(e));
  }
};
function IP(e, t, r = e.schema) {
  const { gen: i, parentSchema: n, data: s, keyword: a, it: u } = e;
  d(n), u.opts.unevaluated && r.length && u.items !== !0 && (u.items = Ll.mergeEvaluated.items(i, r.length, u.items));
  const c = i.name("valid"), l = i.const("len", (0, Jw._)`${s}.length`);
  r.forEach((p, h) => {
    (0, Ll.alwaysValidSchema)(u, p) || (i.if((0, Jw._)`${l} > ${h}`, () => e.subschema({
      keyword: a,
      schemaProp: h,
      dataProp: h
    }, c)), e.ok(c));
  });
  function d(p) {
    const { opts: h, errSchemaPath: v } = u, y = r.length, g = y === p.minItems && (y === p.maxItems || p[t] === !1);
    if (h.strictTuples && !g) {
      const _ = `"${a}" is ${y}-tuple, but minItems or maxItems/${t} are not specified or different at path "${v}"`;
      (0, Ll.checkStrictMode)(u, _, h.strictTuples);
    }
  }
}
vo.validateTuple = IP;
vo.default = e9;
Object.defineProperty(i0, "__esModule", { value: !0 });
const t9 = vo, r9 = {
  keyword: "prefixItems",
  type: "array",
  schemaType: ["array"],
  before: "uniqueItems",
  code: (e) => (0, t9.validateTuple)(e, "items")
};
i0.default = r9;
var s0 = {};
Object.defineProperty(s0, "__esModule", { value: !0 });
const Xw = ht, n9 = Pt, i9 = xt, s9 = go, a9 = {
  message: ({ params: { len: e } }) => (0, Xw.str)`must NOT have more than ${e} items`,
  params: ({ params: { len: e } }) => (0, Xw._)`{limit: ${e}}`
}, o9 = {
  keyword: "items",
  type: "array",
  schemaType: ["object", "boolean"],
  before: "uniqueItems",
  error: a9,
  code(e) {
    const { schema: t, parentSchema: r, it: i } = e, { prefixItems: n } = r;
    i.items = !0, !(0, n9.alwaysValidSchema)(i, t) && (n ? (0, s9.validateAdditionalItems)(e, n) : e.ok((0, i9.validateArray)(e)));
  }
};
s0.default = o9;
var a0 = {};
Object.defineProperty(a0, "__esModule", { value: !0 });
const hn = ht, ml = Pt, u9 = {
  message: ({ params: { min: e, max: t } }) => t === void 0 ? (0, hn.str)`must contain at least ${e} valid item(s)` : (0, hn.str)`must contain at least ${e} and no more than ${t} valid item(s)`,
  params: ({ params: { min: e, max: t } }) => t === void 0 ? (0, hn._)`{minContains: ${e}}` : (0, hn._)`{minContains: ${e}, maxContains: ${t}}`
}, c9 = {
  keyword: "contains",
  type: "array",
  schemaType: ["object", "boolean"],
  before: "uniqueItems",
  trackErrors: !0,
  error: u9,
  code(e) {
    const { gen: t, schema: r, parentSchema: i, data: n, it: s } = e;
    let a, u;
    const { minContains: c, maxContains: l } = i;
    s.opts.next ? (a = c === void 0 ? 1 : c, u = l) : a = 1;
    const d = t.const("len", (0, hn._)`${n}.length`);
    if (e.setParams({ min: a, max: u }), u === void 0 && a === 0) {
      (0, ml.checkStrictMode)(s, '"minContains" == 0 without "maxContains": "contains" keyword ignored');
      return;
    }
    if (u !== void 0 && a > u) {
      (0, ml.checkStrictMode)(s, '"minContains" > "maxContains" is always invalid'), e.fail();
      return;
    }
    if ((0, ml.alwaysValidSchema)(s, r)) {
      let g = (0, hn._)`${d} >= ${a}`;
      u !== void 0 && (g = (0, hn._)`${g} && ${d} <= ${u}`), e.pass(g);
      return;
    }
    s.items = !0;
    const p = t.name("valid");
    u === void 0 && a === 1 ? v(p, () => t.if(p, () => t.break())) : a === 0 ? (t.let(p, !0), u !== void 0 && t.if((0, hn._)`${n}.length > 0`, h)) : (t.let(p, !1), h()), e.result(p, () => e.reset());
    function h() {
      const g = t.name("_valid"), _ = t.let("count", 0);
      v(g, () => t.if(g, () => y(_)));
    }
    function v(g, _) {
      t.forRange("i", 0, d, (m) => {
        e.subschema({
          keyword: "contains",
          dataProp: m,
          dataPropType: ml.Type.Num,
          compositeRule: !0
        }, g), _();
      });
    }
    function y(g) {
      t.code((0, hn._)`${g}++`), u === void 0 ? t.if((0, hn._)`${g} >= ${a}`, () => t.assign(p, !0).break()) : (t.if((0, hn._)`${g} > ${u}`, () => t.assign(p, !1).break()), a === 1 ? t.assign(p, !0) : t.if((0, hn._)`${g} >= ${a}`, () => t.assign(p, !0)));
    }
  }
};
a0.default = c9;
var fd = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.validateSchemaDeps = e.validatePropertyDeps = e.error = void 0;
  const t = ht, r = Pt, i = xt;
  e.error = {
    message: ({ params: { property: c, depsCount: l, deps: d } }) => {
      const p = l === 1 ? "property" : "properties";
      return (0, t.str)`must have ${p} ${d} when property ${c} is present`;
    },
    params: ({ params: { property: c, depsCount: l, deps: d, missingProperty: p } }) => (0, t._)`{property: ${c},
    missingProperty: ${p},
    depsCount: ${l},
    deps: ${d}}`
    // TODO change to reference
  };
  const n = {
    keyword: "dependencies",
    type: "object",
    schemaType: "object",
    error: e.error,
    code(c) {
      const [l, d] = s(c);
      a(c, l), u(c, d);
    }
  };
  function s({ schema: c }) {
    const l = {}, d = {};
    for (const p in c) {
      if (p === "__proto__")
        continue;
      const h = Array.isArray(c[p]) ? l : d;
      h[p] = c[p];
    }
    return [l, d];
  }
  function a(c, l = c.schema) {
    const { gen: d, data: p, it: h } = c;
    if (Object.keys(l).length === 0)
      return;
    const v = d.let("missing");
    for (const y in l) {
      const g = l[y];
      if (g.length === 0)
        continue;
      const _ = (0, i.propertyInData)(d, p, y, h.opts.ownProperties);
      c.setParams({
        property: y,
        depsCount: g.length,
        deps: g.join(", ")
      }), h.allErrors ? d.if(_, () => {
        for (const m of g)
          (0, i.checkReportMissingProp)(c, m);
      }) : (d.if((0, t._)`${_} && (${(0, i.checkMissingProp)(c, g, v)})`), (0, i.reportMissingProp)(c, v), d.else());
    }
  }
  e.validatePropertyDeps = a;
  function u(c, l = c.schema) {
    const { gen: d, data: p, keyword: h, it: v } = c, y = d.name("valid");
    for (const g in l)
      (0, r.alwaysValidSchema)(v, l[g]) || (d.if(
        (0, i.propertyInData)(d, p, g, v.opts.ownProperties),
        () => {
          const _ = c.subschema({ keyword: h, schemaProp: g }, y);
          c.mergeValidEvaluated(_, y);
        },
        () => d.var(y, !0)
        // TODO var
      ), c.ok(y));
  }
  e.validateSchemaDeps = u, e.default = n;
})(fd);
var o0 = {};
Object.defineProperty(o0, "__esModule", { value: !0 });
const jP = ht, l9 = Pt, f9 = {
  message: "property name must be valid",
  params: ({ params: e }) => (0, jP._)`{propertyName: ${e.propertyName}}`
}, d9 = {
  keyword: "propertyNames",
  type: "object",
  schemaType: ["object", "boolean"],
  error: f9,
  code(e) {
    const { gen: t, schema: r, data: i, it: n } = e;
    if ((0, l9.alwaysValidSchema)(n, r))
      return;
    const s = t.name("valid");
    t.forIn("key", i, (a) => {
      e.setParams({ propertyName: a }), e.subschema({
        keyword: "propertyNames",
        data: a,
        dataTypes: ["string"],
        propertyName: a,
        compositeRule: !0
      }, s), t.if((0, jP.not)(s), () => {
        e.error(!0), n.allErrors || t.break();
      });
    }), e.ok(s);
  }
};
o0.default = d9;
var dd = {};
Object.defineProperty(dd, "__esModule", { value: !0 });
const yl = xt, On = ht, p9 = nn, gl = Pt, h9 = {
  message: "must NOT have additional properties",
  params: ({ params: e }) => (0, On._)`{additionalProperty: ${e.additionalProperty}}`
}, m9 = {
  keyword: "additionalProperties",
  type: ["object"],
  schemaType: ["boolean", "object"],
  allowUndefined: !0,
  trackErrors: !0,
  error: h9,
  code(e) {
    const { gen: t, schema: r, parentSchema: i, data: n, errsCount: s, it: a } = e;
    if (!s)
      throw new Error("ajv implementation error");
    const { allErrors: u, opts: c } = a;
    if (a.props = !0, c.removeAdditional !== "all" && (0, gl.alwaysValidSchema)(a, r))
      return;
    const l = (0, yl.allSchemaProperties)(i.properties), d = (0, yl.allSchemaProperties)(i.patternProperties);
    p(), e.ok((0, On._)`${s} === ${p9.default.errors}`);
    function p() {
      t.forIn("key", n, (_) => {
        !l.length && !d.length ? y(_) : t.if(h(_), () => y(_));
      });
    }
    function h(_) {
      let m;
      if (l.length > 8) {
        const w = (0, gl.schemaRefOrVal)(a, i.properties, "properties");
        m = (0, yl.isOwnProperty)(t, w, _);
      } else
        l.length ? m = (0, On.or)(...l.map((w) => (0, On._)`${_} === ${w}`)) : m = On.nil;
      return d.length && (m = (0, On.or)(m, ...d.map((w) => (0, On._)`${(0, yl.usePattern)(e, w)}.test(${_})`))), (0, On.not)(m);
    }
    function v(_) {
      t.code((0, On._)`delete ${n}[${_}]`);
    }
    function y(_) {
      if (c.removeAdditional === "all" || c.removeAdditional && r === !1) {
        v(_);
        return;
      }
      if (r === !1) {
        e.setParams({ additionalProperty: _ }), e.error(), u || t.break();
        return;
      }
      if (typeof r == "object" && !(0, gl.alwaysValidSchema)(a, r)) {
        const m = t.name("valid");
        c.removeAdditional === "failing" ? (g(_, m, !1), t.if((0, On.not)(m), () => {
          e.reset(), v(_);
        })) : (g(_, m), u || t.if((0, On.not)(m), () => t.break()));
      }
    }
    function g(_, m, w) {
      const $ = {
        keyword: "additionalProperties",
        dataProp: _,
        dataPropType: gl.Type.Str
      };
      w === !1 && Object.assign($, {
        compositeRule: !0,
        createErrors: !1,
        allErrors: !1
      }), e.subschema($, m);
    }
  }
};
dd.default = m9;
var u0 = {};
Object.defineProperty(u0, "__esModule", { value: !0 });
const y9 = jn, Qw = xt, Xh = Pt, e$ = dd, g9 = {
  keyword: "properties",
  type: "object",
  schemaType: "object",
  code(e) {
    const { gen: t, schema: r, parentSchema: i, data: n, it: s } = e;
    s.opts.removeAdditional === "all" && i.additionalProperties === void 0 && e$.default.code(new y9.KeywordCxt(s, e$.default, "additionalProperties"));
    const a = (0, Qw.allSchemaProperties)(r);
    for (const p of a)
      s.definedProperties.add(p);
    s.opts.unevaluated && a.length && s.props !== !0 && (s.props = Xh.mergeEvaluated.props(t, (0, Xh.toHash)(a), s.props));
    const u = a.filter((p) => !(0, Xh.alwaysValidSchema)(s, r[p]));
    if (u.length === 0)
      return;
    const c = t.name("valid");
    for (const p of u)
      l(p) ? d(p) : (t.if((0, Qw.propertyInData)(t, n, p, s.opts.ownProperties)), d(p), s.allErrors || t.else().var(c, !0), t.endIf()), e.it.definedProperties.add(p), e.ok(c);
    function l(p) {
      return s.opts.useDefaults && !s.compositeRule && r[p].default !== void 0;
    }
    function d(p) {
      e.subschema({
        keyword: "properties",
        schemaProp: p,
        dataProp: p
      }, c);
    }
  }
};
u0.default = g9;
var c0 = {};
Object.defineProperty(c0, "__esModule", { value: !0 });
const t$ = xt, vl = ht, r$ = Pt, n$ = Pt, v9 = {
  keyword: "patternProperties",
  type: "object",
  schemaType: "object",
  code(e) {
    const { gen: t, schema: r, data: i, parentSchema: n, it: s } = e, { opts: a } = s, u = (0, t$.allSchemaProperties)(r), c = u.filter((g) => (0, r$.alwaysValidSchema)(s, r[g]));
    if (u.length === 0 || c.length === u.length && (!s.opts.unevaluated || s.props === !0))
      return;
    const l = a.strictSchema && !a.allowMatchingProperties && n.properties, d = t.name("valid");
    s.props !== !0 && !(s.props instanceof vl.Name) && (s.props = (0, n$.evaluatedPropsToName)(t, s.props));
    const { props: p } = s;
    h();
    function h() {
      for (const g of u)
        l && v(g), s.allErrors ? y(g) : (t.var(d, !0), y(g), t.if(d));
    }
    function v(g) {
      for (const _ in l)
        new RegExp(g).test(_) && (0, r$.checkStrictMode)(s, `property ${_} matches pattern ${g} (use allowMatchingProperties)`);
    }
    function y(g) {
      t.forIn("key", i, (_) => {
        t.if((0, vl._)`${(0, t$.usePattern)(e, g)}.test(${_})`, () => {
          const m = c.includes(g);
          m || e.subschema({
            keyword: "patternProperties",
            schemaProp: g,
            dataProp: _,
            dataPropType: n$.Type.Str
          }, d), s.opts.unevaluated && p !== !0 ? t.assign((0, vl._)`${p}[${_}]`, !0) : !m && !s.allErrors && t.if((0, vl.not)(d), () => t.break());
        });
      });
    }
  }
};
c0.default = v9;
var l0 = {};
Object.defineProperty(l0, "__esModule", { value: !0 });
const b9 = Pt, _9 = {
  keyword: "not",
  schemaType: ["object", "boolean"],
  trackErrors: !0,
  code(e) {
    const { gen: t, schema: r, it: i } = e;
    if ((0, b9.alwaysValidSchema)(i, r)) {
      e.fail();
      return;
    }
    const n = t.name("valid");
    e.subschema({
      keyword: "not",
      compositeRule: !0,
      createErrors: !1,
      allErrors: !1
    }, n), e.failResult(n, () => e.reset(), () => e.error());
  },
  error: { message: "must NOT be valid" }
};
l0.default = _9;
var f0 = {};
Object.defineProperty(f0, "__esModule", { value: !0 });
const w9 = xt, $9 = {
  keyword: "anyOf",
  schemaType: "array",
  trackErrors: !0,
  code: w9.validateUnion,
  error: { message: "must match a schema in anyOf" }
};
f0.default = $9;
var d0 = {};
Object.defineProperty(d0, "__esModule", { value: !0 });
const ql = ht, E9 = Pt, x9 = {
  message: "must match exactly one schema in oneOf",
  params: ({ params: e }) => (0, ql._)`{passingSchemas: ${e.passing}}`
}, O9 = {
  keyword: "oneOf",
  schemaType: "array",
  trackErrors: !0,
  error: x9,
  code(e) {
    const { gen: t, schema: r, parentSchema: i, it: n } = e;
    if (!Array.isArray(r))
      throw new Error("ajv implementation error");
    if (n.opts.discriminator && i.discriminator)
      return;
    const s = r, a = t.let("valid", !1), u = t.let("passing", null), c = t.name("_valid");
    e.setParams({ passing: u }), t.block(l), e.result(a, () => e.reset(), () => e.error(!0));
    function l() {
      s.forEach((d, p) => {
        let h;
        (0, E9.alwaysValidSchema)(n, d) ? t.var(c, !0) : h = e.subschema({
          keyword: "oneOf",
          schemaProp: p,
          compositeRule: !0
        }, c), p > 0 && t.if((0, ql._)`${c} && ${a}`).assign(a, !1).assign(u, (0, ql._)`[${u}, ${p}]`).else(), t.if(c, () => {
          t.assign(a, !0), t.assign(u, p), h && e.mergeEvaluated(h, ql.Name);
        });
      });
    }
  }
};
d0.default = O9;
var p0 = {};
Object.defineProperty(p0, "__esModule", { value: !0 });
const P9 = Pt, S9 = {
  keyword: "allOf",
  schemaType: "array",
  code(e) {
    const { gen: t, schema: r, it: i } = e;
    if (!Array.isArray(r))
      throw new Error("ajv implementation error");
    const n = t.name("valid");
    r.forEach((s, a) => {
      if ((0, P9.alwaysValidSchema)(i, s))
        return;
      const u = e.subschema({ keyword: "allOf", schemaProp: a }, n);
      e.ok(n), e.mergeEvaluated(u);
    });
  }
};
p0.default = S9;
var h0 = {};
Object.defineProperty(h0, "__esModule", { value: !0 });
const wf = ht, kP = Pt, A9 = {
  message: ({ params: e }) => (0, wf.str)`must match "${e.ifClause}" schema`,
  params: ({ params: e }) => (0, wf._)`{failingKeyword: ${e.ifClause}}`
}, C9 = {
  keyword: "if",
  schemaType: ["object", "boolean"],
  trackErrors: !0,
  error: A9,
  code(e) {
    const { gen: t, parentSchema: r, it: i } = e;
    r.then === void 0 && r.else === void 0 && (0, kP.checkStrictMode)(i, '"if" without "then" and "else" is ignored');
    const n = i$(i, "then"), s = i$(i, "else");
    if (!n && !s)
      return;
    const a = t.let("valid", !0), u = t.name("_valid");
    if (c(), e.reset(), n && s) {
      const d = t.let("ifClause");
      e.setParams({ ifClause: d }), t.if(u, l("then", d), l("else", d));
    } else
      n ? t.if(u, l("then")) : t.if((0, wf.not)(u), l("else"));
    e.pass(a, () => e.error(!0));
    function c() {
      const d = e.subschema({
        keyword: "if",
        compositeRule: !0,
        createErrors: !1,
        allErrors: !1
      }, u);
      e.mergeEvaluated(d);
    }
    function l(d, p) {
      return () => {
        const h = e.subschema({ keyword: d }, u);
        t.assign(a, u), e.mergeValidEvaluated(h, a), p ? t.assign(p, (0, wf._)`${d}`) : e.setParams({ ifClause: d });
      };
    }
  }
};
function i$(e, t) {
  const r = e.schema[t];
  return r !== void 0 && !(0, kP.alwaysValidSchema)(e, r);
}
h0.default = C9;
var m0 = {};
Object.defineProperty(m0, "__esModule", { value: !0 });
const R9 = Pt, T9 = {
  keyword: ["then", "else"],
  schemaType: ["object", "boolean"],
  code({ keyword: e, parentSchema: t, it: r }) {
    t.if === void 0 && (0, R9.checkStrictMode)(r, `"${e}" without "if" is ignored`);
  }
};
m0.default = T9;
Object.defineProperty(ld, "__esModule", { value: !0 });
const I9 = go, j9 = i0, k9 = vo, M9 = s0, N9 = a0, D9 = fd, L9 = o0, q9 = dd, F9 = u0, U9 = c0, B9 = l0, V9 = f0, Z9 = d0, z9 = p0, W9 = h0, H9 = m0;
function G9(e = !1) {
  const t = [
    // any
    B9.default,
    V9.default,
    Z9.default,
    z9.default,
    W9.default,
    H9.default,
    // object
    L9.default,
    q9.default,
    D9.default,
    F9.default,
    U9.default
  ];
  return e ? t.push(j9.default, M9.default) : t.push(I9.default, k9.default), t.push(N9.default), t;
}
ld.default = G9;
var y0 = {}, bo = {};
Object.defineProperty(bo, "__esModule", { value: !0 });
bo.dynamicAnchor = void 0;
const Qh = ht, K9 = nn, s$ = Nr, Y9 = ii, J9 = {
  keyword: "$dynamicAnchor",
  schemaType: "string",
  code: (e) => MP(e, e.schema)
};
function MP(e, t) {
  const { gen: r, it: i } = e;
  i.schemaEnv.root.dynamicAnchors[t] = !0;
  const n = (0, Qh._)`${K9.default.dynamicAnchors}${(0, Qh.getProperty)(t)}`, s = i.errSchemaPath === "#" ? i.validateName : X9(e);
  r.if((0, Qh._)`!${n}`, () => r.assign(n, s));
}
bo.dynamicAnchor = MP;
function X9(e) {
  const { schemaEnv: t, schema: r, self: i } = e.it, { root: n, baseId: s, localRefs: a, meta: u } = t.root, { schemaId: c } = i.opts, l = new s$.SchemaEnv({ schema: r, schemaId: c, root: n, baseId: s, localRefs: a, meta: u });
  return s$.compileSchema.call(i, l), (0, Y9.getValidate)(e, l);
}
bo.default = J9;
var _o = {};
Object.defineProperty(_o, "__esModule", { value: !0 });
_o.dynamicRef = void 0;
const a$ = ht, Q9 = nn, o$ = ii, e7 = {
  keyword: "$dynamicRef",
  schemaType: "string",
  code: (e) => NP(e, e.schema)
};
function NP(e, t) {
  const { gen: r, keyword: i, it: n } = e;
  if (t[0] !== "#")
    throw new Error(`"${i}" only supports hash fragment reference`);
  const s = t.slice(1);
  if (n.allErrors)
    a();
  else {
    const c = r.let("valid", !1);
    a(c), e.ok(c);
  }
  function a(c) {
    if (n.schemaEnv.root.dynamicAnchors[s]) {
      const l = r.let("_v", (0, a$._)`${Q9.default.dynamicAnchors}${(0, a$.getProperty)(s)}`);
      r.if(l, u(l, c), u(n.validateName, c));
    } else
      u(n.validateName, c)();
  }
  function u(c, l) {
    return l ? () => r.block(() => {
      (0, o$.callRef)(e, c), r.let(l, !0);
    }) : () => (0, o$.callRef)(e, c);
  }
}
_o.dynamicRef = NP;
_o.default = e7;
var g0 = {};
Object.defineProperty(g0, "__esModule", { value: !0 });
const t7 = bo, r7 = Pt, n7 = {
  keyword: "$recursiveAnchor",
  schemaType: "boolean",
  code(e) {
    e.schema ? (0, t7.dynamicAnchor)(e, "") : (0, r7.checkStrictMode)(e.it, "$recursiveAnchor: false is ignored");
  }
};
g0.default = n7;
var v0 = {};
Object.defineProperty(v0, "__esModule", { value: !0 });
const i7 = _o, s7 = {
  keyword: "$recursiveRef",
  schemaType: "string",
  code: (e) => (0, i7.dynamicRef)(e, e.schema)
};
v0.default = s7;
Object.defineProperty(y0, "__esModule", { value: !0 });
const a7 = bo, o7 = _o, u7 = g0, c7 = v0, l7 = [a7.default, o7.default, u7.default, c7.default];
y0.default = l7;
var b0 = {}, _0 = {};
Object.defineProperty(_0, "__esModule", { value: !0 });
const u$ = fd, f7 = {
  keyword: "dependentRequired",
  type: "object",
  schemaType: "object",
  error: u$.error,
  code: (e) => (0, u$.validatePropertyDeps)(e)
};
_0.default = f7;
var w0 = {};
Object.defineProperty(w0, "__esModule", { value: !0 });
const d7 = fd, p7 = {
  keyword: "dependentSchemas",
  type: "object",
  schemaType: "object",
  code: (e) => (0, d7.validateSchemaDeps)(e)
};
w0.default = p7;
var $0 = {};
Object.defineProperty($0, "__esModule", { value: !0 });
const h7 = Pt, m7 = {
  keyword: ["maxContains", "minContains"],
  type: "array",
  schemaType: "number",
  code({ keyword: e, parentSchema: t, it: r }) {
    t.contains === void 0 && (0, h7.checkStrictMode)(r, `"${e}" without "contains" is ignored`);
  }
};
$0.default = m7;
Object.defineProperty(b0, "__esModule", { value: !0 });
const y7 = _0, g7 = w0, v7 = $0, b7 = [y7.default, g7.default, v7.default];
b0.default = b7;
var E0 = {}, x0 = {};
Object.defineProperty(x0, "__esModule", { value: !0 });
const es = ht, c$ = Pt, _7 = nn, w7 = {
  message: "must NOT have unevaluated properties",
  params: ({ params: e }) => (0, es._)`{unevaluatedProperty: ${e.unevaluatedProperty}}`
}, $7 = {
  keyword: "unevaluatedProperties",
  type: "object",
  schemaType: ["boolean", "object"],
  trackErrors: !0,
  error: w7,
  code(e) {
    const { gen: t, schema: r, data: i, errsCount: n, it: s } = e;
    if (!n)
      throw new Error("ajv implementation error");
    const { allErrors: a, props: u } = s;
    u instanceof es.Name ? t.if((0, es._)`${u} !== true`, () => t.forIn("key", i, (p) => t.if(l(u, p), () => c(p)))) : u !== !0 && t.forIn("key", i, (p) => u === void 0 ? c(p) : t.if(d(u, p), () => c(p))), s.props = !0, e.ok((0, es._)`${n} === ${_7.default.errors}`);
    function c(p) {
      if (r === !1) {
        e.setParams({ unevaluatedProperty: p }), e.error(), a || t.break();
        return;
      }
      if (!(0, c$.alwaysValidSchema)(s, r)) {
        const h = t.name("valid");
        e.subschema({
          keyword: "unevaluatedProperties",
          dataProp: p,
          dataPropType: c$.Type.Str
        }, h), a || t.if((0, es.not)(h), () => t.break());
      }
    }
    function l(p, h) {
      return (0, es._)`!${p} || !${p}[${h}]`;
    }
    function d(p, h) {
      const v = [];
      for (const y in p)
        p[y] === !0 && v.push((0, es._)`${h} !== ${y}`);
      return (0, es.and)(...v);
    }
  }
};
x0.default = $7;
var O0 = {};
Object.defineProperty(O0, "__esModule", { value: !0 });
const Bs = ht, l$ = Pt, E7 = {
  message: ({ params: { len: e } }) => (0, Bs.str)`must NOT have more than ${e} items`,
  params: ({ params: { len: e } }) => (0, Bs._)`{limit: ${e}}`
}, x7 = {
  keyword: "unevaluatedItems",
  type: "array",
  schemaType: ["boolean", "object"],
  error: E7,
  code(e) {
    const { gen: t, schema: r, data: i, it: n } = e, s = n.items || 0;
    if (s === !0)
      return;
    const a = t.const("len", (0, Bs._)`${i}.length`);
    if (r === !1)
      e.setParams({ len: s }), e.fail((0, Bs._)`${a} > ${s}`);
    else if (typeof r == "object" && !(0, l$.alwaysValidSchema)(n, r)) {
      const c = t.var("valid", (0, Bs._)`${a} <= ${s}`);
      t.if((0, Bs.not)(c), () => u(c, s)), e.ok(c);
    }
    n.items = !0;
    function u(c, l) {
      t.forRange("i", l, a, (d) => {
        e.subschema({ keyword: "unevaluatedItems", dataProp: d, dataPropType: l$.Type.Num }, c), n.allErrors || t.if((0, Bs.not)(c), () => t.break());
      });
    }
  }
};
O0.default = x7;
Object.defineProperty(E0, "__esModule", { value: !0 });
const O7 = x0, P7 = O0, S7 = [O7.default, P7.default];
E0.default = S7;
var pd = {}, P0 = {};
Object.defineProperty(P0, "__esModule", { value: !0 });
const rr = ht, A7 = {
  message: ({ schemaCode: e }) => (0, rr.str)`must match format "${e}"`,
  params: ({ schemaCode: e }) => (0, rr._)`{format: ${e}}`
}, C7 = {
  keyword: "format",
  type: ["number", "string"],
  schemaType: "string",
  $data: !0,
  error: A7,
  code(e, t) {
    const { gen: r, data: i, $data: n, schema: s, schemaCode: a, it: u } = e, { opts: c, errSchemaPath: l, schemaEnv: d, self: p } = u;
    if (!c.validateFormats)
      return;
    n ? h() : v();
    function h() {
      const y = r.scopeValue("formats", {
        ref: p.formats,
        code: c.code.formats
      }), g = r.const("fDef", (0, rr._)`${y}[${a}]`), _ = r.let("fType"), m = r.let("format");
      r.if((0, rr._)`typeof ${g} == "object" && !(${g} instanceof RegExp)`, () => r.assign(_, (0, rr._)`${g}.type || "string"`).assign(m, (0, rr._)`${g}.validate`), () => r.assign(_, (0, rr._)`"string"`).assign(m, g)), e.fail$data((0, rr.or)(w(), $()));
      function w() {
        return c.strictSchema === !1 ? rr.nil : (0, rr._)`${a} && !${m}`;
      }
      function $() {
        const E = d.$async ? (0, rr._)`(${g}.async ? await ${m}(${i}) : ${m}(${i}))` : (0, rr._)`${m}(${i})`, A = (0, rr._)`(typeof ${m} == "function" ? ${E} : ${m}.test(${i}))`;
        return (0, rr._)`${m} && ${m} !== true && ${_} === ${t} && !${A}`;
      }
    }
    function v() {
      const y = p.formats[s];
      if (!y) {
        w();
        return;
      }
      if (y === !0)
        return;
      const [g, _, m] = $(y);
      g === t && e.pass(E());
      function w() {
        if (c.strictSchema === !1) {
          p.logger.warn(A());
          return;
        }
        throw new Error(A());
        function A() {
          return `unknown format "${s}" ignored in schema at path "${l}"`;
        }
      }
      function $(A) {
        const R = A instanceof RegExp ? (0, rr.regexpCode)(A) : c.code.formats ? (0, rr._)`${c.code.formats}${(0, rr.getProperty)(s)}` : void 0, I = r.scopeValue("formats", { key: s, ref: A, code: R });
        return typeof A == "object" && !(A instanceof RegExp) ? [A.type || "string", A.validate, (0, rr._)`${I}.validate`] : ["string", A, I];
      }
      function E() {
        if (typeof y == "object" && !(y instanceof RegExp) && y.async) {
          if (!d.$async)
            throw new Error("async format in sync schema");
          return (0, rr._)`await ${m}(${i})`;
        }
        return typeof _ == "function" ? (0, rr._)`${m}(${i})` : (0, rr._)`${m}.test(${i})`;
      }
    }
  }
};
P0.default = C7;
Object.defineProperty(pd, "__esModule", { value: !0 });
const R7 = P0, T7 = [R7.default];
pd.default = T7;
var uo = {};
Object.defineProperty(uo, "__esModule", { value: !0 });
uo.contentVocabulary = uo.metadataVocabulary = void 0;
uo.metadataVocabulary = [
  "title",
  "description",
  "default",
  "deprecated",
  "readOnly",
  "writeOnly",
  "examples"
];
uo.contentVocabulary = [
  "contentMediaType",
  "contentEncoding",
  "contentSchema"
];
Object.defineProperty(Xg, "__esModule", { value: !0 });
const I7 = Qg, j7 = t0, k7 = ld, M7 = y0, N7 = b0, D7 = E0, L7 = pd, f$ = uo, q7 = [
  M7.default,
  I7.default,
  j7.default,
  (0, k7.default)(!0),
  L7.default,
  f$.metadataVocabulary,
  f$.contentVocabulary,
  N7.default,
  D7.default
];
Xg.default = q7;
var hd = {}, DP = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DiscrError = void 0, function(t) {
    t.Tag = "tag", t.Mapping = "mapping";
  }(e.DiscrError || (e.DiscrError = {}));
})(DP);
Object.defineProperty(hd, "__esModule", { value: !0 });
const Fa = ht, By = DP, d$ = Nr, F7 = Pt, U7 = {
  message: ({ params: { discrError: e, tagName: t } }) => e === By.DiscrError.Tag ? `tag "${t}" must be string` : `value of tag "${t}" must be in oneOf`,
  params: ({ params: { discrError: e, tag: t, tagName: r } }) => (0, Fa._)`{error: ${e}, tag: ${r}, tagValue: ${t}}`
}, B7 = {
  keyword: "discriminator",
  type: "object",
  schemaType: "object",
  error: U7,
  code(e) {
    const { gen: t, data: r, schema: i, parentSchema: n, it: s } = e, { oneOf: a } = n;
    if (!s.opts.discriminator)
      throw new Error("discriminator: requires discriminator option");
    const u = i.propertyName;
    if (typeof u != "string")
      throw new Error("discriminator: requires propertyName");
    if (i.mapping)
      throw new Error("discriminator: mapping is not supported");
    if (!a)
      throw new Error("discriminator: requires oneOf keyword");
    const c = t.let("valid", !1), l = t.const("tag", (0, Fa._)`${r}${(0, Fa.getProperty)(u)}`);
    t.if((0, Fa._)`typeof ${l} == "string"`, () => d(), () => e.error(!1, { discrError: By.DiscrError.Tag, tag: l, tagName: u })), e.ok(c);
    function d() {
      const v = h();
      t.if(!1);
      for (const y in v)
        t.elseIf((0, Fa._)`${l} === ${y}`), t.assign(c, p(v[y]));
      t.else(), e.error(!1, { discrError: By.DiscrError.Mapping, tag: l, tagName: u }), t.endIf();
    }
    function p(v) {
      const y = t.name("valid"), g = e.subschema({ keyword: "oneOf", schemaProp: v }, y);
      return e.mergeEvaluated(g, Fa.Name), y;
    }
    function h() {
      var v;
      const y = {}, g = m(n);
      let _ = !0;
      for (let E = 0; E < a.length; E++) {
        let A = a[E];
        A != null && A.$ref && !(0, F7.schemaHasRulesButRef)(A, s.self.RULES) && (A = d$.resolveRef.call(s.self, s.schemaEnv.root, s.baseId, A == null ? void 0 : A.$ref), A instanceof d$.SchemaEnv && (A = A.schema));
        const R = (v = A == null ? void 0 : A.properties) === null || v === void 0 ? void 0 : v[u];
        if (typeof R != "object")
          throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${u}"`);
        _ = _ && (g || m(A)), w(R, E);
      }
      if (!_)
        throw new Error(`discriminator: "${u}" must be required`);
      return y;
      function m({ required: E }) {
        return Array.isArray(E) && E.includes(u);
      }
      function w(E, A) {
        if (E.const)
          $(E.const, A);
        else if (E.enum)
          for (const R of E.enum)
            $(R, A);
        else
          throw new Error(`discriminator: "properties/${u}" must have "const" or "enum"`);
      }
      function $(E, A) {
        if (typeof E != "string" || E in y)
          throw new Error(`discriminator: "${u}" values must be unique strings`);
        y[E] = A;
      }
    }
  }
};
hd.default = B7;
var S0 = {};
const V7 = "https://json-schema.org/draft/2020-12/schema", Z7 = "https://json-schema.org/draft/2020-12/schema", z7 = {
  "https://json-schema.org/draft/2020-12/vocab/core": !0,
  "https://json-schema.org/draft/2020-12/vocab/applicator": !0,
  "https://json-schema.org/draft/2020-12/vocab/unevaluated": !0,
  "https://json-schema.org/draft/2020-12/vocab/validation": !0,
  "https://json-schema.org/draft/2020-12/vocab/meta-data": !0,
  "https://json-schema.org/draft/2020-12/vocab/format-annotation": !0,
  "https://json-schema.org/draft/2020-12/vocab/content": !0
}, W7 = "meta", H7 = "Core and Validation specifications meta-schema", G7 = [
  {
    $ref: "meta/core"
  },
  {
    $ref: "meta/applicator"
  },
  {
    $ref: "meta/unevaluated"
  },
  {
    $ref: "meta/validation"
  },
  {
    $ref: "meta/meta-data"
  },
  {
    $ref: "meta/format-annotation"
  },
  {
    $ref: "meta/content"
  }
], K7 = [
  "object",
  "boolean"
], Y7 = "This meta-schema also defines keywords that have appeared in previous drafts in order to prevent incompatible extensions as they remain in common use.", J7 = {
  definitions: {
    $comment: '"definitions" has been replaced by "$defs".',
    type: "object",
    additionalProperties: {
      $dynamicRef: "#meta"
    },
    deprecated: !0,
    default: {}
  },
  dependencies: {
    $comment: '"dependencies" has been split and replaced by "dependentSchemas" and "dependentRequired" in order to serve their differing semantics.',
    type: "object",
    additionalProperties: {
      anyOf: [
        {
          $dynamicRef: "#meta"
        },
        {
          $ref: "meta/validation#/$defs/stringArray"
        }
      ]
    },
    deprecated: !0,
    default: {}
  },
  $recursiveAnchor: {
    $comment: '"$recursiveAnchor" has been replaced by "$dynamicAnchor".',
    $ref: "meta/core#/$defs/anchorString",
    deprecated: !0
  },
  $recursiveRef: {
    $comment: '"$recursiveRef" has been replaced by "$dynamicRef".',
    $ref: "meta/core#/$defs/uriReferenceString",
    deprecated: !0
  }
}, X7 = {
  $schema: V7,
  $id: Z7,
  $vocabulary: z7,
  $dynamicAnchor: W7,
  title: H7,
  allOf: G7,
  type: K7,
  $comment: Y7,
  properties: J7
}, Q7 = "https://json-schema.org/draft/2020-12/schema", eV = "https://json-schema.org/draft/2020-12/meta/applicator", tV = {
  "https://json-schema.org/draft/2020-12/vocab/applicator": !0
}, rV = "meta", nV = "Applicator vocabulary meta-schema", iV = [
  "object",
  "boolean"
], sV = {
  prefixItems: {
    $ref: "#/$defs/schemaArray"
  },
  items: {
    $dynamicRef: "#meta"
  },
  contains: {
    $dynamicRef: "#meta"
  },
  additionalProperties: {
    $dynamicRef: "#meta"
  },
  properties: {
    type: "object",
    additionalProperties: {
      $dynamicRef: "#meta"
    },
    default: {}
  },
  patternProperties: {
    type: "object",
    additionalProperties: {
      $dynamicRef: "#meta"
    },
    propertyNames: {
      format: "regex"
    },
    default: {}
  },
  dependentSchemas: {
    type: "object",
    additionalProperties: {
      $dynamicRef: "#meta"
    },
    default: {}
  },
  propertyNames: {
    $dynamicRef: "#meta"
  },
  if: {
    $dynamicRef: "#meta"
  },
  then: {
    $dynamicRef: "#meta"
  },
  else: {
    $dynamicRef: "#meta"
  },
  allOf: {
    $ref: "#/$defs/schemaArray"
  },
  anyOf: {
    $ref: "#/$defs/schemaArray"
  },
  oneOf: {
    $ref: "#/$defs/schemaArray"
  },
  not: {
    $dynamicRef: "#meta"
  }
}, aV = {
  schemaArray: {
    type: "array",
    minItems: 1,
    items: {
      $dynamicRef: "#meta"
    }
  }
}, oV = {
  $schema: Q7,
  $id: eV,
  $vocabulary: tV,
  $dynamicAnchor: rV,
  title: nV,
  type: iV,
  properties: sV,
  $defs: aV
}, uV = "https://json-schema.org/draft/2020-12/schema", cV = "https://json-schema.org/draft/2020-12/meta/unevaluated", lV = {
  "https://json-schema.org/draft/2020-12/vocab/unevaluated": !0
}, fV = "meta", dV = "Unevaluated applicator vocabulary meta-schema", pV = [
  "object",
  "boolean"
], hV = {
  unevaluatedItems: {
    $dynamicRef: "#meta"
  },
  unevaluatedProperties: {
    $dynamicRef: "#meta"
  }
}, mV = {
  $schema: uV,
  $id: cV,
  $vocabulary: lV,
  $dynamicAnchor: fV,
  title: dV,
  type: pV,
  properties: hV
}, yV = "https://json-schema.org/draft/2020-12/schema", gV = "https://json-schema.org/draft/2020-12/meta/content", vV = {
  "https://json-schema.org/draft/2020-12/vocab/content": !0
}, bV = "meta", _V = "Content vocabulary meta-schema", wV = [
  "object",
  "boolean"
], $V = {
  contentEncoding: {
    type: "string"
  },
  contentMediaType: {
    type: "string"
  },
  contentSchema: {
    $dynamicRef: "#meta"
  }
}, EV = {
  $schema: yV,
  $id: gV,
  $vocabulary: vV,
  $dynamicAnchor: bV,
  title: _V,
  type: wV,
  properties: $V
}, xV = "https://json-schema.org/draft/2020-12/schema", OV = "https://json-schema.org/draft/2020-12/meta/core", PV = {
  "https://json-schema.org/draft/2020-12/vocab/core": !0
}, SV = "meta", AV = "Core vocabulary meta-schema", CV = [
  "object",
  "boolean"
], RV = {
  $id: {
    $ref: "#/$defs/uriReferenceString",
    $comment: "Non-empty fragments not allowed.",
    pattern: "^[^#]*#?$"
  },
  $schema: {
    $ref: "#/$defs/uriString"
  },
  $ref: {
    $ref: "#/$defs/uriReferenceString"
  },
  $anchor: {
    $ref: "#/$defs/anchorString"
  },
  $dynamicRef: {
    $ref: "#/$defs/uriReferenceString"
  },
  $dynamicAnchor: {
    $ref: "#/$defs/anchorString"
  },
  $vocabulary: {
    type: "object",
    propertyNames: {
      $ref: "#/$defs/uriString"
    },
    additionalProperties: {
      type: "boolean"
    }
  },
  $comment: {
    type: "string"
  },
  $defs: {
    type: "object",
    additionalProperties: {
      $dynamicRef: "#meta"
    }
  }
}, TV = {
  anchorString: {
    type: "string",
    pattern: "^[A-Za-z_][-A-Za-z0-9._]*$"
  },
  uriString: {
    type: "string",
    format: "uri"
  },
  uriReferenceString: {
    type: "string",
    format: "uri-reference"
  }
}, IV = {
  $schema: xV,
  $id: OV,
  $vocabulary: PV,
  $dynamicAnchor: SV,
  title: AV,
  type: CV,
  properties: RV,
  $defs: TV
}, jV = "https://json-schema.org/draft/2020-12/schema", kV = "https://json-schema.org/draft/2020-12/meta/format-annotation", MV = {
  "https://json-schema.org/draft/2020-12/vocab/format-annotation": !0
}, NV = "meta", DV = "Format vocabulary meta-schema for annotation results", LV = [
  "object",
  "boolean"
], qV = {
  format: {
    type: "string"
  }
}, FV = {
  $schema: jV,
  $id: kV,
  $vocabulary: MV,
  $dynamicAnchor: NV,
  title: DV,
  type: LV,
  properties: qV
}, UV = "https://json-schema.org/draft/2020-12/schema", BV = "https://json-schema.org/draft/2020-12/meta/meta-data", VV = {
  "https://json-schema.org/draft/2020-12/vocab/meta-data": !0
}, ZV = "meta", zV = "Meta-data vocabulary meta-schema", WV = [
  "object",
  "boolean"
], HV = {
  title: {
    type: "string"
  },
  description: {
    type: "string"
  },
  default: !0,
  deprecated: {
    type: "boolean",
    default: !1
  },
  readOnly: {
    type: "boolean",
    default: !1
  },
  writeOnly: {
    type: "boolean",
    default: !1
  },
  examples: {
    type: "array",
    items: !0
  }
}, GV = {
  $schema: UV,
  $id: BV,
  $vocabulary: VV,
  $dynamicAnchor: ZV,
  title: zV,
  type: WV,
  properties: HV
}, KV = "https://json-schema.org/draft/2020-12/schema", YV = "https://json-schema.org/draft/2020-12/meta/validation", JV = {
  "https://json-schema.org/draft/2020-12/vocab/validation": !0
}, XV = "meta", QV = "Validation vocabulary meta-schema", eZ = [
  "object",
  "boolean"
], tZ = {
  type: {
    anyOf: [
      {
        $ref: "#/$defs/simpleTypes"
      },
      {
        type: "array",
        items: {
          $ref: "#/$defs/simpleTypes"
        },
        minItems: 1,
        uniqueItems: !0
      }
    ]
  },
  const: !0,
  enum: {
    type: "array",
    items: !0
  },
  multipleOf: {
    type: "number",
    exclusiveMinimum: 0
  },
  maximum: {
    type: "number"
  },
  exclusiveMaximum: {
    type: "number"
  },
  minimum: {
    type: "number"
  },
  exclusiveMinimum: {
    type: "number"
  },
  maxLength: {
    $ref: "#/$defs/nonNegativeInteger"
  },
  minLength: {
    $ref: "#/$defs/nonNegativeIntegerDefault0"
  },
  pattern: {
    type: "string",
    format: "regex"
  },
  maxItems: {
    $ref: "#/$defs/nonNegativeInteger"
  },
  minItems: {
    $ref: "#/$defs/nonNegativeIntegerDefault0"
  },
  uniqueItems: {
    type: "boolean",
    default: !1
  },
  maxContains: {
    $ref: "#/$defs/nonNegativeInteger"
  },
  minContains: {
    $ref: "#/$defs/nonNegativeInteger",
    default: 1
  },
  maxProperties: {
    $ref: "#/$defs/nonNegativeInteger"
  },
  minProperties: {
    $ref: "#/$defs/nonNegativeIntegerDefault0"
  },
  required: {
    $ref: "#/$defs/stringArray"
  },
  dependentRequired: {
    type: "object",
    additionalProperties: {
      $ref: "#/$defs/stringArray"
    }
  }
}, rZ = {
  nonNegativeInteger: {
    type: "integer",
    minimum: 0
  },
  nonNegativeIntegerDefault0: {
    $ref: "#/$defs/nonNegativeInteger",
    default: 0
  },
  simpleTypes: {
    enum: [
      "array",
      "boolean",
      "integer",
      "null",
      "number",
      "object",
      "string"
    ]
  },
  stringArray: {
    type: "array",
    items: {
      type: "string"
    },
    uniqueItems: !0,
    default: []
  }
}, nZ = {
  $schema: KV,
  $id: YV,
  $vocabulary: JV,
  $dynamicAnchor: XV,
  title: QV,
  type: eZ,
  properties: tZ,
  $defs: rZ
};
Object.defineProperty(S0, "__esModule", { value: !0 });
const iZ = X7, sZ = oV, aZ = mV, oZ = EV, uZ = IV, cZ = FV, lZ = GV, fZ = nZ, dZ = ["/properties"];
function pZ(e) {
  return [
    iZ,
    sZ,
    aZ,
    oZ,
    uZ,
    t(this, cZ),
    lZ,
    t(this, fZ)
  ].forEach((r) => this.addMetaSchema(r, void 0, !1)), this;
  function t(r, i) {
    return e ? r.$dataMetaSchema(i, dZ) : i;
  }
}
S0.default = pZ;
(function(e, t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.MissingRefError = t.ValidationError = t.CodeGen = t.Name = t.nil = t.stringify = t.str = t._ = t.KeywordCxt = void 0;
  const r = Xa, i = Xg, n = hd, s = S0, a = "https://json-schema.org/draft/2020-12/schema";
  class u extends r.default {
    constructor(v = {}) {
      super({
        ...v,
        dynamicRef: !0,
        next: !0,
        unevaluated: !0
      });
    }
    _addVocabularies() {
      super._addVocabularies(), i.default.forEach((v) => this.addVocabulary(v)), this.opts.discriminator && this.addKeyword(n.default);
    }
    _addDefaultMetaSchema() {
      super._addDefaultMetaSchema();
      const { $data: v, meta: y } = this.opts;
      y && (s.default.call(this, v), this.refs["http://json-schema.org/schema"] = a);
    }
    defaultMeta() {
      return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(a) ? a : void 0);
    }
  }
  e.exports = t = u, Object.defineProperty(t, "__esModule", { value: !0 }), t.default = u;
  var c = jn;
  Object.defineProperty(t, "KeywordCxt", { enumerable: !0, get: function() {
    return c.KeywordCxt;
  } });
  var l = ht;
  Object.defineProperty(t, "_", { enumerable: !0, get: function() {
    return l._;
  } }), Object.defineProperty(t, "str", { enumerable: !0, get: function() {
    return l.str;
  } }), Object.defineProperty(t, "stringify", { enumerable: !0, get: function() {
    return l.stringify;
  } }), Object.defineProperty(t, "nil", { enumerable: !0, get: function() {
    return l.nil;
  } }), Object.defineProperty(t, "Name", { enumerable: !0, get: function() {
    return l.Name;
  } }), Object.defineProperty(t, "CodeGen", { enumerable: !0, get: function() {
    return l.CodeGen;
  } });
  var d = ac;
  Object.defineProperty(t, "ValidationError", { enumerable: !0, get: function() {
    return d.default;
  } });
  var p = oc;
  Object.defineProperty(t, "MissingRefError", { enumerable: !0, get: function() {
    return p.default;
  } });
})(Ny, Ny.exports);
var hZ = Ny.exports, Vy = { exports: {} }, A0 = {}, C0 = {};
Object.defineProperty(C0, "__esModule", { value: !0 });
const mZ = ii, yZ = [
  "$schema",
  "id",
  "$defs",
  { keyword: "$comment" },
  "definitions",
  mZ.default
];
C0.default = yZ;
var R0 = {}, T0 = {};
Object.defineProperty(T0, "__esModule", { value: !0 });
const Zy = Xa, gZ = ht, Qi = gZ.operators, zy = {
  maximum: {
    exclusive: "exclusiveMaximum",
    ops: [
      { okStr: "<=", ok: Qi.LTE, fail: Qi.GT },
      { okStr: "<", ok: Qi.LT, fail: Qi.GTE }
    ]
  },
  minimum: {
    exclusive: "exclusiveMinimum",
    ops: [
      { okStr: ">=", ok: Qi.GTE, fail: Qi.LT },
      { okStr: ">", ok: Qi.GT, fail: Qi.LTE }
    ]
  }
}, vZ = {
  message: (e) => Zy.str`must be ${Wy(e).okStr} ${e.schemaCode}`,
  params: (e) => Zy._`{comparison: ${Wy(e).okStr}, limit: ${e.schemaCode}}`
}, bZ = {
  keyword: Object.keys(zy),
  type: "number",
  schemaType: "number",
  $data: !0,
  error: vZ,
  code(e) {
    const { data: t, schemaCode: r } = e;
    e.fail$data(Zy._`${t} ${Wy(e).fail} ${r} || isNaN(${t})`);
  }
};
function Wy(e) {
  var t;
  const r = e.keyword, i = !((t = e.parentSchema) === null || t === void 0) && t[zy[r].exclusive] ? 1 : 0;
  return zy[r].ops[i];
}
T0.default = bZ;
var I0 = {};
Object.defineProperty(I0, "__esModule", { value: !0 });
const p$ = {
  exclusiveMaximum: "maximum",
  exclusiveMinimum: "minimum"
}, _Z = {
  keyword: Object.keys(p$),
  type: "number",
  schemaType: "boolean",
  code({ keyword: e, parentSchema: t }) {
    const r = p$[e];
    if (t[r] === void 0)
      throw new Error(`${e} can only be used with ${r}`);
  }
};
I0.default = _Z;
Object.defineProperty(R0, "__esModule", { value: !0 });
const wZ = T0, $Z = I0, EZ = td, xZ = rd, OZ = nd, PZ = id, SZ = sd, AZ = ad, CZ = od, RZ = ud, TZ = cd, IZ = [
  // number
  wZ.default,
  $Z.default,
  EZ.default,
  // string
  xZ.default,
  OZ.default,
  // object
  PZ.default,
  SZ.default,
  // array
  AZ.default,
  CZ.default,
  // any
  { keyword: "type", schemaType: ["string", "array"] },
  { keyword: "nullable", schemaType: "boolean" },
  RZ.default,
  TZ.default
];
R0.default = IZ;
Object.defineProperty(A0, "__esModule", { value: !0 });
const jZ = C0, kZ = R0, MZ = ld, NZ = pd, DZ = ["title", "description", "default"], LZ = [
  jZ.default,
  kZ.default,
  MZ.default(),
  NZ.default,
  DZ
];
A0.default = LZ;
const qZ = "http://json-schema.org/draft-04/schema#", FZ = "http://json-schema.org/draft-04/schema#", UZ = "Core schema meta-schema", BZ = {
  schemaArray: {
    type: "array",
    minItems: 1,
    items: {
      $ref: "#"
    }
  },
  positiveInteger: {
    type: "integer",
    minimum: 0
  },
  positiveIntegerDefault0: {
    allOf: [
      {
        $ref: "#/definitions/positiveInteger"
      },
      {
        default: 0
      }
    ]
  },
  simpleTypes: {
    enum: [
      "array",
      "boolean",
      "integer",
      "null",
      "number",
      "object",
      "string"
    ]
  },
  stringArray: {
    type: "array",
    items: {
      type: "string"
    },
    minItems: 1,
    uniqueItems: !0
  }
}, VZ = "object", ZZ = {
  id: {
    type: "string",
    format: "uri"
  },
  $schema: {
    type: "string",
    format: "uri"
  },
  title: {
    type: "string"
  },
  description: {
    type: "string"
  },
  default: {},
  multipleOf: {
    type: "number",
    minimum: 0,
    exclusiveMinimum: !0
  },
  maximum: {
    type: "number"
  },
  exclusiveMaximum: {
    type: "boolean",
    default: !1
  },
  minimum: {
    type: "number"
  },
  exclusiveMinimum: {
    type: "boolean",
    default: !1
  },
  maxLength: {
    $ref: "#/definitions/positiveInteger"
  },
  minLength: {
    $ref: "#/definitions/positiveIntegerDefault0"
  },
  pattern: {
    type: "string",
    format: "regex"
  },
  additionalItems: {
    anyOf: [
      {
        type: "boolean"
      },
      {
        $ref: "#"
      }
    ],
    default: {}
  },
  items: {
    anyOf: [
      {
        $ref: "#"
      },
      {
        $ref: "#/definitions/schemaArray"
      }
    ],
    default: {}
  },
  maxItems: {
    $ref: "#/definitions/positiveInteger"
  },
  minItems: {
    $ref: "#/definitions/positiveIntegerDefault0"
  },
  uniqueItems: {
    type: "boolean",
    default: !1
  },
  maxProperties: {
    $ref: "#/definitions/positiveInteger"
  },
  minProperties: {
    $ref: "#/definitions/positiveIntegerDefault0"
  },
  required: {
    $ref: "#/definitions/stringArray"
  },
  additionalProperties: {
    anyOf: [
      {
        type: "boolean"
      },
      {
        $ref: "#"
      }
    ],
    default: {}
  },
  definitions: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    default: {}
  },
  properties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    default: {}
  },
  patternProperties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    default: {}
  },
  dependencies: {
    type: "object",
    additionalProperties: {
      anyOf: [
        {
          $ref: "#"
        },
        {
          $ref: "#/definitions/stringArray"
        }
      ]
    }
  },
  enum: {
    type: "array",
    minItems: 1,
    uniqueItems: !0
  },
  type: {
    anyOf: [
      {
        $ref: "#/definitions/simpleTypes"
      },
      {
        type: "array",
        items: {
          $ref: "#/definitions/simpleTypes"
        },
        minItems: 1,
        uniqueItems: !0
      }
    ]
  },
  allOf: {
    $ref: "#/definitions/schemaArray"
  },
  anyOf: {
    $ref: "#/definitions/schemaArray"
  },
  oneOf: {
    $ref: "#/definitions/schemaArray"
  },
  not: {
    $ref: "#"
  }
}, zZ = {
  exclusiveMaximum: [
    "maximum"
  ],
  exclusiveMinimum: [
    "minimum"
  ]
}, WZ = {
  id: qZ,
  $schema: FZ,
  description: UZ,
  definitions: BZ,
  type: VZ,
  properties: ZZ,
  dependencies: zZ,
  default: {}
};
(function(e, t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.CodeGen = t.Name = t.nil = t.stringify = t.str = t._ = t.KeywordCxt = void 0;
  const r = Xa, i = A0, n = hd, s = WZ, a = ["/properties"], u = "http://json-schema.org/draft-04/schema";
  class c extends r.default {
    constructor(h = {}) {
      super({
        ...h,
        schemaId: "id"
      });
    }
    _addVocabularies() {
      super._addVocabularies(), i.default.forEach((h) => this.addVocabulary(h)), this.opts.discriminator && this.addKeyword(n.default);
    }
    _addDefaultMetaSchema() {
      if (super._addDefaultMetaSchema(), !this.opts.meta)
        return;
      const h = this.opts.$data ? this.$dataMetaSchema(s, a) : s;
      this.addMetaSchema(h, u, !1), this.refs["http://json-schema.org/schema"] = u;
    }
    defaultMeta() {
      return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(u) ? u : void 0);
    }
  }
  e.exports = t = c, Object.defineProperty(t, "__esModule", { value: !0 }), t.default = c;
  var l = Xa;
  Object.defineProperty(t, "KeywordCxt", { enumerable: !0, get: function() {
    return l.KeywordCxt;
  } });
  var d = Xa;
  Object.defineProperty(t, "_", { enumerable: !0, get: function() {
    return d._;
  } }), Object.defineProperty(t, "str", { enumerable: !0, get: function() {
    return d.str;
  } }), Object.defineProperty(t, "stringify", { enumerable: !0, get: function() {
    return d.stringify;
  } }), Object.defineProperty(t, "nil", { enumerable: !0, get: function() {
    return d.nil;
  } }), Object.defineProperty(t, "Name", { enumerable: !0, get: function() {
    return d.Name;
  } }), Object.defineProperty(t, "CodeGen", { enumerable: !0, get: function() {
    return d.CodeGen;
  } });
})(Vy, Vy.exports);
var HZ = Vy.exports;
const { openapi: em } = s8, { ono: GZ } = Nn, KZ = EF, YZ = hZ, JZ = HZ, { getSpecificationName: XZ } = ui, QZ = 20, ez = 5e6;
var LP = tz;
function tz(e, t) {
  let r, i;
  if (e.swagger)
    i = em.v2, r = tm();
  else if (e.openapi.startsWith("3.1")) {
    i = em.v31;
    const s = i.$defs.schema;
    delete s.$dynamicAnchor, i.$defs.components.properties.schemas.additionalProperties = s, i.$defs.header.dependentSchemas.schema.properties.schema = s, i.$defs["media-type"].properties.schema = s, i.$defs.parameter.properties.schema = s, r = tm(!1);
  } else
    i = em.v3, r = tm();
  if (!r.validate(i, e)) {
    const s = r.errors;
    let a = 0, u = rz(s);
    if (u.length >= QZ)
      try {
        JSON.stringify(e).length >= ez && (a = u.length - 20, u = u.slice(0, 20));
      } catch {
      }
    let c = `${XZ(e)} schema validation failed.
`;
    throw c += `
`, c += KZ(i, e, u, {
      colorize: t.validate.colorizeErrors,
      indent: 2
    }), a && (c += `

`, c += `Plus an additional ${a} errors. Please resolve the above and re-run validation to see more.`), GZ.syntax(s, { details: s }, c);
  }
}
function tm(e = !0) {
  const t = {
    allErrors: !0,
    strict: !1,
    validateFormats: !1
  };
  return e ? new JZ(t) : new YZ(t);
}
function rz(e) {
  const t = /* @__PURE__ */ new Map();
  return e.forEach((r) => {
    if (["must have required property '$ref'", "must match exactly one schema in oneOf"].includes(r.message))
      return;
    if (t.size) {
      if (t.has(r.instancePath))
        return;
    } else {
      t.set(r.instancePath, r);
      return;
    }
    let i = !0;
    t.forEach((n) => {
      n.instancePath.includes(r.instancePath) && (i = !1);
    }), i && t.set(r.instancePath, r);
  }), t.size ? [...t.values()] : e;
}
var qP = [
  "get",
  "put",
  "post",
  "delete",
  "options",
  "head",
  "patch"
];
const nz = qP, { ono: Si } = Nn, iz = ui;
var sz = az;
function az(e) {
  const t = [];
  Object.keys(e.paths || {}).forEach((r) => {
    const i = e.paths[r], n = `/paths${r}`;
    i && r.indexOf("/") === 0 && oz(e, i, n, t);
  }), e.openapi.startsWith("3.0") && e.components && Object.keys(e.components).forEach((r) => {
    Object.keys(e.components[r]).forEach((i) => {
      const n = `/components/${r}/${i}`;
      if (!/^[a-zA-Z0-9.\-_]+$/.test(i))
        throw Si.syntax(
          `Validation failed. ${n} has an invalid name. Component names should match against: /^[a-zA-Z0-9.-_]+$/`
        );
    });
  });
}
function oz(e, t, r, i) {
  [...nz, "trace"].forEach((n) => {
    const s = t[n], a = `${r}/${n}`;
    if (s) {
      const u = s.operationId;
      if (u)
        if (i.indexOf(u) === -1)
          i.push(u);
        else
          throw Si.syntax(`Validation failed. Duplicate operation id '${u}'`);
      uz(e, t, r, s, a), Object.keys(s.responses || {}).forEach((c) => {
        const l = s.responses[c], d = `${a}/responses/${c}`;
        fz(c, l || {}, d);
      });
    }
  });
}
function uz(e, t, r, i, n) {
  const s = t.parameters || [], a = i.parameters || [];
  try {
    h$(s);
  } catch (c) {
    throw Si.syntax(c, `Validation failed. ${r} has duplicate parameters`);
  }
  try {
    h$(a);
  } catch (c) {
    throw Si.syntax(c, `Validation failed. ${n} has duplicate parameters`);
  }
  const u = s.reduce((c, l) => (c.some((p) => p.in === l.in && p.name === l.name) || c.push(l), c), a.slice());
  cz(u, r, n), lz(u, e, i, n);
}
function cz(e, t, r) {
  const i = [...new Set(t.match(iz.swaggerParamRegExp) || [])];
  if (e.filter((n) => n.in === "path").forEach((n) => {
    if (n.required !== !0)
      throw Si.syntax(
        `Validation failed. Path parameters cannot be optional. Set required=true for the "${n.name}" parameter at ${r}`
      );
    const s = i.indexOf(`{${n.name}}`);
    if (s === -1)
      throw Si.syntax(
        `Validation failed. ${r} has a path parameter named "${n.name}", but there is no corresponding {${n.name}} in the path string`
      );
    i.splice(s, 1);
  }), i.length > 0)
    throw Si.syntax(`Validation failed. ${r} is missing path parameter(s) for ${i}`);
}
function lz(e, t, r, i) {
  e.forEach((n) => {
    if (!n.schema && n.content)
      return;
    const s = `${i}/parameters/${n.name}`;
    Fl(n.schema, s);
  });
}
function h$(e) {
  for (let t = 0; t < e.length - 1; t++) {
    const r = e[t];
    for (let i = t + 1; i < e.length; i++) {
      const n = e[i];
      if (r.name === n.name && r.in === n.in)
        throw Si.syntax(`Validation failed. Found multiple ${r.in} parameters named "${r.name}"`);
    }
  }
}
function fz(e, t, r) {
  Object.keys(t.headers || {}).forEach((i) => {
    const n = t.headers[i], s = `${r}/headers/${i}`;
    n.schema ? Fl(n.schema, s) : n.content && Object.keys(n.content).forEach((a) => {
      n.content[a].schema && Fl(n.content[a].schema || {}, `${s}/content/${a}/schema`);
    });
  }), t.content && Object.keys(t.content).forEach((i) => {
    t.content[i].schema && Fl(t.content[i].schema || {}, `${r}/content/${i}/schema`);
  });
}
function Fl(e, t) {
  if (e.type === "array" && !e.items)
    throw Si.syntax(`Validation failed. ${t} is an array, so it must include an "items" schema`);
}
const dz = qP, { ono: br } = Nn, pz = ui, Hy = ["array", "boolean", "integer", "number", "string"], FP = ["array", "boolean", "integer", "number", "string", "object", "null", void 0];
var hz = mz;
function mz(e) {
  const t = [];
  Object.keys(e.paths || {}).forEach((r) => {
    const i = e.paths[r], n = `/paths${r}`;
    i && r.indexOf("/") === 0 && yz(e, i, n, t);
  }), Object.keys(e.definitions || {}).forEach((r) => {
    const i = e.definitions[r], n = `/definitions/${r}`;
    if (!/^[a-zA-Z0-9.\-_]+$/.test(r))
      throw br.syntax(
        `Validation failed. ${n} has an invalid name. Definition names should match against: /^[a-zA-Z0-9.-_]+$/`
      );
    UP(i, n);
  });
}
function yz(e, t, r, i) {
  dz.forEach((n) => {
    const s = t[n], a = `${r}/${n}`;
    if (s) {
      const u = s.operationId;
      if (u)
        if (i.indexOf(u) === -1)
          i.push(u);
        else
          throw br.syntax(`Validation failed. Duplicate operation id '${u}'`);
      gz(e, t, r, s, a), Object.keys(s.responses || {}).forEach((c) => {
        const l = s.responses[c], d = `${a}/responses/${c}`;
        wz(c, l || {}, d);
      });
    }
  });
}
function gz(e, t, r, i, n) {
  const s = t.parameters || [], a = i.parameters || [];
  try {
    m$(s);
  } catch (c) {
    throw br.syntax(c, `Validation failed. ${r} has duplicate parameters`);
  }
  try {
    m$(a);
  } catch (c) {
    throw br.syntax(c, `Validation failed. ${n} has duplicate parameters`);
  }
  const u = s.reduce((c, l) => (c.some((p) => p.in === l.in && p.name === l.name) || c.push(l), c), a.slice());
  vz(u, n), bz(u, r, n), _z(u, e, i, n);
}
function vz(e, t) {
  const r = e.filter((n) => n.in === "body"), i = e.filter((n) => n.in === "formData");
  if (r.length > 1)
    throw br.syntax(
      `Validation failed. ${t} has ${r.length} body parameters. Only one is allowed.`
    );
  if (r.length > 0 && i.length > 0)
    throw br.syntax(
      `Validation failed. ${t} has body parameters and formData parameters. Only one or the other is allowed.`
    );
}
function bz(e, t, r) {
  const i = t.match(pz.swaggerParamRegExp) || [];
  for (let n = 0; n < i.length; n++)
    for (let s = n + 1; s < i.length; s++)
      if (i[n] === i[s])
        throw br.syntax(`Validation failed. ${r} has multiple path placeholders named ${i[n]}`);
  if (e.filter((n) => n.in === "path").forEach((n) => {
    if (n.required !== !0)
      throw br.syntax(
        `Validation failed. Path parameters cannot be optional. Set required=true for the "${n.name}" parameter at ${r}`
      );
    const s = i.indexOf(`{${n.name}}`);
    if (s === -1)
      throw br.syntax(
        `Validation failed. ${r} has a path parameter named "${n.name}", but there is no corresponding {${n.name}} in the path string`
      );
    i.splice(s, 1);
  }), i.length > 0)
    throw br.syntax(`Validation failed. ${r} is missing path parameter(s) for ${i}`);
}
function _z(e, t, r, i) {
  e.forEach((n) => {
    const s = `${i}/parameters/${n.name}`;
    let a, u;
    switch (n.in) {
      case "body":
        a = n.schema, u = FP;
        break;
      case "formData":
        a = n, u = Hy.concat("file");
        break;
      default:
        a = n, u = Hy;
    }
    if (Gy(a, s, u), UP(a, s), a.type === "file") {
      const c = /multipart\/(.*\+)?form-data/, l = /application\/(.*\+)?x-www-form-urlencoded/;
      if (!(r.consumes || t.consumes || []).some((h) => c.test(h) || l.test(h)))
        throw br.syntax(
          `Validation failed. ${i} has a file parameter, so it must consume multipart/form-data or application/x-www-form-urlencoded`
        );
    }
  });
}
function m$(e) {
  for (let t = 0; t < e.length - 1; t++) {
    const r = e[t];
    for (let i = t + 1; i < e.length; i++) {
      const n = e[i];
      if (r.name === n.name && r.in === n.in)
        throw br.syntax(`Validation failed. Found multiple ${r.in} parameters named "${r.name}"`);
    }
  }
}
function wz(e, t, r) {
  if (e !== "default" && (e < 100 || e > 599))
    throw br.syntax(`Validation failed. ${r} has an invalid response code (${e})`);
  if (Object.keys(t.headers || {}).forEach((i) => {
    const n = t.headers[i], s = `${r}/headers/${i}`;
    Gy(n, s, Hy);
  }), t.schema) {
    const i = FP.concat("file");
    if (i.indexOf(t.schema.type) === -1)
      throw br.syntax(
        `Validation failed. ${r} has an invalid response schema type (${t.schema.type})`
      );
    Gy(t.schema, `${r}/schema`, i);
  }
}
function Gy(e, t, r) {
  if (r.indexOf(e.type) === -1)
    throw br.syntax(`Validation failed. ${t} has an invalid type (${e.type})`);
  if (e.type === "array" && !e.items)
    throw br.syntax(`Validation failed. ${t} is an array, so it must include an "items" schema`);
}
function UP(e, t) {
  function r(i, n) {
    i.properties && Object.keys(i.properties).forEach((s) => {
      i.properties.hasOwnProperty(s) && (n[s] = i.properties[s]);
    }), i.allOf && i.allOf.forEach((s) => {
      r(s, n);
    });
  }
  if (e.required && Array.isArray(e.required)) {
    const i = {};
    r(e, i), e.required.forEach((n) => {
      if (!i[n])
        throw br.syntax(
          `Validation failed. Property '${n}' listed as required but does not exist in '${t}'`
        );
    });
  }
}
const $z = sz, Ez = hz;
var BP = function(t) {
  return t.openapi ? $z(t) : Ez(t);
};
const Ky = MO, xz = ui, Oz = LP, Pz = BP;
var Sz = md;
function md(e) {
  Ky.call(this, md.defaults), Ky.apply(this, arguments);
}
md.defaults = {
  /**
   * Determines how the API definition will be validated.
   *
   * You can add additional validators of your own, replace an existing one with
   * your own implemenation, or disable any validator by setting it to false.
   */
  validate: {
    colorizeErrors: !1,
    schema: Oz,
    spec: Pz
  }
};
xz.inherits(md, Ky);
const { ono: Pn } = Nn, oa = yq, Az = Ox, VP = NO, $f = QE, ZP = Sz, zP = ui, Cz = LP, Rz = BP;
function Mi() {
  oa.apply(this, arguments);
}
zP.inherits(Mi, oa);
Mi.parse = oa.parse;
Mi.resolve = oa.resolve;
Mi.bundle = oa.bundle;
Mi.dereference = oa.dereference;
Object.defineProperty(Mi.prototype, "api", {
  configurable: !0,
  enumerable: !0,
  get() {
    return this.schema;
  }
});
Mi.prototype.parse = async function(e, t, r, i) {
  const n = VP(arguments);
  n.options = new ZP(n.options);
  try {
    const s = await oa.prototype.parse.call(this, n.path, n.schema, n.options);
    if (s.swagger) {
      if (s.swagger === void 0 || s.info === void 0 || s.paths === void 0)
        throw Pn.syntax(`${n.path || "Supplied schema"} is not a valid Swagger API definition.`);
      if (typeof s.swagger == "number")
        throw Pn.syntax('Swagger version number must be a string (e.g. "2.0") not a number.');
      if (typeof s.info.version == "number")
        throw Pn.syntax('API version number must be a string (e.g. "1.0.0") not a number.');
      if (s.swagger !== "2.0")
        throw Pn.syntax(`Unrecognized Swagger version: ${s.swagger}. Expected 2.0`);
    } else {
      const a = ["3.0.0", "3.0.1", "3.0.2", "3.0.3", "3.1.0"];
      if (s.openapi === void 0 || s.info === void 0)
        throw Pn.syntax(`${n.path || "Supplied schema"} is not a valid OpenAPI definition.`);
      if (s.paths === void 0)
        if (s.openapi === "3.1.0") {
          if (s.webhooks === void 0)
            throw Pn.syntax(`${n.path || "Supplied schema"} is not a valid OpenAPI definition.`);
        } else
          throw Pn.syntax(`${n.path || "Supplied schema"} is not a valid OpenAPI definition.`);
      else {
        if (typeof s.openapi == "number")
          throw Pn.syntax('OpenAPI version number must be a string (e.g. "3.0.0") not a number.');
        if (typeof s.info.version == "number")
          throw Pn.syntax('API version number must be a string (e.g. "1.0.0") not a number.');
        if (a.indexOf(s.openapi) === -1)
          throw Pn.syntax(
            `Unsupported OpenAPI version: ${s.openapi}. Swagger Parser only supports versions ${a.join(", ")}`
          );
      }
      zP.fixOasRelativeServers(s, n.path);
    }
    return $f(n.callback, Promise.resolve(s));
  } catch (s) {
    return $f(n.callback, Promise.reject(s));
  }
};
Mi.validate = function(e, t, r, i) {
  const n = this, s = new n();
  return s.validate.apply(s, arguments);
};
Mi.prototype.validate = async function(e, t, r, i) {
  const n = this, s = VP(arguments);
  s.options = new ZP(s.options);
  const a = s.options.dereference.circular;
  s.options.validate.schema && (s.options.dereference.circular = "ignore");
  try {
    if (await this.dereference(s.path, s.schema, s.options), s.options.dereference.circular = a, s.options.validate.schema && (Cz(n.api, s.options), n.$refs.circular)) {
      if (a === !0)
        Az(n, s.options);
      else if (a === !1)
        throw Pn.reference("The API contains circular references");
    }
    return s.options.validate.spec && Rz(n.api), $f(s.callback, Promise.resolve(n.schema));
  } catch (u) {
    return $f(s.callback, Promise.reject(u));
  }
};
var Yy = { exports: {} }, rm, y$;
function Tz() {
  if (y$)
    return rm;
  y$ = 1;
  var e = 1e3, t = e * 60, r = t * 60, i = r * 24, n = i * 7, s = i * 365.25;
  rm = function(d, p) {
    p = p || {};
    var h = typeof d;
    if (h === "string" && d.length > 0)
      return a(d);
    if (h === "number" && isFinite(d))
      return p.long ? c(d) : u(d);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(d)
    );
  };
  function a(d) {
    if (d = String(d), !(d.length > 100)) {
      var p = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        d
      );
      if (p) {
        var h = parseFloat(p[1]), v = (p[2] || "ms").toLowerCase();
        switch (v) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return h * s;
          case "weeks":
          case "week":
          case "w":
            return h * n;
          case "days":
          case "day":
          case "d":
            return h * i;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return h * r;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return h * t;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return h * e;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return h;
          default:
            return;
        }
      }
    }
  }
  function u(d) {
    var p = Math.abs(d);
    return p >= i ? Math.round(d / i) + "d" : p >= r ? Math.round(d / r) + "h" : p >= t ? Math.round(d / t) + "m" : p >= e ? Math.round(d / e) + "s" : d + "ms";
  }
  function c(d) {
    var p = Math.abs(d);
    return p >= i ? l(d, p, i, "day") : p >= r ? l(d, p, r, "hour") : p >= t ? l(d, p, t, "minute") : p >= e ? l(d, p, e, "second") : d + " ms";
  }
  function l(d, p, h, v) {
    var y = p >= h * 1.5;
    return Math.round(d / h) + " " + v + (y ? "s" : "");
  }
  return rm;
}
function Iz(e) {
  r.debug = r, r.default = r, r.coerce = c, r.disable = s, r.enable = n, r.enabled = a, r.humanize = Tz(), r.destroy = l, Object.keys(e).forEach((d) => {
    r[d] = e[d];
  }), r.names = [], r.skips = [], r.formatters = {};
  function t(d) {
    let p = 0;
    for (let h = 0; h < d.length; h++)
      p = (p << 5) - p + d.charCodeAt(h), p |= 0;
    return r.colors[Math.abs(p) % r.colors.length];
  }
  r.selectColor = t;
  function r(d) {
    let p, h = null, v, y;
    function g(..._) {
      if (!g.enabled)
        return;
      const m = g, w = Number(/* @__PURE__ */ new Date()), $ = w - (p || w);
      m.diff = $, m.prev = p, m.curr = w, p = w, _[0] = r.coerce(_[0]), typeof _[0] != "string" && _.unshift("%O");
      let E = 0;
      _[0] = _[0].replace(/%([a-zA-Z%])/g, (R, I) => {
        if (R === "%%")
          return "%";
        E++;
        const D = r.formatters[I];
        if (typeof D == "function") {
          const J = _[E];
          R = D.call(m, J), _.splice(E, 1), E--;
        }
        return R;
      }), r.formatArgs.call(m, _), (m.log || r.log).apply(m, _);
    }
    return g.namespace = d, g.useColors = r.useColors(), g.color = r.selectColor(d), g.extend = i, g.destroy = r.destroy, Object.defineProperty(g, "enabled", {
      enumerable: !0,
      configurable: !1,
      get: () => h !== null ? h : (v !== r.namespaces && (v = r.namespaces, y = r.enabled(d)), y),
      set: (_) => {
        h = _;
      }
    }), typeof r.init == "function" && r.init(g), g;
  }
  function i(d, p) {
    const h = r(this.namespace + (typeof p > "u" ? ":" : p) + d);
    return h.log = this.log, h;
  }
  function n(d) {
    r.save(d), r.namespaces = d, r.names = [], r.skips = [];
    let p;
    const h = (typeof d == "string" ? d : "").split(/[\s,]+/), v = h.length;
    for (p = 0; p < v; p++)
      h[p] && (d = h[p].replace(/\*/g, ".*?"), d[0] === "-" ? r.skips.push(new RegExp("^" + d.slice(1) + "$")) : r.names.push(new RegExp("^" + d + "$")));
  }
  function s() {
    const d = [
      ...r.names.map(u),
      ...r.skips.map(u).map((p) => "-" + p)
    ].join(",");
    return r.enable(""), d;
  }
  function a(d) {
    if (d[d.length - 1] === "*")
      return !0;
    let p, h;
    for (p = 0, h = r.skips.length; p < h; p++)
      if (r.skips[p].test(d))
        return !1;
    for (p = 0, h = r.names.length; p < h; p++)
      if (r.names[p].test(d))
        return !0;
    return !1;
  }
  function u(d) {
    return d.toString().substring(2, d.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  function c(d) {
    return d instanceof Error ? d.stack || d.message : d;
  }
  function l() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  return r.enable(r.load()), r;
}
var jz = Iz;
(function(e, t) {
  t.formatArgs = i, t.save = n, t.load = s, t.useColors = r, t.storage = a(), t.destroy = (() => {
    let c = !1;
    return () => {
      c || (c = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
    };
  })(), t.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function r() {
    return typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? !0 : typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? !1 : typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function i(c) {
    if (c[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + c[0] + (this.useColors ? "%c " : " ") + "+" + e.exports.humanize(this.diff), !this.useColors)
      return;
    const l = "color: " + this.color;
    c.splice(1, 0, l, "color: inherit");
    let d = 0, p = 0;
    c[0].replace(/%[a-zA-Z%]/g, (h) => {
      h !== "%%" && (d++, h === "%c" && (p = d));
    }), c.splice(p, 0, l);
  }
  t.log = console.debug || console.log || (() => {
  });
  function n(c) {
    try {
      c ? t.storage.setItem("debug", c) : t.storage.removeItem("debug");
    } catch {
    }
  }
  function s() {
    let c;
    try {
      c = t.storage.getItem("debug");
    } catch {
    }
    return !c && typeof Me.process < "u" && "env" in Me.process && (c = Me.process.env.DEBUG), c;
  }
  function a() {
    try {
      return localStorage;
    } catch {
    }
  }
  e.exports = jz(t);
  const { formatters: u } = e.exports;
  u.j = function(c) {
    try {
      return JSON.stringify(c);
    } catch (l) {
      return "[UnexpectedJSONParseError]: " + l.message;
    }
  };
})(Yy, Yy.exports);
var kz = Yy.exports;
function g$({ schema: e }) {
  return UE.generateSchema(e);
}
function yd(e) {
  return kz.debug(e);
}
function Mz() {
  var e, t, r, i;
  return ((t = (e = Me.process) == null ? void 0 : e.env) == null ? void 0 : t.DEBUG) || !((i = (r = import.meta) == null ? void 0 : r.env) != null && i.PROD);
}
function Ul(e) {
  return yn.isBuffer(e) ? e.byteLength : new Blob([typeof e == "object" ? JSON.stringify(e) : e]).size || 0;
}
function Nz(e) {
  return typeof e != "string" ? !1 : !isNaN(e) && !isNaN(parseFloat(e));
}
function Dz(e) {
  return typeof e != "string" ? e : Nz(e) ? e.indexOf(".") !== -1 ? parseFloat(e) : parseInt(e) : e;
}
const gd = ({ ms: e, fn: t }) => new Promise((r, i) => {
  const n = setTimeout(() => {
    i({ error: "timeout" });
  }, e);
  t.then((s) => {
    clearTimeout(n), r(s);
  }, i);
}), Jy = yd("security"), WP = new Ju({
  ttl: 1e3 * 1e3
});
async function Lz({ ip: e, request_id: t }) {
  const r = Uf();
  return WP.put(r, { ip: e, request_id: t }), r;
}
async function qz({
  challenge: e,
  ip: t,
  request_id: r
}) {
  const i = WP.get(e);
  return i ? i.ip !== t || i.request_id !== r ? (Jy(`challenge ${e} does not match ip ${t} or request_id ${r}`), !1) : !0 : (Jy(`challenge ${e} not found`), !1);
}
function co({ str: e }) {
  return A3(yn.isBuffer(e) ? e : yn.from(e, "hex"));
}
function Fz({
  message: e,
  signature: t,
  public_key: r
}) {
  const i = rn({ input: co({ str: e }) });
  return G3(t, i, r);
}
async function Uz(e) {
  if (e && typeof e == "object" && "auth" in e && "params" in e) {
    const t = e.auth;
    if (!await qz({ challenge: e.auth.n || "", ip: e.ip, request_id: e.request_id }))
      return !1;
    Jy(`verifying signature for ${e.request_id}`);
    const r = co({
      str: JSON.stringify({ offer: e.offer, params: e.params || {}, nonce: e.auth.n, request_id: e.id })
    });
    return Fz({ message: rn({ input: r }), signature: t.s, public_key: t.pk });
  } else
    return { error: "Missing auth or params" };
}
async function HP() {
  const e = K3.randomPrivateKey(), t = cE(e);
  return { private_key: yn.toString(e, "hex"), public_key: yn.toString(t, "hex") };
}
async function Ef(e, t) {
  const r = yn.isBuffer(e) ? yn.from(e) : e, i = rn({ input: co({ str: r }) });
  return (await H3(i, rn({ input: t }))).toCompactRawBytes();
}
async function Bz({ private_key: e }) {
  return rn({ input: await cE(e) });
}
function rn({ input: e, add0x: t = !1 }) {
  const r = yn.toString(e, "hex");
  return t ? "0x" + r : r;
}
function xf({ input: e }) {
  return yn.from(e.replace(/^0x/, ""), "hex");
}
async function KH() {
  const e = await HP();
  return {
    ...e,
    user_id: e.public_key
  };
}
var GP = { exports: {} };
(function(e) {
  var t = Object.prototype.hasOwnProperty, r = "~";
  function i() {
  }
  Object.create && (i.prototype = /* @__PURE__ */ Object.create(null), new i().__proto__ || (r = !1));
  function n(c, l, d) {
    this.fn = c, this.context = l, this.once = d || !1;
  }
  function s(c, l, d, p, h) {
    if (typeof d != "function")
      throw new TypeError("The listener must be a function");
    var v = new n(d, p || c, h), y = r ? r + l : l;
    return c._events[y] ? c._events[y].fn ? c._events[y] = [c._events[y], v] : c._events[y].push(v) : (c._events[y] = v, c._eventsCount++), c;
  }
  function a(c, l) {
    --c._eventsCount === 0 ? c._events = new i() : delete c._events[l];
  }
  function u() {
    this._events = new i(), this._eventsCount = 0;
  }
  u.prototype.eventNames = function() {
    var l = [], d, p;
    if (this._eventsCount === 0)
      return l;
    for (p in d = this._events)
      t.call(d, p) && l.push(r ? p.slice(1) : p);
    return Object.getOwnPropertySymbols ? l.concat(Object.getOwnPropertySymbols(d)) : l;
  }, u.prototype.listeners = function(l) {
    var d = r ? r + l : l, p = this._events[d];
    if (!p)
      return [];
    if (p.fn)
      return [p.fn];
    for (var h = 0, v = p.length, y = new Array(v); h < v; h++)
      y[h] = p[h].fn;
    return y;
  }, u.prototype.listenerCount = function(l) {
    var d = r ? r + l : l, p = this._events[d];
    return p ? p.fn ? 1 : p.length : 0;
  }, u.prototype.emit = function(l, d, p, h, v, y) {
    var g = r ? r + l : l;
    if (!this._events[g])
      return !1;
    var _ = this._events[g], m = arguments.length, w, $;
    if (_.fn) {
      switch (_.once && this.removeListener(l, _.fn, void 0, !0), m) {
        case 1:
          return _.fn.call(_.context), !0;
        case 2:
          return _.fn.call(_.context, d), !0;
        case 3:
          return _.fn.call(_.context, d, p), !0;
        case 4:
          return _.fn.call(_.context, d, p, h), !0;
        case 5:
          return _.fn.call(_.context, d, p, h, v), !0;
        case 6:
          return _.fn.call(_.context, d, p, h, v, y), !0;
      }
      for ($ = 1, w = new Array(m - 1); $ < m; $++)
        w[$ - 1] = arguments[$];
      _.fn.apply(_.context, w);
    } else {
      var E = _.length, A;
      for ($ = 0; $ < E; $++)
        switch (_[$].once && this.removeListener(l, _[$].fn, void 0, !0), m) {
          case 1:
            _[$].fn.call(_[$].context);
            break;
          case 2:
            _[$].fn.call(_[$].context, d);
            break;
          case 3:
            _[$].fn.call(_[$].context, d, p);
            break;
          case 4:
            _[$].fn.call(_[$].context, d, p, h);
            break;
          default:
            if (!w)
              for (A = 1, w = new Array(m - 1); A < m; A++)
                w[A - 1] = arguments[A];
            _[$].fn.apply(_[$].context, w);
        }
    }
    return !0;
  }, u.prototype.on = function(l, d, p) {
    return s(this, l, d, p, !1);
  }, u.prototype.once = function(l, d, p) {
    return s(this, l, d, p, !0);
  }, u.prototype.removeListener = function(l, d, p, h) {
    var v = r ? r + l : l;
    if (!this._events[v])
      return this;
    if (!d)
      return a(this, v), this;
    var y = this._events[v];
    if (y.fn)
      y.fn === d && (!h || y.once) && (!p || y.context === p) && a(this, v);
    else {
      for (var g = 0, _ = [], m = y.length; g < m; g++)
        (y[g].fn !== d || h && !y[g].once || p && y[g].context !== p) && _.push(y[g]);
      _.length ? this._events[v] = _.length === 1 ? _[0] : _ : a(this, v);
    }
    return this;
  }, u.prototype.removeAllListeners = function(l) {
    var d;
    return l ? (d = r ? r + l : l, this._events[d] && a(this, d)) : (this._events = new i(), this._eventsCount = 0), this;
  }, u.prototype.off = u.prototype.removeListener, u.prototype.addListener = u.prototype.on, u.prefixed = r, u.EventEmitter = u, e.exports = u;
})(GP);
var Vz = GP.exports;
const Zz = /* @__PURE__ */ ta(Vz), wi = new Zz();
async function KP({ request_id: e, data: t, onData: r, onDone: i, onError: n }) {
  if ("error" in t)
    return n && n(t);
  if (t.request_id && t.status === "ready") {
    e = t.request_id;
    return;
  } else {
    if (t.request_id === e && t.status === "data")
      return r && r(t);
    if (t.request_id === e && t.status === "complete")
      return i && i(t);
    if (t.request_id === e)
      return n && n({ error: `Unknown type of response: ${JSON.stringify(t)}`, code: 500 });
  }
}
async function zz({
  request_id: e,
  onData: t,
  onDone: r,
  onError: i
}) {
  const n = {
    write: async (s) => {
      const { offer: a } = s.input;
      wi.emit(`${a.call.module_id}:/${a.call.method_id}:post`, s);
    },
    close: async () => !0
  };
  return wi.on(e, async (s) => {
    KP({ request_id: e, data: s, onData: t, onDone: r, onError: i });
  }), n;
}
async function Wz({ API: e }) {
  wi.on("registerModule", async ({ module: t }) => {
    const { code: r } = await e.registerModule({ module: t });
    return r !== 200 ? { error: "Failed to register module", code: r } : { code: r };
  }), wi.on("registerProtocol", async ({ protocol: t }) => ({ code: 200 }));
  for (const t of e.getModules())
    for (const r in t.schema.paths) {
      const i = t.schema.paths[r];
      for (const n in i)
        wi.on(
          `${t.id}:${r}:${n}`,
          async ({
            input: s,
            globals: a,
            abort: u
          }) => {
            if (u)
              return e.abort({ request_id: s.id });
            const c = await e.execute({
              input: s,
              globals: a,
              // ...channel,
              onData: (l) => {
                wi.emit(`${s.id}`, { request_id: s.id, data: l, status: "data" });
              },
              onDone: (l) => {
                wi.emit(`${s.id}`, { request_id: s.id, status: "complete", data: l });
              },
              onError: (l) => {
                wi.emit(`${s.id}`, { request_id: s.id, error: l, status: "error" });
              }
            });
            return c && "error" in c ? wi.emit(`${s.id}`, { request_id: s.id, error: c == null ? void 0 : c.error, status: "error" }) : c;
          }
        );
    }
}
var YP = function() {
  throw new Error(
    "ws does not work in the browser. Browser clients must use the native WebSocket object"
  );
};
const Hz = /* @__PURE__ */ ta(YP), nm = new Ju({ ttl: 1e3 * 60 * 1 });
async function Gz({
  request_id: e,
  host: t,
  onData: r,
  onDone: i,
  onError: n
}) {
  const s = async () => {
    const c = nm.get(t);
    if (!c || (c == null ? void 0 : c.readyState) !== 1) {
      const l = new Hz(`ws://${t}:8080`);
      return nm.put(t, l), new Promise((d) => {
        l.onopen = () => {
          d(l);
        };
      });
    }
    return c;
  }, a = {
    write: async (c) => {
      (await s()).send(JSON.stringify(c));
    },
    close: async () => {
      const c = await s();
      return c && (c.close(), nm.del(t)), !0;
    }
  }, u = await s();
  return u.onmessage = (c) => {
    try {
      if (yn.isBuffer(c == null ? void 0 : c.data))
        return { error: "buffer not supported yet " };
      const l = typeof c.data == "object" ? c.data : JSON.parse(c.data);
      KP({ request_id: e, data: l, onData: r, onDone: i, onError: n });
    } catch (l) {
      return { error: l };
    }
  }, a;
}
async function Kz({
  API: e,
  ws: t,
  input: r,
  globals: i,
  abort: n
}) {
  if (n)
    return e.abort({ request_id: r.id });
  const s = await e.execute({
    input: r,
    globals: i,
    // ...channel,
    onData: (a) => {
      t.send(JSON.stringify({ request_id: r.id, data: a, status: "data" }));
    },
    onDone: (a) => {
      t.send(JSON.stringify({ request_id: r.id, status: "complete", data: a }));
    },
    onError: (a) => {
      t.send(JSON.stringify({ request_id: r.id, error: a, status: "error" }));
    }
  });
  return s && "error" in s ? t.send(JSON.stringify({ request_id: r.id, error: s == null ? void 0 : s.error, status: "error" })) : s;
}
async function Yz({
  API: e,
  host: t = "127.0.0.1",
  port: r = 8080
}) {
  new YP.WebSocketServer({ host: t, port: r }).on("connection", function(s) {
    s.on("error", console.error), s.on("message", function(u) {
      const c = yn.isBuffer(u) ? yn.toString(u) : typeof u == "string" ? u : "{}";
      let l = JSON.parse(c);
      Kz({ ...l, ws: s, API: e });
    });
  });
}
var cc = {}, j0 = {};
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
(function(e) {
  e.binary = /^(?:[01]{8})+$/, e.boolean = /^(?:true|false)$/, e.byte = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/, e.date = /^(\d{4})-(\d{2})-(\d{2})$/, e.dateTime = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(Z|([+-]\d{2}:?\d{2}))$/i, e.integer = /^-?\d+$/, e.number = /^-?\d+(?:\.\d+)?$/, e["date-time"] = e.dateTime;
})(j0);
const Jz = /* @__PURE__ */ kf(A5);
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
const Xz = fo;
let Qz = Xz.inspect.custom || "inspect";
var qn = qr;
function qr(e) {
  if (!(this instanceof qr))
    return new qr(e);
  this.header = e, this.children = {
    at: {},
    nest: [],
    message: []
  };
}
qr.prototype.at = function(e) {
  const t = this.children.at;
  return t[e] || (t[e] = new qr("")), t[e];
};
qr.prototype.clearCache = function() {
  return this;
};
qr.prototype[Qz] = function() {
  return this.hasException ? "[ EnforcerException: " + bu(this, null, "  ") + " ]" : "[ EnforcerException ]";
};
qr.prototype.nest = function(e) {
  const t = new qr(e);
  return this.children.nest.push(t), t;
};
qr.prototype.merge = function(e) {
  const t = this.children, r = e.children, i = t.at;
  return Object.keys(r.at).forEach((n) => {
    i[n] ? i[n].merge(r.at[n]) : i[n] = r.at[n];
  }), r.nest.forEach((n) => {
    t.nest.push(n);
  }), r.message.forEach((n) => {
    t.message.push(n);
  }), this;
};
qr.prototype.message = function(e) {
  return this.children.message.push(e), this;
};
qr.prototype.push = function(e) {
  const t = typeof e;
  if (t === "string" && e.length)
    this.children.message.push(e);
  else if (t === "object" && e instanceof qr)
    this.children.nest.push(e);
  else
    throw Error("Can only push string or EnforcerException instance");
  return this;
};
qr.prototype.toString = function() {
  return bu(this, null, "");
};
Object.defineProperties(qr.prototype, {
  count: {
    get: function() {
      const e = this.children;
      return e.message.length + e.nest.reduce((t, r) => t + r.count, 0) + Object.keys(e.at).reduce((t, r) => t + e.at[r].count, 0);
    }
  },
  hasException: {
    get: function() {
      const e = this.children;
      if (e.message.length)
        return !0;
      {
        const t = e.nest, r = t.length;
        for (let s = 0; s < r; s++)
          if (t[s].hasException)
            return !0;
        const i = Object.keys(e.at), n = i.length;
        for (let s = 0; s < n; s++)
          if (e.at[i[s]].hasException)
            return !0;
      }
      return !1;
    }
  }
});
function bu(e, t, r) {
  if (!e.hasException)
    return "";
  const i = r + "  ", n = e.children;
  let s = "";
  e.header && (s += (t ? r : "") + e.header);
  const a = n.at, u = Object.keys(a).filter((l) => a[l].hasException), c = u.length === 1;
  return u.forEach((l) => {
    const d = n.at[l];
    e.header || !c || n.nest.length > 0 || n.message.length > 0 ? s += `
` + i + "at: " + l + bu(d, e, i) : s += " > " + l + bu(d, e, r);
  }), n.nest.forEach((l) => {
    l.hasException && (s += `
` + bu(l, e, i));
  }), n.message.forEach((l) => {
    s += `
` + i + l;
  }), s;
}
const JP = Jz, v$ = j0, b$ = qn, _$ = /^([\s\S]+?)\/(?:([\s\S]+?)\+)?([\s\S]+?)$/, XP = ",,,,,,,,,,.................................:;!?", eW = XP.length, QP = "lorem ipsum dolor sit amet consectetur adipiscing elit suspendisse sollicitudin felis pretium laoreet tortor facilisis a integer eu metus velit praesent varius sed erat quis ornare nunc porttitor nulla at ultrices nam ac vestibulum metus maecenas malesuada lectus leo blandit a congue gravida phasellus consectetur libero et tincidunt diam pellentesque lacus neque eros sed porta nunc id lobortis eget ligula mollis nulla nunc maximus gravida felis finibus est ullamcorper pellentesque ex in turpis pharetra dictum in fermentum arcu mauris odio molestie iaculis accumsan nec convallis nec nunc vestibulum nisl curabitur tristique non porttitor vivamus dui ipsum orci eget vulputate lacus interdum suscipit massa elementum sodales at interdum fames ante primis in faucibus duis mi pulvinar accumsan donec odio enim sed dignissim turpis quisque vitae turpis ut nibh tincidunt aliquam magna semper aliquam feugiat sapien justo egestas condimentum metus tincidunt odio volutpat vehicula pulvinar arcu diam bibendum sem leo sodales eleifend vehicula fusce faucibus quam lorem rhoncus amet hendrerit rhoncus augue mattis commodo lobortis urna consequat hendrerit enim risus placerat eros euismod ligula tellus tempus condimentum ac lectus erat ultrices mi lacus nisi scelerisque vehicula cursus cras enim elit aenean aliquam tempor ullamcorper est proin aliquet orci et augue posuere viverra massa augue purus orci purus neque ut elit pretium molestie vel tellus ex consequat tristique urna fringilla dignissim ex lectus imperdiet lobortis potenti efficitur feugiat facilisi placerat posuere bibendum velit volutpat dapibus donec".split(" "), tW = QP.length;
var Qt = {
  arrayRemoveItem: rW,
  copy: (e) => Xy(/* @__PURE__ */ new Map(), e),
  determineSchemaFromSchemas: Bl,
  edgeSlashes: nW,
  findMediaMatch: iW,
  freeze: Vl,
  getDateFromValidDateString: sW,
  getDefinitionType: oW,
  greatestCommonDenominator: eS,
  isDate: Qy,
  isNumber: Zl,
  isInteger: uW,
  isPlainObject: lc,
  isObject: Of,
  isObjectStringMap: cW,
  leastCommonMultiple: lW,
  leastOf: fW,
  lowerCaseObjectProperties: dW,
  mapObject: pW,
  merge: eg,
  methods: hW,
  mostOf: mW,
  parseCookieString: yW,
  parseQueryString: gW,
  randomNumber: tS,
  randomOneOf: vW,
  randomText: bW,
  reject: _W,
  rxStringToRx: $W,
  same: tg,
  schemaObjectHasSkipCode: rg,
  smart: _i,
  toPlainObject: function(e, t) {
    const r = /* @__PURE__ */ new Map();
    if (t || (t = {}), typeof t != "object")
      throw Error('Parameter "options" must be an object');
    if (t.hasOwnProperty("allowInheritedProperties") || (t.allowInheritedProperties = !1), t.hasOwnProperty("preserve") || (t.preserve = []), !Array.isArray(t.preserve))
      throw Error('Option "preserve" must be an array');
    t.preserve = new Set(t.preserve), t.preserve.add(Date);
    const i = ng(e, t, r);
    if (!i.set)
      throw Error("Unable to convert value to plain object");
    return i.value;
  },
  toQueryString: EW,
  ucFirst: rS,
  validateExamples: xW,
  validateMaxMin: OW
};
function rW(e, t) {
  const r = e.indexOf(t);
  return r !== -1 && e.splice(r, 1), e;
}
function Xy(e, t) {
  if (t instanceof Date)
    return /* @__PURE__ */ new Date(+t);
  if (t instanceof Me.Buffer)
    return t.slice(0);
  if (Array.isArray(t)) {
    let r = e.get(t);
    return r || (r = [], e.set(t, r), t.forEach((i) => r.push(Xy(e, i))), r);
  } else if (lc(t)) {
    let r = e.get(t);
    return r || (r = {}, e.set(t, r), Object.keys(t).forEach((i) => r[i] = Xy(e, t[i])), r);
  } else
    return t;
}
function Or() {
  throw Error("Date object cannot be modified");
}
function Bl(e, t) {
  const r = typeof t, i = e.length;
  for (let n = 0; n < i; n++) {
    const s = e[n];
    if (s.type === "array" && Array.isArray(t) || s.type === "boolean" && r === "boolean" || s.type === "integer" && r === "number" && /^\d+$/.test(String(t)) || s.type === "number" && r === "number" || s.type === "string" && r === "string" || s.type === "object" && r === "object" && t !== null || t === null && (s.nullable || s["x-nullable"]))
      return s;
    if (s.anyOf) {
      const a = Bl(a.anyOf, t);
      if (a !== null)
        return a;
    } else if (s.oneOf) {
      const a = Bl(a.oneOf, t);
      if (a !== null)
        return a;
    } else if (s.allOf) {
      const a = s.allOf.length;
      for (let u = 0; u < a; u++) {
        const c = c.allOf[u];
        if (c.type !== void 0)
          return c;
        if (c.anyOf || c.oneOf)
          return Bl(c.anyOf ?? c.oneOf, t);
      }
    }
  }
  return null;
}
function nW(e, t, r) {
  return e = e.replace(/^\//, "").replace(/\/$/, ""), e.length === 0 && (t || r) ? "/" : (t && (e = "/" + e), r && (e += "/"), e);
}
function iW(e, t) {
  const r = e.split(/, */).map((a, u) => {
    const c = a.split(";"), l = _$.exec(c[0]), d = /q=(\d(?:\.\d)?)/.exec(c[1]);
    if (l)
      return {
        extension: l[2] || "*",
        index: u,
        quality: +(d && d[1] || 1),
        subType: l[3],
        type: l[1]
      };
  }).filter((a) => !!a), i = [];
  r.forEach((a) => {
    t.forEach((u, c) => {
      const l = _$.exec(u);
      if (l) {
        const d = l[1], p = l[3], h = l[2] || "*";
        (a.type === d || a.type === "*" || d === "*") && (a.subType === p || a.subType === "*" || p === "*") && (a.extension === h || a.extension === "*" || h === "*") && i.push({
          index: a.index,
          order: c,
          quality: a.quality,
          score: (a.type === d ? 1 : 0) + (a.subType === p ? 1 : 0) + (a.extension === h ? 1 : 0),
          value: u
        });
      }
    });
  }), i.sort((a, u) => a.quality < u.quality ? 1 : a.quality > u.quality ? -1 : a.score < u.score ? 1 : a.score > u.score ? -1 : a.index < u.index ? 1 : a.index > u.index || a.order < u.order ? -1 : 1);
  const n = {}, s = [];
  return i.forEach((a) => {
    const u = a.value;
    n[u] || (n[u] = a, s.push(a.value));
  }), s;
}
function Vl(e) {
  return !e || typeof e != "object" || e instanceof Me.Buffer || (e instanceof Date && (e.setDate = Or, e.setFullYear = Or, e.setHours = Or, e.setMilliseconds = Or, e.setMinutes = Or, e.setMonth = Or, e.setSeconds = Or, e.setTime = Or, e.setUTCDate = Or, e.setUTCFullYear = Or, e.setUTCHours = Or, e.setUTCMilliseconds = Or, e.setUTCMinutes = Or, e.setUTCMonth = Or, e.setUTCSeconds = Or, e.setYear = Or), Object.freeze(e)), e;
}
function sW(e, t) {
  const r = new Date(t), i = r.toISOString(), n = e === "date" ? v$.date.exec(i.substring(0, 10)) : v$["date-time"].exec(i), s = +n[1], a = +n[2] - 1, u = +n[3], c = +n[4] || 0, l = +n[5] || 0, d = +n[6] || 0, h = +aW(n[7]) || 0;
  return r.getUTCFullYear() === s && r.getUTCMonth() === a && r.getUTCDate() === u && r.getUTCHours() === c && r.getUTCMinutes() === l && r.getUTCSeconds() === d && r.getUTCMilliseconds() === h ? r : null;
}
function aW(e) {
  if (e === void 0)
    return;
  var t = e;
  const r = 3 - e.length;
  return r > 0 ? t = e + "0".repeat(r) : r < 0 && (t = e.substr(0, 3)), t;
}
function oW(e) {
  if (Array.isArray(e))
    return "array";
  if (lc(e))
    return "object";
  if (e === null)
    return "null";
  const t = typeof e;
  return t === "object" ? "decoratedObject" : t;
}
function eS(e, t) {
  for (e = Math.abs(e), t = Math.abs(t); t; ) {
    const r = t;
    t = e % t, e = r;
  }
  return e;
}
function Qy(e) {
  return e && !isNaN(e) && e instanceof Date;
}
function Zl(e) {
  return typeof e == "number" && !isNaN(e);
}
function uW(e) {
  return !isNaN(e) && typeof e == "number" && e === Math.round(e);
}
function Of(e) {
  return e && typeof e == "object" && Object.prototype.toString.call(e) === "[object Object]";
}
function lc(e) {
  if (!Of(e))
    return !1;
  const t = e.constructor;
  if (typeof t != "function")
    return !1;
  const r = t.prototype;
  return Of(r) ? r.hasOwnProperty("isPrototypeOf") : !1;
}
function cW(e) {
  if (!lc(e))
    return !1;
  const t = Object.keys(e), r = t.length;
  for (let i = 0; i < r; i++)
    if (typeof t[i] != "string" || typeof e[t[i]] != "string")
      return !1;
  return !0;
}
function lW(e, t) {
  return typeof e != "number" || typeof t != "number" ? !1 : !e || !t ? 0 : Math.abs(e * t / eS(e, t));
}
function fW(e) {
  const t = e.length;
  let r = e[0];
  for (let i = 1; i < t; i++)
    e[i] < r && (r = e[i]);
  return r;
}
function dW(e) {
  const t = {};
  return Object.keys(e).forEach((r) => {
    t[r.toLowerCase()] = e[r];
  }), t;
}
function pW(e, t) {
  const r = {};
  return Object.keys(e).forEach((i) => {
    r[i] = t(e[i], i);
  }), r;
}
function eg(e, t, r = "") {
  if (lc(e)) {
    if (!Of(t))
      throw Error(r + ": Unable to merge non-object into plain object.");
    return Object.keys(t).forEach((i) => {
      e[i] = e.hasOwnProperty(i) ? eg(e[i], t[i], r + "> " + i) : t[i];
    }), e;
  } else if (Array.isArray(e)) {
    if (!Array.isArray(t))
      throw Error(r + ": Unable to merge non-array into array");
    const i = e.length, n = i > t.length ? i : t.length;
    for (let s = 0; s < n; s++)
      s >= i ? e[s] = t[s] : e[s] = eg(e[s], t[s], "> " + s);
    return e;
  } else
    return t;
}
function hW() {
  return ["get", "put", "post", "delete", "options", "head", "patch", "trace"];
}
function mW(e) {
  const t = e.length;
  let r = e[0];
  for (let i = 1; i < t; i++)
    e[i] > r && (r = e[i]);
  return r;
}
function yW(e) {
  const t = {};
  return e.split(/; */).forEach((r) => {
    const [i, n] = r.split("=");
    t[i] || (t[i] = []), t[i].push(n || "");
  }), t;
}
function gW(e, t) {
  const r = JP.parse(e, t);
  return Object.keys(r).forEach((i) => {
    const n = r[i];
    Array.isArray(n) || (r[i] = [n]);
  }), Object.assign({}, r);
}
function tS({ min: e, max: t, multipleOf: r, exclusiveMin: i = !1, exclusiveMax: n = !1, decimalPlaces: s = 0, spread: a = 1e3 } = {}) {
  const u = Zl(e), c = Zl(t);
  if (t < e)
    throw Error("Maximum value must be greater than or equal to minimum value");
  if (Zl(r) && r > 0) {
    const l = e % r;
    return l !== 0 && (e += r - l), t -= t % r, t === e ? t : (Math.round(Math.random() * (t - e) / r) + e) * r;
  } else {
    const l = u && c ? t - e : a;
    let d = Math.random() * l;
    return u && (d += e), d = wW(d, s), u && (d < e && (d = e), d === e && i && (d += Math.pow(10, -1 * s))), c && (d > t && (d = t), d === t && n && (d -= Math.pow(10, -1 * s))), u && (d < e || d === e && i) || c && (d > t || d === t && n) ? void 0 : d;
  }
}
function vW(e) {
  const t = Math.floor(Math.random() * e.length);
  return e[t];
}
function bW({ minLength: e = 1, maxLength: t = 250 } = {}) {
  const r = tS({ min: e, max: t }) + 1;
  let i = "", n = 1, s = !0;
  for (; i.length < r; ) {
    const a = Math.floor(Math.random() * tW);
    let u = QP[a];
    if (s && (u = rS(u)), s = !1, i += u, Math.random() >= n) {
      n = 1;
      const c = Math.floor(Math.random() * eW), l = XP[c];
      /[.!?]/.test(l) && (s = !0), i += l;
    } else
      n *= 0.9;
    i += " ";
  }
  return i = i.trim(), i = i.replace(/[,.:;!?]$/, ""), t > 5 ? (i.length >= t && (i = i.substr(0, t - 1)), i += ".") : i.length > t && (i = i.substr(0, t)), i;
}
function _W(e) {
  return Promise.reject(Error(typeof e == "string" ? e : e.toString()));
}
function wW(e, t = 0) {
  const r = Math.pow(10, t);
  return Math.round(e * r) / r;
}
function $W(e) {
  if (typeof e == "string") {
    const r = /^\/([\s\S]+?)\/(\w*)?$/.exec(e);
    return r ? RegExp(r[1], r[2] || "") : RegExp(e);
  } else {
    if (e instanceof RegExp)
      return e;
    throw Error("Cannot convert value to RegExp instance");
  }
}
function tg(e, t) {
  if (e === t)
    return !0;
  const r = typeof e;
  if (r !== typeof t)
    return !1;
  if (Array.isArray(e)) {
    if (!Array.isArray(t))
      return !1;
    const i = e.length;
    if (i !== t.length)
      return !1;
    for (let n = 0; n < i; n++)
      if (!tg(e[n], t[n]))
        return !1;
    return !0;
  } else {
    if (Me.Buffer.isBuffer(e))
      return Me.Buffer.isBuffer(t) && e.toString() === t.toString();
    if (Qy(e))
      return Qy(t) && +t == +e;
    if (e && r === "object") {
      if (!t)
        return !1;
      const i = Object.keys(e), n = i.length;
      if (n !== Object.keys(t).length)
        return !1;
      for (let s = 0; s < n; s++) {
        const a = i[s];
        if (!tg(e[a], t[a]))
          return !1;
      }
      return !0;
    } else
      return !1;
  }
}
function rg(e, t) {
  return (typeof e == "object" && e !== null ? e["x-enforcer-exception-skip-codes"] ?? "" : "").split(/ +/).map((n) => n.trim()).includes(t);
}
function _i(e) {
  const t = typeof e;
  if (t === "string")
    return '"' + e.replace(/"/g, '\\"') + '"';
  if (e instanceof Date)
    return isNaN(e) ? "invalid date object" : e.toISOString();
  if (Array.isArray(e)) {
    let r = "[" + String(e) + "]";
    const i = r.length;
    if (i > 15) {
      const n = i - 15, s = Math.floor(n / 2), a = n - s, u = Math.ceil(i / 2);
      r = r.substr(0, u - a) + "..." + r.substr(u + s);
    }
    return r;
  }
  if (e && t === "object") {
    const r = e.constructor ? e.constructor.name : "";
    return "[object" + (r ? " " + r : "") + "]";
  }
  return String(e);
}
function ng(e, t, r) {
  if (e && e.constructor && t.preserve.has(e.constructor))
    return { set: !0, value: e };
  if (Array.isArray(e)) {
    if (r.has(e))
      return r.get(e);
    const i = { set: !0, value: [] };
    return r.set(e, i), e.forEach((n) => {
      const s = ng(n, t, r);
      s.set && i.value.push(s.value);
    }), i;
  } else if (e && typeof e == "object") {
    if (r.has(e))
      return r.get(e);
    const i = { set: !0, value: {} };
    r.set(e, i);
    for (let n in e)
      if (t.allowInheritedProperties || e.hasOwnProperty(n)) {
        const s = ng(e[n], t, r);
        s.set && (i.value[n] = s.value);
      }
    return i;
  } else
    return e instanceof Object ? { set: !1 } : { set: !0, value: e };
}
function EW(e) {
  return JP.stringify(e);
}
function rS(e) {
  return e[0].toUpperCase() + e.substr(1);
}
function xW(e, t, r, i) {
  const n = i.exceptionSkipCodes, s = i.exceptionEscalateCodes;
  if (e.hasOwnProperty("schema")) {
    if (e.hasOwnProperty("example")) {
      let a, u;
      if ([a, u] = e.schema.deserialize(e.example), u || (u = e.schema.validate(a)), u && !n.WSCH006 && !rg(e, "WSCH006")) {
        const c = new b$("Example not valid. [WSCH006]");
        c.push(u), (s.WSCH006 ? t : r).at("example").push(c);
      }
      Object.defineProperty(e, "example", {
        configurable: !0,
        enumerable: !0,
        value: Vl(a)
      });
    }
    if (e.hasOwnProperty("examples")) {
      const a = e.enforcerData.major;
      Object.keys(e.examples).forEach((u) => {
        let c, l;
        const d = a === 2 ? e.examples[u] : e.examples[u].value;
        if ([c, l] = e.schema.deserialize(d), l || (l = e.schema.validate(c)), l && !n.WSCH006 && !rg(e, "WSCH006")) {
          const p = new b$("Example not valid. [WSCH006]");
          p.push(l), (s.WSCH006 ? t : r).at("examples").at(u).push(p);
        }
        a === 2 ? Object.defineProperty(e.examples, u, {
          configurable: !0,
          enumerable: !0,
          value: Vl(c)
        }) : Object.defineProperty(e.examples[u], "value", {
          configurable: !0,
          enumerable: !0,
          value: Vl(c)
        });
      });
    }
  }
}
function OW(e, t, r, i, n, s, a, u, c) {
  if (t.hasOwnProperty(i)) {
    if (s && t.exclusiveMaximum && a >= u) {
      let l = t.serialize(t[i]).value || t[i], d = t.serialize(a).value || a;
      e.message("Expected " + r + " to be less than " + _i(l) + ". Received: " + _i(d));
    } else if (a > u) {
      let l = t.serialize(t[i]).value || t[i], d = t.serialize(a).value || a;
      e.message("Expected " + r + " to be less than or equal to " + _i(l) + ". Received: " + _i(d));
    }
  }
  if (t.hasOwnProperty(n)) {
    if (s && t.exclusiveMinimum && a <= c) {
      let l = t.serialize(t[n]).value || t[n], d = t.serialize(a).value || a;
      e.message("Expected " + r + " to be greater than " + _i(l) + ". Received: " + _i(d));
    } else if (a < c) {
      let l = t.serialize(t[n]).value || t[n], d = t.serialize(a).value || a;
      e.message("Expected " + r + " to be greater than or equal to " + _i(l) + ". Received: " + _i(d));
    }
  }
}
const cs = j0, hr = Qt, PW = "00000000";
cc.binary = {
  constructors: [Me.Buffer],
  deserialize: function({ exception: e, value: t }) {
    if (t instanceof Me.Buffer)
      return t;
    if (typeof t != "string" || !cs.binary.test(t))
      e.message("Expected a binary octet string");
    else {
      const r = t.length, i = [];
      for (let n = 0; n < r; n += 8)
        i.push(parseInt(t.substr(n, 8), 2));
      return Me.Buffer.from(i, "binary");
    }
  },
  random: nS(8),
  serialize: function({ exception: e, value: t }) {
    if (t instanceof Me.Buffer) {
      let r = "";
      for (let i = 0; i < t.length; i++) {
        const n = t[i].toString(2);
        r += PW.substr(n.length) + n;
      }
      return r;
    } else
      e.message("Expected a Buffer instance. Received: " + hr.smart(t));
  },
  validate: function({ exception: e, schema: t, value: r }) {
    Me.Buffer.isBuffer(r) ? hr.validateMaxMin(e, t, "binary length", "maxLength", "minLength", !0, r.length * 8, t.maxLength, t.minLength) : e.message("Expected value to be a buffer. Received: " + hr.smart(r));
  },
  validator: function(e) {
    const { exception: t } = e;
    this.hasOwnProperty("maxLength") && this.maxLength % 8 !== 0 && t.at("maxLength").message("Binary format requires maxLength to be a multiple of 8"), this.hasOwnProperty("minLength") && this.minLength % 8 !== 0 && t.at("minLength").message("Binary format requires minLength to be a multiple of 8");
  }
};
cc.byte = {
  constructors: [Me.Buffer],
  deserialize: function({ exception: e, value: t }) {
    if (t instanceof Me.Buffer)
      return t;
    if (typeof t == "string")
      if (t = t.replace(/(\s)/gm, ""), !cs.byte.test(t) || t.length % 4 !== 0)
        e.message("Expected a base64 string");
      else
        return Me.Buffer.from(t, "base64");
    else
      e.message("Expected a base64 string");
  },
  random: nS(4),
  serialize: function({ exception: e, value: t }) {
    if (t instanceof Me.Buffer)
      return t.toString("base64");
    e.message("Expected a Buffer instance. Received: " + hr.smart(t));
  },
  validate: function({ exception: e, schema: t, value: r }) {
    Me.Buffer.isBuffer(r) ? hr.validateMaxMin(e, t, "byte length", "maxLength", "minLength", !0, r.length, t.maxLength, t.minLength) : e.message("Expected value to be a buffer. Received: " + hr.smart(r));
  },
  validator: function(e) {
    const { exception: t } = e;
    this.hasOwnProperty("maxLength") && this.maxLength % 4 !== 0 && t.at("maxLength").message("Byte format requires maxLength to be a multiple of 4"), this.hasOwnProperty("minLength") && this.minLength % 4 !== 0 && t.at("minLength").message("Byte format requires minLength to be a multiple of 4");
  }
};
cc.date = {
  constructors: [Date],
  deserialize: function({ exception: e, value: t }) {
    if (t instanceof Date)
      return t;
    if (typeof t != "string" || !cs.date.test(t))
      e.message("Expected a date string of the format YYYY-MM-DD");
    else {
      const r = hr.getDateFromValidDateString("date", t);
      if (!r)
        e.message("Value is not a valid date");
      else
        return r;
    }
  },
  isNumeric: !0,
  random: iS,
  serialize: function({ exception: e, value: t }) {
    const r = t;
    if (typeof t === "string" && (cs.date.test(t) || cs.dateTime.test(t)) && (t = new Date(t)), hr.isDate(t))
      return t.toISOString().substr(0, 10);
    e.message("Expected a valid Date instance or date formatted string. Received: " + hr.smart(r));
  },
  validate: function({ exception: e, schema: t, value: r }) {
    hr.isDate(r) ? hr.validateMaxMin(e, t, t.format, "maximum", "minimum", !1, r, t.maximum, t.minimum) : e.message("Expected a valid date object. Received: " + hr.smart(r));
  },
  validator: function(e) {
    const { exception: t } = e;
    this.hasOwnProperty("maxLength") && this.maxLength !== 10 && t.at("maxLength").message("Date format requires maxLength to equal 10"), this.hasOwnProperty("minLength") && this.minLength % 4 !== 0 && t.at("minLength").message("Date format requires minLength to equal 10");
  }
};
cc.dateTime = {
  constructors: [Date],
  deserialize: function({ exception: e, value: t }) {
    if (t instanceof Date)
      return t;
    if (typeof t != "string" || !cs.dateTime.test(t))
      e.message("Expected a date-time string of the format YYYY-MM-DDThh:mm:ss.sssZ");
    else {
      const r = hr.getDateFromValidDateString("date-time", t);
      if (!r)
        e.message("Expected a date-time string of the format YYYY-MM-DDThh:mm:ss.sssZ");
      else
        return r;
    }
  },
  isNumeric: !0,
  random: iS,
  serialize: function({ exception: e, value: t }) {
    const r = t;
    if (typeof t === "string" && (cs.date.test(t) || cs.dateTime.test(t)) && (t = new Date(t)), hr.isDate(t))
      return t.toISOString();
    e.message("Expected a valid Date instance or an ISO date formatted string. Received: " + hr.smart(r));
  },
  validate: function({ exception: e, schema: t, value: r }) {
    hr.isDate(r) ? hr.validateMaxMin(e, t, t.format, "maximum", "minimum", !1, r, t.maximum, t.minimum) : e.message("Expected a valid date object. Received: " + hr.smart(r));
  },
  validator: function(e) {
    const { exception: t } = e;
    this.hasOwnProperty("maxLength") && this.maxLength !== 10 && t.at("maxLength").message("Date-time format requires maxLength to equal 24"), this.hasOwnProperty("minLength") && this.minLength % 4 !== 0 && t.at("minLength").message("Date-time format requires minLength to equal 24");
  }
};
function nS(e) {
  return function({ schema: t }, { randomNumber: r }) {
    const i = t.hasOwnProperty("minLength"), n = t.hasOwnProperty("maxLength"), s = {};
    i && n ? (s.min = t.minLength / e, s.max = t.maxLength / e) : i ? (s.min = +t.minLength / e, s.max = s.min + 25) : n ? (s.max = +t.maximum / e, s.min = s.max - 25) : (s.min = 1, s.max = 25);
    const a = r(s), u = [];
    for (let c = 0; c < a; c++)
      u.push(Math.floor(Math.random() * 256));
    return Me.Buffer.from(u);
  };
}
function iS({ schema: e }, { randomNumber: t }) {
  const i = e.hasOwnProperty("minimum"), n = e.hasOwnProperty("maximum"), s = {
    exclusiveMinimum: e.exclusiveMinimum,
    exclusiveMaximum: e.exclusiveMaximum
  };
  i && n ? (s.min = +e.minimum, s.max = +e.maximum) : i ? (s.min = +e.minimum, s.max = s.min + 157248e6) : n ? (s.max = +e.maximum, s.min = s.max - 157248e6) : (s.min = Date.now() - 78624e6, s.max = Date.now() + 78624e6);
  const a = t(s);
  if (a !== void 0)
    return new Date(a);
}
function zn(e) {
  if (typeof e != "string")
    throw new TypeError("Path must be a string. Received " + JSON.stringify(e));
}
function w$(e, t) {
  for (var r = "", i = 0, n = -1, s = 0, a, u = 0; u <= e.length; ++u) {
    if (u < e.length)
      a = e.charCodeAt(u);
    else {
      if (a === 47)
        break;
      a = 47;
    }
    if (a === 47) {
      if (!(n === u - 1 || s === 1))
        if (n !== u - 1 && s === 2) {
          if (r.length < 2 || i !== 2 || r.charCodeAt(r.length - 1) !== 46 || r.charCodeAt(r.length - 2) !== 46) {
            if (r.length > 2) {
              var c = r.lastIndexOf("/");
              if (c !== r.length - 1) {
                c === -1 ? (r = "", i = 0) : (r = r.slice(0, c), i = r.length - 1 - r.lastIndexOf("/")), n = u, s = 0;
                continue;
              }
            } else if (r.length === 2 || r.length === 1) {
              r = "", i = 0, n = u, s = 0;
              continue;
            }
          }
          t && (r.length > 0 ? r += "/.." : r = "..", i = 2);
        } else
          r.length > 0 ? r += "/" + e.slice(n + 1, u) : r = e.slice(n + 1, u), i = u - n - 1;
      n = u, s = 0;
    } else
      a === 46 && s !== -1 ? ++s : s = -1;
  }
  return r;
}
function SW(e, t) {
  var r = t.dir || t.root, i = t.base || (t.name || "") + (t.ext || "");
  return r ? r === t.root ? r + i : r + e + i : i;
}
var eo = {
  // path.resolve([from ...], to)
  resolve: function() {
    for (var t = "", r = !1, i, n = arguments.length - 1; n >= -1 && !r; n--) {
      var s;
      n >= 0 ? s = arguments[n] : (i === void 0 && (i = Me.process.cwd()), s = i), zn(s), s.length !== 0 && (t = s + "/" + t, r = s.charCodeAt(0) === 47);
    }
    return t = w$(t, !r), r ? t.length > 0 ? "/" + t : "/" : t.length > 0 ? t : ".";
  },
  normalize: function(t) {
    if (zn(t), t.length === 0)
      return ".";
    var r = t.charCodeAt(0) === 47, i = t.charCodeAt(t.length - 1) === 47;
    return t = w$(t, !r), t.length === 0 && !r && (t = "."), t.length > 0 && i && (t += "/"), r ? "/" + t : t;
  },
  isAbsolute: function(t) {
    return zn(t), t.length > 0 && t.charCodeAt(0) === 47;
  },
  join: function() {
    if (arguments.length === 0)
      return ".";
    for (var t, r = 0; r < arguments.length; ++r) {
      var i = arguments[r];
      zn(i), i.length > 0 && (t === void 0 ? t = i : t += "/" + i);
    }
    return t === void 0 ? "." : eo.normalize(t);
  },
  relative: function(t, r) {
    if (zn(t), zn(r), t === r || (t = eo.resolve(t), r = eo.resolve(r), t === r))
      return "";
    for (var i = 1; i < t.length && t.charCodeAt(i) === 47; ++i)
      ;
    for (var n = t.length, s = n - i, a = 1; a < r.length && r.charCodeAt(a) === 47; ++a)
      ;
    for (var u = r.length, c = u - a, l = s < c ? s : c, d = -1, p = 0; p <= l; ++p) {
      if (p === l) {
        if (c > l) {
          if (r.charCodeAt(a + p) === 47)
            return r.slice(a + p + 1);
          if (p === 0)
            return r.slice(a + p);
        } else
          s > l && (t.charCodeAt(i + p) === 47 ? d = p : p === 0 && (d = 0));
        break;
      }
      var h = t.charCodeAt(i + p), v = r.charCodeAt(a + p);
      if (h !== v)
        break;
      h === 47 && (d = p);
    }
    var y = "";
    for (p = i + d + 1; p <= n; ++p)
      (p === n || t.charCodeAt(p) === 47) && (y.length === 0 ? y += ".." : y += "/..");
    return y.length > 0 ? y + r.slice(a + d) : (a += d, r.charCodeAt(a) === 47 && ++a, r.slice(a));
  },
  _makeLong: function(t) {
    return t;
  },
  dirname: function(t) {
    if (zn(t), t.length === 0)
      return ".";
    for (var r = t.charCodeAt(0), i = r === 47, n = -1, s = !0, a = t.length - 1; a >= 1; --a)
      if (r = t.charCodeAt(a), r === 47) {
        if (!s) {
          n = a;
          break;
        }
      } else
        s = !1;
    return n === -1 ? i ? "/" : "." : i && n === 1 ? "//" : t.slice(0, n);
  },
  basename: function(t, r) {
    if (r !== void 0 && typeof r != "string")
      throw new TypeError('"ext" argument must be a string');
    zn(t);
    var i = 0, n = -1, s = !0, a;
    if (r !== void 0 && r.length > 0 && r.length <= t.length) {
      if (r.length === t.length && r === t)
        return "";
      var u = r.length - 1, c = -1;
      for (a = t.length - 1; a >= 0; --a) {
        var l = t.charCodeAt(a);
        if (l === 47) {
          if (!s) {
            i = a + 1;
            break;
          }
        } else
          c === -1 && (s = !1, c = a + 1), u >= 0 && (l === r.charCodeAt(u) ? --u === -1 && (n = a) : (u = -1, n = c));
      }
      return i === n ? n = c : n === -1 && (n = t.length), t.slice(i, n);
    } else {
      for (a = t.length - 1; a >= 0; --a)
        if (t.charCodeAt(a) === 47) {
          if (!s) {
            i = a + 1;
            break;
          }
        } else
          n === -1 && (s = !1, n = a + 1);
      return n === -1 ? "" : t.slice(i, n);
    }
  },
  extname: function(t) {
    zn(t);
    for (var r = -1, i = 0, n = -1, s = !0, a = 0, u = t.length - 1; u >= 0; --u) {
      var c = t.charCodeAt(u);
      if (c === 47) {
        if (!s) {
          i = u + 1;
          break;
        }
        continue;
      }
      n === -1 && (s = !1, n = u + 1), c === 46 ? r === -1 ? r = u : a !== 1 && (a = 1) : r !== -1 && (a = -1);
    }
    return r === -1 || n === -1 || // We saw a non-dot character immediately before the dot
    a === 0 || // The (right-most) trimmed path component is exactly '..'
    a === 1 && r === n - 1 && r === i + 1 ? "" : t.slice(r, n);
  },
  format: function(t) {
    if (t === null || typeof t != "object")
      throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof t);
    return SW("/", t);
  },
  parse: function(t) {
    zn(t);
    var r = { root: "", dir: "", base: "", ext: "", name: "" };
    if (t.length === 0)
      return r;
    var i = t.charCodeAt(0), n = i === 47, s;
    n ? (r.root = "/", s = 1) : s = 0;
    for (var a = -1, u = 0, c = -1, l = !0, d = t.length - 1, p = 0; d >= s; --d) {
      if (i = t.charCodeAt(d), i === 47) {
        if (!l) {
          u = d + 1;
          break;
        }
        continue;
      }
      c === -1 && (l = !1, c = d + 1), i === 46 ? a === -1 ? a = d : p !== 1 && (p = 1) : a !== -1 && (p = -1);
    }
    return a === -1 || c === -1 || // We saw a non-dot character immediately before the dot
    p === 0 || // The (right-most) trimmed path component is exactly '..'
    p === 1 && a === c - 1 && a === u + 1 ? c !== -1 && (u === 0 && n ? r.base = r.name = t.slice(1, c) : r.base = r.name = t.slice(u, c)) : (u === 0 && n ? (r.name = t.slice(1, a), r.base = t.slice(1, c)) : (r.name = t.slice(u, a), r.base = t.slice(u, c)), r.ext = t.slice(a, c)), u > 0 ? r.dir = t.slice(0, u - 1) : n && (r.dir = "/"), r;
  },
  sep: "/",
  delimiter: ":",
  win32: null,
  posix: null
};
eo.posix = eo;
var AW = eo;
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
const CW = ["value", "error", "warning"];
var _s = Vu;
function Vu(e, t, r) {
  if (!(this instanceof Vu))
    return new Vu(e, t, r);
  (!t || !t.hasException) && (t = void 0), (!r || !r.hasException) && (r = void 0), t && (e = void 0), this.error = t, this.value = e, this.warning = r, this.__iterableIndex = -1;
}
Vu.prototype[Symbol.iterator] = function() {
  return this;
};
Vu.prototype.next = function() {
  return this.__iterableIndex++, this.__iterableIndex > 2 && (this.__iterableIndex = 0), {
    done: !1,
    value: this[CW[this.__iterableIndex]]
  };
};
const k0 = qn, RW = gO, Zu = AW, Pf = _s, sS = ku, aS = Qt, $$ = _r, TW = jO, IW = Hf, ig = /^https?:\/\//i, jW = /\.ya?ml$/i, kW = /\.json$/i;
var oS = wo;
const fc = /* @__PURE__ */ new WeakMap();
function wo(e) {
  this.$refs = {}, fc.set(this, {
    bundled: null,
    dereferenced: null,
    // will hold dereference() returned EnforcerResult
    loads: {},
    // a map of loaded resources
    refs: this.$refs,
    sourceMap: { "": [] },
    // a map of source paths to nodes within the source
    source: e
  });
}
wo.prototype.bundle = async function() {
  const e = fc.get(this);
  if (e.bundled) {
    const { value: s, error: a, warning: u } = e.bundled;
    return new Pf(s, a, u);
  }
  const t = new k0("Unable to bundle definition for one or more reasons"), [r, i] = await this.dereference(), n = aS.copy(r);
  if (i)
    t.push(i);
  else {
    const s = sg(n, null, "", "#", []), a = Array.from(s.keys()).map((l) => {
      const d = s.get(l);
      return { node: l, refs: d };
    }).filter((l) => l.refs.length > 1), c = NW(n) === 2 ? ["definitions", "parameters", "responses", "securityDefinitions", "security", "tags", "externalDocs"] : ["components/schemas", "components/responses", "components/parameters", "components/examples", "components/requestBodies", "components/headers", "components/securitySchemes", "components/links", "components/callbacks", "components", "security", "servers", "tags", "externalDocs"];
    a.forEach((l) => {
      const d = l.refs;
      d.sort((p, h) => {
        const v = p.path, y = h.path;
        let g = c.findIndex((m) => v.startsWith("#/" + m)), _ = c.findIndex((m) => y.startsWith("#/" + m));
        return g === -1 && (g = Number.MAX_SAFE_INTEGER), _ === -1 && (_ = Number.MAX_SAFE_INTEGER), g < _ ? -1 : g > _ ? 1 : v.split("/").length < y.split("/").length ? -1 : 1;
      }), l.ref = d[0];
    }), a.sort((l, d) => l.ref.pathLength > d.ref.pathLength ? -1 : 1), a.forEach((l) => {
      const d = l.refs, p = d.length;
      for (let h = 1; h < p; h++) {
        const v = d[h];
        v.parent[v.key] = { $ref: l.ref.path };
      }
    });
  }
  return e.bundled = new Pf(n, t), e.bundled;
};
wo.prototype.dereference = async function() {
  const e = fc.get(this);
  if (e.dereferenced) {
    const { value: s, error: a, warning: u } = e.dereferenced;
    return new Pf(s, a, u);
  }
  const t = new k0("Unable to dereference definition for one or more reasons"), { source: r } = e, i = Me.process.cwd();
  let n;
  if (typeof r == "string") {
    const s = await cS(i, r, t, e);
    n = await Wa(Zu.dirname(s.path), s.path, s.value, s.value, e, /* @__PURE__ */ new Map(), [], t.at(s.path)), e.refs[s.path] = n;
  } else {
    const s = aS.copy(r);
    n = await Wa(i, "", s, s, e, /* @__PURE__ */ new Map(), [], t.at("root object")), e.refs[""] = n;
  }
  return e.dereferenced = new Pf(n, t), e.dereferenced;
};
wo.prototype.getSourceNode = function(e) {
  const t = this.getSourcePath(e);
  return this.$refs[t];
};
wo.prototype.getSourcePath = function(e) {
  const t = fc.get(this);
  uS(t);
  const r = t.sourceMap, i = Object.keys(r), n = i.length;
  for (let s = 0; s < n; s++) {
    const a = i[s];
    if (r[a].includes(e))
      return a;
  }
};
wo.prototype.resolvePath = function(e, t) {
  const r = fc.get(this);
  uS(r);
  const i = new k0("Could not resolve path from node"), [n, s] = t.split("#");
  let a;
  if (!n)
    a = Sf(e, s, i);
  else {
    const u = this.getSourcePath(e);
    if (!u)
      i.message("Unable to resolve source path for provided node.");
    else {
      const c = Zu.dirname(u), l = ig.test(c) ? sS.resolve(c, n) : Zu.resolve(c, n);
      this.$refs.hasOwnProperty(l) ? a = Sf(this.$refs[l], s, i) : i.message("Unable to resolve paths that were not already resolved during dereference.");
    }
  }
  if (i.hasException)
    throw Error(i.toString());
  return a;
};
function MW() {
  const e = {};
  return e.promise = new Promise((t, r) => {
    e.resolve = t, e.reject = r;
  }), e;
}
function uS(e) {
  if (!e.dereferenced)
    throw Error("You must first call the dereference function before looking up node source.");
  if (e.dereferenced.error)
    throw Error("Cannot get source for a node when dereference has failed.");
}
function sg(e, t, r, i, n, s = /* @__PURE__ */ new Map()) {
  if (e && typeof e == "object") {
    if (n.includes(e))
      return;
    n = n.slice(), n.push(e);
    const a = {
      key: r,
      parent: t,
      path: i,
      pathLength: n.length
    }, u = s.get(e);
    if (u)
      return u.push(a), s;
    s.set(e, [a]), Array.isArray(e) ? e.forEach((c, l) => {
      sg(c, e, l, i + "/" + l, n, s);
    }) : Object.keys(e).forEach((c) => {
      sg(e[c], e, c, i + "/" + c.replace(/~/g, "~0").replace(/\//g, "~1"), n, s);
    });
  }
  return s;
}
function NW(e) {
  if (e) {
    if (e.swagger)
      return 2;
    if (e.openapi) {
      const t = e.openapi.split(".")[0];
      if (/^\d$/.test(t))
        return +t;
    }
  }
}
async function Wa(e, t, r, i, n, s, a, u) {
  if (Array.isArray(i)) {
    if (s.has(i))
      return s.get(i);
    s.set(i, i), n.sourceMap[t].push(i);
    const l = i.map(async (d, p) => {
      i[p] = await Wa(e, t, r, d, n, s, a, u.at(String(p)));
    });
    return await Promise.all(l), i;
  } else if (i && typeof i == "object")
    if (i.hasOwnProperty("$ref") && typeof i.$ref == "string") {
      if (a.includes(i)) {
        u.message("Unresolvable infinite loop");
        return;
      }
      const [, l] = i.$ref.split("#");
      let d = e, p = t, h = r, v;
      if (i.$ref.startsWith("#/"))
        v = Sf(r, l, u);
      else {
        const y = await cS(e, i.$ref, u, n), g = u.at(y.path);
        p = y.path, d = Zu.dirname(p), h = await Wa(d, p, y.value, y.value, n, s, a, g), n.refs[y.path] = h, v = h ? Sf(h, l, g) : void 0;
      }
      return v = await Wa(d, p, h, v, n, s, a.concat([i]), u), v;
    } else {
      const c = s.get(i);
      if (c)
        return c;
      s.set(i, i), n.sourceMap[t].push(i);
      const l = Object.keys(i).map(async (d) => {
        i[d] = await Wa(e, t, r, i[d], n, s, a, u.at(d));
      });
      return await Promise.all(l), i;
    }
  else
    return i;
}
async function cS(e, t, r, i) {
  const { loads: n, sourceMap: s } = i, { loadPath: a, loadMethod: u } = qW(e, t);
  if (n[a])
    return n[a];
  const c = MW();
  n[a] = c.promise;
  const l = await u(a, r.at(a));
  return s[a] = [], c.resolve({
    path: a,
    value: l
  }), c.promise;
}
function DW(e, t) {
  return new Promise((r, i) => {
    const s = (e.startsWith("https") ? TW : IW).request(e, {}, (a) => {
      if (a.statusCode < 200 || a.statusCode >= 300)
        t.message("Request failed with status code " + a.statusCode), r();
      else {
        const u = a.headers["content-type"];
        let c;
        /^application\/json/.test(u) && (c = "json"), /^(?:text|application)\/(?:x-)?yaml/.test(u) && (c = "yaml");
        let l = "";
        a.setEncoding("utf8"), a.on("data", (d) => {
          l += d;
        }), a.on("end", () => {
          const d = lS(l, c, t.nest("Unable to parse resource: " + e));
          r(d.value);
        }), a.on("error", (d) => {
          t.message("Unexpected error: " + d.message), r();
        });
      }
    });
    s.on("error", i), s.end();
  });
}
function LW(e, t) {
  return new Promise((r) => {
    RW.readFile(e, "utf8", (i, n) => {
      if (i && (i.code === "ENOENT" || i.code === "ENOTDIR"))
        t.message("Unable to find referenced file: " + e), r();
      else if (i)
        t.message('Unable to read file "' + e + '": ' + i.toString()), r();
      else {
        let s;
        kW.test(e) && (s = "json"), jW.test(e) && (s = "yaml");
        const a = lS(n, s, t.nest("Unable to parse file: " + e));
        r(a.value);
      }
    });
  });
}
function lS(e, t, r) {
  let i;
  if (t === "json")
    try {
      i = JSON.parse(e);
    } catch (n) {
      r.message(n.toString());
    }
  else if (t === "yaml")
    try {
      i = $$.load(e);
    } catch (n) {
      r.message(n.toString());
    }
  else
    try {
      i = JSON.parse(e), t = "json";
    } catch {
      try {
        i = $$.load(e), t = "yaml";
      } catch {
        r.message("Not valid JSON or YAML");
      }
    }
  return {
    type: t,
    value: i
  };
}
function qW(e, t) {
  const [r] = t.split("#");
  return ig.test(e) || ig.test(t) ? {
    loadPath: sS.resolve(e, r),
    loadMethod: DW
  } : {
    loadPath: Zu.resolve(e, r),
    loadMethod: LW
  };
}
function Sf(e, t, r) {
  if (!t)
    return e;
  if (!t.startsWith("/")) {
    r.message("References must start with #/");
    return;
  }
  const i = t.substring(1).split("/");
  let n = e;
  for (; i.length; ) {
    const s = i.shift().replace(/~1/g, "/").replace(/~0/g, "~");
    if (s !== "#")
      if (n && typeof n == "object" && s in n)
        n = n[s];
      else {
        r.message("Cannot resolve reference: #" + t);
        return;
      }
  }
  return n;
}
function FW(e) {
  throw new Error('Could not dynamically require "' + e + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var sr = zu;
function zu(e, t) {
  if (!(this instanceof zu))
    return new zu(e, t);
  this.config = t, this.value = e;
}
zu.isEnforcerRef = function(e) {
  return typeof e == "object" && e instanceof zu;
};
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
const zl = sr, rs = Qt, UW = /^x-.+/;
var BW = Af;
function uu(e, t, r) {
  const i = e.definition[t], n = !e.production, s = rs.getDefinitionType(i);
  let a;
  return s === "array" ? a = [] : s === "object" ? a = {} : a = i, {
    context: e.context,
    definition: i,
    definitionType: s,
    defToInstanceMap: e.defToInstanceMap,
    exception: n ? e.exception.at(t) : e.exception,
    key: t,
    major: e.major,
    map: e.map,
    minor: e.minor,
    options: e.options,
    parent: e,
    patch: e.patch,
    plugins: e.plugins,
    production: e.production,
    refParser: e.refParser,
    result: a,
    root: e.root,
    staticData: null,
    usedDefault: !1,
    validator: r,
    warn: n ? e.warn.at(t) : e.warn
  };
}
function Af(e, t, r) {
  const { definitionType: i, exception: n, production: s, result: a } = e, u = r.exceptionSkipCodes;
  let c = e.definition;
  try {
    const l = kr(e.validator, e), d = l.freeForm;
    if (!fS(i, e))
      return;
    if (c && typeof c == "object") {
      const h = VW(e);
      if (h)
        return h.value;
      tu(e, a);
    }
    if (s)
      i === "array" ? (c.forEach((h, v) => {
        const y = uu(e, v, l.items);
        a.push(ru(y, t, r));
      }), Object.freeze(a)) : i === "object" ? (Object.keys(c).forEach((v) => {
        let y;
        typeof l != "object" ? y = l : l.properties && l.properties.hasOwnProperty(v) ? y = l.properties[v] : l.additionalProperties && (y = l.additionalProperties);
        const g = uu(e, v, y);
        Object.defineProperty(a, v, {
          configurable: !0,
          enumerable: !0,
          value: ru(g, t, r)
        });
      }), E$(l, e).forEach(({ data: v }) => {
        const y = v.key;
        if (!a.hasOwnProperty(y)) {
          const g = v.validator, _ = zl.isEnforcerRef(g) ? g.config || {} : g;
          if ((_.hasOwnProperty("allowed") ? kr(_.allowed, v) : !0) && _.hasOwnProperty("default")) {
            const w = kr(_.default, v);
            Object.defineProperty(a, y, {
              configurable: !0,
              enumerable: !0,
              value: w
            });
          }
        }
      })) : (e.result = c, tu(e, c));
    else {
      if (l.enum) {
        const h = kr(l.enum, e);
        h.includes(c) || (h.length === 1 ? n.message("Value must be " + rs.smart(h[0]) + ". Received: " + rs.smart(c)) : n.message("Value must be one of: " + h.join(", ") + ". Received: " + rs.smart(c)));
      }
      if (i === "array" && !d)
        c.forEach((h, v) => {
          const y = uu(e, v, l.items);
          a.push(ru(y, t, r));
        }), Object.freeze(a);
      else if (i === "object" && !d) {
        const h = [], v = [], y = [];
        l === !0 ? Object.keys(c).forEach((g) => {
          Object.defineProperty(a, g, {
            configurable: !0,
            enumerable: !0,
            value: c[g]
          });
        }) : l === !1 ? v.push.apply(v, Object.keys(c)) : l.additionalProperties ? Object.keys(c).forEach((g) => {
          const _ = uu(e, g, l.additionalProperties), m = zl.isEnforcerRef(_.validator) ? _.validator.config || {} : _.validator, w = m.hasOwnProperty("allowed") ? kr(m.allowed, _) : !0;
          let $ = !1;
          if (_.definition !== void 0 && (w ? (!m.ignored || !kr(m.ignored, _)) && (Object.defineProperty(a, g, {
            configurable: !0,
            enumerable: !0,
            value: ru(_, t, r)
          }), $ = !0) : v.push(g)), $ && m.errors && m !== _.validator) {
            const E = Object.assign({}, _);
            E.definition = a[g], kr(m.errors, E);
          }
        }) : (Object.keys(c).forEach((_) => {
          UW.test(_) ? Object.defineProperty(a, _, {
            configurable: !0,
            enumerable: !0,
            value: c[_]
          }) : y.push(_);
        }), E$(l, e).forEach((_) => {
          const m = _.data, w = m.key, $ = m.validator, E = zl.isEnforcerRef($) ? $.config || {} : $, A = E.hasOwnProperty("allowed") ? kr(E.allowed, m) : !0;
          if (rs.arrayRemoveItem(y, w), m.definition === void 0 && A && E.hasOwnProperty("default")) {
            const R = kr(E.default, m);
            R !== void 0 && (m.definition = R, m.usedDefault = !0, m.parent.definition[w] = m.definition, m.definitionType = rs.getDefinitionType(m.definition));
          }
          m.definition !== void 0 ? A ? (!E.ignored || !kr(E.ignored, m)) && Object.defineProperty(a, w, {
            configurable: !0,
            enumerable: !0,
            value: ru(m, t, r)
          }) : v.push(w) : A && E.required && kr(E.required, m) && h.push(w);
        })), v.push.apply(v, y), v.length && !u.EDEV001 && !rs.schemaObjectHasSkipCode(c, "EDEV001") && (v.sort(), n.message("Propert" + (v.length === 1 ? "y" : "ies") + " not allowed: " + v.join(", ") + " [EDEV001]")), h.length && (h.sort(), n.message("Missing required propert" + (h.length === 1 ? "y" : "ies") + ": " + h.join(", ")));
      } else if (d)
        e.result = c, tu(e, c);
      else
        switch (i) {
          case "boolean":
          case "null":
          case "number":
          case "string":
            e.result = c, tu(e, c);
            break;
          default:
            n.message("Unknown data type provided");
            break;
        }
    }
    let p = e.definition;
    if (l.deserialize) {
      const h = Object.assign({}, e);
      p = l.deserialize(h), e.result = p, tu(e, c);
    }
    if (!s && l.errors) {
      const h = Object.assign({}, e);
      h.definition = p, kr(l.errors, h);
    }
  } catch (l) {
    n.message("Unexpected error encountered: " + l.stack);
  }
  return e.result;
}
Af.isValidatorState = function(e) {
  return e instanceof dS;
};
function eu(e) {
  return e === "array" ? "an array" : e === "object" ? "a plain object" : "a " + e;
}
function kr(e, t) {
  if (typeof e == "function")
    try {
      return e(t);
    } catch (r) {
      t.exception.message("Unexpected error encountered: " + r.stack);
    }
  else
    return e;
}
function E$(e, t) {
  const r = Object.keys(e.properties || {}).map((i) => {
    const n = e.properties[i];
    return {
      data: uu(t, i, n),
      weight: n.weight || 0
    };
  });
  return r.sort((i, n) => i.weight < n.weight ? -1 : i.weight > n.weight ? 1 : i.data.key < n.data.key ? -1 : 1), r;
}
function VW(e) {
  const { definition: t, map: r, validator: i } = e, n = r.get(t);
  if (!n)
    return;
  let s = n.find((a) => a.validator === i);
  return s ? s.value : void 0;
}
function tu(e, t) {
  const { definition: r, map: i, validator: n } = e;
  let s = i.get(r);
  s || (s = [], i.set(r, s));
  const a = s.find((u) => u.validator === n);
  a ? a.value = t : s.push({ validator: n, value: t });
}
function ru(e, t, r) {
  const i = kr(e.validator, e);
  if (e.validator = i, zl.isEnforcerRef(i)) {
    const n = e.validator.config;
    if (e.definitionType === "boolean")
      return e.validator = e.validator.config, Af(e, t, r);
    if (!n || fS(e.definitionType, Object.assign({}, e, { validator: n })))
      return new e.context[i.value](new dS(e), t, r);
  } else
    return e.validator ? Af(e, t, r) : e.result;
}
function fS(e, t) {
  const { definition: r, exception: i } = t, n = kr(t.validator, t);
  if (!t.production && n.type && r !== void 0) {
    let s = kr(n.type, t);
    if (Array.isArray(s) || (s = [s]), s = s.map((c) => c === "integer" ? "number" : c), s.includes("any") || s.includes(e))
      return !0;
    const a = s.length;
    let u;
    if (a === 1)
      u = eu(s[0]);
    else if (a === 2)
      u = eu(s[0]) + " or " + eu(s[1]);
    else {
      const c = s.pop();
      u = s.map((l) => eu(l)).join(", ") + ", or " + eu(c);
    }
    return i.message("Value must be " + u + ". Received: " + rs.smart(r)), !1;
  } else
    return !0;
}
function dS(e) {
  Object.assign(this, e);
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var ZW = zW;
const im = BW, x$ = qn, O$ = _s, bl = Qt, P$ = { post: !0, put: !0, options: !0, head: !0, patch: !0 };
function zW(e, t, r) {
  return r || (r = FW("./enforcers/" + t)), WW(e, t, r);
}
function WW(e, t, r) {
  const i = [], n = /* @__PURE__ */ new WeakMap(), s = new Function(
    "build",
    `const F = function ${t} (definition, refParser, options) {
            if (!(this instanceof F)) return new F(definition, refParser, options)
            return build(this, definition, refParser, options)
        }
        return F`
  )(u);
  s.prototype = Object.assign({}, r.prototype || {}), s.constructor = s, Object.defineProperty(s, "enforcerDefinition", {
    value: r
  }), Object.defineProperty(s.prototype, "enforcerData", {
    get: function() {
      return n.get(this);
    }
  }), s.prototype.toObject = function() {
    return c(this, /* @__PURE__ */ new Map());
  }, s.extend = function(l) {
    if (typeof l != "function")
      throw Error("Invalid input. Callback must be a function. Received: " + l);
    i.push(l);
  };
  const a = {};
  if (r.statics) {
    const l = r.statics(a);
    Object.keys(l).forEach((d) => {
      s[d] = l[d];
    });
  }
  function u(l, d, p, h = {}) {
    const v = !im.isValidatorState(d);
    h || (h = {}), v && (h = Object.assign({}, h)), h.requestBodyAllowedMethods = h.hasOwnProperty("requestBodyAllowedMethods") ? Object.assign({}, P$, h.requestBodyAllowedMethods) : P$, h.disablePathNormalization = h.hasOwnProperty("disablePathNormalization") ? !!h.disablePathNormalization : !1, h.apiSuggestions = h.hasOwnProperty("apiSuggestions") ? !!h.apiSuggestions : !0, h.production = !!h.production, h.exceptionSkipCodes = h.hasOwnProperty("exceptionSkipCodes") ? Array.isArray(h.exceptionSkipCodes) ? h.exceptionSkipCodes.reduce((m, w) => (m[w] = !0, m), {}) : h.exceptionSkipCodes : {}, h.exceptionEscalateCodes = h.hasOwnProperty("exceptionEscalateCodes") ? Array.isArray(h.exceptionEscalateCodes) ? h.exceptionEscalateCodes.reduce((m, w) => (m[w] = !0, m), {}) : h.exceptionEscalateCodes : {};
    let y;
    if (v) {
      const m = /^(\d+)(?:\.(\d+))(?:\.(\d+))?$/.exec(e.version);
      p || (d = bl.copy(d)), y = {
        context: e,
        definition: d,
        defToInstanceMap: /* @__PURE__ */ new WeakMap(),
        definitionType: bl.getDefinitionType(d),
        exception: x$("One or more errors exist in the " + t + " definition"),
        key: void 0,
        map: /* @__PURE__ */ new Map(),
        major: +m[1],
        minor: +m[2],
        parent: null,
        patch: +(m[3] || 0),
        plugins: [],
        production: h.production,
        refParser: p,
        result: l,
        staticData: a,
        validator: r.validator,
        warn: x$("One or more warnings exist in the " + t + " definition"),
        options: h
      }, y.root = y;
    } else
      y = d, y.staticData = a, y.validator = r.validator, y.result = l;
    const g = y.map.get(y.definition), _ = g ? g.find((m) => m.validator === y.validator) : void 0;
    if (_)
      y.result = l = _.value, im(y, p, h);
    else {
      if (n.set(l, y), y.definition && typeof y.definition == "object" && y.defToInstanceMap.set(y.definition, l), bl.isPlainObject(y.definition) ? im(y, p, h) : y.exception.message("Value must be a plain object"), y.exception.hasException && v)
        return new O$(void 0, y.exception, y.warn);
      r.init && r.init.call(l, y);
      const m = y.plugins;
      i.forEach((w) => m.push(function() {
        w.call(l, {
          enforcers: e,
          exception: y.exception,
          key: y.key,
          major: y.major,
          minor: y.minor,
          parent: y.parent && y.parent.result || null,
          patch: y.patch,
          root: y.root.result,
          warn: y.warn
        });
      }));
    }
    if (v)
      for (; y.plugins.length; )
        y.plugins.shift()();
    return v ? new O$(l, y.exception, y.warn) : l;
  }
  function c(l, d) {
    if (Array.isArray(l)) {
      const p = d.get(l);
      if (p)
        return p;
      const h = [];
      return d.set(l, h), l.forEach((v) => {
        h.push(c(v, d));
      }), h;
    } else if (bl.isPlainObject(l)) {
      const p = d.get(l);
      if (p)
        return p;
      const h = {};
      return d.set(l, h), Object.keys(l).forEach((v) => {
        h[v] = c(l[v], d);
      }), h;
    } else
      return l;
  }
  return s;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var sm, S$;
function A$() {
  return S$ || (S$ = 1, sm = {
    init: function(e) {
    },
    prototype: {},
    validator: function() {
      return {
        type: "object",
        properties: {
          name: {
            type: "string"
          },
          url: {
            type: "string"
          },
          email: {
            type: "string"
          }
        }
      };
    }
  }), sm;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var am, C$;
function R$() {
  return C$ || (C$ = 1, am = {
    init: function(e) {
    },
    prototype: {},
    validator: function(e) {
      return {
        type: "object",
        properties: {
          description: "string",
          url: {
            type: "string",
            required: !0
          }
        }
      };
    }
  }), am;
}
var _l = {};
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var T$;
function pS() {
  if (T$)
    return _l;
  T$ = 1;
  const e = sr, t = [
    "default",
    "enum",
    "exclusiveMaximum",
    "exclusiveMinimum",
    "format",
    "items",
    "maximum",
    "maxItems",
    "maxLength",
    "minimum",
    "minItems",
    "minLength",
    "multipleOf",
    "pattern",
    "type",
    "uniqueItems"
  ];
  _l.extractSchemaDefinition = r, _l.validator = (i) => {
    const { major: n } = i, s = {
      type: "object"
    };
    return n === 2 ? (s.properties = {}, Object.assign(s.properties, {
      type: {
        weight: -15,
        required: !0,
        enum: ["array", "boolean", "integer", "number", "string"]
      },
      collectionFormat: {
        allowed: ({ parent: a }) => a.definition.type === "array",
        enum: ["csv", "ssv", "tsv", "pipes"],
        default: "csv"
      },
      default: { allowed: !0 },
      description: {
        type: "string"
      },
      enum: {
        allowed: !0,
        type: "array",
        items: { freeForm: !0 }
      },
      exclusiveMaximum: { allowed: !0 },
      exclusiveMinimum: { allowed: !0 },
      format: { allowed: !0 },
      items: {
        type: "object",
        allowed: ({ parent: a }) => a.definition.type === "array",
        required: ({ parent: a }) => a.definition.type === "array",
        properties: s.properties,
        errors: s.errors
      },
      maximum: { allowed: !0 },
      maxItems: { allowed: !0 },
      maxLength: { allowed: !0 },
      minimum: { allowed: !0 },
      minItems: { allowed: !0 },
      minLength: { allowed: !0 },
      multipleOf: { allowed: !0 },
      pattern: { allowed: !0 },
      uniqueItems: { allowed: !0 }
    }), s.errors = () => {
    }) : n === 3 && (s.properties = {
      content: {
        type: "object",
        additionalProperties: e("MediaType"),
        errors: ({ exception: a, definition: u }) => {
          const c = Object.keys(u);
          c.length !== 1 && a.message("Value must have exactly one key. Received: " + c.join(", "));
        }
      },
      deprecated: {
        type: "boolean"
      },
      description: {
        type: "string"
      },
      example: { allowed: !0, freeForm: !0 },
      examples: {
        type: "object",
        additionalProperties: e("Example")
      },
      schema: e("Schema")
    }, s.errors = ({ exception: a, major: u, definition: c }) => {
      c.hasOwnProperty("content") && c.hasOwnProperty("schema") ? a.message('Cannot have both "content" and "schema" properties') : !c.hasOwnProperty("content") && !c.hasOwnProperty("schema") && a.message('Missing required property "content" or "schema"'), c.hasOwnProperty("example") && c.hasOwnProperty("examples") && a.message('Cannot have both "example" and "examples" properties');
    }), s;
  };
  function r(i, n) {
    return t.forEach((s) => {
      if (n.hasOwnProperty(s)) {
        const a = n[s];
        switch (s) {
          case "items":
            i[s] = r({}, a);
            break;
          default:
            i[s] = a;
            break;
        }
      }
    }), i;
  }
  return _l;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var om, I$;
function j$() {
  if (I$)
    return om;
  I$ = 1;
  const e = pS(), t = qn, r = _s, i = Qt;
  om = {
    init: function(a) {
      const { context: u, exception: c, major: l, warn: d, options: p } = a;
      if (l === 2) {
        const h = e.extractSchemaDefinition({}, this), [v, y, g] = u.Schema(h);
        v && (this.schema = v), y && c.merge(y), g && d.merge(g);
      }
      i.validateExamples(this, c, d, p);
    },
    prototype: {
      stringify: function(a) {
        const { major: u } = this.enforcerData, c = this.schema, l = t("Unable to stringify value");
        if (u === 2)
          return new r(s(this, this, l, a), l);
        if (u === 3) {
          const d = c && c.type;
          let p;
          if (d === "array")
            p = a.map((h, v) => n(this, c.items, l.at(v), h)).join(",");
          else if (d === "object") {
            const h = [];
            Object.keys(a).forEach((v) => {
              const y = c.properties.hasOwnProperty(v) ? c.properties[v] : c.additionalProperties;
              let g = a[v];
              y !== !0 ? g = n(this, y, l.at(v), g) : typeof g != "string" && l.message("Unable to stringify value: " + i.smart(g)), typeof g == "string" && (this.explode ? h.push(v + "=" + g) : h.push(v, g));
            }), p = h.join(",");
          } else
            p = n(this, c, l, a);
          return new r(p, l);
        }
      }
    },
    validator: function(a) {
      const { major: u } = a, c = e.validator(a);
      return Object.assign(c.properties, {
        explode: {
          type: "boolean",
          default: !1
        },
        required: {
          type: "boolean",
          default: !1
        },
        style: {
          weight: -5,
          allowed: u === 3,
          type: "string",
          default: "simple",
          enum: ["simple"]
        }
      }), c;
    }
  };
  function n(a, u, c, l) {
    if (l === void 0) {
      if (a.allowEmptyValue)
        return "";
      c.message("Empty value not allowed");
    } else if (l === null) {
      if (u.nullable)
        return "null";
      c.message("Null value not allowed");
    } else if (u.type === "boolean") {
      if (l === !0)
        return "true";
      if (l === !1)
        return "false";
      c.message("Expected true or false. Received: " + i.smart(l));
    } else if (u.type === "integer" || u.type === "number") {
      if (typeof l == "number" && !isNaN(l))
        return String(l);
      const d = u.type === "integer" ? "an integer" : "a number";
      c.message("Expected " + d + ". Received: " + i.smart(l));
    } else {
      if (u.type === "string")
        return l;
      c.message("Unable to stringify value: " + i.smart(l));
    }
  }
  function s(a, u, c, l) {
    if (u.type === "array") {
      const d = l.map((p, h) => u.items ? s(a, u.items, c.at(h), p) : p);
      switch (u.collectionFormat) {
        case "csv":
          return d.join(",");
        case "pipes":
          return d.join("|");
        case "ssv":
          return d.join(" ");
        case "tsv":
          return d.join("	");
      }
    } else
      return n(a, u, c, l);
  }
  return om;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var um, k$;
function M$() {
  if (k$)
    return um;
  k$ = 1;
  const e = sr;
  return um = {
    init: function(t) {
    },
    prototype: {},
    validator: function() {
      return {
        type: "object",
        properties: {
          title: {
            required: !0,
            type: "string"
          },
          description: {
            type: "string"
          },
          termsOfService: {
            type: "string"
          },
          contact: e("Contact"),
          license: e("License"),
          version: {
            required: !0,
            type: "string"
          }
        }
      };
    }
  }, um;
}
var cm = { exports: {} };
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var N$;
function D$() {
  return N$ || (N$ = 1, function(e) {
    e.exports = {
      init: function(t) {
      },
      prototype: {},
      validator: function(t) {
        return {
          type: "object",
          properties: {
            name: {
              required: !0,
              type: "string"
            },
            url: {
              type: "string"
            }
          },
          errors: function(r) {
            e.exports, r.validator;
          }
        };
      }
    };
  }(cm)), cm.exports;
}
var lm = { exports: {} };
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var fm, L$;
function ws() {
  if (L$)
    return fm;
  L$ = 1;
  const { isPlainObject: e } = Qt;
  fm = n;
  const t = !0, r = !0, i = !0;
  function n(a, u = {}) {
    if (!(this instanceof n))
      return new n(a, u);
    if (typeof a == "object" && a instanceof n && (u = {
      populate: u.populate === void 0 ? a.populate : u.populate,
      serialize: u.serialize === void 0 ? a.serialize : u.serialize,
      validate: u.validate === void 0 ? a.validate : u.validate
    }, a = a.value), !u || typeof u != "object")
      throw Error("Invalid enforcer value configuration");
    const { populate: c, serialize: l, validate: d } = u;
    this.populate = c, this.serialize = l, this.validate = d, this.value = a;
  }
  n.prototype.attributes = function() {
    return {
      populate: this.populate === void 0 ? t : this.populate,
      serialize: this.serialize === void 0 ? r : this.serialize,
      validate: this.validate === void 0 ? i : this.validate,
      value: this.value
    };
  }, n.inherit = function(a, u) {
    return typeof a == "object" && a instanceof n ? (a.populate === void 0 && u.populate !== void 0 && (a.populate = u.populate), a.serialize === void 0 && u.serialize !== void 0 && (a.serialize = u.serialize), a.validate === void 0 && u.validate !== void 0 && (a.validate = u.validate), a) : new n(a, u);
  }, n.extract = s, n.getAttributes = function(a) {
    return typeof a == "object" && a instanceof n ? a.attributes() : {
      populate: t,
      serialize: r,
      validate: i,
      value: a
    };
  };
  function s(a) {
    if (Array.isArray(a))
      return a.map((u) => s(u));
    if (e(a)) {
      const u = {};
      return Object.keys(a).forEach((c) => {
        u[c] = s(a[c]);
      }), u;
    } else
      return typeof a == "object" && a instanceof n ? a.value : a;
  }
  return fm;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var q$;
function Cf() {
  return q$ || (q$ = 1, function(e) {
    const t = sr, r = qn, i = _s, n = Qt, s = ws(), a = ["body", "headers", "method", "path", "query"], u = /^\d+$/, c = /^\d+(?:\.\d+)?$/;
    e.exports = {
      init: function(y) {
        const { major: g, parent: _, plugins: m, root: w } = y;
        m.push(() => {
          this.parameters || (this.parameters = []), this.parametersMap = {}, _ && _.result && _.result.parameters && l(this.parametersMap, _.result.parameters), l(this.parametersMap, this.parameters), this.allParameters = [], Object.keys(this.parametersMap).forEach(($) => {
            const E = this.parametersMap[$];
            Object.keys(E).forEach((A) => {
              this.allParameters.push(E[A]);
            });
          }), g === 2 && !this.produces && w.result.produces && (this.produces = w.result.produces);
        });
      },
      prototype: {
        /**
         * The the possible response mime types for the response code and accepts string.
         * @param {string, number} code
         * @param {string} accepts The allowed media type string. Example: text/html, application/xhtml+xml, application/xml;q=0.9, text/*;q=0.8
         * @returns {EnforcerResult<string[]>}
         */
        getResponseContentTypeMatches: function(y, g) {
          const _ = new r("Unable to determine acceptable response content types"), m = this.responses[y] || this.responses.default;
          let w;
          return m ? this.produces ? (w = n.findMediaMatch(g, this.produces), w.length || (_.message("Operation does not produce acceptable type"), _.code = "NO_MATCH")) : m.content ? (w = n.findMediaMatch(g, Object.keys(m.content)), w.length || (_.message("Operation does not produce acceptable type"), _.code = "NO_MATCH")) : (_.message("Response mime types not defined"), _.code = "NO_TYPES_SPECIFIED") : (_.message("Invalid response code"), _.code = "NO_CODE"), new i(w, _);
        },
        /**
         * Take the input parameters and deserialize and validate them.
         * @param {object} request
         * @param {string|object} [request.body] The request body
         * @param {Object<string,string>} [request.headers={}] The request headers
         * @param {object} [request.path={}] The path and query string
         * @param {string} [request.query=''] The request query string.
         * @param {object} [options]
         * @param {boolean,string[]} [options.allowOtherQueryParameters=false] Allow query parameter data that is not specified in the OAS document
         * @param {boolean} [options.pathParametersProcessed=false] Set to true if the path parameters have already been parsed, deserialized, and validated
         */
        request: function(y, g) {
          if (g || (g = {}), g && typeof g != "object")
            throw Error("Invalid options. Expected an object. Received: " + g);
          if (g = Object.assign({}, g), g.hasOwnProperty("allowOtherQueryParameters") || (g.allowOtherQueryParameters = !1), g.allowOtherQueryParameters) {
            if (Array.isArray(g.allowOtherQueryParameters))
              g.allowOtherQueryParameters.length === 0 ? g.allowOtherQueryParameters = !1 : g.allowOtherQueryParameters.forEach((I) => {
                if (typeof I != "string")
                  throw Error("Invalid option allowOtherQueryParameters. The value must be a boolean or an array of strings.");
              });
            else if (typeof g.allowOtherQueryParameters != "boolean")
              throw Error("Invalid option allowOtherQueryParameters. The value must be a boolean or an array of strings.");
          }
          if (!y || typeof y != "object")
            throw Error("Invalid request. Expected a non-null object. Received: " + y);
          if (y = this.toRequestObject(y), y.hasOwnProperty("headers") || (y.headers = {}), y.hasOwnProperty("path") || (y.path = {}), y.hasOwnProperty("query") || (y.query = ""), !n.isObjectStringMap(y.headers))
            throw Error("Invalid request headers. Expected an object with string keys and string values");
          if (!g.pathParametersProcessed && !n.isObjectStringMap(y.path))
            throw Error("Invalid request path. Expected an object with string keys and string values");
          if (typeof y.query != "string")
            throw Error("Invalid request query. Expected a string");
          const _ = {
            header: n.lowerCaseObjectProperties(y.headers),
            path: y.path,
            query: n.parseQueryString(decodeURI(y.query))
          };
          y.body !== void 0 && (_.body = y.body);
          const m = _.header.cookie || "", w = y.query;
          _.cookie = m ? n.parseCookieString(m) : {}, delete _.header.cookie;
          const $ = r("Request has one or more errors");
          $.statusCode = 400;
          const E = this.parametersMap, A = {
            cookie: {},
            headers: {},
            path: y.path,
            query: {}
          };
          if (E.formData && (!y.body || typeof y.body != "object"))
            throw Error('Parameters in "formData" require that the provided body be a non-null object');
          if (g.pathParametersProcessed) {
            const I = [];
            if (Object.keys(y.path).forEach((D) => {
              E.path.hasOwnProperty(D) || I.push(D);
            }), I.length) {
              const D = "Received unexpected parameter" + (I.length === 1 ? "" : "s") + ": " + I.join(", ");
              $.nest("In path parameters").message(D);
            }
          }
          const R = ["cookie", "header", "query"];
          if (g.pathParametersProcessed || R.push("path"), E.formData && R.push("formData"), R.forEach((I) => {
            const D = I === "formData", J = D ? $.nest("In body") : $.nest("In " + I + " parameters"), ae = D ? "body" : I, ye = _[ae] || {}, xe = [], je = [], re = (() => {
              if (I === "cookie" || I === "header")
                return [];
              const fe = Object.keys(ye);
              if (I === "query") {
                const le = g.allowOtherQueryParameters;
                return Array.isArray(le) ? fe.filter(($e) => !le.includes($e)) : le ? [] : fe;
              }
              return fe;
            })();
            if (E[I]) {
              const fe = {};
              Object.keys(E[I]).forEach((le) => {
                const $e = E[I][le], Ae = $e.schema && $e.schema.type;
                if (ye.hasOwnProperty(le)) {
                  n.arrayRemoveItem(re, le);
                  const _e = I === "query" ? $e.parse(w, ye) : I === "cookie" ? $e.parse(m, ye) : $e.parse(ye[le]);
                  p(J.at(le), $e.schema, _e, "", (ie) => fe[le] = ie);
                } else if ($e.in === "query" && $e.style === "form" && $e.explode && Ae === "object") {
                  const _e = $e.parse(w, ye);
                  if (_e.error) {
                    const ie = new r("In " + I + ' parameter "' + le + '"');
                    ie.message(_e.error), je.push(ie);
                  } else
                    p(J.at(le), $e.schema, _e, "", (ie) => {
                      Object.keys(ie).forEach((K) => n.arrayRemoveItem(re, K)), fe[le] = ie;
                    });
                } else if ($e.in === "query" && $e.style === "deepObject" && Ae === "object") {
                  const _e = $e.parse(w, ye);
                  if (_e.error) {
                    const ie = new r("In " + I + ' parameter "' + le + '"');
                    ie.push(_e.error), je.push(ie);
                  } else
                    p(J.at(le), $e.schema, _e, "", (ie) => {
                      Object.keys(ie).forEach((K) => n.arrayRemoveItem(re, le + "[" + K + "]")), fe[le] = ie;
                    });
                } else
                  $e.required && xe.push(le);
                !fe.hasOwnProperty(le) && $e.schema.hasOwnProperty("default") && (fe[le] = n.copy($e.schema.default));
              }), A[ae === "header" ? "headers" : ae] = s.extract(fe);
            }
            if (re.length) {
              const fe = "Received unexpected parameter" + (re.length === 1 ? "" : "s") + ": " + re.join(", ");
              if (je.length) {
                const le = J.nest(fe).nest("Possible causes");
                je.forEach(($e) => le.push($e));
              } else
                J.message(fe);
            }
            xe.length && J.message("Missing required parameter" + (xe.length > 1 ? "s" : "") + ": " + xe.join(", "));
          }), _.hasOwnProperty("body")) {
            let I = _.body;
            if (E.body) {
              const D = d(E);
              I = v(I, D.schema), p($.nest("In body"), D.schema, { value: I }, "write", (J) => {
                A.body = s.extract(J);
              });
            } else if (this.requestBody) {
              const { content: D, contentType: J, matches: ae } = h(this, _), ye = ae.length;
              if (ye) {
                const xe = new r("In body");
                let je = !1;
                for (let re = 0; re < ye; re++) {
                  const fe = ae[re], le = D[fe];
                  if (le.schema && (I = v(I, le.schema), p(xe.nest("For Content-Type " + fe), le.schema, { value: I }, "write", ($e) => {
                    A.body = s.extract($e), je = !0;
                  })), J === fe || je)
                    break;
                }
                je || $.push(xe);
              } else
                $.message("Content-Type not accepted"), $.statusCode = 415;
            } else
              E.formData || $.message("Body is not allowed");
          } else if (E.body && d(E).required)
            $.message("Missing required parameter: body");
          else if (this.requestBody && this.requestBody.required)
            $.message("Missing required request body");
          else {
            let I;
            if (E.body)
              I = d(E).schema;
            else if (this.requestBody) {
              const { content: D, matches: J } = h(this, _), ae = J.length;
              for (let ye = 0; ye < ae; ye++) {
                const xe = J[ye], je = D[xe].schema;
                if (je && je.hasOwnProperty("default")) {
                  I = je;
                  break;
                }
              }
            }
            I && I.hasOwnProperty("default") && (A.body = n.copy(I.default));
          }
          return new i(A, $);
        },
        response: function(y, g, _ = {}) {
          const m = new r("Response invalid"), w = new r("Response has one or more warnings"), $ = g !== void 0, E = (() => {
            const ae = String(y)[0];
            return this.responses[y] || this.responses[ae + "XX"] || this.responses.default;
          })(), A = { headers: {} }, R = this.enforcerData.major, I = this.enforcerData.options.exceptionSkipCodes, D = this.enforcerData.options.exceptionEscalateCodes;
          if (!n.isPlainObject(_) && n.isObject(_) && (_ = Object.create({}, _)), !n.isObject(_))
            throw Error("Invalid headers input parameter. Must be a plain object");
          if (_ = n.lowerCaseObjectProperties(_), E) {
            if ($) {
              if (R === 2) {
                const ae = E.schema;
                if (!ae)
                  A.body = g;
                else if (ae.type === "file")
                  A.schema = ae, A.body = g;
                else {
                  g = ae.formalize(g);
                  let ye = ae.validate(g, { readWriteMode: "read" });
                  ye || ([g, ye] = ae.serialize(g)), ye ? m.at("body").merge(ye) : (A.schema = ae, A.body = g);
                }
              } else if (R === 3) {
                const ae = E.content;
                if (!ae)
                  A.body = g;
                else {
                  const ye = Object.keys(ae);
                  let xe;
                  if (_.hasOwnProperty("content-type")) {
                    const re = _["content-type"].split(";")[0].trim();
                    ae.hasOwnProperty(re) ? xe = re : I.WOPE001 || (D.WOPE001 ? m : w).message("Content type specified is not defined as a possible mime-type: " + re + ". [WOPE001]");
                  } else
                    ye.length === 1 ? xe = ye[0] : m.message("Unable to determine content type to use. Please specify this value in the header object");
                  const je = xe && ae[xe] && ae[xe].schema;
                  if (je) {
                    g = je.formalize(g);
                    let re = je.validate(g, { readWriteMode: "read" });
                    re || ([g, re] = je.serialize(g)), re ? m.at("body").merge(re) : (A.schema = je, A.body = g);
                  } else
                    A.body = g;
                }
              }
            }
            const J = Object.keys(_);
            E.headers && Object.keys(E.headers).forEach((ae) => {
              const ye = ae.toLowerCase(), xe = E.headers[ae], je = xe.schema;
              let re;
              if (_.hasOwnProperty(ye) ? re = _[ye] : je.hasOwnProperty("default") && (re = n.copy(je.default)), re !== void 0) {
                n.arrayRemoveItem(J, ye), re = je.formalize(re);
                let fe = je.validate(re);
                fe || ([re, fe] = je.serialize(re)), fe || ([re, fe] = xe.stringify(re)), fe ? m.at("headers").at(ae).merge(fe) : A.headers[ae] = re;
              } else
                xe.required && m.at("headers").at(ae).message("Missing required header: " + ae);
            }), J.forEach((ae) => {
              typeof _[ae] != "string" && !I.WOPE002 && (D.WOPE002 ? m : w).at("headers").at(ae).message("Value has no schema and is not a string. [WOPE002]");
            });
          } else
            m.message("Invalid response code: " + y);
          return A.hasOwnProperty("body") && (A.body = s.extract(A.body)), A.headers && Object.keys(A.headers).forEach((J) => {
            A.headers[J] = s.extract(A.headers[J]);
          }), new i(A, m, w);
        },
        toRequestObject: function(y) {
          const g = {};
          return a.forEach((_) => {
            _ in y && (g[_] = y[_]);
          }), g;
        }
      },
      validator: function({ major: y, definition: g }) {
        return {
          type: "object",
          properties: {
            callbacks: {
              allowed: y === 3,
              type: "object",
              additionalProperties: t("Callback")
            },
            consumes: {
              allowed: y === 2,
              type: "array",
              items: {
                type: "string"
              }
            },
            deprecated: {
              type: "boolean",
              default: !1
            },
            description: {
              type: "string"
            },
            externalDocs: t("ExternalDocumentation"),
            operationId: {
              type: "string",
              errors: (_) => {
                const { exception: m, root: w, definition: $ } = _;
                w.__operationIdMap || (w.__operationIdMap = {}), w.__operationIdMap[$] ? m.message("The operationId must be unique") : w.__operationIdMap[$] = _;
              }
            },
            parameters: {
              type: "array",
              items: t("Parameter"),
              errors: e.exports.parametersValidation
            },
            produces: {
              allowed: y === 2,
              type: "array",
              items: {
                type: "string"
              }
            },
            requestBody: t("RequestBody", {
              // for easy unit testing default key to post if there is no parent key
              allowed: ({ options: _, parent: m }) => y === 3 && !!_.requestBodyAllowedMethods[m.key || "post"]
            }),
            responses: t("Responses", { required: !0 }),
            schemes: {
              allowed: y === 2,
              type: "array",
              items: {
                type: "string",
                enum: ["http", "https", "ws", "wss"]
              }
            },
            security: {
              type: "array",
              items: t("SecurityRequirement")
            },
            servers: {
              allowed: y === 3,
              type: "array",
              items: t("Server")
            },
            summary: {
              type: "string",
              errors: ({ definition: _, warn: m, options: w, parent: $ }) => {
                _.length >= 120 && !w.exceptionSkipCodes.WOPE003 && !n.schemaObjectHasSkipCode(g, "WOPE003") && (w.exceptionEscalateCodes.WOPE003 ? exception : m).message("Value should be less than 120 characters. [WOPE003]");
              }
            },
            tags: {
              type: "array",
              items: {
                type: "string"
              }
            }
          }
        };
      },
      parametersValidation: ({ exception: y, parent: g, root: _, definition: m }) => {
        const w = m.length, $ = [];
        let E = 0, A = !1, R = !1, I = !1;
        for (let D = 0; D < w; D++) {
          const J = m[D];
          J.in === "body" && (E++, A = !0), J.in === "formData" && (R = !0, J.type === "file" && (I = !0));
          for (let ae = 0; ae < w; ae++) {
            const ye = m[ae];
            if (J !== ye && J.name === ye.name && J.in === ye.in) {
              const xe = J.name + " in " + J.in;
              $.includes(xe) || $.push(xe);
            }
          }
        }
        if (E > 1 && y.message("Only one body parameter allowed"), A && R && y.message('Cannot have parameters in "body" and "formData" simultaneously'), $.length && y.message("Parameter name must be unique per location. Duplicates found: " + $.join(", ")), I) {
          const D = g.validator === e.exports.validator && g.definition.consumes || _.definition.consumes, J = Array.isArray(D) ? D.length : 0;
          let ae = !1;
          for (let ye = 0; ye < J; ye++) {
            const xe = D[ye];
            if (xe === "multipart/form-data" || xe === "application/x-www-form-urlencoded") {
              ae = !0;
              break;
            }
          }
          ae || y.message('Parameters of type "file" require the consumes property to be set to either "multipart/form-data" or "application/x-www-form-urlencoded"');
        }
      }
    };
    function l(y, g) {
      g && g.forEach((_) => {
        const m = _.in, w = m === "header" ? _.name.toLowerCase() : _.name;
        y.hasOwnProperty(m) || (y[m] = {}), y[m][w] = _;
      });
    }
    function d(y) {
      const g = Object.keys(y.body)[0];
      return y.body[g];
    }
    function p(y, g, _, m, w) {
      _.error || (_ = g.deserialize(_.value)), _.error || (_.error = g.validate(_.value, { readWriteMode: m })), _.error ? y && y.push(_.error) : w(_.value);
    }
    function h(y, g) {
      const _ = g.header.hasOwnProperty("content-type") ? g.header["content-type"].split(";")[0].trim() : "*/*", m = y.requestBody.content, w = Object.keys(m), $ = n.findMediaMatch(_, w);
      return {
        content: m,
        contentType: _,
        matches: $
      };
    }
    function v(y, g) {
      return typeof y == "string" && (g.type === "boolean" ? (y === "true" && (y = !0), (!y || y === "false") && (y = !1)) : g.type === "integer" ? u.test(y) && (y = parseInt(y)) : g.type === "number" && c.test(y) && (y = parseFloat(y))), y;
    }
  }(lm)), lm.exports;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var dm, F$;
function U$() {
  if (F$)
    return dm;
  F$ = 1;
  const e = pS(), t = sr, r = qn, i = _s, n = Qt, s = ws(), a = /^false/i, u = /^true$/i, c = /^\./;
  dm = {
    init: function(g) {
      const { context: _, definition: m, exception: w, major: $, warn: E, options: A } = g;
      if (m.in === "header" && m.name !== m.name.toLowerCase() && !A.exceptionSkipCodes.WPAR001 && !n.schemaObjectHasSkipCode(m, "WPAR001") && (A.exceptionEscalateCodes.WPAR001 ? w : E).message("Header names are case insensitive and their lower case equivalent will be used. [WPAR001]"), !this.hasOwnProperty("required") && this.in !== "path" && (this.required = !1), $ === 2 && m.in !== "body") {
        const R = e.extractSchemaDefinition({}, this);
        R.type === "file" && (R.type = "string");
        const [I, D, J] = new _.Schema(R);
        I && (this.schema = I), D && w.merge(D), J && E.merge(J);
      } else if ($ === 3 && m.content) {
        const R = Object.keys(m.content)[0];
        m.content[R].schema && (this.schema = m.content[R].schema);
      }
      $ === 3 && this.schema && n.validateExamples(this, w, E, A);
    },
    prototype: {
      /**
       * Parse input. Does not validate.
       * @param {string} value
       * @param {object} [query={}]
       * @returns {EnforcerResult}
       */
      parse: function(g, _) {
        const { major: m } = this.enforcerData, w = this.schema, $ = w && w.type, E = r("Unable to parse value");
        if ((this.in === "path" || this.in === "query") && (g = decodeURIComponent(g)), m === 2)
          if (this.collectionFormat === "multi") {
            _ || (_ = n.parseQueryString(g));
            const A = _[this.name];
            if (A) {
              const R = [];
              return A.forEach((I, D) => {
                !I && !this.allowEmptyValue ? E.at(D).message("Empty value not allowed") : this.items ? R.push(y(this, this.items, E.at(D), I)) : R.push(I);
              }), new i(R, E);
            } else
              return new i(null, E);
          } else if (_ && _.hasOwnProperty(this.name)) {
            const A = _[this.name];
            return A.length ? new i(y(this, this, E, A[A.length - 1]), E) : new i(y(this, this, E, void 0), E);
          } else
            return new i(y(this, this, E, g), E);
        else if (m === 3) {
          const A = this.explode, R = this.style;
          let I;
          if (_ || (this.in === "query" ? _ = n.parseQueryString(g) : this.in === "cookie" && (_ = n.parseCookieString(g))), R === "deepObject") {
            const D = RegExp("(?:^|&)" + this.name + "\\[([^\\]]+)\\](?:=([^&]*))?", "g"), J = {};
            let ae, ye = !1;
            for (; ae = D.exec(g); )
              ye = !0, J[ae[1]] = ae[2];
            ye && (I = J);
          } else if (R === "form") {
            if (A && $ === "object") {
              const D = p("&", "=", "&" + g);
              D && (I = {}, Object.keys(D).forEach((J) => {
                (w.additionalProperties || w.properties && w.properties.hasOwnProperty(J)) && (I[J] = D[J]);
              }));
            } else if (_.hasOwnProperty(this.name)) {
              const D = _[this.name];
              if ($ === "array")
                A ? I = D : D.length > 0 && (I = D[D.length - 1].split(","));
              else if ($ === "object") {
                const J = h(",", D[D.length - 1]);
                J && (I = J);
              } else
                D.length > 0 && (I = D[D.length - 1]);
            }
          } else if (R === "label")
            c.test(g) && ($ === "array" ? I = g.substr(1).split(A ? "." : ",") : $ === "object" ? I = A ? p(".", "=", g) : h(",", g.substr(1)) : I = g.substr(1));
          else if (R === "matrix") {
            const D = this.name, J = RegExp("^;" + D + "(?:=|$)");
            if ($ === "array")
              if (A) {
                const ae = l(";", "=", D, g.substr(1));
                ae && (I = ae);
              } else
                I = g.substr(D.length + 2).split(",");
            else if ($ === "object") {
              if (A || J.test(g)) {
                const ae = A ? p(";", "=", g) : h(",", g.substr(D.length + 2));
                ae && (I = ae);
              }
            } else
              J.test(g) && (I = g.substr(D.length + 2));
          } else if (R === "pipeDelimited") {
            const D = _[this.name];
            D.length > 0 && (I = A ? D : d($, "|", D[D.length - 1]));
          } else if (R === "simple")
            $ === "array" ? I = g.split(",") : $ === "object" ? I = A ? p(",", "=", "," + g) : h(",", g) : I = g;
          else if (R === "spaceDelimited") {
            const D = _[this.name];
            D.length > 0 && (I = A ? D : d($, " ", D[D.length - 1]));
          }
          return I !== void 0 ? $ === "array" ? I = I.map((D, J) => v(this, w.items, E.at(J), D)) : $ === "object" ? Object.keys(I).forEach((D) => {
            w.properties && w.properties[D] ? I[D] = v(this, w.properties[D], E.at(D), I[D]) : typeof w.additionalProperties == "object" && (I[D] = v(this, w.additionalProperties, E.at(D), I[D]));
          }) : I = v(this, w, E, I) : E.message("The value is not formatted properly"), new i(I, E);
        }
      }
    },
    validator: function(g) {
      const { major: _, options: m, definition: w } = g, $ = e.validator(g), E = m.exceptionSkipCodes, A = g.options.exceptionEscalateCodes;
      return {
        type: "object",
        properties: Object.assign({}, $.properties, {
          allowEmptyValue: {
            allowed: ({ parent: R }) => ["query", "formData"].includes(R.definition.in),
            type: "boolean",
            default: !1,
            errors: ({ exception: R, warn: I, major: D, usedDefault: J }) => {
              D === 3 && !J && !E.WPAR002 && !n.schemaObjectHasSkipCode(w, "WPAR002") && (A.WPAR002 ? R : I).message('Per OAS 3.0.2: "Use of this property is NOT RECOMMENDED, as it is likely to be removed in a later revision." [WPAR002]');
            }
          },
          allowReserved: {
            allowed: ({ parent: R }) => _ === 3 && R.definition.in === "query",
            type: "boolean",
            default: !1
          },
          collectionFormat: {
            allowed: ({ major: R, parent: I }) => R === 2 && I.definition.type === "array",
            enum: ({ parent: R }) => ["query", "formData"].includes(R.definition.in) ? ["csv", "ssv", "tsv", "pipes", "multi"] : ["csv", "ssv", "tsv", "pipes"],
            default: "csv"
          },
          explode: {
            type: "boolean",
            allowed: _ === 3,
            default: ({ parent: R }) => R.result.style === "form",
            errors: ({ exception: R, parent: I }) => {
              const D = I.definition.schema && I.definition.schema.type;
              I.definition.in === "cookie" && I.definition.explode && (D === "array" || D === "object") && R.message("Cookies do not support exploded values for non-primitive schemas");
            }
          },
          format: {
            weight: -9,
            allowed: ({ major: R, parent: I }) => R === 2 && ["file", "integer", "number", "string"].includes(I.definition.type),
            type: "string",
            errors: ({ exception: R, parent: I, warn: D }) => {
              const J = I.definition.format;
              if (J) {
                const ae = [];
                switch (I.definition.type) {
                  case "file":
                    ae.push("binary", "byte");
                    break;
                  case "integer":
                    ae.push("int32", "int64");
                    break;
                  case "number":
                    ae.push("float", "double");
                    break;
                  case "string":
                    ae.push("binary", "byte", "date", "date-time", "password");
                    break;
                }
                !ae.includes(J) && !E.WPAR003 && !n.schemaObjectHasSkipCode(w, "WPAR003") && (A.WPAR003 ? R : D).message("Non standard format used: " + J + ". [WPAR003]");
              }
            }
          },
          in: {
            weight: -20,
            required: !0,
            type: "string",
            enum: ({ major: R }) => R === 2 ? ["body", "formData", "header", "query", "path"] : ["cookie", "header", "path", "query"]
          },
          name: {
            required: !0,
            type: "string"
          },
          required: {
            required: ({ parent: R }) => R.definition.in === "path",
            type: "boolean",
            // default: ({parent}) => parent.definition.in === 'path',
            // default: false,
            enum: ({ parent: R }) => R.definition.in === "path" ? [!0] : [!0, !1]
          },
          schema: t("Schema", {
            allowed: ({ parent: R }) => _ === 3 || R.definition.in === "body"
          }),
          style: {
            weight: -19,
            allowed: _ === 3,
            type: "string",
            default: ({ parent: R }) => {
              switch (R.definition.in) {
                case "cookie":
                  return "form";
                case "header":
                  return "simple";
                case "path":
                  return "simple";
                case "query":
                  return "form";
              }
            },
            enum: ({ parent: R }) => {
              switch (R.definition.in) {
                case "cookie":
                  return ["form"];
                case "header":
                  return ["simple"];
                case "path":
                  return ["simple", "label", "matrix"];
                case "query":
                  return ["form", "spaceDelimited", "pipeDelimited", "deepObject"];
              }
            },
            errors: ({ exception: R, parent: I }) => {
              const D = I.definition.style, J = I.definition.schema && I.definition.schema.type;
              if (!J || !D)
                return !1;
              I.definition.in === "query" && D !== "form" && !(D === "spaceDelimited" && J === "array") && !(D === "pipeDelimited" && J === "array") && !(D === "deepObject" && J === "object") && R.message('Style "' + D + '" is incompatible with schema type: ' + J);
            }
          },
          type: {
            weight: -10,
            allowed: ({ major: R, parent: I }) => R === 2 && I.definition.in !== "body",
            required: !0,
            enum: ({ parent: R }) => R.definition.in === "formData" ? ["array", "boolean", "file", "integer", "number", "string"] : ["array", "boolean", "integer", "number", "string"]
          }
        }),
        errors: _ === 3 ? $.errors : (R) => {
          const { exception: I, definition: D } = R;
          D.hasOwnProperty("default") && D.required && I.message('Cannot have a "default" and set "required" to true'), $.errors(R);
        }
      };
    }
  };
  function l(g, _, m, w) {
    const $ = w.split(g), E = $.length, A = [];
    for (let R = 0; R < E; R++) {
      const I = $[R].split(_);
      if (I[0] === m)
        A.push(I[1]);
      else
        return !1;
    }
    return A;
  }
  function d(g, _, m) {
    if (g === "array")
      return m.split(_);
    if (g === "object")
      return h(_, m);
  }
  function p(g, _, m) {
    const $ = RegExp("s([^v]+)v([^s]+)?".replace(/v/g, _).replace(/s/g, g), "g"), E = {};
    let A, R = 0;
    for (; A = $.exec(m); )
      E[A[1]] = A[2] || "", R = A.index + A[0].length;
    if (R === m.length)
      return E;
  }
  function h(g, _) {
    const m = {}, w = _.split(g), $ = w.length;
    if ($ % 2 === 0) {
      for (let E = 1; E < $; E += 2)
        m[w[E - 1]] = w[E];
      return m;
    }
  }
  function v(g, _, m, w) {
    if (w) {
      if (_.type === "boolean") {
        if (u.test(w))
          return !0;
        if (a.test(w))
          return !1;
        m.message('Expected "true" or "false". Received: ' + w);
      } else if (_.type === "integer") {
        const $ = +w;
        if (!isNaN($))
          return $;
        m.message("Expected an integer. Received: " + w);
      } else if (_.type === "number") {
        const $ = +w;
        if (!isNaN($))
          return $;
        m.message("Expected a number. Received: " + w);
      } else if (_.type === "string")
        return w;
    } else {
      if (g.allowEmptyValue)
        return new s(w, { serialize: !1, validate: !1 });
      m.message("Empty value not allowed");
    }
    return w;
  }
  function y(g, _, m, w) {
    if (_.type === "array") {
      let $;
      switch (_.collectionFormat) {
        case "csv":
          $ = w.split(",");
          break;
        case "pipes":
          $ = w.split("|");
          break;
        case "ssv":
          $ = w.split(" ");
          break;
        case "tsv":
          $ = w.split("	");
          break;
      }
      return $.map((E, A) => _.items ? y(g, _.items, m.at(A), E) : E);
    } else
      return v(g, _, m, w);
  }
  return dm;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var pm, B$;
function V$() {
  if (B$)
    return pm;
  B$ = 1;
  const e = sr, t = Qt, r = t.methods();
  return pm = {
    init: function() {
      this.methods = r.filter((i) => !!this[i]);
    },
    prototype: {},
    validator: function({ major: i, options: n, definition: s }) {
      const a = Cf(), u = n.exceptionSkipCodes, c = n.exceptionEscalateCodes;
      return {
        type: "object",
        properties: {
          delete: e("Operation"),
          description: {
            type: "string"
          },
          get: e("Operation"),
          head: e("Operation"),
          options: e("Operation"),
          parameters: {
            weight: -1,
            type: "array",
            items: e("Parameter"),
            errors: a.parametersValidation
          },
          patch: e("Operation"),
          post: e("Operation"),
          put: e("Operation"),
          trace: e("Operation", { allowed: i === 3 }),
          servers: {
            allowed: i === 3,
            type: "array",
            items: e("Server")
          },
          summary: {
            type: "string"
          }
        },
        errors: ({ exception: l, definition: d, warn: p }) => {
          const h = r.length;
          let v = !1;
          for (let y = 0; y < h; y++)
            if (d.hasOwnProperty(r[y])) {
              v = !0;
              break;
            }
          !v && !u.WPAT001 && !t.schemaObjectHasSkipCode(s, "WPAT001") && (c.WPAT001 ? l : p).message("No methods defined. [WPAT001]");
        }
      };
    }
  }, pm;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var hm, Z$;
function z$() {
  if (Z$)
    return hm;
  Z$ = 1;
  const e = sr, t = Qt, r = /{([^}]+)}/, i = t.methods();
  hm = {
    init: function(s) {
      const { exception: a, result: u, plugins: c } = s, l = {};
      s.options.disablePathNormalization || Object.keys(u).forEach((p) => {
        const h = t.edgeSlashes(p, !0, !1);
        h !== p && (u[h] = u[p], delete u[p]);
      }), c.push(() => {
        const d = N0().config;
        Object.keys(u).forEach((_, m) => {
          const w = u[_], $ = _.split("/").length - 1, E = [], A = new RegExp(r, "g");
          let R;
          for (; R = A.exec(_); )
            E.push(R[1]);
          const I = a.at(_).nest("Path parameter definitions inconsistent");
          w.methods.forEach((fe) => {
            const le = I.at(fe), $e = Object.keys(w[fe].parametersMap.path || {}), Ae = $e.length, _e = [];
            for (let V = 0; V < Ae; V++) {
              const z = $e[V];
              E.includes(z) || _e.push(z);
            }
            _e.length && le.message("Path missing defined parameters: " + _e.join(", "));
            const ie = E.length, K = [];
            for (let V = 0; V < ie; V++) {
              const z = E[V];
              $e.includes(z) || K.push(z);
            }
            K.length && le.message("Definition missing path parameters: " + K.join(", "));
          });
          const D = /{([^}]+)}/g;
          let J, ae = "", ye = 0, xe = "";
          for (; R = D.exec(_); )
            J = _.substring(ye, R.index), xe += "0".repeat(J.split("/").length) + "1", ae += n(J) + "([\\s\\S]+?)", ye = R.index + R[0].length;
          J = _.substr(ye), J && (xe += "0".repeat(J.split("/").length) + "0", ae += n(J));
          const je = d.useCaseSensitivePaths ? new RegExp("^" + ae + "$") : new RegExp("^" + ae + "$", "i"), re = (fe) => {
            const le = je.exec(fe);
            if (!le)
              return;
            const $e = {};
            return E.forEach((Ae, _e) => $e[Ae] = le[_e + 1]), {
              params: $e,
              path: w,
              pathKey: _
            };
          };
          re.weight = xe + m, l[$] || (l[$] = []), l[$].push(re);
        });
        const p = Symbol("path parameter"), h = [];
        Object.keys(u).forEach((_, m) => {
          const w = /{([^}]+)}/g, $ = [];
          let E, A = 0;
          for (; E = w.exec(_); ) {
            const I = _.substring(A, E.index);
            $.push(I), $.push(p), A = E.index + E[0].length;
          }
          const R = _.substring(A);
          $.push(R), i.filter((I) => u[_].hasOwnProperty(I)).forEach((I) => {
            h.push({
              key: _,
              method: I,
              signature: d.useCaseSensitivePaths ? [I].concat($) : [I].concat($.map((D) => typeof D == "string" ? D.toLowerCase() : D))
            });
          });
        });
        const v = [], y = [];
        h.forEach((_) => {
          const m = h.filter((w) => {
            const $ = w.signature.length;
            if (_ === w || _.signature.length !== $ || y.includes(w.key))
              return !1;
            for (let E = 0; E < $; E++)
              if (w.signature[E] !== _.signature[E])
                return !1;
            return !0;
          });
          m.length > 0 && (m.unshift(_), m.forEach((w) => y.push(w.key)), v.push(m));
        });
        const g = a.nest("Equivalent paths are not allowed");
        v.forEach((_) => {
          const m = g.nest("Equivalent paths:");
          _.forEach((w) => m.push(w.method.toUpperCase() + " " + w.key));
        }), Object.keys(l).forEach((_) => {
          l[_].sort((m, w) => m.weight < w.weight ? -1 : 1);
        }), this.enforcerData.pathParsers = l;
      });
    },
    prototype: {
      /**
       * Find the Path object for the provided path.
       * @param {string} pathString
       * @returns {{ params: object, path: Path }|undefined}
       */
      findMatch: function(s) {
        return this.findMatches(s)[0];
      },
      findMatches: function(s) {
        const { pathParsers: a } = this.enforcerData, u = [];
        s = s.split("?")[0];
        const c = s.split("/").length - 1, l = a[c];
        if (!l)
          return u;
        const d = l.length;
        for (let p = 0; p < d; p++) {
          const h = l[p], v = h(s);
          v && u.push(v);
        }
        return u;
      }
    },
    validator: function(s) {
      const a = s.options.disablePathNormalization, u = s.options.exceptionSkipCodes, c = s.options.exceptionEscalateCodes, l = s.definition;
      return {
        required: !0,
        type: "object",
        additionalProperties: e("PathItem"),
        errors: ({ exception: d, definition: p, warn: h }) => {
          const v = d.nest("These paths are defined more than once exist due to path normalization:"), y = Object.keys(p), g = {}, _ = [], m = [];
          if (y.forEach((w) => {
            if ((w[0] !== "/" || w[1] === "/") && d.at(w).message("Path must begin with a single forward slash"), !a) {
              const $ = t.edgeSlashes(w, !0, !1);
              g[$] && v.message(w + " --> " + $), $ !== w && !u.WPAS001 && !t.schemaObjectHasSkipCode(l, "WPAS001") && (c.WPAS001 ? d : h).at(w).message("Path normalized from " + w + " to " + $ + ". [WPAS001]"), g[w] = $;
            }
            w !== "/" && (w[w.length - 1] === "/" ? _.push(w) : m.push(w));
          }), !y.length && !u.WPAS002 && !t.schemaObjectHasSkipCode(l, "WPAS002") && (c.WPAS002 ? d : h).message("No paths defined. [WPAS002]"), _.length > 0 && m.length > 0) {
            const w = (c.WPAS003 ? d : h).nest("Some defined paths end with slashes while some do not. This inconsistency may confuse users of your API."), $ = w.nest("Paths without trailing slashes:"), E = w.nest("Paths with trailing slashes:");
            m.forEach((A) => {
              !u.WPAS003 && !t.schemaObjectHasSkipCode(l, "WPAS003") && $.message(A + " [WPAS003]");
            }), _.forEach((A) => {
              !u.WPAS003 && !t.schemaObjectHasSkipCode(l, "WPAS003") && E.message(A + " [WPAS003]");
            });
          }
        }
      };
    }
  };
  function n(s) {
    return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  }
  return hm;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var mm, W$;
function H$() {
  return W$ || (W$ = 1, mm = {
    init: function(e) {
    },
    prototype: {},
    validator: function(e) {
      return {
        type: "object",
        properties: {
          $ref: {
            type: "string"
          }
        }
      };
    }
  }), mm;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var ym, G$;
function K$() {
  if (G$)
    return ym;
  G$ = 1;
  const e = sr, t = Qt, r = /^content-type$/i, i = /^[a-zA-Z0-9.\-_]+$/;
  return ym = {
    init: function(n) {
      const { exception: s, warn: a, options: u } = n;
      t.validateExamples(this, s, a, u);
    },
    prototype: {},
    validator: function({ major: n }) {
      return {
        type: "object",
        properties: {
          description: {
            type: "string",
            required: !0
          },
          content: {
            allowed: n === 3,
            type: "object",
            additionalProperties: e("MediaType")
          },
          examples: {
            allowed: n === 2,
            type: "object",
            additionalProperties: {
              freeForm: !0
            }
          },
          headers: {
            type: "object",
            additionalProperties: e("Header", {
              ignored: ({ key: s }) => r.test(s)
            })
          },
          links: {
            allowed: n === 3,
            type: "object",
            additionalProperties: e("Link", {
              errors: ({ exception: s, key: a }) => {
                i.test(a) || s.message("Invalid key used for link value");
              }
            })
          },
          schema: n === 2 ? e("Schema") : { allowed: !1 }
        }
      };
    }
  }, ym;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var gm, Y$;
function J$() {
  if (Y$)
    return gm;
  Y$ = 1;
  const e = sr, t = Qt, r = /^[1-5]\d{2}$/, i = /^location$/i, n = /^[1-5]X{2}$/;
  return gm = {
    init: function(s) {
    },
    prototype: {},
    validator: function(s) {
      const { major: a, options: u, definition: c } = s, l = u.exceptionSkipCodes, d = u.exceptionEscalateCodes;
      return {
        type: "object",
        additionalProperties: e("Response", {
          allowed: ({ key: p }) => p === "default" || r.test(p) || a === 3 && n.test(p),
          errors: ({ exception: p, key: h, parent: v, warn: y, definition: g, major: _, options: m }) => {
            if (m.apiSuggestions && r.test(h) && v && v.parent && v.parent.key)
              if (v.parent.key.toLowerCase() === "post" && h === "201") {
                const $ = g.headers ? Object.keys(g.headers).filter((E) => i.test(E))[0] : null;
                (!$ || !g.headers[$]) && !l.WRES001 && !t.schemaObjectHasSkipCode(c, "WRES001") && (d.WRES001 ? p : y).message("A 201 response for a POST request should return a location header (https://tools.ietf.org/html/rfc7231#section-4.3.3) and this is not documented in your OpenAPI document. [WRES001]");
              } else
                h === "204" && (_ === 2 && g.schema && !l.WRES002 && !t.schemaObjectHasSkipCode(c, "WRES002") ? (d.WRES002 ? p : y).message("A 204 response must not contain a body (https://tools.ietf.org/html/rfc7231#section-6.3.5) but this response has a defined schema. [WRES002]") : _ === 3 && g.content && !l.WRES003 && !t.schemaObjectHasSkipCode(c, "WRES003") && (d.WRES003 ? p : y).message("A 204 response must not contain a body (https://tools.ietf.org/html/rfc7231#section-6.3.5) but this response has a defined content. [WRES003]"));
          }
        }),
        errors: ({ exception: p, definition: h }) => {
          Object.keys(h).length === 0 && !p.hasException && p.message("Response object cannot be empty");
        }
      };
    }
  }, gm;
}
var vm = { exports: {} }, bm = {}, X$;
function M0() {
  return X$ || (X$ = 1, function(e) {
    e.after = function(t, r, i, n) {
      return e.runHooks(t, r, i, n).value;
    }, e.runHooks = function(t, r, i, n, s = !1) {
      if (t.enforcerData && t.enforcerData.staticData && t.enforcerData.staticData.hooks) {
        const a = t.enforcerData.staticData.hooks[r], u = a !== void 0 ? a.length : 0;
        let c = i, l = !1;
        if (s && u > 0 && (l = n.hasException), !l)
          for (let d = 0; d < u; d++) {
            const p = a[d](i, t, n);
            if (p && typeof p == "object") {
              if (p.done === !0)
                return p;
              if ("value" in p && (c = p.value), p.hasException || n.hasException) {
                l = !0;
                break;
              }
            }
          }
        return {
          done: l === !0,
          // if it has an exception then it is also done
          hasException: l,
          value: c
        };
      } else
        return {
          done: !1,
          hasException: !1,
          value: i
        };
    };
  }(bm)), bm;
}
var _m = {}, Q$;
function hS() {
  if (Q$)
    return _m;
  Q$ = 1;
  const e = qn, t = Qt, r = ws();
  return _m.anyOneOf = function(i, n, s, a, u, c, l) {
    n instanceof r && (n = n.value);
    const d = i.anyOf ? "anyOf" : "oneOf", p = [], h = [];
    if (i[d].forEach((v) => {
      const y = new e(""), g = new Map(a);
      if (c) {
        const m = v.validate(n);
        if (m) {
          p.push(m);
          return;
        }
      }
      const _ = u(y, g, v, t.copy(n), l);
      if (y.hasException)
        p.push(y);
      else {
        let m = 1;
        if (v.type === "object") {
          const w = v.properties || {}, $ = Object.keys(_), E = $.length;
          for (let A = 0; A < E; A++) {
            const R = $[A];
            if (w.hasOwnProperty(R))
              m++;
            else if (v.additionalProperties === !1) {
              m = 0;
              break;
            }
          }
        }
        m > 0 && !c && v.validate(_) && (m = 0), m > 0 && h.push({ score: m, result: t.copy(_) });
      }
    }), h.length > 1) {
      h.sort((g, _) => g.score > _.score ? -1 : 1);
      const v = h[0].score, y = h.filter((g) => g.score === v);
      if (y.length > 1) {
        const g = c ? "Unable to determine serialization schema because too many schemas match. Use of a discriminator or making your schemas more specific would help this problem." : "Unable to determine deserialization schema because too many schemas match. Use of a discriminator or making your schemas more specific would help this problem.";
        s.message(g);
      } else
        return t.merge(n, y[0].result);
    } else if (h.length === 0)
      if (p.length > 0) {
        const v = s.nest("No matching schemas");
        p.forEach((y) => v.push(y));
      } else
        s.message("No matching schemas");
    else
      return t.merge(n, h[0].result);
  }, _m;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var wm, e2;
function HW() {
  if (e2)
    return wm;
  e2 = 1;
  const e = M0(), t = hS(), r = Qt, i = ws(), n = /^\s*true\s*$/i, s = /^\s*false\s*$/i, a = /^\s*\d+\s*$/, u = /^\s*(?:\d+(?:\.\d+)?)|(?:\.\d+)\s*$/;
  wm = c;
  function c(l, d, p, h, v) {
    let { serialize: y, value: g } = i.getAttributes(h);
    if (!y)
      return h;
    const _ = p.type, m = typeof g;
    if (g && m === "object") {
      let $ = d.get(p);
      if ($ && $.includes(g))
        return g;
      d.set(p, [g]);
    }
    const w = e.runHooks(p, "beforeDeserialize", g, l);
    if (g = w.value, w.done)
      return g;
    if (g === null && (p.nullable || p["x-nullable"]))
      return e.after(p, "afterDeserialize", g, l);
    if (p.allOf) {
      const $ = l.at("allOf");
      if (p.allOf[0].type === "object") {
        const E = {};
        return p.allOf.forEach((A, R) => {
          const I = c($.at(R), d, A, h, v);
          Object.assign(E, I);
        }), e.after(p, "afterDeserialize", Object.assign(g, E), l);
      } else
        return c($.at("0"), d, p.allOf[0], h, v);
    } else if (p.anyOf || p.oneOf) {
      let $;
      if (p.discriminator) {
        const { name: E, key: A, schema: R } = p.discriminate(g, !0);
        R ? $ = Object.assign(g, c(l, d, R, h, v)) : l.message('Discriminator property "' + A + '" as "' + E + '" did not map to a schema');
      } else
        $ = t.anyOneOf(
          p,
          h,
          l,
          d,
          c,
          !1,
          v
        );
      return e.after(p, "afterDeserialize", $, l);
    } else if (_ === "array") {
      if (Array.isArray(g))
        return p.items && g.forEach(($, E) => {
          g[E] = c(l.at(E), d, p.items, i.inherit($, { serialize: y }), v);
        }), e.after(p, "afterDeserialize", g, l);
      l.message("Expected an array. Received: " + r.smart(g));
    } else if (_ === "object")
      if (r.isObject(g)) {
        const $ = p.additionalProperties, E = p.properties || {};
        if (Object.keys(g).forEach((A) => {
          E.hasOwnProperty(A) ? g[A] = c(l.at(A), d, E[A], i.inherit(g[A], { serialize: y }), v) : $ && (g[A] = c(l.at(A), d, $, i.inherit(g[A], { serialize: y }), v));
        }), p.discriminator) {
          const { name: A, key: R, schema: I } = p.discriminate(g, !0);
          I ? Object.assign(g, c(l, d, I, h, v)) : l.message('Discriminator property "' + R + '" as "' + A + '" did not map to a schema');
        }
        return e.after(p, "afterDeserialize", g, l);
      } else
        l.message("Expected an object. Received: " + r.smart(g));
    else if (p !== !0) {
      const $ = p.enforcerData.staticData.dataTypes, E = $[p.type] && $[p.type][p.format] || null;
      if (_ === "boolean")
        if (E && E.deserialize) {
          const A = E.deserialize({
            exception: l,
            schema: p,
            value: g
          });
          return e.after(p, "afterDeserialize", A, l);
        } else if (m !== "boolean") {
          if (!v.strict) {
            if (m === "string") {
              if (n.test(g))
                return !0;
              if (s.test(g))
                return !1;
            } else if (m === "number")
              return e.after(p, "afterDeserialize", !!g, l);
          }
          l.message("Expected a boolean. Received: " + r.smart(g));
        } else
          return e.after(p, "afterDeserialize", g, l);
      else if (_ === "integer")
        if (E && E.deserialize) {
          const A = E.deserialize({
            exception: l,
            schema: p,
            value: g
          });
          return e.after(p, "afterDeserialize", A, l);
        } else if (m !== "number" || !r.isInteger(g)) {
          if (!v.strict && m === "string" && a.test(g))
            return e.after(p, "afterDeserialize", +g, l);
          l.message("Expected an integer. Received: " + r.smart(g));
        } else
          return e.after(p, "afterDeserialize", g, l);
      else if (_ === "number")
        if (E && E.deserialize) {
          const A = E.deserialize({
            exception: l,
            schema: p,
            value: g
          });
          return e.after(p, "afterDeserialize", A, l);
        } else if (m !== "number") {
          if (!v.strict && m === "string" && u.test(g))
            return e.after(p, "afterDeserialize", +g, l);
          l.message("Expected a number. Received: " + r.smart(g));
        } else
          return e.after(p, "afterDeserialize", g, l);
      else if (_ === "string") {
        if (E && E.deserialize) {
          const A = E.deserialize({
            exception: l,
            schema: p,
            value: g
          });
          return e.after(p, "afterDeserialize", A, l);
        }
        if (m !== "string")
          l.message("Expected a string. Received: " + r.smart(g));
        else
          return e.after(p, "afterDeserialize", g, l);
      }
    } else
      return e.after(p, "afterDeserialize", g, l);
  }
  return wm;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var $m, t2;
function GW() {
  if (t2)
    return $m;
  t2 = 1;
  const e = Qt, t = ws();
  $m = r;
  function r(n, s, a, u, c, l, d, p) {
    const { populate: h, value: v } = t.getAttributes(l[d]), y = u.type;
    if (!h) {
      l[d] = v;
      return;
    }
    if (!(u.hasOwnProperty("x-condition") && !c[u["x-condition"]]))
      if (u.allOf)
        u.allOf.forEach((g) => {
          r(n, s, a, g, c, l, d, p);
        });
      else if (u.anyOf || u.oneOf) {
        const g = u.anyOf ? "anyOf" : "oneOf";
        if (!u.discriminator)
          n.message("Unable to populate " + g + " without a discriminator");
        else {
          const { name: _, key: m, schema: w } = u.discriminate(v, !0);
          w ? r(n, s, a, w, c, l, d, p) : n.message('Discriminator property "' + m + '" as "' + _ + '" did not map to a schema');
        }
      } else if (u.not)
        n.message('Cannot populate "not" schemas');
      else if (y === "array")
        if (v !== void 0 && !Array.isArray(v))
          n.message("Provided value must be an array. Received: " + e.smart(v));
        else {
          const g = i(n, u, c, l, d, p);
          u.items && Array.isArray(g) && (a < 0 ? s.message("Reached maximum depth") : g.forEach((_, m) => {
            r(n.at(m), s.at(m), a - 1, u.items, c, g, m, p);
          }));
        }
      else if (y === "object")
        if (v !== void 0 && (!v || typeof v != "object"))
          n.message("Provided value must be an object. Received: " + e.smart(v));
        else if (a < 0)
          s.message("Reached maximum depth");
        else {
          const g = i(n, u, c, l, d, p), _ = g || {}, m = u.additionalProperties;
          if (m) {
            const $ = u.properties || {};
            Object.keys(_).forEach((E) => {
              $.hasOwnProperty(E) || r(n.at(E), s.at(E), a - 1, m, c, _, E, p);
            });
          }
          const w = u.properties;
          w && Object.keys(w).forEach(($) => {
            r(n.at($), s.at($), a - 1, w[$], c, _, $, p);
          }), (g || Object.keys(_).length) && (l[d] = _);
        }
      else
        i(n, u, c, l, d, p);
  }
  function i(n, s, a, u, c, l) {
    if (!(s.hasOwnProperty("x-condition") && !a[s["x-condition"]])) {
      if (u[c] === void 0) {
        const d = s.type;
        if (l.variables && s.hasOwnProperty("x-variable") && a.hasOwnProperty(s["x-variable"])) {
          const p = a[s["x-variable"]];
          p !== void 0 && (u[c] = p);
        } else if (l.templates && d === "string" && s.hasOwnProperty("x-template"))
          u[c] = l.injector(s["x-template"], a);
        else if (l.defaults && s.hasOwnProperty("x-default")) {
          const p = s["x-default"];
          p !== void 0 && (u[c] = l.templateDefaults && typeof p == "string" ? l.injector(p, a) : p);
        } else if (l.defaults && s.hasOwnProperty("default")) {
          const p = s.default;
          p !== void 0 && (u[c] = l.templateDefaults && typeof p == "string" ? l.injector(p, a) : p);
        }
      }
      return u[c];
    }
  }
  return $m;
}
var wl = { exports: {} }, Em = {}, xm, r2;
function vd() {
  return r2 || (r2 = 1, xm = {
    ROOT: 0,
    GROUP: 1,
    POSITION: 2,
    SET: 3,
    RANGE: 4,
    REPETITION: 5,
    REFERENCE: 6,
    CHAR: 7
  }), xm;
}
var bi = {}, n2;
function mS() {
  if (n2)
    return bi;
  n2 = 1;
  const e = vd(), t = () => [{ type: e.RANGE, from: 48, to: 57 }], r = () => [
    { type: e.CHAR, value: 95 },
    { type: e.RANGE, from: 97, to: 122 },
    { type: e.RANGE, from: 65, to: 90 }
  ].concat(t()), i = () => [
    { type: e.CHAR, value: 9 },
    { type: e.CHAR, value: 10 },
    { type: e.CHAR, value: 11 },
    { type: e.CHAR, value: 12 },
    { type: e.CHAR, value: 13 },
    { type: e.CHAR, value: 32 },
    { type: e.CHAR, value: 160 },
    { type: e.CHAR, value: 5760 },
    { type: e.RANGE, from: 8192, to: 8202 },
    { type: e.CHAR, value: 8232 },
    { type: e.CHAR, value: 8233 },
    { type: e.CHAR, value: 8239 },
    { type: e.CHAR, value: 8287 },
    { type: e.CHAR, value: 12288 },
    { type: e.CHAR, value: 65279 }
  ], n = () => [
    { type: e.CHAR, value: 10 },
    { type: e.CHAR, value: 13 },
    { type: e.CHAR, value: 8232 },
    { type: e.CHAR, value: 8233 }
  ];
  return bi.words = () => ({ type: e.SET, set: r(), not: !1 }), bi.notWords = () => ({ type: e.SET, set: r(), not: !0 }), bi.ints = () => ({ type: e.SET, set: t(), not: !1 }), bi.notInts = () => ({ type: e.SET, set: t(), not: !0 }), bi.whitespace = () => ({ type: e.SET, set: i(), not: !1 }), bi.notWhitespace = () => ({ type: e.SET, set: i(), not: !0 }), bi.anyChar = () => ({ type: e.SET, set: n(), not: !0 }), bi;
}
var i2;
function KW() {
  return i2 || (i2 = 1, function(e) {
    const t = vd(), r = mS(), i = "@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^ ?", n = { 0: 0, t: 9, n: 10, v: 11, f: 12, r: 13 };
    e.strToChars = function(s) {
      var a = /(\[\\b\])|(\\)?\\(?:u([A-F0-9]{4})|x([A-F0-9]{2})|(0?[0-7]{2})|c([@A-Z[\\\]^?])|([0tnvfr]))/g;
      return s = s.replace(a, function(u, c, l, d, p, h, v, y) {
        if (l)
          return u;
        var g = c ? 8 : d ? parseInt(d, 16) : p ? parseInt(p, 16) : h ? parseInt(h, 8) : v ? i.indexOf(v) : n[y], _ = String.fromCharCode(g);
        return /[[\]{}^$.|?*+()]/.test(_) && (_ = "\\" + _), _;
      }), s;
    }, e.tokenizeClass = (s, a) => {
      for (var u = [], c = /\\(?:(w)|(d)|(s)|(W)|(D)|(S))|((?:(?:\\)(.)|([^\]\\]))-(?:\\)?([^\]]))|(\])|(?:\\)?([^])/g, l, d; (l = c.exec(s)) != null; )
        if (l[1])
          u.push(r.words());
        else if (l[2])
          u.push(r.ints());
        else if (l[3])
          u.push(r.whitespace());
        else if (l[4])
          u.push(r.notWords());
        else if (l[5])
          u.push(r.notInts());
        else if (l[6])
          u.push(r.notWhitespace());
        else if (l[7])
          u.push({
            type: t.RANGE,
            from: (l[8] || l[9]).charCodeAt(0),
            to: l[10].charCodeAt(0)
          });
        else if (d = l[12])
          u.push({
            type: t.CHAR,
            value: d.charCodeAt(0)
          });
        else
          return [u, c.lastIndex];
      e.error(a, "Unterminated character class");
    }, e.error = (s, a) => {
      throw new SyntaxError("Invalid regular expression: /" + s + "/: " + a);
    };
  }(Em)), Em;
}
var Ma = {}, s2;
function YW() {
  if (s2)
    return Ma;
  s2 = 1;
  const e = vd();
  return Ma.wordBoundary = () => ({ type: e.POSITION, value: "b" }), Ma.nonWordBoundary = () => ({ type: e.POSITION, value: "B" }), Ma.begin = () => ({ type: e.POSITION, value: "^" }), Ma.end = () => ({ type: e.POSITION, value: "$" }), Ma;
}
var a2;
function JW() {
  if (a2)
    return wl.exports;
  a2 = 1;
  const e = KW(), t = vd(), r = mS(), i = YW();
  return wl.exports = (n) => {
    var s = 0, a, u, c = { type: t.ROOT, stack: [] }, l = c, d = c.stack, p = [], h = (A) => {
      e.error(n, `Nothing to repeat at column ${A - 1}`);
    }, v = e.strToChars(n);
    for (a = v.length; s < a; )
      switch (u = v[s++], u) {
        case "\\":
          switch (u = v[s++], u) {
            case "b":
              d.push(i.wordBoundary());
              break;
            case "B":
              d.push(i.nonWordBoundary());
              break;
            case "w":
              d.push(r.words());
              break;
            case "W":
              d.push(r.notWords());
              break;
            case "d":
              d.push(r.ints());
              break;
            case "D":
              d.push(r.notInts());
              break;
            case "s":
              d.push(r.whitespace());
              break;
            case "S":
              d.push(r.notWhitespace());
              break;
            default:
              /\d/.test(u) ? d.push({ type: t.REFERENCE, value: parseInt(u, 10) }) : d.push({ type: t.CHAR, value: u.charCodeAt(0) });
          }
          break;
        case "^":
          d.push(i.begin());
          break;
        case "$":
          d.push(i.end());
          break;
        case "[":
          var y;
          v[s] === "^" ? (y = !0, s++) : y = !1;
          var g = e.tokenizeClass(v.slice(s), n);
          s += g[1], d.push({
            type: t.SET,
            set: g[0],
            not: y
          });
          break;
        case ".":
          d.push(r.anyChar());
          break;
        case "(":
          var _ = {
            type: t.GROUP,
            stack: [],
            remember: !0
          };
          u = v[s], u === "?" && (u = v[s + 1], s += 2, u === "=" ? _.followedBy = !0 : u === "!" ? _.notFollowedBy = !0 : u !== ":" && e.error(
            n,
            `Invalid group, character '${u}' after '?' at column ${s - 1}`
          ), _.remember = !1), d.push(_), p.push(l), l = _, d = _.stack;
          break;
        case ")":
          p.length === 0 && e.error(n, `Unmatched ) at column ${s - 1}`), l = p.pop(), d = l.options ? l.options[l.options.length - 1] : l.stack;
          break;
        case "|":
          l.options || (l.options = [l.stack], delete l.stack);
          var m = [];
          l.options.push(m), d = m;
          break;
        case "{":
          var w = /^(\d+)(,(\d+)?)?\}/.exec(v.slice(s)), $, E;
          w !== null ? (d.length === 0 && h(s), $ = parseInt(w[1], 10), E = w[2] ? w[3] ? parseInt(w[3], 10) : 1 / 0 : $, s += w[0].length, d.push({
            type: t.REPETITION,
            min: $,
            max: E,
            value: d.pop()
          })) : d.push({
            type: t.CHAR,
            value: 123
          });
          break;
        case "?":
          d.length === 0 && h(s), d.push({
            type: t.REPETITION,
            min: 0,
            max: 1,
            value: d.pop()
          });
          break;
        case "+":
          d.length === 0 && h(s), d.push({
            type: t.REPETITION,
            min: 1,
            max: 1 / 0,
            value: d.pop()
          });
          break;
        case "*":
          d.length === 0 && h(s), d.push({
            type: t.REPETITION,
            min: 0,
            max: 1 / 0,
            value: d.pop()
          });
          break;
        default:
          d.push({
            type: t.CHAR,
            value: u.charCodeAt(0)
          });
      }
    return p.length !== 0 && e.error(n, "Unterminated group"), c;
  }, wl.exports.types = t, wl.exports;
}
var Om, o2;
function XW() {
  if (o2)
    return Om;
  o2 = 1;
  class e {
    constructor(i, n) {
      this.low = i, this.high = n, this.length = 1 + n - i;
    }
    overlaps(i) {
      return !(this.high < i.low || this.low > i.high);
    }
    touches(i) {
      return !(this.high + 1 < i.low || this.low - 1 > i.high);
    }
    // Returns inclusive combination of SubRanges as a SubRange.
    add(i) {
      return new e(
        Math.min(this.low, i.low),
        Math.max(this.high, i.high)
      );
    }
    // Returns subtraction of SubRanges as an array of SubRanges.
    // (There's a case where subtraction divides it in 2)
    subtract(i) {
      return i.low <= this.low && i.high >= this.high ? [] : i.low > this.low && i.high < this.high ? [
        new e(this.low, i.low - 1),
        new e(i.high + 1, this.high)
      ] : i.low <= this.low ? [new e(i.high + 1, this.high)] : [new e(this.low, i.low - 1)];
    }
    toString() {
      return this.low == this.high ? this.low.toString() : this.low + "-" + this.high;
    }
  }
  class t {
    constructor(i, n) {
      this.ranges = [], this.length = 0, i != null && this.add(i, n);
    }
    _update_length() {
      this.length = this.ranges.reduce((i, n) => i + n.length, 0);
    }
    add(i, n) {
      var s = (a) => {
        for (var u = 0; u < this.ranges.length && !a.touches(this.ranges[u]); )
          u++;
        for (var c = this.ranges.slice(0, u); u < this.ranges.length && a.touches(this.ranges[u]); )
          a = a.add(this.ranges[u]), u++;
        c.push(a), this.ranges = c.concat(this.ranges.slice(u)), this._update_length();
      };
      return i instanceof t ? i.ranges.forEach(s) : (n == null && (n = i), s(new e(i, n))), this;
    }
    subtract(i, n) {
      var s = (a) => {
        for (var u = 0; u < this.ranges.length && !a.overlaps(this.ranges[u]); )
          u++;
        for (var c = this.ranges.slice(0, u); u < this.ranges.length && a.overlaps(this.ranges[u]); )
          c = c.concat(this.ranges[u].subtract(a)), u++;
        this.ranges = c.concat(this.ranges.slice(u)), this._update_length();
      };
      return i instanceof t ? i.ranges.forEach(s) : (n == null && (n = i), s(new e(i, n))), this;
    }
    intersect(i, n) {
      var s = [], a = (u) => {
        for (var c = 0; c < this.ranges.length && !u.overlaps(this.ranges[c]); )
          c++;
        for (; c < this.ranges.length && u.overlaps(this.ranges[c]); ) {
          var l = Math.max(this.ranges[c].low, u.low), d = Math.min(this.ranges[c].high, u.high);
          s.push(new e(l, d)), c++;
        }
      };
      return i instanceof t ? i.ranges.forEach(a) : (n == null && (n = i), a(new e(i, n))), this.ranges = s, this._update_length(), this;
    }
    index(i) {
      for (var n = 0; n < this.ranges.length && this.ranges[n].length <= i; )
        i -= this.ranges[n].length, n++;
      return this.ranges[n].low + i;
    }
    toString() {
      return "[ " + this.ranges.join(", ") + " ]";
    }
    clone() {
      return new t(this);
    }
    numbers() {
      return this.ranges.reduce((i, n) => {
        for (var s = n.low; s <= n.high; )
          i.push(s), s++;
        return i;
      }, []);
    }
    subranges() {
      return this.ranges.map((i) => ({
        low: i.low,
        high: i.high,
        length: 1 + i.high - i.low
      }));
    }
  }
  return Om = t, Om;
}
var Pm, u2;
function QW() {
  if (u2)
    return Pm;
  u2 = 1;
  const e = JW(), t = XW(), r = e.types;
  return Pm = class cu {
    /**
     * @constructor
     * @param {RegExp|String} regexp
     * @param {String} m
     */
    constructor(n, s) {
      if (this._setDefaults(n), n instanceof RegExp)
        this.ignoreCase = n.ignoreCase, this.multiline = n.multiline, n = n.source;
      else if (typeof n == "string")
        this.ignoreCase = s && s.indexOf("i") !== -1, this.multiline = s && s.indexOf("m") !== -1;
      else
        throw new Error("Expected a regexp or string");
      this.tokens = e(n);
    }
    /**
     * Checks if some custom properties have been set for this regexp.
     *
     * @param {RandExp} randexp
     * @param {RegExp} regexp
     */
    _setDefaults(n) {
      this.max = n.max != null ? n.max : cu.prototype.max != null ? cu.prototype.max : 100, this.defaultRange = n.defaultRange ? n.defaultRange : this.defaultRange.clone(), n.randInt && (this.randInt = n.randInt);
    }
    /**
     * Generates the random string.
     *
     * @return {String}
     */
    gen() {
      return this._gen(this.tokens, []);
    }
    /**
     * Generate random string modeled after given tokens.
     *
     * @param {Object} token
     * @param {Array.<String>} groups
     * @return {String}
     */
    _gen(n, s) {
      var a, u, c, l, d;
      switch (n.type) {
        case r.ROOT:
        case r.GROUP:
          if (n.followedBy || n.notFollowedBy)
            return "";
          for (n.remember && n.groupNumber === void 0 && (n.groupNumber = s.push(null) - 1), a = n.options ? this._randSelect(n.options) : n.stack, u = "", l = 0, d = a.length; l < d; l++)
            u += this._gen(a[l], s);
          return n.remember && (s[n.groupNumber] = u), u;
        case r.POSITION:
          return "";
        case r.SET:
          var p = this._expand(n);
          return p.length ? String.fromCharCode(this._randSelect(p)) : "";
        case r.REPETITION:
          for (c = this.randInt(
            n.min,
            n.max === 1 / 0 ? n.min + this.max : n.max
          ), u = "", l = 0; l < c; l++)
            u += this._gen(n.value, s);
          return u;
        case r.REFERENCE:
          return s[n.value - 1] || "";
        case r.CHAR:
          var h = this.ignoreCase && this._randBool() ? this._toOtherCase(n.value) : n.value;
          return String.fromCharCode(h);
      }
    }
    /**
     * If code is alphabetic, converts to other case.
     * If not alphabetic, returns back code.
     *
     * @param {Number} code
     * @return {Number}
     */
    _toOtherCase(n) {
      return n + (97 <= n && n <= 122 ? -32 : 65 <= n && n <= 90 ? 32 : 0);
    }
    /**
     * Randomly returns a true or false value.
     *
     * @return {Boolean}
     */
    _randBool() {
      return !this.randInt(0, 1);
    }
    /**
     * Randomly selects and returns a value from the array.
     *
     * @param {Array.<Object>} arr
     * @return {Object}
     */
    _randSelect(n) {
      return n instanceof t ? n.index(this.randInt(0, n.length - 1)) : n[this.randInt(0, n.length - 1)];
    }
    /**
     * expands a token to a DiscontinuousRange of characters which has a
     * length and an index function (for random selecting)
     *
     * @param {Object} token
     * @return {DiscontinuousRange}
     */
    _expand(n) {
      if (n.type === e.types.CHAR)
        return new t(n.value);
      if (n.type === e.types.RANGE)
        return new t(n.from, n.to);
      {
        let s = new t();
        for (let a = 0; a < n.set.length; a++) {
          let u = this._expand(n.set[a]);
          if (s.add(u), this.ignoreCase)
            for (let c = 0; c < u.length; c++) {
              let l = u.index(c), d = this._toOtherCase(l);
              l !== d && s.add(d);
            }
        }
        return n.not ? this.defaultRange.clone().subtract(s) : this.defaultRange.clone().intersect(s);
      }
    }
    /**
     * Randomly generates and returns a number between a and b (inclusive).
     *
     * @param {Number} a
     * @param {Number} b
     * @return {Number}
     */
    randInt(n, s) {
      return n + Math.floor(Math.random() * (1 + s - n));
    }
    /**
     * Default range of characters to generate from.
     */
    get defaultRange() {
      return this._range = this._range || new t(32, 126);
    }
    set defaultRange(n) {
      this._range = n;
    }
    /**
     *
     * Enables use of randexp with a shorter call.
     *
     * @param {RegExp|String| regexp}
     * @param {String} m
     * @return {String}
     */
    static randexp(n, s) {
      var a;
      return typeof n == "string" && (n = new RegExp(n, s)), n._randexp === void 0 ? (a = new cu(n, s), n._randexp = a) : (a = n._randexp, a._setDefaults(n)), a.gen();
    }
    /**
     * Enables sugary /regexp/.gen syntax.
     */
    static sugar() {
      RegExp.prototype.gen = function() {
        return cu.randexp(this);
      };
    }
  }, Pm;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var Sm, c2;
function eH() {
  if (c2)
    return Sm;
  c2 = 1;
  const e = QW(), t = Qt, { copy: r, randomOneOf: i, randomNumber: n, randomText: s } = t;
  Sm = a;
  function a(c, l, d, p, h, v, y, g) {
    const _ = p.type, m = h[v];
    if (m && typeof m == "object") {
      if (d.get(m))
        return;
      d.set(m, !0);
    }
    if (!(g > y.maxDepth)) {
      if (p.hasOwnProperty("default") && Math.random() < y.defaultPossibility)
        h[v] = t.copy(p.default);
      else if (p.enum)
        h[v] = r(i(p.enum));
      else if (p.allOf) {
        const [w, $] = p.allOfMerged;
        $ ? l.nest("Cannot generate random value for schema with allOf").push($) : a(c, l, d, w, h, v, y, g);
      } else if (p.anyOf || p.oneOf) {
        const w = p.anyOf ? "anyOf" : "oneOf";
        if (p.discriminator) {
          const { name: $, key: E, schema: A } = p.discriminate(m, !0);
          if (A)
            a(c, l, d, A, h, v, y, g);
          else if ($ === void 0) {
            const R = i(p[w]);
            a(c, l, d, R, h, v, y, g);
          } else
            c.message('Discriminator property "' + E + '" as "' + $ + '" did not map to a schema');
        } else {
          const $ = i(p[w]);
          a(c, l, d, $, h, v, y, g);
        }
      } else if (p.not)
        l.message("Cannot generate random value for schema with not");
      else if (_ === "array") {
        const w = p.hasOwnProperty("minItems") ? p.minItems : 0;
        let $ = p.hasOwnProperty("maxItems") ? p.maxItems : w + y.arrayVariation - Math.round(0.5 * g);
        $ < w && ($ = w);
        const E = n({ min: w, max: $ });
        if (g > 0 && h.hasOwnProperty(v) && !Array.isArray(h[v]))
          c.message("Provided value is not an array");
        else {
          const A = Array.isArray(m) ? m : [];
          for (let R = 0; R < E; R++) {
            let I = !0, D = y.uniqueItemRetry;
            for (; I && D; ) {
              const J = {};
              a(c.at(R), l.at(R), d, p.items, J, "value", y, g + 1);
              const ae = J.value;
              I = p.uniqueItems && A.findIndex((ye) => t.same(ye, ae)) !== -1, I ? I && !D && l.message("Cannot generate example due to too narrowly scoped schema constraints") : A[R] = ae;
            }
          }
          h[v] = A;
        }
      } else if (_ === "object")
        if (g > 0 && h.hasOwnProperty(v) && !t.isObject(h[v]))
          c.message("Provided value is not a plain object");
        else {
          const w = p.properties ? Object.keys(p.properties) : [], $ = h[v] || {};
          let E = 0;
          p.required && p.required.forEach((I) => {
            const D = w.indexOf(I);
            D !== -1 && w.splice(D, 1);
            let J = p.properties && p.properties[I];
            J || (J = p.additionalProperties), J === !0 && (J = u(p)), a(c.at(I), l.at(I), d, J, $, I, y, g + 1), E++;
          });
          let A = w.length;
          const R = p.hasOwnProperty("maxProperties") ? p.maxProperties : Number.MAX_SAFE_INTEGER;
          for (; A && E < R; ) {
            if (Math.random() < y.definedPropertyPossibility) {
              const I = Math.floor(Math.random() * A), D = w[I];
              a(c.at(D), l.at(D), d, p.properties[D], $, D, y, g + 1), E++;
            }
            A--;
          }
          if (p.additionalProperties) {
            const I = p.hasOwnProperty("minProperties") ? p.minProperties : 0;
            let D = E < I || Math.random() < y.additionalPropertiesPossibility, J = 1;
            for (; D && E < R; ) {
              const ae = "additionalProperty" + J++;
              if (!$.hasOwnProperty(ae)) {
                const ye = p.additionalProperties === !0 ? u(p) : p.additionalProperties;
                a(c.at(ae), l.at(ae), d, ye, $, ae, y, g + 1), E++, D = E < I || Math.random() < y.additionalPropertiesPossibility;
              }
            }
          }
          h[v] = $;
        }
      else if (!h.hasOwnProperty(v) || g === 0) {
        const w = p.enforcerData.staticData.dataTypes, $ = w[p.type] && w[p.type][p.format] || null;
        if ($ && $.random)
          h[v] = $.random({ exception: c, schema: p }, { chooseOne: i, randomNumber: n, randomText: s });
        else if (_ === "boolean")
          h[v] = i([!0, !1]);
        else if (_ === "integer" || _ === "number") {
          const E = _ === "integer" ? 0 : n({ min: 1, max: 4 }), A = !!p.exclusiveMinimum, R = !!p.exclusiveMaximum, I = p.hasOwnProperty("multipleOf") ? p.multipleOf : 0, D = p.hasOwnProperty("minimum"), J = p.hasOwnProperty("maximum");
          let ae, ye;
          D && !J ? (ae = p.minimum, ye = ae + y.numberVariation) : !D && J ? (ye = p.maximum, ae = ye - y.numberVariation) : D && J ? (ae = p.minimum, ye = p.maximum) : (ae = -1 * Math.floor(y.numberVariation * 0.25), ye = Math.ceil(y.numberVariation * 0.75)), h[v] = n({ min: ae, max: ye, multipleOf: I, exclusiveMin: A, exclusiveMax: R, decimalPlaces: E });
        } else if (_ === "string")
          if (p.hasOwnProperty("pattern"))
            h[v] = new e(p.pattern).gen();
          else {
            const E = {};
            p.hasOwnProperty("minLength") && (E.minLength = p.minLength), p.hasOwnProperty("maxLength") && (E.maxLength = p.maxLength), h[v] = s(E);
          }
      }
    }
  }
  function u(c) {
    const l = i([
      { type: "boolean" },
      { type: "integer" },
      { type: "number" },
      { type: "string" },
      { type: "string", format: "date" },
      { type: "string", format: "date-time" }
    ]), [d] = new c.enforcerData.context.Schema(l);
    return d;
  }
  return Sm;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var Am, l2;
function tH() {
  if (l2)
    return Am;
  l2 = 1;
  const e = M0(), t = hS(), r = Qt, i = ws();
  Am = n;
  function n(s, a, u, c) {
    let { serialize: l, value: d } = i.getAttributes(c);
    if (!l)
      return c;
    const p = u.type;
    if (d && typeof d == "object") {
      const v = a.get(u);
      if (v && v.includes(d))
        return d;
      a.set(u, [d]);
    }
    const h = e.runHooks(u, "beforeSerialize", d, s);
    if (d = h.value, h.done)
      return d;
    if (d === null && (u.nullable || u["x-nullable"]))
      return e.after(u, "afterSerialize", d, s);
    if (u.allOf) {
      const v = {}, y = s.nest("Unable to serialize allOf");
      return u.allOf.forEach((g, _) => {
        const m = n(y.at(_), a, g, c);
        Object.assign(v, m);
      }), e.after(u, "afterSerialize", Object.assign(d, v), s);
    } else if (u.anyOf || u.oneOf) {
      let v;
      if (u.discriminator) {
        const { name: y, key: g, schema: _ } = u.discriminate(d, !0);
        _ ? v = Object.assign(d, n(s, a, _, c)) : s.message('Discriminator property "' + g + '" as "' + y + '" did not map to a schema');
      } else
        v = t.anyOneOf(u, c, s, a, n, !0);
      return e.after(u, "afterSerialize", v, s);
    } else if (p === "array") {
      if (Array.isArray(d))
        return u.items && d.forEach((v, y) => {
          d[y] = n(s.at(y), a, u.items, i.inherit(v, { serialize: l }));
        }), e.after(u, "afterSerialize", d, s);
      s.message("Expected an array. Received: " + r.smart(d));
    } else if (p === "object")
      if (r.isObject(d)) {
        const v = u.additionalProperties, y = u.properties || {};
        if (Object.keys(d).forEach((g) => {
          y.hasOwnProperty(g) ? d[g] = n(s.at(g), a, y[g], d[g]) : v && (d[g] = n(s.at(g), a, v, d[g]));
        }), u.discriminator) {
          const { name: g, key: _, schema: m } = u.discriminate(d, !0);
          m ? Object.assign(d, n(s, a, m, c)) : s.message('Discriminator property "' + _ + '" as "' + g + '" did not map to a schema');
        }
        return e.after(u, "afterSerialize", d, s);
      } else
        s.message("Expected an object. Received: " + r.smart(c));
    else if (u !== !0) {
      const v = u.enforcerData.staticData.dataTypes, y = v[u.type] && v[u.type][u.format] || {};
      if (y.serialize || (y.serialize = function({ value: g }) {
        return g;
      }), p === "boolean") {
        let g = y.serialize({
          exception: s,
          schema: u,
          value: d
        });
        return typeof g != "boolean" && s.message("Unable to serialize to a boolean. Received: " + r.smart(d)), e.after(u, "afterSerialize", g, s);
      } else if (p === "integer") {
        let g = y.serialize({
          exception: s,
          schema: u,
          value: d
        });
        return (typeof g != "number" || isNaN(g) || g !== Math.round(g)) && s.message("Unable to serialize to an integer. Received: " + r.smart(d)), e.after(u, "afterSerialize", g, s);
      } else if (p === "number") {
        let g = y.serialize({
          exception: s,
          schema: u,
          value: d
        });
        return (typeof g != "number" || isNaN(g)) && s.message("Unable to serialize to a number. Received: " + r.smart(d)), e.after(u, "afterSerialize", g, s);
      } else if (p === "string") {
        let g = y.serialize({
          exception: s,
          schema: u,
          value: d
        });
        return typeof g != "string" && s.message("Unable to serialize to a string. Received: " + r.smart(d)), e.after(u, "afterSerialize", g, s);
      }
    } else
      return e.after(u, "afterSerialize", d, s);
  }
  return Am;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var Cm, f2;
function rH() {
  if (f2)
    return Cm;
  f2 = 1;
  const e = M0(), t = qn, r = Qt, i = ws();
  Cm = n;
  function n(a, u, c, l, d) {
    let { validate: p, value: h } = i.getAttributes(l);
    if (!p)
      return l;
    const v = c.type;
    if (h && typeof h == "object") {
      let g = u.get(h);
      if (g && g.indexOf(c) !== -1)
        return;
      g || (g = [], u.set(h, g)), g.push(c);
    }
    const y = e.runHooks(c, "beforeValidate", h, a);
    if (h = y.value, y.done)
      return h;
    if (h === null && (c.nullable || c["x-nullable"]))
      return e.after(c, "afterValidate", h, a);
    if (c.allOf) {
      const g = a.nest("Did not validate against all schemas");
      c.allOf.forEach((_, m) => {
        n(g.at(m), u, _, l, d);
      });
    } else if (c.anyOf)
      if (c.discriminator) {
        const g = c.discriminate(h, !0), _ = g.schema, m = g.key;
        if (!_)
          a.message('Discriminator property "' + m + '" as "' + h[m] + '" did not map to a schema');
        else {
          const w = a.at(h[m]);
          n(w, u, _, h, d);
        }
      } else {
        const g = t("Did not validate against at least one schema"), _ = c.anyOf.length;
        let m = !1;
        for (let w = 0; w < _; w++) {
          const $ = g.at(w);
          if (n($, u, c.anyOf[w], h, d), !$.hasException) {
            m = !0;
            break;
          }
        }
        m || a.push(g);
      }
    else if (c.oneOf)
      if (c.discriminator) {
        const { name: g, key: _, schema: m } = c.discriminate(h, !0);
        if (!m)
          a.message('Discriminator property "' + _ + '" as "' + g + '" did not map to a schema');
        else {
          const w = a.at(h[_]);
          n(w, u, m, h, d);
        }
      } else {
        const g = t("Did not validate against exactly one schema"), _ = c.oneOf.length;
        let m = 0;
        for (let w = 0; w < _; w++) {
          const $ = t("Invalid value");
          n($, u, c.oneOf[w], h, d), $.hasException ? g.at(w).push($) : (m++, g.at(w).message("Valid value"));
        }
        m !== 1 && a.push(g);
      }
    else if (c.not) {
      const g = t("");
      n(g, u, c.not, h, d), g.hasException || a.message("Value should not validate against schema");
    } else if (v === "array")
      if (!Array.isArray(h))
        a.message("Expected an array. Received: " + r.smart(h));
      else {
        const g = h.length;
        if (c.hasOwnProperty("maxItems") && c.maxItems < g && a.message("Too many items in the array. Maximum of " + c.maxItems + ". Found " + g + " items"), c.hasOwnProperty("minItems") && c.minItems > g && a.message("Too few items in the array. Minimum of " + c.minItems + ". Found " + g + " items"), c.uniqueItems) {
          const _ = [];
          h.forEach((m, w) => {
            const $ = _.length;
            let E;
            for (let A = 0; A < $; A++)
              if (r.same(m, _[A])) {
                a.message("Array items must be unique. Value is not unique at index " + w), E = !0;
                break;
              }
            E || _.push(m);
          });
        }
        c.items && h.forEach((_, m) => {
          n(a.at(m), u, c.items, _, d);
        });
      }
    else if (v === "object")
      if (!r.isObject(h))
        a.message("Expected a non-null object. Received: " + r.smart(h));
      else {
        const g = c.properties || {}, _ = d.readWriteMode, m = [], w = c.required ? c.required.filter((E) => {
          const A = g[E];
          return !d.readWriteMode || !A || d.readWriteMode === "write" && !A.readOnly || d.readWriteMode === "read" && !A.writeOnly;
        }) : [], $ = Object.keys(h);
        if ($.forEach((E) => {
          const A = w.indexOf(E);
          if (A !== -1 && w.splice(A, 1), g.hasOwnProperty(E)) {
            const R = g[E];
            (_ === "write" && R.readOnly || _ === "read" && R.writeOnly) && m.push(E), n(a.at(E), u, R, h[E], d);
          } else if (c.additionalProperties === !1)
            a.at(E).message("Property not allowed");
          else if (typeof c.additionalProperties == "object") {
            const R = c.additionalProperties;
            (_ === "write" && R.readOnly || _ === "read" && R.writeOnly) && m.push(E), n(a.at(E), u, c.additionalProperties, h[E], d);
          } else
            d.isExample && N0().config.examplesWarnAdditionalProperty === !0 && a.at(E).message("Property is an additional property");
        }), w.length > 0 && a.message("One or more required properties missing: " + w.join(", ")), m.length > 0 && (_ === "write" ? a.message("Cannot write to read only properties: " + m.join(", ")) : _ === "read" && a.message("Cannot read from write only properties: " + m.join(", "))), s(a, c, "object property count", "maxProperties", "minProperties", !1, $.length, c.maxProperties, c.minProperties), c.discriminator) {
          const E = c.discriminate(h, !0), { name: A, key: R } = E;
          E.schema ? n(a, u, E.schema, h, d) : A && a.message('Discriminator property "' + R + '" as "' + A + '" did not map to a schema');
        }
      }
    else {
      const g = c.enforcerData.staticData.dataTypes, _ = g[c.type] && g[c.type][c.format] || { validate: null };
      if (_.validate)
        _.validate({ exception: a, schema: c, value: h });
      else if (v === "boolean")
        typeof h != "boolean" && a.message("Expected a boolean. Received: " + r.smart(h));
      else if (v === "integer")
        isNaN(h) || Math.round(h) !== h || typeof h != "number" ? a.message("Expected an integer. Received: " + r.smart(h)) : (d.maxMin !== !1 && s(a, c, "integer", "maximum", "minimum", !0, h, c.maximum, c.minimum), c.multipleOf && h % c.multipleOf !== 0 && a.message("Expected a multiple of " + c.multipleOf + ". Received: " + r.smart(h)));
      else if (v === "number")
        isNaN(h) || typeof h != "number" ? a.message("Expected a number. Received: " + r.smart(h)) : (d.maxMin !== !1 && s(a, c, "number", "maximum", "minimum", !0, h, c.maximum, c.minimum), c.multipleOf && !Number.isInteger(h / c.multipleOf) && a.message("Expected a multiple of " + c.multipleOf + ". Received: " + r.smart(h)));
      else if (c.type === "string")
        if (typeof h != "string")
          a.message("Expected a string. Received: " + r.smart(h));
        else {
          const m = h.length;
          c.hasOwnProperty("maxLength") && m > c.maxLength && a.message("String too long. " + r.smart(h) + " (" + m + ") above maximum length of " + c.maxLength), c.hasOwnProperty("minLength") && m < c.minLength && a.message("String too short. " + r.smart(h) + " (" + m + ") below minimum length of " + c.minLength), c.hasOwnProperty("pattern") && !c.pattern.test(h) && a.message("String does not match required pattern " + c.pattern + " with value: " + r.smart(h));
        }
    }
    if (c.enum && d.enum !== !1) {
      const g = c.enum.length;
      let _;
      for (let m = 0; m < g; m++)
        if (r.same(h, c.enum[m])) {
          _ = !0;
          break;
        }
      _ || a.message("Value " + r.smart(h) + " did not meet enum requirements");
    }
    e.after(c, "afterValidate", h, a, !0);
  }
  function s(a, u, c, l, d, p, h, v, y) {
    u.hasOwnProperty(l) && (p && u.exclusiveMaximum && h >= v ? a.message("Expected " + c + " to be less than " + r.smart(u.serialize(u[l]).value) + ". Received: " + r.smart(u.serialize(h).value)) : h > v && a.message("Expected " + c + " to be less than or equal to " + r.smart(u.serialize(u[l]).value) + ". Received: " + r.smart(u.serialize(h).value))), u.hasOwnProperty(d) && (p && u.exclusiveMinimum && h <= y ? a.message("Expected " + c + " to be greater than " + r.smart(u.serialize(u[d]).value) + ". Received: " + r.smart(u.serialize(h).value)) : h < y && a.message("Expected " + c + " to be greater than or equal to " + r.smart(u.serialize(u[d]).value) + ". Received: " + r.smart(u.serialize(h).value)));
  }
  return Cm;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var d2;
function p2() {
  return d2 || (d2 = 1, function(e) {
    const t = sr, r = qn, i = oS, n = _s, s = HW(), a = GW(), u = eH(), c = tH(), l = rH(), d = Qt, p = ws(), h = d.freeze, v = /^https?:\/\//, y = {
      colon: w(() => /:([_$a-z][_$a-z0-9]*)/ig),
      doubleHandlebar: w(() => /{{([_$a-z][_$a-z0-9]*)}}/ig),
      handlebar: w(() => /{([_$a-z][_$a-z0-9]*)}/ig)
    }, g = [
      { type: "array", properties: ["items", "maxItems", "minItems", "uniqueItems"] },
      { type: "number", properties: ["exclusiveMaximum", "exclusiveMinimum", "maximum", "minimum", "multpleOf"] },
      { type: "object", properties: ["additionProperties", "maxProperties", "minProperties", "properties"] },
      { type: "string", properties: ["maxLength", "minLength", "pattern"] }
    ], _ = {
      /**
       * Take a serialized (ready for HTTP transmission) value and deserialize it.
       * Converts strings of binary, byte, date, and date-time to JavaScript equivalents.
       * @param {*} value
       * @param {object} [options]
       * @param {boolean} [options.strict=true] Whether to be strict on input when deserializing.
       * @returns {EnforcerResult<*>}
       */
      deserialize: function(re, fe) {
        fe || (fe = {}), fe.hasOwnProperty("strict") || (fe.strict = !0);
        const le = r("Unable to deserialize value"), $e = s(le, /* @__PURE__ */ new Map(), this, d.copy(re), fe);
        return new n($e, le);
      },
      /**
       * Get discriminator key and schema.
       * @param {*} value
       * @param {boolean=false} details
       * @returns {Schema|{ key:string, name:string, schema:Schema }}
       */
      discriminate: function(re, fe) {
        const { major: le, root: $e } = this.enforcerData, Ae = this.discriminator, _e = $e.result;
        let ie, K, V;
        if (Ae) {
          if (le === 2)
            ie = Ae, K = Ae && re && re.hasOwnProperty(Ae) ? re[Ae] : void 0, K && (V = _e.definitions && _e.definitions[K]);
          else if (le === 3 && (ie = Ae.propertyName, K = Ae && re && re.hasOwnProperty(Ae.propertyName) ? re[Ae.propertyName] : void 0, K)) {
            const z = Ae.mapping;
            V = z && z.hasOwnProperty(K) ? z[K] : _e.components && _e.components.schemas && _e.components.schemas[K];
          }
          return fe ? { key: ie, name: K, schema: V } : V;
        }
      },
      /**
       * Take a non plain object and convert it into a plain object far enough so that validation and serialization can occur.
       * @param {*} value
       * @returns {*}
       */
      formalize: function(re) {
        return this.enforcerData.context.Schema.formalize(re);
      },
      /**
       * Populate a value from a list of parameters.
       * @param {object} [params]
       * @param {*} [value]
       * @param {object} [options]
       * @param {boolean} [options.copy=false]
       * @param {boolean} [options.conditions=true]
       * @param {boolean} [options.defaults=true]
       * @param {number} [options.depth=100]
       * @param {string} [options.replacement='handlebar']
       * @param {boolean} [options.templateDefaults=true]
       * @param {boolean} [options.templates=true]
       * @param {boolean} [options.variables=true]
       * @returns {EnforcerResult<*>}
       */
      populate: function(re, fe, le = {}) {
        if (re == null && (re = {}), !re || !d.isObject(re))
          throw Error("Invalid params specified. Must be a plain object");
        if (!le || !d.isObject(le))
          throw Error("Invalid options specified. Must be a plain object");
        if (le.hasOwnProperty("copy") || (le.copy = !1), le.hasOwnProperty("conditions") || (le.conditions = !0), le.hasOwnProperty("defaults") || (le.defaults = !0), le.hasOwnProperty("depth") || (le.depth = 100), le.hasOwnProperty("replacement") || (le.replacement = "handlebar"), le.hasOwnProperty("templateDefaults") || (le.templateDefaults = !0), le.hasOwnProperty("templates") || (le.templates = !0), le.hasOwnProperty("variables") || (le.variables = !0), !d.isInteger(le.depth) || le.depth < 0)
          throw Error("Invalid depth specified. Expected a non-negative integer");
        if (!y.hasOwnProperty(le.replacement))
          throw Error("Invalid replacement type specified. Expected one of: " + Object.keys(y).join(", "));
        le.injector = y[le.replacement], re || (re = {}), le.copy && (fe = d.copy(fe));
        const $e = { value: fe }, Ae = r("Unable to populate value"), _e = r("One or more warnings found while populating value");
        return a(Ae, _e, le.depth - 1, this, re, $e, "value", le), new n($e.value, Ae, _e);
      },
      /**
       * Produce a random value for the schema.
       * @param {*} [value] An initial value to add random values to.
       * @param {object} [options]
       * @param {number} [options.additionalPropertiesPossibility=0]
       * @param {number} [options.arrayVariation=4]
       * @param {boolean} [options.copy=false]
       * @param {number} [options.defaultPossibility=.25]
       * @param {number} [options.definedPropertyPossibility=.80]
       * @param {number} [options.maxDepth=10]
       * @param {number} [options.numberVariation=1000]
       * @param {number} [options.uniqueItemRetry=5]
       * @returns {EnforcerResult<*>}
       */
      random: function(re, fe = {}) {
        if (!fe || !d.isObject(fe))
          throw Error("Invalid options specified. Must be a plain object");
        if (fe.hasOwnProperty("additionalPropertiesPossibility") || (fe.additionalPropertiesPossibility = 0), fe.hasOwnProperty("arrayVariation") || (fe.arrayVariation = 4), fe.hasOwnProperty("copy") || (fe.copy = !1), fe.hasOwnProperty("defaultPossibility") || (fe.defaultPossibility = 0.25), fe.hasOwnProperty("definedPropertyPossibility") || (fe.definedPropertyPossibility = 0.8), fe.hasOwnProperty("maxDepth") || (fe.maxDepth = 10), fe.hasOwnProperty("numberVariation") || (fe.numberVariation = 1e3), fe.hasOwnProperty("uniqueItemRetry") || (fe.uniqueItemRetry = 5), fe.additionalPropertiesPossibility < 0 || fe.additionalPropertiesPossibility > 1)
          throw Error('The option "additionalPropertiesPossibility" must be between 0 and 1 inclusive');
        if (fe.defaultPossibility < 0 || fe.defaultPossibility > 1)
          throw Error('The option "defaultPossibility" must be between 0 and 1 inclusive');
        if (fe.definedPropertyPossibility < 0 || fe.definedPropertyPossibility > 1)
          throw Error('The option "definedPropertyPossibility" must be between 0 and 1 inclusive');
        const le = r("Unable to generate random value"), $e = r("One or more warnings found while generating random value"), Ae = { root: fe.copy ? d.copy(re) : re };
        return u(le, $e, /* @__PURE__ */ new Map(), this, Ae, "root", fe, 0), new n(Ae.root, le, $e);
      },
      /**
       * Take a deserialized (not ready for HTTP transmission) value and serialize it.
       * Converts Buffer and Date objects into string equivalent.
       * @param value
       * @returns {EnforcerResult<*>}
       */
      serialize: function(re) {
        const fe = r("Unable to serialize value"), le = c(fe, /* @__PURE__ */ new Map(), this, d.copy(re));
        return new n(le, fe);
      },
      /**
       * Check to see if the value is valid for this schema.
       * @param {*} value
       * @param {object} [options]
       * @param {string} [options.readWriteMode] Can be undefined, "read", or "write"
       * @returns {EnforcerException|undefined}
       */
      validate: function(re, fe) {
        const le = r("Invalid value");
        if (fe || (fe = {}), l(le, /* @__PURE__ */ new Map(), this, re, fe), le.hasException)
          return le;
      }
    };
    e.exports = {
      init: function(re) {
        const { exception: fe, major: le, plugins: $e, refParser: Ae, staticData: _e, warn: ie, options: K, definition: V } = re, z = K.exceptionSkipCodes, C = K.exceptionEscalateCodes, q = _e.dataTypes, N = q && q[this.type] && q[this.type][this.format] || null;
        if (N && N.validator && N.validator.call(this, re), this.allOf) {
          const F = new r("Unable to merge allOf schemas"), T = new r("One or more warnings produced while merging allOf schemas"), Z = R(F, T, this.allOf.map((k) => k.toObject()), q, le, z, C), Y = {
            exception: F,
            warning: T
          };
          if (!F.hasException) {
            const k = new r("Unable to serialize merged schemas"), U = xe(Z, k, q);
            if (k.hasException)
              F.push(k);
            else {
              const [pe, we] = new re.context.Schema(U);
              we ? (we.title = "One or more error exist when all schemas are considered", F.push(we)) : Y.value = pe;
            }
          }
          Object.defineProperty(this, "allOfMerged", {
            get: () => new n(Y.value, Y.exception, Y.warning)
          });
        }
        if (this.required && this.required.length > 0 && this.additionalProperties !== !1) {
          const F = this.required.slice(0);
          if (Object.keys(this.properties || {}).forEach((T) => {
            const Z = F.indexOf(T);
            Z !== -1 && F.splice(Z, 1);
          }), F.length > 0 && !z.WSCH007 && !d.schemaObjectHasSkipCode(V, "WSCH007")) {
            const T = C.WSCH007 ? fe : ie;
            F.length === 1 ? T.message("Required property not specified as a property but allowed via additionalProperties: " + F[0] + " [WSCH007]") : T.message("Required properties not specified as a property but allowed via additionalProperties: " + F.join(", ") + " [WSCH007]");
          }
        }
        $e.push(() => {
          const F = this.discriminator;
          if (le === 3 && Ae && F && F.mapping) {
            const T = Ae instanceof i, Z = re.definition, Y = this.enforcerData.defToInstanceMap;
            Object.keys(F.mapping).forEach((k) => {
              const U = F.mapping[k];
              let pe;
              if (T) {
                const we = v.test(U) || U.indexOf("/") !== -1 ? U : "#/components/schemas/" + U, He = Ae.getSourceNode(Z);
                pe = Ae.resolvePath(He, we);
              } else {
                const we = v.test(U) || U.indexOf("/") !== -1 ? U : "#/components/schemas/" + U;
                pe = Ae.$refs.get(we);
              }
              je(F.mapping, k, Y.get(pe));
            });
          }
          if (this.hasOwnProperty("enum")) {
            const T = fe.at("enum"), Z = this.enum.map((Y, k) => $(this, T.at(k), Y, {
              enum: !1,
              escalateCodes: C,
              skipCodes: z
            }));
            Object.freeze(Z), je(this, "enum", Z);
          }
          if (this.hasOwnProperty("default")) {
            const T = $(this, fe.at("default"), this.default, {});
            je(this, "default", h(T));
          }
          if (this.hasOwnProperty("example")) {
            const T = new r("Example not valid. [WSCH006]"), Z = $(this, T, this.example, {
              isExample: !0
            });
            T.hasException && !z.WSCH006 && !d.schemaObjectHasSkipCode(V, "WSCH006") && (C.WSCH006 ? fe : ie).at("example").push(T), je(this, "example", h(Z));
          }
        });
      },
      prototype: _,
      statics: function(re) {
        const fe = {}, le = /* @__PURE__ */ new Set(), $e = re.dataTypes = {
          boolean: {},
          integer: {},
          number: {},
          string: {}
        }, Ae = re.hooks = {
          afterDeserialize: [],
          afterSerialize: [],
          afterValidate: [],
          beforeDeserialize: [],
          beforeSerialize: [],
          beforeValidate: []
        };
        return re.dataTypeConstructors = function() {
          return Array.from(le.values());
        }, {
          defineDataTypeFormat: function(_e, ie, K) {
            if (!$e.hasOwnProperty(_e))
              throw Error("Invalid type specified. Must be one of: " + Object.keys($e).join(", "));
            if (!ie || typeof ie != "string")
              throw Error("Invalid format specified. Must be a non-empty string");
            if ($e.hasOwnProperty(ie))
              throw Error('Format "' + ie + '" is already defined');
            if (K !== null) {
              if (typeof K != "object" || typeof K.deserialize != "function" || typeof K.serialize != "function" || typeof K.validate != "function" || K.random && typeof K.random != "function")
                throw Error('Invalid data type definition. Must be an object that defines handlers for "deserialize", "serialize", and "validate" with optional "random" handler.');
              if (K.constructors)
                K.constructors.forEach((V) => {
                  if (typeof V != "function")
                    throw Error("Invalid constructor specified. Expected a function, received: " + V);
                  le.add(V);
                });
              else {
                const V = _e + "-" + ie;
                fe[V] || (fe[V] = !0, console.warn('WARNING: Data type definition missing recommended "constructors" property for type "' + _e + '" and format "' + ie + '".'));
              }
            }
            $e[_e][ie] = Object.assign({}, K, { type: _e, format: ie });
          },
          extractValue: p.extract,
          formalize: function(_e) {
            return _e instanceof this.constructor.Value ? (_e.value = d.toPlainObject(_e.value, {
              preserve: re.dataTypeConstructors()
            }), _e) : d.toPlainObject(_e, {
              preserve: re.dataTypeConstructors()
            });
          },
          hook: function(_e, ie) {
            if (!Ae.hasOwnProperty(_e))
              throw Error("Invalid hook type. Choose one of: " + Object.keys(Ae).join(", "));
            if (typeof ie != "function")
              throw Error("Invalid hook handler. Expected a function. Received: " + d.smart(ie));
            Ae[_e].push(ie);
          },
          unhook: function(_e, ie) {
            const K = Ae[_e] || [], V = K.indexOf(ie);
            V !== -1 && K.splice(V, 1);
          },
          Value: p
        };
      },
      validator: function(re) {
        const { major: fe, options: le, definition: $e } = re, Ae = le.exceptionSkipCodes, _e = le.exceptionEscalateCodes, ie = {
          weight: -8,
          allowed: ({ parent: C }) => ae(C.result),
          type: ({ parent: C }) => ye(C.result),
          deserialize: ({ exception: C, parent: q, result: N }) => {
            const F = s(C, /* @__PURE__ */ new Map(), q.result, N);
            return C.hasException ? N : F;
          },
          errors: ({ exception: C, parent: q, result: N }) => {
            l(C, /* @__PURE__ */ new Map(), q.result, N, { maxMin: !1 });
          }
        }, K = {
          allowed: ({ parent: C }) => C.definition.type === "array",
          type: "number",
          errors: ({ exception: C, result: q }) => {
            (!d.isInteger(q) || q < 0) && C.message("Value must be a non-negative integer");
          }
        }, V = {
          allowed: ({ parent: C }) => C.definition.type === "string" && !ae(C.result),
          type: "number",
          errors: ({ exception: C, result: q }) => {
            (!d.isInteger(q) || q < 0) && C.message("Value must be a non-negative integer");
          }
        }, z = {
          allowed: ({ parent: C }) => C.definition.type === "object",
          type: "number",
          errors: ({ exception: C, result: q }) => {
            (!d.isInteger(q) || q < 0) && C.message("Value must be a non-negative integer");
          }
        };
        return {
          type: "object",
          properties: {
            additionalProperties: t("Schema", {
              allowed: ({ parent: C }) => C.definition.type === "object",
              type: ["boolean", "object"],
              // either boolean or object
              default: !0
            }),
            allOf: {
              type: "array",
              items: t("Schema"),
              errors: ({ exception: C, definition: q }) => {
                const N = {}, F = {};
                q.forEach((Z) => {
                  Z.hasOwnProperty("type") && (N[Z.type] || (N[Z.type] = !0), Z.hasOwnProperty("format") && (Z.format, F[Z.format] = F[Z.format] ? F[Z.format] + 1 : 1));
                });
                const T = Object.keys(F).length;
                q.length === 0 && C.message("Must have at least one item"), Object.keys(N).length > 1 && C.message("All items must be of the same type"), T > 1 && C.message("All items must be of the same format");
              }
            },
            anyOf: {
              allowed: ({ major: C }) => C === 3,
              type: "array",
              items: t("Schema")
            },
            default: {
              freeForm: !0,
              type: ({ parent: C, definition: q }) => {
                const N = C.definition, F = [];
                if (N.type !== void 0)
                  F.push(N.type);
                else if (N.anyOf || N.oneOf) {
                  const T = d.determineSchemaFromSchemas(N.anyOf ?? N.oneOf, q);
                  T === null ? Array.isArray(q) ? F.push("array") : typeof q == "object" ? F.push("object") : F.push(typeof q) : T.type !== void 0 && F.push(T.type);
                } else if (N.allOf) {
                  const T = N.allOf.length;
                  for (let Z = 0; Z < T; Z++) {
                    const Y = N.allOf[Z];
                    if (Y.type !== void 0) {
                      F.push(Y.type);
                      break;
                    }
                  }
                }
                return (N.nullable === !0 || N["x-nullable"] === !0) && F.push("null"), F;
              }
            },
            deprecated: {
              allowed: ({ major: C }) => C === 3,
              type: "boolean",
              default: !1
            },
            description: {
              type: "string"
            },
            discriminator: {
              allowed: ({ parent: C }) => C && C.validator === e.exports.validator && (C.definition.type === "object" || C.definition.anyOf || C.definition.oneOf),
              type: ({ major: C }) => C === 2 ? "string" : "object",
              properties: {
                propertyName: {
                  type: "string",
                  required: !0,
                  errors: ({ definition: C, parent: q }) => {
                    const N = q.parent.definition;
                    N.type === "object" && (!N.required || !N.required.includes(C)) && q.parent.exception.message('Property "' + C + '" must be required because it is used as the discriminator property');
                  }
                },
                mapping: {
                  type: "object",
                  additionalProperties: {
                    type: "string",
                    errors: ({ exception: C, parent: q, refParser: N, result: F }) => {
                      if (N) {
                        let T;
                        if (N instanceof i)
                          try {
                            const Z = v.test(F) || F.indexOf("/") !== -1 ? F : "#/components/schemas/" + F, Y = N.getSourceNode(q.definition);
                            T = N.resolvePath(Y, Z);
                          } catch {
                            C.message("Reference cannot be resolved: " + F);
                          }
                        else
                          try {
                            const Z = v.test(F) || F.indexOf("/") !== -1 ? F : "#/components/schemas/" + F;
                            T = N.$refs.get(Z);
                          } catch {
                            const Y = ". If you are using multiple files to define your OpenAPI document then this may be a limitation of the original dereference function. You can try the custom reference parser (in beta) to see if this resolves the issue.";
                            C.message("Reference cannot be resolved: " + F + Y);
                          }
                        if (T) {
                          const Z = q.parent.parent.definition;
                          Z.anyOf && !Z.anyOf.includes(T) ? C.message("Mapping reference must exist in anyOf: " + F) : Z.oneOf && !Z.oneOf.includes(T) && C.message("Mapping reference must exist in oneOf: " + F);
                        }
                      }
                    }
                  }
                }
              },
              errors: ({ exception: C, major: q, parent: N, definition: F }) => {
                q === 2 ? ((!N.definition.required || !N.definition.required.includes(F)) && C.message('Value "' + F + `" must be found in the parent's required properties list.`), (!N.definition.properties || !N.definition.properties.hasOwnProperty(F)) && C.message('Value "' + F + `" must be found in the parent's properties definition.`)) : q === 3 && F.hasOwnProperty("propertyName") && F.type === "object" && ((!N.definition.required || !N.definition.required.includes(F.propertyName)) && C.message('Value "' + F.propertyName + `" must be found in the parent's required properties list.`), (!N.definition.properties || !N.definition.properties.hasOwnProperty(F.propertyName)) && C.message('Value "' + F.propertyName + `" must be found in the parent's properties definition.`));
              }
            },
            enum: {
              weight: -7,
              type: "array",
              items: {
                allowed: ({ parent: C }) => !!(C && C.parent),
                type: ({ parent: C }) => {
                  const q = C.parent.definition, N = [q.type];
                  return (q.nullable === !0 || q["x-nullable"] === !0) && N.push("null"), N;
                },
                freeForm: !0
              }
            },
            example: {
              allowed: !0,
              freeForm: !0
            },
            exclusiveMaximum: {
              allowed: ({ parent: C }) => ae(C.result),
              type: "boolean",
              errors: ({ exception: C, definition: q, parent: N }) => {
                q && !N.definition.hasOwnProperty("maximum") && C.message("Cannot use exclusiveMaximum without defining a maximum");
              }
            },
            exclusiveMinimum: {
              allowed: ({ parent: C }) => ae(C.result),
              type: "boolean",
              errors: ({ exception: C, definition: q, parent: N }) => {
                q && !N.definition.hasOwnProperty("minimum") && C.message("Cannot use exclusiveMinimum without defining a minimum");
              }
            },
            externalDocs: t("ExternalDocumentation"),
            format: {
              weight: -9,
              allowed: ({ parent: C }) => ["boolean", "integer", "number", "string"].includes(C.definition.type),
              type: "string",
              errors: ({ exception: C, parent: q, warn: N }) => {
                const F = q.definition.format;
                if (F) {
                  const T = q.definition.type, Y = q.staticData.dataTypes[T];
                  !(Y ? Object.keys(Y) : []).includes(F) && !Ae.WSCH001 && !d.schemaObjectHasSkipCode($e, "WSCH001") && (_e.WSCH001 ? C : N).message('Non standard format "' + F + '" used for type "' + T + '". [WSCH001]');
                }
              }
            },
            items: t("Schema", {
              allowed: ({ parent: C }) => C.definition.type === "array",
              required: ({ parent: C }) => C.definition.type === "array"
            }),
            maximum: ie,
            maxItems: K,
            maxLength: V,
            maxProperties: z,
            minimum: ie,
            minItems: K,
            minLength: V,
            minProperties: z,
            multipleOf: {
              allowed: ({ parent: C }) => ["integer", "number"].includes(C.definition.type),
              type: "number"
            },
            not: t("Schema", { allowed: fe === 3 }),
            nullable: {
              allowed: ({ major: C }) => C === 3,
              type: "boolean",
              default: !1
            },
            oneOf: {
              allowed: ({ major: C }) => C === 3,
              type: "array",
              items: t("Schema")
            },
            pattern: {
              allowed: ({ parent: C }) => C.definition.type === "string",
              type: "string",
              deserialize: ({ exception: C, result: q }) => q ? new RegExp(q) : (C.message("Value must be a non-empty string"), /./),
              errors: ({ exception: C, result: q }) => {
                q || C.message("Value must be a non-empty string");
              }
            },
            properties: {
              weight: -5,
              allowed: ({ parent: C }) => C.definition.type === "object",
              type: "object",
              additionalProperties: t("Schema")
            },
            readOnly: {
              allowed: A,
              type: "boolean",
              default: !1,
              errors: ({ major: C, parent: q, definition: N }) => {
                C === 2 && N && q && q.parent && q.parent.parent && q.parent.parent.definition.required && q.parent.parent.definition.required.includes(q.key) && !Ae.WSCH002 && !d.schemaObjectHasSkipCode($e, "WSCH002") && q[_e.WSCH002 ? "exception" : "warn"].message("Property should not be marked as both read only and required. [WSCH002]");
              }
            },
            required: {
              weight: 1,
              allowed: ({ parent: C }) => C.definition.type === "object",
              type: "array",
              items: { type: "string" },
              errors: ({ definition: C, exception: q, parent: N }) => {
                const F = N.definition.additionalProperties, T = N.definition.properties;
                C.forEach((Z) => {
                  (!T || !T[Z]) && !F && q.at(Z).message("Property is listed as required but is not defined in the schema properties and additional properties are not allowed.");
                });
              }
            },
            title: "string",
            type: {
              weight: -10,
              type: "string",
              default: ({ parent: C }) => {
                const q = C.definition;
                if (!(q.hasOwnProperty("allOf") || q.hasOwnProperty("anyOf") || q.hasOwnProperty("not") || q.hasOwnProperty("oneOf"))) {
                  for (let N = g.length; N--; N >= 0) {
                    const F = g[N].type, T = g[N].properties;
                    for (let Z = T.length; Z--; Z >= 0)
                      if (T[Z] in q)
                        return F;
                  }
                  if ("default" in q) {
                    const N = q.default;
                    if (Array.isArray(N))
                      return "array";
                    switch (typeof N) {
                      case "boolean":
                        return "boolean";
                      case "number":
                        return "number";
                      case "object":
                        return "object";
                      case "string":
                        return "string";
                    }
                  }
                  if ("enum" in q) {
                    const N = q.enum[0];
                    if (Array.isArray(N))
                      return "array";
                    switch (typeof N) {
                      case "boolean":
                        return "boolean";
                      case "number":
                        return "number";
                      case "object":
                        return "object";
                      case "string":
                        return "string";
                    }
                  }
                }
              },
              enum: ({ definition: C, exception: q, parent: N }) => {
                const F = e.exports.validator;
                let T = fe === 2, Z = N.parent;
                for (; T && Z; )
                  Z.validator === F && (T = !1), Z = Z.parent;
                return C === "file" && fe === 2 && !T && q.message('Value can only be "file" for non-nested schemas'), T ? ["array", "boolean", "file", "integer", "number", "object", "string"] : ["array", "boolean", "integer", "number", "object", "string"];
              }
            },
            uniqueItems: {
              allowed: ({ parent: C }) => C.definition.type === "array",
              type: "boolean"
            },
            writeOnly: {
              allowed: (C) => C.major === 3 && !!A(C),
              type: "boolean",
              default: !1
            },
            xml: t("Xml")
          },
          errors: (C) => {
            const { exception: q, definition: N, result: F, warn: T } = C;
            if (!N.hasOwnProperty("allOf") && !N.hasOwnProperty("anyOf") && !N.hasOwnProperty("not") && !N.hasOwnProperty("oneOf") && !("type" in N) && !Ae.WSCH005 && !d.schemaObjectHasSkipCode($e, "WSCH005") && (_e.WSCH005 ? q : T).message("Schemas with an indeterminable type cannot serialize, deserialize, or validate values. [WSCH005]"), J(F.minItems, F.maxItems) || q.message('Property "minItems" must be less than or equal to "maxItems"'), J(F.minLength, F.maxLength) || q.message('Property "minLength" must be less than or equal to "maxLength"'), J(F.minProperties, F.maxProperties) || q.message('Property "minProperties" must be less than or equal to "maxProperties"'), F.required && F.hasOwnProperty("maxProperties") && F.required.length > F.maxProperties && q.message('There are more required properties than is allows by "maxProperties" contraint'), !J(F.minimum, F.maximum, F.exclusiveMinimum, F.exclusiveMaximum)) {
              const Y = F.exclusiveMinimum || F.exclusiveMaximum ? "" : "or equal to ";
              q.message('Property "minimum" must be less than ' + Y + '"maximum"');
            }
            F.hasOwnProperty("properties") && Object.keys(F.properties).forEach((Y) => {
              const k = F.properties[Y];
              k.readOnly && k.writeOnly && q.at("properties").at(Y).message("Cannot be marked as both readOnly and writeOnly");
            });
            const Z = [];
            ["allOf", "anyOf", "oneOf", "not"].forEach((Y) => {
              F.hasOwnProperty(Y) && Z.push(Y);
            }), Z.length > 1 && q.message("Cannot have multiple composites: " + Z.join(", "));
          }
        };
      }
    };
    function m(re, fe) {
      const le = "exclusive" + fe[0].toUpperCase() + fe.substring(1), $e = {};
      return $e[le] = !1, re.map((Ae) => Ae.hasOwnProperty(fe) && !Ae.hasOwnProperty(le) ? Object.assign({}, $e, Ae) : Ae);
    }
    function w(re) {
      return function(fe, le) {
        const $e = re();
        let Ae, _e = "", ie = 0;
        for (; Ae = $e.exec(fe); ) {
          const K = Ae[1];
          _e += fe.substring(ie, Ae.index) + (le[K] !== void 0 ? le[K] : Ae[0]), ie = Ae.index + Ae[0].length;
        }
        return _e + fe.substr(ie);
      };
    }
    function $(re, fe, le, $e) {
      let Ae;
      if ([le, Ae] = re.deserialize(le), !Ae) {
        const _e = r("Invalid value");
        l(_e, /* @__PURE__ */ new Map(), re, le, $e), _e.hasException && (Ae = _e);
      }
      return Ae && fe.push(Ae), le;
    }
    function E(re, fe = {}, le = {}) {
      return re.forEach(($e) => {
        $e.hasOwnProperty("format") && (le[$e.format] = !0), $e.hasOwnProperty("type") && (fe[$e.type] = !0), $e.hasOwnProperty("allOf") && E($e.allOf, fe, le);
      }), {
        formats: Object.keys(le),
        types: Object.keys(fe)
      };
    }
    function A({ parent: re }) {
      return re && re.parent && re.parent.key === "properties" && re.parent.parent && re.parent.parent.validator === e.exports.validator;
    }
    function R(re, fe, le, $e, Ae, _e, ie) {
      const { types: K, formats: V } = E(le);
      if (K.length > 1)
        return re.message("All items must be of the same type. Found: " + K.join(", "));
      if (V.length > 1)
        return re.message("All items must be of the same format. Found: " + V.join(", "));
      const z = {};
      le.forEach((Ne) => {
        if (typeof Ne == "object" && Ne !== null) {
          const Le = Ne["x-enforcer-exception-skip-codes"];
          Le !== void 0 && (z["x-enforcer-exception-skip-codes"] === void 0 && (z["x-enforcer-exception-skip-codes"] = ""), z["x-enforcer-exception-skip-codes"] += " " + Le);
        }
      });
      const C = K[0], q = V[0], N = V.length > 0 ? $e[C][V[0]] : null, F = N ? N.isNumeric : !1, T = {};
      C && (T.type = C), q && (T.format = q);
      const Z = Array.from(new Set(le.filter((Ne) => Ne.hasOwnProperty("default")).map((Ne) => Ne.default)));
      Z.length > 1 && !_e.WSCH003 && !d.schemaObjectHasSkipCode(z, "WSCH003") && (ie.WSCH003 ? re : fe).message("Two or more defaults found. Using first default. [WSCH003]"), Z.length > 0 && (T.default = Z[0]);
      let Y = 0;
      const k = re.at("enum"), U = [];
      le.forEach((Ne, Le) => {
        if (Ne.hasOwnProperty("enum"))
          if (Y++, N && N.serialize) {
            const at = Ne.enum.map((mt) => N.serialize({
              exception: k.at(Le),
              schema: Ne,
              value: mt
            }));
            U.push(at);
          } else
            U.push(Ne.enum);
      });
      const pe = {};
      U.forEach((Ne) => {
        Ne.forEach((Le) => {
          pe[Le] ? pe[Le]++ : pe[Le] = 1;
        });
      });
      const He = Object.keys(pe).filter((Ne) => pe[Ne] === Y);
      Y && (He.length === 0 ? re.message("Enum values across schemas have nothing in common") : T.enum = He);
      const Fe = Array.from(new Set(le.filter((Ne) => Ne.hasOwnProperty("example")).map((Ne) => Ne.example)));
      Fe.length > 1 && !_e.WSCH004 && !d.schemaObjectHasSkipCode(z, "WSCH004") && (ie.WSCH004 ? re : fe).message("Two or more examples found. Using first example. [WSCH004]"), Fe.length > 0 && (T.example = Fe[0]);
      const Ge = [], jt = [], Ee = [], Mt = [], St = { hasTrue: !1, hasFalse: !1 };
      if (le.forEach((Ne) => {
        Ne.allOf && Ge.push.apply(Ge, Ne.allOf), Ne.oneOf && Ge.push.apply(jt, Ne.oneOf), Ne.anyOf && Ge.push.apply(Ee, Ne.anyOf), Ne.not && Mt.push(Ne.not), Ne.hasOwnProperty("nullable") && (St[Ne.nullable ? "hasTrue" : "hasFalse"] = !0);
      }), Ge.length && Object.assign(T, R(re.at("allOf"), fe.at("allOf"), Ge, $e, Ae, _e, ie)), jt.length && (T.oneOf = jt), Ee.length && (T.anyOf = Ee), Mt.length === 1 && (T.not = Mt[0]), Mt.length > 1 && (T.not = R(re.at("not"), fe.at("not"), Mt, $e, Ae, _e, ie)), St.hasTrue && St.hasFalse ? re.message("Unable to merge conflicting nullable values") : St.hasTrue ? T.nullable = !0 : St.hasFalse && (T.nullable = !1), I(T, le, "readOnly", D), I(T, le, "writeOnly", D), Ae === 2) {
        const Ne = {};
        le.forEach((at) => {
          at.discriminator && (Ne[at.discriminator] = !0);
        });
        const Le = Object.keys(Ne);
        Le.length === 1 && (T.discriminator = Le[0]), Le.length > 1 && re.message("Unable to merge multiple discriminator values into one");
      } else if (Ae === 3) {
        const Ne = {}, Le = {}, at = [];
        le.forEach((qe) => {
          if (qe.discriminator) {
            const L = qe.discriminator;
            Ne[L.propertyName] = !0, L.mapping && Object.keys(L.mapping).forEach((x) => {
              const S = L.mapping[x];
              Le.hasOwnProperty(x) ? Le[x] !== S && at.push(x) : Le[x] = S;
            });
          }
        });
        const mt = Object.keys(Ne);
        mt.length === 1 && (T.discriminator = mt[0]), mt.length > 1 && re.message("Unable to merge multiple discriminator values into one"), at.length > 0 && re.message("Conflicting discriminator mappings attempt to map different values to same name");
      }
      if (C === "array") {
        const Ne = le.filter((Le) => Le.hasOwnProperty("items")).map((Le) => Le.items);
        T.items = R(re.at("items"), fe.at("items"), Ne, $e, Ae, _e, ie), I(T, le, "maxItems", (Le, at) => ({ value: Le < at ? Le : at })), I(T, le, "minItems", (Le, at) => ({ value: Le > at ? Le : at })), I(T, le, "uniqueItems", D);
      } else if (C === "integer" || C === "number" || F)
        I(T, le, "maximum", (Ne, Le) => ({ value: Ne < Le ? Ne : Le })), I(T, le, "minimum", (Ne, Le) => ({ value: Ne > Le ? Ne : Le })), I(T, le, "multipleOf", (Ne, Le) => ({ value: d.leastCommonMultiple(Ne, Le) })), I(T, m(le, "maximum"), "exclusiveMaximum", (Ne, Le, at, mt, qe) => {
          const L = qe[at].maximum, x = qe[mt].maximum;
          return Ne === !0 && L <= x ? { index: at, value: !0 } : Le === !0 && x <= L ? { index: mt, value: !0 } : L <= x ? { index: at, value: !1 } : { index: mt, value: !1 };
        }), I(T, m(le, "minimum"), "exclusiveMinimum", (Ne, Le, at, mt, qe) => {
          const L = qe[at].minimum, x = qe[mt].minimum;
          return Ne === !0 && L >= x ? { index: at, value: !0 } : Le === !0 && x >= L ? { index: mt, value: !0 } : L >= x ? { index: at, value: !1 } : { index: mt, value: !1 };
        });
      else if (C === "object") {
        const Ne = { true: !1, false: !1 }, Le = le.filter((S) => {
          const G = S.additionalProperties;
          return S.hasOwnProperty("additionalProperties") ? (G === !1 && (Ne.false = !0), G === !0 && (Ne.true = !0), typeof G == "object") : !1;
        }).map((S) => S.additionalProperties);
        Ne.false && (Ne.true || Le.length) ? re.message("Conflict with additionalProperties") : Le.length === 1 ? T.additionalProperties = Le[0] : Le.length > 1 && (T.additionalProperties = R(re.at("additionalProperties"), fe.at("additionalProperties"), Le, $e, Ae, _e, ie));
        const at = re.at("properties"), mt = re.at("properties"), qe = {}, L = {};
        le.forEach((S) => {
          S.hasOwnProperty("properties") && Object.keys(S.properties).forEach((G) => {
            qe[G] || (qe[G] = []), qe[G].push(S.properties[G]);
          }), S.hasOwnProperty("required") && S.required.forEach((G) => {
            L[G] = !0;
          });
        }), Object.keys(qe).forEach((S) => {
          const G = qe[S];
          G.length > 0 && (T.properties || (T.properties = {}), G.length === 1 ? T.properties[S] = G[0] : T.properties[S] = R(at.at(S), mt.at(S), G, $e, Ae, _e, ie));
        });
        const x = Object.keys(L);
        x.length && (T.required = x), I(T, le, "maxProperties", (S, G) => ({ value: S < G ? S : G })), I(T, le, "minProperties", (S, G) => ({ value: S > G ? S : G }));
      } else if (C === "string") {
        const Ne = le.filter((Le) => Le.hasOwnProperty("pattern"));
        Ne.length === 1 ? T.patterns = Ne[0] : Ne.length > 1 && re.message("Unable to merge multiple patterns"), I(T, le, "maxLength", (Le, at) => ({ value: Le < at ? Le : at })), I(T, le, "minLength", (Le, at) => ({ value: Le > at ? Le : at }));
      }
      return T;
    }
    function I(re, fe, le, $e) {
      const Ae = fe.length, _e = [];
      for (let ie = 0; ie < Ae; ie++)
        if (fe[ie].hasOwnProperty(le)) {
          const K = fe[ie][le];
          _e.push({ index: ie, value: K });
        }
      if (_e.length === 1)
        re[le] = _e[0].value;
      else if (_e.length > 1) {
        const ie = _e.length;
        let K = _e[0].value, V = _e[0].index;
        for (let z = 1; z < ie; z++) {
          const C = $e(K, _e[z].value, V, _e[z].index, fe);
          C !== void 0 && (K = C.value, V = C.index);
        }
        re[le] = K;
      }
    }
    function D(re, fe) {
      return { value: re === !0 || fe === !0 };
    }
    function J(re, fe, le, $e) {
      return re === void 0 || fe === void 0 ? !0 : (re = re.valueOf(), fe = fe.valueOf(), re < fe || !le && !$e && re === fe);
    }
    function ae(re) {
      if (["number", "integer"].includes(re.type))
        return !0;
      const fe = re.enforcerData.staticData.dataTypes, le = fe[re.type] && fe[re.type][re.format];
      return !!(le && le.isNumeric);
    }
    function ye(re) {
      const fe = re.enforcerData.staticData.dataTypes, le = fe[re.type] && fe[re.type][re.format];
      if (le && le.isNumeric)
        switch (re.type) {
          case "boolean":
            return "boolean";
          case "string":
            return "string";
          case "integer":
          case "number":
          default:
            return "number";
        }
      else
        return "number";
    }
    function xe(re, fe, le, $e) {
      if (re.pattern && (re.pattern = re.pattern.source), !$e)
        $e = [re];
      else if (!$e.includes(re))
        $e.push(re);
      else
        return re;
      if (re.type === "array" && re.items)
        re.items = xe(re.items, fe.at("items"), le, $e);
      else if (re.type === "object") {
        if (re.additionalProperties && typeof re.additionalProperties == "object" && (re.additionalProperties = xe(re.additionalProperties, fe.at("additionalProperties"), le, $e)), re.properties) {
          const Ae = fe.at("properties");
          Object.keys(re.properties).forEach((_e) => {
            re.properties[_e] = xe(re.properties[_e], Ae.at(_e), le, $e);
          });
        }
      } else {
        const Ae = le.hasOwnProperty(re.type) && le[re.type].hasOwnProperty(re.format) && le[re.type][re.format];
        Ae && Ae.serialize && ["default", "maximum", "minimum", "multipleOf"].forEach((_e) => {
          re.hasOwnProperty(_e) && (re[_e] = Ae.serialize({
            exception: fe.at(_e),
            schema: re,
            value: re[_e]
          }));
        });
      }
      return re;
    }
    function je(re, fe, le) {
      Object.defineProperty(re, fe, {
        configurable: !0,
        enumerable: !0,
        value: le
      });
    }
  }(vm)), vm.exports;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var Rm, h2;
function m2() {
  return h2 || (h2 = 1, Rm = {
    init: function(e) {
    },
    prototype: {},
    validator: function({ major: e, root: t }) {
      return {
        type: "object",
        additionalProperties: {
          type: "array",
          items: {
            type: "string"
          },
          errors: ({ exception: r, parent: i, definition: n }) => {
            t.definition && Object.keys(i.definition).forEach((s) => {
              let a;
              if (e === 2 ? (a = t.definition && t.definition.securityDefinitions && t.definition.securityDefinitions[s], a || r.at(s).message("Security requirement name must be defined at the document root under the securityDefinitions")) : e === 3 && (a = t.definition && t.definition.components && t.definition.components.securitySchemes && t.definition.components.securitySchemes[s], a || r.at(s).message("Security requirement name must be defined at the document root under the components/securitySchemes")), a)
                if (a.type === "oauth2") {
                  let u;
                  e === 2 ? u = a.scopes && Object.keys(a.scopes) || [] : e === 3 && (u = [], Object.keys(a.flows || {}).forEach((c) => {
                    const l = a.flows[c];
                    l.scopes && u.push(...Object.keys(l.scopes));
                  })), n.forEach((c) => {
                    if (!u.includes(c)) {
                      const l = e === 2 ? "securityDefinitions" : "securitySchemes";
                      r.at(s).message("Oauth2 scope not defined in " + l);
                    }
                  });
                } else
                  n.length > 0 && a.type !== "openIdConnect" && r.at(s).message("Security requirement for " + a.type + " value must be an empty array");
            });
          }
        }
      };
    }
  }), Rm;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var Tm, y2;
function g2() {
  if (y2)
    return Tm;
  y2 = 1;
  const e = sr;
  return Tm = {
    init: function(t) {
    },
    prototype: {},
    validator: function({ major: t }) {
      return {
        type: "object",
        properties: {
          authorizationUrl: {
            allowed: ({ parent: r }) => t === 2 && r.definition.type === "oauth2",
            required: ({ parent: r }) => ["implicit", "accessCode"].includes(r.definition.flow),
            type: "string"
          },
          bearerFormat: {
            allowed: ({ parent: r }) => t === 3 && r.definition.type === "http",
            type: "string"
          },
          description: "string",
          flow: {
            allowed: ({ parent: r }) => t === 2 && r.definition.type === "oauth2",
            required: !0,
            type: "string",
            enum: ["implicit", "password", "application", "accessCode"]
          },
          flows: e("OAuthFlows", {
            allowed: ({ parent: r }) => t === 3 && r.definition.type === "oauth2"
          }),
          in: {
            allowed: ({ parent: r }) => r.definition.type === "apiKey",
            required: !0,
            type: "string",
            enum: t === 2 ? ["query", "header"] : ["query", "header", "cookie"]
          },
          name: {
            allowed: ({ parent: r }) => r.definition.type === "apiKey",
            required: !0,
            type: "string"
          },
          openIdConnectUrl: {
            allowed: t === 3,
            required: ({ parent: r }) => r.definition.type === "openIdConnect",
            type: "string"
          },
          scheme: {
            allowed: ({ parent: r }) => t === 3 && r.definition.type === "http",
            required: !0,
            type: "string"
          },
          scopes: {
            allowed: ({ parent: r }) => t === 2 && r.definition.type === "oauth2",
            type: "object",
            required: !0,
            additionalProperties: {
              type: "string"
            }
          },
          tokenUrl: {
            allowed: ({ parent: r }) => t === 2 && r.definition.type === "oauth2",
            required: ({ parent: r }) => ["password", "application", "accessCode"].includes(r.definition.flow)
          },
          type: {
            weight: -10,
            required: !0,
            type: "string",
            enum: t === 2 ? ["basic", "apiKey", "oauth2"] : ["apiKey", "http", "oauth2", "openIdConnect"]
          }
        }
      };
    }
  }, Tm;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var Im, v2;
function yS() {
  if (v2)
    return Im;
  v2 = 1;
  const e = sr, t = qn, r = _s, i = Cf(), n = Qt, s = /^((?:https?|wss?):\/\/)?(.+?)(\/.+)?$/, a = /^\d+\.\d+\.\d+$/;
  return Im = {
    init: function(u) {
    },
    prototype: {
      /**
       * Get path parameters and operation from a method and path.
       * @param {string} method
       * @param {string} path
       * @returns {EnforcerResult<{operation:OperationEnforcer, params:Object}>}
       */
      path: function(u, c) {
        const l = t("Request has one or more errors");
        c = this.enforcerData.options.disablePathNormalization ? c.split("?")[0] : n.edgeSlashes(c.split("?")[0], !0, !1), u = u.toLowerCase();
        const d = this.paths.findMatches(c);
        if (d.length === 0)
          return l.message("Path not found"), l.statusCode = 404, new r(void 0, l);
        const p = d.find((_) => _.path.methods.includes(u));
        if (!p) {
          const _ = /* @__PURE__ */ new Set();
          return d.forEach((m) => {
            m.path.methods.forEach((w) => {
              _.add(w.toUpperCase());
            });
          }), l.message("Method not allowed: " + u.toUpperCase()), l.statusCode = 405, l.pathItem = d[0].path, l.pathItems = d.map((m) => m.path), l.headers = { Allow: Array.from(_).join(", ") }, new r(void 0, l);
        }
        const v = p.path[u], y = v.parametersMap.path, g = p.params;
        if (y) {
          const _ = l.nest("Error in one or more path parameters");
          Object.keys(y).forEach((m) => {
            const w = y[m], $ = y[m].schema;
            let E = w.parse(g[m]);
            E.error || (E = $.deserialize(E.value)), E.error || (E.error = $.validate(E.value)), E.error ? _.at(m).push(E.error) : g[m] = E.value;
          });
        }
        return l.hasException && (l.statusCode = 400, l.operation = v, l.pathKey = p.pathKey), new r({
          operation: v,
          params: g,
          pathKey: p.pathKey
        }, l);
      },
      /**
       * Deserialize and validate a request.
       * @param {object} [request]
       * @param {object|string} [request.body]
       * @param {Object<string,string>} [request.headers={}] The request headers
       * @param {string} [request.method='get']
       * @param {string} [request.path='/']
       * @param {Object<string,string>} [request.query] Will be overwritten if the path includes query string parameters.
       * @param {object} [options]
       * @param {boolean,string[]} [options.allowOtherQueryParameters=false] Allow query parameter data that is not specified in the OAS document
       * @returns {EnforcerResult<{ body:*, cookie:object, headers:object, operation: Operation, path:object, query:object, response:function }>}
       */
      request: function(u, c) {
        if (u = this.toRequestObject(u), !u || typeof u != "object")
          throw Error("Invalid request. Expected a non-null object. Received: " + u);
        if (u.hasOwnProperty("body") && !(typeof u.body == "string" || typeof u.body == "object"))
          throw Error("Invalid body provided");
        if (u.hasOwnProperty("headers") && !n.isObjectStringMap(u.headers))
          throw Error("Invalid request headers. Expected an object with string keys and string values");
        if (u.hasOwnProperty("method") && typeof u.method != "string")
          throw Error("Invalid request method. Expected a string");
        if (!u.hasOwnProperty("path"))
          throw Error("Missing required request path");
        if (typeof u.path != "string")
          throw Error("Invalid request path. Expected a string");
        if (u.hasOwnProperty("query") && !n.isObjectStringMap(u.query))
          throw Error("Invalid request query. Expected an object with string keys and string values");
        if (c || (c = {}), typeof c != "object")
          throw Error("Invalid options. Expected an object. Received: " + c);
        c = Object.assign({}, c), c.hasOwnProperty("allowOtherQueryParameters") || (c.allowOtherQueryParameters = !1), c.pathParametersProcessed = !0;
        const l = u.hasOwnProperty("method") ? u.method.toLowerCase() : "get";
        let [d, p] = u.path.split("?");
        !p && u.hasOwnProperty("query") && (p = n.toQueryString(u.query));
        const h = this.enforcerData.options.disablePathNormalization ? d : n.edgeSlashes(d, !0, !1), [v, y] = this.path(l, h);
        if (y)
          return new r(void 0, y);
        const { operation: g, params: _, pathKey: m } = v, w = {
          headers: u.headers || {},
          path: _,
          query: p || ""
        };
        u.hasOwnProperty("body") && (w.body = u.body);
        const $ = g.request(w, c);
        return $.value ? ($.value.operation = g, $.value.response = (E, A, R = {}) => {
          if (R = n.lowerCaseObjectProperties(R), !R["content-type"] && w.headers.accept) {
            const I = g.getResponseContentTypeMatches(E, w.headers.accept);
            I.length && (R["content-type"] = I[0]);
          }
          return g.response(E, A, R);
        }, $.value.pathKey = m) : ($.error.statusCode = 400, $.error.operation = g, $.error.pathKey = v.pathKey), $;
      },
      toRequestObject: i.prototype.toRequestObject
    },
    validator: function({ major: u }) {
      return {
        type: "object",
        properties: {
          basePath: {
            allowed: u === 2,
            type: "string",
            errors: ({ exception: c, definition: l }) => {
              l[0] !== "/" && c.message("Value must start with a forward slash");
            }
          },
          components: e("Components", { weight: -1, allowed: u === 3 }),
          consumes: {
            allowed: u === 2,
            type: "array",
            items: {
              type: "string"
            }
          },
          definitions: {
            weight: -1,
            allowed: u === 2,
            type: "object",
            additionalProperties: e("Schema")
          },
          host: {
            type: "string",
            allowed: u === 2,
            errors: ({ exception: c, definition: l }) => {
              const d = s.exec(l);
              d && (d[1] && c.message("Value must not include the scheme: " + d[1]), d[3] && c.message("Value must not include sub path: " + d[3]));
            }
          },
          info: e("Info", { required: !0 }),
          openapi: {
            allowed: u === 3,
            required: !0,
            type: "string",
            errors: ({ exception: c, definition: l }) => {
              a.test(l) || c.message("Value must be a semantic version number");
            }
          },
          parameters: {
            allowed: u === 2,
            type: "object",
            additionalProperties: e("Parameter")
          },
          paths: e("Paths", { required: !0 }),
          produces: {
            allowed: u === 2,
            type: "array",
            items: {
              type: "string"
            }
          },
          responses: {
            allowed: u === 2,
            type: "object",
            additionalProperties: e("Response")
          },
          schemes: {
            allowed: u === 2,
            type: "array",
            items: {
              type: "string",
              enum: ["http", "https", "ws", "wss"]
            }
          },
          security: {
            type: "array",
            items: e("SecurityRequirement")
          },
          securityDefinitions: {
            allowed: u === 2,
            type: "object",
            additionalProperties: e("SecurityScheme")
          },
          servers: {
            allowed: u === 3,
            type: "array",
            items: e("Server")
          },
          swagger: {
            allowed: u === 2,
            required: !0,
            type: "string",
            enum: ["2.0"]
          },
          tags: {
            type: "array",
            items: e("Tag")
          },
          externalDocs: e("ExternalDocumentation")
        }
      };
    }
  }, Im;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var jm, b2;
function nH() {
  return b2 || (b2 = 1, jm = yS()), jm;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var km, _2;
function w2() {
  if (_2)
    return km;
  _2 = 1;
  const e = sr;
  return km = {
    init: function(t) {
    },
    prototype: {},
    validator: function(t) {
      return {
        type: "object",
        properties: {
          name: {
            required: !0,
            type: "string"
          },
          description: "string",
          externalDocs: e("ExternalDocumentation")
        }
      };
    }
  }, km;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var Mm, $2;
function E2() {
  return $2 || ($2 = 1, Mm = {
    init: function(e) {
    },
    prototype: {},
    validator: function() {
      return {
        type: "object",
        properties: {
          name: "string",
          namespace: "string",
          prefix: "string",
          attribute: {
            type: "boolean",
            default: !1
          },
          wrapped: {
            type: "boolean",
            default: !1
          }
        }
      };
    }
  }), Mm;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var Nm, x2;
function iH() {
  if (x2)
    return Nm;
  x2 = 1;
  const e = sr;
  return Nm = {
    init: function(t) {
    },
    prototype: {},
    validator: function() {
      return {
        type: "object",
        additionalProperties: e("PathItem")
      };
    }
  }, Nm;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var Dm, O2;
function sH() {
  if (O2)
    return Dm;
  O2 = 1;
  const e = sr;
  return Dm = {
    init: function(t) {
    },
    prototype: {},
    validator: function({ major: t }) {
      return {
        allowed: t === 3,
        type: "object",
        properties: {
          callbacks: {
            type: "object",
            additionalProperties: e("Callback")
          },
          examples: {
            type: "object",
            additionalProperties: e("Example")
          },
          headers: {
            type: "object",
            additionalProperties: e("Header")
          },
          links: {
            type: "object",
            additionalProperties: e("Link")
          },
          parameters: {
            type: "object",
            additionalProperties: e("Parameter")
          },
          requestBodies: {
            type: "object",
            additionalProperties: e("RequestBody")
          },
          responses: {
            type: "object",
            additionalProperties: e("Response")
          },
          schemas: {
            type: "object",
            additionalProperties: e("Schema")
          },
          securitySchemes: {
            type: "object",
            additionalProperties: e("SecurityScheme")
          }
        }
      };
    }
  }, Dm;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var Lm, P2;
function aH() {
  if (P2)
    return Lm;
  P2 = 1;
  const e = sr, t = /^([a-z-]+)\/(\*|[a-z-]+)(?:\+([a-z-]+))?/;
  return Lm = {
    init: function(r) {
    },
    prototype: {},
    validator: function(r) {
      return {
        type: "object",
        allowed: ({ exception: i, key: n, parent: s }) => {
          const a = s && s.parent && s.parent.definition && s.parent.definition.schema;
          return a && a.type === "object" && a.properties && a.properties.hasOwnProperty(n) ? !0 : "Encoding property " + n + " not found among schema object properties";
        },
        properties: {
          allowReserved: {
            type: "boolean",
            ignored: ({ parent: i }) => i.parent.parent.key !== "application/x-www-form-urlencoded",
            default: !1
          },
          contentType: {
            type: "string",
            default: ({ parent: i }) => {
              const n = i.key, s = i.parent.parent.definition.schema.properties[n];
              if (s.type === "string" && s.format === "binary")
                return "application/octet-stream";
              if (s.type === "object")
                return "application/json";
              if (s.type === "array") {
                const a = s.items;
                if (a.type === "string" && a.format === "binary")
                  return "application/octet-stream";
                if (a.type === "object" || a.type === "array")
                  return "application/json";
              }
              return "text/plain";
            },
            errors: ({ exception: i, definition: n }) => {
              t.test(n) || i.message("Value is not a valid content-type");
            }
          },
          headers: {
            ignored: ({ parent: i }) => !i.parent.parent.key.startsWith("multipart/"),
            type: "object",
            additionalProperties: e("Header", {
              ignored: ({ key: i }) => i.toLowerCase() === "content-type"
            })
          },
          style: {
            weight: -5,
            type: "string",
            ignored: ({ parent: i }) => i.parent.parent.key !== "application/x-www-form-urlencoded",
            default: "form",
            enum: ["form", "spaceDelimited", "pipeDelimited", "deepObject"],
            errors: ({ exception: i, parent: n, definition: s }) => {
              const a = n.parent.parent.definition.schema.type;
              if (!a || !s)
                return !1;
              n.definition.in === "query" && s !== "form" && !(s === "spaceDelimited" && a === "array") && !(s === "pipeDelimited" && a === "array") && !(s === "deepObject" && a === "object") && i.message('Style "' + s + '" is incompatible with schema type: ' + a);
            }
          },
          explode: {
            type: "boolean",
            ignored: ({ parent: i }) => i.parent.parent.key !== "application/x-www-form-urlencoded",
            default: ({ parent: i }) => i.definition.style === "form"
          }
        }
      };
    }
  }, Lm;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var qm, S2;
function oH() {
  return S2 || (S2 = 1, qm = {
    init: function(e) {
    },
    prototype: {},
    validator: function(e) {
      return {
        type: "object",
        properties: {
          summary: { type: "string" },
          description: { type: "string" },
          value: { allowed: !0, freeForm: !0 },
          externalValue: { type: "string" }
        },
        errors: ({ exception: t, definition: r }) => {
          r.hasOwnProperty("value") && r.hasOwnProperty("externalValue") && t.message('Cannot have both "externalValue" and "value" properties');
        }
      };
    }
  }), qm;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var Fm, A2;
function uH() {
  if (A2)
    return Fm;
  A2 = 1;
  const e = sr;
  return Fm = {
    init: function(t) {
    },
    prototype: {},
    validator: function(t) {
      return {
        type: "object",
        properties: {
          description: {
            type: "string"
          },
          operationRef: {
            type: "string"
          },
          operationId: {
            type: "string"
          },
          parameters: {
            type: "object",
            additionalProperties: !0
          },
          requestBody: {},
          server: e("Server")
        },
        errors: ({ definition: r, exception: i }) => {
          r.hasOwnProperty("operationRef") && r.hasOwnProperty("operationId") && i.message("Must not define both operationId and operationRef");
        }
      };
    }
  }, Fm;
}
var Um = { exports: {} };
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var Bm, C2;
function gS() {
  if (C2)
    return Bm;
  C2 = 1;
  const e = sr;
  return Bm = {
    init: function(t) {
    },
    prototype: {},
    validator: function({ major: t }) {
      return {
        allowed: t === 3,
        type: "object",
        properties: {
          description: {
            type: "string"
          },
          content: {
            type: "object",
            required: !0,
            additionalProperties: e("MediaType")
          },
          required: {
            type: "boolean",
            default: !1
          }
        }
      };
    }
  }, Bm;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var R2;
function cH() {
  return R2 || (R2 = 1, function(e) {
    const t = sr, r = gS(), i = Qt, n = /(?:^multipart\/)|(?:^application\/x-www-form-urlencoded$)/;
    e.exports = {
      init: function(s) {
        const { exception: a, warn: u, plugins: c, options: l } = s;
        c.push(() => {
          i.validateExamples(this, a, u, l);
        });
      },
      prototype: {},
      validator: function(s) {
        const a = s.options.exceptionEscalateCodes, u = s.options.exceptionSkipCodes, c = s.definition;
        return {
          type: "object",
          properties: {
            encoding: {
              type: "object",
              allowed: ({ parent: l }) => l.parent.parent.validator === r.validator,
              additionalProperties: t("Encoding"),
              errors: ({ exception: l, parent: d }) => {
                n.test(d.key) || l.message("Mime type must be multipart/* or application/x-www-form-urlencoded. Found: " + d.key);
              }
            },
            example: { allowed: !0, freeForm: !0 },
            examples: {
              type: "object",
              additionalProperties: t("Example")
            },
            schema: t("Schema")
          },
          errors: ({ parent: l, key: d, exception: p, warn: h }) => {
            l && l.key === "content" && !e.exports.rx.mediaType.test(d) && !u.WMED001 && !i.schemaObjectHasSkipCode(c, "WMED001") && (a.WMED001 ? p : h).message("Media type appears invalid. [WMED001]");
          }
        };
      },
      rx: {
        mediaType: /^(?:\*|(application|audio|example|font|image|message|model|multipart|text|video|x-\S+))\/(?:\*|(?:([\w.\-]+)\+)?([\w.\-]+)(?:; *(.+))?)$/
      }
    };
  }(Um)), Um.exports;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var Vm, T2;
function lH() {
  return T2 || (T2 = 1, Vm = {
    init: function(e) {
    },
    prototype: {},
    validator: function(e) {
      return {
        type: "object",
        properties: {
          authorizationUrl: {
            allowed: ({ parent: t }) => t && ["implicit", "authorizationCode"].includes(t.key),
            required: !0,
            type: "string"
          },
          refreshUrl: {
            type: "string"
          },
          scopes: {
            required: !0,
            type: "object",
            additionalProperties: {
              type: "string"
            }
          },
          tokenUrl: {
            allowed: ({ parent: t }) => t && ["password", "clientCredentials", "authorizationCode"].includes(t.key),
            required: !0,
            type: "string"
          }
        }
      };
    }
  }), Vm;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var Zm, I2;
function fH() {
  if (I2)
    return Zm;
  I2 = 1;
  const e = sr;
  return Zm = {
    init: function(t) {
    },
    prototype: {},
    validator: function(t) {
      return {
        type: "object",
        properties: {
          authorizationCode: e("OAuthFlow"),
          clientCredentials: e("OAuthFlow"),
          implicit: e("OAuthFlow"),
          password: e("OAuthFlow")
        }
      };
    }
  }, Zm;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var zm, j2;
function dH() {
  if (j2)
    return zm;
  j2 = 1;
  const e = sr;
  return zm = {
    init: function(t) {
    },
    prototype: {},
    validator: function(t) {
      return {
        type: "object",
        properties: {
          description: {
            type: "string"
          },
          url: {
            type: "string",
            required: !0
          },
          variables: e("ServerVariable")
        }
      };
    }
  }, zm;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var Wm, k2;
function pH() {
  return k2 || (k2 = 1, Wm = {
    init: function(e) {
    },
    prototype: {},
    validator: function(e) {
      return {
        type: "object",
        additionalProperties: {
          type: "object",
          properties: {
            default: {
              type: "string",
              required: !0
            },
            description: {
              type: "string"
            },
            enum: {
              type: "array",
              items: {
                type: "string"
              }
            }
          }
        }
      };
    }
  }), Wm;
}
const hH = "openapi-enforcer", mH = "1.22.3", yH = "Library for validating, parsing, and formatting data against open api schemas.", gH = "index.js", vH = {
  test: "tests"
}, bH = {
  test: "mocha --recursive test",
  coverage: "nyc --reporter=html npm test",
  "coverage:report": "nyc npm test && nyc report --reporter=text-lcov | coveralls",
  "coverage:watch": "chokidar 'test/**/*' 'bin/**/*' -c 'npm run coverage'",
  "docs:build": "markdown-docs build docs-src docs",
  "docs:dev": "markdown-docs dev docs-src",
  prepublishOnly: "npm test"
}, _H = {
  type: "git",
  url: "git+https://github.com/byu-oit/openapi-enforcer.git"
}, wH = "openapi-enforcer.d.ts", $H = [
  "openapi",
  "swagger",
  "validate",
  "response",
  "build",
  "compose",
  "parse",
  "format",
  "deserialize",
  "serialize",
  "request validation",
  "request parsing",
  "response validation",
  "response serializing",
  "utility",
  "utils",
  "plugable"
], EH = "James Speirs", xH = "Apache-2.0", OH = {
  url: "https://github.com/byu-oit/openapi-enforcer/issues"
}, PH = "https://openapi-enforcer.com", SH = {
  chai: "^4.3.4",
  coveralls: "^3.1.1",
  mocha: "^9.1.3",
  nyc: "^15.1.0"
}, AH = {
  "js-yaml": "^4.1.0",
  randexp: "^0.5.3"
}, CH = {
  name: hH,
  version: mH,
  description: yH,
  main: gH,
  directories: vH,
  scripts: bH,
  repository: _H,
  types: wH,
  keywords: $H,
  author: EH,
  license: xH,
  bugs: OH,
  homepage: PH,
  devDependencies: SH,
  dependencies: AH
};
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var Hm, M2;
function N0() {
  if (M2)
    return Hm;
  M2 = 1, Hm = a;
  const e = cc, t = qn, r = oS, i = _s, n = ZW, s = Qt;
  async function a(l, d) {
    let p, h = t("One or more warnings exist int he OpenAPI definition");
    d = Object.assign({}, d), d.hasOwnProperty("hideWarnings") || (d.hideWarnings = !1), d.hasOwnProperty("fullResult") || (d.fullResult = !1), d.hasOwnProperty("componentOptions") || (d.componentOptions = {});
    let v;
    l = s.copy(l);
    const y = new r(l), [g, _] = await y.dereference();
    if (l = g, v = _, !v) {
      v = t("One or more errors exist in the OpenAPI definition");
      const m = l.hasOwnProperty("swagger");
      if (!m && !l.hasOwnProperty("openapi"))
        v.message('Missing required "openapi" or "swagger" property');
      else {
        const w = /^(\d+)(?:\.(\d+))(?:\.(\d+))?$/.exec(l.swagger || l.openapi);
        w ? [p, v, h] = (+w[1] === 2 ? a.v2_0.Swagger : a.v3_0.OpenApi)(l, y, d.componentOptions) : v.at(m ? "swagger" : "openapi").message("Invalid value");
      }
    }
    if (d.fullResult)
      return new i(p, v, h);
    if (!d.hideWarnings && h && h.hasException && console.warn(h.toString()), v && v.hasException)
      throw Error(v.toString());
    return p.getBundledDefinition = async function() {
      const m = await y.bundle();
      if (m.error)
        throw Error(m.error);
      return m.value;
    }, p;
  }
  a.config = {
    examplesWarnAdditionalProperty: !0,
    useCaseSensitivePaths: !0,
    useNewRefParser: !1
  }, a.bundle = async function(l) {
    const p = await new r(l).bundle();
    if (a.config.useNewRefParser)
      return p;
    {
      const [h, v] = p;
      if (v)
        throw v;
      return h;
    }
  }, a.dereference = async function(l) {
    const p = await new r(l).dereference();
    if (a.config.useNewRefParser)
      return p;
    {
      const [h, v] = p;
      if (v)
        throw v;
      return h;
    }
  }, a.Enforcer = a, a.Exception = t, a.Result = i, a.toPlainObject = s.toPlainObject;
  const u = a.v2_0 = {};
  Object.defineProperty(u, "version", { value: "2.0" }), Object.assign(u, {
    Contact: n(u, "Contact", A$()),
    ExternalDocumentation: n(u, "ExternalDocumentation", R$()),
    Header: n(u, "Header", j$()),
    Info: n(u, "Info", M$()),
    License: n(u, "License", D$()),
    Operation: n(u, "Operation", Cf()),
    Parameter: n(u, "Parameter", U$()),
    PathItem: n(u, "PathItem", V$()),
    Paths: n(u, "Paths", z$()),
    Reference: n(u, "Reference", H$()),
    Response: n(u, "Response", K$()),
    Responses: n(u, "Responses", J$()),
    Schema: n(u, "Schema", p2()),
    SecurityRequirement: n(u, "SecurityRequirement", m2()),
    SecurityScheme: n(u, "SecurityScheme", g2()),
    Swagger: n(u, "Swagger", nH()),
    Tag: n(u, "Tag", w2()),
    Xml: n(u, "Xml", E2())
  });
  const c = a.v3_0 = {};
  return Object.defineProperty(c, "version", { value: "3.0" }), Object.assign(c, {
    Callback: n(c, "Callback", iH()),
    Components: n(c, "Components", sH()),
    Contact: n(c, "Contact", A$()),
    Encoding: n(c, "Encoding", aH()),
    Example: n(c, "Example", oH()),
    ExternalDocumentation: n(c, "ExternalDocumentation", R$()),
    Header: n(c, "Header", j$()),
    Info: n(c, "Info", M$()),
    License: n(c, "License", D$()),
    Link: n(c, "Link", uH()),
    MediaType: n(c, "MediaType", cH()),
    OAuthFlow: n(c, "OAuthFlow", lH()),
    OAuthFlows: n(c, "OAuthFlows", fH()),
    OpenApi: n(c, "OpenApi", yS()),
    Operation: n(c, "Operation", Cf()),
    Parameter: n(c, "Parameter", U$()),
    PathItem: n(c, "PathItem", V$()),
    Paths: n(c, "Paths", z$()),
    Reference: n(c, "Reference", H$()),
    RequestBody: n(c, "RequestBody", gS()),
    Response: n(c, "Response", K$()),
    Responses: n(c, "Responses", J$()),
    Schema: n(c, "Schema", p2()),
    SecurityRequirement: n(c, "SecurityRequirement", m2()),
    SecurityScheme: n(c, "SecurityScheme", g2()),
    Server: n(c, "Server", dH()),
    ServerVariable: n(c, "ServerVariable", pH()),
    Tag: n(c, "Tag", w2()),
    Xml: n(c, "Xml", E2())
  }), Object.defineProperty(a, "version", {
    configurable: !1,
    value: CH.version
  }), [a.v2_0.Schema, a.v3_0.Schema].forEach((l) => {
    l.defineDataTypeFormat("integer", "int32", null), l.defineDataTypeFormat("integer", "int64", null), l.defineDataTypeFormat("number", "float", null), l.defineDataTypeFormat("number", "double", null), l.defineDataTypeFormat("string", "binary", e.binary), l.defineDataTypeFormat("string", "byte", e.byte), l.defineDataTypeFormat("string", "date", e.date), l.defineDataTypeFormat("string", "date-time", e.dateTime);
  }), Hm;
}
var RH = N0();
const vS = /* @__PURE__ */ ta(RH);
var Rf = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
Rf.exports;
(function(e, t) {
  (function() {
    var r, i = "4.17.21", n = 200, s = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", a = "Expected a function", u = "Invalid `variable` option passed into `_.template`", c = "__lodash_hash_undefined__", l = 500, d = "__lodash_placeholder__", p = 1, h = 2, v = 4, y = 1, g = 2, _ = 1, m = 2, w = 4, $ = 8, E = 16, A = 32, R = 64, I = 128, D = 256, J = 512, ae = 30, ye = "...", xe = 800, je = 16, re = 1, fe = 2, le = 3, $e = 1 / 0, Ae = 9007199254740991, _e = 17976931348623157e292, ie = 0 / 0, K = 4294967295, V = K - 1, z = K >>> 1, C = [
      ["ary", I],
      ["bind", _],
      ["bindKey", m],
      ["curry", $],
      ["curryRight", E],
      ["flip", J],
      ["partial", A],
      ["partialRight", R],
      ["rearg", D]
    ], q = "[object Arguments]", N = "[object Array]", F = "[object AsyncFunction]", T = "[object Boolean]", Z = "[object Date]", Y = "[object DOMException]", k = "[object Error]", U = "[object Function]", pe = "[object GeneratorFunction]", we = "[object Map]", He = "[object Number]", Fe = "[object Null]", Ge = "[object Object]", jt = "[object Promise]", Ee = "[object Proxy]", Mt = "[object RegExp]", St = "[object Set]", Ne = "[object String]", Le = "[object Symbol]", at = "[object Undefined]", mt = "[object WeakMap]", qe = "[object WeakSet]", L = "[object ArrayBuffer]", x = "[object DataView]", S = "[object Float32Array]", G = "[object Float64Array]", ce = "[object Int8Array]", me = "[object Int16Array]", Oe = "[object Int32Array]", ut = "[object Uint8Array]", Dt = "[object Uint8ClampedArray]", Tt = "[object Uint16Array]", wt = "[object Uint32Array]", It = /\b__p \+= '';/g, $o = /\b(__p \+=) '' \+/g, Eo = /(__e\(.*?\)|\b__t\)) \+\n'';/g, ua = /&(?:amp|lt|gt|quot|#39);/g, ca = /[&<>"']/g, xo = RegExp(ua.source), Fn = RegExp(ca.source), Oo = /<%-([\s\S]+?)%>/g, la = /<%([\s\S]+?)%>/g, fa = /<%=([\s\S]+?)%>/g, $s = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, da = /^\w*$/, Po = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Ni = /[\\^$.*+?()[\]{}|]/g, So = RegExp(Ni.source), Di = /^\s+/, se = /\s/, X = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, ue = /\{\n\/\* \[wrapped with (.+)\] \*/, ve = /,? & /, ge = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, Ye = /[()=,{}\[\]\/\s]/, Xe = /\\(\\)?/g, Et = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, Lt = /\w*$/, Wt = /^[-+]0x[0-9a-f]+$/i, vt = /^0b[01]+$/i, Q = /^\[object .+?Constructor\]$/, O = /^0o[0-7]+$/i, j = /^(?:0|[1-9]\d*)$/, W = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, ne = /($^)/, te = /['\n\r\u2028\u2029\\]/g, Ie = "\\ud800-\\udfff", Se = "\\u0300-\\u036f", Ke = "\\ufe20-\\ufe2f", Ze = "\\u20d0-\\u20ff", ct = Se + Ke + Ze, Ut = "\\u2700-\\u27bf", Ur = "a-z\\xdf-\\xf6\\xf8-\\xff", Gr = "\\xac\\xb1\\xd7\\xf7", bn = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", Es = "\\u2000-\\u206f", dc = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", Ao = "A-Z\\xc0-\\xd6\\xd8-\\xde", xs = "\\ufe0e\\ufe0f", Os = Gr + bn + Es + dc, Li = "['’]", pc = "[" + Ie + "]", Co = "[" + Os + "]", Un = "[" + ct + "]", D0 = "\\d+", wS = "[" + Ut + "]", L0 = "[" + Ur + "]", q0 = "[^" + Ie + Os + D0 + Ut + Ur + Ao + "]", bd = "\\ud83c[\\udffb-\\udfff]", $S = "(?:" + Un + "|" + bd + ")", F0 = "[^" + Ie + "]", _d = "(?:\\ud83c[\\udde6-\\uddff]){2}", wd = "[\\ud800-\\udbff][\\udc00-\\udfff]", pa = "[" + Ao + "]", U0 = "\\u200d", B0 = "(?:" + L0 + "|" + q0 + ")", ES = "(?:" + pa + "|" + q0 + ")", V0 = "(?:" + Li + "(?:d|ll|m|re|s|t|ve))?", Z0 = "(?:" + Li + "(?:D|LL|M|RE|S|T|VE))?", z0 = $S + "?", W0 = "[" + xs + "]?", xS = "(?:" + U0 + "(?:" + [F0, _d, wd].join("|") + ")" + W0 + z0 + ")*", OS = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", PS = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", H0 = W0 + z0 + xS, SS = "(?:" + [wS, _d, wd].join("|") + ")" + H0, AS = "(?:" + [F0 + Un + "?", Un, _d, wd, pc].join("|") + ")", CS = RegExp(Li, "g"), RS = RegExp(Un, "g"), $d = RegExp(bd + "(?=" + bd + ")|" + AS + H0, "g"), TS = RegExp([
      pa + "?" + L0 + "+" + V0 + "(?=" + [Co, pa, "$"].join("|") + ")",
      ES + "+" + Z0 + "(?=" + [Co, pa + B0, "$"].join("|") + ")",
      pa + "?" + B0 + "+" + V0,
      pa + "+" + Z0,
      PS,
      OS,
      D0,
      SS
    ].join("|"), "g"), IS = RegExp("[" + U0 + Ie + ct + xs + "]"), jS = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, kS = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ], MS = -1, Ht = {};
    Ht[S] = Ht[G] = Ht[ce] = Ht[me] = Ht[Oe] = Ht[ut] = Ht[Dt] = Ht[Tt] = Ht[wt] = !0, Ht[q] = Ht[N] = Ht[L] = Ht[T] = Ht[x] = Ht[Z] = Ht[k] = Ht[U] = Ht[we] = Ht[He] = Ht[Ge] = Ht[Mt] = Ht[St] = Ht[Ne] = Ht[mt] = !1;
    var zt = {};
    zt[q] = zt[N] = zt[L] = zt[x] = zt[T] = zt[Z] = zt[S] = zt[G] = zt[ce] = zt[me] = zt[Oe] = zt[we] = zt[He] = zt[Ge] = zt[Mt] = zt[St] = zt[Ne] = zt[Le] = zt[ut] = zt[Dt] = zt[Tt] = zt[wt] = !0, zt[k] = zt[U] = zt[mt] = !1;
    var NS = {
      // Latin-1 Supplement block.
      À: "A",
      Á: "A",
      Â: "A",
      Ã: "A",
      Ä: "A",
      Å: "A",
      à: "a",
      á: "a",
      â: "a",
      ã: "a",
      ä: "a",
      å: "a",
      Ç: "C",
      ç: "c",
      Ð: "D",
      ð: "d",
      È: "E",
      É: "E",
      Ê: "E",
      Ë: "E",
      è: "e",
      é: "e",
      ê: "e",
      ë: "e",
      Ì: "I",
      Í: "I",
      Î: "I",
      Ï: "I",
      ì: "i",
      í: "i",
      î: "i",
      ï: "i",
      Ñ: "N",
      ñ: "n",
      Ò: "O",
      Ó: "O",
      Ô: "O",
      Õ: "O",
      Ö: "O",
      Ø: "O",
      ò: "o",
      ó: "o",
      ô: "o",
      õ: "o",
      ö: "o",
      ø: "o",
      Ù: "U",
      Ú: "U",
      Û: "U",
      Ü: "U",
      ù: "u",
      ú: "u",
      û: "u",
      ü: "u",
      Ý: "Y",
      ý: "y",
      ÿ: "y",
      Æ: "Ae",
      æ: "ae",
      Þ: "Th",
      þ: "th",
      ß: "ss",
      // Latin Extended-A block.
      Ā: "A",
      Ă: "A",
      Ą: "A",
      ā: "a",
      ă: "a",
      ą: "a",
      Ć: "C",
      Ĉ: "C",
      Ċ: "C",
      Č: "C",
      ć: "c",
      ĉ: "c",
      ċ: "c",
      č: "c",
      Ď: "D",
      Đ: "D",
      ď: "d",
      đ: "d",
      Ē: "E",
      Ĕ: "E",
      Ė: "E",
      Ę: "E",
      Ě: "E",
      ē: "e",
      ĕ: "e",
      ė: "e",
      ę: "e",
      ě: "e",
      Ĝ: "G",
      Ğ: "G",
      Ġ: "G",
      Ģ: "G",
      ĝ: "g",
      ğ: "g",
      ġ: "g",
      ģ: "g",
      Ĥ: "H",
      Ħ: "H",
      ĥ: "h",
      ħ: "h",
      Ĩ: "I",
      Ī: "I",
      Ĭ: "I",
      Į: "I",
      İ: "I",
      ĩ: "i",
      ī: "i",
      ĭ: "i",
      į: "i",
      ı: "i",
      Ĵ: "J",
      ĵ: "j",
      Ķ: "K",
      ķ: "k",
      ĸ: "k",
      Ĺ: "L",
      Ļ: "L",
      Ľ: "L",
      Ŀ: "L",
      Ł: "L",
      ĺ: "l",
      ļ: "l",
      ľ: "l",
      ŀ: "l",
      ł: "l",
      Ń: "N",
      Ņ: "N",
      Ň: "N",
      Ŋ: "N",
      ń: "n",
      ņ: "n",
      ň: "n",
      ŋ: "n",
      Ō: "O",
      Ŏ: "O",
      Ő: "O",
      ō: "o",
      ŏ: "o",
      ő: "o",
      Ŕ: "R",
      Ŗ: "R",
      Ř: "R",
      ŕ: "r",
      ŗ: "r",
      ř: "r",
      Ś: "S",
      Ŝ: "S",
      Ş: "S",
      Š: "S",
      ś: "s",
      ŝ: "s",
      ş: "s",
      š: "s",
      Ţ: "T",
      Ť: "T",
      Ŧ: "T",
      ţ: "t",
      ť: "t",
      ŧ: "t",
      Ũ: "U",
      Ū: "U",
      Ŭ: "U",
      Ů: "U",
      Ű: "U",
      Ų: "U",
      ũ: "u",
      ū: "u",
      ŭ: "u",
      ů: "u",
      ű: "u",
      ų: "u",
      Ŵ: "W",
      ŵ: "w",
      Ŷ: "Y",
      ŷ: "y",
      Ÿ: "Y",
      Ź: "Z",
      Ż: "Z",
      Ž: "Z",
      ź: "z",
      ż: "z",
      ž: "z",
      Ĳ: "IJ",
      ĳ: "ij",
      Œ: "Oe",
      œ: "oe",
      ŉ: "'n",
      ſ: "s"
    }, DS = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    }, LS = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    }, qS = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    }, FS = parseFloat, US = parseInt, G0 = typeof rt == "object" && rt && rt.Object === Object && rt, BS = typeof self == "object" && self && self.Object === Object && self, mr = G0 || BS || Function("return this")(), Ed = t && !t.nodeType && t, Ps = Ed && !0 && e && !e.nodeType && e, K0 = Ps && Ps.exports === Ed, xd = K0 && G0.process, sn = function() {
      try {
        var de = Ps && Ps.require && Ps.require("util").types;
        return de || xd && xd.binding && xd.binding("util");
      } catch {
      }
    }(), Y0 = sn && sn.isArrayBuffer, J0 = sn && sn.isDate, X0 = sn && sn.isMap, Q0 = sn && sn.isRegExp, ev = sn && sn.isSet, tv = sn && sn.isTypedArray;
    function Kr(de, Pe, be) {
      switch (be.length) {
        case 0:
          return de.call(Pe);
        case 1:
          return de.call(Pe, be[0]);
        case 2:
          return de.call(Pe, be[0], be[1]);
        case 3:
          return de.call(Pe, be[0], be[1], be[2]);
      }
      return de.apply(Pe, be);
    }
    function VS(de, Pe, be, ze) {
      for (var ft = -1, Nt = de == null ? 0 : de.length; ++ft < Nt; ) {
        var ur = de[ft];
        Pe(ze, ur, be(ur), de);
      }
      return ze;
    }
    function an(de, Pe) {
      for (var be = -1, ze = de == null ? 0 : de.length; ++be < ze && Pe(de[be], be, de) !== !1; )
        ;
      return de;
    }
    function ZS(de, Pe) {
      for (var be = de == null ? 0 : de.length; be-- && Pe(de[be], be, de) !== !1; )
        ;
      return de;
    }
    function rv(de, Pe) {
      for (var be = -1, ze = de == null ? 0 : de.length; ++be < ze; )
        if (!Pe(de[be], be, de))
          return !1;
      return !0;
    }
    function qi(de, Pe) {
      for (var be = -1, ze = de == null ? 0 : de.length, ft = 0, Nt = []; ++be < ze; ) {
        var ur = de[be];
        Pe(ur, be, de) && (Nt[ft++] = ur);
      }
      return Nt;
    }
    function hc(de, Pe) {
      var be = de == null ? 0 : de.length;
      return !!be && ha(de, Pe, 0) > -1;
    }
    function Od(de, Pe, be) {
      for (var ze = -1, ft = de == null ? 0 : de.length; ++ze < ft; )
        if (be(Pe, de[ze]))
          return !0;
      return !1;
    }
    function Kt(de, Pe) {
      for (var be = -1, ze = de == null ? 0 : de.length, ft = Array(ze); ++be < ze; )
        ft[be] = Pe(de[be], be, de);
      return ft;
    }
    function Fi(de, Pe) {
      for (var be = -1, ze = Pe.length, ft = de.length; ++be < ze; )
        de[ft + be] = Pe[be];
      return de;
    }
    function Pd(de, Pe, be, ze) {
      var ft = -1, Nt = de == null ? 0 : de.length;
      for (ze && Nt && (be = de[++ft]); ++ft < Nt; )
        be = Pe(be, de[ft], ft, de);
      return be;
    }
    function zS(de, Pe, be, ze) {
      var ft = de == null ? 0 : de.length;
      for (ze && ft && (be = de[--ft]); ft--; )
        be = Pe(be, de[ft], ft, de);
      return be;
    }
    function Sd(de, Pe) {
      for (var be = -1, ze = de == null ? 0 : de.length; ++be < ze; )
        if (Pe(de[be], be, de))
          return !0;
      return !1;
    }
    var WS = Ad("length");
    function HS(de) {
      return de.split("");
    }
    function GS(de) {
      return de.match(ge) || [];
    }
    function nv(de, Pe, be) {
      var ze;
      return be(de, function(ft, Nt, ur) {
        if (Pe(ft, Nt, ur))
          return ze = Nt, !1;
      }), ze;
    }
    function mc(de, Pe, be, ze) {
      for (var ft = de.length, Nt = be + (ze ? 1 : -1); ze ? Nt-- : ++Nt < ft; )
        if (Pe(de[Nt], Nt, de))
          return Nt;
      return -1;
    }
    function ha(de, Pe, be) {
      return Pe === Pe ? aA(de, Pe, be) : mc(de, iv, be);
    }
    function KS(de, Pe, be, ze) {
      for (var ft = be - 1, Nt = de.length; ++ft < Nt; )
        if (ze(de[ft], Pe))
          return ft;
      return -1;
    }
    function iv(de) {
      return de !== de;
    }
    function sv(de, Pe) {
      var be = de == null ? 0 : de.length;
      return be ? Rd(de, Pe) / be : ie;
    }
    function Ad(de) {
      return function(Pe) {
        return Pe == null ? r : Pe[de];
      };
    }
    function Cd(de) {
      return function(Pe) {
        return de == null ? r : de[Pe];
      };
    }
    function av(de, Pe, be, ze, ft) {
      return ft(de, function(Nt, ur, Zt) {
        be = ze ? (ze = !1, Nt) : Pe(be, Nt, ur, Zt);
      }), be;
    }
    function YS(de, Pe) {
      var be = de.length;
      for (de.sort(Pe); be--; )
        de[be] = de[be].value;
      return de;
    }
    function Rd(de, Pe) {
      for (var be, ze = -1, ft = de.length; ++ze < ft; ) {
        var Nt = Pe(de[ze]);
        Nt !== r && (be = be === r ? Nt : be + Nt);
      }
      return be;
    }
    function Td(de, Pe) {
      for (var be = -1, ze = Array(de); ++be < de; )
        ze[be] = Pe(be);
      return ze;
    }
    function JS(de, Pe) {
      return Kt(Pe, function(be) {
        return [be, de[be]];
      });
    }
    function ov(de) {
      return de && de.slice(0, fv(de) + 1).replace(Di, "");
    }
    function Yr(de) {
      return function(Pe) {
        return de(Pe);
      };
    }
    function Id(de, Pe) {
      return Kt(Pe, function(be) {
        return de[be];
      });
    }
    function Ro(de, Pe) {
      return de.has(Pe);
    }
    function uv(de, Pe) {
      for (var be = -1, ze = de.length; ++be < ze && ha(Pe, de[be], 0) > -1; )
        ;
      return be;
    }
    function cv(de, Pe) {
      for (var be = de.length; be-- && ha(Pe, de[be], 0) > -1; )
        ;
      return be;
    }
    function XS(de, Pe) {
      for (var be = de.length, ze = 0; be--; )
        de[be] === Pe && ++ze;
      return ze;
    }
    var QS = Cd(NS), eA = Cd(DS);
    function tA(de) {
      return "\\" + qS[de];
    }
    function rA(de, Pe) {
      return de == null ? r : de[Pe];
    }
    function ma(de) {
      return IS.test(de);
    }
    function nA(de) {
      return jS.test(de);
    }
    function iA(de) {
      for (var Pe, be = []; !(Pe = de.next()).done; )
        be.push(Pe.value);
      return be;
    }
    function jd(de) {
      var Pe = -1, be = Array(de.size);
      return de.forEach(function(ze, ft) {
        be[++Pe] = [ft, ze];
      }), be;
    }
    function lv(de, Pe) {
      return function(be) {
        return de(Pe(be));
      };
    }
    function Ui(de, Pe) {
      for (var be = -1, ze = de.length, ft = 0, Nt = []; ++be < ze; ) {
        var ur = de[be];
        (ur === Pe || ur === d) && (de[be] = d, Nt[ft++] = be);
      }
      return Nt;
    }
    function yc(de) {
      var Pe = -1, be = Array(de.size);
      return de.forEach(function(ze) {
        be[++Pe] = ze;
      }), be;
    }
    function sA(de) {
      var Pe = -1, be = Array(de.size);
      return de.forEach(function(ze) {
        be[++Pe] = [ze, ze];
      }), be;
    }
    function aA(de, Pe, be) {
      for (var ze = be - 1, ft = de.length; ++ze < ft; )
        if (de[ze] === Pe)
          return ze;
      return -1;
    }
    function oA(de, Pe, be) {
      for (var ze = be + 1; ze--; )
        if (de[ze] === Pe)
          return ze;
      return ze;
    }
    function ya(de) {
      return ma(de) ? cA(de) : WS(de);
    }
    function _n(de) {
      return ma(de) ? lA(de) : HS(de);
    }
    function fv(de) {
      for (var Pe = de.length; Pe-- && se.test(de.charAt(Pe)); )
        ;
      return Pe;
    }
    var uA = Cd(LS);
    function cA(de) {
      for (var Pe = $d.lastIndex = 0; $d.test(de); )
        ++Pe;
      return Pe;
    }
    function lA(de) {
      return de.match($d) || [];
    }
    function fA(de) {
      return de.match(TS) || [];
    }
    var dA = function de(Pe) {
      Pe = Pe == null ? mr : ga.defaults(mr.Object(), Pe, ga.pick(mr, kS));
      var be = Pe.Array, ze = Pe.Date, ft = Pe.Error, Nt = Pe.Function, ur = Pe.Math, Zt = Pe.Object, kd = Pe.RegExp, pA = Pe.String, on = Pe.TypeError, gc = be.prototype, hA = Nt.prototype, va = Zt.prototype, vc = Pe["__core-js_shared__"], bc = hA.toString, Ft = va.hasOwnProperty, mA = 0, dv = function() {
        var o = /[^.]+$/.exec(vc && vc.keys && vc.keys.IE_PROTO || "");
        return o ? "Symbol(src)_1." + o : "";
      }(), _c = va.toString, yA = bc.call(Zt), gA = mr._, vA = kd(
        "^" + bc.call(Ft).replace(Ni, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      ), wc = K0 ? Pe.Buffer : r, Bi = Pe.Symbol, $c = Pe.Uint8Array, pv = wc ? wc.allocUnsafe : r, Ec = lv(Zt.getPrototypeOf, Zt), hv = Zt.create, mv = va.propertyIsEnumerable, xc = gc.splice, yv = Bi ? Bi.isConcatSpreadable : r, To = Bi ? Bi.iterator : r, Ss = Bi ? Bi.toStringTag : r, Oc = function() {
        try {
          var o = Is(Zt, "defineProperty");
          return o({}, "", {}), o;
        } catch {
        }
      }(), bA = Pe.clearTimeout !== mr.clearTimeout && Pe.clearTimeout, _A = ze && ze.now !== mr.Date.now && ze.now, wA = Pe.setTimeout !== mr.setTimeout && Pe.setTimeout, Pc = ur.ceil, Sc = ur.floor, Md = Zt.getOwnPropertySymbols, $A = wc ? wc.isBuffer : r, gv = Pe.isFinite, EA = gc.join, xA = lv(Zt.keys, Zt), cr = ur.max, wr = ur.min, OA = ze.now, PA = Pe.parseInt, vv = ur.random, SA = gc.reverse, Nd = Is(Pe, "DataView"), Io = Is(Pe, "Map"), Dd = Is(Pe, "Promise"), ba = Is(Pe, "Set"), jo = Is(Pe, "WeakMap"), ko = Is(Zt, "create"), Ac = jo && new jo(), _a = {}, AA = js(Nd), CA = js(Io), RA = js(Dd), TA = js(ba), IA = js(jo), Cc = Bi ? Bi.prototype : r, Mo = Cc ? Cc.valueOf : r, bv = Cc ? Cc.toString : r;
      function B(o) {
        if (Xt(o) && !pt(o) && !(o instanceof At)) {
          if (o instanceof un)
            return o;
          if (Ft.call(o, "__wrapped__"))
            return _b(o);
        }
        return new un(o);
      }
      var wa = function() {
        function o() {
        }
        return function(f) {
          if (!Yt(f))
            return {};
          if (hv)
            return hv(f);
          o.prototype = f;
          var b = new o();
          return o.prototype = r, b;
        };
      }();
      function Rc() {
      }
      function un(o, f) {
        this.__wrapped__ = o, this.__actions__ = [], this.__chain__ = !!f, this.__index__ = 0, this.__values__ = r;
      }
      B.templateSettings = {
        /**
         * Used to detect `data` property values to be HTML-escaped.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        escape: Oo,
        /**
         * Used to detect code to be evaluated.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        evaluate: la,
        /**
         * Used to detect `data` property values to inject.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        interpolate: fa,
        /**
         * Used to reference the data object in the template text.
         *
         * @memberOf _.templateSettings
         * @type {string}
         */
        variable: "",
        /**
         * Used to import variables into the compiled template.
         *
         * @memberOf _.templateSettings
         * @type {Object}
         */
        imports: {
          /**
           * A reference to the `lodash` function.
           *
           * @memberOf _.templateSettings.imports
           * @type {Function}
           */
          _: B
        }
      }, B.prototype = Rc.prototype, B.prototype.constructor = B, un.prototype = wa(Rc.prototype), un.prototype.constructor = un;
      function At(o) {
        this.__wrapped__ = o, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = K, this.__views__ = [];
      }
      function jA() {
        var o = new At(this.__wrapped__);
        return o.__actions__ = Br(this.__actions__), o.__dir__ = this.__dir__, o.__filtered__ = this.__filtered__, o.__iteratees__ = Br(this.__iteratees__), o.__takeCount__ = this.__takeCount__, o.__views__ = Br(this.__views__), o;
      }
      function kA() {
        if (this.__filtered__) {
          var o = new At(this);
          o.__dir__ = -1, o.__filtered__ = !0;
        } else
          o = this.clone(), o.__dir__ *= -1;
        return o;
      }
      function MA() {
        var o = this.__wrapped__.value(), f = this.__dir__, b = pt(o), P = f < 0, M = b ? o.length : 0, H = HC(0, M, this.__views__), ee = H.start, oe = H.end, he = oe - ee, Ce = P ? oe : ee - 1, Re = this.__iteratees__, ke = Re.length, Ue = 0, Je = wr(he, this.__takeCount__);
        if (!b || !P && M == he && Je == he)
          return Vv(o, this.__actions__);
        var it = [];
        e:
          for (; he-- && Ue < Je; ) {
            Ce += f;
            for (var bt = -1, st = o[Ce]; ++bt < ke; ) {
              var Ot = Re[bt], Rt = Ot.iteratee, Qr = Ot.type, jr = Rt(st);
              if (Qr == fe)
                st = jr;
              else if (!jr) {
                if (Qr == re)
                  continue e;
                break e;
              }
            }
            it[Ue++] = st;
          }
        return it;
      }
      At.prototype = wa(Rc.prototype), At.prototype.constructor = At;
      function As(o) {
        var f = -1, b = o == null ? 0 : o.length;
        for (this.clear(); ++f < b; ) {
          var P = o[f];
          this.set(P[0], P[1]);
        }
      }
      function NA() {
        this.__data__ = ko ? ko(null) : {}, this.size = 0;
      }
      function DA(o) {
        var f = this.has(o) && delete this.__data__[o];
        return this.size -= f ? 1 : 0, f;
      }
      function LA(o) {
        var f = this.__data__;
        if (ko) {
          var b = f[o];
          return b === c ? r : b;
        }
        return Ft.call(f, o) ? f[o] : r;
      }
      function qA(o) {
        var f = this.__data__;
        return ko ? f[o] !== r : Ft.call(f, o);
      }
      function FA(o, f) {
        var b = this.__data__;
        return this.size += this.has(o) ? 0 : 1, b[o] = ko && f === r ? c : f, this;
      }
      As.prototype.clear = NA, As.prototype.delete = DA, As.prototype.get = LA, As.prototype.has = qA, As.prototype.set = FA;
      function ci(o) {
        var f = -1, b = o == null ? 0 : o.length;
        for (this.clear(); ++f < b; ) {
          var P = o[f];
          this.set(P[0], P[1]);
        }
      }
      function UA() {
        this.__data__ = [], this.size = 0;
      }
      function BA(o) {
        var f = this.__data__, b = Tc(f, o);
        if (b < 0)
          return !1;
        var P = f.length - 1;
        return b == P ? f.pop() : xc.call(f, b, 1), --this.size, !0;
      }
      function VA(o) {
        var f = this.__data__, b = Tc(f, o);
        return b < 0 ? r : f[b][1];
      }
      function ZA(o) {
        return Tc(this.__data__, o) > -1;
      }
      function zA(o, f) {
        var b = this.__data__, P = Tc(b, o);
        return P < 0 ? (++this.size, b.push([o, f])) : b[P][1] = f, this;
      }
      ci.prototype.clear = UA, ci.prototype.delete = BA, ci.prototype.get = VA, ci.prototype.has = ZA, ci.prototype.set = zA;
      function li(o) {
        var f = -1, b = o == null ? 0 : o.length;
        for (this.clear(); ++f < b; ) {
          var P = o[f];
          this.set(P[0], P[1]);
        }
      }
      function WA() {
        this.size = 0, this.__data__ = {
          hash: new As(),
          map: new (Io || ci)(),
          string: new As()
        };
      }
      function HA(o) {
        var f = Vc(this, o).delete(o);
        return this.size -= f ? 1 : 0, f;
      }
      function GA(o) {
        return Vc(this, o).get(o);
      }
      function KA(o) {
        return Vc(this, o).has(o);
      }
      function YA(o, f) {
        var b = Vc(this, o), P = b.size;
        return b.set(o, f), this.size += b.size == P ? 0 : 1, this;
      }
      li.prototype.clear = WA, li.prototype.delete = HA, li.prototype.get = GA, li.prototype.has = KA, li.prototype.set = YA;
      function Cs(o) {
        var f = -1, b = o == null ? 0 : o.length;
        for (this.__data__ = new li(); ++f < b; )
          this.add(o[f]);
      }
      function JA(o) {
        return this.__data__.set(o, c), this;
      }
      function XA(o) {
        return this.__data__.has(o);
      }
      Cs.prototype.add = Cs.prototype.push = JA, Cs.prototype.has = XA;
      function wn(o) {
        var f = this.__data__ = new ci(o);
        this.size = f.size;
      }
      function QA() {
        this.__data__ = new ci(), this.size = 0;
      }
      function eC(o) {
        var f = this.__data__, b = f.delete(o);
        return this.size = f.size, b;
      }
      function tC(o) {
        return this.__data__.get(o);
      }
      function rC(o) {
        return this.__data__.has(o);
      }
      function nC(o, f) {
        var b = this.__data__;
        if (b instanceof ci) {
          var P = b.__data__;
          if (!Io || P.length < n - 1)
            return P.push([o, f]), this.size = ++b.size, this;
          b = this.__data__ = new li(P);
        }
        return b.set(o, f), this.size = b.size, this;
      }
      wn.prototype.clear = QA, wn.prototype.delete = eC, wn.prototype.get = tC, wn.prototype.has = rC, wn.prototype.set = nC;
      function _v(o, f) {
        var b = pt(o), P = !b && ks(o), M = !b && !P && Hi(o), H = !b && !P && !M && Oa(o), ee = b || P || M || H, oe = ee ? Td(o.length, pA) : [], he = oe.length;
        for (var Ce in o)
          (f || Ft.call(o, Ce)) && !(ee && // Safari 9 has enumerable `arguments.length` in strict mode.
          (Ce == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          M && (Ce == "offset" || Ce == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          H && (Ce == "buffer" || Ce == "byteLength" || Ce == "byteOffset") || // Skip index properties.
          hi(Ce, he))) && oe.push(Ce);
        return oe;
      }
      function wv(o) {
        var f = o.length;
        return f ? o[Gd(0, f - 1)] : r;
      }
      function iC(o, f) {
        return Zc(Br(o), Rs(f, 0, o.length));
      }
      function sC(o) {
        return Zc(Br(o));
      }
      function Ld(o, f, b) {
        (b !== r && !$n(o[f], b) || b === r && !(f in o)) && fi(o, f, b);
      }
      function No(o, f, b) {
        var P = o[f];
        (!(Ft.call(o, f) && $n(P, b)) || b === r && !(f in o)) && fi(o, f, b);
      }
      function Tc(o, f) {
        for (var b = o.length; b--; )
          if ($n(o[b][0], f))
            return b;
        return -1;
      }
      function aC(o, f, b, P) {
        return Vi(o, function(M, H, ee) {
          f(P, M, b(M), ee);
        }), P;
      }
      function $v(o, f) {
        return o && Vn(f, dr(f), o);
      }
      function oC(o, f) {
        return o && Vn(f, Zr(f), o);
      }
      function fi(o, f, b) {
        f == "__proto__" && Oc ? Oc(o, f, {
          configurable: !0,
          enumerable: !0,
          value: b,
          writable: !0
        }) : o[f] = b;
      }
      function qd(o, f) {
        for (var b = -1, P = f.length, M = be(P), H = o == null; ++b < P; )
          M[b] = H ? r : bp(o, f[b]);
        return M;
      }
      function Rs(o, f, b) {
        return o === o && (b !== r && (o = o <= b ? o : b), f !== r && (o = o >= f ? o : f)), o;
      }
      function cn(o, f, b, P, M, H) {
        var ee, oe = f & p, he = f & h, Ce = f & v;
        if (b && (ee = M ? b(o, P, M, H) : b(o)), ee !== r)
          return ee;
        if (!Yt(o))
          return o;
        var Re = pt(o);
        if (Re) {
          if (ee = KC(o), !oe)
            return Br(o, ee);
        } else {
          var ke = $r(o), Ue = ke == U || ke == pe;
          if (Hi(o))
            return Wv(o, oe);
          if (ke == Ge || ke == q || Ue && !M) {
            if (ee = he || Ue ? {} : fb(o), !oe)
              return he ? LC(o, oC(ee, o)) : DC(o, $v(ee, o));
          } else {
            if (!zt[ke])
              return M ? o : {};
            ee = YC(o, ke, oe);
          }
        }
        H || (H = new wn());
        var Je = H.get(o);
        if (Je)
          return Je;
        H.set(o, ee), Fb(o) ? o.forEach(function(st) {
          ee.add(cn(st, f, b, st, o, H));
        }) : Lb(o) && o.forEach(function(st, Ot) {
          ee.set(Ot, cn(st, f, b, Ot, o, H));
        });
        var it = Ce ? he ? sp : ip : he ? Zr : dr, bt = Re ? r : it(o);
        return an(bt || o, function(st, Ot) {
          bt && (Ot = st, st = o[Ot]), No(ee, Ot, cn(st, f, b, Ot, o, H));
        }), ee;
      }
      function uC(o) {
        var f = dr(o);
        return function(b) {
          return Ev(b, o, f);
        };
      }
      function Ev(o, f, b) {
        var P = b.length;
        if (o == null)
          return !P;
        for (o = Zt(o); P--; ) {
          var M = b[P], H = f[M], ee = o[M];
          if (ee === r && !(M in o) || !H(ee))
            return !1;
        }
        return !0;
      }
      function xv(o, f, b) {
        if (typeof o != "function")
          throw new on(a);
        return Vo(function() {
          o.apply(r, b);
        }, f);
      }
      function Do(o, f, b, P) {
        var M = -1, H = hc, ee = !0, oe = o.length, he = [], Ce = f.length;
        if (!oe)
          return he;
        b && (f = Kt(f, Yr(b))), P ? (H = Od, ee = !1) : f.length >= n && (H = Ro, ee = !1, f = new Cs(f));
        e:
          for (; ++M < oe; ) {
            var Re = o[M], ke = b == null ? Re : b(Re);
            if (Re = P || Re !== 0 ? Re : 0, ee && ke === ke) {
              for (var Ue = Ce; Ue--; )
                if (f[Ue] === ke)
                  continue e;
              he.push(Re);
            } else
              H(f, ke, P) || he.push(Re);
          }
        return he;
      }
      var Vi = Jv(Bn), Ov = Jv(Ud, !0);
      function cC(o, f) {
        var b = !0;
        return Vi(o, function(P, M, H) {
          return b = !!f(P, M, H), b;
        }), b;
      }
      function Ic(o, f, b) {
        for (var P = -1, M = o.length; ++P < M; ) {
          var H = o[P], ee = f(H);
          if (ee != null && (oe === r ? ee === ee && !Xr(ee) : b(ee, oe)))
            var oe = ee, he = H;
        }
        return he;
      }
      function lC(o, f, b, P) {
        var M = o.length;
        for (b = gt(b), b < 0 && (b = -b > M ? 0 : M + b), P = P === r || P > M ? M : gt(P), P < 0 && (P += M), P = b > P ? 0 : Bb(P); b < P; )
          o[b++] = f;
        return o;
      }
      function Pv(o, f) {
        var b = [];
        return Vi(o, function(P, M, H) {
          f(P, M, H) && b.push(P);
        }), b;
      }
      function yr(o, f, b, P, M) {
        var H = -1, ee = o.length;
        for (b || (b = XC), M || (M = []); ++H < ee; ) {
          var oe = o[H];
          f > 0 && b(oe) ? f > 1 ? yr(oe, f - 1, b, P, M) : Fi(M, oe) : P || (M[M.length] = oe);
        }
        return M;
      }
      var Fd = Xv(), Sv = Xv(!0);
      function Bn(o, f) {
        return o && Fd(o, f, dr);
      }
      function Ud(o, f) {
        return o && Sv(o, f, dr);
      }
      function jc(o, f) {
        return qi(f, function(b) {
          return mi(o[b]);
        });
      }
      function Ts(o, f) {
        f = zi(f, o);
        for (var b = 0, P = f.length; o != null && b < P; )
          o = o[Zn(f[b++])];
        return b && b == P ? o : r;
      }
      function Av(o, f, b) {
        var P = f(o);
        return pt(o) ? P : Fi(P, b(o));
      }
      function Tr(o) {
        return o == null ? o === r ? at : Fe : Ss && Ss in Zt(o) ? WC(o) : sR(o);
      }
      function Bd(o, f) {
        return o > f;
      }
      function fC(o, f) {
        return o != null && Ft.call(o, f);
      }
      function dC(o, f) {
        return o != null && f in Zt(o);
      }
      function pC(o, f, b) {
        return o >= wr(f, b) && o < cr(f, b);
      }
      function Vd(o, f, b) {
        for (var P = b ? Od : hc, M = o[0].length, H = o.length, ee = H, oe = be(H), he = 1 / 0, Ce = []; ee--; ) {
          var Re = o[ee];
          ee && f && (Re = Kt(Re, Yr(f))), he = wr(Re.length, he), oe[ee] = !b && (f || M >= 120 && Re.length >= 120) ? new Cs(ee && Re) : r;
        }
        Re = o[0];
        var ke = -1, Ue = oe[0];
        e:
          for (; ++ke < M && Ce.length < he; ) {
            var Je = Re[ke], it = f ? f(Je) : Je;
            if (Je = b || Je !== 0 ? Je : 0, !(Ue ? Ro(Ue, it) : P(Ce, it, b))) {
              for (ee = H; --ee; ) {
                var bt = oe[ee];
                if (!(bt ? Ro(bt, it) : P(o[ee], it, b)))
                  continue e;
              }
              Ue && Ue.push(it), Ce.push(Je);
            }
          }
        return Ce;
      }
      function hC(o, f, b, P) {
        return Bn(o, function(M, H, ee) {
          f(P, b(M), H, ee);
        }), P;
      }
      function Lo(o, f, b) {
        f = zi(f, o), o = mb(o, f);
        var P = o == null ? o : o[Zn(fn(f))];
        return P == null ? r : Kr(P, o, b);
      }
      function Cv(o) {
        return Xt(o) && Tr(o) == q;
      }
      function mC(o) {
        return Xt(o) && Tr(o) == L;
      }
      function yC(o) {
        return Xt(o) && Tr(o) == Z;
      }
      function qo(o, f, b, P, M) {
        return o === f ? !0 : o == null || f == null || !Xt(o) && !Xt(f) ? o !== o && f !== f : gC(o, f, b, P, qo, M);
      }
      function gC(o, f, b, P, M, H) {
        var ee = pt(o), oe = pt(f), he = ee ? N : $r(o), Ce = oe ? N : $r(f);
        he = he == q ? Ge : he, Ce = Ce == q ? Ge : Ce;
        var Re = he == Ge, ke = Ce == Ge, Ue = he == Ce;
        if (Ue && Hi(o)) {
          if (!Hi(f))
            return !1;
          ee = !0, Re = !1;
        }
        if (Ue && !Re)
          return H || (H = new wn()), ee || Oa(o) ? ub(o, f, b, P, M, H) : ZC(o, f, he, b, P, M, H);
        if (!(b & y)) {
          var Je = Re && Ft.call(o, "__wrapped__"), it = ke && Ft.call(f, "__wrapped__");
          if (Je || it) {
            var bt = Je ? o.value() : o, st = it ? f.value() : f;
            return H || (H = new wn()), M(bt, st, b, P, H);
          }
        }
        return Ue ? (H || (H = new wn()), zC(o, f, b, P, M, H)) : !1;
      }
      function vC(o) {
        return Xt(o) && $r(o) == we;
      }
      function Zd(o, f, b, P) {
        var M = b.length, H = M, ee = !P;
        if (o == null)
          return !H;
        for (o = Zt(o); M--; ) {
          var oe = b[M];
          if (ee && oe[2] ? oe[1] !== o[oe[0]] : !(oe[0] in o))
            return !1;
        }
        for (; ++M < H; ) {
          oe = b[M];
          var he = oe[0], Ce = o[he], Re = oe[1];
          if (ee && oe[2]) {
            if (Ce === r && !(he in o))
              return !1;
          } else {
            var ke = new wn();
            if (P)
              var Ue = P(Ce, Re, he, o, f, ke);
            if (!(Ue === r ? qo(Re, Ce, y | g, P, ke) : Ue))
              return !1;
          }
        }
        return !0;
      }
      function Rv(o) {
        if (!Yt(o) || eR(o))
          return !1;
        var f = mi(o) ? vA : Q;
        return f.test(js(o));
      }
      function bC(o) {
        return Xt(o) && Tr(o) == Mt;
      }
      function _C(o) {
        return Xt(o) && $r(o) == St;
      }
      function wC(o) {
        return Xt(o) && Yc(o.length) && !!Ht[Tr(o)];
      }
      function Tv(o) {
        return typeof o == "function" ? o : o == null ? zr : typeof o == "object" ? pt(o) ? kv(o[0], o[1]) : jv(o) : Qb(o);
      }
      function zd(o) {
        if (!Bo(o))
          return xA(o);
        var f = [];
        for (var b in Zt(o))
          Ft.call(o, b) && b != "constructor" && f.push(b);
        return f;
      }
      function $C(o) {
        if (!Yt(o))
          return iR(o);
        var f = Bo(o), b = [];
        for (var P in o)
          P == "constructor" && (f || !Ft.call(o, P)) || b.push(P);
        return b;
      }
      function Wd(o, f) {
        return o < f;
      }
      function Iv(o, f) {
        var b = -1, P = Vr(o) ? be(o.length) : [];
        return Vi(o, function(M, H, ee) {
          P[++b] = f(M, H, ee);
        }), P;
      }
      function jv(o) {
        var f = op(o);
        return f.length == 1 && f[0][2] ? pb(f[0][0], f[0][1]) : function(b) {
          return b === o || Zd(b, o, f);
        };
      }
      function kv(o, f) {
        return cp(o) && db(f) ? pb(Zn(o), f) : function(b) {
          var P = bp(b, o);
          return P === r && P === f ? _p(b, o) : qo(f, P, y | g);
        };
      }
      function kc(o, f, b, P, M) {
        o !== f && Fd(f, function(H, ee) {
          if (M || (M = new wn()), Yt(H))
            EC(o, f, ee, b, kc, P, M);
          else {
            var oe = P ? P(fp(o, ee), H, ee + "", o, f, M) : r;
            oe === r && (oe = H), Ld(o, ee, oe);
          }
        }, Zr);
      }
      function EC(o, f, b, P, M, H, ee) {
        var oe = fp(o, b), he = fp(f, b), Ce = ee.get(he);
        if (Ce) {
          Ld(o, b, Ce);
          return;
        }
        var Re = H ? H(oe, he, b + "", o, f, ee) : r, ke = Re === r;
        if (ke) {
          var Ue = pt(he), Je = !Ue && Hi(he), it = !Ue && !Je && Oa(he);
          Re = he, Ue || Je || it ? pt(oe) ? Re = oe : er(oe) ? Re = Br(oe) : Je ? (ke = !1, Re = Wv(he, !0)) : it ? (ke = !1, Re = Hv(he, !0)) : Re = [] : Zo(he) || ks(he) ? (Re = oe, ks(oe) ? Re = Vb(oe) : (!Yt(oe) || mi(oe)) && (Re = fb(he))) : ke = !1;
        }
        ke && (ee.set(he, Re), M(Re, he, P, H, ee), ee.delete(he)), Ld(o, b, Re);
      }
      function Mv(o, f) {
        var b = o.length;
        if (b)
          return f += f < 0 ? b : 0, hi(f, b) ? o[f] : r;
      }
      function Nv(o, f, b) {
        f.length ? f = Kt(f, function(H) {
          return pt(H) ? function(ee) {
            return Ts(ee, H.length === 1 ? H[0] : H);
          } : H;
        }) : f = [zr];
        var P = -1;
        f = Kt(f, Yr(nt()));
        var M = Iv(o, function(H, ee, oe) {
          var he = Kt(f, function(Ce) {
            return Ce(H);
          });
          return { criteria: he, index: ++P, value: H };
        });
        return YS(M, function(H, ee) {
          return NC(H, ee, b);
        });
      }
      function xC(o, f) {
        return Dv(o, f, function(b, P) {
          return _p(o, P);
        });
      }
      function Dv(o, f, b) {
        for (var P = -1, M = f.length, H = {}; ++P < M; ) {
          var ee = f[P], oe = Ts(o, ee);
          b(oe, ee) && Fo(H, zi(ee, o), oe);
        }
        return H;
      }
      function OC(o) {
        return function(f) {
          return Ts(f, o);
        };
      }
      function Hd(o, f, b, P) {
        var M = P ? KS : ha, H = -1, ee = f.length, oe = o;
        for (o === f && (f = Br(f)), b && (oe = Kt(o, Yr(b))); ++H < ee; )
          for (var he = 0, Ce = f[H], Re = b ? b(Ce) : Ce; (he = M(oe, Re, he, P)) > -1; )
            oe !== o && xc.call(oe, he, 1), xc.call(o, he, 1);
        return o;
      }
      function Lv(o, f) {
        for (var b = o ? f.length : 0, P = b - 1; b--; ) {
          var M = f[b];
          if (b == P || M !== H) {
            var H = M;
            hi(M) ? xc.call(o, M, 1) : Jd(o, M);
          }
        }
        return o;
      }
      function Gd(o, f) {
        return o + Sc(vv() * (f - o + 1));
      }
      function PC(o, f, b, P) {
        for (var M = -1, H = cr(Pc((f - o) / (b || 1)), 0), ee = be(H); H--; )
          ee[P ? H : ++M] = o, o += b;
        return ee;
      }
      function Kd(o, f) {
        var b = "";
        if (!o || f < 1 || f > Ae)
          return b;
        do
          f % 2 && (b += o), f = Sc(f / 2), f && (o += o);
        while (f);
        return b;
      }
      function $t(o, f) {
        return dp(hb(o, f, zr), o + "");
      }
      function SC(o) {
        return wv(Pa(o));
      }
      function AC(o, f) {
        var b = Pa(o);
        return Zc(b, Rs(f, 0, b.length));
      }
      function Fo(o, f, b, P) {
        if (!Yt(o))
          return o;
        f = zi(f, o);
        for (var M = -1, H = f.length, ee = H - 1, oe = o; oe != null && ++M < H; ) {
          var he = Zn(f[M]), Ce = b;
          if (he === "__proto__" || he === "constructor" || he === "prototype")
            return o;
          if (M != ee) {
            var Re = oe[he];
            Ce = P ? P(Re, he, oe) : r, Ce === r && (Ce = Yt(Re) ? Re : hi(f[M + 1]) ? [] : {});
          }
          No(oe, he, Ce), oe = oe[he];
        }
        return o;
      }
      var qv = Ac ? function(o, f) {
        return Ac.set(o, f), o;
      } : zr, CC = Oc ? function(o, f) {
        return Oc(o, "toString", {
          configurable: !0,
          enumerable: !1,
          value: $p(f),
          writable: !0
        });
      } : zr;
      function RC(o) {
        return Zc(Pa(o));
      }
      function ln(o, f, b) {
        var P = -1, M = o.length;
        f < 0 && (f = -f > M ? 0 : M + f), b = b > M ? M : b, b < 0 && (b += M), M = f > b ? 0 : b - f >>> 0, f >>>= 0;
        for (var H = be(M); ++P < M; )
          H[P] = o[P + f];
        return H;
      }
      function TC(o, f) {
        var b;
        return Vi(o, function(P, M, H) {
          return b = f(P, M, H), !b;
        }), !!b;
      }
      function Mc(o, f, b) {
        var P = 0, M = o == null ? P : o.length;
        if (typeof f == "number" && f === f && M <= z) {
          for (; P < M; ) {
            var H = P + M >>> 1, ee = o[H];
            ee !== null && !Xr(ee) && (b ? ee <= f : ee < f) ? P = H + 1 : M = H;
          }
          return M;
        }
        return Yd(o, f, zr, b);
      }
      function Yd(o, f, b, P) {
        var M = 0, H = o == null ? 0 : o.length;
        if (H === 0)
          return 0;
        f = b(f);
        for (var ee = f !== f, oe = f === null, he = Xr(f), Ce = f === r; M < H; ) {
          var Re = Sc((M + H) / 2), ke = b(o[Re]), Ue = ke !== r, Je = ke === null, it = ke === ke, bt = Xr(ke);
          if (ee)
            var st = P || it;
          else
            Ce ? st = it && (P || Ue) : oe ? st = it && Ue && (P || !Je) : he ? st = it && Ue && !Je && (P || !bt) : Je || bt ? st = !1 : st = P ? ke <= f : ke < f;
          st ? M = Re + 1 : H = Re;
        }
        return wr(H, V);
      }
      function Fv(o, f) {
        for (var b = -1, P = o.length, M = 0, H = []; ++b < P; ) {
          var ee = o[b], oe = f ? f(ee) : ee;
          if (!b || !$n(oe, he)) {
            var he = oe;
            H[M++] = ee === 0 ? 0 : ee;
          }
        }
        return H;
      }
      function Uv(o) {
        return typeof o == "number" ? o : Xr(o) ? ie : +o;
      }
      function Jr(o) {
        if (typeof o == "string")
          return o;
        if (pt(o))
          return Kt(o, Jr) + "";
        if (Xr(o))
          return bv ? bv.call(o) : "";
        var f = o + "";
        return f == "0" && 1 / o == -$e ? "-0" : f;
      }
      function Zi(o, f, b) {
        var P = -1, M = hc, H = o.length, ee = !0, oe = [], he = oe;
        if (b)
          ee = !1, M = Od;
        else if (H >= n) {
          var Ce = f ? null : BC(o);
          if (Ce)
            return yc(Ce);
          ee = !1, M = Ro, he = new Cs();
        } else
          he = f ? [] : oe;
        e:
          for (; ++P < H; ) {
            var Re = o[P], ke = f ? f(Re) : Re;
            if (Re = b || Re !== 0 ? Re : 0, ee && ke === ke) {
              for (var Ue = he.length; Ue--; )
                if (he[Ue] === ke)
                  continue e;
              f && he.push(ke), oe.push(Re);
            } else
              M(he, ke, b) || (he !== oe && he.push(ke), oe.push(Re));
          }
        return oe;
      }
      function Jd(o, f) {
        return f = zi(f, o), o = mb(o, f), o == null || delete o[Zn(fn(f))];
      }
      function Bv(o, f, b, P) {
        return Fo(o, f, b(Ts(o, f)), P);
      }
      function Nc(o, f, b, P) {
        for (var M = o.length, H = P ? M : -1; (P ? H-- : ++H < M) && f(o[H], H, o); )
          ;
        return b ? ln(o, P ? 0 : H, P ? H + 1 : M) : ln(o, P ? H + 1 : 0, P ? M : H);
      }
      function Vv(o, f) {
        var b = o;
        return b instanceof At && (b = b.value()), Pd(f, function(P, M) {
          return M.func.apply(M.thisArg, Fi([P], M.args));
        }, b);
      }
      function Xd(o, f, b) {
        var P = o.length;
        if (P < 2)
          return P ? Zi(o[0]) : [];
        for (var M = -1, H = be(P); ++M < P; )
          for (var ee = o[M], oe = -1; ++oe < P; )
            oe != M && (H[M] = Do(H[M] || ee, o[oe], f, b));
        return Zi(yr(H, 1), f, b);
      }
      function Zv(o, f, b) {
        for (var P = -1, M = o.length, H = f.length, ee = {}; ++P < M; ) {
          var oe = P < H ? f[P] : r;
          b(ee, o[P], oe);
        }
        return ee;
      }
      function Qd(o) {
        return er(o) ? o : [];
      }
      function ep(o) {
        return typeof o == "function" ? o : zr;
      }
      function zi(o, f) {
        return pt(o) ? o : cp(o, f) ? [o] : bb(qt(o));
      }
      var IC = $t;
      function Wi(o, f, b) {
        var P = o.length;
        return b = b === r ? P : b, !f && b >= P ? o : ln(o, f, b);
      }
      var zv = bA || function(o) {
        return mr.clearTimeout(o);
      };
      function Wv(o, f) {
        if (f)
          return o.slice();
        var b = o.length, P = pv ? pv(b) : new o.constructor(b);
        return o.copy(P), P;
      }
      function tp(o) {
        var f = new o.constructor(o.byteLength);
        return new $c(f).set(new $c(o)), f;
      }
      function jC(o, f) {
        var b = f ? tp(o.buffer) : o.buffer;
        return new o.constructor(b, o.byteOffset, o.byteLength);
      }
      function kC(o) {
        var f = new o.constructor(o.source, Lt.exec(o));
        return f.lastIndex = o.lastIndex, f;
      }
      function MC(o) {
        return Mo ? Zt(Mo.call(o)) : {};
      }
      function Hv(o, f) {
        var b = f ? tp(o.buffer) : o.buffer;
        return new o.constructor(b, o.byteOffset, o.length);
      }
      function Gv(o, f) {
        if (o !== f) {
          var b = o !== r, P = o === null, M = o === o, H = Xr(o), ee = f !== r, oe = f === null, he = f === f, Ce = Xr(f);
          if (!oe && !Ce && !H && o > f || H && ee && he && !oe && !Ce || P && ee && he || !b && he || !M)
            return 1;
          if (!P && !H && !Ce && o < f || Ce && b && M && !P && !H || oe && b && M || !ee && M || !he)
            return -1;
        }
        return 0;
      }
      function NC(o, f, b) {
        for (var P = -1, M = o.criteria, H = f.criteria, ee = M.length, oe = b.length; ++P < ee; ) {
          var he = Gv(M[P], H[P]);
          if (he) {
            if (P >= oe)
              return he;
            var Ce = b[P];
            return he * (Ce == "desc" ? -1 : 1);
          }
        }
        return o.index - f.index;
      }
      function Kv(o, f, b, P) {
        for (var M = -1, H = o.length, ee = b.length, oe = -1, he = f.length, Ce = cr(H - ee, 0), Re = be(he + Ce), ke = !P; ++oe < he; )
          Re[oe] = f[oe];
        for (; ++M < ee; )
          (ke || M < H) && (Re[b[M]] = o[M]);
        for (; Ce--; )
          Re[oe++] = o[M++];
        return Re;
      }
      function Yv(o, f, b, P) {
        for (var M = -1, H = o.length, ee = -1, oe = b.length, he = -1, Ce = f.length, Re = cr(H - oe, 0), ke = be(Re + Ce), Ue = !P; ++M < Re; )
          ke[M] = o[M];
        for (var Je = M; ++he < Ce; )
          ke[Je + he] = f[he];
        for (; ++ee < oe; )
          (Ue || M < H) && (ke[Je + b[ee]] = o[M++]);
        return ke;
      }
      function Br(o, f) {
        var b = -1, P = o.length;
        for (f || (f = be(P)); ++b < P; )
          f[b] = o[b];
        return f;
      }
      function Vn(o, f, b, P) {
        var M = !b;
        b || (b = {});
        for (var H = -1, ee = f.length; ++H < ee; ) {
          var oe = f[H], he = P ? P(b[oe], o[oe], oe, b, o) : r;
          he === r && (he = o[oe]), M ? fi(b, oe, he) : No(b, oe, he);
        }
        return b;
      }
      function DC(o, f) {
        return Vn(o, up(o), f);
      }
      function LC(o, f) {
        return Vn(o, cb(o), f);
      }
      function Dc(o, f) {
        return function(b, P) {
          var M = pt(b) ? VS : aC, H = f ? f() : {};
          return M(b, o, nt(P, 2), H);
        };
      }
      function $a(o) {
        return $t(function(f, b) {
          var P = -1, M = b.length, H = M > 1 ? b[M - 1] : r, ee = M > 2 ? b[2] : r;
          for (H = o.length > 3 && typeof H == "function" ? (M--, H) : r, ee && Ir(b[0], b[1], ee) && (H = M < 3 ? r : H, M = 1), f = Zt(f); ++P < M; ) {
            var oe = b[P];
            oe && o(f, oe, P, H);
          }
          return f;
        });
      }
      function Jv(o, f) {
        return function(b, P) {
          if (b == null)
            return b;
          if (!Vr(b))
            return o(b, P);
          for (var M = b.length, H = f ? M : -1, ee = Zt(b); (f ? H-- : ++H < M) && P(ee[H], H, ee) !== !1; )
            ;
          return b;
        };
      }
      function Xv(o) {
        return function(f, b, P) {
          for (var M = -1, H = Zt(f), ee = P(f), oe = ee.length; oe--; ) {
            var he = ee[o ? oe : ++M];
            if (b(H[he], he, H) === !1)
              break;
          }
          return f;
        };
      }
      function qC(o, f, b) {
        var P = f & _, M = Uo(o);
        function H() {
          var ee = this && this !== mr && this instanceof H ? M : o;
          return ee.apply(P ? b : this, arguments);
        }
        return H;
      }
      function Qv(o) {
        return function(f) {
          f = qt(f);
          var b = ma(f) ? _n(f) : r, P = b ? b[0] : f.charAt(0), M = b ? Wi(b, 1).join("") : f.slice(1);
          return P[o]() + M;
        };
      }
      function Ea(o) {
        return function(f) {
          return Pd(Jb(Yb(f).replace(CS, "")), o, "");
        };
      }
      function Uo(o) {
        return function() {
          var f = arguments;
          switch (f.length) {
            case 0:
              return new o();
            case 1:
              return new o(f[0]);
            case 2:
              return new o(f[0], f[1]);
            case 3:
              return new o(f[0], f[1], f[2]);
            case 4:
              return new o(f[0], f[1], f[2], f[3]);
            case 5:
              return new o(f[0], f[1], f[2], f[3], f[4]);
            case 6:
              return new o(f[0], f[1], f[2], f[3], f[4], f[5]);
            case 7:
              return new o(f[0], f[1], f[2], f[3], f[4], f[5], f[6]);
          }
          var b = wa(o.prototype), P = o.apply(b, f);
          return Yt(P) ? P : b;
        };
      }
      function FC(o, f, b) {
        var P = Uo(o);
        function M() {
          for (var H = arguments.length, ee = be(H), oe = H, he = xa(M); oe--; )
            ee[oe] = arguments[oe];
          var Ce = H < 3 && ee[0] !== he && ee[H - 1] !== he ? [] : Ui(ee, he);
          if (H -= Ce.length, H < b)
            return ib(
              o,
              f,
              Lc,
              M.placeholder,
              r,
              ee,
              Ce,
              r,
              r,
              b - H
            );
          var Re = this && this !== mr && this instanceof M ? P : o;
          return Kr(Re, this, ee);
        }
        return M;
      }
      function eb(o) {
        return function(f, b, P) {
          var M = Zt(f);
          if (!Vr(f)) {
            var H = nt(b, 3);
            f = dr(f), b = function(oe) {
              return H(M[oe], oe, M);
            };
          }
          var ee = o(f, b, P);
          return ee > -1 ? M[H ? f[ee] : ee] : r;
        };
      }
      function tb(o) {
        return pi(function(f) {
          var b = f.length, P = b, M = un.prototype.thru;
          for (o && f.reverse(); P--; ) {
            var H = f[P];
            if (typeof H != "function")
              throw new on(a);
            if (M && !ee && Bc(H) == "wrapper")
              var ee = new un([], !0);
          }
          for (P = ee ? P : b; ++P < b; ) {
            H = f[P];
            var oe = Bc(H), he = oe == "wrapper" ? ap(H) : r;
            he && lp(he[0]) && he[1] == (I | $ | A | D) && !he[4].length && he[9] == 1 ? ee = ee[Bc(he[0])].apply(ee, he[3]) : ee = H.length == 1 && lp(H) ? ee[oe]() : ee.thru(H);
          }
          return function() {
            var Ce = arguments, Re = Ce[0];
            if (ee && Ce.length == 1 && pt(Re))
              return ee.plant(Re).value();
            for (var ke = 0, Ue = b ? f[ke].apply(this, Ce) : Re; ++ke < b; )
              Ue = f[ke].call(this, Ue);
            return Ue;
          };
        });
      }
      function Lc(o, f, b, P, M, H, ee, oe, he, Ce) {
        var Re = f & I, ke = f & _, Ue = f & m, Je = f & ($ | E), it = f & J, bt = Ue ? r : Uo(o);
        function st() {
          for (var Ot = arguments.length, Rt = be(Ot), Qr = Ot; Qr--; )
            Rt[Qr] = arguments[Qr];
          if (Je)
            var jr = xa(st), en = XS(Rt, jr);
          if (P && (Rt = Kv(Rt, P, M, Je)), H && (Rt = Yv(Rt, H, ee, Je)), Ot -= en, Je && Ot < Ce) {
            var tr = Ui(Rt, jr);
            return ib(
              o,
              f,
              Lc,
              st.placeholder,
              b,
              Rt,
              tr,
              oe,
              he,
              Ce - Ot
            );
          }
          var En = ke ? b : this, gi = Ue ? En[o] : o;
          return Ot = Rt.length, oe ? Rt = aR(Rt, oe) : it && Ot > 1 && Rt.reverse(), Re && he < Ot && (Rt.length = he), this && this !== mr && this instanceof st && (gi = bt || Uo(gi)), gi.apply(En, Rt);
        }
        return st;
      }
      function rb(o, f) {
        return function(b, P) {
          return hC(b, o, f(P), {});
        };
      }
      function qc(o, f) {
        return function(b, P) {
          var M;
          if (b === r && P === r)
            return f;
          if (b !== r && (M = b), P !== r) {
            if (M === r)
              return P;
            typeof b == "string" || typeof P == "string" ? (b = Jr(b), P = Jr(P)) : (b = Uv(b), P = Uv(P)), M = o(b, P);
          }
          return M;
        };
      }
      function rp(o) {
        return pi(function(f) {
          return f = Kt(f, Yr(nt())), $t(function(b) {
            var P = this;
            return o(f, function(M) {
              return Kr(M, P, b);
            });
          });
        });
      }
      function Fc(o, f) {
        f = f === r ? " " : Jr(f);
        var b = f.length;
        if (b < 2)
          return b ? Kd(f, o) : f;
        var P = Kd(f, Pc(o / ya(f)));
        return ma(f) ? Wi(_n(P), 0, o).join("") : P.slice(0, o);
      }
      function UC(o, f, b, P) {
        var M = f & _, H = Uo(o);
        function ee() {
          for (var oe = -1, he = arguments.length, Ce = -1, Re = P.length, ke = be(Re + he), Ue = this && this !== mr && this instanceof ee ? H : o; ++Ce < Re; )
            ke[Ce] = P[Ce];
          for (; he--; )
            ke[Ce++] = arguments[++oe];
          return Kr(Ue, M ? b : this, ke);
        }
        return ee;
      }
      function nb(o) {
        return function(f, b, P) {
          return P && typeof P != "number" && Ir(f, b, P) && (b = P = r), f = yi(f), b === r ? (b = f, f = 0) : b = yi(b), P = P === r ? f < b ? 1 : -1 : yi(P), PC(f, b, P, o);
        };
      }
      function Uc(o) {
        return function(f, b) {
          return typeof f == "string" && typeof b == "string" || (f = dn(f), b = dn(b)), o(f, b);
        };
      }
      function ib(o, f, b, P, M, H, ee, oe, he, Ce) {
        var Re = f & $, ke = Re ? ee : r, Ue = Re ? r : ee, Je = Re ? H : r, it = Re ? r : H;
        f |= Re ? A : R, f &= ~(Re ? R : A), f & w || (f &= ~(_ | m));
        var bt = [
          o,
          f,
          M,
          Je,
          ke,
          it,
          Ue,
          oe,
          he,
          Ce
        ], st = b.apply(r, bt);
        return lp(o) && yb(st, bt), st.placeholder = P, gb(st, o, f);
      }
      function np(o) {
        var f = ur[o];
        return function(b, P) {
          if (b = dn(b), P = P == null ? 0 : wr(gt(P), 292), P && gv(b)) {
            var M = (qt(b) + "e").split("e"), H = f(M[0] + "e" + (+M[1] + P));
            return M = (qt(H) + "e").split("e"), +(M[0] + "e" + (+M[1] - P));
          }
          return f(b);
        };
      }
      var BC = ba && 1 / yc(new ba([, -0]))[1] == $e ? function(o) {
        return new ba(o);
      } : Op;
      function sb(o) {
        return function(f) {
          var b = $r(f);
          return b == we ? jd(f) : b == St ? sA(f) : JS(f, o(f));
        };
      }
      function di(o, f, b, P, M, H, ee, oe) {
        var he = f & m;
        if (!he && typeof o != "function")
          throw new on(a);
        var Ce = P ? P.length : 0;
        if (Ce || (f &= ~(A | R), P = M = r), ee = ee === r ? ee : cr(gt(ee), 0), oe = oe === r ? oe : gt(oe), Ce -= M ? M.length : 0, f & R) {
          var Re = P, ke = M;
          P = M = r;
        }
        var Ue = he ? r : ap(o), Je = [
          o,
          f,
          b,
          P,
          M,
          Re,
          ke,
          H,
          ee,
          oe
        ];
        if (Ue && nR(Je, Ue), o = Je[0], f = Je[1], b = Je[2], P = Je[3], M = Je[4], oe = Je[9] = Je[9] === r ? he ? 0 : o.length : cr(Je[9] - Ce, 0), !oe && f & ($ | E) && (f &= ~($ | E)), !f || f == _)
          var it = qC(o, f, b);
        else
          f == $ || f == E ? it = FC(o, f, oe) : (f == A || f == (_ | A)) && !M.length ? it = UC(o, f, b, P) : it = Lc.apply(r, Je);
        var bt = Ue ? qv : yb;
        return gb(bt(it, Je), o, f);
      }
      function ab(o, f, b, P) {
        return o === r || $n(o, va[b]) && !Ft.call(P, b) ? f : o;
      }
      function ob(o, f, b, P, M, H) {
        return Yt(o) && Yt(f) && (H.set(f, o), kc(o, f, r, ob, H), H.delete(f)), o;
      }
      function VC(o) {
        return Zo(o) ? r : o;
      }
      function ub(o, f, b, P, M, H) {
        var ee = b & y, oe = o.length, he = f.length;
        if (oe != he && !(ee && he > oe))
          return !1;
        var Ce = H.get(o), Re = H.get(f);
        if (Ce && Re)
          return Ce == f && Re == o;
        var ke = -1, Ue = !0, Je = b & g ? new Cs() : r;
        for (H.set(o, f), H.set(f, o); ++ke < oe; ) {
          var it = o[ke], bt = f[ke];
          if (P)
            var st = ee ? P(bt, it, ke, f, o, H) : P(it, bt, ke, o, f, H);
          if (st !== r) {
            if (st)
              continue;
            Ue = !1;
            break;
          }
          if (Je) {
            if (!Sd(f, function(Ot, Rt) {
              if (!Ro(Je, Rt) && (it === Ot || M(it, Ot, b, P, H)))
                return Je.push(Rt);
            })) {
              Ue = !1;
              break;
            }
          } else if (!(it === bt || M(it, bt, b, P, H))) {
            Ue = !1;
            break;
          }
        }
        return H.delete(o), H.delete(f), Ue;
      }
      function ZC(o, f, b, P, M, H, ee) {
        switch (b) {
          case x:
            if (o.byteLength != f.byteLength || o.byteOffset != f.byteOffset)
              return !1;
            o = o.buffer, f = f.buffer;
          case L:
            return !(o.byteLength != f.byteLength || !H(new $c(o), new $c(f)));
          case T:
          case Z:
          case He:
            return $n(+o, +f);
          case k:
            return o.name == f.name && o.message == f.message;
          case Mt:
          case Ne:
            return o == f + "";
          case we:
            var oe = jd;
          case St:
            var he = P & y;
            if (oe || (oe = yc), o.size != f.size && !he)
              return !1;
            var Ce = ee.get(o);
            if (Ce)
              return Ce == f;
            P |= g, ee.set(o, f);
            var Re = ub(oe(o), oe(f), P, M, H, ee);
            return ee.delete(o), Re;
          case Le:
            if (Mo)
              return Mo.call(o) == Mo.call(f);
        }
        return !1;
      }
      function zC(o, f, b, P, M, H) {
        var ee = b & y, oe = ip(o), he = oe.length, Ce = ip(f), Re = Ce.length;
        if (he != Re && !ee)
          return !1;
        for (var ke = he; ke--; ) {
          var Ue = oe[ke];
          if (!(ee ? Ue in f : Ft.call(f, Ue)))
            return !1;
        }
        var Je = H.get(o), it = H.get(f);
        if (Je && it)
          return Je == f && it == o;
        var bt = !0;
        H.set(o, f), H.set(f, o);
        for (var st = ee; ++ke < he; ) {
          Ue = oe[ke];
          var Ot = o[Ue], Rt = f[Ue];
          if (P)
            var Qr = ee ? P(Rt, Ot, Ue, f, o, H) : P(Ot, Rt, Ue, o, f, H);
          if (!(Qr === r ? Ot === Rt || M(Ot, Rt, b, P, H) : Qr)) {
            bt = !1;
            break;
          }
          st || (st = Ue == "constructor");
        }
        if (bt && !st) {
          var jr = o.constructor, en = f.constructor;
          jr != en && "constructor" in o && "constructor" in f && !(typeof jr == "function" && jr instanceof jr && typeof en == "function" && en instanceof en) && (bt = !1);
        }
        return H.delete(o), H.delete(f), bt;
      }
      function pi(o) {
        return dp(hb(o, r, Eb), o + "");
      }
      function ip(o) {
        return Av(o, dr, up);
      }
      function sp(o) {
        return Av(o, Zr, cb);
      }
      var ap = Ac ? function(o) {
        return Ac.get(o);
      } : Op;
      function Bc(o) {
        for (var f = o.name + "", b = _a[f], P = Ft.call(_a, f) ? b.length : 0; P--; ) {
          var M = b[P], H = M.func;
          if (H == null || H == o)
            return M.name;
        }
        return f;
      }
      function xa(o) {
        var f = Ft.call(B, "placeholder") ? B : o;
        return f.placeholder;
      }
      function nt() {
        var o = B.iteratee || Ep;
        return o = o === Ep ? Tv : o, arguments.length ? o(arguments[0], arguments[1]) : o;
      }
      function Vc(o, f) {
        var b = o.__data__;
        return QC(f) ? b[typeof f == "string" ? "string" : "hash"] : b.map;
      }
      function op(o) {
        for (var f = dr(o), b = f.length; b--; ) {
          var P = f[b], M = o[P];
          f[b] = [P, M, db(M)];
        }
        return f;
      }
      function Is(o, f) {
        var b = rA(o, f);
        return Rv(b) ? b : r;
      }
      function WC(o) {
        var f = Ft.call(o, Ss), b = o[Ss];
        try {
          o[Ss] = r;
          var P = !0;
        } catch {
        }
        var M = _c.call(o);
        return P && (f ? o[Ss] = b : delete o[Ss]), M;
      }
      var up = Md ? function(o) {
        return o == null ? [] : (o = Zt(o), qi(Md(o), function(f) {
          return mv.call(o, f);
        }));
      } : Pp, cb = Md ? function(o) {
        for (var f = []; o; )
          Fi(f, up(o)), o = Ec(o);
        return f;
      } : Pp, $r = Tr;
      (Nd && $r(new Nd(new ArrayBuffer(1))) != x || Io && $r(new Io()) != we || Dd && $r(Dd.resolve()) != jt || ba && $r(new ba()) != St || jo && $r(new jo()) != mt) && ($r = function(o) {
        var f = Tr(o), b = f == Ge ? o.constructor : r, P = b ? js(b) : "";
        if (P)
          switch (P) {
            case AA:
              return x;
            case CA:
              return we;
            case RA:
              return jt;
            case TA:
              return St;
            case IA:
              return mt;
          }
        return f;
      });
      function HC(o, f, b) {
        for (var P = -1, M = b.length; ++P < M; ) {
          var H = b[P], ee = H.size;
          switch (H.type) {
            case "drop":
              o += ee;
              break;
            case "dropRight":
              f -= ee;
              break;
            case "take":
              f = wr(f, o + ee);
              break;
            case "takeRight":
              o = cr(o, f - ee);
              break;
          }
        }
        return { start: o, end: f };
      }
      function GC(o) {
        var f = o.match(ue);
        return f ? f[1].split(ve) : [];
      }
      function lb(o, f, b) {
        f = zi(f, o);
        for (var P = -1, M = f.length, H = !1; ++P < M; ) {
          var ee = Zn(f[P]);
          if (!(H = o != null && b(o, ee)))
            break;
          o = o[ee];
        }
        return H || ++P != M ? H : (M = o == null ? 0 : o.length, !!M && Yc(M) && hi(ee, M) && (pt(o) || ks(o)));
      }
      function KC(o) {
        var f = o.length, b = new o.constructor(f);
        return f && typeof o[0] == "string" && Ft.call(o, "index") && (b.index = o.index, b.input = o.input), b;
      }
      function fb(o) {
        return typeof o.constructor == "function" && !Bo(o) ? wa(Ec(o)) : {};
      }
      function YC(o, f, b) {
        var P = o.constructor;
        switch (f) {
          case L:
            return tp(o);
          case T:
          case Z:
            return new P(+o);
          case x:
            return jC(o, b);
          case S:
          case G:
          case ce:
          case me:
          case Oe:
          case ut:
          case Dt:
          case Tt:
          case wt:
            return Hv(o, b);
          case we:
            return new P();
          case He:
          case Ne:
            return new P(o);
          case Mt:
            return kC(o);
          case St:
            return new P();
          case Le:
            return MC(o);
        }
      }
      function JC(o, f) {
        var b = f.length;
        if (!b)
          return o;
        var P = b - 1;
        return f[P] = (b > 1 ? "& " : "") + f[P], f = f.join(b > 2 ? ", " : " "), o.replace(X, `{
/* [wrapped with ` + f + `] */
`);
      }
      function XC(o) {
        return pt(o) || ks(o) || !!(yv && o && o[yv]);
      }
      function hi(o, f) {
        var b = typeof o;
        return f = f ?? Ae, !!f && (b == "number" || b != "symbol" && j.test(o)) && o > -1 && o % 1 == 0 && o < f;
      }
      function Ir(o, f, b) {
        if (!Yt(b))
          return !1;
        var P = typeof f;
        return (P == "number" ? Vr(b) && hi(f, b.length) : P == "string" && f in b) ? $n(b[f], o) : !1;
      }
      function cp(o, f) {
        if (pt(o))
          return !1;
        var b = typeof o;
        return b == "number" || b == "symbol" || b == "boolean" || o == null || Xr(o) ? !0 : da.test(o) || !$s.test(o) || f != null && o in Zt(f);
      }
      function QC(o) {
        var f = typeof o;
        return f == "string" || f == "number" || f == "symbol" || f == "boolean" ? o !== "__proto__" : o === null;
      }
      function lp(o) {
        var f = Bc(o), b = B[f];
        if (typeof b != "function" || !(f in At.prototype))
          return !1;
        if (o === b)
          return !0;
        var P = ap(b);
        return !!P && o === P[0];
      }
      function eR(o) {
        return !!dv && dv in o;
      }
      var tR = vc ? mi : Sp;
      function Bo(o) {
        var f = o && o.constructor, b = typeof f == "function" && f.prototype || va;
        return o === b;
      }
      function db(o) {
        return o === o && !Yt(o);
      }
      function pb(o, f) {
        return function(b) {
          return b == null ? !1 : b[o] === f && (f !== r || o in Zt(b));
        };
      }
      function rR(o) {
        var f = Gc(o, function(P) {
          return b.size === l && b.clear(), P;
        }), b = f.cache;
        return f;
      }
      function nR(o, f) {
        var b = o[1], P = f[1], M = b | P, H = M < (_ | m | I), ee = P == I && b == $ || P == I && b == D && o[7].length <= f[8] || P == (I | D) && f[7].length <= f[8] && b == $;
        if (!(H || ee))
          return o;
        P & _ && (o[2] = f[2], M |= b & _ ? 0 : w);
        var oe = f[3];
        if (oe) {
          var he = o[3];
          o[3] = he ? Kv(he, oe, f[4]) : oe, o[4] = he ? Ui(o[3], d) : f[4];
        }
        return oe = f[5], oe && (he = o[5], o[5] = he ? Yv(he, oe, f[6]) : oe, o[6] = he ? Ui(o[5], d) : f[6]), oe = f[7], oe && (o[7] = oe), P & I && (o[8] = o[8] == null ? f[8] : wr(o[8], f[8])), o[9] == null && (o[9] = f[9]), o[0] = f[0], o[1] = M, o;
      }
      function iR(o) {
        var f = [];
        if (o != null)
          for (var b in Zt(o))
            f.push(b);
        return f;
      }
      function sR(o) {
        return _c.call(o);
      }
      function hb(o, f, b) {
        return f = cr(f === r ? o.length - 1 : f, 0), function() {
          for (var P = arguments, M = -1, H = cr(P.length - f, 0), ee = be(H); ++M < H; )
            ee[M] = P[f + M];
          M = -1;
          for (var oe = be(f + 1); ++M < f; )
            oe[M] = P[M];
          return oe[f] = b(ee), Kr(o, this, oe);
        };
      }
      function mb(o, f) {
        return f.length < 2 ? o : Ts(o, ln(f, 0, -1));
      }
      function aR(o, f) {
        for (var b = o.length, P = wr(f.length, b), M = Br(o); P--; ) {
          var H = f[P];
          o[P] = hi(H, b) ? M[H] : r;
        }
        return o;
      }
      function fp(o, f) {
        if (!(f === "constructor" && typeof o[f] == "function") && f != "__proto__")
          return o[f];
      }
      var yb = vb(qv), Vo = wA || function(o, f) {
        return mr.setTimeout(o, f);
      }, dp = vb(CC);
      function gb(o, f, b) {
        var P = f + "";
        return dp(o, JC(P, oR(GC(P), b)));
      }
      function vb(o) {
        var f = 0, b = 0;
        return function() {
          var P = OA(), M = je - (P - b);
          if (b = P, M > 0) {
            if (++f >= xe)
              return arguments[0];
          } else
            f = 0;
          return o.apply(r, arguments);
        };
      }
      function Zc(o, f) {
        var b = -1, P = o.length, M = P - 1;
        for (f = f === r ? P : f; ++b < f; ) {
          var H = Gd(b, M), ee = o[H];
          o[H] = o[b], o[b] = ee;
        }
        return o.length = f, o;
      }
      var bb = rR(function(o) {
        var f = [];
        return o.charCodeAt(0) === 46 && f.push(""), o.replace(Po, function(b, P, M, H) {
          f.push(M ? H.replace(Xe, "$1") : P || b);
        }), f;
      });
      function Zn(o) {
        if (typeof o == "string" || Xr(o))
          return o;
        var f = o + "";
        return f == "0" && 1 / o == -$e ? "-0" : f;
      }
      function js(o) {
        if (o != null) {
          try {
            return bc.call(o);
          } catch {
          }
          try {
            return o + "";
          } catch {
          }
        }
        return "";
      }
      function oR(o, f) {
        return an(C, function(b) {
          var P = "_." + b[0];
          f & b[1] && !hc(o, P) && o.push(P);
        }), o.sort();
      }
      function _b(o) {
        if (o instanceof At)
          return o.clone();
        var f = new un(o.__wrapped__, o.__chain__);
        return f.__actions__ = Br(o.__actions__), f.__index__ = o.__index__, f.__values__ = o.__values__, f;
      }
      function uR(o, f, b) {
        (b ? Ir(o, f, b) : f === r) ? f = 1 : f = cr(gt(f), 0);
        var P = o == null ? 0 : o.length;
        if (!P || f < 1)
          return [];
        for (var M = 0, H = 0, ee = be(Pc(P / f)); M < P; )
          ee[H++] = ln(o, M, M += f);
        return ee;
      }
      function cR(o) {
        for (var f = -1, b = o == null ? 0 : o.length, P = 0, M = []; ++f < b; ) {
          var H = o[f];
          H && (M[P++] = H);
        }
        return M;
      }
      function lR() {
        var o = arguments.length;
        if (!o)
          return [];
        for (var f = be(o - 1), b = arguments[0], P = o; P--; )
          f[P - 1] = arguments[P];
        return Fi(pt(b) ? Br(b) : [b], yr(f, 1));
      }
      var fR = $t(function(o, f) {
        return er(o) ? Do(o, yr(f, 1, er, !0)) : [];
      }), dR = $t(function(o, f) {
        var b = fn(f);
        return er(b) && (b = r), er(o) ? Do(o, yr(f, 1, er, !0), nt(b, 2)) : [];
      }), pR = $t(function(o, f) {
        var b = fn(f);
        return er(b) && (b = r), er(o) ? Do(o, yr(f, 1, er, !0), r, b) : [];
      });
      function hR(o, f, b) {
        var P = o == null ? 0 : o.length;
        return P ? (f = b || f === r ? 1 : gt(f), ln(o, f < 0 ? 0 : f, P)) : [];
      }
      function mR(o, f, b) {
        var P = o == null ? 0 : o.length;
        return P ? (f = b || f === r ? 1 : gt(f), f = P - f, ln(o, 0, f < 0 ? 0 : f)) : [];
      }
      function yR(o, f) {
        return o && o.length ? Nc(o, nt(f, 3), !0, !0) : [];
      }
      function gR(o, f) {
        return o && o.length ? Nc(o, nt(f, 3), !0) : [];
      }
      function vR(o, f, b, P) {
        var M = o == null ? 0 : o.length;
        return M ? (b && typeof b != "number" && Ir(o, f, b) && (b = 0, P = M), lC(o, f, b, P)) : [];
      }
      function wb(o, f, b) {
        var P = o == null ? 0 : o.length;
        if (!P)
          return -1;
        var M = b == null ? 0 : gt(b);
        return M < 0 && (M = cr(P + M, 0)), mc(o, nt(f, 3), M);
      }
      function $b(o, f, b) {
        var P = o == null ? 0 : o.length;
        if (!P)
          return -1;
        var M = P - 1;
        return b !== r && (M = gt(b), M = b < 0 ? cr(P + M, 0) : wr(M, P - 1)), mc(o, nt(f, 3), M, !0);
      }
      function Eb(o) {
        var f = o == null ? 0 : o.length;
        return f ? yr(o, 1) : [];
      }
      function bR(o) {
        var f = o == null ? 0 : o.length;
        return f ? yr(o, $e) : [];
      }
      function _R(o, f) {
        var b = o == null ? 0 : o.length;
        return b ? (f = f === r ? 1 : gt(f), yr(o, f)) : [];
      }
      function wR(o) {
        for (var f = -1, b = o == null ? 0 : o.length, P = {}; ++f < b; ) {
          var M = o[f];
          P[M[0]] = M[1];
        }
        return P;
      }
      function xb(o) {
        return o && o.length ? o[0] : r;
      }
      function $R(o, f, b) {
        var P = o == null ? 0 : o.length;
        if (!P)
          return -1;
        var M = b == null ? 0 : gt(b);
        return M < 0 && (M = cr(P + M, 0)), ha(o, f, M);
      }
      function ER(o) {
        var f = o == null ? 0 : o.length;
        return f ? ln(o, 0, -1) : [];
      }
      var xR = $t(function(o) {
        var f = Kt(o, Qd);
        return f.length && f[0] === o[0] ? Vd(f) : [];
      }), OR = $t(function(o) {
        var f = fn(o), b = Kt(o, Qd);
        return f === fn(b) ? f = r : b.pop(), b.length && b[0] === o[0] ? Vd(b, nt(f, 2)) : [];
      }), PR = $t(function(o) {
        var f = fn(o), b = Kt(o, Qd);
        return f = typeof f == "function" ? f : r, f && b.pop(), b.length && b[0] === o[0] ? Vd(b, r, f) : [];
      });
      function SR(o, f) {
        return o == null ? "" : EA.call(o, f);
      }
      function fn(o) {
        var f = o == null ? 0 : o.length;
        return f ? o[f - 1] : r;
      }
      function AR(o, f, b) {
        var P = o == null ? 0 : o.length;
        if (!P)
          return -1;
        var M = P;
        return b !== r && (M = gt(b), M = M < 0 ? cr(P + M, 0) : wr(M, P - 1)), f === f ? oA(o, f, M) : mc(o, iv, M, !0);
      }
      function CR(o, f) {
        return o && o.length ? Mv(o, gt(f)) : r;
      }
      var RR = $t(Ob);
      function Ob(o, f) {
        return o && o.length && f && f.length ? Hd(o, f) : o;
      }
      function TR(o, f, b) {
        return o && o.length && f && f.length ? Hd(o, f, nt(b, 2)) : o;
      }
      function IR(o, f, b) {
        return o && o.length && f && f.length ? Hd(o, f, r, b) : o;
      }
      var jR = pi(function(o, f) {
        var b = o == null ? 0 : o.length, P = qd(o, f);
        return Lv(o, Kt(f, function(M) {
          return hi(M, b) ? +M : M;
        }).sort(Gv)), P;
      });
      function kR(o, f) {
        var b = [];
        if (!(o && o.length))
          return b;
        var P = -1, M = [], H = o.length;
        for (f = nt(f, 3); ++P < H; ) {
          var ee = o[P];
          f(ee, P, o) && (b.push(ee), M.push(P));
        }
        return Lv(o, M), b;
      }
      function pp(o) {
        return o == null ? o : SA.call(o);
      }
      function MR(o, f, b) {
        var P = o == null ? 0 : o.length;
        return P ? (b && typeof b != "number" && Ir(o, f, b) ? (f = 0, b = P) : (f = f == null ? 0 : gt(f), b = b === r ? P : gt(b)), ln(o, f, b)) : [];
      }
      function NR(o, f) {
        return Mc(o, f);
      }
      function DR(o, f, b) {
        return Yd(o, f, nt(b, 2));
      }
      function LR(o, f) {
        var b = o == null ? 0 : o.length;
        if (b) {
          var P = Mc(o, f);
          if (P < b && $n(o[P], f))
            return P;
        }
        return -1;
      }
      function qR(o, f) {
        return Mc(o, f, !0);
      }
      function FR(o, f, b) {
        return Yd(o, f, nt(b, 2), !0);
      }
      function UR(o, f) {
        var b = o == null ? 0 : o.length;
        if (b) {
          var P = Mc(o, f, !0) - 1;
          if ($n(o[P], f))
            return P;
        }
        return -1;
      }
      function BR(o) {
        return o && o.length ? Fv(o) : [];
      }
      function VR(o, f) {
        return o && o.length ? Fv(o, nt(f, 2)) : [];
      }
      function ZR(o) {
        var f = o == null ? 0 : o.length;
        return f ? ln(o, 1, f) : [];
      }
      function zR(o, f, b) {
        return o && o.length ? (f = b || f === r ? 1 : gt(f), ln(o, 0, f < 0 ? 0 : f)) : [];
      }
      function WR(o, f, b) {
        var P = o == null ? 0 : o.length;
        return P ? (f = b || f === r ? 1 : gt(f), f = P - f, ln(o, f < 0 ? 0 : f, P)) : [];
      }
      function HR(o, f) {
        return o && o.length ? Nc(o, nt(f, 3), !1, !0) : [];
      }
      function GR(o, f) {
        return o && o.length ? Nc(o, nt(f, 3)) : [];
      }
      var KR = $t(function(o) {
        return Zi(yr(o, 1, er, !0));
      }), YR = $t(function(o) {
        var f = fn(o);
        return er(f) && (f = r), Zi(yr(o, 1, er, !0), nt(f, 2));
      }), JR = $t(function(o) {
        var f = fn(o);
        return f = typeof f == "function" ? f : r, Zi(yr(o, 1, er, !0), r, f);
      });
      function XR(o) {
        return o && o.length ? Zi(o) : [];
      }
      function QR(o, f) {
        return o && o.length ? Zi(o, nt(f, 2)) : [];
      }
      function eT(o, f) {
        return f = typeof f == "function" ? f : r, o && o.length ? Zi(o, r, f) : [];
      }
      function hp(o) {
        if (!(o && o.length))
          return [];
        var f = 0;
        return o = qi(o, function(b) {
          if (er(b))
            return f = cr(b.length, f), !0;
        }), Td(f, function(b) {
          return Kt(o, Ad(b));
        });
      }
      function Pb(o, f) {
        if (!(o && o.length))
          return [];
        var b = hp(o);
        return f == null ? b : Kt(b, function(P) {
          return Kr(f, r, P);
        });
      }
      var tT = $t(function(o, f) {
        return er(o) ? Do(o, f) : [];
      }), rT = $t(function(o) {
        return Xd(qi(o, er));
      }), nT = $t(function(o) {
        var f = fn(o);
        return er(f) && (f = r), Xd(qi(o, er), nt(f, 2));
      }), iT = $t(function(o) {
        var f = fn(o);
        return f = typeof f == "function" ? f : r, Xd(qi(o, er), r, f);
      }), sT = $t(hp);
      function aT(o, f) {
        return Zv(o || [], f || [], No);
      }
      function oT(o, f) {
        return Zv(o || [], f || [], Fo);
      }
      var uT = $t(function(o) {
        var f = o.length, b = f > 1 ? o[f - 1] : r;
        return b = typeof b == "function" ? (o.pop(), b) : r, Pb(o, b);
      });
      function Sb(o) {
        var f = B(o);
        return f.__chain__ = !0, f;
      }
      function cT(o, f) {
        return f(o), o;
      }
      function zc(o, f) {
        return f(o);
      }
      var lT = pi(function(o) {
        var f = o.length, b = f ? o[0] : 0, P = this.__wrapped__, M = function(H) {
          return qd(H, o);
        };
        return f > 1 || this.__actions__.length || !(P instanceof At) || !hi(b) ? this.thru(M) : (P = P.slice(b, +b + (f ? 1 : 0)), P.__actions__.push({
          func: zc,
          args: [M],
          thisArg: r
        }), new un(P, this.__chain__).thru(function(H) {
          return f && !H.length && H.push(r), H;
        }));
      });
      function fT() {
        return Sb(this);
      }
      function dT() {
        return new un(this.value(), this.__chain__);
      }
      function pT() {
        this.__values__ === r && (this.__values__ = Ub(this.value()));
        var o = this.__index__ >= this.__values__.length, f = o ? r : this.__values__[this.__index__++];
        return { done: o, value: f };
      }
      function hT() {
        return this;
      }
      function mT(o) {
        for (var f, b = this; b instanceof Rc; ) {
          var P = _b(b);
          P.__index__ = 0, P.__values__ = r, f ? M.__wrapped__ = P : f = P;
          var M = P;
          b = b.__wrapped__;
        }
        return M.__wrapped__ = o, f;
      }
      function yT() {
        var o = this.__wrapped__;
        if (o instanceof At) {
          var f = o;
          return this.__actions__.length && (f = new At(this)), f = f.reverse(), f.__actions__.push({
            func: zc,
            args: [pp],
            thisArg: r
          }), new un(f, this.__chain__);
        }
        return this.thru(pp);
      }
      function gT() {
        return Vv(this.__wrapped__, this.__actions__);
      }
      var vT = Dc(function(o, f, b) {
        Ft.call(o, b) ? ++o[b] : fi(o, b, 1);
      });
      function bT(o, f, b) {
        var P = pt(o) ? rv : cC;
        return b && Ir(o, f, b) && (f = r), P(o, nt(f, 3));
      }
      function _T(o, f) {
        var b = pt(o) ? qi : Pv;
        return b(o, nt(f, 3));
      }
      var wT = eb(wb), $T = eb($b);
      function ET(o, f) {
        return yr(Wc(o, f), 1);
      }
      function xT(o, f) {
        return yr(Wc(o, f), $e);
      }
      function OT(o, f, b) {
        return b = b === r ? 1 : gt(b), yr(Wc(o, f), b);
      }
      function Ab(o, f) {
        var b = pt(o) ? an : Vi;
        return b(o, nt(f, 3));
      }
      function Cb(o, f) {
        var b = pt(o) ? ZS : Ov;
        return b(o, nt(f, 3));
      }
      var PT = Dc(function(o, f, b) {
        Ft.call(o, b) ? o[b].push(f) : fi(o, b, [f]);
      });
      function ST(o, f, b, P) {
        o = Vr(o) ? o : Pa(o), b = b && !P ? gt(b) : 0;
        var M = o.length;
        return b < 0 && (b = cr(M + b, 0)), Jc(o) ? b <= M && o.indexOf(f, b) > -1 : !!M && ha(o, f, b) > -1;
      }
      var AT = $t(function(o, f, b) {
        var P = -1, M = typeof f == "function", H = Vr(o) ? be(o.length) : [];
        return Vi(o, function(ee) {
          H[++P] = M ? Kr(f, ee, b) : Lo(ee, f, b);
        }), H;
      }), CT = Dc(function(o, f, b) {
        fi(o, b, f);
      });
      function Wc(o, f) {
        var b = pt(o) ? Kt : Iv;
        return b(o, nt(f, 3));
      }
      function RT(o, f, b, P) {
        return o == null ? [] : (pt(f) || (f = f == null ? [] : [f]), b = P ? r : b, pt(b) || (b = b == null ? [] : [b]), Nv(o, f, b));
      }
      var TT = Dc(function(o, f, b) {
        o[b ? 0 : 1].push(f);
      }, function() {
        return [[], []];
      });
      function IT(o, f, b) {
        var P = pt(o) ? Pd : av, M = arguments.length < 3;
        return P(o, nt(f, 4), b, M, Vi);
      }
      function jT(o, f, b) {
        var P = pt(o) ? zS : av, M = arguments.length < 3;
        return P(o, nt(f, 4), b, M, Ov);
      }
      function kT(o, f) {
        var b = pt(o) ? qi : Pv;
        return b(o, Kc(nt(f, 3)));
      }
      function MT(o) {
        var f = pt(o) ? wv : SC;
        return f(o);
      }
      function NT(o, f, b) {
        (b ? Ir(o, f, b) : f === r) ? f = 1 : f = gt(f);
        var P = pt(o) ? iC : AC;
        return P(o, f);
      }
      function DT(o) {
        var f = pt(o) ? sC : RC;
        return f(o);
      }
      function LT(o) {
        if (o == null)
          return 0;
        if (Vr(o))
          return Jc(o) ? ya(o) : o.length;
        var f = $r(o);
        return f == we || f == St ? o.size : zd(o).length;
      }
      function qT(o, f, b) {
        var P = pt(o) ? Sd : TC;
        return b && Ir(o, f, b) && (f = r), P(o, nt(f, 3));
      }
      var FT = $t(function(o, f) {
        if (o == null)
          return [];
        var b = f.length;
        return b > 1 && Ir(o, f[0], f[1]) ? f = [] : b > 2 && Ir(f[0], f[1], f[2]) && (f = [f[0]]), Nv(o, yr(f, 1), []);
      }), Hc = _A || function() {
        return mr.Date.now();
      };
      function UT(o, f) {
        if (typeof f != "function")
          throw new on(a);
        return o = gt(o), function() {
          if (--o < 1)
            return f.apply(this, arguments);
        };
      }
      function Rb(o, f, b) {
        return f = b ? r : f, f = o && f == null ? o.length : f, di(o, I, r, r, r, r, f);
      }
      function Tb(o, f) {
        var b;
        if (typeof f != "function")
          throw new on(a);
        return o = gt(o), function() {
          return --o > 0 && (b = f.apply(this, arguments)), o <= 1 && (f = r), b;
        };
      }
      var mp = $t(function(o, f, b) {
        var P = _;
        if (b.length) {
          var M = Ui(b, xa(mp));
          P |= A;
        }
        return di(o, P, f, b, M);
      }), Ib = $t(function(o, f, b) {
        var P = _ | m;
        if (b.length) {
          var M = Ui(b, xa(Ib));
          P |= A;
        }
        return di(f, P, o, b, M);
      });
      function jb(o, f, b) {
        f = b ? r : f;
        var P = di(o, $, r, r, r, r, r, f);
        return P.placeholder = jb.placeholder, P;
      }
      function kb(o, f, b) {
        f = b ? r : f;
        var P = di(o, E, r, r, r, r, r, f);
        return P.placeholder = kb.placeholder, P;
      }
      function Mb(o, f, b) {
        var P, M, H, ee, oe, he, Ce = 0, Re = !1, ke = !1, Ue = !0;
        if (typeof o != "function")
          throw new on(a);
        f = dn(f) || 0, Yt(b) && (Re = !!b.leading, ke = "maxWait" in b, H = ke ? cr(dn(b.maxWait) || 0, f) : H, Ue = "trailing" in b ? !!b.trailing : Ue);
        function Je(tr) {
          var En = P, gi = M;
          return P = M = r, Ce = tr, ee = o.apply(gi, En), ee;
        }
        function it(tr) {
          return Ce = tr, oe = Vo(Ot, f), Re ? Je(tr) : ee;
        }
        function bt(tr) {
          var En = tr - he, gi = tr - Ce, e1 = f - En;
          return ke ? wr(e1, H - gi) : e1;
        }
        function st(tr) {
          var En = tr - he, gi = tr - Ce;
          return he === r || En >= f || En < 0 || ke && gi >= H;
        }
        function Ot() {
          var tr = Hc();
          if (st(tr))
            return Rt(tr);
          oe = Vo(Ot, bt(tr));
        }
        function Rt(tr) {
          return oe = r, Ue && P ? Je(tr) : (P = M = r, ee);
        }
        function Qr() {
          oe !== r && zv(oe), Ce = 0, P = he = M = oe = r;
        }
        function jr() {
          return oe === r ? ee : Rt(Hc());
        }
        function en() {
          var tr = Hc(), En = st(tr);
          if (P = arguments, M = this, he = tr, En) {
            if (oe === r)
              return it(he);
            if (ke)
              return zv(oe), oe = Vo(Ot, f), Je(he);
          }
          return oe === r && (oe = Vo(Ot, f)), ee;
        }
        return en.cancel = Qr, en.flush = jr, en;
      }
      var BT = $t(function(o, f) {
        return xv(o, 1, f);
      }), VT = $t(function(o, f, b) {
        return xv(o, dn(f) || 0, b);
      });
      function ZT(o) {
        return di(o, J);
      }
      function Gc(o, f) {
        if (typeof o != "function" || f != null && typeof f != "function")
          throw new on(a);
        var b = function() {
          var P = arguments, M = f ? f.apply(this, P) : P[0], H = b.cache;
          if (H.has(M))
            return H.get(M);
          var ee = o.apply(this, P);
          return b.cache = H.set(M, ee) || H, ee;
        };
        return b.cache = new (Gc.Cache || li)(), b;
      }
      Gc.Cache = li;
      function Kc(o) {
        if (typeof o != "function")
          throw new on(a);
        return function() {
          var f = arguments;
          switch (f.length) {
            case 0:
              return !o.call(this);
            case 1:
              return !o.call(this, f[0]);
            case 2:
              return !o.call(this, f[0], f[1]);
            case 3:
              return !o.call(this, f[0], f[1], f[2]);
          }
          return !o.apply(this, f);
        };
      }
      function zT(o) {
        return Tb(2, o);
      }
      var WT = IC(function(o, f) {
        f = f.length == 1 && pt(f[0]) ? Kt(f[0], Yr(nt())) : Kt(yr(f, 1), Yr(nt()));
        var b = f.length;
        return $t(function(P) {
          for (var M = -1, H = wr(P.length, b); ++M < H; )
            P[M] = f[M].call(this, P[M]);
          return Kr(o, this, P);
        });
      }), yp = $t(function(o, f) {
        var b = Ui(f, xa(yp));
        return di(o, A, r, f, b);
      }), Nb = $t(function(o, f) {
        var b = Ui(f, xa(Nb));
        return di(o, R, r, f, b);
      }), HT = pi(function(o, f) {
        return di(o, D, r, r, r, f);
      });
      function GT(o, f) {
        if (typeof o != "function")
          throw new on(a);
        return f = f === r ? f : gt(f), $t(o, f);
      }
      function KT(o, f) {
        if (typeof o != "function")
          throw new on(a);
        return f = f == null ? 0 : cr(gt(f), 0), $t(function(b) {
          var P = b[f], M = Wi(b, 0, f);
          return P && Fi(M, P), Kr(o, this, M);
        });
      }
      function YT(o, f, b) {
        var P = !0, M = !0;
        if (typeof o != "function")
          throw new on(a);
        return Yt(b) && (P = "leading" in b ? !!b.leading : P, M = "trailing" in b ? !!b.trailing : M), Mb(o, f, {
          leading: P,
          maxWait: f,
          trailing: M
        });
      }
      function JT(o) {
        return Rb(o, 1);
      }
      function XT(o, f) {
        return yp(ep(f), o);
      }
      function QT() {
        if (!arguments.length)
          return [];
        var o = arguments[0];
        return pt(o) ? o : [o];
      }
      function eI(o) {
        return cn(o, v);
      }
      function tI(o, f) {
        return f = typeof f == "function" ? f : r, cn(o, v, f);
      }
      function rI(o) {
        return cn(o, p | v);
      }
      function nI(o, f) {
        return f = typeof f == "function" ? f : r, cn(o, p | v, f);
      }
      function iI(o, f) {
        return f == null || Ev(o, f, dr(f));
      }
      function $n(o, f) {
        return o === f || o !== o && f !== f;
      }
      var sI = Uc(Bd), aI = Uc(function(o, f) {
        return o >= f;
      }), ks = Cv(function() {
        return arguments;
      }()) ? Cv : function(o) {
        return Xt(o) && Ft.call(o, "callee") && !mv.call(o, "callee");
      }, pt = be.isArray, oI = Y0 ? Yr(Y0) : mC;
      function Vr(o) {
        return o != null && Yc(o.length) && !mi(o);
      }
      function er(o) {
        return Xt(o) && Vr(o);
      }
      function uI(o) {
        return o === !0 || o === !1 || Xt(o) && Tr(o) == T;
      }
      var Hi = $A || Sp, cI = J0 ? Yr(J0) : yC;
      function lI(o) {
        return Xt(o) && o.nodeType === 1 && !Zo(o);
      }
      function fI(o) {
        if (o == null)
          return !0;
        if (Vr(o) && (pt(o) || typeof o == "string" || typeof o.splice == "function" || Hi(o) || Oa(o) || ks(o)))
          return !o.length;
        var f = $r(o);
        if (f == we || f == St)
          return !o.size;
        if (Bo(o))
          return !zd(o).length;
        for (var b in o)
          if (Ft.call(o, b))
            return !1;
        return !0;
      }
      function dI(o, f) {
        return qo(o, f);
      }
      function pI(o, f, b) {
        b = typeof b == "function" ? b : r;
        var P = b ? b(o, f) : r;
        return P === r ? qo(o, f, r, b) : !!P;
      }
      function gp(o) {
        if (!Xt(o))
          return !1;
        var f = Tr(o);
        return f == k || f == Y || typeof o.message == "string" && typeof o.name == "string" && !Zo(o);
      }
      function hI(o) {
        return typeof o == "number" && gv(o);
      }
      function mi(o) {
        if (!Yt(o))
          return !1;
        var f = Tr(o);
        return f == U || f == pe || f == F || f == Ee;
      }
      function Db(o) {
        return typeof o == "number" && o == gt(o);
      }
      function Yc(o) {
        return typeof o == "number" && o > -1 && o % 1 == 0 && o <= Ae;
      }
      function Yt(o) {
        var f = typeof o;
        return o != null && (f == "object" || f == "function");
      }
      function Xt(o) {
        return o != null && typeof o == "object";
      }
      var Lb = X0 ? Yr(X0) : vC;
      function mI(o, f) {
        return o === f || Zd(o, f, op(f));
      }
      function yI(o, f, b) {
        return b = typeof b == "function" ? b : r, Zd(o, f, op(f), b);
      }
      function gI(o) {
        return qb(o) && o != +o;
      }
      function vI(o) {
        if (tR(o))
          throw new ft(s);
        return Rv(o);
      }
      function bI(o) {
        return o === null;
      }
      function _I(o) {
        return o == null;
      }
      function qb(o) {
        return typeof o == "number" || Xt(o) && Tr(o) == He;
      }
      function Zo(o) {
        if (!Xt(o) || Tr(o) != Ge)
          return !1;
        var f = Ec(o);
        if (f === null)
          return !0;
        var b = Ft.call(f, "constructor") && f.constructor;
        return typeof b == "function" && b instanceof b && bc.call(b) == yA;
      }
      var vp = Q0 ? Yr(Q0) : bC;
      function wI(o) {
        return Db(o) && o >= -Ae && o <= Ae;
      }
      var Fb = ev ? Yr(ev) : _C;
      function Jc(o) {
        return typeof o == "string" || !pt(o) && Xt(o) && Tr(o) == Ne;
      }
      function Xr(o) {
        return typeof o == "symbol" || Xt(o) && Tr(o) == Le;
      }
      var Oa = tv ? Yr(tv) : wC;
      function $I(o) {
        return o === r;
      }
      function EI(o) {
        return Xt(o) && $r(o) == mt;
      }
      function xI(o) {
        return Xt(o) && Tr(o) == qe;
      }
      var OI = Uc(Wd), PI = Uc(function(o, f) {
        return o <= f;
      });
      function Ub(o) {
        if (!o)
          return [];
        if (Vr(o))
          return Jc(o) ? _n(o) : Br(o);
        if (To && o[To])
          return iA(o[To]());
        var f = $r(o), b = f == we ? jd : f == St ? yc : Pa;
        return b(o);
      }
      function yi(o) {
        if (!o)
          return o === 0 ? o : 0;
        if (o = dn(o), o === $e || o === -$e) {
          var f = o < 0 ? -1 : 1;
          return f * _e;
        }
        return o === o ? o : 0;
      }
      function gt(o) {
        var f = yi(o), b = f % 1;
        return f === f ? b ? f - b : f : 0;
      }
      function Bb(o) {
        return o ? Rs(gt(o), 0, K) : 0;
      }
      function dn(o) {
        if (typeof o == "number")
          return o;
        if (Xr(o))
          return ie;
        if (Yt(o)) {
          var f = typeof o.valueOf == "function" ? o.valueOf() : o;
          o = Yt(f) ? f + "" : f;
        }
        if (typeof o != "string")
          return o === 0 ? o : +o;
        o = ov(o);
        var b = vt.test(o);
        return b || O.test(o) ? US(o.slice(2), b ? 2 : 8) : Wt.test(o) ? ie : +o;
      }
      function Vb(o) {
        return Vn(o, Zr(o));
      }
      function SI(o) {
        return o ? Rs(gt(o), -Ae, Ae) : o === 0 ? o : 0;
      }
      function qt(o) {
        return o == null ? "" : Jr(o);
      }
      var AI = $a(function(o, f) {
        if (Bo(f) || Vr(f)) {
          Vn(f, dr(f), o);
          return;
        }
        for (var b in f)
          Ft.call(f, b) && No(o, b, f[b]);
      }), Zb = $a(function(o, f) {
        Vn(f, Zr(f), o);
      }), Xc = $a(function(o, f, b, P) {
        Vn(f, Zr(f), o, P);
      }), CI = $a(function(o, f, b, P) {
        Vn(f, dr(f), o, P);
      }), RI = pi(qd);
      function TI(o, f) {
        var b = wa(o);
        return f == null ? b : $v(b, f);
      }
      var II = $t(function(o, f) {
        o = Zt(o);
        var b = -1, P = f.length, M = P > 2 ? f[2] : r;
        for (M && Ir(f[0], f[1], M) && (P = 1); ++b < P; )
          for (var H = f[b], ee = Zr(H), oe = -1, he = ee.length; ++oe < he; ) {
            var Ce = ee[oe], Re = o[Ce];
            (Re === r || $n(Re, va[Ce]) && !Ft.call(o, Ce)) && (o[Ce] = H[Ce]);
          }
        return o;
      }), jI = $t(function(o) {
        return o.push(r, ob), Kr(zb, r, o);
      });
      function kI(o, f) {
        return nv(o, nt(f, 3), Bn);
      }
      function MI(o, f) {
        return nv(o, nt(f, 3), Ud);
      }
      function NI(o, f) {
        return o == null ? o : Fd(o, nt(f, 3), Zr);
      }
      function DI(o, f) {
        return o == null ? o : Sv(o, nt(f, 3), Zr);
      }
      function LI(o, f) {
        return o && Bn(o, nt(f, 3));
      }
      function qI(o, f) {
        return o && Ud(o, nt(f, 3));
      }
      function FI(o) {
        return o == null ? [] : jc(o, dr(o));
      }
      function UI(o) {
        return o == null ? [] : jc(o, Zr(o));
      }
      function bp(o, f, b) {
        var P = o == null ? r : Ts(o, f);
        return P === r ? b : P;
      }
      function BI(o, f) {
        return o != null && lb(o, f, fC);
      }
      function _p(o, f) {
        return o != null && lb(o, f, dC);
      }
      var VI = rb(function(o, f, b) {
        f != null && typeof f.toString != "function" && (f = _c.call(f)), o[f] = b;
      }, $p(zr)), ZI = rb(function(o, f, b) {
        f != null && typeof f.toString != "function" && (f = _c.call(f)), Ft.call(o, f) ? o[f].push(b) : o[f] = [b];
      }, nt), zI = $t(Lo);
      function dr(o) {
        return Vr(o) ? _v(o) : zd(o);
      }
      function Zr(o) {
        return Vr(o) ? _v(o, !0) : $C(o);
      }
      function WI(o, f) {
        var b = {};
        return f = nt(f, 3), Bn(o, function(P, M, H) {
          fi(b, f(P, M, H), P);
        }), b;
      }
      function HI(o, f) {
        var b = {};
        return f = nt(f, 3), Bn(o, function(P, M, H) {
          fi(b, M, f(P, M, H));
        }), b;
      }
      var GI = $a(function(o, f, b) {
        kc(o, f, b);
      }), zb = $a(function(o, f, b, P) {
        kc(o, f, b, P);
      }), KI = pi(function(o, f) {
        var b = {};
        if (o == null)
          return b;
        var P = !1;
        f = Kt(f, function(H) {
          return H = zi(H, o), P || (P = H.length > 1), H;
        }), Vn(o, sp(o), b), P && (b = cn(b, p | h | v, VC));
        for (var M = f.length; M--; )
          Jd(b, f[M]);
        return b;
      });
      function YI(o, f) {
        return Wb(o, Kc(nt(f)));
      }
      var JI = pi(function(o, f) {
        return o == null ? {} : xC(o, f);
      });
      function Wb(o, f) {
        if (o == null)
          return {};
        var b = Kt(sp(o), function(P) {
          return [P];
        });
        return f = nt(f), Dv(o, b, function(P, M) {
          return f(P, M[0]);
        });
      }
      function XI(o, f, b) {
        f = zi(f, o);
        var P = -1, M = f.length;
        for (M || (M = 1, o = r); ++P < M; ) {
          var H = o == null ? r : o[Zn(f[P])];
          H === r && (P = M, H = b), o = mi(H) ? H.call(o) : H;
        }
        return o;
      }
      function QI(o, f, b) {
        return o == null ? o : Fo(o, f, b);
      }
      function ej(o, f, b, P) {
        return P = typeof P == "function" ? P : r, o == null ? o : Fo(o, f, b, P);
      }
      var Hb = sb(dr), Gb = sb(Zr);
      function tj(o, f, b) {
        var P = pt(o), M = P || Hi(o) || Oa(o);
        if (f = nt(f, 4), b == null) {
          var H = o && o.constructor;
          M ? b = P ? new H() : [] : Yt(o) ? b = mi(H) ? wa(Ec(o)) : {} : b = {};
        }
        return (M ? an : Bn)(o, function(ee, oe, he) {
          return f(b, ee, oe, he);
        }), b;
      }
      function rj(o, f) {
        return o == null ? !0 : Jd(o, f);
      }
      function nj(o, f, b) {
        return o == null ? o : Bv(o, f, ep(b));
      }
      function ij(o, f, b, P) {
        return P = typeof P == "function" ? P : r, o == null ? o : Bv(o, f, ep(b), P);
      }
      function Pa(o) {
        return o == null ? [] : Id(o, dr(o));
      }
      function sj(o) {
        return o == null ? [] : Id(o, Zr(o));
      }
      function aj(o, f, b) {
        return b === r && (b = f, f = r), b !== r && (b = dn(b), b = b === b ? b : 0), f !== r && (f = dn(f), f = f === f ? f : 0), Rs(dn(o), f, b);
      }
      function oj(o, f, b) {
        return f = yi(f), b === r ? (b = f, f = 0) : b = yi(b), o = dn(o), pC(o, f, b);
      }
      function uj(o, f, b) {
        if (b && typeof b != "boolean" && Ir(o, f, b) && (f = b = r), b === r && (typeof f == "boolean" ? (b = f, f = r) : typeof o == "boolean" && (b = o, o = r)), o === r && f === r ? (o = 0, f = 1) : (o = yi(o), f === r ? (f = o, o = 0) : f = yi(f)), o > f) {
          var P = o;
          o = f, f = P;
        }
        if (b || o % 1 || f % 1) {
          var M = vv();
          return wr(o + M * (f - o + FS("1e-" + ((M + "").length - 1))), f);
        }
        return Gd(o, f);
      }
      var cj = Ea(function(o, f, b) {
        return f = f.toLowerCase(), o + (b ? Kb(f) : f);
      });
      function Kb(o) {
        return wp(qt(o).toLowerCase());
      }
      function Yb(o) {
        return o = qt(o), o && o.replace(W, QS).replace(RS, "");
      }
      function lj(o, f, b) {
        o = qt(o), f = Jr(f);
        var P = o.length;
        b = b === r ? P : Rs(gt(b), 0, P);
        var M = b;
        return b -= f.length, b >= 0 && o.slice(b, M) == f;
      }
      function fj(o) {
        return o = qt(o), o && Fn.test(o) ? o.replace(ca, eA) : o;
      }
      function dj(o) {
        return o = qt(o), o && So.test(o) ? o.replace(Ni, "\\$&") : o;
      }
      var pj = Ea(function(o, f, b) {
        return o + (b ? "-" : "") + f.toLowerCase();
      }), hj = Ea(function(o, f, b) {
        return o + (b ? " " : "") + f.toLowerCase();
      }), mj = Qv("toLowerCase");
      function yj(o, f, b) {
        o = qt(o), f = gt(f);
        var P = f ? ya(o) : 0;
        if (!f || P >= f)
          return o;
        var M = (f - P) / 2;
        return Fc(Sc(M), b) + o + Fc(Pc(M), b);
      }
      function gj(o, f, b) {
        o = qt(o), f = gt(f);
        var P = f ? ya(o) : 0;
        return f && P < f ? o + Fc(f - P, b) : o;
      }
      function vj(o, f, b) {
        o = qt(o), f = gt(f);
        var P = f ? ya(o) : 0;
        return f && P < f ? Fc(f - P, b) + o : o;
      }
      function bj(o, f, b) {
        return b || f == null ? f = 0 : f && (f = +f), PA(qt(o).replace(Di, ""), f || 0);
      }
      function _j(o, f, b) {
        return (b ? Ir(o, f, b) : f === r) ? f = 1 : f = gt(f), Kd(qt(o), f);
      }
      function wj() {
        var o = arguments, f = qt(o[0]);
        return o.length < 3 ? f : f.replace(o[1], o[2]);
      }
      var $j = Ea(function(o, f, b) {
        return o + (b ? "_" : "") + f.toLowerCase();
      });
      function Ej(o, f, b) {
        return b && typeof b != "number" && Ir(o, f, b) && (f = b = r), b = b === r ? K : b >>> 0, b ? (o = qt(o), o && (typeof f == "string" || f != null && !vp(f)) && (f = Jr(f), !f && ma(o)) ? Wi(_n(o), 0, b) : o.split(f, b)) : [];
      }
      var xj = Ea(function(o, f, b) {
        return o + (b ? " " : "") + wp(f);
      });
      function Oj(o, f, b) {
        return o = qt(o), b = b == null ? 0 : Rs(gt(b), 0, o.length), f = Jr(f), o.slice(b, b + f.length) == f;
      }
      function Pj(o, f, b) {
        var P = B.templateSettings;
        b && Ir(o, f, b) && (f = r), o = qt(o), f = Xc({}, f, P, ab);
        var M = Xc({}, f.imports, P.imports, ab), H = dr(M), ee = Id(M, H), oe, he, Ce = 0, Re = f.interpolate || ne, ke = "__p += '", Ue = kd(
          (f.escape || ne).source + "|" + Re.source + "|" + (Re === fa ? Et : ne).source + "|" + (f.evaluate || ne).source + "|$",
          "g"
        ), Je = "//# sourceURL=" + (Ft.call(f, "sourceURL") ? (f.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++MS + "]") + `
`;
        o.replace(Ue, function(st, Ot, Rt, Qr, jr, en) {
          return Rt || (Rt = Qr), ke += o.slice(Ce, en).replace(te, tA), Ot && (oe = !0, ke += `' +
__e(` + Ot + `) +
'`), jr && (he = !0, ke += `';
` + jr + `;
__p += '`), Rt && (ke += `' +
((__t = (` + Rt + `)) == null ? '' : __t) +
'`), Ce = en + st.length, st;
        }), ke += `';
`;
        var it = Ft.call(f, "variable") && f.variable;
        if (!it)
          ke = `with (obj) {
` + ke + `
}
`;
        else if (Ye.test(it))
          throw new ft(u);
        ke = (he ? ke.replace(It, "") : ke).replace($o, "$1").replace(Eo, "$1;"), ke = "function(" + (it || "obj") + `) {
` + (it ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (oe ? ", __e = _.escape" : "") + (he ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + ke + `return __p
}`;
        var bt = Xb(function() {
          return Nt(H, Je + "return " + ke).apply(r, ee);
        });
        if (bt.source = ke, gp(bt))
          throw bt;
        return bt;
      }
      function Sj(o) {
        return qt(o).toLowerCase();
      }
      function Aj(o) {
        return qt(o).toUpperCase();
      }
      function Cj(o, f, b) {
        if (o = qt(o), o && (b || f === r))
          return ov(o);
        if (!o || !(f = Jr(f)))
          return o;
        var P = _n(o), M = _n(f), H = uv(P, M), ee = cv(P, M) + 1;
        return Wi(P, H, ee).join("");
      }
      function Rj(o, f, b) {
        if (o = qt(o), o && (b || f === r))
          return o.slice(0, fv(o) + 1);
        if (!o || !(f = Jr(f)))
          return o;
        var P = _n(o), M = cv(P, _n(f)) + 1;
        return Wi(P, 0, M).join("");
      }
      function Tj(o, f, b) {
        if (o = qt(o), o && (b || f === r))
          return o.replace(Di, "");
        if (!o || !(f = Jr(f)))
          return o;
        var P = _n(o), M = uv(P, _n(f));
        return Wi(P, M).join("");
      }
      function Ij(o, f) {
        var b = ae, P = ye;
        if (Yt(f)) {
          var M = "separator" in f ? f.separator : M;
          b = "length" in f ? gt(f.length) : b, P = "omission" in f ? Jr(f.omission) : P;
        }
        o = qt(o);
        var H = o.length;
        if (ma(o)) {
          var ee = _n(o);
          H = ee.length;
        }
        if (b >= H)
          return o;
        var oe = b - ya(P);
        if (oe < 1)
          return P;
        var he = ee ? Wi(ee, 0, oe).join("") : o.slice(0, oe);
        if (M === r)
          return he + P;
        if (ee && (oe += he.length - oe), vp(M)) {
          if (o.slice(oe).search(M)) {
            var Ce, Re = he;
            for (M.global || (M = kd(M.source, qt(Lt.exec(M)) + "g")), M.lastIndex = 0; Ce = M.exec(Re); )
              var ke = Ce.index;
            he = he.slice(0, ke === r ? oe : ke);
          }
        } else if (o.indexOf(Jr(M), oe) != oe) {
          var Ue = he.lastIndexOf(M);
          Ue > -1 && (he = he.slice(0, Ue));
        }
        return he + P;
      }
      function jj(o) {
        return o = qt(o), o && xo.test(o) ? o.replace(ua, uA) : o;
      }
      var kj = Ea(function(o, f, b) {
        return o + (b ? " " : "") + f.toUpperCase();
      }), wp = Qv("toUpperCase");
      function Jb(o, f, b) {
        return o = qt(o), f = b ? r : f, f === r ? nA(o) ? fA(o) : GS(o) : o.match(f) || [];
      }
      var Xb = $t(function(o, f) {
        try {
          return Kr(o, r, f);
        } catch (b) {
          return gp(b) ? b : new ft(b);
        }
      }), Mj = pi(function(o, f) {
        return an(f, function(b) {
          b = Zn(b), fi(o, b, mp(o[b], o));
        }), o;
      });
      function Nj(o) {
        var f = o == null ? 0 : o.length, b = nt();
        return o = f ? Kt(o, function(P) {
          if (typeof P[1] != "function")
            throw new on(a);
          return [b(P[0]), P[1]];
        }) : [], $t(function(P) {
          for (var M = -1; ++M < f; ) {
            var H = o[M];
            if (Kr(H[0], this, P))
              return Kr(H[1], this, P);
          }
        });
      }
      function Dj(o) {
        return uC(cn(o, p));
      }
      function $p(o) {
        return function() {
          return o;
        };
      }
      function Lj(o, f) {
        return o == null || o !== o ? f : o;
      }
      var qj = tb(), Fj = tb(!0);
      function zr(o) {
        return o;
      }
      function Ep(o) {
        return Tv(typeof o == "function" ? o : cn(o, p));
      }
      function Uj(o) {
        return jv(cn(o, p));
      }
      function Bj(o, f) {
        return kv(o, cn(f, p));
      }
      var Vj = $t(function(o, f) {
        return function(b) {
          return Lo(b, o, f);
        };
      }), Zj = $t(function(o, f) {
        return function(b) {
          return Lo(o, b, f);
        };
      });
      function xp(o, f, b) {
        var P = dr(f), M = jc(f, P);
        b == null && !(Yt(f) && (M.length || !P.length)) && (b = f, f = o, o = this, M = jc(f, dr(f)));
        var H = !(Yt(b) && "chain" in b) || !!b.chain, ee = mi(o);
        return an(M, function(oe) {
          var he = f[oe];
          o[oe] = he, ee && (o.prototype[oe] = function() {
            var Ce = this.__chain__;
            if (H || Ce) {
              var Re = o(this.__wrapped__), ke = Re.__actions__ = Br(this.__actions__);
              return ke.push({ func: he, args: arguments, thisArg: o }), Re.__chain__ = Ce, Re;
            }
            return he.apply(o, Fi([this.value()], arguments));
          });
        }), o;
      }
      function zj() {
        return mr._ === this && (mr._ = gA), this;
      }
      function Op() {
      }
      function Wj(o) {
        return o = gt(o), $t(function(f) {
          return Mv(f, o);
        });
      }
      var Hj = rp(Kt), Gj = rp(rv), Kj = rp(Sd);
      function Qb(o) {
        return cp(o) ? Ad(Zn(o)) : OC(o);
      }
      function Yj(o) {
        return function(f) {
          return o == null ? r : Ts(o, f);
        };
      }
      var Jj = nb(), Xj = nb(!0);
      function Pp() {
        return [];
      }
      function Sp() {
        return !1;
      }
      function Qj() {
        return {};
      }
      function ek() {
        return "";
      }
      function tk() {
        return !0;
      }
      function rk(o, f) {
        if (o = gt(o), o < 1 || o > Ae)
          return [];
        var b = K, P = wr(o, K);
        f = nt(f), o -= K;
        for (var M = Td(P, f); ++b < o; )
          f(b);
        return M;
      }
      function nk(o) {
        return pt(o) ? Kt(o, Zn) : Xr(o) ? [o] : Br(bb(qt(o)));
      }
      function ik(o) {
        var f = ++mA;
        return qt(o) + f;
      }
      var sk = qc(function(o, f) {
        return o + f;
      }, 0), ak = np("ceil"), ok = qc(function(o, f) {
        return o / f;
      }, 1), uk = np("floor");
      function ck(o) {
        return o && o.length ? Ic(o, zr, Bd) : r;
      }
      function lk(o, f) {
        return o && o.length ? Ic(o, nt(f, 2), Bd) : r;
      }
      function fk(o) {
        return sv(o, zr);
      }
      function dk(o, f) {
        return sv(o, nt(f, 2));
      }
      function pk(o) {
        return o && o.length ? Ic(o, zr, Wd) : r;
      }
      function hk(o, f) {
        return o && o.length ? Ic(o, nt(f, 2), Wd) : r;
      }
      var mk = qc(function(o, f) {
        return o * f;
      }, 1), yk = np("round"), gk = qc(function(o, f) {
        return o - f;
      }, 0);
      function vk(o) {
        return o && o.length ? Rd(o, zr) : 0;
      }
      function bk(o, f) {
        return o && o.length ? Rd(o, nt(f, 2)) : 0;
      }
      return B.after = UT, B.ary = Rb, B.assign = AI, B.assignIn = Zb, B.assignInWith = Xc, B.assignWith = CI, B.at = RI, B.before = Tb, B.bind = mp, B.bindAll = Mj, B.bindKey = Ib, B.castArray = QT, B.chain = Sb, B.chunk = uR, B.compact = cR, B.concat = lR, B.cond = Nj, B.conforms = Dj, B.constant = $p, B.countBy = vT, B.create = TI, B.curry = jb, B.curryRight = kb, B.debounce = Mb, B.defaults = II, B.defaultsDeep = jI, B.defer = BT, B.delay = VT, B.difference = fR, B.differenceBy = dR, B.differenceWith = pR, B.drop = hR, B.dropRight = mR, B.dropRightWhile = yR, B.dropWhile = gR, B.fill = vR, B.filter = _T, B.flatMap = ET, B.flatMapDeep = xT, B.flatMapDepth = OT, B.flatten = Eb, B.flattenDeep = bR, B.flattenDepth = _R, B.flip = ZT, B.flow = qj, B.flowRight = Fj, B.fromPairs = wR, B.functions = FI, B.functionsIn = UI, B.groupBy = PT, B.initial = ER, B.intersection = xR, B.intersectionBy = OR, B.intersectionWith = PR, B.invert = VI, B.invertBy = ZI, B.invokeMap = AT, B.iteratee = Ep, B.keyBy = CT, B.keys = dr, B.keysIn = Zr, B.map = Wc, B.mapKeys = WI, B.mapValues = HI, B.matches = Uj, B.matchesProperty = Bj, B.memoize = Gc, B.merge = GI, B.mergeWith = zb, B.method = Vj, B.methodOf = Zj, B.mixin = xp, B.negate = Kc, B.nthArg = Wj, B.omit = KI, B.omitBy = YI, B.once = zT, B.orderBy = RT, B.over = Hj, B.overArgs = WT, B.overEvery = Gj, B.overSome = Kj, B.partial = yp, B.partialRight = Nb, B.partition = TT, B.pick = JI, B.pickBy = Wb, B.property = Qb, B.propertyOf = Yj, B.pull = RR, B.pullAll = Ob, B.pullAllBy = TR, B.pullAllWith = IR, B.pullAt = jR, B.range = Jj, B.rangeRight = Xj, B.rearg = HT, B.reject = kT, B.remove = kR, B.rest = GT, B.reverse = pp, B.sampleSize = NT, B.set = QI, B.setWith = ej, B.shuffle = DT, B.slice = MR, B.sortBy = FT, B.sortedUniq = BR, B.sortedUniqBy = VR, B.split = Ej, B.spread = KT, B.tail = ZR, B.take = zR, B.takeRight = WR, B.takeRightWhile = HR, B.takeWhile = GR, B.tap = cT, B.throttle = YT, B.thru = zc, B.toArray = Ub, B.toPairs = Hb, B.toPairsIn = Gb, B.toPath = nk, B.toPlainObject = Vb, B.transform = tj, B.unary = JT, B.union = KR, B.unionBy = YR, B.unionWith = JR, B.uniq = XR, B.uniqBy = QR, B.uniqWith = eT, B.unset = rj, B.unzip = hp, B.unzipWith = Pb, B.update = nj, B.updateWith = ij, B.values = Pa, B.valuesIn = sj, B.without = tT, B.words = Jb, B.wrap = XT, B.xor = rT, B.xorBy = nT, B.xorWith = iT, B.zip = sT, B.zipObject = aT, B.zipObjectDeep = oT, B.zipWith = uT, B.entries = Hb, B.entriesIn = Gb, B.extend = Zb, B.extendWith = Xc, xp(B, B), B.add = sk, B.attempt = Xb, B.camelCase = cj, B.capitalize = Kb, B.ceil = ak, B.clamp = aj, B.clone = eI, B.cloneDeep = rI, B.cloneDeepWith = nI, B.cloneWith = tI, B.conformsTo = iI, B.deburr = Yb, B.defaultTo = Lj, B.divide = ok, B.endsWith = lj, B.eq = $n, B.escape = fj, B.escapeRegExp = dj, B.every = bT, B.find = wT, B.findIndex = wb, B.findKey = kI, B.findLast = $T, B.findLastIndex = $b, B.findLastKey = MI, B.floor = uk, B.forEach = Ab, B.forEachRight = Cb, B.forIn = NI, B.forInRight = DI, B.forOwn = LI, B.forOwnRight = qI, B.get = bp, B.gt = sI, B.gte = aI, B.has = BI, B.hasIn = _p, B.head = xb, B.identity = zr, B.includes = ST, B.indexOf = $R, B.inRange = oj, B.invoke = zI, B.isArguments = ks, B.isArray = pt, B.isArrayBuffer = oI, B.isArrayLike = Vr, B.isArrayLikeObject = er, B.isBoolean = uI, B.isBuffer = Hi, B.isDate = cI, B.isElement = lI, B.isEmpty = fI, B.isEqual = dI, B.isEqualWith = pI, B.isError = gp, B.isFinite = hI, B.isFunction = mi, B.isInteger = Db, B.isLength = Yc, B.isMap = Lb, B.isMatch = mI, B.isMatchWith = yI, B.isNaN = gI, B.isNative = vI, B.isNil = _I, B.isNull = bI, B.isNumber = qb, B.isObject = Yt, B.isObjectLike = Xt, B.isPlainObject = Zo, B.isRegExp = vp, B.isSafeInteger = wI, B.isSet = Fb, B.isString = Jc, B.isSymbol = Xr, B.isTypedArray = Oa, B.isUndefined = $I, B.isWeakMap = EI, B.isWeakSet = xI, B.join = SR, B.kebabCase = pj, B.last = fn, B.lastIndexOf = AR, B.lowerCase = hj, B.lowerFirst = mj, B.lt = OI, B.lte = PI, B.max = ck, B.maxBy = lk, B.mean = fk, B.meanBy = dk, B.min = pk, B.minBy = hk, B.stubArray = Pp, B.stubFalse = Sp, B.stubObject = Qj, B.stubString = ek, B.stubTrue = tk, B.multiply = mk, B.nth = CR, B.noConflict = zj, B.noop = Op, B.now = Hc, B.pad = yj, B.padEnd = gj, B.padStart = vj, B.parseInt = bj, B.random = uj, B.reduce = IT, B.reduceRight = jT, B.repeat = _j, B.replace = wj, B.result = XI, B.round = yk, B.runInContext = de, B.sample = MT, B.size = LT, B.snakeCase = $j, B.some = qT, B.sortedIndex = NR, B.sortedIndexBy = DR, B.sortedIndexOf = LR, B.sortedLastIndex = qR, B.sortedLastIndexBy = FR, B.sortedLastIndexOf = UR, B.startCase = xj, B.startsWith = Oj, B.subtract = gk, B.sum = vk, B.sumBy = bk, B.template = Pj, B.times = rk, B.toFinite = yi, B.toInteger = gt, B.toLength = Bb, B.toLower = Sj, B.toNumber = dn, B.toSafeInteger = SI, B.toString = qt, B.toUpper = Aj, B.trim = Cj, B.trimEnd = Rj, B.trimStart = Tj, B.truncate = Ij, B.unescape = jj, B.uniqueId = ik, B.upperCase = kj, B.upperFirst = wp, B.each = Ab, B.eachRight = Cb, B.first = xb, xp(B, function() {
        var o = {};
        return Bn(B, function(f, b) {
          Ft.call(B.prototype, b) || (o[b] = f);
        }), o;
      }(), { chain: !1 }), B.VERSION = i, an(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(o) {
        B[o].placeholder = B;
      }), an(["drop", "take"], function(o, f) {
        At.prototype[o] = function(b) {
          b = b === r ? 1 : cr(gt(b), 0);
          var P = this.__filtered__ && !f ? new At(this) : this.clone();
          return P.__filtered__ ? P.__takeCount__ = wr(b, P.__takeCount__) : P.__views__.push({
            size: wr(b, K),
            type: o + (P.__dir__ < 0 ? "Right" : "")
          }), P;
        }, At.prototype[o + "Right"] = function(b) {
          return this.reverse()[o](b).reverse();
        };
      }), an(["filter", "map", "takeWhile"], function(o, f) {
        var b = f + 1, P = b == re || b == le;
        At.prototype[o] = function(M) {
          var H = this.clone();
          return H.__iteratees__.push({
            iteratee: nt(M, 3),
            type: b
          }), H.__filtered__ = H.__filtered__ || P, H;
        };
      }), an(["head", "last"], function(o, f) {
        var b = "take" + (f ? "Right" : "");
        At.prototype[o] = function() {
          return this[b](1).value()[0];
        };
      }), an(["initial", "tail"], function(o, f) {
        var b = "drop" + (f ? "" : "Right");
        At.prototype[o] = function() {
          return this.__filtered__ ? new At(this) : this[b](1);
        };
      }), At.prototype.compact = function() {
        return this.filter(zr);
      }, At.prototype.find = function(o) {
        return this.filter(o).head();
      }, At.prototype.findLast = function(o) {
        return this.reverse().find(o);
      }, At.prototype.invokeMap = $t(function(o, f) {
        return typeof o == "function" ? new At(this) : this.map(function(b) {
          return Lo(b, o, f);
        });
      }), At.prototype.reject = function(o) {
        return this.filter(Kc(nt(o)));
      }, At.prototype.slice = function(o, f) {
        o = gt(o);
        var b = this;
        return b.__filtered__ && (o > 0 || f < 0) ? new At(b) : (o < 0 ? b = b.takeRight(-o) : o && (b = b.drop(o)), f !== r && (f = gt(f), b = f < 0 ? b.dropRight(-f) : b.take(f - o)), b);
      }, At.prototype.takeRightWhile = function(o) {
        return this.reverse().takeWhile(o).reverse();
      }, At.prototype.toArray = function() {
        return this.take(K);
      }, Bn(At.prototype, function(o, f) {
        var b = /^(?:filter|find|map|reject)|While$/.test(f), P = /^(?:head|last)$/.test(f), M = B[P ? "take" + (f == "last" ? "Right" : "") : f], H = P || /^find/.test(f);
        M && (B.prototype[f] = function() {
          var ee = this.__wrapped__, oe = P ? [1] : arguments, he = ee instanceof At, Ce = oe[0], Re = he || pt(ee), ke = function(Ot) {
            var Rt = M.apply(B, Fi([Ot], oe));
            return P && Ue ? Rt[0] : Rt;
          };
          Re && b && typeof Ce == "function" && Ce.length != 1 && (he = Re = !1);
          var Ue = this.__chain__, Je = !!this.__actions__.length, it = H && !Ue, bt = he && !Je;
          if (!H && Re) {
            ee = bt ? ee : new At(this);
            var st = o.apply(ee, oe);
            return st.__actions__.push({ func: zc, args: [ke], thisArg: r }), new un(st, Ue);
          }
          return it && bt ? o.apply(this, oe) : (st = this.thru(ke), it ? P ? st.value()[0] : st.value() : st);
        });
      }), an(["pop", "push", "shift", "sort", "splice", "unshift"], function(o) {
        var f = gc[o], b = /^(?:push|sort|unshift)$/.test(o) ? "tap" : "thru", P = /^(?:pop|shift)$/.test(o);
        B.prototype[o] = function() {
          var M = arguments;
          if (P && !this.__chain__) {
            var H = this.value();
            return f.apply(pt(H) ? H : [], M);
          }
          return this[b](function(ee) {
            return f.apply(pt(ee) ? ee : [], M);
          });
        };
      }), Bn(At.prototype, function(o, f) {
        var b = B[f];
        if (b) {
          var P = b.name + "";
          Ft.call(_a, P) || (_a[P] = []), _a[P].push({ name: f, func: b });
        }
      }), _a[Lc(r, m).name] = [{
        name: "wrapper",
        func: r
      }], At.prototype.clone = jA, At.prototype.reverse = kA, At.prototype.value = MA, B.prototype.at = lT, B.prototype.chain = fT, B.prototype.commit = dT, B.prototype.next = pT, B.prototype.plant = mT, B.prototype.reverse = yT, B.prototype.toJSON = B.prototype.valueOf = B.prototype.value = gT, B.prototype.first = B.prototype.head, To && (B.prototype[To] = hT), B;
    }, ga = dA();
    Ps ? ((Ps.exports = ga)._ = ga, Ed._ = ga) : mr._ = ga;
  }).call(rt);
})(Rf, Rf.exports);
var TH = Rf.exports;
const IH = /* @__PURE__ */ ta(TH), bS = (e) => {
  const t = {};
  return Object.keys(e.schema.paths).map((r) => {
    const i = r.replace("/", "");
    t[i] = async (n) => new Promise((s, a) => {
      e.fns[i].fn({
        ...n,
        onData: n == null ? void 0 : n.onData,
        onDone: s,
        onError: a
      });
    });
  }), t;
}, _S = async ({ id: e, desc: t, version: r }) => {
  const i = {}, n = {}, s = {};
  return {
    addMethod: ({ id: u, fn: c, desc: l, settings: d }) => {
      i[u] = {
        fn: async (h) => c(h),
        settings: d,
        desc: l
      };
      const p = {
        addInput: ({ schema: h }) => {
          if (n[u])
            throw new Error(`Method ${u} already has an input, only one input per method allowed`);
          return n[u] = g$({ schema: h }), p;
        },
        addOutput: ({ schema: h, desc: v, code: y }) => (s[u] || (s[u] = []), s[u].push({ schema: g$({ schema: h }), desc: v, code: y }), p),
        setMultiplier: ({ multiplier: h }) => {
          var v;
          return (v = i[u]) != null && v.settings || (i[u].settings = {}), i[u].settings = { ...i[u].settings, multiplier: h }, p;
        }
      };
      return p;
    },
    run: async () => {
      const u = {};
      Object.keys(i).forEach((v) => {
        var g;
        const y = {
          required: !1,
          content: {}
        };
        u[`/${v}`] = {
          post: {
            summary: i[v].desc,
            operationId: v,
            tags: (g = IH.keys(i[v].settings)) == null ? void 0 : g.map((_) => {
              var w, $;
              const m = ($ = (w = i[v]) == null ? void 0 : w.settings) == null ? void 0 : $[_];
              return `${_}=${m}`;
            }),
            //FNS[fn_id].settings?.free ? ["free=true"] : [],
            requestBody: n[v] ? {
              required: !0,
              content: {
                "application/json": {
                  schema: n[v]
                }
              }
            } : y,
            responses: {}
          }
        }, s[v].forEach((_) => {
          u[`/${v}`].post.responses[_.code] = {
            description: _.desc,
            content: {
              "application/json": {
                schema: _.schema
              }
            }
          };
        });
      });
      const c = {};
      Object.keys(i).forEach((v) => {
        c[v] = {
          fn: i[v].fn,
          desc: i[v].desc,
          settings: i[v].settings
        };
      });
      const l = {
        id: e,
        fns: c,
        schema: {
          openapi: "3.0.0",
          info: {
            title: e,
            description: t,
            version: r || "1.0.0"
          },
          paths: u
        }
      }, [d, p, h] = await vS(l.schema, {
        fullResult: !0
      });
      if (p)
        throw new Error(`Module ${e} verification failed: ${p.message()}`);
      return l;
    }
  };
}, N2 = new Ju({ ttl: 1e4 }), D2 = new Ju({ ttl: 1e4 }), L2 = new Ju({ ttl: 1e4 }), jH = async ({ user_id: e }) => {
  const t = N2.get(e);
  if (t)
    return t;
  const r = await gd({
    ms: 15e3,
    fn: fetch("https://wallet.promptc0.com/getStatus", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ user_id: e })
    })
  }).then((i) => "json" in i && i.json());
  return !r || "error" in r || typeof r.result === void 0 ? !1 : (N2.put(e, r.result), r.result);
}, kH = async ({ user_id: e }) => {
  const t = D2.get(e);
  if (t)
    return t;
  const r = await gd({
    ms: 15e3,
    fn: fetch("https://wallet.promptc0.com/getBalance", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ user_id: e })
    })
  }).then((i) => "json" in i && i.json());
  return !r || "error" in r || typeof r.result === void 0 ? !1 : (D2.put(e, r.result), r.result);
}, MH = async ({ user_id: e }) => {
  const t = L2.get(e);
  if (t)
    return t;
  const r = await gd({
    ms: 15e3,
    fn: fetch("https://wallet.promptc0.com/getBalance", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ user_id: e })
    })
  }).then((i) => "json" in i && i.json());
  return !r || "error" in r || typeof r.result === void 0 ? !1 : (L2.put(e, r.result), r.result);
}, NH = async ({ receipt: e }) => gd({
  ms: 15e3,
  fn: fetch("https://wallet.promptc0.com/charge", {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify({ receipt: e })
  }).then((t) => t.json())
}), $l = yd("module:handshake"), ag = async () => {
  const e = await _S({
    id: "wallet",
    desc: "Wallet module",
    version: "1.0.0"
  });
  return e.addMethod({
    id: "getStatus",
    desc: "Get wallet status",
    fn: async ({ onData: t, onError: r, onDone: i, user_id: n }) => {
      const s = await jH({ user_id: n });
      return !s || "error" in s ? r({ error: (s == null ? void 0 : s.error) || "Unknown error", code: 500 }) : ($l(`fetched status ${s} for ${n}`), i({ result: s }), {
        abort: () => {
        }
      });
    }
  }).addInput({
    schema: Te.object({
      user_id: Te.string()
    })
  }).addOutput({
    code: 200,
    desc: "Returns wallet status",
    schema: Te.object({
      result: Te.string()
    })
  }), e.addMethod({
    id: "getBalance",
    desc: "Get wallet balance",
    fn: async ({ onData: t, onError: r, onDone: i, user_id: n }) => {
      const s = await kH({ user_id: n });
      return typeof s === void 0 || typeof s == "object" && "error" in s ? r({ error: (s == null ? void 0 : s.error) || "Unknown error", code: 500 }) : ($l(`fetched balance ${s} for ${n}`), i({ result: s }), {
        abort: () => {
        }
      });
    }
  }).addInput({
    schema: Te.object({
      user_id: Te.string()
    })
  }).addOutput({
    code: 200,
    desc: "Returns wallet balance",
    schema: Te.object({
      result: Te.number()
    })
  }), e.addMethod({
    id: "getSubsidizedBalance",
    desc: "Get wallet's subsidized credits",
    fn: async ({ onData: t, onError: r, onDone: i, user_id: n }) => {
      const s = await MH({ user_id: n });
      return !s || "error" in s ? r({ error: (s == null ? void 0 : s.error) || "Unknown error", code: 500 }) : ($l(`fetched subsidized balance ${s} for ${n}`), i({ result: s }), {
        abort: () => {
        }
      });
    }
  }).addInput({
    schema: Te.object({
      user_id: Te.string()
    })
  }).addOutput({
    code: 200,
    desc: "Returns wallet's subsidized credits",
    schema: Te.object({
      result: Te.number()
    })
  }), e.addMethod({
    id: "charge",
    desc: "Charge wallet",
    fn: async ({ onData: t, onError: r, onDone: i, receipt: n }) => {
      const s = await NH({ receipt: n });
      return s && "error" in s ? r({ error: s.error, code: 500 }) : ($l(`charged wallet ${n.user_id} with ${n.amount}`), i({ result: s.body }), {
        abort: () => {
        }
      });
    }
  }).addInput({
    schema: Te.object({
      receipt: og
    })
  }).addOutput({
    code: 200,
    desc: "Charge wallet",
    schema: Te.object({
      result: Te.number()
    })
  }), e.run();
};
async function q2({
  input: e,
  globals: t,
  request: r
}) {
  var y;
  const { MODULES: i, PROTOCOLS: n, REQUESTS: s } = t;
  if (s[e.id])
    return;
  e.offer.call.module_id !== "handshake" && (s[e.id] = !0);
  const { call: a } = e.offer, u = a.method_id.replace("/", ""), c = i.find(
    (g) => g.id === a.module_id && g.schema.paths[`/${a.method_id}`] && g.fns[u]
  );
  if (!c)
    return r.onError({ error: `Unknown call ${a.module_id}`, code: 404 });
  if (typeof ((y = c.fns[u]) == null ? void 0 : y.fn) != "function")
    return r.onError({ error: "Function id references are not supported yet", code: 404 });
  const l = {
    openapi: "3.0.0",
    ...c.schema
  };
  l.info.title = c.id;
  const [d, p, h] = await vS(l, {
    fullResult: !0
  });
  if (p)
    return r.onError({ error: p.message(), code: 500 });
  h && console.warn(h.message);
  const v = c.fns[u].fn;
  if (console.log(`Executing ${a.module_id}:${a.method_id} / ${e.id}`), typeof v == "function") {
    let g = 0;
    const _ = async ($) => {
      const E = $ == null ? void 0 : $.data;
      E && (g += Ul(E)), r != null && r.onData && r.onData($);
    }, m = async ($) => {
      var R, I;
      const E = {
        id: Uf(),
        user_id: e.meta.user_id,
        offer: e.offer,
        details: {
          input: {
            bytes: 0,
            tokens: 0
          },
          output: {
            bytes: 0,
            tokens: 0
          }
        },
        total_bytes: 0,
        total_tokens: 0
      };
      let A = 0;
      if (e != null && e.signed_transaction && ((R = e == null ? void 0 : e.offer) != null && R.multiplier)) {
        let D = g;
        $ != null && $.data && (D = Ul($ == null ? void 0 : $.data)), A = ((I = c.fns[u].settings) == null ? void 0 : I.multiplier) || 0;
        const J = Ul(e.params || 0);
        E.details = {
          input: {
            bytes: J,
            tokens: J * A
          },
          output: {
            bytes: D,
            tokens: A * D
          }
        }, E.total_tokens = E.details.input.tokens + E.details.output.tokens, E.total_bytes = E.details.input.bytes + E.details.output.bytes;
        const ae = await Ef(JSON.stringify(E), xf({ input: t.private_key }));
        E.sig = rn({ input: ae });
        const ye = og.safeParse(E);
        if (!ye.success)
          return (r == null ? void 0 : r.onError) && r.onError({ error: "invalid receipt", code: 500 });
        $.receipt = ye.data;
        const xe = bS(await ag());
        try {
          const je = await xe.charge({
            receipt: $.receipt
          });
        } catch (je) {
          return (r == null ? void 0 : r.onError) && r.onError(je);
        }
      }
      r != null && r.onDone && r.onDone($);
    }, w = await v({
      stripe: t.stripe,
      ...e.params,
      user_id: e.meta.user_id,
      onData: _,
      onDone: m,
      onError: r.onError
    });
    return typeof w == "object" && "error" in w ? r.onError({ ...w == null ? void 0 : w.error }) : (e.offer.id !== "handshake" && (s[e.id] = w), w);
  } else
    return r.onError({ error: `Unknown function ${e.offer.call.method_id}`, code: 404 });
}
const DH = yd("module:handshake"), LH = async () => {
  const e = await _S({
    id: "handshake",
    desc: "Handshake module",
    version: "1.0.0"
  });
  return e.addMethod({
    id: "challenge",
    fn: async ({ onData: t, onError: r, onDone: i, request_id: n, ip: s }) => {
      const a = await Lz({ request_id: n, ip: s || "localhost" });
      return DH(`generated challenge ${a} for ${n}`), i && i({ result: a }), {
        abort: () => {
        }
      };
    },
    desc: "Generate security challenge",
    settings: { free: !0 }
  }).addInput({
    schema: Te.object({
      request_id: Te.string(),
      ip: Te.string()
    })
  }).addOutput({
    code: 200,
    desc: "Returns a random nonce for signing",
    schema: Te.object({
      result: Te.string()
    })
  }), e.run();
}, nu = yd("server"), Na = [], Gm = [], Km = {}, Ym = {};
async function qH({
  modules: e,
  private_key: t,
  protocols: r,
  globals: i,
  type: n = "events",
  no_auth: s = !1,
  host: a = "127.0.0.1",
  port: u = 8080
}) {
  if (t || (t = (await HP()).private_key), i)
    for (const l in i)
      nu(`setting global ${l}`), Km[l] = i[l];
  e = [...e, await LH(), await ag()];
  for (const l of e) {
    if (!n1.safeParse(l).success)
      throw nu(`invalid module ${l.id}`), new Error("Invalid Module");
    Na.push(l), nu(`loaded module ${l.id}`);
  }
  if (r)
    for (const l of r) {
      if (!ty.safeParse(l).success)
        throw new Error("Invalid Protocol");
      Gm.push(l), nu(`loaded protocol ${l.id}`);
    }
  const c = {
    getModules: () => Na,
    execute: async function({
      input: l,
      globals: d,
      onData: p,
      onDone: h,
      onError: v
    }) {
      var $, E, A, R;
      nu(`executing ${l.offer.call.module_id}:${l.offer.call.method_id} / ${l.id}`);
      const y = ty.safeParse(l);
      if (!y.success)
        return { error: "Invalid payload", code: 400 };
      if (!s && l.offer.call.module_id === "handshake" && l.offer.call.method_id === "challenge") {
        const I = async (D) => {
          const J = D.result;
          if (!J)
            return v({ error: "Invalid challenge", code: 400 });
          h({ request_id: l.id, status: "challenge", data: { challenge: J } });
        };
        return q2({
          input: { ...y.data, params: { request_id: l.id, ip: (d == null ? void 0 : d.ip) || "localhost" } },
          globals: { MODULES: Na, PROTOCOLS: Gm, REQUESTS: Ym, ...Km, ...d },
          request: {
            request_id: l.id,
            abort: async () => {
            },
            setAbort: async () => {
            },
            onDone: I,
            onError: v
          },
          onData: p,
          onDone: I,
          onError: v
        });
      }
      if (!s && !await Uz({ ...l, request_id: l.id, ip: (d == null ? void 0 : d.ip) || "localhost" }))
        return { error: "Unauthorized", code: 401 };
      const g = Na.find((I) => I.id === l.offer.call.module_id), _ = (E = ($ = g == null ? void 0 : g.schema) == null ? void 0 : $.paths[`/${l.offer.call.method_id}`]) == null ? void 0 : E.post;
      if (!_)
        return { error: "Invalid module method", code: 404 };
      const m = Dz(((R = (A = _.tags) == null ? void 0 : A.find((I) => I.startsWith("multiplier="))) == null ? void 0 : R.split("=")[1]) || "0");
      if (m && typeof m == "number") {
        if (!l.signed_transaction)
          return { error: "Missing tx", code: 400 };
        if (!K2.safeParse(l.signed_transaction).success)
          return { error: "Invalid tx", code: 400 };
        const D = await bS(await ag()).getBalance({ user_id: l.meta.user_id }) || 0;
        if ((D == null ? void 0 : D.result) === void 0)
          return { error: "Invalid balance", code: 400 };
        if (await Ul(l.params || {}) * m > (D == null ? void 0 : D.result))
          return { error: "Insufficient balance", code: 402 };
      }
      const w = await _k({
        module_id: l.offer.call.module_id,
        method_id: l.offer.call.method_id,
        request_id: l.id,
        onData: p,
        onDone: h,
        onError: v,
        tx: l.signed_transaction || void 0
      });
      return "error" in w ? { error: w.error, code: 500 } : q2({
        input: { ...y.data, params: (l == null ? void 0 : l.params) || null },
        globals: { MODULES: Na, PROTOCOLS: Gm, REQUESTS: Ym, ...Km, ...d, private_key: t },
        request: w,
        onData: p,
        onDone: h,
        onError: v
      });
    },
    abort: async function({ request_id: l }) {
      const d = Ym[l];
      return d ? typeof d == "object" && d.abort() : { error: "Unknown request", code: 404 };
    },
    registerModule: async function({ module: l }) {
      return n1.safeParse(l).success ? (Na.push(l), { code: 200 }) : { error: "Invalid Module", code: 400 };
    },
    signOffer: async function(l) {
      if (!t)
        return { error: "No private key", code: 500 };
      const d = co({ str: JSON.stringify(l) }), p = await Ef(d, xf({ input: t }));
      return {
        ...l,
        id: Uf(),
        sig: {
          c: rn({ input: d }),
          s: rn({ input: p }),
          pk: await Bz({ private_key: t })
        }
      };
    }
  };
  switch (n) {
    case "events":
      Wz({ API: c });
      break;
    case "websocket":
      Yz({ API: c, host: a, port: u });
      break;
  }
  return c;
}
async function YH({
  host: e,
  type: t = "events",
  server_modules: r = [],
  server_private_key: i
}) {
  let n;
  switch (t) {
    case "websocket":
      n = Gz;
      break;
    case "events":
      n = zz;
      break;
  }
  const s = {
    request: async ({ user: a, offer: u, params: c, tx: l }) => {
      var E, A, R;
      const d = Uf(), p = new Promise((I, D) => {
        const J = setTimeout(
          () => {
            D("timeout");
          },
          Mz() ? 1e6 : 1e4
        );
        s.compute({
          onData: () => {
          },
          onDone: (ae) => {
            clearTimeout(J), I(ae.data);
          },
          onError: (ae) => {
            clearTimeout(J), D(ae);
          },
          request: {
            id: d,
            meta: {
              user_id: a.user_id
            },
            params: c,
            offer: {
              id: "handshake",
              call: {
                module_id: "handshake",
                method_id: "challenge"
              },
              sig: {
                n: "",
                c: "",
                s: "",
                pk: a.public_key
              }
            },
            auth: {
              n: "",
              c: "",
              s: "",
              pk: a.public_key
            }
          }
        });
      }), [h] = await Promise.all([p]);
      if (!((E = h == null ? void 0 : h.data) != null && E.challenge))
        return { error: "Invalid challenge", code: 400 };
      const v = co({
        str: JSON.stringify({ offer: u, params: c || {}, nonce: (A = h == null ? void 0 : h.data) == null ? void 0 : A.challenge, request_id: d })
      });
      rn({ input: v });
      const y = await Ef(v, xf({ input: a.private_key })), g = {
        n: (R = h == null ? void 0 : h.data) == null ? void 0 : R.challenge,
        c: rn({ input: v }),
        s: rn({ input: y }),
        pk: a.public_key
      }, _ = co({
        str: JSON.stringify({ offer: u, params: c || {}, request_id: d, max_spent: (l == null ? void 0 : l.max_spent) || 0 })
      }), m = await Ef(_, xf({ input: a.private_key })), w = {
        max_spent: (l == null ? void 0 : l.max_spent) || 0,
        signature: {
          c: rn({ input: _ }),
          s: rn({ input: m }),
          pk: a.public_key
        }
      };
      return {
        id: d,
        meta: {
          user_id: a.user_id
        },
        params: c,
        auth: g,
        signed_transaction: w,
        offer: u
      };
    },
    compute: async ({ request: a, onData: u, onDone: c, onError: l }) => {
      if (!n)
        return { error: "Invalid channel type", code: 400 };
      const { write: d, close: p } = await n({
        request_id: a.id,
        host: e,
        onData: u,
        onDone: c,
        onError: l
      });
      return d({ input: a }), {
        abort: () => {
          d({ input: a, abort: !0 });
        }
      };
    }
  };
  if (e === "localhost") {
    const a = await qH({
      modules: r,
      type: "events",
      private_key: i || void 0
    });
    if ("error" in a)
      throw new Error(JSON.stringify(a.error));
  }
  return s;
}
export {
  YH as Client,
  _k as Request,
  qH as Server,
  g$ as convertZod,
  KH as generateUser,
  _S as moduleGenerator,
  Te as z
};
//# sourceMappingURL=bundle.js.map
