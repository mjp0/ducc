async function Ek({
  tx: e,
  onData: t,
  onDone: r,
  onError: n,
  request_id: i,
  method_id: s,
  module_id: a
}) {
  const c = {
    request_id: i,
    tx: e,
    abort: async () => {
    },
    setAbort: async (l) => {
      c.abort = l;
    },
    ...{
      onData: async (l) => {
        t && t(l);
      },
      onDone: async (l) => {
        r && r(l);
      },
      onError: async (l) => {
        n && n(l);
      }
    }
  };
  return c;
}
var kt;
(function(e) {
  e.assertEqual = (i) => i;
  function t(i) {
  }
  e.assertIs = t;
  function r(i) {
    throw new Error();
  }
  e.assertNever = r, e.arrayToEnum = (i) => {
    const s = {};
    for (const a of i)
      s[a] = a;
    return s;
  }, e.getValidEnumValues = (i) => {
    const s = e.objectKeys(i).filter((u) => typeof i[i[u]] != "number"), a = {};
    for (const u of s)
      a[u] = i[u];
    return e.objectValues(a);
  }, e.objectValues = (i) => e.objectKeys(i).map(function(s) {
    return i[s];
  }), e.objectKeys = typeof Object.keys == "function" ? (i) => Object.keys(i) : (i) => {
    const s = [];
    for (const a in i)
      Object.prototype.hasOwnProperty.call(i, a) && s.push(a);
    return s;
  }, e.find = (i, s) => {
    for (const a of i)
      if (s(a))
        return a;
  }, e.isInteger = typeof Number.isInteger == "function" ? (i) => Number.isInteger(i) : (i) => typeof i == "number" && isFinite(i) && Math.floor(i) === i;
  function n(i, s = " | ") {
    return i.map((a) => typeof a == "string" ? `'${a}'` : a).join(s);
  }
  e.joinValues = n, e.jsonStringifyReplacer = (i, s) => typeof s == "bigint" ? s.toString() : s;
})(kt || (kt = {}));
var Ym;
(function(e) {
  e.mergeShapes = (t, r) => ({
    ...t,
    ...r
    // second overwrites first
  });
})(Ym || (Ym = {}));
const Ve = kt.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), ns = (e) => {
  switch (typeof e) {
    case "undefined":
      return Ve.undefined;
    case "string":
      return Ve.string;
    case "number":
      return isNaN(e) ? Ve.nan : Ve.number;
    case "boolean":
      return Ve.boolean;
    case "function":
      return Ve.function;
    case "bigint":
      return Ve.bigint;
    case "symbol":
      return Ve.symbol;
    case "object":
      return Array.isArray(e) ? Ve.array : e === null ? Ve.null : e.then && typeof e.then == "function" && e.catch && typeof e.catch == "function" ? Ve.promise : typeof Map < "u" && e instanceof Map ? Ve.map : typeof Set < "u" && e instanceof Set ? Ve.set : typeof Date < "u" && e instanceof Date ? Ve.date : Ve.object;
    default:
      return Ve.unknown;
  }
}, De = kt.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]), xk = (e) => JSON.stringify(e, null, 2).replace(/"([^"]+)":/g, "$1:");
let Tn = class extends Error {
  constructor(t) {
    super(), this.issues = [], this.addIssue = (n) => {
      this.issues = [...this.issues, n];
    }, this.addIssues = (n = []) => {
      this.issues = [...this.issues, ...n];
    };
    const r = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, r) : this.__proto__ = r, this.name = "ZodError", this.issues = t;
  }
  get errors() {
    return this.issues;
  }
  format(t) {
    const r = t || function(s) {
      return s.message;
    }, n = { _errors: [] }, i = (s) => {
      for (const a of s.issues)
        if (a.code === "invalid_union")
          a.unionErrors.map(i);
        else if (a.code === "invalid_return_type")
          i(a.returnTypeError);
        else if (a.code === "invalid_arguments")
          i(a.argumentsError);
        else if (a.path.length === 0)
          n._errors.push(r(a));
        else {
          let u = n, c = 0;
          for (; c < a.path.length; ) {
            const l = a.path[c];
            c === a.path.length - 1 ? (u[l] = u[l] || { _errors: [] }, u[l]._errors.push(r(a))) : u[l] = u[l] || { _errors: [] }, u = u[l], c++;
          }
        }
    };
    return i(this), n;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, kt.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(t = (r) => r.message) {
    const r = {}, n = [];
    for (const i of this.issues)
      i.path.length > 0 ? (r[i.path[0]] = r[i.path[0]] || [], r[i.path[0]].push(t(i))) : n.push(t(i));
    return { formErrors: n, fieldErrors: r };
  }
  get formErrors() {
    return this.flatten();
  }
};
Tn.create = (e) => new Tn(e);
const vu = (e, t) => {
  let r;
  switch (e.code) {
    case De.invalid_type:
      e.received === Ve.undefined ? r = "Required" : r = `Expected ${e.expected}, received ${e.received}`;
      break;
    case De.invalid_literal:
      r = `Invalid literal value, expected ${JSON.stringify(e.expected, kt.jsonStringifyReplacer)}`;
      break;
    case De.unrecognized_keys:
      r = `Unrecognized key(s) in object: ${kt.joinValues(e.keys, ", ")}`;
      break;
    case De.invalid_union:
      r = "Invalid input";
      break;
    case De.invalid_union_discriminator:
      r = `Invalid discriminator value. Expected ${kt.joinValues(e.options)}`;
      break;
    case De.invalid_enum_value:
      r = `Invalid enum value. Expected ${kt.joinValues(e.options)}, received '${e.received}'`;
      break;
    case De.invalid_arguments:
      r = "Invalid function arguments";
      break;
    case De.invalid_return_type:
      r = "Invalid function return type";
      break;
    case De.invalid_date:
      r = "Invalid date";
      break;
    case De.invalid_string:
      typeof e.validation == "object" ? "includes" in e.validation ? (r = `Invalid input: must include "${e.validation.includes}"`, typeof e.validation.position == "number" && (r = `${r} at one or more positions greater than or equal to ${e.validation.position}`)) : "startsWith" in e.validation ? r = `Invalid input: must start with "${e.validation.startsWith}"` : "endsWith" in e.validation ? r = `Invalid input: must end with "${e.validation.endsWith}"` : kt.assertNever(e.validation) : e.validation !== "regex" ? r = `Invalid ${e.validation}` : r = "Invalid";
      break;
    case De.too_small:
      e.type === "array" ? r = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "more than"} ${e.minimum} element(s)` : e.type === "string" ? r = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "over"} ${e.minimum} character(s)` : e.type === "number" ? r = `Number must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${e.minimum}` : e.type === "date" ? r = `Date must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(e.minimum))}` : r = "Invalid input";
      break;
    case De.too_big:
      e.type === "array" ? r = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "less than"} ${e.maximum} element(s)` : e.type === "string" ? r = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "under"} ${e.maximum} character(s)` : e.type === "number" ? r = `Number must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "bigint" ? r = `BigInt must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "date" ? r = `Date must be ${e.exact ? "exactly" : e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(e.maximum))}` : r = "Invalid input";
      break;
    case De.custom:
      r = "Invalid input";
      break;
    case De.invalid_intersection_types:
      r = "Intersection results could not be merged";
      break;
    case De.not_multiple_of:
      r = `Number must be a multiple of ${e.multipleOf}`;
      break;
    case De.not_finite:
      r = "Number must be finite";
      break;
    default:
      r = t.defaultError, kt.assertNever(e);
  }
  return { message: r };
};
let V2 = vu;
function Ok(e) {
  V2 = e;
}
function Zl() {
  return V2;
}
const zl = (e) => {
  const { data: t, path: r, errorMaps: n, issueData: i } = e, s = [...r, ...i.path || []], a = {
    ...i,
    path: s
  };
  let u = "";
  const c = n.filter((l) => !!l).slice().reverse();
  for (const l of c)
    u = l(a, { data: t, defaultError: u }).message;
  return {
    ...i,
    path: s,
    message: i.message || u
  };
}, Pk = [];
function We(e, t) {
  const r = zl({
    issueData: t,
    data: e.data,
    path: e.path,
    errorMaps: [
      e.common.contextualErrorMap,
      e.schemaErrorMap,
      Zl(),
      vu
      // then global default map
    ].filter((n) => !!n)
  });
  e.common.issues.push(r);
}
class Ar {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(t, r) {
    const n = [];
    for (const i of r) {
      if (i.status === "aborted")
        return dt;
      i.status === "dirty" && t.dirty(), n.push(i.value);
    }
    return { status: t.value, value: n };
  }
  static async mergeObjectAsync(t, r) {
    const n = [];
    for (const i of r)
      n.push({
        key: await i.key,
        value: await i.value
      });
    return Ar.mergeObjectSync(t, n);
  }
  static mergeObjectSync(t, r) {
    const n = {};
    for (const i of r) {
      const { key: s, value: a } = i;
      if (s.status === "aborted" || a.status === "aborted")
        return dt;
      s.status === "dirty" && t.dirty(), a.status === "dirty" && t.dirty(), s.value !== "__proto__" && (typeof a.value < "u" || i.alwaysSet) && (n[s.value] = a.value);
    }
    return { status: t.value, value: n };
  }
}
const dt = Object.freeze({
  status: "aborted"
}), Z2 = (e) => ({ status: "dirty", value: e }), Dr = (e) => ({ status: "valid", value: e }), Jm = (e) => e.status === "aborted", Xm = (e) => e.status === "dirty", bu = (e) => e.status === "valid", Wl = (e) => typeof Promise < "u" && e instanceof Promise;
var tt;
(function(e) {
  e.errToObj = (t) => typeof t == "string" ? { message: t } : t || {}, e.toString = (t) => typeof t == "string" ? t : t == null ? void 0 : t.message;
})(tt || (tt = {}));
class ri {
  constructor(t, r, n, i) {
    this._cachedPath = [], this.parent = t, this.data = r, this._path = n, this._key = i;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
}
const r1 = (e, t) => {
  if (bu(t))
    return { success: !0, data: t.value };
  if (!e.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      const r = new Tn(e.common.issues);
      return this._error = r, this._error;
    }
  };
};
function yt(e) {
  if (!e)
    return {};
  const { errorMap: t, invalid_type_error: r, required_error: n, description: i } = e;
  if (t && (r || n))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return t ? { errorMap: t, description: i } : { errorMap: (a, u) => a.code !== "invalid_type" ? { message: u.defaultError } : typeof u.data > "u" ? { message: n ?? u.defaultError } : { message: r ?? u.defaultError }, description: i };
}
class _t {
  constructor(t) {
    this.spa = this.safeParseAsync, this._def = t, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(t) {
    return ns(t.data);
  }
  _getOrReturnCtx(t, r) {
    return r || {
      common: t.parent.common,
      data: t.data,
      parsedType: ns(t.data),
      schemaErrorMap: this._def.errorMap,
      path: t.path,
      parent: t.parent
    };
  }
  _processInputParams(t) {
    return {
      status: new Ar(),
      ctx: {
        common: t.parent.common,
        data: t.data,
        parsedType: ns(t.data),
        schemaErrorMap: this._def.errorMap,
        path: t.path,
        parent: t.parent
      }
    };
  }
  _parseSync(t) {
    const r = this._parse(t);
    if (Wl(r))
      throw new Error("Synchronous parse encountered promise.");
    return r;
  }
  _parseAsync(t) {
    const r = this._parse(t);
    return Promise.resolve(r);
  }
  parse(t, r) {
    const n = this.safeParse(t, r);
    if (n.success)
      return n.data;
    throw n.error;
  }
  safeParse(t, r) {
    var n;
    const i = {
      common: {
        issues: [],
        async: (n = r == null ? void 0 : r.async) !== null && n !== void 0 ? n : !1,
        contextualErrorMap: r == null ? void 0 : r.errorMap
      },
      path: (r == null ? void 0 : r.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: ns(t)
    }, s = this._parseSync({ data: t, path: i.path, parent: i });
    return r1(i, s);
  }
  async parseAsync(t, r) {
    const n = await this.safeParseAsync(t, r);
    if (n.success)
      return n.data;
    throw n.error;
  }
  async safeParseAsync(t, r) {
    const n = {
      common: {
        issues: [],
        contextualErrorMap: r == null ? void 0 : r.errorMap,
        async: !0
      },
      path: (r == null ? void 0 : r.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: ns(t)
    }, i = this._parse({ data: t, path: n.path, parent: n }), s = await (Wl(i) ? i : Promise.resolve(i));
    return r1(n, s);
  }
  refine(t, r) {
    const n = (i) => typeof r == "string" || typeof r > "u" ? { message: r } : typeof r == "function" ? r(i) : r;
    return this._refinement((i, s) => {
      const a = t(i), u = () => s.addIssue({
        code: De.custom,
        ...n(i)
      });
      return typeof Promise < "u" && a instanceof Promise ? a.then((c) => c ? !0 : (u(), !1)) : a ? !0 : (u(), !1);
    });
  }
  refinement(t, r) {
    return this._refinement((n, i) => t(n) ? !0 : (i.addIssue(typeof r == "function" ? r(n, i) : r), !1));
  }
  _refinement(t) {
    return new kn({
      schema: this,
      typeName: ot.ZodEffects,
      effect: { type: "refinement", refinement: t }
    });
  }
  superRefine(t) {
    return this._refinement(t);
  }
  optional() {
    return Ei.create(this, this._def);
  }
  nullable() {
    return Js.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return In.create(this, this._def);
  }
  promise() {
    return to.create(this, this._def);
  }
  or(t) {
    return Eu.create([this, t], this._def);
  }
  and(t) {
    return xu.create(this, t, this._def);
  }
  transform(t) {
    return new kn({
      ...yt(this._def),
      schema: this,
      typeName: ot.ZodEffects,
      effect: { type: "transform", transform: t }
    });
  }
  default(t) {
    const r = typeof t == "function" ? t : () => t;
    return new Cu({
      ...yt(this._def),
      innerType: this,
      defaultValue: r,
      typeName: ot.ZodDefault
    });
  }
  brand() {
    return new W2({
      typeName: ot.ZodBranded,
      type: this,
      ...yt(this._def)
    });
  }
  catch(t) {
    const r = typeof t == "function" ? t : () => t;
    return new Yl({
      ...yt(this._def),
      innerType: this,
      catchValue: r,
      typeName: ot.ZodCatch
    });
  }
  describe(t) {
    const r = this.constructor;
    return new r({
      ...this._def,
      description: t
    });
  }
  pipe(t) {
    return Zu.create(this, t);
  }
  readonly() {
    return Xl.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const Sk = /^c[^\s-]{8,}$/i, Ak = /^[a-z][a-z0-9]*$/, Ck = /[0-9A-HJKMNP-TV-Z]{26}/, Rk = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, Tk = /^([A-Z0-9_+-]+\.?)*[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, Ik = /^(\p{Extended_Pictographic}|\p{Emoji_Component})+$/u, jk = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/, kk = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/, Mk = (e) => e.precision ? e.offset ? new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`) : new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}Z$`) : e.precision === 0 ? e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$") : e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");
function Nk(e, t) {
  return !!((t === "v4" || !t) && jk.test(e) || (t === "v6" || !t) && kk.test(e));
}
class Rn extends _t {
  constructor() {
    super(...arguments), this._regex = (t, r, n) => this.refinement((i) => t.test(i), {
      validation: r,
      code: De.invalid_string,
      ...tt.errToObj(n)
    }), this.nonempty = (t) => this.min(1, tt.errToObj(t)), this.trim = () => new Rn({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    }), this.toLowerCase = () => new Rn({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    }), this.toUpperCase = () => new Rn({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  _parse(t) {
    if (this._def.coerce && (t.data = String(t.data)), this._getType(t) !== Ve.string) {
      const s = this._getOrReturnCtx(t);
      return We(
        s,
        {
          code: De.invalid_type,
          expected: Ve.string,
          received: s.parsedType
        }
        //
      ), dt;
    }
    const n = new Ar();
    let i;
    for (const s of this._def.checks)
      if (s.kind === "min")
        t.data.length < s.value && (i = this._getOrReturnCtx(t, i), We(i, {
          code: De.too_small,
          minimum: s.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: s.message
        }), n.dirty());
      else if (s.kind === "max")
        t.data.length > s.value && (i = this._getOrReturnCtx(t, i), We(i, {
          code: De.too_big,
          maximum: s.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: s.message
        }), n.dirty());
      else if (s.kind === "length") {
        const a = t.data.length > s.value, u = t.data.length < s.value;
        (a || u) && (i = this._getOrReturnCtx(t, i), a ? We(i, {
          code: De.too_big,
          maximum: s.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: s.message
        }) : u && We(i, {
          code: De.too_small,
          minimum: s.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: s.message
        }), n.dirty());
      } else if (s.kind === "email")
        Tk.test(t.data) || (i = this._getOrReturnCtx(t, i), We(i, {
          validation: "email",
          code: De.invalid_string,
          message: s.message
        }), n.dirty());
      else if (s.kind === "emoji")
        Ik.test(t.data) || (i = this._getOrReturnCtx(t, i), We(i, {
          validation: "emoji",
          code: De.invalid_string,
          message: s.message
        }), n.dirty());
      else if (s.kind === "uuid")
        Rk.test(t.data) || (i = this._getOrReturnCtx(t, i), We(i, {
          validation: "uuid",
          code: De.invalid_string,
          message: s.message
        }), n.dirty());
      else if (s.kind === "cuid")
        Sk.test(t.data) || (i = this._getOrReturnCtx(t, i), We(i, {
          validation: "cuid",
          code: De.invalid_string,
          message: s.message
        }), n.dirty());
      else if (s.kind === "cuid2")
        Ak.test(t.data) || (i = this._getOrReturnCtx(t, i), We(i, {
          validation: "cuid2",
          code: De.invalid_string,
          message: s.message
        }), n.dirty());
      else if (s.kind === "ulid")
        Ck.test(t.data) || (i = this._getOrReturnCtx(t, i), We(i, {
          validation: "ulid",
          code: De.invalid_string,
          message: s.message
        }), n.dirty());
      else if (s.kind === "url")
        try {
          new URL(t.data);
        } catch {
          i = this._getOrReturnCtx(t, i), We(i, {
            validation: "url",
            code: De.invalid_string,
            message: s.message
          }), n.dirty();
        }
      else
        s.kind === "regex" ? (s.regex.lastIndex = 0, s.regex.test(t.data) || (i = this._getOrReturnCtx(t, i), We(i, {
          validation: "regex",
          code: De.invalid_string,
          message: s.message
        }), n.dirty())) : s.kind === "trim" ? t.data = t.data.trim() : s.kind === "includes" ? t.data.includes(s.value, s.position) || (i = this._getOrReturnCtx(t, i), We(i, {
          code: De.invalid_string,
          validation: { includes: s.value, position: s.position },
          message: s.message
        }), n.dirty()) : s.kind === "toLowerCase" ? t.data = t.data.toLowerCase() : s.kind === "toUpperCase" ? t.data = t.data.toUpperCase() : s.kind === "startsWith" ? t.data.startsWith(s.value) || (i = this._getOrReturnCtx(t, i), We(i, {
          code: De.invalid_string,
          validation: { startsWith: s.value },
          message: s.message
        }), n.dirty()) : s.kind === "endsWith" ? t.data.endsWith(s.value) || (i = this._getOrReturnCtx(t, i), We(i, {
          code: De.invalid_string,
          validation: { endsWith: s.value },
          message: s.message
        }), n.dirty()) : s.kind === "datetime" ? Mk(s).test(t.data) || (i = this._getOrReturnCtx(t, i), We(i, {
          code: De.invalid_string,
          validation: "datetime",
          message: s.message
        }), n.dirty()) : s.kind === "ip" ? Nk(t.data, s.version) || (i = this._getOrReturnCtx(t, i), We(i, {
          validation: "ip",
          code: De.invalid_string,
          message: s.message
        }), n.dirty()) : kt.assertNever(s);
    return { status: n.value, value: t.data };
  }
  _addCheck(t) {
    return new Rn({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  email(t) {
    return this._addCheck({ kind: "email", ...tt.errToObj(t) });
  }
  url(t) {
    return this._addCheck({ kind: "url", ...tt.errToObj(t) });
  }
  emoji(t) {
    return this._addCheck({ kind: "emoji", ...tt.errToObj(t) });
  }
  uuid(t) {
    return this._addCheck({ kind: "uuid", ...tt.errToObj(t) });
  }
  cuid(t) {
    return this._addCheck({ kind: "cuid", ...tt.errToObj(t) });
  }
  cuid2(t) {
    return this._addCheck({ kind: "cuid2", ...tt.errToObj(t) });
  }
  ulid(t) {
    return this._addCheck({ kind: "ulid", ...tt.errToObj(t) });
  }
  ip(t) {
    return this._addCheck({ kind: "ip", ...tt.errToObj(t) });
  }
  datetime(t) {
    var r;
    return typeof t == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      message: t
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof (t == null ? void 0 : t.precision) > "u" ? null : t == null ? void 0 : t.precision,
      offset: (r = t == null ? void 0 : t.offset) !== null && r !== void 0 ? r : !1,
      ...tt.errToObj(t == null ? void 0 : t.message)
    });
  }
  regex(t, r) {
    return this._addCheck({
      kind: "regex",
      regex: t,
      ...tt.errToObj(r)
    });
  }
  includes(t, r) {
    return this._addCheck({
      kind: "includes",
      value: t,
      position: r == null ? void 0 : r.position,
      ...tt.errToObj(r == null ? void 0 : r.message)
    });
  }
  startsWith(t, r) {
    return this._addCheck({
      kind: "startsWith",
      value: t,
      ...tt.errToObj(r)
    });
  }
  endsWith(t, r) {
    return this._addCheck({
      kind: "endsWith",
      value: t,
      ...tt.errToObj(r)
    });
  }
  min(t, r) {
    return this._addCheck({
      kind: "min",
      value: t,
      ...tt.errToObj(r)
    });
  }
  max(t, r) {
    return this._addCheck({
      kind: "max",
      value: t,
      ...tt.errToObj(r)
    });
  }
  length(t, r) {
    return this._addCheck({
      kind: "length",
      value: t,
      ...tt.errToObj(r)
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((t) => t.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((t) => t.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((t) => t.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((t) => t.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((t) => t.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((t) => t.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((t) => t.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((t) => t.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((t) => t.kind === "ip");
  }
  get minLength() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "min" && (t === null || r.value > t) && (t = r.value);
    return t;
  }
  get maxLength() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    return t;
  }
}
Rn.create = (e) => {
  var t;
  return new Rn({
    checks: [],
    typeName: ot.ZodString,
    coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
    ...yt(e)
  });
};
function Dk(e, t) {
  const r = (e.toString().split(".")[1] || "").length, n = (t.toString().split(".")[1] || "").length, i = r > n ? r : n, s = parseInt(e.toFixed(i).replace(".", "")), a = parseInt(t.toFixed(i).replace(".", ""));
  return s % a / Math.pow(10, i);
}
class ls extends _t {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = Number(t.data)), this._getType(t) !== Ve.number) {
      const s = this._getOrReturnCtx(t);
      return We(s, {
        code: De.invalid_type,
        expected: Ve.number,
        received: s.parsedType
      }), dt;
    }
    let n;
    const i = new Ar();
    for (const s of this._def.checks)
      s.kind === "int" ? kt.isInteger(t.data) || (n = this._getOrReturnCtx(t, n), We(n, {
        code: De.invalid_type,
        expected: "integer",
        received: "float",
        message: s.message
      }), i.dirty()) : s.kind === "min" ? (s.inclusive ? t.data < s.value : t.data <= s.value) && (n = this._getOrReturnCtx(t, n), We(n, {
        code: De.too_small,
        minimum: s.value,
        type: "number",
        inclusive: s.inclusive,
        exact: !1,
        message: s.message
      }), i.dirty()) : s.kind === "max" ? (s.inclusive ? t.data > s.value : t.data >= s.value) && (n = this._getOrReturnCtx(t, n), We(n, {
        code: De.too_big,
        maximum: s.value,
        type: "number",
        inclusive: s.inclusive,
        exact: !1,
        message: s.message
      }), i.dirty()) : s.kind === "multipleOf" ? Dk(t.data, s.value) !== 0 && (n = this._getOrReturnCtx(t, n), We(n, {
        code: De.not_multiple_of,
        multipleOf: s.value,
        message: s.message
      }), i.dirty()) : s.kind === "finite" ? Number.isFinite(t.data) || (n = this._getOrReturnCtx(t, n), We(n, {
        code: De.not_finite,
        message: s.message
      }), i.dirty()) : kt.assertNever(s);
    return { status: i.value, value: t.data };
  }
  gte(t, r) {
    return this.setLimit("min", t, !0, tt.toString(r));
  }
  gt(t, r) {
    return this.setLimit("min", t, !1, tt.toString(r));
  }
  lte(t, r) {
    return this.setLimit("max", t, !0, tt.toString(r));
  }
  lt(t, r) {
    return this.setLimit("max", t, !1, tt.toString(r));
  }
  setLimit(t, r, n, i) {
    return new ls({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: r,
          inclusive: n,
          message: tt.toString(i)
        }
      ]
    });
  }
  _addCheck(t) {
    return new ls({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  int(t) {
    return this._addCheck({
      kind: "int",
      message: tt.toString(t)
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: tt.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: tt.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: tt.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: tt.toString(t)
    });
  }
  multipleOf(t, r) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: tt.toString(r)
    });
  }
  finite(t) {
    return this._addCheck({
      kind: "finite",
      message: tt.toString(t)
    });
  }
  safe(t) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: tt.toString(t)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: tt.toString(t)
    });
  }
  get minValue() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "min" && (t === null || r.value > t) && (t = r.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    return t;
  }
  get isInt() {
    return !!this._def.checks.find((t) => t.kind === "int" || t.kind === "multipleOf" && kt.isInteger(t.value));
  }
  get isFinite() {
    let t = null, r = null;
    for (const n of this._def.checks) {
      if (n.kind === "finite" || n.kind === "int" || n.kind === "multipleOf")
        return !0;
      n.kind === "min" ? (r === null || n.value > r) && (r = n.value) : n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    }
    return Number.isFinite(r) && Number.isFinite(t);
  }
}
ls.create = (e) => new ls({
  checks: [],
  typeName: ot.ZodNumber,
  coerce: (e == null ? void 0 : e.coerce) || !1,
  ...yt(e)
});
class fs extends _t {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = BigInt(t.data)), this._getType(t) !== Ve.bigint) {
      const s = this._getOrReturnCtx(t);
      return We(s, {
        code: De.invalid_type,
        expected: Ve.bigint,
        received: s.parsedType
      }), dt;
    }
    let n;
    const i = new Ar();
    for (const s of this._def.checks)
      s.kind === "min" ? (s.inclusive ? t.data < s.value : t.data <= s.value) && (n = this._getOrReturnCtx(t, n), We(n, {
        code: De.too_small,
        type: "bigint",
        minimum: s.value,
        inclusive: s.inclusive,
        message: s.message
      }), i.dirty()) : s.kind === "max" ? (s.inclusive ? t.data > s.value : t.data >= s.value) && (n = this._getOrReturnCtx(t, n), We(n, {
        code: De.too_big,
        type: "bigint",
        maximum: s.value,
        inclusive: s.inclusive,
        message: s.message
      }), i.dirty()) : s.kind === "multipleOf" ? t.data % s.value !== BigInt(0) && (n = this._getOrReturnCtx(t, n), We(n, {
        code: De.not_multiple_of,
        multipleOf: s.value,
        message: s.message
      }), i.dirty()) : kt.assertNever(s);
    return { status: i.value, value: t.data };
  }
  gte(t, r) {
    return this.setLimit("min", t, !0, tt.toString(r));
  }
  gt(t, r) {
    return this.setLimit("min", t, !1, tt.toString(r));
  }
  lte(t, r) {
    return this.setLimit("max", t, !0, tt.toString(r));
  }
  lt(t, r) {
    return this.setLimit("max", t, !1, tt.toString(r));
  }
  setLimit(t, r, n, i) {
    return new fs({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: r,
          inclusive: n,
          message: tt.toString(i)
        }
      ]
    });
  }
  _addCheck(t) {
    return new fs({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: tt.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: tt.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: tt.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: tt.toString(t)
    });
  }
  multipleOf(t, r) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: tt.toString(r)
    });
  }
  get minValue() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "min" && (t === null || r.value > t) && (t = r.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    return t;
  }
}
fs.create = (e) => {
  var t;
  return new fs({
    checks: [],
    typeName: ot.ZodBigInt,
    coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
    ...yt(e)
  });
};
class _u extends _t {
  _parse(t) {
    if (this._def.coerce && (t.data = !!t.data), this._getType(t) !== Ve.boolean) {
      const n = this._getOrReturnCtx(t);
      return We(n, {
        code: De.invalid_type,
        expected: Ve.boolean,
        received: n.parsedType
      }), dt;
    }
    return Dr(t.data);
  }
}
_u.create = (e) => new _u({
  typeName: ot.ZodBoolean,
  coerce: (e == null ? void 0 : e.coerce) || !1,
  ...yt(e)
});
class Ks extends _t {
  _parse(t) {
    if (this._def.coerce && (t.data = new Date(t.data)), this._getType(t) !== Ve.date) {
      const s = this._getOrReturnCtx(t);
      return We(s, {
        code: De.invalid_type,
        expected: Ve.date,
        received: s.parsedType
      }), dt;
    }
    if (isNaN(t.data.getTime())) {
      const s = this._getOrReturnCtx(t);
      return We(s, {
        code: De.invalid_date
      }), dt;
    }
    const n = new Ar();
    let i;
    for (const s of this._def.checks)
      s.kind === "min" ? t.data.getTime() < s.value && (i = this._getOrReturnCtx(t, i), We(i, {
        code: De.too_small,
        message: s.message,
        inclusive: !0,
        exact: !1,
        minimum: s.value,
        type: "date"
      }), n.dirty()) : s.kind === "max" ? t.data.getTime() > s.value && (i = this._getOrReturnCtx(t, i), We(i, {
        code: De.too_big,
        message: s.message,
        inclusive: !0,
        exact: !1,
        maximum: s.value,
        type: "date"
      }), n.dirty()) : kt.assertNever(s);
    return {
      status: n.value,
      value: new Date(t.data.getTime())
    };
  }
  _addCheck(t) {
    return new Ks({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  min(t, r) {
    return this._addCheck({
      kind: "min",
      value: t.getTime(),
      message: tt.toString(r)
    });
  }
  max(t, r) {
    return this._addCheck({
      kind: "max",
      value: t.getTime(),
      message: tt.toString(r)
    });
  }
  get minDate() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "min" && (t === null || r.value > t) && (t = r.value);
    return t != null ? new Date(t) : null;
  }
  get maxDate() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    return t != null ? new Date(t) : null;
  }
}
Ks.create = (e) => new Ks({
  checks: [],
  coerce: (e == null ? void 0 : e.coerce) || !1,
  typeName: ot.ZodDate,
  ...yt(e)
});
class Hl extends _t {
  _parse(t) {
    if (this._getType(t) !== Ve.symbol) {
      const n = this._getOrReturnCtx(t);
      return We(n, {
        code: De.invalid_type,
        expected: Ve.symbol,
        received: n.parsedType
      }), dt;
    }
    return Dr(t.data);
  }
}
Hl.create = (e) => new Hl({
  typeName: ot.ZodSymbol,
  ...yt(e)
});
class wu extends _t {
  _parse(t) {
    if (this._getType(t) !== Ve.undefined) {
      const n = this._getOrReturnCtx(t);
      return We(n, {
        code: De.invalid_type,
        expected: Ve.undefined,
        received: n.parsedType
      }), dt;
    }
    return Dr(t.data);
  }
}
wu.create = (e) => new wu({
  typeName: ot.ZodUndefined,
  ...yt(e)
});
class $u extends _t {
  _parse(t) {
    if (this._getType(t) !== Ve.null) {
      const n = this._getOrReturnCtx(t);
      return We(n, {
        code: De.invalid_type,
        expected: Ve.null,
        received: n.parsedType
      }), dt;
    }
    return Dr(t.data);
  }
}
$u.create = (e) => new $u({
  typeName: ot.ZodNull,
  ...yt(e)
});
class eo extends _t {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(t) {
    return Dr(t.data);
  }
}
eo.create = (e) => new eo({
  typeName: ot.ZodAny,
  ...yt(e)
});
class zs extends _t {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(t) {
    return Dr(t.data);
  }
}
zs.create = (e) => new zs({
  typeName: ot.ZodUnknown,
  ...yt(e)
});
class Ai extends _t {
  _parse(t) {
    const r = this._getOrReturnCtx(t);
    return We(r, {
      code: De.invalid_type,
      expected: Ve.never,
      received: r.parsedType
    }), dt;
  }
}
Ai.create = (e) => new Ai({
  typeName: ot.ZodNever,
  ...yt(e)
});
class Gl extends _t {
  _parse(t) {
    if (this._getType(t) !== Ve.undefined) {
      const n = this._getOrReturnCtx(t);
      return We(n, {
        code: De.invalid_type,
        expected: Ve.void,
        received: n.parsedType
      }), dt;
    }
    return Dr(t.data);
  }
}
Gl.create = (e) => new Gl({
  typeName: ot.ZodVoid,
  ...yt(e)
});
class In extends _t {
  _parse(t) {
    const { ctx: r, status: n } = this._processInputParams(t), i = this._def;
    if (r.parsedType !== Ve.array)
      return We(r, {
        code: De.invalid_type,
        expected: Ve.array,
        received: r.parsedType
      }), dt;
    if (i.exactLength !== null) {
      const a = r.data.length > i.exactLength.value, u = r.data.length < i.exactLength.value;
      (a || u) && (We(r, {
        code: a ? De.too_big : De.too_small,
        minimum: u ? i.exactLength.value : void 0,
        maximum: a ? i.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: i.exactLength.message
      }), n.dirty());
    }
    if (i.minLength !== null && r.data.length < i.minLength.value && (We(r, {
      code: De.too_small,
      minimum: i.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: i.minLength.message
    }), n.dirty()), i.maxLength !== null && r.data.length > i.maxLength.value && (We(r, {
      code: De.too_big,
      maximum: i.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: i.maxLength.message
    }), n.dirty()), r.common.async)
      return Promise.all([...r.data].map((a, u) => i.type._parseAsync(new ri(r, a, r.path, u)))).then((a) => Ar.mergeArray(n, a));
    const s = [...r.data].map((a, u) => i.type._parseSync(new ri(r, a, r.path, u)));
    return Ar.mergeArray(n, s);
  }
  get element() {
    return this._def.type;
  }
  min(t, r) {
    return new In({
      ...this._def,
      minLength: { value: t, message: tt.toString(r) }
    });
  }
  max(t, r) {
    return new In({
      ...this._def,
      maxLength: { value: t, message: tt.toString(r) }
    });
  }
  length(t, r) {
    return new In({
      ...this._def,
      exactLength: { value: t, message: tt.toString(r) }
    });
  }
  nonempty(t) {
    return this.min(1, t);
  }
}
In.create = (e, t) => new In({
  type: e,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: ot.ZodArray,
  ...yt(t)
});
function Na(e) {
  if (e instanceof Jt) {
    const t = {};
    for (const r in e.shape) {
      const n = e.shape[r];
      t[r] = Ei.create(Na(n));
    }
    return new Jt({
      ...e._def,
      shape: () => t
    });
  } else
    return e instanceof In ? new In({
      ...e._def,
      type: Na(e.element)
    }) : e instanceof Ei ? Ei.create(Na(e.unwrap())) : e instanceof Js ? Js.create(Na(e.unwrap())) : e instanceof ni ? ni.create(e.items.map((t) => Na(t))) : e;
}
class Jt extends _t {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const t = this._def.shape(), r = kt.objectKeys(t);
    return this._cached = { shape: t, keys: r };
  }
  _parse(t) {
    if (this._getType(t) !== Ve.object) {
      const l = this._getOrReturnCtx(t);
      return We(l, {
        code: De.invalid_type,
        expected: Ve.object,
        received: l.parsedType
      }), dt;
    }
    const { status: n, ctx: i } = this._processInputParams(t), { shape: s, keys: a } = this._getCached(), u = [];
    if (!(this._def.catchall instanceof Ai && this._def.unknownKeys === "strip"))
      for (const l in i.data)
        a.includes(l) || u.push(l);
    const c = [];
    for (const l of a) {
      const d = s[l], p = i.data[l];
      c.push({
        key: { status: "valid", value: l },
        value: d._parse(new ri(i, p, i.path, l)),
        alwaysSet: l in i.data
      });
    }
    if (this._def.catchall instanceof Ai) {
      const l = this._def.unknownKeys;
      if (l === "passthrough")
        for (const d of u)
          c.push({
            key: { status: "valid", value: d },
            value: { status: "valid", value: i.data[d] }
          });
      else if (l === "strict")
        u.length > 0 && (We(i, {
          code: De.unrecognized_keys,
          keys: u
        }), n.dirty());
      else if (l !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const l = this._def.catchall;
      for (const d of u) {
        const p = i.data[d];
        c.push({
          key: { status: "valid", value: d },
          value: l._parse(
            new ri(i, p, i.path, d)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: d in i.data
        });
      }
    }
    return i.common.async ? Promise.resolve().then(async () => {
      const l = [];
      for (const d of c) {
        const p = await d.key;
        l.push({
          key: p,
          value: await d.value,
          alwaysSet: d.alwaysSet
        });
      }
      return l;
    }).then((l) => Ar.mergeObjectSync(n, l)) : Ar.mergeObjectSync(n, c);
  }
  get shape() {
    return this._def.shape();
  }
  strict(t) {
    return tt.errToObj, new Jt({
      ...this._def,
      unknownKeys: "strict",
      ...t !== void 0 ? {
        errorMap: (r, n) => {
          var i, s, a, u;
          const c = (a = (s = (i = this._def).errorMap) === null || s === void 0 ? void 0 : s.call(i, r, n).message) !== null && a !== void 0 ? a : n.defaultError;
          return r.code === "unrecognized_keys" ? {
            message: (u = tt.errToObj(t).message) !== null && u !== void 0 ? u : c
          } : {
            message: c
          };
        }
      } : {}
    });
  }
  strip() {
    return new Jt({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new Jt({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(t) {
    return new Jt({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...t
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(t) {
    return new Jt({
      unknownKeys: t._def.unknownKeys,
      catchall: t._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...t._def.shape()
      }),
      typeName: ot.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(t, r) {
    return this.augment({ [t]: r });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(t) {
    return new Jt({
      ...this._def,
      catchall: t
    });
  }
  pick(t) {
    const r = {};
    return kt.objectKeys(t).forEach((n) => {
      t[n] && this.shape[n] && (r[n] = this.shape[n]);
    }), new Jt({
      ...this._def,
      shape: () => r
    });
  }
  omit(t) {
    const r = {};
    return kt.objectKeys(this.shape).forEach((n) => {
      t[n] || (r[n] = this.shape[n]);
    }), new Jt({
      ...this._def,
      shape: () => r
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return Na(this);
  }
  partial(t) {
    const r = {};
    return kt.objectKeys(this.shape).forEach((n) => {
      const i = this.shape[n];
      t && !t[n] ? r[n] = i : r[n] = i.optional();
    }), new Jt({
      ...this._def,
      shape: () => r
    });
  }
  required(t) {
    const r = {};
    return kt.objectKeys(this.shape).forEach((n) => {
      if (t && !t[n])
        r[n] = this.shape[n];
      else {
        let s = this.shape[n];
        for (; s instanceof Ei; )
          s = s._def.innerType;
        r[n] = s;
      }
    }), new Jt({
      ...this._def,
      shape: () => r
    });
  }
  keyof() {
    return z2(kt.objectKeys(this.shape));
  }
}
Jt.create = (e, t) => new Jt({
  shape: () => e,
  unknownKeys: "strip",
  catchall: Ai.create(),
  typeName: ot.ZodObject,
  ...yt(t)
});
Jt.strictCreate = (e, t) => new Jt({
  shape: () => e,
  unknownKeys: "strict",
  catchall: Ai.create(),
  typeName: ot.ZodObject,
  ...yt(t)
});
Jt.lazycreate = (e, t) => new Jt({
  shape: e,
  unknownKeys: "strip",
  catchall: Ai.create(),
  typeName: ot.ZodObject,
  ...yt(t)
});
class Eu extends _t {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t), n = this._def.options;
    function i(s) {
      for (const u of s)
        if (u.result.status === "valid")
          return u.result;
      for (const u of s)
        if (u.result.status === "dirty")
          return r.common.issues.push(...u.ctx.common.issues), u.result;
      const a = s.map((u) => new Tn(u.ctx.common.issues));
      return We(r, {
        code: De.invalid_union,
        unionErrors: a
      }), dt;
    }
    if (r.common.async)
      return Promise.all(n.map(async (s) => {
        const a = {
          ...r,
          common: {
            ...r.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await s._parseAsync({
            data: r.data,
            path: r.path,
            parent: a
          }),
          ctx: a
        };
      })).then(i);
    {
      let s;
      const a = [];
      for (const c of n) {
        const l = {
          ...r,
          common: {
            ...r.common,
            issues: []
          },
          parent: null
        }, d = c._parseSync({
          data: r.data,
          path: r.path,
          parent: l
        });
        if (d.status === "valid")
          return d;
        d.status === "dirty" && !s && (s = { result: d, ctx: l }), l.common.issues.length && a.push(l.common.issues);
      }
      if (s)
        return r.common.issues.push(...s.ctx.common.issues), s.result;
      const u = a.map((c) => new Tn(c));
      return We(r, {
        code: De.invalid_union,
        unionErrors: u
      }), dt;
    }
  }
  get options() {
    return this._def.options;
  }
}
Eu.create = (e, t) => new Eu({
  options: e,
  typeName: ot.ZodUnion,
  ...yt(t)
});
const wl = (e) => e instanceof Pu ? wl(e.schema) : e instanceof kn ? wl(e.innerType()) : e instanceof Su ? [e.value] : e instanceof ds ? e.options : e instanceof Au ? Object.keys(e.enum) : e instanceof Cu ? wl(e._def.innerType) : e instanceof wu ? [void 0] : e instanceof $u ? [null] : null;
class Cf extends _t {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t);
    if (r.parsedType !== Ve.object)
      return We(r, {
        code: De.invalid_type,
        expected: Ve.object,
        received: r.parsedType
      }), dt;
    const n = this.discriminator, i = r.data[n], s = this.optionsMap.get(i);
    return s ? r.common.async ? s._parseAsync({
      data: r.data,
      path: r.path,
      parent: r
    }) : s._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }) : (We(r, {
      code: De.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [n]
    }), dt);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(t, r, n) {
    const i = /* @__PURE__ */ new Map();
    for (const s of r) {
      const a = wl(s.shape[t]);
      if (!a)
        throw new Error(`A discriminator value for key \`${t}\` could not be extracted from all schema options`);
      for (const u of a) {
        if (i.has(u))
          throw new Error(`Discriminator property ${String(t)} has duplicate value ${String(u)}`);
        i.set(u, s);
      }
    }
    return new Cf({
      typeName: ot.ZodDiscriminatedUnion,
      discriminator: t,
      options: r,
      optionsMap: i,
      ...yt(n)
    });
  }
}
function Qm(e, t) {
  const r = ns(e), n = ns(t);
  if (e === t)
    return { valid: !0, data: e };
  if (r === Ve.object && n === Ve.object) {
    const i = kt.objectKeys(t), s = kt.objectKeys(e).filter((u) => i.indexOf(u) !== -1), a = { ...e, ...t };
    for (const u of s) {
      const c = Qm(e[u], t[u]);
      if (!c.valid)
        return { valid: !1 };
      a[u] = c.data;
    }
    return { valid: !0, data: a };
  } else if (r === Ve.array && n === Ve.array) {
    if (e.length !== t.length)
      return { valid: !1 };
    const i = [];
    for (let s = 0; s < e.length; s++) {
      const a = e[s], u = t[s], c = Qm(a, u);
      if (!c.valid)
        return { valid: !1 };
      i.push(c.data);
    }
    return { valid: !0, data: i };
  } else
    return r === Ve.date && n === Ve.date && +e == +t ? { valid: !0, data: e } : { valid: !1 };
}
class xu extends _t {
  _parse(t) {
    const { status: r, ctx: n } = this._processInputParams(t), i = (s, a) => {
      if (Jm(s) || Jm(a))
        return dt;
      const u = Qm(s.value, a.value);
      return u.valid ? ((Xm(s) || Xm(a)) && r.dirty(), { status: r.value, value: u.data }) : (We(n, {
        code: De.invalid_intersection_types
      }), dt);
    };
    return n.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: n.data,
        path: n.path,
        parent: n
      }),
      this._def.right._parseAsync({
        data: n.data,
        path: n.path,
        parent: n
      })
    ]).then(([s, a]) => i(s, a)) : i(this._def.left._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }), this._def.right._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }));
  }
}
xu.create = (e, t, r) => new xu({
  left: e,
  right: t,
  typeName: ot.ZodIntersection,
  ...yt(r)
});
class ni extends _t {
  _parse(t) {
    const { status: r, ctx: n } = this._processInputParams(t);
    if (n.parsedType !== Ve.array)
      return We(n, {
        code: De.invalid_type,
        expected: Ve.array,
        received: n.parsedType
      }), dt;
    if (n.data.length < this._def.items.length)
      return We(n, {
        code: De.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), dt;
    !this._def.rest && n.data.length > this._def.items.length && (We(n, {
      code: De.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), r.dirty());
    const s = [...n.data].map((a, u) => {
      const c = this._def.items[u] || this._def.rest;
      return c ? c._parse(new ri(n, a, n.path, u)) : null;
    }).filter((a) => !!a);
    return n.common.async ? Promise.all(s).then((a) => Ar.mergeArray(r, a)) : Ar.mergeArray(r, s);
  }
  get items() {
    return this._def.items;
  }
  rest(t) {
    return new ni({
      ...this._def,
      rest: t
    });
  }
}
ni.create = (e, t) => {
  if (!Array.isArray(e))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new ni({
    items: e,
    typeName: ot.ZodTuple,
    rest: null,
    ...yt(t)
  });
};
class Ou extends _t {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(t) {
    const { status: r, ctx: n } = this._processInputParams(t);
    if (n.parsedType !== Ve.object)
      return We(n, {
        code: De.invalid_type,
        expected: Ve.object,
        received: n.parsedType
      }), dt;
    const i = [], s = this._def.keyType, a = this._def.valueType;
    for (const u in n.data)
      i.push({
        key: s._parse(new ri(n, u, n.path, u)),
        value: a._parse(new ri(n, n.data[u], n.path, u))
      });
    return n.common.async ? Ar.mergeObjectAsync(r, i) : Ar.mergeObjectSync(r, i);
  }
  get element() {
    return this._def.valueType;
  }
  static create(t, r, n) {
    return r instanceof _t ? new Ou({
      keyType: t,
      valueType: r,
      typeName: ot.ZodRecord,
      ...yt(n)
    }) : new Ou({
      keyType: Rn.create(),
      valueType: t,
      typeName: ot.ZodRecord,
      ...yt(r)
    });
  }
}
class Kl extends _t {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(t) {
    const { status: r, ctx: n } = this._processInputParams(t);
    if (n.parsedType !== Ve.map)
      return We(n, {
        code: De.invalid_type,
        expected: Ve.map,
        received: n.parsedType
      }), dt;
    const i = this._def.keyType, s = this._def.valueType, a = [...n.data.entries()].map(([u, c], l) => ({
      key: i._parse(new ri(n, u, n.path, [l, "key"])),
      value: s._parse(new ri(n, c, n.path, [l, "value"]))
    }));
    if (n.common.async) {
      const u = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const c of a) {
          const l = await c.key, d = await c.value;
          if (l.status === "aborted" || d.status === "aborted")
            return dt;
          (l.status === "dirty" || d.status === "dirty") && r.dirty(), u.set(l.value, d.value);
        }
        return { status: r.value, value: u };
      });
    } else {
      const u = /* @__PURE__ */ new Map();
      for (const c of a) {
        const l = c.key, d = c.value;
        if (l.status === "aborted" || d.status === "aborted")
          return dt;
        (l.status === "dirty" || d.status === "dirty") && r.dirty(), u.set(l.value, d.value);
      }
      return { status: r.value, value: u };
    }
  }
}
Kl.create = (e, t, r) => new Kl({
  valueType: t,
  keyType: e,
  typeName: ot.ZodMap,
  ...yt(r)
});
class Ys extends _t {
  _parse(t) {
    const { status: r, ctx: n } = this._processInputParams(t);
    if (n.parsedType !== Ve.set)
      return We(n, {
        code: De.invalid_type,
        expected: Ve.set,
        received: n.parsedType
      }), dt;
    const i = this._def;
    i.minSize !== null && n.data.size < i.minSize.value && (We(n, {
      code: De.too_small,
      minimum: i.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: i.minSize.message
    }), r.dirty()), i.maxSize !== null && n.data.size > i.maxSize.value && (We(n, {
      code: De.too_big,
      maximum: i.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: i.maxSize.message
    }), r.dirty());
    const s = this._def.valueType;
    function a(c) {
      const l = /* @__PURE__ */ new Set();
      for (const d of c) {
        if (d.status === "aborted")
          return dt;
        d.status === "dirty" && r.dirty(), l.add(d.value);
      }
      return { status: r.value, value: l };
    }
    const u = [...n.data.values()].map((c, l) => s._parse(new ri(n, c, n.path, l)));
    return n.common.async ? Promise.all(u).then((c) => a(c)) : a(u);
  }
  min(t, r) {
    return new Ys({
      ...this._def,
      minSize: { value: t, message: tt.toString(r) }
    });
  }
  max(t, r) {
    return new Ys({
      ...this._def,
      maxSize: { value: t, message: tt.toString(r) }
    });
  }
  size(t, r) {
    return this.min(t, r).max(t, r);
  }
  nonempty(t) {
    return this.min(1, t);
  }
}
Ys.create = (e, t) => new Ys({
  valueType: e,
  minSize: null,
  maxSize: null,
  typeName: ot.ZodSet,
  ...yt(t)
});
class Wa extends _t {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(t) {
    const { ctx: r } = this._processInputParams(t);
    if (r.parsedType !== Ve.function)
      return We(r, {
        code: De.invalid_type,
        expected: Ve.function,
        received: r.parsedType
      }), dt;
    function n(u, c) {
      return zl({
        data: u,
        path: r.path,
        errorMaps: [
          r.common.contextualErrorMap,
          r.schemaErrorMap,
          Zl(),
          vu
        ].filter((l) => !!l),
        issueData: {
          code: De.invalid_arguments,
          argumentsError: c
        }
      });
    }
    function i(u, c) {
      return zl({
        data: u,
        path: r.path,
        errorMaps: [
          r.common.contextualErrorMap,
          r.schemaErrorMap,
          Zl(),
          vu
        ].filter((l) => !!l),
        issueData: {
          code: De.invalid_return_type,
          returnTypeError: c
        }
      });
    }
    const s = { errorMap: r.common.contextualErrorMap }, a = r.data;
    if (this._def.returns instanceof to) {
      const u = this;
      return Dr(async function(...c) {
        const l = new Tn([]), d = await u._def.args.parseAsync(c, s).catch((v) => {
          throw l.addIssue(n(c, v)), l;
        }), p = await Reflect.apply(a, this, d);
        return await u._def.returns._def.type.parseAsync(p, s).catch((v) => {
          throw l.addIssue(i(p, v)), l;
        });
      });
    } else {
      const u = this;
      return Dr(function(...c) {
        const l = u._def.args.safeParse(c, s);
        if (!l.success)
          throw new Tn([n(c, l.error)]);
        const d = Reflect.apply(a, this, l.data), p = u._def.returns.safeParse(d, s);
        if (!p.success)
          throw new Tn([i(d, p.error)]);
        return p.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...t) {
    return new Wa({
      ...this._def,
      args: ni.create(t).rest(zs.create())
    });
  }
  returns(t) {
    return new Wa({
      ...this._def,
      returns: t
    });
  }
  implement(t) {
    return this.parse(t);
  }
  strictImplement(t) {
    return this.parse(t);
  }
  static create(t, r, n) {
    return new Wa({
      args: t || ni.create([]).rest(zs.create()),
      returns: r || zs.create(),
      typeName: ot.ZodFunction,
      ...yt(n)
    });
  }
}
class Pu extends _t {
  get schema() {
    return this._def.getter();
  }
  _parse(t) {
    const { ctx: r } = this._processInputParams(t);
    return this._def.getter()._parse({ data: r.data, path: r.path, parent: r });
  }
}
Pu.create = (e, t) => new Pu({
  getter: e,
  typeName: ot.ZodLazy,
  ...yt(t)
});
class Su extends _t {
  _parse(t) {
    if (t.data !== this._def.value) {
      const r = this._getOrReturnCtx(t);
      return We(r, {
        received: r.data,
        code: De.invalid_literal,
        expected: this._def.value
      }), dt;
    }
    return { status: "valid", value: t.data };
  }
  get value() {
    return this._def.value;
  }
}
Su.create = (e, t) => new Su({
  value: e,
  typeName: ot.ZodLiteral,
  ...yt(t)
});
function z2(e, t) {
  return new ds({
    values: e,
    typeName: ot.ZodEnum,
    ...yt(t)
  });
}
class ds extends _t {
  _parse(t) {
    if (typeof t.data != "string") {
      const r = this._getOrReturnCtx(t), n = this._def.values;
      return We(r, {
        expected: kt.joinValues(n),
        received: r.parsedType,
        code: De.invalid_type
      }), dt;
    }
    if (this._def.values.indexOf(t.data) === -1) {
      const r = this._getOrReturnCtx(t), n = this._def.values;
      return We(r, {
        received: r.data,
        code: De.invalid_enum_value,
        options: n
      }), dt;
    }
    return Dr(t.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const t = {};
    for (const r of this._def.values)
      t[r] = r;
    return t;
  }
  get Values() {
    const t = {};
    for (const r of this._def.values)
      t[r] = r;
    return t;
  }
  get Enum() {
    const t = {};
    for (const r of this._def.values)
      t[r] = r;
    return t;
  }
  extract(t) {
    return ds.create(t);
  }
  exclude(t) {
    return ds.create(this.options.filter((r) => !t.includes(r)));
  }
}
ds.create = z2;
class Au extends _t {
  _parse(t) {
    const r = kt.getValidEnumValues(this._def.values), n = this._getOrReturnCtx(t);
    if (n.parsedType !== Ve.string && n.parsedType !== Ve.number) {
      const i = kt.objectValues(r);
      return We(n, {
        expected: kt.joinValues(i),
        received: n.parsedType,
        code: De.invalid_type
      }), dt;
    }
    if (r.indexOf(t.data) === -1) {
      const i = kt.objectValues(r);
      return We(n, {
        received: n.data,
        code: De.invalid_enum_value,
        options: i
      }), dt;
    }
    return Dr(t.data);
  }
  get enum() {
    return this._def.values;
  }
}
Au.create = (e, t) => new Au({
  values: e,
  typeName: ot.ZodNativeEnum,
  ...yt(t)
});
class to extends _t {
  unwrap() {
    return this._def.type;
  }
  _parse(t) {
    const { ctx: r } = this._processInputParams(t);
    if (r.parsedType !== Ve.promise && r.common.async === !1)
      return We(r, {
        code: De.invalid_type,
        expected: Ve.promise,
        received: r.parsedType
      }), dt;
    const n = r.parsedType === Ve.promise ? r.data : Promise.resolve(r.data);
    return Dr(n.then((i) => this._def.type.parseAsync(i, {
      path: r.path,
      errorMap: r.common.contextualErrorMap
    })));
  }
}
to.create = (e, t) => new to({
  type: e,
  typeName: ot.ZodPromise,
  ...yt(t)
});
class kn extends _t {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ot.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(t) {
    const { status: r, ctx: n } = this._processInputParams(t), i = this._def.effect || null, s = {
      addIssue: (a) => {
        We(n, a), a.fatal ? r.abort() : r.dirty();
      },
      get path() {
        return n.path;
      }
    };
    if (s.addIssue = s.addIssue.bind(s), i.type === "preprocess") {
      const a = i.transform(n.data, s);
      return n.common.issues.length ? {
        status: "dirty",
        value: n.data
      } : n.common.async ? Promise.resolve(a).then((u) => this._def.schema._parseAsync({
        data: u,
        path: n.path,
        parent: n
      })) : this._def.schema._parseSync({
        data: a,
        path: n.path,
        parent: n
      });
    }
    if (i.type === "refinement") {
      const a = (u) => {
        const c = i.refinement(u, s);
        if (n.common.async)
          return Promise.resolve(c);
        if (c instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return u;
      };
      if (n.common.async === !1) {
        const u = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n
        });
        return u.status === "aborted" ? dt : (u.status === "dirty" && r.dirty(), a(u.value), { status: r.value, value: u.value });
      } else
        return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((u) => u.status === "aborted" ? dt : (u.status === "dirty" && r.dirty(), a(u.value).then(() => ({ status: r.value, value: u.value }))));
    }
    if (i.type === "transform")
      if (n.common.async === !1) {
        const a = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n
        });
        if (!bu(a))
          return a;
        const u = i.transform(a.value, s);
        if (u instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: r.value, value: u };
      } else
        return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((a) => bu(a) ? Promise.resolve(i.transform(a.value, s)).then((u) => ({ status: r.value, value: u })) : a);
    kt.assertNever(i);
  }
}
kn.create = (e, t, r) => new kn({
  schema: e,
  typeName: ot.ZodEffects,
  effect: t,
  ...yt(r)
});
kn.createWithPreprocess = (e, t, r) => new kn({
  schema: t,
  effect: { type: "preprocess", transform: e },
  typeName: ot.ZodEffects,
  ...yt(r)
});
class Ei extends _t {
  _parse(t) {
    return this._getType(t) === Ve.undefined ? Dr(void 0) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
}
Ei.create = (e, t) => new Ei({
  innerType: e,
  typeName: ot.ZodOptional,
  ...yt(t)
});
class Js extends _t {
  _parse(t) {
    return this._getType(t) === Ve.null ? Dr(null) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
}
Js.create = (e, t) => new Js({
  innerType: e,
  typeName: ot.ZodNullable,
  ...yt(t)
});
class Cu extends _t {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t);
    let n = r.data;
    return r.parsedType === Ve.undefined && (n = this._def.defaultValue()), this._def.innerType._parse({
      data: n,
      path: r.path,
      parent: r
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
Cu.create = (e, t) => new Cu({
  innerType: e,
  typeName: ot.ZodDefault,
  defaultValue: typeof t.default == "function" ? t.default : () => t.default,
  ...yt(t)
});
class Yl extends _t {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t), n = {
      ...r,
      common: {
        ...r.common,
        issues: []
      }
    }, i = this._def.innerType._parse({
      data: n.data,
      path: n.path,
      parent: {
        ...n
      }
    });
    return Wl(i) ? i.then((s) => ({
      status: "valid",
      value: s.status === "valid" ? s.value : this._def.catchValue({
        get error() {
          return new Tn(n.common.issues);
        },
        input: n.data
      })
    })) : {
      status: "valid",
      value: i.status === "valid" ? i.value : this._def.catchValue({
        get error() {
          return new Tn(n.common.issues);
        },
        input: n.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
}
Yl.create = (e, t) => new Yl({
  innerType: e,
  typeName: ot.ZodCatch,
  catchValue: typeof t.catch == "function" ? t.catch : () => t.catch,
  ...yt(t)
});
class Jl extends _t {
  _parse(t) {
    if (this._getType(t) !== Ve.nan) {
      const n = this._getOrReturnCtx(t);
      return We(n, {
        code: De.invalid_type,
        expected: Ve.nan,
        received: n.parsedType
      }), dt;
    }
    return { status: "valid", value: t.data };
  }
}
Jl.create = (e) => new Jl({
  typeName: ot.ZodNaN,
  ...yt(e)
});
const Lk = Symbol("zod_brand");
class W2 extends _t {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t), n = r.data;
    return this._def.type._parse({
      data: n,
      path: r.path,
      parent: r
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class Zu extends _t {
  _parse(t) {
    const { status: r, ctx: n } = this._processInputParams(t);
    if (n.common.async)
      return (async () => {
        const s = await this._def.in._parseAsync({
          data: n.data,
          path: n.path,
          parent: n
        });
        return s.status === "aborted" ? dt : s.status === "dirty" ? (r.dirty(), Z2(s.value)) : this._def.out._parseAsync({
          data: s.value,
          path: n.path,
          parent: n
        });
      })();
    {
      const i = this._def.in._parseSync({
        data: n.data,
        path: n.path,
        parent: n
      });
      return i.status === "aborted" ? dt : i.status === "dirty" ? (r.dirty(), {
        status: "dirty",
        value: i.value
      }) : this._def.out._parseSync({
        data: i.value,
        path: n.path,
        parent: n
      });
    }
  }
  static create(t, r) {
    return new Zu({
      in: t,
      out: r,
      typeName: ot.ZodPipeline
    });
  }
}
class Xl extends _t {
  _parse(t) {
    const r = this._def.innerType._parse(t);
    return bu(r) && (r.value = Object.freeze(r.value)), r;
  }
}
Xl.create = (e, t) => new Xl({
  innerType: e,
  typeName: ot.ZodReadonly,
  ...yt(t)
});
const H2 = (e, t = {}, r) => e ? eo.create().superRefine((n, i) => {
  var s, a;
  if (!e(n)) {
    const u = typeof t == "function" ? t(n) : typeof t == "string" ? { message: t } : t, c = (a = (s = u.fatal) !== null && s !== void 0 ? s : r) !== null && a !== void 0 ? a : !0, l = typeof u == "string" ? { message: u } : u;
    i.addIssue({ code: "custom", ...l, fatal: c });
  }
}) : eo.create(), qk = {
  object: Jt.lazycreate
};
var ot;
(function(e) {
  e.ZodString = "ZodString", e.ZodNumber = "ZodNumber", e.ZodNaN = "ZodNaN", e.ZodBigInt = "ZodBigInt", e.ZodBoolean = "ZodBoolean", e.ZodDate = "ZodDate", e.ZodSymbol = "ZodSymbol", e.ZodUndefined = "ZodUndefined", e.ZodNull = "ZodNull", e.ZodAny = "ZodAny", e.ZodUnknown = "ZodUnknown", e.ZodNever = "ZodNever", e.ZodVoid = "ZodVoid", e.ZodArray = "ZodArray", e.ZodObject = "ZodObject", e.ZodUnion = "ZodUnion", e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", e.ZodIntersection = "ZodIntersection", e.ZodTuple = "ZodTuple", e.ZodRecord = "ZodRecord", e.ZodMap = "ZodMap", e.ZodSet = "ZodSet", e.ZodFunction = "ZodFunction", e.ZodLazy = "ZodLazy", e.ZodLiteral = "ZodLiteral", e.ZodEnum = "ZodEnum", e.ZodEffects = "ZodEffects", e.ZodNativeEnum = "ZodNativeEnum", e.ZodOptional = "ZodOptional", e.ZodNullable = "ZodNullable", e.ZodDefault = "ZodDefault", e.ZodCatch = "ZodCatch", e.ZodPromise = "ZodPromise", e.ZodBranded = "ZodBranded", e.ZodPipeline = "ZodPipeline", e.ZodReadonly = "ZodReadonly";
})(ot || (ot = {}));
const Fk = (e, t = {
  message: `Input not instance of ${e.name}`
}) => H2((r) => r instanceof e, t), G2 = Rn.create, K2 = ls.create, Uk = Jl.create, Bk = fs.create, Y2 = _u.create, Vk = Ks.create, Zk = Hl.create, zk = wu.create, Wk = $u.create, Hk = eo.create, Gk = zs.create, Kk = Ai.create, Yk = Gl.create, Jk = In.create, Xk = Jt.create, Qk = Jt.strictCreate, e3 = Eu.create, t3 = Cf.create, r3 = xu.create, n3 = ni.create, i3 = Ou.create, s3 = Kl.create, a3 = Ys.create, o3 = Wa.create, u3 = Pu.create, c3 = Su.create, l3 = ds.create, f3 = Au.create, d3 = to.create, n1 = kn.create, p3 = Ei.create, h3 = Js.create, m3 = kn.createWithPreprocess, y3 = Zu.create, g3 = () => G2().optional(), v3 = () => K2().optional(), b3 = () => Y2().optional(), _3 = {
  string: (e) => Rn.create({ ...e, coerce: !0 }),
  number: (e) => ls.create({ ...e, coerce: !0 }),
  boolean: (e) => _u.create({
    ...e,
    coerce: !0
  }),
  bigint: (e) => fs.create({ ...e, coerce: !0 }),
  date: (e) => Ks.create({ ...e, coerce: !0 })
}, w3 = dt;
var Te = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: vu,
  setErrorMap: Ok,
  getErrorMap: Zl,
  makeIssue: zl,
  EMPTY_PATH: Pk,
  addIssueToContext: We,
  ParseStatus: Ar,
  INVALID: dt,
  DIRTY: Z2,
  OK: Dr,
  isAborted: Jm,
  isDirty: Xm,
  isValid: bu,
  isAsync: Wl,
  get util() {
    return kt;
  },
  get objectUtil() {
    return Ym;
  },
  ZodParsedType: Ve,
  getParsedType: ns,
  ZodType: _t,
  ZodString: Rn,
  ZodNumber: ls,
  ZodBigInt: fs,
  ZodBoolean: _u,
  ZodDate: Ks,
  ZodSymbol: Hl,
  ZodUndefined: wu,
  ZodNull: $u,
  ZodAny: eo,
  ZodUnknown: zs,
  ZodNever: Ai,
  ZodVoid: Gl,
  ZodArray: In,
  ZodObject: Jt,
  ZodUnion: Eu,
  ZodDiscriminatedUnion: Cf,
  ZodIntersection: xu,
  ZodTuple: ni,
  ZodRecord: Ou,
  ZodMap: Kl,
  ZodSet: Ys,
  ZodFunction: Wa,
  ZodLazy: Pu,
  ZodLiteral: Su,
  ZodEnum: ds,
  ZodNativeEnum: Au,
  ZodPromise: to,
  ZodEffects: kn,
  ZodTransformer: kn,
  ZodOptional: Ei,
  ZodNullable: Js,
  ZodDefault: Cu,
  ZodCatch: Yl,
  ZodNaN: Jl,
  BRAND: Lk,
  ZodBranded: W2,
  ZodPipeline: Zu,
  ZodReadonly: Xl,
  custom: H2,
  Schema: _t,
  ZodSchema: _t,
  late: qk,
  get ZodFirstPartyTypeKind() {
    return ot;
  },
  coerce: _3,
  any: Hk,
  array: Jk,
  bigint: Bk,
  boolean: Y2,
  date: Vk,
  discriminatedUnion: t3,
  effect: n1,
  enum: l3,
  function: o3,
  instanceof: Fk,
  intersection: r3,
  lazy: u3,
  literal: c3,
  map: s3,
  nan: Uk,
  nativeEnum: f3,
  never: Kk,
  null: Wk,
  nullable: h3,
  number: K2,
  object: Xk,
  oboolean: b3,
  onumber: v3,
  optional: p3,
  ostring: g3,
  pipeline: y3,
  preprocess: m3,
  promise: d3,
  record: i3,
  set: a3,
  strictObject: Qk,
  string: G2,
  symbol: Zk,
  transformer: n1,
  tuple: n3,
  undefined: zk,
  union: e3,
  unknown: Gk,
  void: Yk,
  NEVER: w3,
  ZodIssueCode: De,
  quotelessJson: xk,
  ZodError: Tn
});
Te.object({
  user_id: Te.string().nonempty(),
  public_key: Te.string().nonempty(),
  private_key: Te.string().nonempty()
});
Te.object({
  id: Te.string().nonempty(),
  path: Te.string().nonempty().catch("/"),
  method: Te.string().nonempty().catch("post")
});
const Rf = Te.object({
  n: Te.string().optional(),
  c: Te.string(),
  s: Te.string(),
  pk: Te.string()
}), $3 = Te.object({
  module_id: Te.string().nonempty(),
  method_id: Te.string().nonempty()
}), J2 = Te.object({
  id: Te.string().nonempty(),
  call: $3,
  multiplier: Te.number().nonnegative().optional(),
  sig: Rf
}), X2 = Te.object({
  max_spent: Te.number().nonnegative(),
  signature: Rf
}), ey = Te.object({
  id: Te.string().nonempty(),
  meta: Te.object({
    user_id: Te.string().nonempty()
  }),
  auth: Rf,
  offer: J2,
  params: Te.any().optional(),
  signed_transaction: X2.optional(),
  abort: Te.boolean().optional()
});
ey.merge(
  Te.object({
    auth: Rf
  })
);
const Q2 = Te.object({
  input: Te.object({
    tokens: Te.number(),
    bytes: Te.number()
  }),
  output: Te.object({
    tokens: Te.number(),
    bytes: Te.number()
  })
}), ag = Te.object({
  id: Te.string(),
  user_id: Te.string(),
  details: Q2,
  total_bytes: Te.number(),
  total_tokens: Te.number(),
  offer: J2,
  sig: Te.string()
}), Tf = Te.object({
  request_id: Te.string().nonempty(),
  msg: Te.any().optional(),
  code: Te.string().optional(),
  data: Te.any().optional()
});
Tf.merge(
  Te.object({
    status: Te.literal("ready")
  })
);
Tf.merge(
  Te.object({
    status: Te.literal("data")
  })
);
Tf.merge(
  Te.object({
    receipt: ag,
    costs: Q2,
    status: Te.literal("complete")
  })
);
Tf.merge(
  Te.object({
    status: Te.literal("challenge"),
    data: Te.object({
      challenge: Te.string()
    })
  })
);
const Ru = Te.lazy(
  () => Te.object({
    type: Te.string(),
    properties: Te.union([Te.record(Ru), Ru]).optional(),
    required: Te.array(Te.string()).optional()
  })
), E3 = Te.object({
  summary: Te.string(),
  operationId: Te.string(),
  tags: Te.array(Te.string()).optional(),
  requestBody: Te.object({
    required: Te.boolean(),
    content: Te.record(
      Te.object({
        schema: Ru
      })
    ).optional()
  }),
  responses: Te.record(
    Te.object({
      description: Te.string(),
      content: Te.record(
        Te.object({
          schema: Ru
        })
      )
    })
  )
}), i1 = Te.object({
  id: Te.string().nonempty(),
  fns: Te.record(Te.any()),
  // TODO: specify this (tired of trying to make zod work with functions)
  schema: Te.object({
    info: Te.object({
      title: Te.string().optional().describe("filled in by the server"),
      description: Te.string().nonempty(),
      version: Te.string().nonempty()
    }),
    paths: Te.record(Te.record(E3)),
    components: Te.object({ schemas: Te.record(Ru) }).optional()
  })
});
function uu(e) {
  if (!Number.isSafeInteger(e) || e < 0)
    throw new Error(`Wrong positive integer: ${e}`);
}
function eE(e, ...t) {
  if (!(e instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (t.length > 0 && !t.includes(e.length))
    throw new Error(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
function ty(e, t = !0) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function tE(e, t) {
  eE(e);
  const r = t.outputLen;
  if (e.length < r)
    throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
const Jc = /* @__PURE__ */ BigInt(2 ** 32 - 1), s1 = /* @__PURE__ */ BigInt(32);
function a1(e, t = !1) {
  return t ? { h: Number(e & Jc), l: Number(e >> s1 & Jc) } : { h: Number(e >> s1 & Jc) | 0, l: Number(e & Jc) | 0 };
}
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const x3 = (e) => e instanceof Uint8Array, O3 = (e) => new Uint8Array(e.buffer, e.byteOffset, e.byteLength), Ql = (e) => new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4)), ef = (e, t) => e << 32 - t | e >>> t, P3 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!P3)
  throw new Error("Non little-endian hardware is not supported");
function S3(e) {
  if (typeof e != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
  return new Uint8Array(new TextEncoder().encode(e));
}
function og(e) {
  if (typeof e == "string" && (e = S3(e)), !x3(e))
    throw new Error(`expected Uint8Array, got ${typeof e}`);
  return e;
}
class A3 {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
}
function C3(e) {
  const t = (n, i) => e(i).update(og(n)).digest(), r = e({});
  return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = (n) => e(n), t;
}
class R3 extends A3 {
  constructor(t, r, n = {}, i, s, a) {
    if (super(), this.blockLen = t, this.outputLen = r, this.length = 0, this.pos = 0, this.finished = !1, this.destroyed = !1, uu(t), uu(r), uu(i), r < 0 || r > i)
      throw new Error("outputLen bigger than keyLen");
    if (n.key !== void 0 && (n.key.length < 1 || n.key.length > i))
      throw new Error(`key must be up 1..${i} byte long or undefined`);
    if (n.salt !== void 0 && n.salt.length !== s)
      throw new Error(`salt must be ${s} byte long or undefined`);
    if (n.personalization !== void 0 && n.personalization.length !== a)
      throw new Error(`personalization must be ${a} byte long or undefined`);
    this.buffer32 = Ql(this.buffer = new Uint8Array(t));
  }
  update(t) {
    ty(this);
    const { blockLen: r, buffer: n, buffer32: i } = this;
    t = og(t);
    const s = t.length, a = t.byteOffset, u = t.buffer;
    for (let c = 0; c < s; ) {
      this.pos === r && (this.compress(i, 0, !1), this.pos = 0);
      const l = Math.min(r - this.pos, s - c), d = a + c;
      if (l === r && !(d % 4) && c + l < s) {
        const p = new Uint32Array(u, d, Math.floor((s - c) / 4));
        for (let h = 0; c + r < s; h += i.length, c += r)
          this.length += r, this.compress(p, h, !1);
        continue;
      }
      n.set(t.subarray(c, c + l), this.pos), this.pos += l, this.length += l, c += l;
    }
    return this;
  }
  digestInto(t) {
    ty(this), tE(t, this);
    const { pos: r, buffer32: n } = this;
    this.finished = !0, this.buffer.subarray(r).fill(0), this.compress(n, 0, !0);
    const i = Ql(t);
    this.get().forEach((s, a) => i[a] = s);
  }
  digest() {
    const { buffer: t, outputLen: r } = this;
    this.digestInto(t);
    const n = t.slice(0, r);
    return this.destroy(), n;
  }
  _cloneInto(t) {
    const { buffer: r, length: n, finished: i, destroyed: s, outputLen: a, pos: u } = this;
    return t || (t = new this.constructor({ dkLen: a })), t.set(...this.get()), t.length = n, t.finished = i, t.destroyed = s, t.outputLen = a, t.buffer.set(r), t.pos = u, t;
  }
}
const vi = /* @__PURE__ */ new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]);
function Gi(e, t, r, n, i) {
  return e = e + t + i | 0, n = ef(n ^ e, 16), r = r + n | 0, t = ef(t ^ r, 12), { a: e, b: t, c: r, d: n };
}
function Ki(e, t, r, n, i) {
  return e = e + t + i | 0, n = ef(n ^ e, 8), r = r + n | 0, t = ef(t ^ r, 7), { a: e, b: t, c: r, d: n };
}
function o1(e, t, r, n, i, s, a, u, c, l, d, p, h, v, y, g, _, m, w, $) {
  let E = 0;
  for (let A = 0; A < n; A++)
    ({ a: i, b: c, c: h, d: _ } = Gi(i, c, h, _, r[t + e[E++]])), { a: i, b: c, c: h, d: _ } = Ki(i, c, h, _, r[t + e[E++]]), { a: s, b: l, c: v, d: m } = Gi(s, l, v, m, r[t + e[E++]]), { a: s, b: l, c: v, d: m } = Ki(s, l, v, m, r[t + e[E++]]), { a, b: d, c: y, d: w } = Gi(a, d, y, w, r[t + e[E++]]), { a, b: d, c: y, d: w } = Ki(a, d, y, w, r[t + e[E++]]), { a: u, b: p, c: g, d: $ } = Gi(u, p, g, $, r[t + e[E++]]), { a: u, b: p, c: g, d: $ } = Ki(u, p, g, $, r[t + e[E++]]), { a: i, b: l, c: y, d: $ } = Gi(i, l, y, $, r[t + e[E++]]), { a: i, b: l, c: y, d: $ } = Ki(i, l, y, $, r[t + e[E++]]), { a: s, b: d, c: g, d: _ } = Gi(s, d, g, _, r[t + e[E++]]), { a: s, b: d, c: g, d: _ } = Ki(s, d, g, _, r[t + e[E++]]), { a, b: p, c: h, d: m } = Gi(a, p, h, m, r[t + e[E++]]), { a, b: p, c: h, d: m } = Ki(a, p, h, m, r[t + e[E++]]), { a: u, b: c, c: v, d: w } = Gi(u, c, v, w, r[t + e[E++]]), { a: u, b: c, c: v, d: w } = Ki(u, c, v, w, r[t + e[E++]]);
  return { v0: i, v1: s, v2: a, v3: u, v4: c, v5: l, v6: d, v7: p, v8: h, v9: v, v10: y, v11: g, v12: _, v13: m, v14: w, v15: $ };
}
const u1 = /* @__PURE__ */ (() => {
  const e = Array.from({ length: 16 }, (n, i) => i), t = (n) => [2, 6, 3, 10, 7, 0, 4, 13, 1, 11, 12, 5, 9, 14, 15, 8].map((i) => n[i]), r = [];
  for (let n = 0, i = e; n < 7; n++, i = t(i))
    r.push(...i);
  return Uint8Array.from(r);
})();
class ug extends R3 {
  constructor(t = {}, r = 0) {
    if (super(64, t.dkLen === void 0 ? 32 : t.dkLen, {}, Number.MAX_SAFE_INTEGER, 0, 0), this.flags = 0, this.chunkPos = 0, this.chunksDone = 0, this.stack = [], this.posOut = 0, this.bufferOut32 = new Uint32Array(16), this.chunkOut = 0, this.enableXOF = !0, this.outputLen = t.dkLen === void 0 ? 32 : t.dkLen, uu(this.outputLen), t.key !== void 0 && t.context !== void 0)
      throw new Error("Blake3: only key or context can be specified at same time");
    if (t.key !== void 0) {
      const n = og(t.key).slice();
      if (n.length !== 32)
        throw new Error("Blake3: key should be 32 byte");
      this.IV = Ql(n), this.flags = r | 16;
    } else if (t.context !== void 0) {
      const n = new ug(
        { dkLen: 32 },
        32
        /* Flags.DERIVE_KEY_CONTEXT */
      ).update(t.context).digest();
      this.IV = Ql(n), this.flags = r | 64;
    } else
      this.IV = vi.slice(), this.flags = r;
    this.state = this.IV.slice(), this.bufferOut = O3(this.bufferOut32);
  }
  // Unused
  get() {
    return [];
  }
  set() {
  }
  b2Compress(t, r, n, i = 0) {
    const { state: s, pos: a } = this, { h: u, l: c } = a1(BigInt(t), !0), { v0: l, v1: d, v2: p, v3: h, v4: v, v5: y, v6: g, v7: _, v8: m, v9: w, v10: $, v11: E, v12: A, v13: R, v14: I, v15: D } = o1(u1, i, n, 7, s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7], vi[0], vi[1], vi[2], vi[3], u, c, a, r);
    s[0] = l ^ m, s[1] = d ^ w, s[2] = p ^ $, s[3] = h ^ E, s[4] = v ^ A, s[5] = y ^ R, s[6] = g ^ I, s[7] = _ ^ D;
  }
  compress(t, r = 0, n = !1) {
    let i = this.flags;
    if (this.chunkPos || (i |= 1), (this.chunkPos === 15 || n) && (i |= 2), n || (this.pos = this.blockLen), this.b2Compress(this.chunksDone, i, t, r), this.chunkPos += 1, this.chunkPos === 16 || n) {
      let s = this.state;
      this.state = this.IV.slice();
      for (let a, u = this.chunksDone + 1; (n || !(u & 1)) && (a = this.stack.pop()); u >>= 1)
        this.buffer32.set(a, 0), this.buffer32.set(s, 8), this.pos = this.blockLen, this.b2Compress(0, this.flags | 4, this.buffer32, 0), s = this.state, this.state = this.IV.slice();
      this.chunksDone++, this.chunkPos = 0, this.stack.push(s);
    }
    this.pos = 0;
  }
  _cloneInto(t) {
    t = super._cloneInto(t);
    const { IV: r, flags: n, state: i, chunkPos: s, posOut: a, chunkOut: u, stack: c, chunksDone: l } = this;
    return t.state.set(i.slice()), t.stack = c.map((d) => Uint32Array.from(d)), t.IV.set(r), t.flags = n, t.chunkPos = s, t.chunksDone = l, t.posOut = a, t.chunkOut = u, t.enableXOF = this.enableXOF, t.bufferOut32.set(this.bufferOut32), t;
  }
  destroy() {
    this.destroyed = !0, this.state.fill(0), this.buffer32.fill(0), this.IV.fill(0), this.bufferOut32.fill(0);
    for (let t of this.stack)
      t.fill(0);
  }
  // Same as b2Compress, but doesn't modify state and returns 16 u32 array (instead of 8)
  b2CompressOut() {
    const { state: t, pos: r, flags: n, buffer32: i, bufferOut32: s } = this, { h: a, l: u } = a1(BigInt(this.chunkOut++)), { v0: c, v1: l, v2: d, v3: p, v4: h, v5: v, v6: y, v7: g, v8: _, v9: m, v10: w, v11: $, v12: E, v13: A, v14: R, v15: I } = o1(u1, 0, i, 7, t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], vi[0], vi[1], vi[2], vi[3], u, a, r, n);
    s[0] = c ^ _, s[1] = l ^ m, s[2] = d ^ w, s[3] = p ^ $, s[4] = h ^ E, s[5] = v ^ A, s[6] = y ^ R, s[7] = g ^ I, s[8] = t[0] ^ _, s[9] = t[1] ^ m, s[10] = t[2] ^ w, s[11] = t[3] ^ $, s[12] = t[4] ^ E, s[13] = t[5] ^ A, s[14] = t[6] ^ R, s[15] = t[7] ^ I, this.posOut = 0;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0, this.buffer.fill(0, this.pos);
    let t = this.flags | 8;
    this.stack.length ? (t |= 4, this.compress(this.buffer32, 0, !0), this.chunksDone = 0, this.pos = this.blockLen) : t |= (this.chunkPos ? 0 : 1) | 2, this.flags = t, this.b2CompressOut();
  }
  writeInto(t) {
    ty(this, !1), eE(t), this.finish();
    const { blockLen: r, bufferOut: n } = this;
    for (let i = 0, s = t.length; i < s; ) {
      this.posOut >= r && this.b2CompressOut();
      const a = Math.min(r - this.posOut, s - i);
      t.set(n.subarray(this.posOut, this.posOut + a), i), this.posOut += a, i += a;
    }
    return t;
  }
  xofInto(t) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible after digest call");
    return this.writeInto(t);
  }
  xof(t) {
    return uu(t), this.xofInto(new Uint8Array(t));
  }
  digestInto(t) {
    if (tE(t, this), this.finished)
      throw new Error("digest() was already called");
    return this.enableXOF = !1, this.writeInto(t), this.destroy(), t;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
}
const T3 = /* @__PURE__ */ C3((e) => new ug(e));
var rt = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function ea(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function If(e) {
  if (e.__esModule)
    return e;
  var t = e.default;
  if (typeof t == "function") {
    var r = function n() {
      return this instanceof n ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    r.prototype = t.prototype;
  } else
    r = {};
  return Object.defineProperty(r, "__esModule", { value: !0 }), Object.keys(e).forEach(function(n) {
    var i = Object.getOwnPropertyDescriptor(e, n);
    Object.defineProperty(r, n, i.get ? i : {
      enumerable: !0,
      get: function() {
        return e[n];
      }
    });
  }), r;
}
var ry = { exports: {} };
function rE(e) {
  return e.length;
}
function I3(e) {
  const t = e.byteLength;
  let r = "";
  for (let n = 0; n < t; n++)
    r += String.fromCharCode(e[n]);
  return r;
}
function j3(e, t, r = 0, n = rE(t)) {
  const i = Math.min(n, e.byteLength - r);
  for (let s = 0; s < i; s++)
    e[r + s] = t.charCodeAt(s);
  return i;
}
var k3 = {
  byteLength: rE,
  toString: I3,
  write: j3
};
const Fa = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", Bs = new Uint8Array(256);
for (let e = 0; e < Fa.length; e++)
  Bs[Fa.charCodeAt(e)] = e;
Bs[
  /* - */
  45
] = 62;
Bs[
  /* _ */
  95
] = 63;
function nE(e) {
  let t = e.length;
  return e.charCodeAt(t - 1) === 61 && t--, t > 1 && e.charCodeAt(t - 1) === 61 && t--, t * 3 >>> 2;
}
function M3(e) {
  const t = e.byteLength;
  let r = "";
  for (let n = 0; n < t; n += 3)
    r += Fa[e[n] >> 2] + Fa[(e[n] & 3) << 4 | e[n + 1] >> 4] + Fa[(e[n + 1] & 15) << 2 | e[n + 2] >> 6] + Fa[e[n + 2] & 63];
  return t % 3 === 2 ? r = r.substring(0, r.length - 1) + "=" : t % 3 === 1 && (r = r.substring(0, r.length - 2) + "=="), r;
}
function N3(e, t, r = 0, n = nE(t)) {
  const i = Math.min(n, e.byteLength - r);
  for (let s = 0, a = 0; a < i; s += 4) {
    const u = Bs[t.charCodeAt(s)], c = Bs[t.charCodeAt(s + 1)], l = Bs[t.charCodeAt(s + 2)], d = Bs[t.charCodeAt(s + 3)];
    e[a++] = u << 2 | c >> 4, e[a++] = (c & 15) << 4 | l >> 2, e[a++] = (l & 3) << 6 | d & 63;
  }
  return i;
}
var D3 = {
  byteLength: nE,
  toString: M3,
  write: N3
};
function iE(e) {
  return e.length >>> 1;
}
function L3(e) {
  const t = e.byteLength;
  e = new DataView(e.buffer, e.byteOffset, t);
  let r = "", n = 0;
  for (let i = t - t % 4; n < i; n += 4)
    r += e.getUint32(n).toString(16).padStart(8, "0");
  for (; n < t; n++)
    r += e.getUint8(n).toString(16).padStart(2, "0");
  return r;
}
function q3(e, t, r = 0, n = iE(t)) {
  const i = Math.min(n, e.byteLength - r);
  for (let s = 0; s < i; s++) {
    const a = c1(t.charCodeAt(s * 2)), u = c1(t.charCodeAt(s * 2 + 1));
    if (a === void 0 || u === void 0)
      return e.subarray(0, s);
    e[r + s] = a << 4 | u;
  }
  return i;
}
var F3 = {
  byteLength: iE,
  toString: L3,
  write: q3
};
function c1(e) {
  if (e >= 48 && e <= 57)
    return e - 48;
  if (e >= 65 && e <= 70)
    return e - 65 + 10;
  if (e >= 97 && e <= 102)
    return e - 97 + 10;
}
function ny(e) {
  let t = 0;
  for (let r = 0, n = e.length; r < n; r++) {
    const i = e.charCodeAt(r);
    if (i >= 55296 && i <= 56319 && r + 1 < n) {
      const s = e.charCodeAt(r + 1);
      if (s >= 56320 && s <= 57343) {
        t += 4, r++;
        continue;
      }
    }
    i <= 127 ? t += 1 : i <= 2047 ? t += 2 : t += 3;
  }
  return t;
}
let iy;
if (typeof TextDecoder < "u") {
  const e = new TextDecoder();
  iy = function(r) {
    return e.decode(r);
  };
} else
  iy = function(t) {
    const r = t.byteLength;
    let n = "", i = 0;
    for (; i < r; ) {
      let s = t[i];
      if (s <= 127) {
        n += String.fromCharCode(s), i++;
        continue;
      }
      let a = 0, u = 0;
      if (s <= 223 ? (a = 1, u = s & 31) : s <= 239 ? (a = 2, u = s & 15) : s <= 244 && (a = 3, u = s & 7), r - i - a > 0) {
        let c = 0;
        for (; c < a; )
          s = t[i + c + 1], u = u << 6 | s & 63, c += 1;
      } else
        u = 65533, a = r - i;
      n += String.fromCodePoint(u), i += a + 1;
    }
    return n;
  };
let sy;
if (typeof TextEncoder < "u") {
  const e = new TextEncoder();
  sy = function(r, n, i = 0, s = ny(n)) {
    const a = Math.min(s, r.byteLength - i);
    return e.encodeInto(n, r.subarray(i, i + a)), a;
  };
} else
  sy = function(t, r, n = 0, i = ny(r)) {
    const s = Math.min(i, t.byteLength - n);
    t = t.subarray(n, n + s);
    let a = 0, u = 0;
    for (; a < r.length; ) {
      const c = r.codePointAt(a);
      if (c <= 127) {
        t[u++] = c, a++;
        continue;
      }
      let l = 0, d = 0;
      for (c <= 2047 ? (l = 6, d = 192) : c <= 65535 ? (l = 12, d = 224) : c <= 2097151 && (l = 18, d = 240), t[u++] = d | c >> l, l -= 6; l >= 0; )
        t[u++] = 128 | c >> l & 63, l -= 6;
      a += c >= 65536 ? 2 : 1;
    }
    return s;
  };
var U3 = {
  byteLength: ny,
  toString: iy,
  write: sy
};
function sE(e) {
  return e.length * 2;
}
function B3(e) {
  const t = e.byteLength;
  let r = "";
  for (let n = 0; n < t - 1; n += 2)
    r += String.fromCharCode(e[n] + e[n + 1] * 256);
  return r;
}
function V3(e, t, r = 0, n = sE(t)) {
  const i = Math.min(n, e.byteLength - r);
  let s = i;
  for (let a = 0; a < t.length && !((s -= 2) < 0); ++a) {
    const u = t.charCodeAt(a), c = u >> 8, l = u % 256;
    e[r + a * 2] = l, e[r + a * 2 + 1] = c;
  }
  return i;
}
var Z3 = {
  byteLength: sE,
  toString: B3,
  write: V3
};
(function(e, t) {
  const r = k3, n = D3, i = F3, s = U3, a = Z3, u = new Uint8Array(Uint16Array.of(255).buffer)[0] === 255;
  function c(T) {
    switch (T) {
      case "ascii":
        return r;
      case "base64":
        return n;
      case "hex":
        return i;
      case "utf8":
      case "utf-8":
      case void 0:
        return s;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return a;
      default:
        throw new Error(`Unknown encoding: ${T}`);
    }
  }
  function l(T) {
    return T instanceof Uint8Array;
  }
  function d(T) {
    try {
      return c(T), !0;
    } catch {
      return !1;
    }
  }
  function p(T, Z, Y) {
    const k = new Uint8Array(T);
    return Z !== void 0 && t.fill(k, Z, 0, k.byteLength, Y), k;
  }
  function h(T) {
    return new Uint8Array(T);
  }
  function v(T) {
    return new Uint8Array(T);
  }
  function y(T, Z) {
    return c(Z).byteLength(T);
  }
  function g(T, Z) {
    if (T === Z)
      return 0;
    const Y = Math.min(T.byteLength, Z.byteLength);
    T = new DataView(T.buffer, T.byteOffset, T.byteLength), Z = new DataView(Z.buffer, Z.byteOffset, Z.byteLength);
    let k = 0;
    for (let U = Y - Y % 4; k < U; k += 4) {
      const pe = T.getUint32(k, u), we = Z.getUint32(k, u);
      if (pe !== we)
        break;
    }
    for (; k < Y; k++) {
      const U = T.getUint8(k), pe = Z.getUint8(k);
      if (U < pe)
        return -1;
      if (U > pe)
        return 1;
    }
    return T.byteLength > Z.byteLength ? 1 : T.byteLength < Z.byteLength ? -1 : 0;
  }
  function _(T, Z) {
    Z === void 0 && (Z = T.reduce((U, pe) => U + pe.byteLength, 0));
    const Y = new Uint8Array(Z);
    let k = 0;
    for (const U of T) {
      if (k + U.byteLength > Y.byteLength) {
        const pe = U.subarray(0, Y.byteLength - k);
        return Y.set(pe, k), Y;
      }
      Y.set(U, k), k += U.byteLength;
    }
    return Y;
  }
  function m(T, Z, Y = 0, k = 0, U = T.byteLength) {
    if (U > 0 && U < k || U === k || T.byteLength === 0 || Z.byteLength === 0)
      return 0;
    if (Y < 0)
      throw new RangeError("targetStart is out of range");
    if (k < 0 || k >= T.byteLength)
      throw new RangeError("sourceStart is out of range");
    if (U < 0)
      throw new RangeError("sourceEnd is out of range");
    Y >= Z.byteLength && (Y = Z.byteLength), U > T.byteLength && (U = T.byteLength), Z.byteLength - Y < U - k && (U = Z.length - Y + k);
    const pe = U - k;
    return T === Z ? Z.copyWithin(Y, k, U) : Z.set(T.subarray(k, U), Y), pe;
  }
  function w(T, Z) {
    if (T === Z)
      return !0;
    if (T.byteLength !== Z.byteLength)
      return !1;
    const Y = T.byteLength;
    T = new DataView(T.buffer, T.byteOffset, T.byteLength), Z = new DataView(Z.buffer, Z.byteOffset, Z.byteLength);
    let k = 0;
    for (let U = Y - Y % 4; k < U; k += 4)
      if (T.getUint32(k, u) !== Z.getUint32(k, u))
        return !1;
    for (; k < Y; k++)
      if (T.getUint8(k) !== Z.getUint8(k))
        return !1;
    return !0;
  }
  function $(T, Z, Y, k, U) {
    if (typeof Z == "string" ? typeof Y == "string" ? (U = Y, Y = 0, k = T.byteLength) : typeof k == "string" && (U = k, k = T.byteLength) : typeof Z == "number" ? Z = Z & 255 : typeof Z == "boolean" && (Z = +Z), Y < 0 || T.byteLength < Y || T.byteLength < k)
      throw new RangeError("Out of range index");
    if (Y === void 0 && (Y = 0), k === void 0 && (k = T.byteLength), k <= Y)
      return T;
    if (Z || (Z = 0), typeof Z == "number")
      for (let pe = Y; pe < k; ++pe)
        T[pe] = Z;
    else {
      Z = l(Z) ? Z : E(Z, U);
      const pe = Z.byteLength;
      for (let we = 0; we < k - Y; ++we)
        T[we + Y] = Z[we % pe];
    }
    return T;
  }
  function E(T, Z, Y) {
    return typeof T == "string" ? A(T, Z) : Array.isArray(T) ? R(T) : ArrayBuffer.isView(T) ? I(T) : D(T, Z, Y);
  }
  function A(T, Z) {
    const Y = c(Z), k = new Uint8Array(Y.byteLength(T));
    return Y.write(k, T, 0, k.byteLength), k;
  }
  function R(T) {
    const Z = new Uint8Array(T.length);
    return Z.set(T), Z;
  }
  function I(T) {
    const Z = new Uint8Array(T.byteLength);
    return Z.set(T), Z;
  }
  function D(T, Z, Y) {
    return new Uint8Array(T, Z, Y);
  }
  function J(T, Z, Y, k) {
    return ye(T, Z, Y, k) !== -1;
  }
  function ae(T, Z, Y, k, U) {
    if (T.byteLength === 0)
      return -1;
    if (typeof Y == "string" ? (k = Y, Y = 0) : Y === void 0 ? Y = U ? 0 : T.length - 1 : Y < 0 && (Y += T.byteLength), Y >= T.byteLength) {
      if (U)
        return -1;
      Y = T.byteLength - 1;
    } else if (Y < 0)
      if (U)
        Y = 0;
      else
        return -1;
    if (typeof Z == "string")
      Z = E(Z, k);
    else if (typeof Z == "number")
      return Z = Z & 255, U ? T.indexOf(Z, Y) : T.lastIndexOf(Z, Y);
    if (Z.byteLength === 0)
      return -1;
    if (U) {
      let pe = -1;
      for (let we = Y; we < T.byteLength; we++)
        if (T[we] === Z[pe === -1 ? 0 : we - pe]) {
          if (pe === -1 && (pe = we), we - pe + 1 === Z.byteLength)
            return pe;
        } else
          pe !== -1 && (we -= we - pe), pe = -1;
    } else {
      Y + Z.byteLength > T.byteLength && (Y = T.byteLength - Z.byteLength);
      for (let pe = Y; pe >= 0; pe--) {
        let we = !0;
        for (let He = 0; He < Z.byteLength; He++)
          if (T[pe + He] !== Z[He]) {
            we = !1;
            break;
          }
        if (we)
          return pe;
      }
    }
    return -1;
  }
  function ye(T, Z, Y, k) {
    return ae(
      T,
      Z,
      Y,
      k,
      !0
      /* first */
    );
  }
  function xe(T, Z, Y, k) {
    return ae(
      T,
      Z,
      Y,
      k,
      !1
      /* last */
    );
  }
  function je(T, Z, Y) {
    const k = T[Z];
    T[Z] = T[Y], T[Y] = k;
  }
  function re(T) {
    const Z = T.byteLength;
    if (Z % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let Y = 0; Y < Z; Y += 2)
      je(T, Y, Y + 1);
    return T;
  }
  function fe(T) {
    const Z = T.byteLength;
    if (Z % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let Y = 0; Y < Z; Y += 4)
      je(T, Y, Y + 3), je(T, Y + 1, Y + 2);
    return T;
  }
  function le(T) {
    const Z = T.byteLength;
    if (Z % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let Y = 0; Y < Z; Y += 8)
      je(T, Y, Y + 7), je(T, Y + 1, Y + 6), je(T, Y + 2, Y + 5), je(T, Y + 3, Y + 4);
    return T;
  }
  function $e(T) {
    return T;
  }
  function Ae(T, Z, Y = 0, k = T.byteLength) {
    const U = T.byteLength;
    return Y >= U || k <= Y ? "" : (Y < 0 && (Y = 0), k > U && (k = U), (Y !== 0 || k < U) && (T = T.subarray(Y, k)), c(Z).toString(T));
  }
  function _e(T, Z, Y, k, U) {
    return Y === void 0 ? U = "utf8" : k === void 0 && typeof Y == "string" ? (U = Y, Y = void 0) : U === void 0 && typeof k == "string" && (U = k, k = void 0), c(U).write(T, Z, Y, k);
  }
  function ie(T, Z, Y) {
    return Y === void 0 && (Y = 0), new DataView(T.buffer, T.byteOffset, T.byteLength).setFloat64(Y, Z, !0), Y + 8;
  }
  function K(T, Z, Y) {
    return Y === void 0 && (Y = 0), new DataView(T.buffer, T.byteOffset, T.byteLength).setFloat32(Y, Z, !0), Y + 4;
  }
  function V(T, Z, Y) {
    return Y === void 0 && (Y = 0), new DataView(T.buffer, T.byteOffset, T.byteLength).setUint32(Y, Z, !0), Y + 4;
  }
  function z(T, Z, Y) {
    return Y === void 0 && (Y = 0), new DataView(T.buffer, T.byteOffset, T.byteLength).setInt32(Y, Z, !0), Y + 4;
  }
  function C(T, Z) {
    return Z === void 0 && (Z = 0), new DataView(T.buffer, T.byteOffset, T.byteLength).getFloat64(Z, !0);
  }
  function q(T, Z) {
    return Z === void 0 && (Z = 0), new DataView(T.buffer, T.byteOffset, T.byteLength).getFloat32(Z, !0);
  }
  function N(T, Z) {
    return Z === void 0 && (Z = 0), new DataView(T.buffer, T.byteOffset, T.byteLength).getUint32(Z, !0);
  }
  function F(T, Z) {
    return Z === void 0 && (Z = 0), new DataView(T.buffer, T.byteOffset, T.byteLength).getInt32(Z, !0);
  }
  e.exports = t = {
    isBuffer: l,
    isEncoding: d,
    alloc: p,
    allocUnsafe: h,
    allocUnsafeSlow: v,
    byteLength: y,
    compare: g,
    concat: _,
    copy: m,
    equals: w,
    fill: $,
    from: E,
    includes: J,
    indexOf: ye,
    lastIndexOf: xe,
    swap16: re,
    swap32: fe,
    swap64: le,
    toBuffer: $e,
    toString: Ae,
    write: _e,
    writeDoubleLE: ie,
    writeFloatLE: K,
    writeUInt32LE: V,
    writeInt32LE: z,
    readDoubleLE: C,
    readFloatLE: q,
    readUInt32LE: N,
    readInt32LE: F
  };
})(ry, ry.exports);
var z3 = ry.exports;
const yn = /* @__PURE__ */ ea(z3);
/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
const cg = 2n ** 256n, as = cg - 0x1000003d1n, fr = cg - 0x14551231950b75fc4402da1732fc9bebfn, aE = 0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798n, oE = 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8n, uE = { p: as, n: fr, a: 0n, b: 7n, Gx: aE, Gy: oE }, Sr = 32, l1 = (e) => Be(Be(e * e) * e + uE.b), Bt = (e = "") => {
  throw new Error(e);
}, jf = (e) => typeof e == "bigint", cE = (e) => typeof e == "string", Sp = (e) => jf(e) && 0n < e && e < as, Tu = (e) => jf(e) && 0n < e && e < fr, lE = (e, t) => (
  // is Uint8Array (of specific length)
  !(e instanceof Uint8Array) || typeof t == "number" && t > 0 && e.length !== t ? Bt("Uint8Array expected") : e
), tn = (e) => new Uint8Array(e), Ci = (e, t) => lE(cE(e) ? zu(e) : tn(e), t), Be = (e, t = as) => {
  let r = e % t;
  return r >= 0n ? r : t + r;
}, f1 = (e) => e instanceof Pr ? e : Bt("Point expected");
let d1;
class Pr {
  constructor(t, r, n) {
    this.px = t, this.py = r, this.pz = n;
  }
  //3d=less inversions
  static fromAffine(t) {
    return new Pr(t.x, t.y, 1n);
  }
  static fromHex(t) {
    t = Ci(t);
    let r;
    const n = t[0], i = t.subarray(1), s = tf(i, 0, Sr), a = t.length;
    if (a === 33 && [2, 3].includes(n)) {
      Sp(s) || Bt("Point hex invalid: x not FE");
      let u = W3(l1(s));
      const c = (u & 1n) === 1n;
      (n & 1) === 1 !== c && (u = Be(-u)), r = new Pr(s, u, 1n);
    }
    return a === 65 && n === 4 && (r = new Pr(s, tf(i, Sr, 2 * Sr), 1n)), r ? r.ok() : Bt("Point is not on curve");
  }
  static fromPrivateKey(t) {
    return xi.mul(rf(t));
  }
  // Create point from a private key.
  get x() {
    return this.aff().x;
  }
  // .x, .y will call expensive toAffine:
  get y() {
    return this.aff().y;
  }
  // should be used with care.
  equals(t) {
    const { px: r, py: n, pz: i } = this, { px: s, py: a, pz: u } = f1(t), c = Be(r * u), l = Be(s * i), d = Be(n * u), p = Be(a * i);
    return c === l && d === p;
  }
  negate() {
    return new Pr(this.px, Be(-this.py), this.pz);
  }
  // Flip point over y coord
  double() {
    return this.add(this);
  }
  // Point doubling: P+P, complete formula.
  add(t) {
    const { px: r, py: n, pz: i } = this, { px: s, py: a, pz: u } = f1(t), { a: c, b: l } = uE;
    let d = 0n, p = 0n, h = 0n;
    const v = Be(l * 3n);
    let y = Be(r * s), g = Be(n * a), _ = Be(i * u), m = Be(r + n), w = Be(s + a);
    m = Be(m * w), w = Be(y + g), m = Be(m - w), w = Be(r + i);
    let $ = Be(s + u);
    return w = Be(w * $), $ = Be(y + _), w = Be(w - $), $ = Be(n + i), d = Be(a + u), $ = Be($ * d), d = Be(g + _), $ = Be($ - d), h = Be(c * w), d = Be(v * _), h = Be(d + h), d = Be(g - h), h = Be(g + h), p = Be(d * h), g = Be(y + y), g = Be(g + y), _ = Be(c * _), w = Be(v * w), g = Be(g + _), _ = Be(y - _), _ = Be(c * _), w = Be(w + _), y = Be(g * w), p = Be(p + y), y = Be($ * w), d = Be(m * d), d = Be(d - y), y = Be(m * g), h = Be($ * h), h = Be(h + y), new Pr(d, p, h);
  }
  mul(t, r = !0) {
    if (!r && t === 0n)
      return $l;
    if (Tu(t) || Bt("invalid scalar"), this.equals(xi))
      return eM(t).p;
    let n = $l, i = xi;
    for (let s = this; t > 0n; s = s.double(), t >>= 1n)
      t & 1n ? n = n.add(s) : r && (i = i.add(s));
    return n;
  }
  mulAddQUns(t, r, n) {
    return this.mul(r, !1).add(t.mul(n, !1)).ok();
  }
  // to private keys. Doesn't use Shamir trick
  toAffine() {
    const { px: t, py: r, pz: n } = this;
    if (this.equals($l))
      return { x: 0n, y: 0n };
    if (n === 1n)
      return { x: t, y: r };
    const i = Hu(n);
    return Be(n * i) !== 1n && Bt("invalid inverse"), { x: Be(t * i), y: Be(r * i) };
  }
  assertValidity() {
    const { x: t, y: r } = this.aff();
    return (!Sp(t) || !Sp(r)) && Bt("Point invalid: x or y"), Be(r * r) === l1(t) ? (
      // y = x + ax + b, must be equal
      this
    ) : Bt("Point invalid: not on curve");
  }
  multiply(t) {
    return this.mul(t);
  }
  // Aliases to compress code
  aff() {
    return this.toAffine();
  }
  ok() {
    return this.assertValidity();
  }
  toHex(t = !0) {
    const { x: r, y: n } = this.aff();
    return (t ? (n & 1n) === 0n ? "02" : "03" : "04") + cu(r) + (t ? "" : cu(n));
  }
  toRawBytes(t = !0) {
    return zu(this.toHex(t));
  }
}
Pr.BASE = new Pr(aE, oE, 1n);
Pr.ZERO = new Pr(0n, 1n, 0n);
const { BASE: xi, ZERO: $l } = Pr, fE = (e, t) => e.toString(16).padStart(t, "0"), lg = (e) => Array.from(e).map((t) => fE(t, 2)).join(""), zu = (e) => {
  const t = e.length;
  (!cE(e) || t % 2) && Bt("hex invalid 1");
  const r = tn(t / 2);
  for (let n = 0; n < r.length; n++) {
    const i = n * 2, s = e.slice(i, i + 2), a = Number.parseInt(s, 16);
    (Number.isNaN(a) || a < 0) && Bt("hex invalid 2"), r[n] = a;
  }
  return r;
}, Wu = (e) => BigInt("0x" + (lg(e) || "0")), tf = (e, t, r) => Wu(e.slice(t, r)), kf = (e) => jf(e) && e >= 0n && e < cg ? zu(fE(e, 2 * Sr)) : Bt("bigint expected"), cu = (e) => lg(kf(e)), ay = (...e) => {
  const t = tn(e.reduce((n, i) => n + lE(i).length, 0));
  let r = 0;
  return e.forEach((n) => {
    t.set(n, r), r += n.length;
  }), t;
}, Hu = (e, t = as) => {
  (e === 0n || t <= 0n) && Bt("no inverse n=" + e + " mod=" + t);
  let r = Be(e, t), n = t, i = 0n, s = 1n;
  for (; r !== 0n; ) {
    const a = n / r, u = n % r, c = i - s * a;
    n = r, r = u, i = s, s = c;
  }
  return n === 1n ? Be(i, t) : Bt("no inverse");
}, W3 = (e) => {
  let t = 1n;
  for (let r = e, n = (as + 1n) / 4n; n > 0n; n >>= 1n)
    n & 1n && (t = t * r % as), r = r * r % as;
  return Be(t * t) === e ? t : Bt("sqrt invalid");
}, rf = (e) => (jf(e) || (e = Wu(Ci(e, Sr))), Tu(e) ? e : Bt("private key out of range")), fg = (e) => e > fr >> 1n;
function dE(e, t = !0) {
  return Pr.fromPrivateKey(e).toRawBytes(t);
}
class ro {
  constructor(t, r, n) {
    this.r = t, this.s = r, this.recovery = n, this.assertValidity();
  }
  // constructed outside.
  static fromCompact(t) {
    return t = Ci(t, 64), new ro(tf(t, 0, Sr), tf(t, Sr, 2 * Sr));
  }
  assertValidity() {
    return Tu(this.r) && Tu(this.s) ? this : Bt();
  }
  // 0 < r or s < CURVE.n
  addRecoveryBit(t) {
    return new ro(this.r, this.s, t);
  }
  hasHighS() {
    return fg(this.s);
  }
  recoverPublicKey(t) {
    const { r, s: n, recovery: i } = this;
    [0, 1, 2, 3].includes(i) || Bt("recovery id invalid");
    const s = dg(Ci(t, 32)), a = i === 2 || i === 3 ? r + fr : r;
    a >= as && Bt("q.x invalid");
    const u = i & 1 ? "03" : "02", c = Pr.fromHex(u + cu(a)), l = Hu(a, fr), d = Be(-s * l, fr), p = Be(n * l, fr);
    return xi.mulAddQUns(c, d, p);
  }
  toCompactRawBytes() {
    return zu(this.toCompactHex());
  }
  // Uint8Array 64b compact repr
  toCompactHex() {
    return cu(this.r) + cu(this.s);
  }
  // hex 64b compact repr
}
const pE = (e) => {
  const t = e.length * 8 - 256, r = Wu(e);
  return t > 0 ? r >> BigInt(t) : r;
}, dg = (e) => Be(pE(e), fr), p1 = (e) => kf(e), h1 = () => (
  // We support: 1) browsers 2) node.js 19+ 3) deno, other envs with crypto
  typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0
);
let lu;
const hE = { lowS: !0 }, H3 = { lowS: !0 };
function G3(e, t, r = hE) {
  ["der", "recovered", "canonical"].some((p) => p in r) && Bt("sign() legacy options not supported");
  let { lowS: n } = r;
  n == null && (n = !0);
  const i = dg(Ci(e)), s = p1(i), a = rf(t), u = [p1(a), s];
  let c = r.extraEntropy;
  if (c) {
    c === !0 && (c = Mf.randomBytes(Sr));
    const p = Ci(c);
    p.length !== Sr && Bt(), u.push(p);
  }
  const l = i, d = (p) => {
    const h = pE(p);
    if (!Tu(h))
      return;
    const v = Hu(h, fr), y = xi.mul(h).aff(), g = Be(y.x, fr);
    if (g === 0n)
      return;
    const _ = Be(v * Be(l + Be(a * g, fr), fr), fr);
    if (_ === 0n)
      return;
    let m = _, w = (y.x === g ? 0 : 2) | Number(y.y & 1n);
    return n && fg(_) && (m = Be(-_, fr), w ^= 1), new ro(g, m, w);
  };
  return { seed: ay(...u), k2sig: d };
}
function K3(e) {
  let t = tn(Sr), r = tn(Sr), n = 0;
  const i = () => {
    t.fill(1), r.fill(0), n = 0;
  }, s = "drbg: tried 1000 values";
  if (e) {
    const a = (...l) => Mf.hmacSha256Async(r, t, ...l), u = async (l = tn()) => {
      r = await a(tn([0]), l), t = await a(), l.length !== 0 && (r = await a(tn([1]), l), t = await a());
    }, c = async () => (n++ >= 1e3 && Bt(s), t = await a(), t);
    return async (l, d) => {
      i(), await u(l);
      let p;
      for (; !(p = d(await c())); )
        await u();
      return i(), p;
    };
  } else {
    const a = (...l) => {
      const d = lu;
      return d || Bt("etc.hmacSha256Sync not set"), d(r, t, ...l);
    }, u = (l = tn()) => {
      r = a(tn([0]), l), t = a(), l.length !== 0 && (r = a(tn([1]), l), t = a());
    }, c = () => (n++ >= 1e3 && Bt(s), t = a(), t);
    return (l, d) => {
      i(), u(l);
      let p;
      for (; !(p = d(c())); )
        u();
      return i(), p;
    };
  }
}
async function Y3(e, t, r = hE) {
  const { seed: n, k2sig: i } = G3(e, t, r);
  return K3(!0)(n, i);
}
function J3(e, t, r, n = H3) {
  let { lowS: i } = n;
  i == null && (i = !0), "strict" in n && Bt("verify() legacy options not supported");
  let s, a, u;
  const c = e && typeof e == "object" && "r" in e;
  !c && Ci(e).length !== 2 * Sr && Bt("signature must be 64 bytes");
  try {
    s = c ? new ro(e.r, e.s).assertValidity() : ro.fromCompact(e), a = dg(Ci(t, Sr)), u = r instanceof Pr ? r.ok() : Pr.fromHex(r);
  } catch {
    return !1;
  }
  if (!s)
    return !1;
  const { r: l, s: d } = s;
  if (i && fg(d))
    return !1;
  let p;
  try {
    const v = Hu(d, fr), y = Be(a * v, fr), g = Be(l * v, fr);
    p = xi.mulAddQUns(u, y, g).aff();
  } catch {
    return !1;
  }
  return p ? Be(p.x, fr) === l : !1;
}
function mE(e) {
  e = Ci(e);
  const t = Sr + 8;
  (e.length < t || e.length > 1024) && Bt("expected proper params");
  const r = Be(Wu(e), fr - 1n) + 1n;
  return kf(r);
}
const Mf = {
  hexToBytes: zu,
  bytesToHex: lg,
  concatBytes: ay,
  bytesToNumberBE: Wu,
  numberToBytesBE: kf,
  mod: Be,
  invert: Hu,
  hmacSha256Async: async (e, ...t) => {
    const r = h1();
    if (!r)
      return Bt("etc.hmacSha256Async not set");
    const n = r.subtle, i = await n.importKey("raw", e, { name: "HMAC", hash: { name: "SHA-256" } }, !1, ["sign"]);
    return tn(await n.sign("HMAC", i, ay(...t)));
  },
  hmacSha256Sync: lu,
  hashToPrivateKey: mE,
  randomBytes: (e) => {
    const t = h1();
    return t || Bt("crypto.getRandomValues must be defined"), t.getRandomValues(tn(e));
  }
}, X3 = {
  normPrivateKeyToScalar: rf,
  isValidPrivateKey: (e) => {
    try {
      return !!rf(e);
    } catch {
      return !1;
    }
  },
  randomPrivateKey: () => mE(Mf.randomBytes(Sr + 8)),
  precompute(e = 8, t = xi) {
    return t.multiply(3n), t;
  }
  // no-op
};
Object.defineProperties(Mf, { hmacSha256Sync: {
  configurable: !1,
  get() {
    return lu;
  },
  set(e) {
    lu || (lu = e);
  }
} });
const Ns = 8, Q3 = () => {
  const e = [], t = 256 / Ns + 1;
  let r = xi, n = r;
  for (let i = 0; i < t; i++) {
    n = r, e.push(n);
    for (let s = 1; s < 2 ** (Ns - 1); s++)
      n = n.add(r), e.push(n);
    r = n.double();
  }
  return e;
}, eM = (e) => {
  const t = d1 || (d1 = Q3()), r = (d, p) => {
    let h = p.negate();
    return d ? h : p;
  };
  let n = $l, i = xi;
  const s = 1 + 256 / Ns, a = 2 ** (Ns - 1), u = BigInt(2 ** Ns - 1), c = 2 ** Ns, l = BigInt(Ns);
  for (let d = 0; d < s; d++) {
    const p = d * a;
    let h = Number(e & u);
    e >>= l, h > a && (h -= c, e += 1n);
    const v = p, y = p + Math.abs(h) - 1, g = d % 2 !== 0, _ = h < 0;
    h === 0 ? i = i.add(r(g, t[v])) : n = n.add(r(_, t[y]));
  }
  return { p: n, f: i };
};
function yE(e) {
  throw new Error('Could not dynamically require "' + e + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var pg = { exports: {} }, Ha = typeof Reflect == "object" ? Reflect : null, m1 = Ha && typeof Ha.apply == "function" ? Ha.apply : function(t, r, n) {
  return Function.prototype.apply.call(t, r, n);
}, El;
Ha && typeof Ha.ownKeys == "function" ? El = Ha.ownKeys : Object.getOwnPropertySymbols ? El = function(t) {
  return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t));
} : El = function(t) {
  return Object.getOwnPropertyNames(t);
};
function tM(e) {
  console && console.warn && console.warn(e);
}
var gE = Number.isNaN || function(t) {
  return t !== t;
};
function Vt() {
  Vt.init.call(this);
}
pg.exports = Vt;
pg.exports.once = sM;
Vt.EventEmitter = Vt;
Vt.prototype._events = void 0;
Vt.prototype._eventsCount = 0;
Vt.prototype._maxListeners = void 0;
var y1 = 10;
function Nf(e) {
  if (typeof e != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e);
}
Object.defineProperty(Vt, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return y1;
  },
  set: function(e) {
    if (typeof e != "number" || e < 0 || gE(e))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e + ".");
    y1 = e;
  }
});
Vt.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
Vt.prototype.setMaxListeners = function(t) {
  if (typeof t != "number" || t < 0 || gE(t))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
  return this._maxListeners = t, this;
};
function vE(e) {
  return e._maxListeners === void 0 ? Vt.defaultMaxListeners : e._maxListeners;
}
Vt.prototype.getMaxListeners = function() {
  return vE(this);
};
Vt.prototype.emit = function(t) {
  for (var r = [], n = 1; n < arguments.length; n++)
    r.push(arguments[n]);
  var i = t === "error", s = this._events;
  if (s !== void 0)
    i = i && s.error === void 0;
  else if (!i)
    return !1;
  if (i) {
    var a;
    if (r.length > 0 && (a = r[0]), a instanceof Error)
      throw a;
    var u = new Error("Unhandled error." + (a ? " (" + a.message + ")" : ""));
    throw u.context = a, u;
  }
  var c = s[t];
  if (c === void 0)
    return !1;
  if (typeof c == "function")
    m1(c, this, r);
  else
    for (var l = c.length, d = EE(c, l), n = 0; n < l; ++n)
      m1(d[n], this, r);
  return !0;
};
function bE(e, t, r, n) {
  var i, s, a;
  if (Nf(r), s = e._events, s === void 0 ? (s = e._events = /* @__PURE__ */ Object.create(null), e._eventsCount = 0) : (s.newListener !== void 0 && (e.emit(
    "newListener",
    t,
    r.listener ? r.listener : r
  ), s = e._events), a = s[t]), a === void 0)
    a = s[t] = r, ++e._eventsCount;
  else if (typeof a == "function" ? a = s[t] = n ? [r, a] : [a, r] : n ? a.unshift(r) : a.push(r), i = vE(e), i > 0 && a.length > i && !a.warned) {
    a.warned = !0;
    var u = new Error("Possible EventEmitter memory leak detected. " + a.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    u.name = "MaxListenersExceededWarning", u.emitter = e, u.type = t, u.count = a.length, tM(u);
  }
  return e;
}
Vt.prototype.addListener = function(t, r) {
  return bE(this, t, r, !1);
};
Vt.prototype.on = Vt.prototype.addListener;
Vt.prototype.prependListener = function(t, r) {
  return bE(this, t, r, !0);
};
function rM() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function _E(e, t, r) {
  var n = { fired: !1, wrapFn: void 0, target: e, type: t, listener: r }, i = rM.bind(n);
  return i.listener = r, n.wrapFn = i, i;
}
Vt.prototype.once = function(t, r) {
  return Nf(r), this.on(t, _E(this, t, r)), this;
};
Vt.prototype.prependOnceListener = function(t, r) {
  return Nf(r), this.prependListener(t, _E(this, t, r)), this;
};
Vt.prototype.removeListener = function(t, r) {
  var n, i, s, a, u;
  if (Nf(r), i = this._events, i === void 0)
    return this;
  if (n = i[t], n === void 0)
    return this;
  if (n === r || n.listener === r)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete i[t], i.removeListener && this.emit("removeListener", t, n.listener || r));
  else if (typeof n != "function") {
    for (s = -1, a = n.length - 1; a >= 0; a--)
      if (n[a] === r || n[a].listener === r) {
        u = n[a].listener, s = a;
        break;
      }
    if (s < 0)
      return this;
    s === 0 ? n.shift() : nM(n, s), n.length === 1 && (i[t] = n[0]), i.removeListener !== void 0 && this.emit("removeListener", t, u || r);
  }
  return this;
};
Vt.prototype.off = Vt.prototype.removeListener;
Vt.prototype.removeAllListeners = function(t) {
  var r, n, i;
  if (n = this._events, n === void 0)
    return this;
  if (n.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : n[t] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete n[t]), this;
  if (arguments.length === 0) {
    var s = Object.keys(n), a;
    for (i = 0; i < s.length; ++i)
      a = s[i], a !== "removeListener" && this.removeAllListeners(a);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (r = n[t], typeof r == "function")
    this.removeListener(t, r);
  else if (r !== void 0)
    for (i = r.length - 1; i >= 0; i--)
      this.removeListener(t, r[i]);
  return this;
};
function wE(e, t, r) {
  var n = e._events;
  if (n === void 0)
    return [];
  var i = n[t];
  return i === void 0 ? [] : typeof i == "function" ? r ? [i.listener || i] : [i] : r ? iM(i) : EE(i, i.length);
}
Vt.prototype.listeners = function(t) {
  return wE(this, t, !0);
};
Vt.prototype.rawListeners = function(t) {
  return wE(this, t, !1);
};
Vt.listenerCount = function(e, t) {
  return typeof e.listenerCount == "function" ? e.listenerCount(t) : $E.call(e, t);
};
Vt.prototype.listenerCount = $E;
function $E(e) {
  var t = this._events;
  if (t !== void 0) {
    var r = t[e];
    if (typeof r == "function")
      return 1;
    if (r !== void 0)
      return r.length;
  }
  return 0;
}
Vt.prototype.eventNames = function() {
  return this._eventsCount > 0 ? El(this._events) : [];
};
function EE(e, t) {
  for (var r = new Array(t), n = 0; n < t; ++n)
    r[n] = e[n];
  return r;
}
function nM(e, t) {
  for (; t + 1 < e.length; t++)
    e[t] = e[t + 1];
  e.pop();
}
function iM(e) {
  for (var t = new Array(e.length), r = 0; r < t.length; ++r)
    t[r] = e[r].listener || e[r];
  return t;
}
function sM(e, t) {
  return new Promise(function(r, n) {
    function i(a) {
      e.removeListener(t, s), n(a);
    }
    function s() {
      typeof e.removeListener == "function" && e.removeListener("error", i), r([].slice.call(arguments));
    }
    xE(e, t, s, { once: !0 }), t !== "error" && aM(e, i, { once: !0 });
  });
}
function aM(e, t, r) {
  typeof e.on == "function" && xE(e, "error", t, r);
}
function xE(e, t, r, n) {
  if (typeof e.on == "function")
    n.once ? e.once(t, r) : e.on(t, r);
  else if (typeof e.addEventListener == "function")
    e.addEventListener(t, function i(s) {
      n.once && e.removeEventListener(t, i), r(s);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e);
}
var hg = pg.exports, Me = {}, co = {}, Df = {};
Df.byteLength = cM;
Df.toByteArray = fM;
Df.fromByteArray = hM;
var Kn = [], pn = [], oM = typeof Uint8Array < "u" ? Uint8Array : Array, Ap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var Pa = 0, uM = Ap.length; Pa < uM; ++Pa)
  Kn[Pa] = Ap[Pa], pn[Ap.charCodeAt(Pa)] = Pa;
pn["-".charCodeAt(0)] = 62;
pn["_".charCodeAt(0)] = 63;
function OE(e) {
  var t = e.length;
  if (t % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var r = e.indexOf("=");
  r === -1 && (r = t);
  var n = r === t ? 0 : 4 - r % 4;
  return [r, n];
}
function cM(e) {
  var t = OE(e), r = t[0], n = t[1];
  return (r + n) * 3 / 4 - n;
}
function lM(e, t, r) {
  return (t + r) * 3 / 4 - r;
}
function fM(e) {
  var t, r = OE(e), n = r[0], i = r[1], s = new oM(lM(e, n, i)), a = 0, u = i > 0 ? n - 4 : n, c;
  for (c = 0; c < u; c += 4)
    t = pn[e.charCodeAt(c)] << 18 | pn[e.charCodeAt(c + 1)] << 12 | pn[e.charCodeAt(c + 2)] << 6 | pn[e.charCodeAt(c + 3)], s[a++] = t >> 16 & 255, s[a++] = t >> 8 & 255, s[a++] = t & 255;
  return i === 2 && (t = pn[e.charCodeAt(c)] << 2 | pn[e.charCodeAt(c + 1)] >> 4, s[a++] = t & 255), i === 1 && (t = pn[e.charCodeAt(c)] << 10 | pn[e.charCodeAt(c + 1)] << 4 | pn[e.charCodeAt(c + 2)] >> 2, s[a++] = t >> 8 & 255, s[a++] = t & 255), s;
}
function dM(e) {
  return Kn[e >> 18 & 63] + Kn[e >> 12 & 63] + Kn[e >> 6 & 63] + Kn[e & 63];
}
function pM(e, t, r) {
  for (var n, i = [], s = t; s < r; s += 3)
    n = (e[s] << 16 & 16711680) + (e[s + 1] << 8 & 65280) + (e[s + 2] & 255), i.push(dM(n));
  return i.join("");
}
function hM(e) {
  for (var t, r = e.length, n = r % 3, i = [], s = 16383, a = 0, u = r - n; a < u; a += s)
    i.push(pM(e, a, a + s > u ? u : a + s));
  return n === 1 ? (t = e[r - 1], i.push(
    Kn[t >> 2] + Kn[t << 4 & 63] + "=="
  )) : n === 2 && (t = (e[r - 2] << 8) + e[r - 1], i.push(
    Kn[t >> 10] + Kn[t >> 4 & 63] + Kn[t << 2 & 63] + "="
  )), i.join("");
}
var mg = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
mg.read = function(e, t, r, n, i) {
  var s, a, u = i * 8 - n - 1, c = (1 << u) - 1, l = c >> 1, d = -7, p = r ? i - 1 : 0, h = r ? -1 : 1, v = e[t + p];
  for (p += h, s = v & (1 << -d) - 1, v >>= -d, d += u; d > 0; s = s * 256 + e[t + p], p += h, d -= 8)
    ;
  for (a = s & (1 << -d) - 1, s >>= -d, d += n; d > 0; a = a * 256 + e[t + p], p += h, d -= 8)
    ;
  if (s === 0)
    s = 1 - l;
  else {
    if (s === c)
      return a ? NaN : (v ? -1 : 1) * (1 / 0);
    a = a + Math.pow(2, n), s = s - l;
  }
  return (v ? -1 : 1) * a * Math.pow(2, s - n);
};
mg.write = function(e, t, r, n, i, s) {
  var a, u, c, l = s * 8 - i - 1, d = (1 << l) - 1, p = d >> 1, h = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, v = n ? 0 : s - 1, y = n ? 1 : -1, g = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
  for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (u = isNaN(t) ? 1 : 0, a = d) : (a = Math.floor(Math.log(t) / Math.LN2), t * (c = Math.pow(2, -a)) < 1 && (a--, c *= 2), a + p >= 1 ? t += h / c : t += h * Math.pow(2, 1 - p), t * c >= 2 && (a++, c /= 2), a + p >= d ? (u = 0, a = d) : a + p >= 1 ? (u = (t * c - 1) * Math.pow(2, i), a = a + p) : (u = t * Math.pow(2, p - 1) * Math.pow(2, i), a = 0)); i >= 8; e[r + v] = u & 255, v += y, u /= 256, i -= 8)
    ;
  for (a = a << i | u, l += i; l > 0; e[r + v] = a & 255, v += y, a /= 256, l -= 8)
    ;
  e[r + v - y] |= g * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(e) {
  const t = Df, r = mg, n = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  e.Buffer = u, e.SlowBuffer = w, e.INSPECT_MAX_BYTES = 50;
  const i = 2147483647;
  e.kMaxLength = i, u.TYPED_ARRAY_SUPPORT = s(), !u.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function s() {
    try {
      const L = new Uint8Array(1), x = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(x, Uint8Array.prototype), Object.setPrototypeOf(L, x), L.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(u.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (u.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(u.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (u.isBuffer(this))
        return this.byteOffset;
    }
  });
  function a(L) {
    if (L > i)
      throw new RangeError('The value "' + L + '" is invalid for option "size"');
    const x = new Uint8Array(L);
    return Object.setPrototypeOf(x, u.prototype), x;
  }
  function u(L, x, S) {
    if (typeof L == "number") {
      if (typeof x == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return p(L);
    }
    return c(L, x, S);
  }
  u.poolSize = 8192;
  function c(L, x, S) {
    if (typeof L == "string")
      return h(L, x);
    if (ArrayBuffer.isView(L))
      return y(L);
    if (L == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof L
      );
    if (Ne(L, ArrayBuffer) || L && Ne(L.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (Ne(L, SharedArrayBuffer) || L && Ne(L.buffer, SharedArrayBuffer)))
      return g(L, x, S);
    if (typeof L == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const G = L.valueOf && L.valueOf();
    if (G != null && G !== L)
      return u.from(G, x, S);
    const ce = _(L);
    if (ce)
      return ce;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof L[Symbol.toPrimitive] == "function")
      return u.from(L[Symbol.toPrimitive]("string"), x, S);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof L
    );
  }
  u.from = function(L, x, S) {
    return c(L, x, S);
  }, Object.setPrototypeOf(u.prototype, Uint8Array.prototype), Object.setPrototypeOf(u, Uint8Array);
  function l(L) {
    if (typeof L != "number")
      throw new TypeError('"size" argument must be of type number');
    if (L < 0)
      throw new RangeError('The value "' + L + '" is invalid for option "size"');
  }
  function d(L, x, S) {
    return l(L), L <= 0 ? a(L) : x !== void 0 ? typeof S == "string" ? a(L).fill(x, S) : a(L).fill(x) : a(L);
  }
  u.alloc = function(L, x, S) {
    return d(L, x, S);
  };
  function p(L) {
    return l(L), a(L < 0 ? 0 : m(L) | 0);
  }
  u.allocUnsafe = function(L) {
    return p(L);
  }, u.allocUnsafeSlow = function(L) {
    return p(L);
  };
  function h(L, x) {
    if ((typeof x != "string" || x === "") && (x = "utf8"), !u.isEncoding(x))
      throw new TypeError("Unknown encoding: " + x);
    const S = $(L, x) | 0;
    let G = a(S);
    const ce = G.write(L, x);
    return ce !== S && (G = G.slice(0, ce)), G;
  }
  function v(L) {
    const x = L.length < 0 ? 0 : m(L.length) | 0, S = a(x);
    for (let G = 0; G < x; G += 1)
      S[G] = L[G] & 255;
    return S;
  }
  function y(L) {
    if (Ne(L, Uint8Array)) {
      const x = new Uint8Array(L);
      return g(x.buffer, x.byteOffset, x.byteLength);
    }
    return v(L);
  }
  function g(L, x, S) {
    if (x < 0 || L.byteLength < x)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (L.byteLength < x + (S || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let G;
    return x === void 0 && S === void 0 ? G = new Uint8Array(L) : S === void 0 ? G = new Uint8Array(L, x) : G = new Uint8Array(L, x, S), Object.setPrototypeOf(G, u.prototype), G;
  }
  function _(L) {
    if (u.isBuffer(L)) {
      const x = m(L.length) | 0, S = a(x);
      return S.length === 0 || L.copy(S, 0, 0, x), S;
    }
    if (L.length !== void 0)
      return typeof L.length != "number" || Le(L.length) ? a(0) : v(L);
    if (L.type === "Buffer" && Array.isArray(L.data))
      return v(L.data);
  }
  function m(L) {
    if (L >= i)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i.toString(16) + " bytes");
    return L | 0;
  }
  function w(L) {
    return +L != L && (L = 0), u.alloc(+L);
  }
  u.isBuffer = function(x) {
    return x != null && x._isBuffer === !0 && x !== u.prototype;
  }, u.compare = function(x, S) {
    if (Ne(x, Uint8Array) && (x = u.from(x, x.offset, x.byteLength)), Ne(S, Uint8Array) && (S = u.from(S, S.offset, S.byteLength)), !u.isBuffer(x) || !u.isBuffer(S))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (x === S)
      return 0;
    let G = x.length, ce = S.length;
    for (let me = 0, Oe = Math.min(G, ce); me < Oe; ++me)
      if (x[me] !== S[me]) {
        G = x[me], ce = S[me];
        break;
      }
    return G < ce ? -1 : ce < G ? 1 : 0;
  }, u.isEncoding = function(x) {
    switch (String(x).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, u.concat = function(x, S) {
    if (!Array.isArray(x))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (x.length === 0)
      return u.alloc(0);
    let G;
    if (S === void 0)
      for (S = 0, G = 0; G < x.length; ++G)
        S += x[G].length;
    const ce = u.allocUnsafe(S);
    let me = 0;
    for (G = 0; G < x.length; ++G) {
      let Oe = x[G];
      if (Ne(Oe, Uint8Array))
        me + Oe.length > ce.length ? (u.isBuffer(Oe) || (Oe = u.from(Oe)), Oe.copy(ce, me)) : Uint8Array.prototype.set.call(
          ce,
          Oe,
          me
        );
      else if (u.isBuffer(Oe))
        Oe.copy(ce, me);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      me += Oe.length;
    }
    return ce;
  };
  function $(L, x) {
    if (u.isBuffer(L))
      return L.length;
    if (ArrayBuffer.isView(L) || Ne(L, ArrayBuffer))
      return L.byteLength;
    if (typeof L != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof L
      );
    const S = L.length, G = arguments.length > 2 && arguments[2] === !0;
    if (!G && S === 0)
      return 0;
    let ce = !1;
    for (; ; )
      switch (x) {
        case "ascii":
        case "latin1":
        case "binary":
          return S;
        case "utf8":
        case "utf-8":
          return Ge(L).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return S * 2;
        case "hex":
          return S >>> 1;
        case "base64":
          return Mt(L).length;
        default:
          if (ce)
            return G ? -1 : Ge(L).length;
          x = ("" + x).toLowerCase(), ce = !0;
      }
  }
  u.byteLength = $;
  function E(L, x, S) {
    let G = !1;
    if ((x === void 0 || x < 0) && (x = 0), x > this.length || ((S === void 0 || S > this.length) && (S = this.length), S <= 0) || (S >>>= 0, x >>>= 0, S <= x))
      return "";
    for (L || (L = "utf8"); ; )
      switch (L) {
        case "hex":
          return _e(this, x, S);
        case "utf8":
        case "utf-8":
          return re(this, x, S);
        case "ascii":
          return $e(this, x, S);
        case "latin1":
        case "binary":
          return Ae(this, x, S);
        case "base64":
          return je(this, x, S);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ie(this, x, S);
        default:
          if (G)
            throw new TypeError("Unknown encoding: " + L);
          L = (L + "").toLowerCase(), G = !0;
      }
  }
  u.prototype._isBuffer = !0;
  function A(L, x, S) {
    const G = L[x];
    L[x] = L[S], L[S] = G;
  }
  u.prototype.swap16 = function() {
    const x = this.length;
    if (x % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let S = 0; S < x; S += 2)
      A(this, S, S + 1);
    return this;
  }, u.prototype.swap32 = function() {
    const x = this.length;
    if (x % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let S = 0; S < x; S += 4)
      A(this, S, S + 3), A(this, S + 1, S + 2);
    return this;
  }, u.prototype.swap64 = function() {
    const x = this.length;
    if (x % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let S = 0; S < x; S += 8)
      A(this, S, S + 7), A(this, S + 1, S + 6), A(this, S + 2, S + 5), A(this, S + 3, S + 4);
    return this;
  }, u.prototype.toString = function() {
    const x = this.length;
    return x === 0 ? "" : arguments.length === 0 ? re(this, 0, x) : E.apply(this, arguments);
  }, u.prototype.toLocaleString = u.prototype.toString, u.prototype.equals = function(x) {
    if (!u.isBuffer(x))
      throw new TypeError("Argument must be a Buffer");
    return this === x ? !0 : u.compare(this, x) === 0;
  }, u.prototype.inspect = function() {
    let x = "";
    const S = e.INSPECT_MAX_BYTES;
    return x = this.toString("hex", 0, S).replace(/(.{2})/g, "$1 ").trim(), this.length > S && (x += " ... "), "<Buffer " + x + ">";
  }, n && (u.prototype[n] = u.prototype.inspect), u.prototype.compare = function(x, S, G, ce, me) {
    if (Ne(x, Uint8Array) && (x = u.from(x, x.offset, x.byteLength)), !u.isBuffer(x))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof x
      );
    if (S === void 0 && (S = 0), G === void 0 && (G = x ? x.length : 0), ce === void 0 && (ce = 0), me === void 0 && (me = this.length), S < 0 || G > x.length || ce < 0 || me > this.length)
      throw new RangeError("out of range index");
    if (ce >= me && S >= G)
      return 0;
    if (ce >= me)
      return -1;
    if (S >= G)
      return 1;
    if (S >>>= 0, G >>>= 0, ce >>>= 0, me >>>= 0, this === x)
      return 0;
    let Oe = me - ce, ut = G - S;
    const Dt = Math.min(Oe, ut), Tt = this.slice(ce, me), wt = x.slice(S, G);
    for (let It = 0; It < Dt; ++It)
      if (Tt[It] !== wt[It]) {
        Oe = Tt[It], ut = wt[It];
        break;
      }
    return Oe < ut ? -1 : ut < Oe ? 1 : 0;
  };
  function R(L, x, S, G, ce) {
    if (L.length === 0)
      return -1;
    if (typeof S == "string" ? (G = S, S = 0) : S > 2147483647 ? S = 2147483647 : S < -2147483648 && (S = -2147483648), S = +S, Le(S) && (S = ce ? 0 : L.length - 1), S < 0 && (S = L.length + S), S >= L.length) {
      if (ce)
        return -1;
      S = L.length - 1;
    } else if (S < 0)
      if (ce)
        S = 0;
      else
        return -1;
    if (typeof x == "string" && (x = u.from(x, G)), u.isBuffer(x))
      return x.length === 0 ? -1 : I(L, x, S, G, ce);
    if (typeof x == "number")
      return x = x & 255, typeof Uint8Array.prototype.indexOf == "function" ? ce ? Uint8Array.prototype.indexOf.call(L, x, S) : Uint8Array.prototype.lastIndexOf.call(L, x, S) : I(L, [x], S, G, ce);
    throw new TypeError("val must be string, number or Buffer");
  }
  function I(L, x, S, G, ce) {
    let me = 1, Oe = L.length, ut = x.length;
    if (G !== void 0 && (G = String(G).toLowerCase(), G === "ucs2" || G === "ucs-2" || G === "utf16le" || G === "utf-16le")) {
      if (L.length < 2 || x.length < 2)
        return -1;
      me = 2, Oe /= 2, ut /= 2, S /= 2;
    }
    function Dt(wt, It) {
      return me === 1 ? wt[It] : wt.readUInt16BE(It * me);
    }
    let Tt;
    if (ce) {
      let wt = -1;
      for (Tt = S; Tt < Oe; Tt++)
        if (Dt(L, Tt) === Dt(x, wt === -1 ? 0 : Tt - wt)) {
          if (wt === -1 && (wt = Tt), Tt - wt + 1 === ut)
            return wt * me;
        } else
          wt !== -1 && (Tt -= Tt - wt), wt = -1;
    } else
      for (S + ut > Oe && (S = Oe - ut), Tt = S; Tt >= 0; Tt--) {
        let wt = !0;
        for (let It = 0; It < ut; It++)
          if (Dt(L, Tt + It) !== Dt(x, It)) {
            wt = !1;
            break;
          }
        if (wt)
          return Tt;
      }
    return -1;
  }
  u.prototype.includes = function(x, S, G) {
    return this.indexOf(x, S, G) !== -1;
  }, u.prototype.indexOf = function(x, S, G) {
    return R(this, x, S, G, !0);
  }, u.prototype.lastIndexOf = function(x, S, G) {
    return R(this, x, S, G, !1);
  };
  function D(L, x, S, G) {
    S = Number(S) || 0;
    const ce = L.length - S;
    G ? (G = Number(G), G > ce && (G = ce)) : G = ce;
    const me = x.length;
    G > me / 2 && (G = me / 2);
    let Oe;
    for (Oe = 0; Oe < G; ++Oe) {
      const ut = parseInt(x.substr(Oe * 2, 2), 16);
      if (Le(ut))
        return Oe;
      L[S + Oe] = ut;
    }
    return Oe;
  }
  function J(L, x, S, G) {
    return St(Ge(x, L.length - S), L, S, G);
  }
  function ae(L, x, S, G) {
    return St(jt(x), L, S, G);
  }
  function ye(L, x, S, G) {
    return St(Mt(x), L, S, G);
  }
  function xe(L, x, S, G) {
    return St(Ee(x, L.length - S), L, S, G);
  }
  u.prototype.write = function(x, S, G, ce) {
    if (S === void 0)
      ce = "utf8", G = this.length, S = 0;
    else if (G === void 0 && typeof S == "string")
      ce = S, G = this.length, S = 0;
    else if (isFinite(S))
      S = S >>> 0, isFinite(G) ? (G = G >>> 0, ce === void 0 && (ce = "utf8")) : (ce = G, G = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const me = this.length - S;
    if ((G === void 0 || G > me) && (G = me), x.length > 0 && (G < 0 || S < 0) || S > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    ce || (ce = "utf8");
    let Oe = !1;
    for (; ; )
      switch (ce) {
        case "hex":
          return D(this, x, S, G);
        case "utf8":
        case "utf-8":
          return J(this, x, S, G);
        case "ascii":
        case "latin1":
        case "binary":
          return ae(this, x, S, G);
        case "base64":
          return ye(this, x, S, G);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return xe(this, x, S, G);
        default:
          if (Oe)
            throw new TypeError("Unknown encoding: " + ce);
          ce = ("" + ce).toLowerCase(), Oe = !0;
      }
  }, u.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function je(L, x, S) {
    return x === 0 && S === L.length ? t.fromByteArray(L) : t.fromByteArray(L.slice(x, S));
  }
  function re(L, x, S) {
    S = Math.min(L.length, S);
    const G = [];
    let ce = x;
    for (; ce < S; ) {
      const me = L[ce];
      let Oe = null, ut = me > 239 ? 4 : me > 223 ? 3 : me > 191 ? 2 : 1;
      if (ce + ut <= S) {
        let Dt, Tt, wt, It;
        switch (ut) {
          case 1:
            me < 128 && (Oe = me);
            break;
          case 2:
            Dt = L[ce + 1], (Dt & 192) === 128 && (It = (me & 31) << 6 | Dt & 63, It > 127 && (Oe = It));
            break;
          case 3:
            Dt = L[ce + 1], Tt = L[ce + 2], (Dt & 192) === 128 && (Tt & 192) === 128 && (It = (me & 15) << 12 | (Dt & 63) << 6 | Tt & 63, It > 2047 && (It < 55296 || It > 57343) && (Oe = It));
            break;
          case 4:
            Dt = L[ce + 1], Tt = L[ce + 2], wt = L[ce + 3], (Dt & 192) === 128 && (Tt & 192) === 128 && (wt & 192) === 128 && (It = (me & 15) << 18 | (Dt & 63) << 12 | (Tt & 63) << 6 | wt & 63, It > 65535 && It < 1114112 && (Oe = It));
        }
      }
      Oe === null ? (Oe = 65533, ut = 1) : Oe > 65535 && (Oe -= 65536, G.push(Oe >>> 10 & 1023 | 55296), Oe = 56320 | Oe & 1023), G.push(Oe), ce += ut;
    }
    return le(G);
  }
  const fe = 4096;
  function le(L) {
    const x = L.length;
    if (x <= fe)
      return String.fromCharCode.apply(String, L);
    let S = "", G = 0;
    for (; G < x; )
      S += String.fromCharCode.apply(
        String,
        L.slice(G, G += fe)
      );
    return S;
  }
  function $e(L, x, S) {
    let G = "";
    S = Math.min(L.length, S);
    for (let ce = x; ce < S; ++ce)
      G += String.fromCharCode(L[ce] & 127);
    return G;
  }
  function Ae(L, x, S) {
    let G = "";
    S = Math.min(L.length, S);
    for (let ce = x; ce < S; ++ce)
      G += String.fromCharCode(L[ce]);
    return G;
  }
  function _e(L, x, S) {
    const G = L.length;
    (!x || x < 0) && (x = 0), (!S || S < 0 || S > G) && (S = G);
    let ce = "";
    for (let me = x; me < S; ++me)
      ce += at[L[me]];
    return ce;
  }
  function ie(L, x, S) {
    const G = L.slice(x, S);
    let ce = "";
    for (let me = 0; me < G.length - 1; me += 2)
      ce += String.fromCharCode(G[me] + G[me + 1] * 256);
    return ce;
  }
  u.prototype.slice = function(x, S) {
    const G = this.length;
    x = ~~x, S = S === void 0 ? G : ~~S, x < 0 ? (x += G, x < 0 && (x = 0)) : x > G && (x = G), S < 0 ? (S += G, S < 0 && (S = 0)) : S > G && (S = G), S < x && (S = x);
    const ce = this.subarray(x, S);
    return Object.setPrototypeOf(ce, u.prototype), ce;
  };
  function K(L, x, S) {
    if (L % 1 !== 0 || L < 0)
      throw new RangeError("offset is not uint");
    if (L + x > S)
      throw new RangeError("Trying to access beyond buffer length");
  }
  u.prototype.readUintLE = u.prototype.readUIntLE = function(x, S, G) {
    x = x >>> 0, S = S >>> 0, G || K(x, S, this.length);
    let ce = this[x], me = 1, Oe = 0;
    for (; ++Oe < S && (me *= 256); )
      ce += this[x + Oe] * me;
    return ce;
  }, u.prototype.readUintBE = u.prototype.readUIntBE = function(x, S, G) {
    x = x >>> 0, S = S >>> 0, G || K(x, S, this.length);
    let ce = this[x + --S], me = 1;
    for (; S > 0 && (me *= 256); )
      ce += this[x + --S] * me;
    return ce;
  }, u.prototype.readUint8 = u.prototype.readUInt8 = function(x, S) {
    return x = x >>> 0, S || K(x, 1, this.length), this[x];
  }, u.prototype.readUint16LE = u.prototype.readUInt16LE = function(x, S) {
    return x = x >>> 0, S || K(x, 2, this.length), this[x] | this[x + 1] << 8;
  }, u.prototype.readUint16BE = u.prototype.readUInt16BE = function(x, S) {
    return x = x >>> 0, S || K(x, 2, this.length), this[x] << 8 | this[x + 1];
  }, u.prototype.readUint32LE = u.prototype.readUInt32LE = function(x, S) {
    return x = x >>> 0, S || K(x, 4, this.length), (this[x] | this[x + 1] << 8 | this[x + 2] << 16) + this[x + 3] * 16777216;
  }, u.prototype.readUint32BE = u.prototype.readUInt32BE = function(x, S) {
    return x = x >>> 0, S || K(x, 4, this.length), this[x] * 16777216 + (this[x + 1] << 16 | this[x + 2] << 8 | this[x + 3]);
  }, u.prototype.readBigUInt64LE = mt(function(x) {
    x = x >>> 0, pe(x, "offset");
    const S = this[x], G = this[x + 7];
    (S === void 0 || G === void 0) && we(x, this.length - 8);
    const ce = S + this[++x] * 2 ** 8 + this[++x] * 2 ** 16 + this[++x] * 2 ** 24, me = this[++x] + this[++x] * 2 ** 8 + this[++x] * 2 ** 16 + G * 2 ** 24;
    return BigInt(ce) + (BigInt(me) << BigInt(32));
  }), u.prototype.readBigUInt64BE = mt(function(x) {
    x = x >>> 0, pe(x, "offset");
    const S = this[x], G = this[x + 7];
    (S === void 0 || G === void 0) && we(x, this.length - 8);
    const ce = S * 2 ** 24 + this[++x] * 2 ** 16 + this[++x] * 2 ** 8 + this[++x], me = this[++x] * 2 ** 24 + this[++x] * 2 ** 16 + this[++x] * 2 ** 8 + G;
    return (BigInt(ce) << BigInt(32)) + BigInt(me);
  }), u.prototype.readIntLE = function(x, S, G) {
    x = x >>> 0, S = S >>> 0, G || K(x, S, this.length);
    let ce = this[x], me = 1, Oe = 0;
    for (; ++Oe < S && (me *= 256); )
      ce += this[x + Oe] * me;
    return me *= 128, ce >= me && (ce -= Math.pow(2, 8 * S)), ce;
  }, u.prototype.readIntBE = function(x, S, G) {
    x = x >>> 0, S = S >>> 0, G || K(x, S, this.length);
    let ce = S, me = 1, Oe = this[x + --ce];
    for (; ce > 0 && (me *= 256); )
      Oe += this[x + --ce] * me;
    return me *= 128, Oe >= me && (Oe -= Math.pow(2, 8 * S)), Oe;
  }, u.prototype.readInt8 = function(x, S) {
    return x = x >>> 0, S || K(x, 1, this.length), this[x] & 128 ? (255 - this[x] + 1) * -1 : this[x];
  }, u.prototype.readInt16LE = function(x, S) {
    x = x >>> 0, S || K(x, 2, this.length);
    const G = this[x] | this[x + 1] << 8;
    return G & 32768 ? G | 4294901760 : G;
  }, u.prototype.readInt16BE = function(x, S) {
    x = x >>> 0, S || K(x, 2, this.length);
    const G = this[x + 1] | this[x] << 8;
    return G & 32768 ? G | 4294901760 : G;
  }, u.prototype.readInt32LE = function(x, S) {
    return x = x >>> 0, S || K(x, 4, this.length), this[x] | this[x + 1] << 8 | this[x + 2] << 16 | this[x + 3] << 24;
  }, u.prototype.readInt32BE = function(x, S) {
    return x = x >>> 0, S || K(x, 4, this.length), this[x] << 24 | this[x + 1] << 16 | this[x + 2] << 8 | this[x + 3];
  }, u.prototype.readBigInt64LE = mt(function(x) {
    x = x >>> 0, pe(x, "offset");
    const S = this[x], G = this[x + 7];
    (S === void 0 || G === void 0) && we(x, this.length - 8);
    const ce = this[x + 4] + this[x + 5] * 2 ** 8 + this[x + 6] * 2 ** 16 + (G << 24);
    return (BigInt(ce) << BigInt(32)) + BigInt(S + this[++x] * 2 ** 8 + this[++x] * 2 ** 16 + this[++x] * 2 ** 24);
  }), u.prototype.readBigInt64BE = mt(function(x) {
    x = x >>> 0, pe(x, "offset");
    const S = this[x], G = this[x + 7];
    (S === void 0 || G === void 0) && we(x, this.length - 8);
    const ce = (S << 24) + // Overflow
    this[++x] * 2 ** 16 + this[++x] * 2 ** 8 + this[++x];
    return (BigInt(ce) << BigInt(32)) + BigInt(this[++x] * 2 ** 24 + this[++x] * 2 ** 16 + this[++x] * 2 ** 8 + G);
  }), u.prototype.readFloatLE = function(x, S) {
    return x = x >>> 0, S || K(x, 4, this.length), r.read(this, x, !0, 23, 4);
  }, u.prototype.readFloatBE = function(x, S) {
    return x = x >>> 0, S || K(x, 4, this.length), r.read(this, x, !1, 23, 4);
  }, u.prototype.readDoubleLE = function(x, S) {
    return x = x >>> 0, S || K(x, 8, this.length), r.read(this, x, !0, 52, 8);
  }, u.prototype.readDoubleBE = function(x, S) {
    return x = x >>> 0, S || K(x, 8, this.length), r.read(this, x, !1, 52, 8);
  };
  function V(L, x, S, G, ce, me) {
    if (!u.isBuffer(L))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (x > ce || x < me)
      throw new RangeError('"value" argument is out of bounds');
    if (S + G > L.length)
      throw new RangeError("Index out of range");
  }
  u.prototype.writeUintLE = u.prototype.writeUIntLE = function(x, S, G, ce) {
    if (x = +x, S = S >>> 0, G = G >>> 0, !ce) {
      const ut = Math.pow(2, 8 * G) - 1;
      V(this, x, S, G, ut, 0);
    }
    let me = 1, Oe = 0;
    for (this[S] = x & 255; ++Oe < G && (me *= 256); )
      this[S + Oe] = x / me & 255;
    return S + G;
  }, u.prototype.writeUintBE = u.prototype.writeUIntBE = function(x, S, G, ce) {
    if (x = +x, S = S >>> 0, G = G >>> 0, !ce) {
      const ut = Math.pow(2, 8 * G) - 1;
      V(this, x, S, G, ut, 0);
    }
    let me = G - 1, Oe = 1;
    for (this[S + me] = x & 255; --me >= 0 && (Oe *= 256); )
      this[S + me] = x / Oe & 255;
    return S + G;
  }, u.prototype.writeUint8 = u.prototype.writeUInt8 = function(x, S, G) {
    return x = +x, S = S >>> 0, G || V(this, x, S, 1, 255, 0), this[S] = x & 255, S + 1;
  }, u.prototype.writeUint16LE = u.prototype.writeUInt16LE = function(x, S, G) {
    return x = +x, S = S >>> 0, G || V(this, x, S, 2, 65535, 0), this[S] = x & 255, this[S + 1] = x >>> 8, S + 2;
  }, u.prototype.writeUint16BE = u.prototype.writeUInt16BE = function(x, S, G) {
    return x = +x, S = S >>> 0, G || V(this, x, S, 2, 65535, 0), this[S] = x >>> 8, this[S + 1] = x & 255, S + 2;
  }, u.prototype.writeUint32LE = u.prototype.writeUInt32LE = function(x, S, G) {
    return x = +x, S = S >>> 0, G || V(this, x, S, 4, 4294967295, 0), this[S + 3] = x >>> 24, this[S + 2] = x >>> 16, this[S + 1] = x >>> 8, this[S] = x & 255, S + 4;
  }, u.prototype.writeUint32BE = u.prototype.writeUInt32BE = function(x, S, G) {
    return x = +x, S = S >>> 0, G || V(this, x, S, 4, 4294967295, 0), this[S] = x >>> 24, this[S + 1] = x >>> 16, this[S + 2] = x >>> 8, this[S + 3] = x & 255, S + 4;
  };
  function z(L, x, S, G, ce) {
    U(x, G, ce, L, S, 7);
    let me = Number(x & BigInt(4294967295));
    L[S++] = me, me = me >> 8, L[S++] = me, me = me >> 8, L[S++] = me, me = me >> 8, L[S++] = me;
    let Oe = Number(x >> BigInt(32) & BigInt(4294967295));
    return L[S++] = Oe, Oe = Oe >> 8, L[S++] = Oe, Oe = Oe >> 8, L[S++] = Oe, Oe = Oe >> 8, L[S++] = Oe, S;
  }
  function C(L, x, S, G, ce) {
    U(x, G, ce, L, S, 7);
    let me = Number(x & BigInt(4294967295));
    L[S + 7] = me, me = me >> 8, L[S + 6] = me, me = me >> 8, L[S + 5] = me, me = me >> 8, L[S + 4] = me;
    let Oe = Number(x >> BigInt(32) & BigInt(4294967295));
    return L[S + 3] = Oe, Oe = Oe >> 8, L[S + 2] = Oe, Oe = Oe >> 8, L[S + 1] = Oe, Oe = Oe >> 8, L[S] = Oe, S + 8;
  }
  u.prototype.writeBigUInt64LE = mt(function(x, S = 0) {
    return z(this, x, S, BigInt(0), BigInt("0xffffffffffffffff"));
  }), u.prototype.writeBigUInt64BE = mt(function(x, S = 0) {
    return C(this, x, S, BigInt(0), BigInt("0xffffffffffffffff"));
  }), u.prototype.writeIntLE = function(x, S, G, ce) {
    if (x = +x, S = S >>> 0, !ce) {
      const Dt = Math.pow(2, 8 * G - 1);
      V(this, x, S, G, Dt - 1, -Dt);
    }
    let me = 0, Oe = 1, ut = 0;
    for (this[S] = x & 255; ++me < G && (Oe *= 256); )
      x < 0 && ut === 0 && this[S + me - 1] !== 0 && (ut = 1), this[S + me] = (x / Oe >> 0) - ut & 255;
    return S + G;
  }, u.prototype.writeIntBE = function(x, S, G, ce) {
    if (x = +x, S = S >>> 0, !ce) {
      const Dt = Math.pow(2, 8 * G - 1);
      V(this, x, S, G, Dt - 1, -Dt);
    }
    let me = G - 1, Oe = 1, ut = 0;
    for (this[S + me] = x & 255; --me >= 0 && (Oe *= 256); )
      x < 0 && ut === 0 && this[S + me + 1] !== 0 && (ut = 1), this[S + me] = (x / Oe >> 0) - ut & 255;
    return S + G;
  }, u.prototype.writeInt8 = function(x, S, G) {
    return x = +x, S = S >>> 0, G || V(this, x, S, 1, 127, -128), x < 0 && (x = 255 + x + 1), this[S] = x & 255, S + 1;
  }, u.prototype.writeInt16LE = function(x, S, G) {
    return x = +x, S = S >>> 0, G || V(this, x, S, 2, 32767, -32768), this[S] = x & 255, this[S + 1] = x >>> 8, S + 2;
  }, u.prototype.writeInt16BE = function(x, S, G) {
    return x = +x, S = S >>> 0, G || V(this, x, S, 2, 32767, -32768), this[S] = x >>> 8, this[S + 1] = x & 255, S + 2;
  }, u.prototype.writeInt32LE = function(x, S, G) {
    return x = +x, S = S >>> 0, G || V(this, x, S, 4, 2147483647, -2147483648), this[S] = x & 255, this[S + 1] = x >>> 8, this[S + 2] = x >>> 16, this[S + 3] = x >>> 24, S + 4;
  }, u.prototype.writeInt32BE = function(x, S, G) {
    return x = +x, S = S >>> 0, G || V(this, x, S, 4, 2147483647, -2147483648), x < 0 && (x = 4294967295 + x + 1), this[S] = x >>> 24, this[S + 1] = x >>> 16, this[S + 2] = x >>> 8, this[S + 3] = x & 255, S + 4;
  }, u.prototype.writeBigInt64LE = mt(function(x, S = 0) {
    return z(this, x, S, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), u.prototype.writeBigInt64BE = mt(function(x, S = 0) {
    return C(this, x, S, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function q(L, x, S, G, ce, me) {
    if (S + G > L.length)
      throw new RangeError("Index out of range");
    if (S < 0)
      throw new RangeError("Index out of range");
  }
  function N(L, x, S, G, ce) {
    return x = +x, S = S >>> 0, ce || q(L, x, S, 4), r.write(L, x, S, G, 23, 4), S + 4;
  }
  u.prototype.writeFloatLE = function(x, S, G) {
    return N(this, x, S, !0, G);
  }, u.prototype.writeFloatBE = function(x, S, G) {
    return N(this, x, S, !1, G);
  };
  function F(L, x, S, G, ce) {
    return x = +x, S = S >>> 0, ce || q(L, x, S, 8), r.write(L, x, S, G, 52, 8), S + 8;
  }
  u.prototype.writeDoubleLE = function(x, S, G) {
    return F(this, x, S, !0, G);
  }, u.prototype.writeDoubleBE = function(x, S, G) {
    return F(this, x, S, !1, G);
  }, u.prototype.copy = function(x, S, G, ce) {
    if (!u.isBuffer(x))
      throw new TypeError("argument should be a Buffer");
    if (G || (G = 0), !ce && ce !== 0 && (ce = this.length), S >= x.length && (S = x.length), S || (S = 0), ce > 0 && ce < G && (ce = G), ce === G || x.length === 0 || this.length === 0)
      return 0;
    if (S < 0)
      throw new RangeError("targetStart out of bounds");
    if (G < 0 || G >= this.length)
      throw new RangeError("Index out of range");
    if (ce < 0)
      throw new RangeError("sourceEnd out of bounds");
    ce > this.length && (ce = this.length), x.length - S < ce - G && (ce = x.length - S + G);
    const me = ce - G;
    return this === x && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(S, G, ce) : Uint8Array.prototype.set.call(
      x,
      this.subarray(G, ce),
      S
    ), me;
  }, u.prototype.fill = function(x, S, G, ce) {
    if (typeof x == "string") {
      if (typeof S == "string" ? (ce = S, S = 0, G = this.length) : typeof G == "string" && (ce = G, G = this.length), ce !== void 0 && typeof ce != "string")
        throw new TypeError("encoding must be a string");
      if (typeof ce == "string" && !u.isEncoding(ce))
        throw new TypeError("Unknown encoding: " + ce);
      if (x.length === 1) {
        const Oe = x.charCodeAt(0);
        (ce === "utf8" && Oe < 128 || ce === "latin1") && (x = Oe);
      }
    } else
      typeof x == "number" ? x = x & 255 : typeof x == "boolean" && (x = Number(x));
    if (S < 0 || this.length < S || this.length < G)
      throw new RangeError("Out of range index");
    if (G <= S)
      return this;
    S = S >>> 0, G = G === void 0 ? this.length : G >>> 0, x || (x = 0);
    let me;
    if (typeof x == "number")
      for (me = S; me < G; ++me)
        this[me] = x;
    else {
      const Oe = u.isBuffer(x) ? x : u.from(x, ce), ut = Oe.length;
      if (ut === 0)
        throw new TypeError('The value "' + x + '" is invalid for argument "value"');
      for (me = 0; me < G - S; ++me)
        this[me + S] = Oe[me % ut];
    }
    return this;
  };
  const T = {};
  function Z(L, x, S) {
    T[L] = class extends S {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: x.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${L}]`, this.stack, delete this.name;
      }
      get code() {
        return L;
      }
      set code(ce) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: ce,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${L}]: ${this.message}`;
      }
    };
  }
  Z(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(L) {
      return L ? `${L} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), Z(
    "ERR_INVALID_ARG_TYPE",
    function(L, x) {
      return `The "${L}" argument must be of type number. Received type ${typeof x}`;
    },
    TypeError
  ), Z(
    "ERR_OUT_OF_RANGE",
    function(L, x, S) {
      let G = `The value of "${L}" is out of range.`, ce = S;
      return Number.isInteger(S) && Math.abs(S) > 2 ** 32 ? ce = Y(String(S)) : typeof S == "bigint" && (ce = String(S), (S > BigInt(2) ** BigInt(32) || S < -(BigInt(2) ** BigInt(32))) && (ce = Y(ce)), ce += "n"), G += ` It must be ${x}. Received ${ce}`, G;
    },
    RangeError
  );
  function Y(L) {
    let x = "", S = L.length;
    const G = L[0] === "-" ? 1 : 0;
    for (; S >= G + 4; S -= 3)
      x = `_${L.slice(S - 3, S)}${x}`;
    return `${L.slice(0, S)}${x}`;
  }
  function k(L, x, S) {
    pe(x, "offset"), (L[x] === void 0 || L[x + S] === void 0) && we(x, L.length - (S + 1));
  }
  function U(L, x, S, G, ce, me) {
    if (L > S || L < x) {
      const Oe = typeof x == "bigint" ? "n" : "";
      let ut;
      throw me > 3 ? x === 0 || x === BigInt(0) ? ut = `>= 0${Oe} and < 2${Oe} ** ${(me + 1) * 8}${Oe}` : ut = `>= -(2${Oe} ** ${(me + 1) * 8 - 1}${Oe}) and < 2 ** ${(me + 1) * 8 - 1}${Oe}` : ut = `>= ${x}${Oe} and <= ${S}${Oe}`, new T.ERR_OUT_OF_RANGE("value", ut, L);
    }
    k(G, ce, me);
  }
  function pe(L, x) {
    if (typeof L != "number")
      throw new T.ERR_INVALID_ARG_TYPE(x, "number", L);
  }
  function we(L, x, S) {
    throw Math.floor(L) !== L ? (pe(L, S), new T.ERR_OUT_OF_RANGE(S || "offset", "an integer", L)) : x < 0 ? new T.ERR_BUFFER_OUT_OF_BOUNDS() : new T.ERR_OUT_OF_RANGE(
      S || "offset",
      `>= ${S ? 1 : 0} and <= ${x}`,
      L
    );
  }
  const He = /[^+/0-9A-Za-z-_]/g;
  function Fe(L) {
    if (L = L.split("=")[0], L = L.trim().replace(He, ""), L.length < 2)
      return "";
    for (; L.length % 4 !== 0; )
      L = L + "=";
    return L;
  }
  function Ge(L, x) {
    x = x || 1 / 0;
    let S;
    const G = L.length;
    let ce = null;
    const me = [];
    for (let Oe = 0; Oe < G; ++Oe) {
      if (S = L.charCodeAt(Oe), S > 55295 && S < 57344) {
        if (!ce) {
          if (S > 56319) {
            (x -= 3) > -1 && me.push(239, 191, 189);
            continue;
          } else if (Oe + 1 === G) {
            (x -= 3) > -1 && me.push(239, 191, 189);
            continue;
          }
          ce = S;
          continue;
        }
        if (S < 56320) {
          (x -= 3) > -1 && me.push(239, 191, 189), ce = S;
          continue;
        }
        S = (ce - 55296 << 10 | S - 56320) + 65536;
      } else
        ce && (x -= 3) > -1 && me.push(239, 191, 189);
      if (ce = null, S < 128) {
        if ((x -= 1) < 0)
          break;
        me.push(S);
      } else if (S < 2048) {
        if ((x -= 2) < 0)
          break;
        me.push(
          S >> 6 | 192,
          S & 63 | 128
        );
      } else if (S < 65536) {
        if ((x -= 3) < 0)
          break;
        me.push(
          S >> 12 | 224,
          S >> 6 & 63 | 128,
          S & 63 | 128
        );
      } else if (S < 1114112) {
        if ((x -= 4) < 0)
          break;
        me.push(
          S >> 18 | 240,
          S >> 12 & 63 | 128,
          S >> 6 & 63 | 128,
          S & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return me;
  }
  function jt(L) {
    const x = [];
    for (let S = 0; S < L.length; ++S)
      x.push(L.charCodeAt(S) & 255);
    return x;
  }
  function Ee(L, x) {
    let S, G, ce;
    const me = [];
    for (let Oe = 0; Oe < L.length && !((x -= 2) < 0); ++Oe)
      S = L.charCodeAt(Oe), G = S >> 8, ce = S % 256, me.push(ce), me.push(G);
    return me;
  }
  function Mt(L) {
    return t.toByteArray(Fe(L));
  }
  function St(L, x, S, G) {
    let ce;
    for (ce = 0; ce < G && !(ce + S >= x.length || ce >= L.length); ++ce)
      x[ce + S] = L[ce];
    return ce;
  }
  function Ne(L, x) {
    return L instanceof x || L != null && L.constructor != null && L.constructor.name != null && L.constructor.name === x.name;
  }
  function Le(L) {
    return L !== L;
  }
  const at = function() {
    const L = "0123456789abcdef", x = new Array(256);
    for (let S = 0; S < 16; ++S) {
      const G = S * 16;
      for (let ce = 0; ce < 16; ++ce)
        x[G + ce] = L[S] + L[ce];
    }
    return x;
  }();
  function mt(L) {
    return typeof BigInt > "u" ? qe : L;
  }
  function qe() {
    throw new Error("BigInt not supported");
  }
})(co);
var PE = { exports: {} }, ir = PE.exports = {}, Wn, Hn;
function oy() {
  throw new Error("setTimeout has not been defined");
}
function uy() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? Wn = setTimeout : Wn = oy;
  } catch {
    Wn = oy;
  }
  try {
    typeof clearTimeout == "function" ? Hn = clearTimeout : Hn = uy;
  } catch {
    Hn = uy;
  }
})();
function SE(e) {
  if (Wn === setTimeout)
    return setTimeout(e, 0);
  if ((Wn === oy || !Wn) && setTimeout)
    return Wn = setTimeout, setTimeout(e, 0);
  try {
    return Wn(e, 0);
  } catch {
    try {
      return Wn.call(null, e, 0);
    } catch {
      return Wn.call(this, e, 0);
    }
  }
}
function mM(e) {
  if (Hn === clearTimeout)
    return clearTimeout(e);
  if ((Hn === uy || !Hn) && clearTimeout)
    return Hn = clearTimeout, clearTimeout(e);
  try {
    return Hn(e);
  } catch {
    try {
      return Hn.call(null, e);
    } catch {
      return Hn.call(this, e);
    }
  }
}
var $i = [], Ga = !1, Vs, xl = -1;
function yM() {
  !Ga || !Vs || (Ga = !1, Vs.length ? $i = Vs.concat($i) : xl = -1, $i.length && AE());
}
function AE() {
  if (!Ga) {
    var e = SE(yM);
    Ga = !0;
    for (var t = $i.length; t; ) {
      for (Vs = $i, $i = []; ++xl < t; )
        Vs && Vs[xl].run();
      xl = -1, t = $i.length;
    }
    Vs = null, Ga = !1, mM(e);
  }
}
ir.nextTick = function(e) {
  var t = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var r = 1; r < arguments.length; r++)
      t[r - 1] = arguments[r];
  $i.push(new CE(e, t)), $i.length === 1 && !Ga && SE(AE);
};
function CE(e, t) {
  this.fun = e, this.array = t;
}
CE.prototype.run = function() {
  this.fun.apply(null, this.array);
};
ir.title = "browser";
ir.browser = !0;
ir.env = {};
ir.argv = [];
ir.version = "";
ir.versions = {};
function Ii() {
}
ir.on = Ii;
ir.addListener = Ii;
ir.once = Ii;
ir.off = Ii;
ir.removeListener = Ii;
ir.removeAllListeners = Ii;
ir.emit = Ii;
ir.prependListener = Ii;
ir.prependOnceListener = Ii;
ir.listeners = function(e) {
  return [];
};
ir.binding = function(e) {
  throw new Error("process.binding is not supported");
};
ir.cwd = function() {
  return "/";
};
ir.chdir = function(e) {
  throw new Error("process.chdir is not supported");
};
ir.umask = function() {
  return 0;
};
var gM = PE.exports;
(function(e) {
  Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
  const t = co, r = gM, n = (a) => a && a.__esModule ? a : { default: a }, i = n(r), s = globalThis || void 0 || self;
  Object.defineProperty(e, "Buffer", { enumerable: !0, get: () => t.Buffer }), Object.defineProperty(e, "process", { enumerable: !0, get: () => i.default }), e.global = s;
})(Me);
var yg = {};
yg.stringify = function e(t) {
  if (typeof t > "u")
    return t;
  if (t && Me.Buffer.isBuffer(t))
    return JSON.stringify(":base64:" + t.toString("base64"));
  if (t && t.toJSON && (t = t.toJSON()), t && typeof t == "object") {
    var r = "", n = Array.isArray(t);
    r = n ? "[" : "{";
    var i = !0;
    for (var s in t) {
      var a = typeof t[s] == "function" || !n && typeof t[s] > "u";
      Object.hasOwnProperty.call(t, s) && !a && (i || (r += ","), i = !1, n ? t[s] == null ? r += "null" : r += e(t[s]) : t[s] !== void 0 && (r += e(s) + ":" + e(t[s])));
    }
    return r += n ? "]" : "}", r;
  } else
    return typeof t == "string" ? JSON.stringify(/^:/.test(t) ? ":" + t : t) : typeof t > "u" ? "null" : JSON.stringify(t);
};
yg.parse = function(e) {
  return JSON.parse(e, function(t, r) {
    return typeof r == "string" ? /^:base64:/.test(r) ? Me.Buffer.from(r.substring(8), "base64") : /^:/.test(r) ? r.substring(1) : r : r;
  });
};
const vM = hg, g1 = yg, bM = (e) => {
  const t = {
    redis: "@keyv/redis",
    rediss: "@keyv/redis",
    mongodb: "@keyv/mongo",
    mongo: "@keyv/mongo",
    sqlite: "@keyv/sqlite",
    postgresql: "@keyv/postgres",
    postgres: "@keyv/postgres",
    mysql: "@keyv/mysql",
    etcd: "@keyv/etcd",
    offline: "@keyv/offline",
    tiered: "@keyv/tiered"
  };
  if (e.adapter || e.uri) {
    const r = e.adapter || /^[^:+]*/.exec(e.uri)[0];
    return new (yE(t[r]))(e);
  }
  return /* @__PURE__ */ new Map();
}, v1 = [
  "sqlite",
  "postgres",
  "mysql",
  "mongo",
  "redis",
  "tiered"
];
class _M extends vM {
  constructor(t, { emitErrors: r = !0, ...n } = {}) {
    if (super(), this.opts = {
      namespace: "keyv",
      serialize: g1.stringify,
      deserialize: g1.parse,
      ...typeof t == "string" ? { uri: t } : t,
      ...n
    }, !this.opts.store) {
      const s = { ...this.opts };
      this.opts.store = bM(s);
    }
    if (this.opts.compression) {
      const s = this.opts.compression;
      this.opts.serialize = s.serialize.bind(s), this.opts.deserialize = s.deserialize.bind(s);
    }
    typeof this.opts.store.on == "function" && r && this.opts.store.on("error", (s) => this.emit("error", s)), this.opts.store.namespace = this.opts.namespace;
    const i = (s) => async function* () {
      for await (const [a, u] of typeof s == "function" ? s(this.opts.store.namespace) : s) {
        const c = await this.opts.deserialize(u);
        if (!(this.opts.store.namespace && !a.includes(this.opts.store.namespace))) {
          if (typeof c.expires == "number" && Date.now() > c.expires) {
            this.delete(a);
            continue;
          }
          yield [this._getKeyUnprefix(a), c.value];
        }
      }
    };
    typeof this.opts.store[Symbol.iterator] == "function" && this.opts.store instanceof Map ? this.iterator = i(this.opts.store) : typeof this.opts.store.iterator == "function" && this.opts.store.opts && this._checkIterableAdaptar() && (this.iterator = i(this.opts.store.iterator.bind(this.opts.store)));
  }
  _checkIterableAdaptar() {
    return v1.includes(this.opts.store.opts.dialect) || v1.findIndex((t) => this.opts.store.opts.url.includes(t)) >= 0;
  }
  _getKeyPrefix(t) {
    return `${this.opts.namespace}:${t}`;
  }
  _getKeyPrefixArray(t) {
    return t.map((r) => `${this.opts.namespace}:${r}`);
  }
  _getKeyUnprefix(t) {
    return t.split(":").splice(1).join(":");
  }
  get(t, r) {
    const { store: n } = this.opts, i = Array.isArray(t), s = i ? this._getKeyPrefixArray(t) : this._getKeyPrefix(t);
    if (i && n.getMany === void 0) {
      const a = [];
      for (const u of s)
        a.push(
          Promise.resolve().then(() => n.get(u)).then((c) => typeof c == "string" ? this.opts.deserialize(c) : this.opts.compression ? this.opts.deserialize(c) : c).then((c) => {
            if (c != null)
              return typeof c.expires == "number" && Date.now() > c.expires ? this.delete(u).then(() => {
              }) : r && r.raw ? c : c.value;
          })
        );
      return Promise.allSettled(a).then((u) => {
        const c = [];
        for (const l of u)
          c.push(l.value);
        return c;
      });
    }
    return Promise.resolve().then(() => i ? n.getMany(s) : n.get(s)).then((a) => typeof a == "string" ? this.opts.deserialize(a) : this.opts.compression ? this.opts.deserialize(a) : a).then((a) => {
      if (a != null) {
        if (i) {
          const u = [];
          for (let c of a) {
            if (typeof c == "string" && (c = this.opts.deserialize(c)), c == null) {
              u.push(void 0);
              continue;
            }
            typeof c.expires == "number" && Date.now() > c.expires ? (this.delete(t).then(() => {
            }), u.push(void 0)) : u.push(r && r.raw ? c : c.value);
          }
          return u;
        }
        return typeof a.expires == "number" && Date.now() > a.expires ? this.delete(t).then(() => {
        }) : r && r.raw ? a : a.value;
      }
    });
  }
  set(t, r, n) {
    const i = this._getKeyPrefix(t);
    typeof n > "u" && (n = this.opts.ttl), n === 0 && (n = void 0);
    const { store: s } = this.opts;
    return Promise.resolve().then(() => {
      const a = typeof n == "number" ? Date.now() + n : null;
      return typeof r == "symbol" && this.emit("error", "symbol cannot be serialized"), r = { value: r, expires: a }, this.opts.serialize(r);
    }).then((a) => s.set(i, a, n)).then(() => !0);
  }
  delete(t) {
    const { store: r } = this.opts;
    if (Array.isArray(t)) {
      const i = this._getKeyPrefixArray(t);
      if (r.deleteMany === void 0) {
        const s = [];
        for (const a of i)
          s.push(r.delete(a));
        return Promise.allSettled(s).then((a) => a.every((u) => u.value === !0));
      }
      return Promise.resolve().then(() => r.deleteMany(i));
    }
    const n = this._getKeyPrefix(t);
    return Promise.resolve().then(() => r.delete(n));
  }
  clear() {
    const { store: t } = this.opts;
    return Promise.resolve().then(() => t.clear());
  }
  has(t) {
    const r = this._getKeyPrefix(t), { store: n } = this.opts;
    return Promise.resolve().then(async () => typeof n.has == "function" ? n.has(r) : await n.get(r) !== void 0);
  }
  disconnect() {
    const { store: t } = this.opts;
    if (typeof t.disconnect == "function")
      return t.disconnect();
  }
}
var wM = _M;
const Lf = /* @__PURE__ */ ea(wM);
let qf = (e = 21) => crypto.getRandomValues(new Uint8Array(e)).reduce((t, r) => (r &= 63, r < 36 ? t += r.toString(36) : r < 62 ? t += (r - 26).toString(36).toUpperCase() : r > 62 ? t += "-" : t += "_", t), "");
var RE = {}, Xs = {}, gg = {};
Object.defineProperty(gg, "__esModule", { value: !0 });
const b1 = (e) => {
  if (typeof e == "object" && e !== null) {
    if (typeof Object.getPrototypeOf == "function") {
      const t = Object.getPrototypeOf(e);
      return t === Object.prototype || t === null;
    }
    return Object.prototype.toString.call(e) === "[object Object]";
  }
  return !1;
}, Jn = (...e) => e.reduce((t, r) => {
  if (Array.isArray(r))
    throw new TypeError("Arguments provided to ts-deepmerge must be objects, not arrays.");
  return Object.keys(r).forEach((n) => {
    ["__proto__", "constructor", "prototype"].includes(n) || (Array.isArray(t[n]) && Array.isArray(r[n]) ? t[n] = Jn.options.mergeArrays ? Jn.options.uniqueArrayItems ? Array.from(new Set(t[n].concat(r[n]))) : [...t[n], ...r[n]] : r[n] : b1(t[n]) && b1(r[n]) ? t[n] = Jn(t[n], r[n]) : t[n] = r[n] === void 0 ? Jn.options.allowUndefinedOverrides ? r[n] : t[n] : r[n]);
  }), t;
}, {}), cy = {
  allowUndefinedOverrides: !0,
  mergeArrays: !0,
  uniqueArrayItems: !0
};
Jn.options = cy;
Jn.withOptions = (e, ...t) => {
  Jn.options = Object.assign(Object.assign({}, cy), e);
  const r = Jn(...t);
  return Jn.options = cy, r;
};
gg.default = Jn;
var TE = {}, ly = {}, Qn = {}, Ff = {}, Gu = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.getParsedType = e.ZodParsedType = e.objectUtil = e.util = void 0;
  var t;
  (function(n) {
    n.assertEqual = (u) => u;
    function i(u) {
    }
    n.assertIs = i;
    function s(u) {
      throw new Error();
    }
    n.assertNever = s, n.arrayToEnum = (u) => {
      const c = {};
      for (const l of u)
        c[l] = l;
      return c;
    }, n.getValidEnumValues = (u) => {
      const c = n.objectKeys(u).filter((d) => typeof u[u[d]] != "number"), l = {};
      for (const d of c)
        l[d] = u[d];
      return n.objectValues(l);
    }, n.objectValues = (u) => n.objectKeys(u).map(function(c) {
      return u[c];
    }), n.objectKeys = typeof Object.keys == "function" ? (u) => Object.keys(u) : (u) => {
      const c = [];
      for (const l in u)
        Object.prototype.hasOwnProperty.call(u, l) && c.push(l);
      return c;
    }, n.find = (u, c) => {
      for (const l of u)
        if (c(l))
          return l;
    }, n.isInteger = typeof Number.isInteger == "function" ? (u) => Number.isInteger(u) : (u) => typeof u == "number" && isFinite(u) && Math.floor(u) === u;
    function a(u, c = " | ") {
      return u.map((l) => typeof l == "string" ? `'${l}'` : l).join(c);
    }
    n.joinValues = a, n.jsonStringifyReplacer = (u, c) => typeof c == "bigint" ? c.toString() : c;
  })(t = e.util || (e.util = {})), function(n) {
    n.mergeShapes = (i, s) => ({
      ...i,
      ...s
    });
  }(e.objectUtil || (e.objectUtil = {})), e.ZodParsedType = t.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set"
  ]);
  const r = (n) => {
    switch (typeof n) {
      case "undefined":
        return e.ZodParsedType.undefined;
      case "string":
        return e.ZodParsedType.string;
      case "number":
        return isNaN(n) ? e.ZodParsedType.nan : e.ZodParsedType.number;
      case "boolean":
        return e.ZodParsedType.boolean;
      case "function":
        return e.ZodParsedType.function;
      case "bigint":
        return e.ZodParsedType.bigint;
      case "symbol":
        return e.ZodParsedType.symbol;
      case "object":
        return Array.isArray(n) ? e.ZodParsedType.array : n === null ? e.ZodParsedType.null : n.then && typeof n.then == "function" && n.catch && typeof n.catch == "function" ? e.ZodParsedType.promise : typeof Map < "u" && n instanceof Map ? e.ZodParsedType.map : typeof Set < "u" && n instanceof Set ? e.ZodParsedType.set : typeof Date < "u" && n instanceof Date ? e.ZodParsedType.date : e.ZodParsedType.object;
      default:
        return e.ZodParsedType.unknown;
    }
  };
  e.getParsedType = r;
})(Gu);
var ei = {};
Object.defineProperty(ei, "__esModule", { value: !0 });
ei.ZodError = ei.quotelessJson = ei.ZodIssueCode = void 0;
const IE = Gu;
ei.ZodIssueCode = IE.util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
const $M = (e) => JSON.stringify(e, null, 2).replace(/"([^"]+)":/g, "$1:");
ei.quotelessJson = $M;
class fy extends Error {
  constructor(t) {
    super(), this.issues = [], this.addIssue = (n) => {
      this.issues = [...this.issues, n];
    }, this.addIssues = (n = []) => {
      this.issues = [...this.issues, ...n];
    };
    const r = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, r) : this.__proto__ = r, this.name = "ZodError", this.issues = t;
  }
  get errors() {
    return this.issues;
  }
  format(t) {
    const r = t || function(s) {
      return s.message;
    }, n = { _errors: [] }, i = (s) => {
      for (const a of s.issues)
        if (a.code === "invalid_union")
          a.unionErrors.map(i);
        else if (a.code === "invalid_return_type")
          i(a.returnTypeError);
        else if (a.code === "invalid_arguments")
          i(a.argumentsError);
        else if (a.path.length === 0)
          n._errors.push(r(a));
        else {
          let u = n, c = 0;
          for (; c < a.path.length; ) {
            const l = a.path[c];
            c === a.path.length - 1 ? (u[l] = u[l] || { _errors: [] }, u[l]._errors.push(r(a))) : u[l] = u[l] || { _errors: [] }, u = u[l], c++;
          }
        }
    };
    return i(this), n;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, IE.util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(t = (r) => r.message) {
    const r = {}, n = [];
    for (const i of this.issues)
      i.path.length > 0 ? (r[i.path[0]] = r[i.path[0]] || [], r[i.path[0]].push(t(i))) : n.push(t(i));
    return { formErrors: n, fieldErrors: r };
  }
  get formErrors() {
    return this.flatten();
  }
}
ei.ZodError = fy;
fy.create = (e) => new fy(e);
Object.defineProperty(Ff, "__esModule", { value: !0 });
const ks = Gu, Er = ei, EM = (e, t) => {
  let r;
  switch (e.code) {
    case Er.ZodIssueCode.invalid_type:
      e.received === ks.ZodParsedType.undefined ? r = "Required" : r = `Expected ${e.expected}, received ${e.received}`;
      break;
    case Er.ZodIssueCode.invalid_literal:
      r = `Invalid literal value, expected ${JSON.stringify(e.expected, ks.util.jsonStringifyReplacer)}`;
      break;
    case Er.ZodIssueCode.unrecognized_keys:
      r = `Unrecognized key(s) in object: ${ks.util.joinValues(e.keys, ", ")}`;
      break;
    case Er.ZodIssueCode.invalid_union:
      r = "Invalid input";
      break;
    case Er.ZodIssueCode.invalid_union_discriminator:
      r = `Invalid discriminator value. Expected ${ks.util.joinValues(e.options)}`;
      break;
    case Er.ZodIssueCode.invalid_enum_value:
      r = `Invalid enum value. Expected ${ks.util.joinValues(e.options)}, received '${e.received}'`;
      break;
    case Er.ZodIssueCode.invalid_arguments:
      r = "Invalid function arguments";
      break;
    case Er.ZodIssueCode.invalid_return_type:
      r = "Invalid function return type";
      break;
    case Er.ZodIssueCode.invalid_date:
      r = "Invalid date";
      break;
    case Er.ZodIssueCode.invalid_string:
      typeof e.validation == "object" ? "includes" in e.validation ? (r = `Invalid input: must include "${e.validation.includes}"`, typeof e.validation.position == "number" && (r = `${r} at one or more positions greater than or equal to ${e.validation.position}`)) : "startsWith" in e.validation ? r = `Invalid input: must start with "${e.validation.startsWith}"` : "endsWith" in e.validation ? r = `Invalid input: must end with "${e.validation.endsWith}"` : ks.util.assertNever(e.validation) : e.validation !== "regex" ? r = `Invalid ${e.validation}` : r = "Invalid";
      break;
    case Er.ZodIssueCode.too_small:
      e.type === "array" ? r = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "more than"} ${e.minimum} element(s)` : e.type === "string" ? r = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "over"} ${e.minimum} character(s)` : e.type === "number" ? r = `Number must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${e.minimum}` : e.type === "date" ? r = `Date must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(e.minimum))}` : r = "Invalid input";
      break;
    case Er.ZodIssueCode.too_big:
      e.type === "array" ? r = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "less than"} ${e.maximum} element(s)` : e.type === "string" ? r = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "under"} ${e.maximum} character(s)` : e.type === "number" ? r = `Number must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "bigint" ? r = `BigInt must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "date" ? r = `Date must be ${e.exact ? "exactly" : e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(e.maximum))}` : r = "Invalid input";
      break;
    case Er.ZodIssueCode.custom:
      r = "Invalid input";
      break;
    case Er.ZodIssueCode.invalid_intersection_types:
      r = "Intersection results could not be merged";
      break;
    case Er.ZodIssueCode.not_multiple_of:
      r = `Number must be a multiple of ${e.multipleOf}`;
      break;
    case Er.ZodIssueCode.not_finite:
      r = "Number must be finite";
      break;
    default:
      r = t.defaultError, ks.util.assertNever(e);
  }
  return { message: r };
};
Ff.default = EM;
var xM = rt && rt.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Qn, "__esModule", { value: !0 });
Qn.getErrorMap = Qn.setErrorMap = Qn.defaultErrorMap = void 0;
const jE = xM(Ff);
Qn.defaultErrorMap = jE.default;
let kE = jE.default;
function OM(e) {
  kE = e;
}
Qn.setErrorMap = OM;
function PM() {
  return kE;
}
Qn.getErrorMap = PM;
var vg = {};
(function(e) {
  var t = rt && rt.__importDefault || function(v) {
    return v && v.__esModule ? v : { default: v };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.isAsync = e.isValid = e.isDirty = e.isAborted = e.OK = e.DIRTY = e.INVALID = e.ParseStatus = e.addIssueToContext = e.EMPTY_PATH = e.makeIssue = void 0;
  const r = Qn, n = t(Ff), i = (v) => {
    const { data: y, path: g, errorMaps: _, issueData: m } = v, w = [...g, ...m.path || []], $ = {
      ...m,
      path: w
    };
    let E = "";
    const A = _.filter((R) => !!R).slice().reverse();
    for (const R of A)
      E = R($, { data: y, defaultError: E }).message;
    return {
      ...m,
      path: w,
      message: m.message || E
    };
  };
  e.makeIssue = i, e.EMPTY_PATH = [];
  function s(v, y) {
    const g = (0, e.makeIssue)({
      issueData: y,
      data: v.data,
      path: v.path,
      errorMaps: [
        v.common.contextualErrorMap,
        v.schemaErrorMap,
        (0, r.getErrorMap)(),
        n.default
      ].filter((_) => !!_)
    });
    v.common.issues.push(g);
  }
  e.addIssueToContext = s;
  class a {
    constructor() {
      this.value = "valid";
    }
    dirty() {
      this.value === "valid" && (this.value = "dirty");
    }
    abort() {
      this.value !== "aborted" && (this.value = "aborted");
    }
    static mergeArray(y, g) {
      const _ = [];
      for (const m of g) {
        if (m.status === "aborted")
          return e.INVALID;
        m.status === "dirty" && y.dirty(), _.push(m.value);
      }
      return { status: y.value, value: _ };
    }
    static async mergeObjectAsync(y, g) {
      const _ = [];
      for (const m of g)
        _.push({
          key: await m.key,
          value: await m.value
        });
      return a.mergeObjectSync(y, _);
    }
    static mergeObjectSync(y, g) {
      const _ = {};
      for (const m of g) {
        const { key: w, value: $ } = m;
        if (w.status === "aborted" || $.status === "aborted")
          return e.INVALID;
        w.status === "dirty" && y.dirty(), $.status === "dirty" && y.dirty(), w.value !== "__proto__" && (typeof $.value < "u" || m.alwaysSet) && (_[w.value] = $.value);
      }
      return { status: y.value, value: _ };
    }
  }
  e.ParseStatus = a, e.INVALID = Object.freeze({
    status: "aborted"
  });
  const u = (v) => ({ status: "dirty", value: v });
  e.DIRTY = u;
  const c = (v) => ({ status: "valid", value: v });
  e.OK = c;
  const l = (v) => v.status === "aborted";
  e.isAborted = l;
  const d = (v) => v.status === "dirty";
  e.isDirty = d;
  const p = (v) => v.status === "valid";
  e.isValid = p;
  const h = (v) => typeof Promise < "u" && v instanceof Promise;
  e.isAsync = h;
})(vg);
var ME = {};
Object.defineProperty(ME, "__esModule", { value: !0 });
var NE = {}, DE = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.errorUtil = void 0, function(t) {
    t.errToObj = (r) => typeof r == "string" ? { message: r } : r || {}, t.toString = (r) => typeof r == "string" ? r : r == null ? void 0 : r.message;
  }(e.errorUtil || (e.errorUtil = {}));
})(DE);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.date = e.boolean = e.bigint = e.array = e.any = e.coerce = e.ZodFirstPartyTypeKind = e.late = e.ZodSchema = e.Schema = e.custom = e.ZodReadonly = e.ZodPipeline = e.ZodBranded = e.BRAND = e.ZodNaN = e.ZodCatch = e.ZodDefault = e.ZodNullable = e.ZodOptional = e.ZodTransformer = e.ZodEffects = e.ZodPromise = e.ZodNativeEnum = e.ZodEnum = e.ZodLiteral = e.ZodLazy = e.ZodFunction = e.ZodSet = e.ZodMap = e.ZodRecord = e.ZodTuple = e.ZodIntersection = e.ZodDiscriminatedUnion = e.ZodUnion = e.ZodObject = e.ZodArray = e.ZodVoid = e.ZodNever = e.ZodUnknown = e.ZodAny = e.ZodNull = e.ZodUndefined = e.ZodSymbol = e.ZodDate = e.ZodBoolean = e.ZodBigInt = e.ZodNumber = e.ZodString = e.ZodType = void 0, e.NEVER = e.void = e.unknown = e.union = e.undefined = e.tuple = e.transformer = e.symbol = e.string = e.strictObject = e.set = e.record = e.promise = e.preprocess = e.pipeline = e.ostring = e.optional = e.onumber = e.oboolean = e.object = e.number = e.nullable = e.null = e.never = e.nativeEnum = e.nan = e.map = e.literal = e.lazy = e.intersection = e.instanceof = e.function = e.enum = e.effect = e.discriminatedUnion = void 0;
  const t = Qn, r = DE, n = vg, i = Gu, s = ei;
  class a {
    constructor(O, j, W, ne) {
      this._cachedPath = [], this.parent = O, this.data = j, this._path = W, this._key = ne;
    }
    get path() {
      return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
    }
  }
  const u = (Q, O) => {
    if ((0, n.isValid)(O))
      return { success: !0, data: O.value };
    if (!Q.common.issues.length)
      throw new Error("Validation failed but no issues detected.");
    return {
      success: !1,
      get error() {
        if (this._error)
          return this._error;
        const j = new s.ZodError(Q.common.issues);
        return this._error = j, this._error;
      }
    };
  };
  function c(Q) {
    if (!Q)
      return {};
    const { errorMap: O, invalid_type_error: j, required_error: W, description: ne } = Q;
    if (O && (j || W))
      throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    return O ? { errorMap: O, description: ne } : { errorMap: (Ie, Se) => Ie.code !== "invalid_type" ? { message: Se.defaultError } : typeof Se.data > "u" ? { message: W ?? Se.defaultError } : { message: j ?? Se.defaultError }, description: ne };
  }
  class l {
    constructor(O) {
      this.spa = this.safeParseAsync, this._def = O, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
    }
    get description() {
      return this._def.description;
    }
    _getType(O) {
      return (0, i.getParsedType)(O.data);
    }
    _getOrReturnCtx(O, j) {
      return j || {
        common: O.parent.common,
        data: O.data,
        parsedType: (0, i.getParsedType)(O.data),
        schemaErrorMap: this._def.errorMap,
        path: O.path,
        parent: O.parent
      };
    }
    _processInputParams(O) {
      return {
        status: new n.ParseStatus(),
        ctx: {
          common: O.parent.common,
          data: O.data,
          parsedType: (0, i.getParsedType)(O.data),
          schemaErrorMap: this._def.errorMap,
          path: O.path,
          parent: O.parent
        }
      };
    }
    _parseSync(O) {
      const j = this._parse(O);
      if ((0, n.isAsync)(j))
        throw new Error("Synchronous parse encountered promise.");
      return j;
    }
    _parseAsync(O) {
      const j = this._parse(O);
      return Promise.resolve(j);
    }
    parse(O, j) {
      const W = this.safeParse(O, j);
      if (W.success)
        return W.data;
      throw W.error;
    }
    safeParse(O, j) {
      var W;
      const ne = {
        common: {
          issues: [],
          async: (W = j == null ? void 0 : j.async) !== null && W !== void 0 ? W : !1,
          contextualErrorMap: j == null ? void 0 : j.errorMap
        },
        path: (j == null ? void 0 : j.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: O,
        parsedType: (0, i.getParsedType)(O)
      }, te = this._parseSync({ data: O, path: ne.path, parent: ne });
      return u(ne, te);
    }
    async parseAsync(O, j) {
      const W = await this.safeParseAsync(O, j);
      if (W.success)
        return W.data;
      throw W.error;
    }
    async safeParseAsync(O, j) {
      const W = {
        common: {
          issues: [],
          contextualErrorMap: j == null ? void 0 : j.errorMap,
          async: !0
        },
        path: (j == null ? void 0 : j.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: O,
        parsedType: (0, i.getParsedType)(O)
      }, ne = this._parse({ data: O, path: W.path, parent: W }), te = await ((0, n.isAsync)(ne) ? ne : Promise.resolve(ne));
      return u(W, te);
    }
    refine(O, j) {
      const W = (ne) => typeof j == "string" || typeof j > "u" ? { message: j } : typeof j == "function" ? j(ne) : j;
      return this._refinement((ne, te) => {
        const Ie = O(ne), Se = () => te.addIssue({
          code: s.ZodIssueCode.custom,
          ...W(ne)
        });
        return typeof Promise < "u" && Ie instanceof Promise ? Ie.then((Ke) => Ke ? !0 : (Se(), !1)) : Ie ? !0 : (Se(), !1);
      });
    }
    refinement(O, j) {
      return this._refinement((W, ne) => O(W) ? !0 : (ne.addIssue(typeof j == "function" ? j(W, ne) : j), !1));
    }
    _refinement(O) {
      return new Fe({
        schema: this,
        typeName: qe.ZodEffects,
        effect: { type: "refinement", refinement: O }
      });
    }
    superRefine(O) {
      return this._refinement(O);
    }
    optional() {
      return Ge.create(this, this._def);
    }
    nullable() {
      return jt.create(this, this._def);
    }
    nullish() {
      return this.nullable().optional();
    }
    array() {
      return $e.create(this, this._def);
    }
    promise() {
      return He.create(this, this._def);
    }
    or(O) {
      return ie.create([this, O], this._def);
    }
    and(O) {
      return C.create(this, O, this._def);
    }
    transform(O) {
      return new Fe({
        ...c(this._def),
        schema: this,
        typeName: qe.ZodEffects,
        effect: { type: "transform", transform: O }
      });
    }
    default(O) {
      const j = typeof O == "function" ? O : () => O;
      return new Ee({
        ...c(this._def),
        innerType: this,
        defaultValue: j,
        typeName: qe.ZodDefault
      });
    }
    brand() {
      return new Ne({
        typeName: qe.ZodBranded,
        type: this,
        ...c(this._def)
      });
    }
    catch(O) {
      const j = typeof O == "function" ? O : () => O;
      return new Mt({
        ...c(this._def),
        innerType: this,
        catchValue: j,
        typeName: qe.ZodCatch
      });
    }
    describe(O) {
      const j = this.constructor;
      return new j({
        ...this._def,
        description: O
      });
    }
    pipe(O) {
      return Le.create(this, O);
    }
    readonly() {
      return at.create(this);
    }
    isOptional() {
      return this.safeParse(void 0).success;
    }
    isNullable() {
      return this.safeParse(null).success;
    }
  }
  e.ZodType = l, e.Schema = l, e.ZodSchema = l;
  const d = /^c[^\s-]{8,}$/i, p = /^[a-z][a-z0-9]*$/, h = /[0-9A-HJKMNP-TV-Z]{26}/, v = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, y = /^([A-Z0-9_+-]+\.?)*[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, g = /^(\p{Extended_Pictographic}|\p{Emoji_Component})+$/u, _ = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/, m = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/, w = (Q) => Q.precision ? Q.offset ? new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${Q.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`) : new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${Q.precision}}Z$`) : Q.precision === 0 ? Q.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$") : Q.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");
  function $(Q, O) {
    return !!((O === "v4" || !O) && _.test(Q) || (O === "v6" || !O) && m.test(Q));
  }
  class E extends l {
    constructor() {
      super(...arguments), this._regex = (O, j, W) => this.refinement((ne) => O.test(ne), {
        validation: j,
        code: s.ZodIssueCode.invalid_string,
        ...r.errorUtil.errToObj(W)
      }), this.nonempty = (O) => this.min(1, r.errorUtil.errToObj(O)), this.trim = () => new E({
        ...this._def,
        checks: [...this._def.checks, { kind: "trim" }]
      }), this.toLowerCase = () => new E({
        ...this._def,
        checks: [...this._def.checks, { kind: "toLowerCase" }]
      }), this.toUpperCase = () => new E({
        ...this._def,
        checks: [...this._def.checks, { kind: "toUpperCase" }]
      });
    }
    _parse(O) {
      if (this._def.coerce && (O.data = String(O.data)), this._getType(O) !== i.ZodParsedType.string) {
        const te = this._getOrReturnCtx(O);
        return (0, n.addIssueToContext)(te, {
          code: s.ZodIssueCode.invalid_type,
          expected: i.ZodParsedType.string,
          received: te.parsedType
        }), n.INVALID;
      }
      const W = new n.ParseStatus();
      let ne;
      for (const te of this._def.checks)
        if (te.kind === "min")
          O.data.length < te.value && (ne = this._getOrReturnCtx(O, ne), (0, n.addIssueToContext)(ne, {
            code: s.ZodIssueCode.too_small,
            minimum: te.value,
            type: "string",
            inclusive: !0,
            exact: !1,
            message: te.message
          }), W.dirty());
        else if (te.kind === "max")
          O.data.length > te.value && (ne = this._getOrReturnCtx(O, ne), (0, n.addIssueToContext)(ne, {
            code: s.ZodIssueCode.too_big,
            maximum: te.value,
            type: "string",
            inclusive: !0,
            exact: !1,
            message: te.message
          }), W.dirty());
        else if (te.kind === "length") {
          const Ie = O.data.length > te.value, Se = O.data.length < te.value;
          (Ie || Se) && (ne = this._getOrReturnCtx(O, ne), Ie ? (0, n.addIssueToContext)(ne, {
            code: s.ZodIssueCode.too_big,
            maximum: te.value,
            type: "string",
            inclusive: !0,
            exact: !0,
            message: te.message
          }) : Se && (0, n.addIssueToContext)(ne, {
            code: s.ZodIssueCode.too_small,
            minimum: te.value,
            type: "string",
            inclusive: !0,
            exact: !0,
            message: te.message
          }), W.dirty());
        } else if (te.kind === "email")
          y.test(O.data) || (ne = this._getOrReturnCtx(O, ne), (0, n.addIssueToContext)(ne, {
            validation: "email",
            code: s.ZodIssueCode.invalid_string,
            message: te.message
          }), W.dirty());
        else if (te.kind === "emoji")
          g.test(O.data) || (ne = this._getOrReturnCtx(O, ne), (0, n.addIssueToContext)(ne, {
            validation: "emoji",
            code: s.ZodIssueCode.invalid_string,
            message: te.message
          }), W.dirty());
        else if (te.kind === "uuid")
          v.test(O.data) || (ne = this._getOrReturnCtx(O, ne), (0, n.addIssueToContext)(ne, {
            validation: "uuid",
            code: s.ZodIssueCode.invalid_string,
            message: te.message
          }), W.dirty());
        else if (te.kind === "cuid")
          d.test(O.data) || (ne = this._getOrReturnCtx(O, ne), (0, n.addIssueToContext)(ne, {
            validation: "cuid",
            code: s.ZodIssueCode.invalid_string,
            message: te.message
          }), W.dirty());
        else if (te.kind === "cuid2")
          p.test(O.data) || (ne = this._getOrReturnCtx(O, ne), (0, n.addIssueToContext)(ne, {
            validation: "cuid2",
            code: s.ZodIssueCode.invalid_string,
            message: te.message
          }), W.dirty());
        else if (te.kind === "ulid")
          h.test(O.data) || (ne = this._getOrReturnCtx(O, ne), (0, n.addIssueToContext)(ne, {
            validation: "ulid",
            code: s.ZodIssueCode.invalid_string,
            message: te.message
          }), W.dirty());
        else if (te.kind === "url")
          try {
            new URL(O.data);
          } catch {
            ne = this._getOrReturnCtx(O, ne), (0, n.addIssueToContext)(ne, {
              validation: "url",
              code: s.ZodIssueCode.invalid_string,
              message: te.message
            }), W.dirty();
          }
        else
          te.kind === "regex" ? (te.regex.lastIndex = 0, te.regex.test(O.data) || (ne = this._getOrReturnCtx(O, ne), (0, n.addIssueToContext)(ne, {
            validation: "regex",
            code: s.ZodIssueCode.invalid_string,
            message: te.message
          }), W.dirty())) : te.kind === "trim" ? O.data = O.data.trim() : te.kind === "includes" ? O.data.includes(te.value, te.position) || (ne = this._getOrReturnCtx(O, ne), (0, n.addIssueToContext)(ne, {
            code: s.ZodIssueCode.invalid_string,
            validation: { includes: te.value, position: te.position },
            message: te.message
          }), W.dirty()) : te.kind === "toLowerCase" ? O.data = O.data.toLowerCase() : te.kind === "toUpperCase" ? O.data = O.data.toUpperCase() : te.kind === "startsWith" ? O.data.startsWith(te.value) || (ne = this._getOrReturnCtx(O, ne), (0, n.addIssueToContext)(ne, {
            code: s.ZodIssueCode.invalid_string,
            validation: { startsWith: te.value },
            message: te.message
          }), W.dirty()) : te.kind === "endsWith" ? O.data.endsWith(te.value) || (ne = this._getOrReturnCtx(O, ne), (0, n.addIssueToContext)(ne, {
            code: s.ZodIssueCode.invalid_string,
            validation: { endsWith: te.value },
            message: te.message
          }), W.dirty()) : te.kind === "datetime" ? w(te).test(O.data) || (ne = this._getOrReturnCtx(O, ne), (0, n.addIssueToContext)(ne, {
            code: s.ZodIssueCode.invalid_string,
            validation: "datetime",
            message: te.message
          }), W.dirty()) : te.kind === "ip" ? $(O.data, te.version) || (ne = this._getOrReturnCtx(O, ne), (0, n.addIssueToContext)(ne, {
            validation: "ip",
            code: s.ZodIssueCode.invalid_string,
            message: te.message
          }), W.dirty()) : i.util.assertNever(te);
      return { status: W.value, value: O.data };
    }
    _addCheck(O) {
      return new E({
        ...this._def,
        checks: [...this._def.checks, O]
      });
    }
    email(O) {
      return this._addCheck({ kind: "email", ...r.errorUtil.errToObj(O) });
    }
    url(O) {
      return this._addCheck({ kind: "url", ...r.errorUtil.errToObj(O) });
    }
    emoji(O) {
      return this._addCheck({ kind: "emoji", ...r.errorUtil.errToObj(O) });
    }
    uuid(O) {
      return this._addCheck({ kind: "uuid", ...r.errorUtil.errToObj(O) });
    }
    cuid(O) {
      return this._addCheck({ kind: "cuid", ...r.errorUtil.errToObj(O) });
    }
    cuid2(O) {
      return this._addCheck({ kind: "cuid2", ...r.errorUtil.errToObj(O) });
    }
    ulid(O) {
      return this._addCheck({ kind: "ulid", ...r.errorUtil.errToObj(O) });
    }
    ip(O) {
      return this._addCheck({ kind: "ip", ...r.errorUtil.errToObj(O) });
    }
    datetime(O) {
      var j;
      return typeof O == "string" ? this._addCheck({
        kind: "datetime",
        precision: null,
        offset: !1,
        message: O
      }) : this._addCheck({
        kind: "datetime",
        precision: typeof (O == null ? void 0 : O.precision) > "u" ? null : O == null ? void 0 : O.precision,
        offset: (j = O == null ? void 0 : O.offset) !== null && j !== void 0 ? j : !1,
        ...r.errorUtil.errToObj(O == null ? void 0 : O.message)
      });
    }
    regex(O, j) {
      return this._addCheck({
        kind: "regex",
        regex: O,
        ...r.errorUtil.errToObj(j)
      });
    }
    includes(O, j) {
      return this._addCheck({
        kind: "includes",
        value: O,
        position: j == null ? void 0 : j.position,
        ...r.errorUtil.errToObj(j == null ? void 0 : j.message)
      });
    }
    startsWith(O, j) {
      return this._addCheck({
        kind: "startsWith",
        value: O,
        ...r.errorUtil.errToObj(j)
      });
    }
    endsWith(O, j) {
      return this._addCheck({
        kind: "endsWith",
        value: O,
        ...r.errorUtil.errToObj(j)
      });
    }
    min(O, j) {
      return this._addCheck({
        kind: "min",
        value: O,
        ...r.errorUtil.errToObj(j)
      });
    }
    max(O, j) {
      return this._addCheck({
        kind: "max",
        value: O,
        ...r.errorUtil.errToObj(j)
      });
    }
    length(O, j) {
      return this._addCheck({
        kind: "length",
        value: O,
        ...r.errorUtil.errToObj(j)
      });
    }
    get isDatetime() {
      return !!this._def.checks.find((O) => O.kind === "datetime");
    }
    get isEmail() {
      return !!this._def.checks.find((O) => O.kind === "email");
    }
    get isURL() {
      return !!this._def.checks.find((O) => O.kind === "url");
    }
    get isEmoji() {
      return !!this._def.checks.find((O) => O.kind === "emoji");
    }
    get isUUID() {
      return !!this._def.checks.find((O) => O.kind === "uuid");
    }
    get isCUID() {
      return !!this._def.checks.find((O) => O.kind === "cuid");
    }
    get isCUID2() {
      return !!this._def.checks.find((O) => O.kind === "cuid2");
    }
    get isULID() {
      return !!this._def.checks.find((O) => O.kind === "ulid");
    }
    get isIP() {
      return !!this._def.checks.find((O) => O.kind === "ip");
    }
    get minLength() {
      let O = null;
      for (const j of this._def.checks)
        j.kind === "min" && (O === null || j.value > O) && (O = j.value);
      return O;
    }
    get maxLength() {
      let O = null;
      for (const j of this._def.checks)
        j.kind === "max" && (O === null || j.value < O) && (O = j.value);
      return O;
    }
  }
  e.ZodString = E, E.create = (Q) => {
    var O;
    return new E({
      checks: [],
      typeName: qe.ZodString,
      coerce: (O = Q == null ? void 0 : Q.coerce) !== null && O !== void 0 ? O : !1,
      ...c(Q)
    });
  };
  function A(Q, O) {
    const j = (Q.toString().split(".")[1] || "").length, W = (O.toString().split(".")[1] || "").length, ne = j > W ? j : W, te = parseInt(Q.toFixed(ne).replace(".", "")), Ie = parseInt(O.toFixed(ne).replace(".", ""));
    return te % Ie / Math.pow(10, ne);
  }
  class R extends l {
    constructor() {
      super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
    }
    _parse(O) {
      if (this._def.coerce && (O.data = Number(O.data)), this._getType(O) !== i.ZodParsedType.number) {
        const te = this._getOrReturnCtx(O);
        return (0, n.addIssueToContext)(te, {
          code: s.ZodIssueCode.invalid_type,
          expected: i.ZodParsedType.number,
          received: te.parsedType
        }), n.INVALID;
      }
      let W;
      const ne = new n.ParseStatus();
      for (const te of this._def.checks)
        te.kind === "int" ? i.util.isInteger(O.data) || (W = this._getOrReturnCtx(O, W), (0, n.addIssueToContext)(W, {
          code: s.ZodIssueCode.invalid_type,
          expected: "integer",
          received: "float",
          message: te.message
        }), ne.dirty()) : te.kind === "min" ? (te.inclusive ? O.data < te.value : O.data <= te.value) && (W = this._getOrReturnCtx(O, W), (0, n.addIssueToContext)(W, {
          code: s.ZodIssueCode.too_small,
          minimum: te.value,
          type: "number",
          inclusive: te.inclusive,
          exact: !1,
          message: te.message
        }), ne.dirty()) : te.kind === "max" ? (te.inclusive ? O.data > te.value : O.data >= te.value) && (W = this._getOrReturnCtx(O, W), (0, n.addIssueToContext)(W, {
          code: s.ZodIssueCode.too_big,
          maximum: te.value,
          type: "number",
          inclusive: te.inclusive,
          exact: !1,
          message: te.message
        }), ne.dirty()) : te.kind === "multipleOf" ? A(O.data, te.value) !== 0 && (W = this._getOrReturnCtx(O, W), (0, n.addIssueToContext)(W, {
          code: s.ZodIssueCode.not_multiple_of,
          multipleOf: te.value,
          message: te.message
        }), ne.dirty()) : te.kind === "finite" ? Number.isFinite(O.data) || (W = this._getOrReturnCtx(O, W), (0, n.addIssueToContext)(W, {
          code: s.ZodIssueCode.not_finite,
          message: te.message
        }), ne.dirty()) : i.util.assertNever(te);
      return { status: ne.value, value: O.data };
    }
    gte(O, j) {
      return this.setLimit("min", O, !0, r.errorUtil.toString(j));
    }
    gt(O, j) {
      return this.setLimit("min", O, !1, r.errorUtil.toString(j));
    }
    lte(O, j) {
      return this.setLimit("max", O, !0, r.errorUtil.toString(j));
    }
    lt(O, j) {
      return this.setLimit("max", O, !1, r.errorUtil.toString(j));
    }
    setLimit(O, j, W, ne) {
      return new R({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind: O,
            value: j,
            inclusive: W,
            message: r.errorUtil.toString(ne)
          }
        ]
      });
    }
    _addCheck(O) {
      return new R({
        ...this._def,
        checks: [...this._def.checks, O]
      });
    }
    int(O) {
      return this._addCheck({
        kind: "int",
        message: r.errorUtil.toString(O)
      });
    }
    positive(O) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: !1,
        message: r.errorUtil.toString(O)
      });
    }
    negative(O) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: !1,
        message: r.errorUtil.toString(O)
      });
    }
    nonpositive(O) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: !0,
        message: r.errorUtil.toString(O)
      });
    }
    nonnegative(O) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: !0,
        message: r.errorUtil.toString(O)
      });
    }
    multipleOf(O, j) {
      return this._addCheck({
        kind: "multipleOf",
        value: O,
        message: r.errorUtil.toString(j)
      });
    }
    finite(O) {
      return this._addCheck({
        kind: "finite",
        message: r.errorUtil.toString(O)
      });
    }
    safe(O) {
      return this._addCheck({
        kind: "min",
        inclusive: !0,
        value: Number.MIN_SAFE_INTEGER,
        message: r.errorUtil.toString(O)
      })._addCheck({
        kind: "max",
        inclusive: !0,
        value: Number.MAX_SAFE_INTEGER,
        message: r.errorUtil.toString(O)
      });
    }
    get minValue() {
      let O = null;
      for (const j of this._def.checks)
        j.kind === "min" && (O === null || j.value > O) && (O = j.value);
      return O;
    }
    get maxValue() {
      let O = null;
      for (const j of this._def.checks)
        j.kind === "max" && (O === null || j.value < O) && (O = j.value);
      return O;
    }
    get isInt() {
      return !!this._def.checks.find((O) => O.kind === "int" || O.kind === "multipleOf" && i.util.isInteger(O.value));
    }
    get isFinite() {
      let O = null, j = null;
      for (const W of this._def.checks) {
        if (W.kind === "finite" || W.kind === "int" || W.kind === "multipleOf")
          return !0;
        W.kind === "min" ? (j === null || W.value > j) && (j = W.value) : W.kind === "max" && (O === null || W.value < O) && (O = W.value);
      }
      return Number.isFinite(j) && Number.isFinite(O);
    }
  }
  e.ZodNumber = R, R.create = (Q) => new R({
    checks: [],
    typeName: qe.ZodNumber,
    coerce: (Q == null ? void 0 : Q.coerce) || !1,
    ...c(Q)
  });
  class I extends l {
    constructor() {
      super(...arguments), this.min = this.gte, this.max = this.lte;
    }
    _parse(O) {
      if (this._def.coerce && (O.data = BigInt(O.data)), this._getType(O) !== i.ZodParsedType.bigint) {
        const te = this._getOrReturnCtx(O);
        return (0, n.addIssueToContext)(te, {
          code: s.ZodIssueCode.invalid_type,
          expected: i.ZodParsedType.bigint,
          received: te.parsedType
        }), n.INVALID;
      }
      let W;
      const ne = new n.ParseStatus();
      for (const te of this._def.checks)
        te.kind === "min" ? (te.inclusive ? O.data < te.value : O.data <= te.value) && (W = this._getOrReturnCtx(O, W), (0, n.addIssueToContext)(W, {
          code: s.ZodIssueCode.too_small,
          type: "bigint",
          minimum: te.value,
          inclusive: te.inclusive,
          message: te.message
        }), ne.dirty()) : te.kind === "max" ? (te.inclusive ? O.data > te.value : O.data >= te.value) && (W = this._getOrReturnCtx(O, W), (0, n.addIssueToContext)(W, {
          code: s.ZodIssueCode.too_big,
          type: "bigint",
          maximum: te.value,
          inclusive: te.inclusive,
          message: te.message
        }), ne.dirty()) : te.kind === "multipleOf" ? O.data % te.value !== BigInt(0) && (W = this._getOrReturnCtx(O, W), (0, n.addIssueToContext)(W, {
          code: s.ZodIssueCode.not_multiple_of,
          multipleOf: te.value,
          message: te.message
        }), ne.dirty()) : i.util.assertNever(te);
      return { status: ne.value, value: O.data };
    }
    gte(O, j) {
      return this.setLimit("min", O, !0, r.errorUtil.toString(j));
    }
    gt(O, j) {
      return this.setLimit("min", O, !1, r.errorUtil.toString(j));
    }
    lte(O, j) {
      return this.setLimit("max", O, !0, r.errorUtil.toString(j));
    }
    lt(O, j) {
      return this.setLimit("max", O, !1, r.errorUtil.toString(j));
    }
    setLimit(O, j, W, ne) {
      return new I({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind: O,
            value: j,
            inclusive: W,
            message: r.errorUtil.toString(ne)
          }
        ]
      });
    }
    _addCheck(O) {
      return new I({
        ...this._def,
        checks: [...this._def.checks, O]
      });
    }
    positive(O) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: !1,
        message: r.errorUtil.toString(O)
      });
    }
    negative(O) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: !1,
        message: r.errorUtil.toString(O)
      });
    }
    nonpositive(O) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: !0,
        message: r.errorUtil.toString(O)
      });
    }
    nonnegative(O) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: !0,
        message: r.errorUtil.toString(O)
      });
    }
    multipleOf(O, j) {
      return this._addCheck({
        kind: "multipleOf",
        value: O,
        message: r.errorUtil.toString(j)
      });
    }
    get minValue() {
      let O = null;
      for (const j of this._def.checks)
        j.kind === "min" && (O === null || j.value > O) && (O = j.value);
      return O;
    }
    get maxValue() {
      let O = null;
      for (const j of this._def.checks)
        j.kind === "max" && (O === null || j.value < O) && (O = j.value);
      return O;
    }
  }
  e.ZodBigInt = I, I.create = (Q) => {
    var O;
    return new I({
      checks: [],
      typeName: qe.ZodBigInt,
      coerce: (O = Q == null ? void 0 : Q.coerce) !== null && O !== void 0 ? O : !1,
      ...c(Q)
    });
  };
  class D extends l {
    _parse(O) {
      if (this._def.coerce && (O.data = !!O.data), this._getType(O) !== i.ZodParsedType.boolean) {
        const W = this._getOrReturnCtx(O);
        return (0, n.addIssueToContext)(W, {
          code: s.ZodIssueCode.invalid_type,
          expected: i.ZodParsedType.boolean,
          received: W.parsedType
        }), n.INVALID;
      }
      return (0, n.OK)(O.data);
    }
  }
  e.ZodBoolean = D, D.create = (Q) => new D({
    typeName: qe.ZodBoolean,
    coerce: (Q == null ? void 0 : Q.coerce) || !1,
    ...c(Q)
  });
  class J extends l {
    _parse(O) {
      if (this._def.coerce && (O.data = new Date(O.data)), this._getType(O) !== i.ZodParsedType.date) {
        const te = this._getOrReturnCtx(O);
        return (0, n.addIssueToContext)(te, {
          code: s.ZodIssueCode.invalid_type,
          expected: i.ZodParsedType.date,
          received: te.parsedType
        }), n.INVALID;
      }
      if (isNaN(O.data.getTime())) {
        const te = this._getOrReturnCtx(O);
        return (0, n.addIssueToContext)(te, {
          code: s.ZodIssueCode.invalid_date
        }), n.INVALID;
      }
      const W = new n.ParseStatus();
      let ne;
      for (const te of this._def.checks)
        te.kind === "min" ? O.data.getTime() < te.value && (ne = this._getOrReturnCtx(O, ne), (0, n.addIssueToContext)(ne, {
          code: s.ZodIssueCode.too_small,
          message: te.message,
          inclusive: !0,
          exact: !1,
          minimum: te.value,
          type: "date"
        }), W.dirty()) : te.kind === "max" ? O.data.getTime() > te.value && (ne = this._getOrReturnCtx(O, ne), (0, n.addIssueToContext)(ne, {
          code: s.ZodIssueCode.too_big,
          message: te.message,
          inclusive: !0,
          exact: !1,
          maximum: te.value,
          type: "date"
        }), W.dirty()) : i.util.assertNever(te);
      return {
        status: W.value,
        value: new Date(O.data.getTime())
      };
    }
    _addCheck(O) {
      return new J({
        ...this._def,
        checks: [...this._def.checks, O]
      });
    }
    min(O, j) {
      return this._addCheck({
        kind: "min",
        value: O.getTime(),
        message: r.errorUtil.toString(j)
      });
    }
    max(O, j) {
      return this._addCheck({
        kind: "max",
        value: O.getTime(),
        message: r.errorUtil.toString(j)
      });
    }
    get minDate() {
      let O = null;
      for (const j of this._def.checks)
        j.kind === "min" && (O === null || j.value > O) && (O = j.value);
      return O != null ? new Date(O) : null;
    }
    get maxDate() {
      let O = null;
      for (const j of this._def.checks)
        j.kind === "max" && (O === null || j.value < O) && (O = j.value);
      return O != null ? new Date(O) : null;
    }
  }
  e.ZodDate = J, J.create = (Q) => new J({
    checks: [],
    coerce: (Q == null ? void 0 : Q.coerce) || !1,
    typeName: qe.ZodDate,
    ...c(Q)
  });
  class ae extends l {
    _parse(O) {
      if (this._getType(O) !== i.ZodParsedType.symbol) {
        const W = this._getOrReturnCtx(O);
        return (0, n.addIssueToContext)(W, {
          code: s.ZodIssueCode.invalid_type,
          expected: i.ZodParsedType.symbol,
          received: W.parsedType
        }), n.INVALID;
      }
      return (0, n.OK)(O.data);
    }
  }
  e.ZodSymbol = ae, ae.create = (Q) => new ae({
    typeName: qe.ZodSymbol,
    ...c(Q)
  });
  class ye extends l {
    _parse(O) {
      if (this._getType(O) !== i.ZodParsedType.undefined) {
        const W = this._getOrReturnCtx(O);
        return (0, n.addIssueToContext)(W, {
          code: s.ZodIssueCode.invalid_type,
          expected: i.ZodParsedType.undefined,
          received: W.parsedType
        }), n.INVALID;
      }
      return (0, n.OK)(O.data);
    }
  }
  e.ZodUndefined = ye, ye.create = (Q) => new ye({
    typeName: qe.ZodUndefined,
    ...c(Q)
  });
  class xe extends l {
    _parse(O) {
      if (this._getType(O) !== i.ZodParsedType.null) {
        const W = this._getOrReturnCtx(O);
        return (0, n.addIssueToContext)(W, {
          code: s.ZodIssueCode.invalid_type,
          expected: i.ZodParsedType.null,
          received: W.parsedType
        }), n.INVALID;
      }
      return (0, n.OK)(O.data);
    }
  }
  e.ZodNull = xe, xe.create = (Q) => new xe({
    typeName: qe.ZodNull,
    ...c(Q)
  });
  class je extends l {
    constructor() {
      super(...arguments), this._any = !0;
    }
    _parse(O) {
      return (0, n.OK)(O.data);
    }
  }
  e.ZodAny = je, je.create = (Q) => new je({
    typeName: qe.ZodAny,
    ...c(Q)
  });
  class re extends l {
    constructor() {
      super(...arguments), this._unknown = !0;
    }
    _parse(O) {
      return (0, n.OK)(O.data);
    }
  }
  e.ZodUnknown = re, re.create = (Q) => new re({
    typeName: qe.ZodUnknown,
    ...c(Q)
  });
  class fe extends l {
    _parse(O) {
      const j = this._getOrReturnCtx(O);
      return (0, n.addIssueToContext)(j, {
        code: s.ZodIssueCode.invalid_type,
        expected: i.ZodParsedType.never,
        received: j.parsedType
      }), n.INVALID;
    }
  }
  e.ZodNever = fe, fe.create = (Q) => new fe({
    typeName: qe.ZodNever,
    ...c(Q)
  });
  class le extends l {
    _parse(O) {
      if (this._getType(O) !== i.ZodParsedType.undefined) {
        const W = this._getOrReturnCtx(O);
        return (0, n.addIssueToContext)(W, {
          code: s.ZodIssueCode.invalid_type,
          expected: i.ZodParsedType.void,
          received: W.parsedType
        }), n.INVALID;
      }
      return (0, n.OK)(O.data);
    }
  }
  e.ZodVoid = le, le.create = (Q) => new le({
    typeName: qe.ZodVoid,
    ...c(Q)
  });
  class $e extends l {
    _parse(O) {
      const { ctx: j, status: W } = this._processInputParams(O), ne = this._def;
      if (j.parsedType !== i.ZodParsedType.array)
        return (0, n.addIssueToContext)(j, {
          code: s.ZodIssueCode.invalid_type,
          expected: i.ZodParsedType.array,
          received: j.parsedType
        }), n.INVALID;
      if (ne.exactLength !== null) {
        const Ie = j.data.length > ne.exactLength.value, Se = j.data.length < ne.exactLength.value;
        (Ie || Se) && ((0, n.addIssueToContext)(j, {
          code: Ie ? s.ZodIssueCode.too_big : s.ZodIssueCode.too_small,
          minimum: Se ? ne.exactLength.value : void 0,
          maximum: Ie ? ne.exactLength.value : void 0,
          type: "array",
          inclusive: !0,
          exact: !0,
          message: ne.exactLength.message
        }), W.dirty());
      }
      if (ne.minLength !== null && j.data.length < ne.minLength.value && ((0, n.addIssueToContext)(j, {
        code: s.ZodIssueCode.too_small,
        minimum: ne.minLength.value,
        type: "array",
        inclusive: !0,
        exact: !1,
        message: ne.minLength.message
      }), W.dirty()), ne.maxLength !== null && j.data.length > ne.maxLength.value && ((0, n.addIssueToContext)(j, {
        code: s.ZodIssueCode.too_big,
        maximum: ne.maxLength.value,
        type: "array",
        inclusive: !0,
        exact: !1,
        message: ne.maxLength.message
      }), W.dirty()), j.common.async)
        return Promise.all([...j.data].map((Ie, Se) => ne.type._parseAsync(new a(j, Ie, j.path, Se)))).then((Ie) => n.ParseStatus.mergeArray(W, Ie));
      const te = [...j.data].map((Ie, Se) => ne.type._parseSync(new a(j, Ie, j.path, Se)));
      return n.ParseStatus.mergeArray(W, te);
    }
    get element() {
      return this._def.type;
    }
    min(O, j) {
      return new $e({
        ...this._def,
        minLength: { value: O, message: r.errorUtil.toString(j) }
      });
    }
    max(O, j) {
      return new $e({
        ...this._def,
        maxLength: { value: O, message: r.errorUtil.toString(j) }
      });
    }
    length(O, j) {
      return new $e({
        ...this._def,
        exactLength: { value: O, message: r.errorUtil.toString(j) }
      });
    }
    nonempty(O) {
      return this.min(1, O);
    }
  }
  e.ZodArray = $e, $e.create = (Q, O) => new $e({
    type: Q,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: qe.ZodArray,
    ...c(O)
  });
  function Ae(Q) {
    if (Q instanceof _e) {
      const O = {};
      for (const j in Q.shape) {
        const W = Q.shape[j];
        O[j] = Ge.create(Ae(W));
      }
      return new _e({
        ...Q._def,
        shape: () => O
      });
    } else
      return Q instanceof $e ? new $e({
        ...Q._def,
        type: Ae(Q.element)
      }) : Q instanceof Ge ? Ge.create(Ae(Q.unwrap())) : Q instanceof jt ? jt.create(Ae(Q.unwrap())) : Q instanceof q ? q.create(Q.items.map((O) => Ae(O))) : Q;
  }
  class _e extends l {
    constructor() {
      super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
    }
    _getCached() {
      if (this._cached !== null)
        return this._cached;
      const O = this._def.shape(), j = i.util.objectKeys(O);
      return this._cached = { shape: O, keys: j };
    }
    _parse(O) {
      if (this._getType(O) !== i.ZodParsedType.object) {
        const Ze = this._getOrReturnCtx(O);
        return (0, n.addIssueToContext)(Ze, {
          code: s.ZodIssueCode.invalid_type,
          expected: i.ZodParsedType.object,
          received: Ze.parsedType
        }), n.INVALID;
      }
      const { status: W, ctx: ne } = this._processInputParams(O), { shape: te, keys: Ie } = this._getCached(), Se = [];
      if (!(this._def.catchall instanceof fe && this._def.unknownKeys === "strip"))
        for (const Ze in ne.data)
          Ie.includes(Ze) || Se.push(Ze);
      const Ke = [];
      for (const Ze of Ie) {
        const ct = te[Ze], Ut = ne.data[Ze];
        Ke.push({
          key: { status: "valid", value: Ze },
          value: ct._parse(new a(ne, Ut, ne.path, Ze)),
          alwaysSet: Ze in ne.data
        });
      }
      if (this._def.catchall instanceof fe) {
        const Ze = this._def.unknownKeys;
        if (Ze === "passthrough")
          for (const ct of Se)
            Ke.push({
              key: { status: "valid", value: ct },
              value: { status: "valid", value: ne.data[ct] }
            });
        else if (Ze === "strict")
          Se.length > 0 && ((0, n.addIssueToContext)(ne, {
            code: s.ZodIssueCode.unrecognized_keys,
            keys: Se
          }), W.dirty());
        else if (Ze !== "strip")
          throw new Error("Internal ZodObject error: invalid unknownKeys value.");
      } else {
        const Ze = this._def.catchall;
        for (const ct of Se) {
          const Ut = ne.data[ct];
          Ke.push({
            key: { status: "valid", value: ct },
            value: Ze._parse(new a(ne, Ut, ne.path, ct)),
            alwaysSet: ct in ne.data
          });
        }
      }
      return ne.common.async ? Promise.resolve().then(async () => {
        const Ze = [];
        for (const ct of Ke) {
          const Ut = await ct.key;
          Ze.push({
            key: Ut,
            value: await ct.value,
            alwaysSet: ct.alwaysSet
          });
        }
        return Ze;
      }).then((Ze) => n.ParseStatus.mergeObjectSync(W, Ze)) : n.ParseStatus.mergeObjectSync(W, Ke);
    }
    get shape() {
      return this._def.shape();
    }
    strict(O) {
      return r.errorUtil.errToObj, new _e({
        ...this._def,
        unknownKeys: "strict",
        ...O !== void 0 ? {
          errorMap: (j, W) => {
            var ne, te, Ie, Se;
            const Ke = (Ie = (te = (ne = this._def).errorMap) === null || te === void 0 ? void 0 : te.call(ne, j, W).message) !== null && Ie !== void 0 ? Ie : W.defaultError;
            return j.code === "unrecognized_keys" ? {
              message: (Se = r.errorUtil.errToObj(O).message) !== null && Se !== void 0 ? Se : Ke
            } : {
              message: Ke
            };
          }
        } : {}
      });
    }
    strip() {
      return new _e({
        ...this._def,
        unknownKeys: "strip"
      });
    }
    passthrough() {
      return new _e({
        ...this._def,
        unknownKeys: "passthrough"
      });
    }
    extend(O) {
      return new _e({
        ...this._def,
        shape: () => ({
          ...this._def.shape(),
          ...O
        })
      });
    }
    merge(O) {
      return new _e({
        unknownKeys: O._def.unknownKeys,
        catchall: O._def.catchall,
        shape: () => ({
          ...this._def.shape(),
          ...O._def.shape()
        }),
        typeName: qe.ZodObject
      });
    }
    setKey(O, j) {
      return this.augment({ [O]: j });
    }
    catchall(O) {
      return new _e({
        ...this._def,
        catchall: O
      });
    }
    pick(O) {
      const j = {};
      return i.util.objectKeys(O).forEach((W) => {
        O[W] && this.shape[W] && (j[W] = this.shape[W]);
      }), new _e({
        ...this._def,
        shape: () => j
      });
    }
    omit(O) {
      const j = {};
      return i.util.objectKeys(this.shape).forEach((W) => {
        O[W] || (j[W] = this.shape[W]);
      }), new _e({
        ...this._def,
        shape: () => j
      });
    }
    deepPartial() {
      return Ae(this);
    }
    partial(O) {
      const j = {};
      return i.util.objectKeys(this.shape).forEach((W) => {
        const ne = this.shape[W];
        O && !O[W] ? j[W] = ne : j[W] = ne.optional();
      }), new _e({
        ...this._def,
        shape: () => j
      });
    }
    required(O) {
      const j = {};
      return i.util.objectKeys(this.shape).forEach((W) => {
        if (O && !O[W])
          j[W] = this.shape[W];
        else {
          let te = this.shape[W];
          for (; te instanceof Ge; )
            te = te._def.innerType;
          j[W] = te;
        }
      }), new _e({
        ...this._def,
        shape: () => j
      });
    }
    keyof() {
      return U(i.util.objectKeys(this.shape));
    }
  }
  e.ZodObject = _e, _e.create = (Q, O) => new _e({
    shape: () => Q,
    unknownKeys: "strip",
    catchall: fe.create(),
    typeName: qe.ZodObject,
    ...c(O)
  }), _e.strictCreate = (Q, O) => new _e({
    shape: () => Q,
    unknownKeys: "strict",
    catchall: fe.create(),
    typeName: qe.ZodObject,
    ...c(O)
  }), _e.lazycreate = (Q, O) => new _e({
    shape: Q,
    unknownKeys: "strip",
    catchall: fe.create(),
    typeName: qe.ZodObject,
    ...c(O)
  });
  class ie extends l {
    _parse(O) {
      const { ctx: j } = this._processInputParams(O), W = this._def.options;
      function ne(te) {
        for (const Se of te)
          if (Se.result.status === "valid")
            return Se.result;
        for (const Se of te)
          if (Se.result.status === "dirty")
            return j.common.issues.push(...Se.ctx.common.issues), Se.result;
        const Ie = te.map((Se) => new s.ZodError(Se.ctx.common.issues));
        return (0, n.addIssueToContext)(j, {
          code: s.ZodIssueCode.invalid_union,
          unionErrors: Ie
        }), n.INVALID;
      }
      if (j.common.async)
        return Promise.all(W.map(async (te) => {
          const Ie = {
            ...j,
            common: {
              ...j.common,
              issues: []
            },
            parent: null
          };
          return {
            result: await te._parseAsync({
              data: j.data,
              path: j.path,
              parent: Ie
            }),
            ctx: Ie
          };
        })).then(ne);
      {
        let te;
        const Ie = [];
        for (const Ke of W) {
          const Ze = {
            ...j,
            common: {
              ...j.common,
              issues: []
            },
            parent: null
          }, ct = Ke._parseSync({
            data: j.data,
            path: j.path,
            parent: Ze
          });
          if (ct.status === "valid")
            return ct;
          ct.status === "dirty" && !te && (te = { result: ct, ctx: Ze }), Ze.common.issues.length && Ie.push(Ze.common.issues);
        }
        if (te)
          return j.common.issues.push(...te.ctx.common.issues), te.result;
        const Se = Ie.map((Ke) => new s.ZodError(Ke));
        return (0, n.addIssueToContext)(j, {
          code: s.ZodIssueCode.invalid_union,
          unionErrors: Se
        }), n.INVALID;
      }
    }
    get options() {
      return this._def.options;
    }
  }
  e.ZodUnion = ie, ie.create = (Q, O) => new ie({
    options: Q,
    typeName: qe.ZodUnion,
    ...c(O)
  });
  const K = (Q) => Q instanceof Y ? K(Q.schema) : Q instanceof Fe ? K(Q.innerType()) : Q instanceof k ? [Q.value] : Q instanceof pe ? Q.options : Q instanceof we ? Object.keys(Q.enum) : Q instanceof Ee ? K(Q._def.innerType) : Q instanceof ye ? [void 0] : Q instanceof xe ? [null] : null;
  class V extends l {
    _parse(O) {
      const { ctx: j } = this._processInputParams(O);
      if (j.parsedType !== i.ZodParsedType.object)
        return (0, n.addIssueToContext)(j, {
          code: s.ZodIssueCode.invalid_type,
          expected: i.ZodParsedType.object,
          received: j.parsedType
        }), n.INVALID;
      const W = this.discriminator, ne = j.data[W], te = this.optionsMap.get(ne);
      return te ? j.common.async ? te._parseAsync({
        data: j.data,
        path: j.path,
        parent: j
      }) : te._parseSync({
        data: j.data,
        path: j.path,
        parent: j
      }) : ((0, n.addIssueToContext)(j, {
        code: s.ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [W]
      }), n.INVALID);
    }
    get discriminator() {
      return this._def.discriminator;
    }
    get options() {
      return this._def.options;
    }
    get optionsMap() {
      return this._def.optionsMap;
    }
    static create(O, j, W) {
      const ne = /* @__PURE__ */ new Map();
      for (const te of j) {
        const Ie = K(te.shape[O]);
        if (!Ie)
          throw new Error(`A discriminator value for key \`${O}\` could not be extracted from all schema options`);
        for (const Se of Ie) {
          if (ne.has(Se))
            throw new Error(`Discriminator property ${String(O)} has duplicate value ${String(Se)}`);
          ne.set(Se, te);
        }
      }
      return new V({
        typeName: qe.ZodDiscriminatedUnion,
        discriminator: O,
        options: j,
        optionsMap: ne,
        ...c(W)
      });
    }
  }
  e.ZodDiscriminatedUnion = V;
  function z(Q, O) {
    const j = (0, i.getParsedType)(Q), W = (0, i.getParsedType)(O);
    if (Q === O)
      return { valid: !0, data: Q };
    if (j === i.ZodParsedType.object && W === i.ZodParsedType.object) {
      const ne = i.util.objectKeys(O), te = i.util.objectKeys(Q).filter((Se) => ne.indexOf(Se) !== -1), Ie = { ...Q, ...O };
      for (const Se of te) {
        const Ke = z(Q[Se], O[Se]);
        if (!Ke.valid)
          return { valid: !1 };
        Ie[Se] = Ke.data;
      }
      return { valid: !0, data: Ie };
    } else if (j === i.ZodParsedType.array && W === i.ZodParsedType.array) {
      if (Q.length !== O.length)
        return { valid: !1 };
      const ne = [];
      for (let te = 0; te < Q.length; te++) {
        const Ie = Q[te], Se = O[te], Ke = z(Ie, Se);
        if (!Ke.valid)
          return { valid: !1 };
        ne.push(Ke.data);
      }
      return { valid: !0, data: ne };
    } else
      return j === i.ZodParsedType.date && W === i.ZodParsedType.date && +Q == +O ? { valid: !0, data: Q } : { valid: !1 };
  }
  class C extends l {
    _parse(O) {
      const { status: j, ctx: W } = this._processInputParams(O), ne = (te, Ie) => {
        if ((0, n.isAborted)(te) || (0, n.isAborted)(Ie))
          return n.INVALID;
        const Se = z(te.value, Ie.value);
        return Se.valid ? (((0, n.isDirty)(te) || (0, n.isDirty)(Ie)) && j.dirty(), { status: j.value, value: Se.data }) : ((0, n.addIssueToContext)(W, {
          code: s.ZodIssueCode.invalid_intersection_types
        }), n.INVALID);
      };
      return W.common.async ? Promise.all([
        this._def.left._parseAsync({
          data: W.data,
          path: W.path,
          parent: W
        }),
        this._def.right._parseAsync({
          data: W.data,
          path: W.path,
          parent: W
        })
      ]).then(([te, Ie]) => ne(te, Ie)) : ne(this._def.left._parseSync({
        data: W.data,
        path: W.path,
        parent: W
      }), this._def.right._parseSync({
        data: W.data,
        path: W.path,
        parent: W
      }));
    }
  }
  e.ZodIntersection = C, C.create = (Q, O, j) => new C({
    left: Q,
    right: O,
    typeName: qe.ZodIntersection,
    ...c(j)
  });
  class q extends l {
    _parse(O) {
      const { status: j, ctx: W } = this._processInputParams(O);
      if (W.parsedType !== i.ZodParsedType.array)
        return (0, n.addIssueToContext)(W, {
          code: s.ZodIssueCode.invalid_type,
          expected: i.ZodParsedType.array,
          received: W.parsedType
        }), n.INVALID;
      if (W.data.length < this._def.items.length)
        return (0, n.addIssueToContext)(W, {
          code: s.ZodIssueCode.too_small,
          minimum: this._def.items.length,
          inclusive: !0,
          exact: !1,
          type: "array"
        }), n.INVALID;
      !this._def.rest && W.data.length > this._def.items.length && ((0, n.addIssueToContext)(W, {
        code: s.ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), j.dirty());
      const te = [...W.data].map((Ie, Se) => {
        const Ke = this._def.items[Se] || this._def.rest;
        return Ke ? Ke._parse(new a(W, Ie, W.path, Se)) : null;
      }).filter((Ie) => !!Ie);
      return W.common.async ? Promise.all(te).then((Ie) => n.ParseStatus.mergeArray(j, Ie)) : n.ParseStatus.mergeArray(j, te);
    }
    get items() {
      return this._def.items;
    }
    rest(O) {
      return new q({
        ...this._def,
        rest: O
      });
    }
  }
  e.ZodTuple = q, q.create = (Q, O) => {
    if (!Array.isArray(Q))
      throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    return new q({
      items: Q,
      typeName: qe.ZodTuple,
      rest: null,
      ...c(O)
    });
  };
  class N extends l {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(O) {
      const { status: j, ctx: W } = this._processInputParams(O);
      if (W.parsedType !== i.ZodParsedType.object)
        return (0, n.addIssueToContext)(W, {
          code: s.ZodIssueCode.invalid_type,
          expected: i.ZodParsedType.object,
          received: W.parsedType
        }), n.INVALID;
      const ne = [], te = this._def.keyType, Ie = this._def.valueType;
      for (const Se in W.data)
        ne.push({
          key: te._parse(new a(W, Se, W.path, Se)),
          value: Ie._parse(new a(W, W.data[Se], W.path, Se))
        });
      return W.common.async ? n.ParseStatus.mergeObjectAsync(j, ne) : n.ParseStatus.mergeObjectSync(j, ne);
    }
    get element() {
      return this._def.valueType;
    }
    static create(O, j, W) {
      return j instanceof l ? new N({
        keyType: O,
        valueType: j,
        typeName: qe.ZodRecord,
        ...c(W)
      }) : new N({
        keyType: E.create(),
        valueType: O,
        typeName: qe.ZodRecord,
        ...c(j)
      });
    }
  }
  e.ZodRecord = N;
  class F extends l {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(O) {
      const { status: j, ctx: W } = this._processInputParams(O);
      if (W.parsedType !== i.ZodParsedType.map)
        return (0, n.addIssueToContext)(W, {
          code: s.ZodIssueCode.invalid_type,
          expected: i.ZodParsedType.map,
          received: W.parsedType
        }), n.INVALID;
      const ne = this._def.keyType, te = this._def.valueType, Ie = [...W.data.entries()].map(([Se, Ke], Ze) => ({
        key: ne._parse(new a(W, Se, W.path, [Ze, "key"])),
        value: te._parse(new a(W, Ke, W.path, [Ze, "value"]))
      }));
      if (W.common.async) {
        const Se = /* @__PURE__ */ new Map();
        return Promise.resolve().then(async () => {
          for (const Ke of Ie) {
            const Ze = await Ke.key, ct = await Ke.value;
            if (Ze.status === "aborted" || ct.status === "aborted")
              return n.INVALID;
            (Ze.status === "dirty" || ct.status === "dirty") && j.dirty(), Se.set(Ze.value, ct.value);
          }
          return { status: j.value, value: Se };
        });
      } else {
        const Se = /* @__PURE__ */ new Map();
        for (const Ke of Ie) {
          const Ze = Ke.key, ct = Ke.value;
          if (Ze.status === "aborted" || ct.status === "aborted")
            return n.INVALID;
          (Ze.status === "dirty" || ct.status === "dirty") && j.dirty(), Se.set(Ze.value, ct.value);
        }
        return { status: j.value, value: Se };
      }
    }
  }
  e.ZodMap = F, F.create = (Q, O, j) => new F({
    valueType: O,
    keyType: Q,
    typeName: qe.ZodMap,
    ...c(j)
  });
  class T extends l {
    _parse(O) {
      const { status: j, ctx: W } = this._processInputParams(O);
      if (W.parsedType !== i.ZodParsedType.set)
        return (0, n.addIssueToContext)(W, {
          code: s.ZodIssueCode.invalid_type,
          expected: i.ZodParsedType.set,
          received: W.parsedType
        }), n.INVALID;
      const ne = this._def;
      ne.minSize !== null && W.data.size < ne.minSize.value && ((0, n.addIssueToContext)(W, {
        code: s.ZodIssueCode.too_small,
        minimum: ne.minSize.value,
        type: "set",
        inclusive: !0,
        exact: !1,
        message: ne.minSize.message
      }), j.dirty()), ne.maxSize !== null && W.data.size > ne.maxSize.value && ((0, n.addIssueToContext)(W, {
        code: s.ZodIssueCode.too_big,
        maximum: ne.maxSize.value,
        type: "set",
        inclusive: !0,
        exact: !1,
        message: ne.maxSize.message
      }), j.dirty());
      const te = this._def.valueType;
      function Ie(Ke) {
        const Ze = /* @__PURE__ */ new Set();
        for (const ct of Ke) {
          if (ct.status === "aborted")
            return n.INVALID;
          ct.status === "dirty" && j.dirty(), Ze.add(ct.value);
        }
        return { status: j.value, value: Ze };
      }
      const Se = [...W.data.values()].map((Ke, Ze) => te._parse(new a(W, Ke, W.path, Ze)));
      return W.common.async ? Promise.all(Se).then((Ke) => Ie(Ke)) : Ie(Se);
    }
    min(O, j) {
      return new T({
        ...this._def,
        minSize: { value: O, message: r.errorUtil.toString(j) }
      });
    }
    max(O, j) {
      return new T({
        ...this._def,
        maxSize: { value: O, message: r.errorUtil.toString(j) }
      });
    }
    size(O, j) {
      return this.min(O, j).max(O, j);
    }
    nonempty(O) {
      return this.min(1, O);
    }
  }
  e.ZodSet = T, T.create = (Q, O) => new T({
    valueType: Q,
    minSize: null,
    maxSize: null,
    typeName: qe.ZodSet,
    ...c(O)
  });
  class Z extends l {
    constructor() {
      super(...arguments), this.validate = this.implement;
    }
    _parse(O) {
      const { ctx: j } = this._processInputParams(O);
      if (j.parsedType !== i.ZodParsedType.function)
        return (0, n.addIssueToContext)(j, {
          code: s.ZodIssueCode.invalid_type,
          expected: i.ZodParsedType.function,
          received: j.parsedType
        }), n.INVALID;
      function W(Se, Ke) {
        return (0, n.makeIssue)({
          data: Se,
          path: j.path,
          errorMaps: [
            j.common.contextualErrorMap,
            j.schemaErrorMap,
            (0, t.getErrorMap)(),
            t.defaultErrorMap
          ].filter((Ze) => !!Ze),
          issueData: {
            code: s.ZodIssueCode.invalid_arguments,
            argumentsError: Ke
          }
        });
      }
      function ne(Se, Ke) {
        return (0, n.makeIssue)({
          data: Se,
          path: j.path,
          errorMaps: [
            j.common.contextualErrorMap,
            j.schemaErrorMap,
            (0, t.getErrorMap)(),
            t.defaultErrorMap
          ].filter((Ze) => !!Ze),
          issueData: {
            code: s.ZodIssueCode.invalid_return_type,
            returnTypeError: Ke
          }
        });
      }
      const te = { errorMap: j.common.contextualErrorMap }, Ie = j.data;
      if (this._def.returns instanceof He) {
        const Se = this;
        return (0, n.OK)(async function(...Ke) {
          const Ze = new s.ZodError([]), ct = await Se._def.args.parseAsync(Ke, te).catch((Gr) => {
            throw Ze.addIssue(W(Ke, Gr)), Ze;
          }), Ut = await Reflect.apply(Ie, this, ct);
          return await Se._def.returns._def.type.parseAsync(Ut, te).catch((Gr) => {
            throw Ze.addIssue(ne(Ut, Gr)), Ze;
          });
        });
      } else {
        const Se = this;
        return (0, n.OK)(function(...Ke) {
          const Ze = Se._def.args.safeParse(Ke, te);
          if (!Ze.success)
            throw new s.ZodError([W(Ke, Ze.error)]);
          const ct = Reflect.apply(Ie, this, Ze.data), Ut = Se._def.returns.safeParse(ct, te);
          if (!Ut.success)
            throw new s.ZodError([ne(ct, Ut.error)]);
          return Ut.data;
        });
      }
    }
    parameters() {
      return this._def.args;
    }
    returnType() {
      return this._def.returns;
    }
    args(...O) {
      return new Z({
        ...this._def,
        args: q.create(O).rest(re.create())
      });
    }
    returns(O) {
      return new Z({
        ...this._def,
        returns: O
      });
    }
    implement(O) {
      return this.parse(O);
    }
    strictImplement(O) {
      return this.parse(O);
    }
    static create(O, j, W) {
      return new Z({
        args: O || q.create([]).rest(re.create()),
        returns: j || re.create(),
        typeName: qe.ZodFunction,
        ...c(W)
      });
    }
  }
  e.ZodFunction = Z;
  class Y extends l {
    get schema() {
      return this._def.getter();
    }
    _parse(O) {
      const { ctx: j } = this._processInputParams(O);
      return this._def.getter()._parse({ data: j.data, path: j.path, parent: j });
    }
  }
  e.ZodLazy = Y, Y.create = (Q, O) => new Y({
    getter: Q,
    typeName: qe.ZodLazy,
    ...c(O)
  });
  class k extends l {
    _parse(O) {
      if (O.data !== this._def.value) {
        const j = this._getOrReturnCtx(O);
        return (0, n.addIssueToContext)(j, {
          received: j.data,
          code: s.ZodIssueCode.invalid_literal,
          expected: this._def.value
        }), n.INVALID;
      }
      return { status: "valid", value: O.data };
    }
    get value() {
      return this._def.value;
    }
  }
  e.ZodLiteral = k, k.create = (Q, O) => new k({
    value: Q,
    typeName: qe.ZodLiteral,
    ...c(O)
  });
  function U(Q, O) {
    return new pe({
      values: Q,
      typeName: qe.ZodEnum,
      ...c(O)
    });
  }
  class pe extends l {
    _parse(O) {
      if (typeof O.data != "string") {
        const j = this._getOrReturnCtx(O), W = this._def.values;
        return (0, n.addIssueToContext)(j, {
          expected: i.util.joinValues(W),
          received: j.parsedType,
          code: s.ZodIssueCode.invalid_type
        }), n.INVALID;
      }
      if (this._def.values.indexOf(O.data) === -1) {
        const j = this._getOrReturnCtx(O), W = this._def.values;
        return (0, n.addIssueToContext)(j, {
          received: j.data,
          code: s.ZodIssueCode.invalid_enum_value,
          options: W
        }), n.INVALID;
      }
      return (0, n.OK)(O.data);
    }
    get options() {
      return this._def.values;
    }
    get enum() {
      const O = {};
      for (const j of this._def.values)
        O[j] = j;
      return O;
    }
    get Values() {
      const O = {};
      for (const j of this._def.values)
        O[j] = j;
      return O;
    }
    get Enum() {
      const O = {};
      for (const j of this._def.values)
        O[j] = j;
      return O;
    }
    extract(O) {
      return pe.create(O);
    }
    exclude(O) {
      return pe.create(this.options.filter((j) => !O.includes(j)));
    }
  }
  e.ZodEnum = pe, pe.create = U;
  class we extends l {
    _parse(O) {
      const j = i.util.getValidEnumValues(this._def.values), W = this._getOrReturnCtx(O);
      if (W.parsedType !== i.ZodParsedType.string && W.parsedType !== i.ZodParsedType.number) {
        const ne = i.util.objectValues(j);
        return (0, n.addIssueToContext)(W, {
          expected: i.util.joinValues(ne),
          received: W.parsedType,
          code: s.ZodIssueCode.invalid_type
        }), n.INVALID;
      }
      if (j.indexOf(O.data) === -1) {
        const ne = i.util.objectValues(j);
        return (0, n.addIssueToContext)(W, {
          received: W.data,
          code: s.ZodIssueCode.invalid_enum_value,
          options: ne
        }), n.INVALID;
      }
      return (0, n.OK)(O.data);
    }
    get enum() {
      return this._def.values;
    }
  }
  e.ZodNativeEnum = we, we.create = (Q, O) => new we({
    values: Q,
    typeName: qe.ZodNativeEnum,
    ...c(O)
  });
  class He extends l {
    unwrap() {
      return this._def.type;
    }
    _parse(O) {
      const { ctx: j } = this._processInputParams(O);
      if (j.parsedType !== i.ZodParsedType.promise && j.common.async === !1)
        return (0, n.addIssueToContext)(j, {
          code: s.ZodIssueCode.invalid_type,
          expected: i.ZodParsedType.promise,
          received: j.parsedType
        }), n.INVALID;
      const W = j.parsedType === i.ZodParsedType.promise ? j.data : Promise.resolve(j.data);
      return (0, n.OK)(W.then((ne) => this._def.type.parseAsync(ne, {
        path: j.path,
        errorMap: j.common.contextualErrorMap
      })));
    }
  }
  e.ZodPromise = He, He.create = (Q, O) => new He({
    type: Q,
    typeName: qe.ZodPromise,
    ...c(O)
  });
  class Fe extends l {
    innerType() {
      return this._def.schema;
    }
    sourceType() {
      return this._def.schema._def.typeName === qe.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(O) {
      const { status: j, ctx: W } = this._processInputParams(O), ne = this._def.effect || null, te = {
        addIssue: (Ie) => {
          (0, n.addIssueToContext)(W, Ie), Ie.fatal ? j.abort() : j.dirty();
        },
        get path() {
          return W.path;
        }
      };
      if (te.addIssue = te.addIssue.bind(te), ne.type === "preprocess") {
        const Ie = ne.transform(W.data, te);
        return W.common.issues.length ? {
          status: "dirty",
          value: W.data
        } : W.common.async ? Promise.resolve(Ie).then((Se) => this._def.schema._parseAsync({
          data: Se,
          path: W.path,
          parent: W
        })) : this._def.schema._parseSync({
          data: Ie,
          path: W.path,
          parent: W
        });
      }
      if (ne.type === "refinement") {
        const Ie = (Se) => {
          const Ke = ne.refinement(Se, te);
          if (W.common.async)
            return Promise.resolve(Ke);
          if (Ke instanceof Promise)
            throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
          return Se;
        };
        if (W.common.async === !1) {
          const Se = this._def.schema._parseSync({
            data: W.data,
            path: W.path,
            parent: W
          });
          return Se.status === "aborted" ? n.INVALID : (Se.status === "dirty" && j.dirty(), Ie(Se.value), { status: j.value, value: Se.value });
        } else
          return this._def.schema._parseAsync({ data: W.data, path: W.path, parent: W }).then((Se) => Se.status === "aborted" ? n.INVALID : (Se.status === "dirty" && j.dirty(), Ie(Se.value).then(() => ({ status: j.value, value: Se.value }))));
      }
      if (ne.type === "transform")
        if (W.common.async === !1) {
          const Ie = this._def.schema._parseSync({
            data: W.data,
            path: W.path,
            parent: W
          });
          if (!(0, n.isValid)(Ie))
            return Ie;
          const Se = ne.transform(Ie.value, te);
          if (Se instanceof Promise)
            throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
          return { status: j.value, value: Se };
        } else
          return this._def.schema._parseAsync({ data: W.data, path: W.path, parent: W }).then((Ie) => (0, n.isValid)(Ie) ? Promise.resolve(ne.transform(Ie.value, te)).then((Se) => ({ status: j.value, value: Se })) : Ie);
      i.util.assertNever(ne);
    }
  }
  e.ZodEffects = Fe, e.ZodTransformer = Fe, Fe.create = (Q, O, j) => new Fe({
    schema: Q,
    typeName: qe.ZodEffects,
    effect: O,
    ...c(j)
  }), Fe.createWithPreprocess = (Q, O, j) => new Fe({
    schema: O,
    effect: { type: "preprocess", transform: Q },
    typeName: qe.ZodEffects,
    ...c(j)
  });
  class Ge extends l {
    _parse(O) {
      return this._getType(O) === i.ZodParsedType.undefined ? (0, n.OK)(void 0) : this._def.innerType._parse(O);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  e.ZodOptional = Ge, Ge.create = (Q, O) => new Ge({
    innerType: Q,
    typeName: qe.ZodOptional,
    ...c(O)
  });
  class jt extends l {
    _parse(O) {
      return this._getType(O) === i.ZodParsedType.null ? (0, n.OK)(null) : this._def.innerType._parse(O);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  e.ZodNullable = jt, jt.create = (Q, O) => new jt({
    innerType: Q,
    typeName: qe.ZodNullable,
    ...c(O)
  });
  class Ee extends l {
    _parse(O) {
      const { ctx: j } = this._processInputParams(O);
      let W = j.data;
      return j.parsedType === i.ZodParsedType.undefined && (W = this._def.defaultValue()), this._def.innerType._parse({
        data: W,
        path: j.path,
        parent: j
      });
    }
    removeDefault() {
      return this._def.innerType;
    }
  }
  e.ZodDefault = Ee, Ee.create = (Q, O) => new Ee({
    innerType: Q,
    typeName: qe.ZodDefault,
    defaultValue: typeof O.default == "function" ? O.default : () => O.default,
    ...c(O)
  });
  class Mt extends l {
    _parse(O) {
      const { ctx: j } = this._processInputParams(O), W = {
        ...j,
        common: {
          ...j.common,
          issues: []
        }
      }, ne = this._def.innerType._parse({
        data: W.data,
        path: W.path,
        parent: {
          ...W
        }
      });
      return (0, n.isAsync)(ne) ? ne.then((te) => ({
        status: "valid",
        value: te.status === "valid" ? te.value : this._def.catchValue({
          get error() {
            return new s.ZodError(W.common.issues);
          },
          input: W.data
        })
      })) : {
        status: "valid",
        value: ne.status === "valid" ? ne.value : this._def.catchValue({
          get error() {
            return new s.ZodError(W.common.issues);
          },
          input: W.data
        })
      };
    }
    removeCatch() {
      return this._def.innerType;
    }
  }
  e.ZodCatch = Mt, Mt.create = (Q, O) => new Mt({
    innerType: Q,
    typeName: qe.ZodCatch,
    catchValue: typeof O.catch == "function" ? O.catch : () => O.catch,
    ...c(O)
  });
  class St extends l {
    _parse(O) {
      if (this._getType(O) !== i.ZodParsedType.nan) {
        const W = this._getOrReturnCtx(O);
        return (0, n.addIssueToContext)(W, {
          code: s.ZodIssueCode.invalid_type,
          expected: i.ZodParsedType.nan,
          received: W.parsedType
        }), n.INVALID;
      }
      return { status: "valid", value: O.data };
    }
  }
  e.ZodNaN = St, St.create = (Q) => new St({
    typeName: qe.ZodNaN,
    ...c(Q)
  }), e.BRAND = Symbol("zod_brand");
  class Ne extends l {
    _parse(O) {
      const { ctx: j } = this._processInputParams(O), W = j.data;
      return this._def.type._parse({
        data: W,
        path: j.path,
        parent: j
      });
    }
    unwrap() {
      return this._def.type;
    }
  }
  e.ZodBranded = Ne;
  class Le extends l {
    _parse(O) {
      const { status: j, ctx: W } = this._processInputParams(O);
      if (W.common.async)
        return (async () => {
          const te = await this._def.in._parseAsync({
            data: W.data,
            path: W.path,
            parent: W
          });
          return te.status === "aborted" ? n.INVALID : te.status === "dirty" ? (j.dirty(), (0, n.DIRTY)(te.value)) : this._def.out._parseAsync({
            data: te.value,
            path: W.path,
            parent: W
          });
        })();
      {
        const ne = this._def.in._parseSync({
          data: W.data,
          path: W.path,
          parent: W
        });
        return ne.status === "aborted" ? n.INVALID : ne.status === "dirty" ? (j.dirty(), {
          status: "dirty",
          value: ne.value
        }) : this._def.out._parseSync({
          data: ne.value,
          path: W.path,
          parent: W
        });
      }
    }
    static create(O, j) {
      return new Le({
        in: O,
        out: j,
        typeName: qe.ZodPipeline
      });
    }
  }
  e.ZodPipeline = Le;
  class at extends l {
    _parse(O) {
      const j = this._def.innerType._parse(O);
      return (0, n.isValid)(j) && (j.value = Object.freeze(j.value)), j;
    }
  }
  e.ZodReadonly = at, at.create = (Q, O) => new at({
    innerType: Q,
    typeName: qe.ZodReadonly,
    ...c(O)
  });
  const mt = (Q, O = {}, j) => Q ? je.create().superRefine((W, ne) => {
    var te, Ie;
    if (!Q(W)) {
      const Se = typeof O == "function" ? O(W) : typeof O == "string" ? { message: O } : O, Ke = (Ie = (te = Se.fatal) !== null && te !== void 0 ? te : j) !== null && Ie !== void 0 ? Ie : !0, Ze = typeof Se == "string" ? { message: Se } : Se;
      ne.addIssue({ code: "custom", ...Ze, fatal: Ke });
    }
  }) : je.create();
  e.custom = mt, e.late = {
    object: _e.lazycreate
  };
  var qe;
  (function(Q) {
    Q.ZodString = "ZodString", Q.ZodNumber = "ZodNumber", Q.ZodNaN = "ZodNaN", Q.ZodBigInt = "ZodBigInt", Q.ZodBoolean = "ZodBoolean", Q.ZodDate = "ZodDate", Q.ZodSymbol = "ZodSymbol", Q.ZodUndefined = "ZodUndefined", Q.ZodNull = "ZodNull", Q.ZodAny = "ZodAny", Q.ZodUnknown = "ZodUnknown", Q.ZodNever = "ZodNever", Q.ZodVoid = "ZodVoid", Q.ZodArray = "ZodArray", Q.ZodObject = "ZodObject", Q.ZodUnion = "ZodUnion", Q.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", Q.ZodIntersection = "ZodIntersection", Q.ZodTuple = "ZodTuple", Q.ZodRecord = "ZodRecord", Q.ZodMap = "ZodMap", Q.ZodSet = "ZodSet", Q.ZodFunction = "ZodFunction", Q.ZodLazy = "ZodLazy", Q.ZodLiteral = "ZodLiteral", Q.ZodEnum = "ZodEnum", Q.ZodEffects = "ZodEffects", Q.ZodNativeEnum = "ZodNativeEnum", Q.ZodOptional = "ZodOptional", Q.ZodNullable = "ZodNullable", Q.ZodDefault = "ZodDefault", Q.ZodCatch = "ZodCatch", Q.ZodPromise = "ZodPromise", Q.ZodBranded = "ZodBranded", Q.ZodPipeline = "ZodPipeline", Q.ZodReadonly = "ZodReadonly";
  })(qe = e.ZodFirstPartyTypeKind || (e.ZodFirstPartyTypeKind = {}));
  const L = (Q, O = {
    message: `Input not instance of ${Q.name}`
  }) => (0, e.custom)((j) => j instanceof Q, O);
  e.instanceof = L;
  const x = E.create;
  e.string = x;
  const S = R.create;
  e.number = S;
  const G = St.create;
  e.nan = G;
  const ce = I.create;
  e.bigint = ce;
  const me = D.create;
  e.boolean = me;
  const Oe = J.create;
  e.date = Oe;
  const ut = ae.create;
  e.symbol = ut;
  const Dt = ye.create;
  e.undefined = Dt;
  const Tt = xe.create;
  e.null = Tt;
  const wt = je.create;
  e.any = wt;
  const It = re.create;
  e.unknown = It;
  const _o = fe.create;
  e.never = _o;
  const wo = le.create;
  e.void = wo;
  const oa = $e.create;
  e.array = oa;
  const ua = _e.create;
  e.object = ua;
  const $o = _e.strictCreate;
  e.strictObject = $o;
  const Fn = ie.create;
  e.union = Fn;
  const Eo = V.create;
  e.discriminatedUnion = Eo;
  const ca = C.create;
  e.intersection = ca;
  const la = q.create;
  e.tuple = la;
  const ws = N.create;
  e.record = ws;
  const fa = F.create;
  e.map = fa;
  const xo = T.create;
  e.set = xo;
  const Ni = Z.create;
  e.function = Ni;
  const Oo = Y.create;
  e.lazy = Oo;
  const Di = k.create;
  e.literal = Di;
  const se = pe.create;
  e.enum = se;
  const X = we.create;
  e.nativeEnum = X;
  const ue = He.create;
  e.promise = ue;
  const ve = Fe.create;
  e.effect = ve, e.transformer = ve;
  const ge = Ge.create;
  e.optional = ge;
  const Ye = jt.create;
  e.nullable = Ye;
  const Xe = Fe.createWithPreprocess;
  e.preprocess = Xe;
  const Et = Le.create;
  e.pipeline = Et;
  const Lt = () => x().optional();
  e.ostring = Lt;
  const Wt = () => S().optional();
  e.onumber = Wt;
  const vt = () => me().optional();
  e.oboolean = vt, e.coerce = {
    string: (Q) => E.create({ ...Q, coerce: !0 }),
    number: (Q) => R.create({ ...Q, coerce: !0 }),
    boolean: (Q) => D.create({
      ...Q,
      coerce: !0
    }),
    bigint: (Q) => I.create({ ...Q, coerce: !0 }),
    date: (Q) => J.create({ ...Q, coerce: !0 })
  }, e.NEVER = n.INVALID;
})(NE);
(function(e) {
  var t = rt && rt.__createBinding || (Object.create ? function(n, i, s, a) {
    a === void 0 && (a = s), Object.defineProperty(n, a, { enumerable: !0, get: function() {
      return i[s];
    } });
  } : function(n, i, s, a) {
    a === void 0 && (a = s), n[a] = i[s];
  }), r = rt && rt.__exportStar || function(n, i) {
    for (var s in n)
      s !== "default" && !Object.prototype.hasOwnProperty.call(i, s) && t(i, n, s);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), r(Qn, e), r(vg, e), r(ME, e), r(Gu, e), r(NE, e), r(ei, e);
})(ly);
(function(e) {
  var t = rt && rt.__createBinding || (Object.create ? function(a, u, c, l) {
    l === void 0 && (l = c), Object.defineProperty(a, l, { enumerable: !0, get: function() {
      return u[c];
    } });
  } : function(a, u, c, l) {
    l === void 0 && (l = c), a[l] = u[c];
  }), r = rt && rt.__setModuleDefault || (Object.create ? function(a, u) {
    Object.defineProperty(a, "default", { enumerable: !0, value: u });
  } : function(a, u) {
    a.default = u;
  }), n = rt && rt.__importStar || function(a) {
    if (a && a.__esModule)
      return a;
    var u = {};
    if (a != null)
      for (var c in a)
        c !== "default" && Object.prototype.hasOwnProperty.call(a, c) && t(u, a, c);
    return r(u, a), u;
  }, i = rt && rt.__exportStar || function(a, u) {
    for (var c in a)
      c !== "default" && !Object.prototype.hasOwnProperty.call(u, c) && t(u, a, c);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.z = void 0;
  const s = n(ly);
  e.z = s, i(ly, e), e.default = s;
})(TE);
Object.defineProperty(Xs, "__esModule", { value: !0 });
Xs.generateSchema = Xs.extendApi = void 0;
const nr = gg, Ol = TE;
function SM(e, t = {}) {
  return e.metaOpenApi = Object.assign(e.metaOpenApi || {}, t), e;
}
Xs.extendApi = SM;
function AM({ zodRef: e, useOutput: t, hideDefinitions: r }) {
  return Object.keys(e.shape).filter((i) => (r == null ? void 0 : r.includes(i)) === !1).reduce((i, s) => Object.assign(Object.assign({}, i), { [s]: Lr(e.shape[s], t) }), {});
}
function _1({ zodRef: e, schemas: t, useOutput: r }) {
  const n = Lr(e._def.schema, r);
  let i = "undefined";
  if (r && e._def.effect) {
    const s = e._def.effect.type === "transform" ? e._def.effect : null;
    if (s && "transform" in s)
      try {
        i = typeof s.transform(
          ["integer", "number"].includes(`${n.type}`) ? 0 : n.type === "string" ? "" : n.type === "boolean" ? !1 : n.type === "object" ? {} : n.type === "null" ? null : n.type === "array" ? [] : void 0,
          { addIssue: () => {
          }, path: [] }
          // TODO: Discover if context is necessary here
        );
      } catch {
      }
  }
  return (0, nr.default)(Object.assign(Object.assign(Object.assign({}, e.description ? { description: e.description } : {}), n), ["number", "string", "boolean", "null"].includes(i) ? {
    type: i
  } : {}), ...t);
}
function CM({ zodRef: e, schemas: t }) {
  const r = {
    type: "string"
  }, { checks: n = [] } = e._def;
  return n.forEach((i) => {
    switch (i.kind) {
      case "email":
        r.format = "email";
        break;
      case "uuid":
        r.format = "uuid";
        break;
      case "cuid":
        r.format = "cuid";
        break;
      case "url":
        r.format = "uri";
        break;
      case "datetime":
        r.format = "date-time";
        break;
      case "length":
        r.minLength = i.value, r.maxLength = i.value;
        break;
      case "max":
        r.maxLength = i.value;
        break;
      case "min":
        r.minLength = i.value;
        break;
      case "regex":
        r.pattern = i.regex.source;
        break;
    }
  }), (0, nr.default)(r, e.description ? { description: e.description } : {}, ...t);
}
function RM({ zodRef: e, schemas: t }) {
  const r = {
    type: "number"
  }, { checks: n = [] } = e._def;
  return n.forEach((i) => {
    switch (i.kind) {
      case "max":
        r.maximum = i.value, i.inclusive || (r.exclusiveMaximum = i.value);
        break;
      case "min":
        r.minimum = i.value, i.inclusive || (r.exclusiveMinimum = i.value);
        break;
      case "int":
        r.type = "integer";
        break;
      case "multipleOf":
        r.multipleOf = i.value;
    }
  }), (0, nr.default)(r, e.description ? { description: e.description } : {}, ...t);
}
function TM(e) {
  const t = [];
  for (const r of e)
    Array.isArray(r.hideDefinitions) && t.push(...r.hideDefinitions);
  return t;
}
function IM({ zodRef: e, schemas: t, useOutput: r, hideDefinitions: n }) {
  var i;
  let s;
  e._def.catchall instanceof Ol.z.ZodNever || ((i = e._def.catchall) === null || i === void 0 ? void 0 : i._def.typeName) === "ZodNever" ? e._def.unknownKeys === "passthrough" ? s = !0 : e._def.unknownKeys === "strict" && (s = !1) : s = Lr(e._def.catchall, r), s = s != null ? { additionalProperties: s } : {};
  const a = Object.keys(e.shape).filter((c) => {
    const l = e.shape[c];
    return !(l.isOptional() || l instanceof Ol.z.ZodDefault || l._def.typeName === "ZodDefault") && !(l instanceof Ol.z.ZodNever || l._def.typeName === "ZodDefault");
  }), u = a.length > 0 ? { required: a } : {};
  return (0, nr.default)(Object.assign(Object.assign(Object.assign({ type: "object", properties: AM({
    zodRef: e,
    schemas: t,
    useOutput: r,
    hideDefinitions: TM(t)
  }) }, u), s), n), e.description ? { description: e.description, hideDefinitions: n } : {}, ...t);
}
function jM({ zodRef: e, schemas: t, useOutput: r }) {
  return (0, nr.default)({
    type: "object",
    additionalProperties: e._def.valueType instanceof Ol.z.ZodUnknown ? {} : Lr(e._def.valueType, r)
  }, e.description ? { description: e.description } : {}, ...t);
}
function kM({ zodRef: e, schemas: t }) {
  return (0, nr.default)({ type: "integer", format: "int64" }, e.description ? { description: e.description } : {}, ...t);
}
function MM({ zodRef: e, schemas: t }) {
  return (0, nr.default)({ type: "boolean" }, e.description ? { description: e.description } : {}, ...t);
}
function NM({ zodRef: e, schemas: t }) {
  return (0, nr.default)({ type: "string", format: "date-time" }, e.description ? { description: e.description } : {}, ...t);
}
function DM({ zodRef: e, schemas: t }) {
  return (0, nr.default)({
    type: "string",
    format: "null",
    nullable: !0
  }, e.description ? { description: e.description } : {}, ...t);
}
function w1({ schemas: e, zodRef: t, useOutput: r }) {
  return (0, nr.default)(Lr(t.unwrap(), r), t.description ? { description: t.description } : {}, ...e);
}
function LM({ schemas: e, zodRef: t, useOutput: r }) {
  return (0, nr.default)(Object.assign({ default: t._def.defaultValue() }, Lr(t._def.innerType, r)), t.description ? { description: t.description } : {}, ...e);
}
function qM({ schemas: e, zodRef: t, useOutput: r }) {
  const n = {};
  return t._def.exactLength != null && (n.minItems = t._def.exactLength.value, n.maxItems = t._def.exactLength.value), t._def.minLength != null && (n.minItems = t._def.minLength.value), t._def.maxLength != null && (n.maxItems = t._def.maxLength.value), (0, nr.default)(Object.assign({ type: "array", items: Lr(t.element, r) }, n), t.description ? { description: t.description } : {}, ...e);
}
function FM({ schemas: e, zodRef: t }) {
  return (0, nr.default)({
    type: typeof t._def.value,
    enum: [t._def.value]
  }, t.description ? { description: t.description } : {}, ...e);
}
function $1({ schemas: e, zodRef: t }) {
  return (0, nr.default)({
    type: typeof Object.values(t._def.values)[0],
    enum: Object.values(t._def.values)
  }, t.description ? { description: t.description } : {}, ...e);
}
function UM({ schemas: e, zodRef: t, useOutput: r }) {
  return (0, nr.default)({
    allOf: [
      Lr(t._def.left, r),
      Lr(t._def.right, r)
    ]
  }, t.description ? { description: t.description } : {}, ...e);
}
function BM({ schemas: e, zodRef: t, useOutput: r }) {
  const n = t._def.options;
  if (n.reduce((i, s) => i && s._def.typeName === "ZodLiteral", !0)) {
    const i = n, s = i.reduce((a, u) => !a || a === typeof u._def.value ? typeof u._def.value : null, null);
    if (s)
      return (0, nr.default)({
        type: s,
        enum: i.map((a) => a._def.value)
      }, t.description ? { description: t.description } : {}, ...e);
  }
  return (0, nr.default)({
    oneOf: n.map((i) => Lr(i, r))
  }, t.description ? { description: t.description } : {}, ...e);
}
function VM({ schemas: e, zodRef: t, useOutput: r }) {
  return (0, nr.default)({
    discriminator: {
      propertyName: t._def.discriminator
    },
    oneOf: Array.from(t._def.options.values()).map((n) => Lr(n, r))
  }, t.description ? { description: t.description } : {}, ...e);
}
function ZM({ zodRef: e, schemas: t }) {
  return (0, nr.default)({ readOnly: !0 }, e.description ? { description: e.description } : {}, ...t);
}
function zM({ schemas: e, zodRef: t }) {
  return (0, nr.default)(Lr(t._def.type), ...e);
}
function Sn({ zodRef: e, schemas: t }) {
  return (0, nr.default)(e.description ? { description: e.description } : {}, ...t);
}
function WM({ zodRef: e, useOutput: t }) {
  return Lr(t ? e._def.out : e._def.in, t);
}
const E1 = {
  ZodObject: IM,
  ZodRecord: jM,
  ZodString: CM,
  ZodNumber: RM,
  ZodBigInt: kM,
  ZodBoolean: MM,
  ZodDate: NM,
  ZodNull: DM,
  ZodOptional: w1,
  ZodNullable: w1,
  ZodDefault: LM,
  ZodArray: qM,
  ZodLiteral: FM,
  ZodEnum: $1,
  ZodNativeEnum: $1,
  ZodTransformer: _1,
  ZodEffects: _1,
  ZodIntersection: UM,
  ZodUnion: BM,
  ZodDiscriminatedUnion: VM,
  ZodNever: ZM,
  ZodBranded: zM,
  // TODO Transform the rest to schemas
  ZodUndefined: Sn,
  // TODO: `prefixItems` is allowed in OpenAPI 3.1 which can be used to create tuples
  ZodTuple: Sn,
  ZodMap: Sn,
  ZodFunction: Sn,
  ZodLazy: Sn,
  ZodPromise: Sn,
  ZodAny: Sn,
  ZodUnknown: Sn,
  ZodVoid: Sn,
  ZodPipeline: WM
};
function Lr(e, t) {
  const { metaOpenApi: r = {} } = e, n = [
    e.isNullable && e.isNullable() ? { nullable: !0 } : {},
    ...Array.isArray(r) ? r : [r]
  ];
  try {
    const i = e._def.typeName;
    return i in E1 ? E1[i]({
      zodRef: e,
      schemas: n,
      useOutput: t
    }) : Sn({ zodRef: e, schemas: n });
  } catch (i) {
    return console.error(i), Sn({ zodRef: e, schemas: n });
  }
}
Xs.generateSchema = Lr;
var Uf = {};
Object.defineProperty(Uf, "__esModule", { value: !0 });
Uf.extendZodWithOpenApi = void 0;
const HM = Xs;
function GM(e, t = !1) {
  !t && typeof e.ZodSchema.prototype.openapi < "u" || (e.ZodSchema.prototype.openapi = function(r) {
    return (0, HM.extendApi)(this, r);
  });
}
Uf.extendZodWithOpenApi = GM;
(function(e) {
  var t = rt && rt.__createBinding || (Object.create ? function(n, i, s, a) {
    a === void 0 && (a = s);
    var u = Object.getOwnPropertyDescriptor(i, s);
    (!u || ("get" in u ? !i.__esModule : u.writable || u.configurable)) && (u = { enumerable: !0, get: function() {
      return i[s];
    } }), Object.defineProperty(n, a, u);
  } : function(n, i, s, a) {
    a === void 0 && (a = s), n[a] = i[s];
  }), r = rt && rt.__exportStar || function(n, i) {
    for (var s in n)
      s !== "default" && !Object.prototype.hasOwnProperty.call(i, s) && t(i, n, s);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), r(Xs, e), r(Uf, e);
})(RE);
const KM = !1, YM = /\r?\n/, JM = /\bono[ @]/;
function XM(e) {
  return !!(e && e.configurable && typeof e.get == "function");
}
function QM(e) {
  return !!// If there is no stack property, then it's writable, since assigning it will create it
  (!e || e.writable || typeof e.set == "function");
}
function LE(e, t) {
  let r = qE(e.stack), n = t ? t.stack : void 0;
  return r && n ? r + `

` + n : r || n;
}
function eN(e, t, r) {
  r ? Object.defineProperty(t, "stack", {
    get: () => {
      let n = e.get.apply(t);
      return LE({ stack: n }, r);
    },
    enumerable: !1,
    configurable: !0
  }) : tN(t, e);
}
function qE(e) {
  if (e) {
    let t = e.split(YM), r;
    for (let n = 0; n < t.length; n++) {
      let i = t[n];
      if (JM.test(i))
        r === void 0 && (r = n);
      else if (r !== void 0) {
        t.splice(r, n - r);
        break;
      }
    }
    if (t.length > 0)
      return t.join(`
`);
  }
  return e;
}
function tN(e, t) {
  Object.defineProperty(e, "stack", {
    get: () => qE(t.get.apply(e)),
    enumerable: !1,
    configurable: !0
  });
}
const rN = ["function", "symbol", "undefined"], nN = ["constructor", "prototype", "__proto__"], iN = Object.getPrototypeOf({});
function FE() {
  let e = {}, t = this;
  for (let r of UE(t))
    if (typeof r == "string") {
      let n = t[r], i = typeof n;
      rN.includes(i) || (e[r] = n);
    }
  return e;
}
function UE(e, t = []) {
  let r = [];
  for (; e && e !== iN; )
    r = r.concat(Object.getOwnPropertyNames(e), Object.getOwnPropertySymbols(e)), e = Object.getPrototypeOf(e);
  let n = new Set(r);
  for (let i of t.concat(nN))
    n.delete(i);
  return n;
}
const sN = ["name", "message", "stack"];
function Pl(e, t, r) {
  let n = e;
  return aN(n, t), t && typeof t == "object" && oN(n, t), n.toJSON = FE, r && typeof r == "object" && Object.assign(n, r), n;
}
function aN(e, t) {
  let r = Object.getOwnPropertyDescriptor(e, "stack");
  XM(r) ? eN(r, e, t) : QM(r) && (e.stack = LE(e, t));
}
function oN(e, t) {
  let r = UE(t, sN), n = e, i = t;
  for (let s of r)
    if (n[s] === void 0)
      try {
        n[s] = i[s];
      } catch {
      }
}
function uN(e) {
  return e = e || {}, {
    concatMessages: e.concatMessages === void 0 ? !0 : !!e.concatMessages,
    format: e.format === void 0 ? KM : typeof e.format == "function" ? e.format : !1
  };
}
function cN(e, t) {
  let r, n, i, s = "";
  return typeof e[0] == "string" ? i = e : typeof e[1] == "string" ? (e[0] instanceof Error ? r = e[0] : n = e[0], i = e.slice(1)) : (r = e[0], n = e[1], i = e.slice(2)), i.length > 0 && (t.format ? s = t.format.apply(void 0, i) : s = i.join(" ")), t.concatMessages && r && r.message && (s += (s ? ` 
` : "") + r.message), { originalError: r, props: n, message: s };
}
const ys = bg;
function bg(e, t) {
  t = uN(t);
  function r(...n) {
    let { originalError: i, props: s, message: a } = cN(n, t), u = new e(a);
    return Pl(u, i, s);
  }
  return r[Symbol.species] = e, r;
}
bg.toJSON = function(t) {
  return FE.call(t);
};
bg.extend = function(t, r, n) {
  return n || r instanceof Error ? Pl(t, r, n) : r ? Pl(t, void 0, r) : Pl(t);
};
const x1 = si;
si.error = new ys(Error);
si.eval = new ys(EvalError);
si.range = new ys(RangeError);
si.reference = new ys(ReferenceError);
si.syntax = new ys(SyntaxError);
si.type = new ys(TypeError);
si.uri = new ys(URIError);
const lN = si;
function si(...e) {
  let t = e[0];
  if (typeof t == "object" && typeof t.name == "string") {
    for (let r of Object.values(lN))
      if (typeof r == "function" && r.name === "ono") {
        let n = r[Symbol.species];
        if (n && n !== Error && (t instanceof n || t.name === n.name))
          return r.apply(void 0, e);
      }
  }
  return si.error.apply(void 0, e);
}
var Ku = {}, BE = {}, VE = function() {
  if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
    return !1;
  if (typeof Symbol.iterator == "symbol")
    return !0;
  var t = {}, r = Symbol("test"), n = Object(r);
  if (typeof r == "string" || Object.prototype.toString.call(r) !== "[object Symbol]" || Object.prototype.toString.call(n) !== "[object Symbol]")
    return !1;
  var i = 42;
  t[r] = i;
  for (r in t)
    return !1;
  if (typeof Object.keys == "function" && Object.keys(t).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(t).length !== 0)
    return !1;
  var s = Object.getOwnPropertySymbols(t);
  if (s.length !== 1 || s[0] !== r || !Object.prototype.propertyIsEnumerable.call(t, r))
    return !1;
  if (typeof Object.getOwnPropertyDescriptor == "function") {
    var a = Object.getOwnPropertyDescriptor(t, r);
    if (a.value !== i || a.enumerable !== !0)
      return !1;
  }
  return !0;
}, fN = VE, _g = function() {
  return fN() && !!Symbol.toStringTag;
}, O1 = typeof Symbol < "u" && Symbol, dN = VE, pN = function() {
  return typeof O1 != "function" || typeof Symbol != "function" || typeof O1("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : dN();
}, P1 = {
  foo: {}
}, hN = Object, mN = function() {
  return { __proto__: P1 }.foo === P1.foo && !({ __proto__: null } instanceof hN);
}, yN = "Function.prototype.bind called on incompatible ", Cp = Array.prototype.slice, gN = Object.prototype.toString, vN = "[object Function]", bN = function(t) {
  var r = this;
  if (typeof r != "function" || gN.call(r) !== vN)
    throw new TypeError(yN + r);
  for (var n = Cp.call(arguments, 1), i, s = function() {
    if (this instanceof i) {
      var d = r.apply(
        this,
        n.concat(Cp.call(arguments))
      );
      return Object(d) === d ? d : this;
    } else
      return r.apply(
        t,
        n.concat(Cp.call(arguments))
      );
  }, a = Math.max(0, r.length - n.length), u = [], c = 0; c < a; c++)
    u.push("$" + c);
  if (i = Function("binder", "return function (" + u.join(",") + "){ return binder.apply(this,arguments); }")(s), r.prototype) {
    var l = function() {
    };
    l.prototype = r.prototype, i.prototype = new l(), l.prototype = null;
  }
  return i;
}, _N = bN, wg = Function.prototype.bind || _N, wN = wg, $N = wN.call(Function.call, Object.prototype.hasOwnProperty), Ct, no = SyntaxError, ZE = Function, Ka = TypeError, Rp = function(e) {
  try {
    return ZE('"use strict"; return (' + e + ").constructor;")();
  } catch {
  }
}, Ws = Object.getOwnPropertyDescriptor;
if (Ws)
  try {
    Ws({}, "");
  } catch {
    Ws = null;
  }
var Tp = function() {
  throw new Ka();
}, EN = Ws ? function() {
  try {
    return arguments.callee, Tp;
  } catch {
    try {
      return Ws(arguments, "callee").get;
    } catch {
      return Tp;
    }
  }
}() : Tp, Sa = pN(), xN = mN(), pr = Object.getPrototypeOf || (xN ? function(e) {
  return e.__proto__;
} : null), Da = {}, ON = typeof Uint8Array > "u" || !pr ? Ct : pr(Uint8Array), Hs = {
  "%AggregateError%": typeof AggregateError > "u" ? Ct : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer > "u" ? Ct : ArrayBuffer,
  "%ArrayIteratorPrototype%": Sa && pr ? pr([][Symbol.iterator]()) : Ct,
  "%AsyncFromSyncIteratorPrototype%": Ct,
  "%AsyncFunction%": Da,
  "%AsyncGenerator%": Da,
  "%AsyncGeneratorFunction%": Da,
  "%AsyncIteratorPrototype%": Da,
  "%Atomics%": typeof Atomics > "u" ? Ct : Atomics,
  "%BigInt%": typeof BigInt > "u" ? Ct : BigInt,
  "%BigInt64Array%": typeof BigInt64Array > "u" ? Ct : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array > "u" ? Ct : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView > "u" ? Ct : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": Error,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": EvalError,
  "%Float32Array%": typeof Float32Array > "u" ? Ct : Float32Array,
  "%Float64Array%": typeof Float64Array > "u" ? Ct : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? Ct : FinalizationRegistry,
  "%Function%": ZE,
  "%GeneratorFunction%": Da,
  "%Int8Array%": typeof Int8Array > "u" ? Ct : Int8Array,
  "%Int16Array%": typeof Int16Array > "u" ? Ct : Int16Array,
  "%Int32Array%": typeof Int32Array > "u" ? Ct : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": Sa && pr ? pr(pr([][Symbol.iterator]())) : Ct,
  "%JSON%": typeof JSON == "object" ? JSON : Ct,
  "%Map%": typeof Map > "u" ? Ct : Map,
  "%MapIteratorPrototype%": typeof Map > "u" || !Sa || !pr ? Ct : pr((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise > "u" ? Ct : Promise,
  "%Proxy%": typeof Proxy > "u" ? Ct : Proxy,
  "%RangeError%": RangeError,
  "%ReferenceError%": ReferenceError,
  "%Reflect%": typeof Reflect > "u" ? Ct : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set > "u" ? Ct : Set,
  "%SetIteratorPrototype%": typeof Set > "u" || !Sa || !pr ? Ct : pr((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? Ct : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": Sa && pr ? pr(""[Symbol.iterator]()) : Ct,
  "%Symbol%": Sa ? Symbol : Ct,
  "%SyntaxError%": no,
  "%ThrowTypeError%": EN,
  "%TypedArray%": ON,
  "%TypeError%": Ka,
  "%Uint8Array%": typeof Uint8Array > "u" ? Ct : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? Ct : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array > "u" ? Ct : Uint16Array,
  "%Uint32Array%": typeof Uint32Array > "u" ? Ct : Uint32Array,
  "%URIError%": URIError,
  "%WeakMap%": typeof WeakMap > "u" ? Ct : WeakMap,
  "%WeakRef%": typeof WeakRef > "u" ? Ct : WeakRef,
  "%WeakSet%": typeof WeakSet > "u" ? Ct : WeakSet
};
if (pr)
  try {
    null.error;
  } catch (e) {
    var PN = pr(pr(e));
    Hs["%Error.prototype%"] = PN;
  }
var SN = function e(t) {
  var r;
  if (t === "%AsyncFunction%")
    r = Rp("async function () {}");
  else if (t === "%GeneratorFunction%")
    r = Rp("function* () {}");
  else if (t === "%AsyncGeneratorFunction%")
    r = Rp("async function* () {}");
  else if (t === "%AsyncGenerator%") {
    var n = e("%AsyncGeneratorFunction%");
    n && (r = n.prototype);
  } else if (t === "%AsyncIteratorPrototype%") {
    var i = e("%AsyncGenerator%");
    i && pr && (r = pr(i.prototype));
  }
  return Hs[t] = r, r;
}, S1 = {
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
}, Yu = wg, nf = $N, AN = Yu.call(Function.call, Array.prototype.concat), CN = Yu.call(Function.apply, Array.prototype.splice), A1 = Yu.call(Function.call, String.prototype.replace), sf = Yu.call(Function.call, String.prototype.slice), RN = Yu.call(Function.call, RegExp.prototype.exec), TN = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, IN = /\\(\\)?/g, jN = function(t) {
  var r = sf(t, 0, 1), n = sf(t, -1);
  if (r === "%" && n !== "%")
    throw new no("invalid intrinsic syntax, expected closing `%`");
  if (n === "%" && r !== "%")
    throw new no("invalid intrinsic syntax, expected opening `%`");
  var i = [];
  return A1(t, TN, function(s, a, u, c) {
    i[i.length] = u ? A1(c, IN, "$1") : a || s;
  }), i;
}, kN = function(t, r) {
  var n = t, i;
  if (nf(S1, n) && (i = S1[n], n = "%" + i[0] + "%"), nf(Hs, n)) {
    var s = Hs[n];
    if (s === Da && (s = SN(n)), typeof s > "u" && !r)
      throw new Ka("intrinsic " + t + " exists, but is not available. Please file an issue!");
    return {
      alias: i,
      name: n,
      value: s
    };
  }
  throw new no("intrinsic " + t + " does not exist!");
}, $g = function(t, r) {
  if (typeof t != "string" || t.length === 0)
    throw new Ka("intrinsic name must be a non-empty string");
  if (arguments.length > 1 && typeof r != "boolean")
    throw new Ka('"allowMissing" argument must be a boolean');
  if (RN(/^%?[^%]*%?$/, t) === null)
    throw new no("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  var n = jN(t), i = n.length > 0 ? n[0] : "", s = kN("%" + i + "%", r), a = s.name, u = s.value, c = !1, l = s.alias;
  l && (i = l[0], CN(n, AN([0, 1], l)));
  for (var d = 1, p = !0; d < n.length; d += 1) {
    var h = n[d], v = sf(h, 0, 1), y = sf(h, -1);
    if ((v === '"' || v === "'" || v === "`" || y === '"' || y === "'" || y === "`") && v !== y)
      throw new no("property names with quotes must have matching quotes");
    if ((h === "constructor" || !p) && (c = !0), i += "." + h, a = "%" + i + "%", nf(Hs, a))
      u = Hs[a];
    else if (u != null) {
      if (!(h in u)) {
        if (!r)
          throw new Ka("base intrinsic for " + t + " exists, but the property is not available.");
        return;
      }
      if (Ws && d + 1 >= n.length) {
        var g = Ws(u, h);
        p = !!g, p && "get" in g && !("originalValue" in g.get) ? u = g.get : u = u[h];
      } else
        p = nf(u, h), u = u[h];
      p && !c && (Hs[a] = u);
    }
  }
  return u;
}, zE = { exports: {} };
(function(e) {
  var t = wg, r = $g, n = r("%Function.prototype.apply%"), i = r("%Function.prototype.call%"), s = r("%Reflect.apply%", !0) || t.call(i, n), a = r("%Object.getOwnPropertyDescriptor%", !0), u = r("%Object.defineProperty%", !0), c = r("%Math.max%");
  if (u)
    try {
      u({}, "a", { value: 1 });
    } catch {
      u = null;
    }
  e.exports = function(p) {
    var h = s(t, i, arguments);
    if (a && u) {
      var v = a(h, "length");
      v.configurable && u(
        h,
        "length",
        { value: 1 + c(0, p.length - (arguments.length - 1)) }
      );
    }
    return h;
  };
  var l = function() {
    return s(t, n, arguments);
  };
  u ? u(e.exports, "apply", { value: l }) : e.exports.apply = l;
})(zE);
var WE = zE.exports, HE = $g, GE = WE, MN = GE(HE("String.prototype.indexOf")), KE = function(t, r) {
  var n = HE(t, !!r);
  return typeof n == "function" && MN(t, ".prototype.") > -1 ? GE(n) : n;
}, NN = _g(), DN = KE, dy = DN("Object.prototype.toString"), Bf = function(t) {
  return NN && t && typeof t == "object" && Symbol.toStringTag in t ? !1 : dy(t) === "[object Arguments]";
}, YE = function(t) {
  return Bf(t) ? !0 : t !== null && typeof t == "object" && typeof t.length == "number" && t.length >= 0 && dy(t) !== "[object Array]" && dy(t.callee) === "[object Function]";
}, LN = function() {
  return Bf(arguments);
}();
Bf.isLegacyArguments = YE;
var qN = LN ? Bf : YE, FN = Object.prototype.toString, UN = Function.prototype.toString, BN = /^\s*(?:function)?\*/, JE = _g(), Ip = Object.getPrototypeOf, VN = function() {
  if (!JE)
    return !1;
  try {
    return Function("return function*() {}")();
  } catch {
  }
}, jp, ZN = function(t) {
  if (typeof t != "function")
    return !1;
  if (BN.test(UN.call(t)))
    return !0;
  if (!JE) {
    var r = FN.call(t);
    return r === "[object GeneratorFunction]";
  }
  if (!Ip)
    return !1;
  if (typeof jp > "u") {
    var n = VN();
    jp = n ? Ip(n) : !1;
  }
  return Ip(t) === jp;
}, XE = Function.prototype.toString, Ua = typeof Reflect == "object" && Reflect !== null && Reflect.apply, py, Sl;
if (typeof Ua == "function" && typeof Object.defineProperty == "function")
  try {
    py = Object.defineProperty({}, "length", {
      get: function() {
        throw Sl;
      }
    }), Sl = {}, Ua(function() {
      throw 42;
    }, null, py);
  } catch (e) {
    e !== Sl && (Ua = null);
  }
else
  Ua = null;
var zN = /^\s*class\b/, hy = function(t) {
  try {
    var r = XE.call(t);
    return zN.test(r);
  } catch {
    return !1;
  }
}, kp = function(t) {
  try {
    return hy(t) ? !1 : (XE.call(t), !0);
  } catch {
    return !1;
  }
}, Al = Object.prototype.toString, WN = "[object Object]", HN = "[object Function]", GN = "[object GeneratorFunction]", KN = "[object HTMLAllCollection]", YN = "[object HTML document.all class]", JN = "[object HTMLCollection]", XN = typeof Symbol == "function" && !!Symbol.toStringTag, QN = !(0 in [,]), my = function() {
  return !1;
};
if (typeof document == "object") {
  var e5 = document.all;
  Al.call(e5) === Al.call(document.all) && (my = function(t) {
    if ((QN || !t) && (typeof t > "u" || typeof t == "object"))
      try {
        var r = Al.call(t);
        return (r === KN || r === YN || r === JN || r === WN) && t("") == null;
      } catch {
      }
    return !1;
  });
}
var t5 = Ua ? function(t) {
  if (my(t))
    return !0;
  if (!t || typeof t != "function" && typeof t != "object")
    return !1;
  try {
    Ua(t, null, py);
  } catch (r) {
    if (r !== Sl)
      return !1;
  }
  return !hy(t) && kp(t);
} : function(t) {
  if (my(t))
    return !0;
  if (!t || typeof t != "function" && typeof t != "object")
    return !1;
  if (XN)
    return kp(t);
  if (hy(t))
    return !1;
  var r = Al.call(t);
  return r !== HN && r !== GN && !/^\[object HTML/.test(r) ? !1 : kp(t);
}, r5 = t5, n5 = Object.prototype.toString, QE = Object.prototype.hasOwnProperty, i5 = function(t, r, n) {
  for (var i = 0, s = t.length; i < s; i++)
    QE.call(t, i) && (n == null ? r(t[i], i, t) : r.call(n, t[i], i, t));
}, s5 = function(t, r, n) {
  for (var i = 0, s = t.length; i < s; i++)
    n == null ? r(t.charAt(i), i, t) : r.call(n, t.charAt(i), i, t);
}, a5 = function(t, r, n) {
  for (var i in t)
    QE.call(t, i) && (n == null ? r(t[i], i, t) : r.call(n, t[i], i, t));
}, o5 = function(t, r, n) {
  if (!r5(r))
    throw new TypeError("iterator must be a function");
  var i;
  arguments.length >= 3 && (i = n), n5.call(t) === "[object Array]" ? i5(t, r, i) : typeof t == "string" ? s5(t, r, i) : a5(t, r, i);
}, u5 = o5, Mp = [
  "BigInt64Array",
  "BigUint64Array",
  "Float32Array",
  "Float64Array",
  "Int16Array",
  "Int32Array",
  "Int8Array",
  "Uint16Array",
  "Uint32Array",
  "Uint8Array",
  "Uint8ClampedArray"
], c5 = typeof globalThis > "u" ? rt : globalThis, l5 = function() {
  for (var t = [], r = 0; r < Mp.length; r++)
    typeof c5[Mp[r]] == "function" && (t[t.length] = Mp[r]);
  return t;
}, f5 = $g, Cl = f5("%Object.getOwnPropertyDescriptor%", !0);
if (Cl)
  try {
    Cl([], "length");
  } catch {
    Cl = null;
  }
var d5 = Cl, af = u5, p5 = l5, C1 = WE, Eg = KE, Rl = d5, h5 = Eg("Object.prototype.toString"), ex = _g(), R1 = typeof globalThis > "u" ? rt : globalThis, yy = p5(), xg = Eg("String.prototype.slice"), Np = Object.getPrototypeOf, m5 = Eg("Array.prototype.indexOf", !0) || function(t, r) {
  for (var n = 0; n < t.length; n += 1)
    if (t[n] === r)
      return n;
  return -1;
}, of = { __proto__: null };
ex && Rl && Np ? af(yy, function(e) {
  var t = new R1[e]();
  if (Symbol.toStringTag in t) {
    var r = Np(t), n = Rl(r, Symbol.toStringTag);
    if (!n) {
      var i = Np(r);
      n = Rl(i, Symbol.toStringTag);
    }
    of["$" + e] = C1(n.get);
  }
}) : af(yy, function(e) {
  var t = new R1[e]();
  of["$" + e] = C1(t.slice);
});
var y5 = function(t) {
  var r = !1;
  return af(of, function(n, i) {
    if (!r)
      try {
        "$" + n(t) === i && (r = xg(i, 1));
      } catch {
      }
  }), r;
}, g5 = function(t) {
  var r = !1;
  return af(of, function(n, i) {
    if (!r)
      try {
        n(t), r = xg(i, 1);
      } catch {
      }
  }), r;
}, tx = function(t) {
  if (!t || typeof t != "object")
    return !1;
  if (!ex) {
    var r = xg(h5(t), 8, -1);
    return m5(yy, r) > -1 ? r : r !== "Object" ? !1 : g5(t);
  }
  return Rl ? y5(t) : null;
}, v5 = tx, b5 = function(t) {
  return !!v5(t);
};
(function(e) {
  var t = qN, r = ZN, n = tx, i = b5;
  function s(Ee) {
    return Ee.call.bind(Ee);
  }
  var a = typeof BigInt < "u", u = typeof Symbol < "u", c = s(Object.prototype.toString), l = s(Number.prototype.valueOf), d = s(String.prototype.valueOf), p = s(Boolean.prototype.valueOf);
  if (a)
    var h = s(BigInt.prototype.valueOf);
  if (u)
    var v = s(Symbol.prototype.valueOf);
  function y(Ee, Mt) {
    if (typeof Ee != "object")
      return !1;
    try {
      return Mt(Ee), !0;
    } catch {
      return !1;
    }
  }
  e.isArgumentsObject = t, e.isGeneratorFunction = r, e.isTypedArray = i;
  function g(Ee) {
    return typeof Promise < "u" && Ee instanceof Promise || Ee !== null && typeof Ee == "object" && typeof Ee.then == "function" && typeof Ee.catch == "function";
  }
  e.isPromise = g;
  function _(Ee) {
    return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(Ee) : i(Ee) || z(Ee);
  }
  e.isArrayBufferView = _;
  function m(Ee) {
    return n(Ee) === "Uint8Array";
  }
  e.isUint8Array = m;
  function w(Ee) {
    return n(Ee) === "Uint8ClampedArray";
  }
  e.isUint8ClampedArray = w;
  function $(Ee) {
    return n(Ee) === "Uint16Array";
  }
  e.isUint16Array = $;
  function E(Ee) {
    return n(Ee) === "Uint32Array";
  }
  e.isUint32Array = E;
  function A(Ee) {
    return n(Ee) === "Int8Array";
  }
  e.isInt8Array = A;
  function R(Ee) {
    return n(Ee) === "Int16Array";
  }
  e.isInt16Array = R;
  function I(Ee) {
    return n(Ee) === "Int32Array";
  }
  e.isInt32Array = I;
  function D(Ee) {
    return n(Ee) === "Float32Array";
  }
  e.isFloat32Array = D;
  function J(Ee) {
    return n(Ee) === "Float64Array";
  }
  e.isFloat64Array = J;
  function ae(Ee) {
    return n(Ee) === "BigInt64Array";
  }
  e.isBigInt64Array = ae;
  function ye(Ee) {
    return n(Ee) === "BigUint64Array";
  }
  e.isBigUint64Array = ye;
  function xe(Ee) {
    return c(Ee) === "[object Map]";
  }
  xe.working = typeof Map < "u" && xe(/* @__PURE__ */ new Map());
  function je(Ee) {
    return typeof Map > "u" ? !1 : xe.working ? xe(Ee) : Ee instanceof Map;
  }
  e.isMap = je;
  function re(Ee) {
    return c(Ee) === "[object Set]";
  }
  re.working = typeof Set < "u" && re(/* @__PURE__ */ new Set());
  function fe(Ee) {
    return typeof Set > "u" ? !1 : re.working ? re(Ee) : Ee instanceof Set;
  }
  e.isSet = fe;
  function le(Ee) {
    return c(Ee) === "[object WeakMap]";
  }
  le.working = typeof WeakMap < "u" && le(/* @__PURE__ */ new WeakMap());
  function $e(Ee) {
    return typeof WeakMap > "u" ? !1 : le.working ? le(Ee) : Ee instanceof WeakMap;
  }
  e.isWeakMap = $e;
  function Ae(Ee) {
    return c(Ee) === "[object WeakSet]";
  }
  Ae.working = typeof WeakSet < "u" && Ae(/* @__PURE__ */ new WeakSet());
  function _e(Ee) {
    return Ae(Ee);
  }
  e.isWeakSet = _e;
  function ie(Ee) {
    return c(Ee) === "[object ArrayBuffer]";
  }
  ie.working = typeof ArrayBuffer < "u" && ie(new ArrayBuffer());
  function K(Ee) {
    return typeof ArrayBuffer > "u" ? !1 : ie.working ? ie(Ee) : Ee instanceof ArrayBuffer;
  }
  e.isArrayBuffer = K;
  function V(Ee) {
    return c(Ee) === "[object DataView]";
  }
  V.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && V(new DataView(new ArrayBuffer(1), 0, 1));
  function z(Ee) {
    return typeof DataView > "u" ? !1 : V.working ? V(Ee) : Ee instanceof DataView;
  }
  e.isDataView = z;
  var C = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
  function q(Ee) {
    return c(Ee) === "[object SharedArrayBuffer]";
  }
  function N(Ee) {
    return typeof C > "u" ? !1 : (typeof q.working > "u" && (q.working = q(new C())), q.working ? q(Ee) : Ee instanceof C);
  }
  e.isSharedArrayBuffer = N;
  function F(Ee) {
    return c(Ee) === "[object AsyncFunction]";
  }
  e.isAsyncFunction = F;
  function T(Ee) {
    return c(Ee) === "[object Map Iterator]";
  }
  e.isMapIterator = T;
  function Z(Ee) {
    return c(Ee) === "[object Set Iterator]";
  }
  e.isSetIterator = Z;
  function Y(Ee) {
    return c(Ee) === "[object Generator]";
  }
  e.isGeneratorObject = Y;
  function k(Ee) {
    return c(Ee) === "[object WebAssembly.Module]";
  }
  e.isWebAssemblyCompiledModule = k;
  function U(Ee) {
    return y(Ee, l);
  }
  e.isNumberObject = U;
  function pe(Ee) {
    return y(Ee, d);
  }
  e.isStringObject = pe;
  function we(Ee) {
    return y(Ee, p);
  }
  e.isBooleanObject = we;
  function He(Ee) {
    return a && y(Ee, h);
  }
  e.isBigIntObject = He;
  function Fe(Ee) {
    return u && y(Ee, v);
  }
  e.isSymbolObject = Fe;
  function Ge(Ee) {
    return U(Ee) || pe(Ee) || we(Ee) || He(Ee) || Fe(Ee);
  }
  e.isBoxedPrimitive = Ge;
  function jt(Ee) {
    return typeof Uint8Array < "u" && (K(Ee) || N(Ee));
  }
  e.isAnyArrayBuffer = jt, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(Ee) {
    Object.defineProperty(e, Ee, {
      enumerable: !1,
      value: function() {
        throw new Error(Ee + " is not supported in userland");
      }
    });
  });
})(BE);
var _5 = function(t) {
  return t && typeof t == "object" && typeof t.copy == "function" && typeof t.fill == "function" && typeof t.readUInt8 == "function";
}, gy = { exports: {} };
typeof Object.create == "function" ? gy.exports = function(t, r) {
  r && (t.super_ = r, t.prototype = Object.create(r.prototype, {
    constructor: {
      value: t,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }));
} : gy.exports = function(t, r) {
  if (r) {
    t.super_ = r;
    var n = function() {
    };
    n.prototype = r.prototype, t.prototype = new n(), t.prototype.constructor = t;
  }
};
var gs = gy.exports;
(function(e) {
  var t = Object.getOwnPropertyDescriptors || function(z) {
    for (var C = Object.keys(z), q = {}, N = 0; N < C.length; N++)
      q[C[N]] = Object.getOwnPropertyDescriptor(z, C[N]);
    return q;
  }, r = /%[sdj%]/g;
  e.format = function(V) {
    if (!A(V)) {
      for (var z = [], C = 0; C < arguments.length; C++)
        z.push(a(arguments[C]));
      return z.join(" ");
    }
    for (var C = 1, q = arguments, N = q.length, F = String(V).replace(r, function(Z) {
      if (Z === "%%")
        return "%";
      if (C >= N)
        return Z;
      switch (Z) {
        case "%s":
          return String(q[C++]);
        case "%d":
          return Number(q[C++]);
        case "%j":
          try {
            return JSON.stringify(q[C++]);
          } catch {
            return "[Circular]";
          }
        default:
          return Z;
      }
    }), T = q[C]; C < N; T = q[++C])
      w(T) || !J(T) ? F += " " + T : F += " " + a(T);
    return F;
  }, e.deprecate = function(V, z) {
    if (typeof Me.process < "u" && Me.process.noDeprecation === !0)
      return V;
    if (typeof Me.process > "u")
      return function() {
        return e.deprecate(V, z).apply(this, arguments);
      };
    var C = !1;
    function q() {
      if (!C) {
        if (Me.process.throwDeprecation)
          throw new Error(z);
        Me.process.traceDeprecation ? console.trace(z) : console.error(z), C = !0;
      }
      return V.apply(this, arguments);
    }
    return q;
  };
  var n = {}, i = /^$/;
  if (Me.process.env.NODE_DEBUG) {
    var s = Me.process.env.NODE_DEBUG;
    s = s.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), i = new RegExp("^" + s + "$", "i");
  }
  e.debuglog = function(V) {
    if (V = V.toUpperCase(), !n[V])
      if (i.test(V)) {
        var z = Me.process.pid;
        n[V] = function() {
          var C = e.format.apply(e, arguments);
          console.error("%s %d: %s", V, z, C);
        };
      } else
        n[V] = function() {
        };
    return n[V];
  };
  function a(V, z) {
    var C = {
      seen: [],
      stylize: c
    };
    return arguments.length >= 3 && (C.depth = arguments[2]), arguments.length >= 4 && (C.colors = arguments[3]), m(z) ? C.showHidden = z : z && e._extend(C, z), I(C.showHidden) && (C.showHidden = !1), I(C.depth) && (C.depth = 2), I(C.colors) && (C.colors = !1), I(C.customInspect) && (C.customInspect = !0), C.colors && (C.stylize = u), d(C, V, C.depth);
  }
  e.inspect = a, a.colors = {
    bold: [1, 22],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    white: [37, 39],
    grey: [90, 39],
    black: [30, 39],
    blue: [34, 39],
    cyan: [36, 39],
    green: [32, 39],
    magenta: [35, 39],
    red: [31, 39],
    yellow: [33, 39]
  }, a.styles = {
    special: "cyan",
    number: "yellow",
    boolean: "yellow",
    undefined: "grey",
    null: "bold",
    string: "green",
    date: "magenta",
    // "name": intentionally not styling
    regexp: "red"
  };
  function u(V, z) {
    var C = a.styles[z];
    return C ? "\x1B[" + a.colors[C][0] + "m" + V + "\x1B[" + a.colors[C][1] + "m" : V;
  }
  function c(V, z) {
    return V;
  }
  function l(V) {
    var z = {};
    return V.forEach(function(C, q) {
      z[C] = !0;
    }), z;
  }
  function d(V, z, C) {
    if (V.customInspect && z && xe(z.inspect) && // Filter out the util module, it's inspect function is special
    z.inspect !== e.inspect && // Also filter out any prototype objects using the circular check.
    !(z.constructor && z.constructor.prototype === z)) {
      var q = z.inspect(C, V);
      return A(q) || (q = d(V, q, C)), q;
    }
    var N = p(V, z);
    if (N)
      return N;
    var F = Object.keys(z), T = l(F);
    if (V.showHidden && (F = Object.getOwnPropertyNames(z)), ye(z) && (F.indexOf("message") >= 0 || F.indexOf("description") >= 0))
      return h(z);
    if (F.length === 0) {
      if (xe(z)) {
        var Z = z.name ? ": " + z.name : "";
        return V.stylize("[Function" + Z + "]", "special");
      }
      if (D(z))
        return V.stylize(RegExp.prototype.toString.call(z), "regexp");
      if (ae(z))
        return V.stylize(Date.prototype.toString.call(z), "date");
      if (ye(z))
        return h(z);
    }
    var Y = "", k = !1, U = ["{", "}"];
    if (_(z) && (k = !0, U = ["[", "]"]), xe(z)) {
      var pe = z.name ? ": " + z.name : "";
      Y = " [Function" + pe + "]";
    }
    if (D(z) && (Y = " " + RegExp.prototype.toString.call(z)), ae(z) && (Y = " " + Date.prototype.toUTCString.call(z)), ye(z) && (Y = " " + h(z)), F.length === 0 && (!k || z.length == 0))
      return U[0] + Y + U[1];
    if (C < 0)
      return D(z) ? V.stylize(RegExp.prototype.toString.call(z), "regexp") : V.stylize("[Object]", "special");
    V.seen.push(z);
    var we;
    return k ? we = v(V, z, C, T, F) : we = F.map(function(He) {
      return y(V, z, C, T, He, k);
    }), V.seen.pop(), g(we, Y, U);
  }
  function p(V, z) {
    if (I(z))
      return V.stylize("undefined", "undefined");
    if (A(z)) {
      var C = "'" + JSON.stringify(z).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return V.stylize(C, "string");
    }
    if (E(z))
      return V.stylize("" + z, "number");
    if (m(z))
      return V.stylize("" + z, "boolean");
    if (w(z))
      return V.stylize("null", "null");
  }
  function h(V) {
    return "[" + Error.prototype.toString.call(V) + "]";
  }
  function v(V, z, C, q, N) {
    for (var F = [], T = 0, Z = z.length; T < Z; ++T)
      Ae(z, String(T)) ? F.push(y(
        V,
        z,
        C,
        q,
        String(T),
        !0
      )) : F.push("");
    return N.forEach(function(Y) {
      Y.match(/^\d+$/) || F.push(y(
        V,
        z,
        C,
        q,
        Y,
        !0
      ));
    }), F;
  }
  function y(V, z, C, q, N, F) {
    var T, Z, Y;
    if (Y = Object.getOwnPropertyDescriptor(z, N) || { value: z[N] }, Y.get ? Y.set ? Z = V.stylize("[Getter/Setter]", "special") : Z = V.stylize("[Getter]", "special") : Y.set && (Z = V.stylize("[Setter]", "special")), Ae(q, N) || (T = "[" + N + "]"), Z || (V.seen.indexOf(Y.value) < 0 ? (w(C) ? Z = d(V, Y.value, null) : Z = d(V, Y.value, C - 1), Z.indexOf(`
`) > -1 && (F ? Z = Z.split(`
`).map(function(k) {
      return "  " + k;
    }).join(`
`).slice(2) : Z = `
` + Z.split(`
`).map(function(k) {
      return "   " + k;
    }).join(`
`))) : Z = V.stylize("[Circular]", "special")), I(T)) {
      if (F && N.match(/^\d+$/))
        return Z;
      T = JSON.stringify("" + N), T.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (T = T.slice(1, -1), T = V.stylize(T, "name")) : (T = T.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), T = V.stylize(T, "string"));
    }
    return T + ": " + Z;
  }
  function g(V, z, C) {
    var q = V.reduce(function(N, F) {
      return F.indexOf(`
`) >= 0, N + F.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    return q > 60 ? C[0] + (z === "" ? "" : z + `
 `) + " " + V.join(`,
  `) + " " + C[1] : C[0] + z + " " + V.join(", ") + " " + C[1];
  }
  e.types = BE;
  function _(V) {
    return Array.isArray(V);
  }
  e.isArray = _;
  function m(V) {
    return typeof V == "boolean";
  }
  e.isBoolean = m;
  function w(V) {
    return V === null;
  }
  e.isNull = w;
  function $(V) {
    return V == null;
  }
  e.isNullOrUndefined = $;
  function E(V) {
    return typeof V == "number";
  }
  e.isNumber = E;
  function A(V) {
    return typeof V == "string";
  }
  e.isString = A;
  function R(V) {
    return typeof V == "symbol";
  }
  e.isSymbol = R;
  function I(V) {
    return V === void 0;
  }
  e.isUndefined = I;
  function D(V) {
    return J(V) && re(V) === "[object RegExp]";
  }
  e.isRegExp = D, e.types.isRegExp = D;
  function J(V) {
    return typeof V == "object" && V !== null;
  }
  e.isObject = J;
  function ae(V) {
    return J(V) && re(V) === "[object Date]";
  }
  e.isDate = ae, e.types.isDate = ae;
  function ye(V) {
    return J(V) && (re(V) === "[object Error]" || V instanceof Error);
  }
  e.isError = ye, e.types.isNativeError = ye;
  function xe(V) {
    return typeof V == "function";
  }
  e.isFunction = xe;
  function je(V) {
    return V === null || typeof V == "boolean" || typeof V == "number" || typeof V == "string" || typeof V == "symbol" || // ES6 symbol
    typeof V > "u";
  }
  e.isPrimitive = je, e.isBuffer = _5;
  function re(V) {
    return Object.prototype.toString.call(V);
  }
  function fe(V) {
    return V < 10 ? "0" + V.toString(10) : V.toString(10);
  }
  var le = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ];
  function $e() {
    var V = /* @__PURE__ */ new Date(), z = [
      fe(V.getHours()),
      fe(V.getMinutes()),
      fe(V.getSeconds())
    ].join(":");
    return [V.getDate(), le[V.getMonth()], z].join(" ");
  }
  e.log = function() {
    console.log("%s - %s", $e(), e.format.apply(e, arguments));
  }, e.inherits = gs, e._extend = function(V, z) {
    if (!z || !J(z))
      return V;
    for (var C = Object.keys(z), q = C.length; q--; )
      V[C[q]] = z[C[q]];
    return V;
  };
  function Ae(V, z) {
    return Object.prototype.hasOwnProperty.call(V, z);
  }
  var _e = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
  e.promisify = function(z) {
    if (typeof z != "function")
      throw new TypeError('The "original" argument must be of type Function');
    if (_e && z[_e]) {
      var C = z[_e];
      if (typeof C != "function")
        throw new TypeError('The "util.promisify.custom" argument must be of type Function');
      return Object.defineProperty(C, _e, {
        value: C,
        enumerable: !1,
        writable: !1,
        configurable: !0
      }), C;
    }
    function C() {
      for (var q, N, F = new Promise(function(Y, k) {
        q = Y, N = k;
      }), T = [], Z = 0; Z < arguments.length; Z++)
        T.push(arguments[Z]);
      T.push(function(Y, k) {
        Y ? N(Y) : q(k);
      });
      try {
        z.apply(this, T);
      } catch (Y) {
        N(Y);
      }
      return F;
    }
    return Object.setPrototypeOf(C, Object.getPrototypeOf(z)), _e && Object.defineProperty(C, _e, {
      value: C,
      enumerable: !1,
      writable: !1,
      configurable: !0
    }), Object.defineProperties(
      C,
      t(z)
    );
  }, e.promisify.custom = _e;
  function ie(V, z) {
    if (!V) {
      var C = new Error("Promise was rejected with a falsy value");
      C.reason = V, V = C;
    }
    return z(V);
  }
  function K(V) {
    if (typeof V != "function")
      throw new TypeError('The "original" argument must be of type Function');
    function z() {
      for (var C = [], q = 0; q < arguments.length; q++)
        C.push(arguments[q]);
      var N = C.pop();
      if (typeof N != "function")
        throw new TypeError("The last argument must be of type Function");
      var F = this, T = function() {
        return N.apply(F, arguments);
      };
      V.apply(this, C).then(
        function(Z) {
          Me.process.nextTick(T.bind(null, null, Z));
        },
        function(Z) {
          Me.process.nextTick(ie.bind(null, Z, T));
        }
      );
    }
    return Object.setPrototypeOf(z, Object.getPrototypeOf(V)), Object.defineProperties(
      z,
      t(V)
    ), z;
  }
  e.callbackify = K;
})(Ku);
typeof module == "object" && typeof module.exports == "object" && (module.exports = Object.assign(module.exports.default, module.exports));
const w5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Ono: ys,
  default: x1,
  ono: x1
}, Symbol.toStringTag, { value: "Module" })), Nn = /* @__PURE__ */ If(w5);
var ai = { exports: {} };
function $5() {
  return typeof Me.process == "object" && typeof Me.process.nextTick == "function" ? Me.process.nextTick : typeof setImmediate == "function" ? setImmediate : function(t) {
    setTimeout(t, 0);
  };
}
var E5 = $5(), T1 = E5, rx = function(t, r) {
  if (t) {
    r.then(function(n) {
      T1(function() {
        t(null, n);
      });
    }, function(n) {
      T1(function() {
        t(n);
      });
    });
    return;
  } else
    return r;
}, or = {}, vy = { exports: {} }, uf = { exports: {} };
/*! https://mths.be/punycode v1.4.1 by @mathias */
uf.exports;
(function(e, t) {
  (function(r) {
    var n = t && !t.nodeType && t, i = e && !e.nodeType && e, s = typeof rt == "object" && rt;
    (s.global === s || s.window === s || s.self === s) && (r = s);
    var a, u = 2147483647, c = 36, l = 1, d = 26, p = 38, h = 700, v = 72, y = 128, g = "-", _ = /^xn--/, m = /[^\x20-\x7E]/, w = /[\x2E\u3002\uFF0E\uFF61]/g, $ = {
      overflow: "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    }, E = c - l, A = Math.floor, R = String.fromCharCode, I;
    function D(ie) {
      throw new RangeError($[ie]);
    }
    function J(ie, K) {
      for (var V = ie.length, z = []; V--; )
        z[V] = K(ie[V]);
      return z;
    }
    function ae(ie, K) {
      var V = ie.split("@"), z = "";
      V.length > 1 && (z = V[0] + "@", ie = V[1]), ie = ie.replace(w, ".");
      var C = ie.split("."), q = J(C, K).join(".");
      return z + q;
    }
    function ye(ie) {
      for (var K = [], V = 0, z = ie.length, C, q; V < z; )
        C = ie.charCodeAt(V++), C >= 55296 && C <= 56319 && V < z ? (q = ie.charCodeAt(V++), (q & 64512) == 56320 ? K.push(((C & 1023) << 10) + (q & 1023) + 65536) : (K.push(C), V--)) : K.push(C);
      return K;
    }
    function xe(ie) {
      return J(ie, function(K) {
        var V = "";
        return K > 65535 && (K -= 65536, V += R(K >>> 10 & 1023 | 55296), K = 56320 | K & 1023), V += R(K), V;
      }).join("");
    }
    function je(ie) {
      return ie - 48 < 10 ? ie - 22 : ie - 65 < 26 ? ie - 65 : ie - 97 < 26 ? ie - 97 : c;
    }
    function re(ie, K) {
      return ie + 22 + 75 * (ie < 26) - ((K != 0) << 5);
    }
    function fe(ie, K, V) {
      var z = 0;
      for (ie = V ? A(ie / h) : ie >> 1, ie += A(ie / K); ie > E * d >> 1; z += c)
        ie = A(ie / E);
      return A(z + (E + 1) * ie / (ie + p));
    }
    function le(ie) {
      var K = [], V = ie.length, z, C = 0, q = y, N = v, F, T, Z, Y, k, U, pe, we, He;
      for (F = ie.lastIndexOf(g), F < 0 && (F = 0), T = 0; T < F; ++T)
        ie.charCodeAt(T) >= 128 && D("not-basic"), K.push(ie.charCodeAt(T));
      for (Z = F > 0 ? F + 1 : 0; Z < V; ) {
        for (Y = C, k = 1, U = c; Z >= V && D("invalid-input"), pe = je(ie.charCodeAt(Z++)), (pe >= c || pe > A((u - C) / k)) && D("overflow"), C += pe * k, we = U <= N ? l : U >= N + d ? d : U - N, !(pe < we); U += c)
          He = c - we, k > A(u / He) && D("overflow"), k *= He;
        z = K.length + 1, N = fe(C - Y, z, Y == 0), A(C / z) > u - q && D("overflow"), q += A(C / z), C %= z, K.splice(C++, 0, q);
      }
      return xe(K);
    }
    function $e(ie) {
      var K, V, z, C, q, N, F, T, Z, Y, k, U = [], pe, we, He, Fe;
      for (ie = ye(ie), pe = ie.length, K = y, V = 0, q = v, N = 0; N < pe; ++N)
        k = ie[N], k < 128 && U.push(R(k));
      for (z = C = U.length, C && U.push(g); z < pe; ) {
        for (F = u, N = 0; N < pe; ++N)
          k = ie[N], k >= K && k < F && (F = k);
        for (we = z + 1, F - K > A((u - V) / we) && D("overflow"), V += (F - K) * we, K = F, N = 0; N < pe; ++N)
          if (k = ie[N], k < K && ++V > u && D("overflow"), k == K) {
            for (T = V, Z = c; Y = Z <= q ? l : Z >= q + d ? d : Z - q, !(T < Y); Z += c)
              Fe = T - Y, He = c - Y, U.push(
                R(re(Y + Fe % He, 0))
              ), T = A(Fe / He);
            U.push(R(re(T, 0))), q = fe(V, we, z == C), V = 0, ++z;
          }
        ++V, ++K;
      }
      return U.join("");
    }
    function Ae(ie) {
      return ae(ie, function(K) {
        return _.test(K) ? le(K.slice(4).toLowerCase()) : K;
      });
    }
    function _e(ie) {
      return ae(ie, function(K) {
        return m.test(K) ? "xn--" + $e(K) : K;
      });
    }
    if (a = {
      /**
       * A string representing the current Punycode.js version number.
       * @memberOf punycode
       * @type String
       */
      version: "1.4.1",
      /**
       * An object of methods to convert from JavaScript's internal character
       * representation (UCS-2) to Unicode code points, and back.
       * @see <https://mathiasbynens.be/notes/javascript-encoding>
       * @memberOf punycode
       * @type Object
       */
      ucs2: {
        decode: ye,
        encode: xe
      },
      decode: le,
      encode: $e,
      toASCII: _e,
      toUnicode: Ae
    }, n && i)
      if (e.exports == n)
        i.exports = a;
      else
        for (I in a)
          a.hasOwnProperty(I) && (n[I] = a[I]);
    else
      r.punycode = a;
  })(rt);
})(uf, uf.exports);
var x5 = uf.exports;
const O5 = /* @__PURE__ */ ea(x5);
function P5(e, t) {
  return Object.prototype.hasOwnProperty.call(e, t);
}
var S5 = function(e, t, r, n) {
  t = t || "&", r = r || "=";
  var i = {};
  if (typeof e != "string" || e.length === 0)
    return i;
  var s = /\+/g;
  e = e.split(t);
  var a = 1e3;
  n && typeof n.maxKeys == "number" && (a = n.maxKeys);
  var u = e.length;
  a > 0 && u > a && (u = a);
  for (var c = 0; c < u; ++c) {
    var l = e[c].replace(s, "%20"), d = l.indexOf(r), p, h, v, y;
    d >= 0 ? (p = l.substr(0, d), h = l.substr(d + 1)) : (p = l, h = ""), v = decodeURIComponent(p), y = decodeURIComponent(h), P5(i, v) ? A5(i[v]) ? i[v].push(y) : i[v] = [i[v], y] : i[v] = y;
  }
  return i;
}, A5 = Array.isArray || function(e) {
  return Object.prototype.toString.call(e) === "[object Array]";
}, Vo = function(e) {
  switch (typeof e) {
    case "string":
      return e;
    case "boolean":
      return e ? "true" : "false";
    case "number":
      return isFinite(e) ? e : "";
    default:
      return "";
  }
}, C5 = function(e, t, r, n) {
  return t = t || "&", r = r || "=", e === null && (e = void 0), typeof e == "object" ? I1(T5(e), function(i) {
    var s = encodeURIComponent(Vo(i)) + r;
    return R5(e[i]) ? I1(e[i], function(a) {
      return s + encodeURIComponent(Vo(a));
    }).join(t) : s + encodeURIComponent(Vo(e[i]));
  }).join(t) : n ? encodeURIComponent(Vo(n)) + r + encodeURIComponent(Vo(e)) : "";
}, R5 = Array.isArray || function(e) {
  return Object.prototype.toString.call(e) === "[object Array]";
};
function I1(e, t) {
  if (e.map)
    return e.map(t);
  for (var r = [], n = 0; n < e.length; n++)
    r.push(t(e[n], n));
  return r;
}
var T5 = Object.keys || function(e) {
  var t = [];
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.push(r);
  return t;
}, Og, Pg, nx = Pg = S5, ix = Og = C5;
function sx(e) {
  return encodeURIComponent(e);
}
function ax(e) {
  return decodeURIComponent(e);
}
var ox = {
  decode: nx,
  encode: ix,
  parse: Pg,
  stringify: Og,
  escape: sx,
  unescape: ax
};
const I5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: nx,
  default: ox,
  encode: ix,
  escape: sx,
  get parse() {
    return Pg;
  },
  get stringify() {
    return Og;
  },
  unescape: ax
}, Symbol.toStringTag, { value: "Module" }));
var j5 = {
  isString: function(e) {
    return typeof e == "string";
  },
  isObject: function(e) {
    return typeof e == "object" && e !== null;
  },
  isNull: function(e) {
    return e === null;
  },
  isNullOrUndefined: function(e) {
    return e == null;
  }
}, k5 = O5, Gn = j5, M5 = Ju, N5 = G5, ux = K5, D5 = H5, L5 = mn;
function mn() {
  this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
}
var q5 = /^([a-z0-9.+-]+:)/i, F5 = /:[0-9]*$/, U5 = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, B5 = ["<", ">", '"', "`", " ", "\r", `
`, "	"], V5 = ["{", "}", "|", "\\", "^", "`"].concat(B5), by = ["'"].concat(V5), j1 = ["%", "/", "?", ";", "#"].concat(by), k1 = ["/", "?", "#"], Z5 = 255, M1 = /^[+a-z0-9A-Z_-]{0,63}$/, z5 = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, W5 = {
  javascript: !0,
  "javascript:": !0
}, _y = {
  javascript: !0,
  "javascript:": !0
}, Ya = {
  http: !0,
  https: !0,
  ftp: !0,
  gopher: !0,
  file: !0,
  "http:": !0,
  "https:": !0,
  "ftp:": !0,
  "gopher:": !0,
  "file:": !0
}, wy = ox;
function Ju(e, t, r) {
  if (e && Gn.isObject(e) && e instanceof mn)
    return e;
  var n = new mn();
  return n.parse(e, t, r), n;
}
mn.prototype.parse = function(e, t, r) {
  if (!Gn.isString(e))
    throw new TypeError("Parameter 'url' must be a string, not " + typeof e);
  var n = e.indexOf("?"), i = n !== -1 && n < e.indexOf("#") ? "?" : "#", s = e.split(i), a = /\\/g;
  s[0] = s[0].replace(a, "/"), e = s.join(i);
  var u = e;
  if (u = u.trim(), !r && e.split("#").length === 1) {
    var c = U5.exec(u);
    if (c)
      return this.path = u, this.href = u, this.pathname = c[1], c[2] ? (this.search = c[2], t ? this.query = wy.parse(this.search.substr(1)) : this.query = this.search.substr(1)) : t && (this.search = "", this.query = {}), this;
  }
  var l = q5.exec(u);
  if (l) {
    l = l[0];
    var d = l.toLowerCase();
    this.protocol = d, u = u.substr(l.length);
  }
  if (r || l || u.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var p = u.substr(0, 2) === "//";
    p && !(l && _y[l]) && (u = u.substr(2), this.slashes = !0);
  }
  if (!_y[l] && (p || l && !Ya[l])) {
    for (var h = -1, v = 0; v < k1.length; v++) {
      var y = u.indexOf(k1[v]);
      y !== -1 && (h === -1 || y < h) && (h = y);
    }
    var g, _;
    h === -1 ? _ = u.lastIndexOf("@") : _ = u.lastIndexOf("@", h), _ !== -1 && (g = u.slice(0, _), u = u.slice(_ + 1), this.auth = decodeURIComponent(g)), h = -1;
    for (var v = 0; v < j1.length; v++) {
      var y = u.indexOf(j1[v]);
      y !== -1 && (h === -1 || y < h) && (h = y);
    }
    h === -1 && (h = u.length), this.host = u.slice(0, h), u = u.slice(h), this.parseHost(), this.hostname = this.hostname || "";
    var m = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!m)
      for (var w = this.hostname.split(/\./), v = 0, $ = w.length; v < $; v++) {
        var E = w[v];
        if (E && !E.match(M1)) {
          for (var A = "", R = 0, I = E.length; R < I; R++)
            E.charCodeAt(R) > 127 ? A += "x" : A += E[R];
          if (!A.match(M1)) {
            var D = w.slice(0, v), J = w.slice(v + 1), ae = E.match(z5);
            ae && (D.push(ae[1]), J.unshift(ae[2])), J.length && (u = "/" + J.join(".") + u), this.hostname = D.join(".");
            break;
          }
        }
      }
    this.hostname.length > Z5 ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), m || (this.hostname = k5.toASCII(this.hostname));
    var ye = this.port ? ":" + this.port : "", xe = this.hostname || "";
    this.host = xe + ye, this.href += this.host, m && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), u[0] !== "/" && (u = "/" + u));
  }
  if (!W5[d])
    for (var v = 0, $ = by.length; v < $; v++) {
      var je = by[v];
      if (u.indexOf(je) !== -1) {
        var re = encodeURIComponent(je);
        re === je && (re = escape(je)), u = u.split(je).join(re);
      }
    }
  var fe = u.indexOf("#");
  fe !== -1 && (this.hash = u.substr(fe), u = u.slice(0, fe));
  var le = u.indexOf("?");
  if (le !== -1 ? (this.search = u.substr(le), this.query = u.substr(le + 1), t && (this.query = wy.parse(this.query)), u = u.slice(0, le)) : t && (this.search = "", this.query = {}), u && (this.pathname = u), Ya[d] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
    var ye = this.pathname || "", $e = this.search || "";
    this.path = ye + $e;
  }
  return this.href = this.format(), this;
};
function H5(e) {
  return Gn.isString(e) && (e = Ju(e)), e instanceof mn ? e.format() : mn.prototype.format.call(e);
}
mn.prototype.format = function() {
  var e = this.auth || "";
  e && (e = encodeURIComponent(e), e = e.replace(/%3A/i, ":"), e += "@");
  var t = this.protocol || "", r = this.pathname || "", n = this.hash || "", i = !1, s = "";
  this.host ? i = e + this.host : this.hostname && (i = e + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"), this.port && (i += ":" + this.port)), this.query && Gn.isObject(this.query) && Object.keys(this.query).length && (s = wy.stringify(this.query));
  var a = this.search || s && "?" + s || "";
  return t && t.substr(-1) !== ":" && (t += ":"), this.slashes || (!t || Ya[t]) && i !== !1 ? (i = "//" + (i || ""), r && r.charAt(0) !== "/" && (r = "/" + r)) : i || (i = ""), n && n.charAt(0) !== "#" && (n = "#" + n), a && a.charAt(0) !== "?" && (a = "?" + a), r = r.replace(/[?#]/g, function(u) {
    return encodeURIComponent(u);
  }), a = a.replace("#", "%23"), t + i + r + a + n;
};
function G5(e, t) {
  return Ju(e, !1, !0).resolve(t);
}
mn.prototype.resolve = function(e) {
  return this.resolveObject(Ju(e, !1, !0)).format();
};
function K5(e, t) {
  return e ? Ju(e, !1, !0).resolveObject(t) : t;
}
mn.prototype.resolveObject = function(e) {
  if (Gn.isString(e)) {
    var t = new mn();
    t.parse(e, !1, !0), e = t;
  }
  for (var r = new mn(), n = Object.keys(this), i = 0; i < n.length; i++) {
    var s = n[i];
    r[s] = this[s];
  }
  if (r.hash = e.hash, e.href === "")
    return r.href = r.format(), r;
  if (e.slashes && !e.protocol) {
    for (var a = Object.keys(e), u = 0; u < a.length; u++) {
      var c = a[u];
      c !== "protocol" && (r[c] = e[c]);
    }
    return Ya[r.protocol] && r.hostname && !r.pathname && (r.path = r.pathname = "/"), r.href = r.format(), r;
  }
  if (e.protocol && e.protocol !== r.protocol) {
    if (!Ya[e.protocol]) {
      for (var l = Object.keys(e), d = 0; d < l.length; d++) {
        var p = l[d];
        r[p] = e[p];
      }
      return r.href = r.format(), r;
    }
    if (r.protocol = e.protocol, !e.host && !_y[e.protocol]) {
      for (var $ = (e.pathname || "").split("/"); $.length && !(e.host = $.shift()); )
        ;
      e.host || (e.host = ""), e.hostname || (e.hostname = ""), $[0] !== "" && $.unshift(""), $.length < 2 && $.unshift(""), r.pathname = $.join("/");
    } else
      r.pathname = e.pathname;
    if (r.search = e.search, r.query = e.query, r.host = e.host || "", r.auth = e.auth, r.hostname = e.hostname || e.host, r.port = e.port, r.pathname || r.search) {
      var h = r.pathname || "", v = r.search || "";
      r.path = h + v;
    }
    return r.slashes = r.slashes || e.slashes, r.href = r.format(), r;
  }
  var y = r.pathname && r.pathname.charAt(0) === "/", g = e.host || e.pathname && e.pathname.charAt(0) === "/", _ = g || y || r.host && e.pathname, m = _, w = r.pathname && r.pathname.split("/") || [], $ = e.pathname && e.pathname.split("/") || [], E = r.protocol && !Ya[r.protocol];
  if (E && (r.hostname = "", r.port = null, r.host && (w[0] === "" ? w[0] = r.host : w.unshift(r.host)), r.host = "", e.protocol && (e.hostname = null, e.port = null, e.host && ($[0] === "" ? $[0] = e.host : $.unshift(e.host)), e.host = null), _ = _ && ($[0] === "" || w[0] === "")), g)
    r.host = e.host || e.host === "" ? e.host : r.host, r.hostname = e.hostname || e.hostname === "" ? e.hostname : r.hostname, r.search = e.search, r.query = e.query, w = $;
  else if ($.length)
    w || (w = []), w.pop(), w = w.concat($), r.search = e.search, r.query = e.query;
  else if (!Gn.isNullOrUndefined(e.search)) {
    if (E) {
      r.hostname = r.host = w.shift();
      var A = r.host && r.host.indexOf("@") > 0 ? r.host.split("@") : !1;
      A && (r.auth = A.shift(), r.host = r.hostname = A.shift());
    }
    return r.search = e.search, r.query = e.query, (!Gn.isNull(r.pathname) || !Gn.isNull(r.search)) && (r.path = (r.pathname ? r.pathname : "") + (r.search ? r.search : "")), r.href = r.format(), r;
  }
  if (!w.length)
    return r.pathname = null, r.search ? r.path = "/" + r.search : r.path = null, r.href = r.format(), r;
  for (var R = w.slice(-1)[0], I = (r.host || e.host || w.length > 1) && (R === "." || R === "..") || R === "", D = 0, J = w.length; J >= 0; J--)
    R = w[J], R === "." ? w.splice(J, 1) : R === ".." ? (w.splice(J, 1), D++) : D && (w.splice(J, 1), D--);
  if (!_ && !m)
    for (; D--; D)
      w.unshift("..");
  _ && w[0] !== "" && (!w[0] || w[0].charAt(0) !== "/") && w.unshift(""), I && w.join("/").substr(-1) !== "/" && w.push("");
  var ae = w[0] === "" || w[0] && w[0].charAt(0) === "/";
  if (E) {
    r.hostname = r.host = ae ? "" : w.length ? w.shift() : "";
    var A = r.host && r.host.indexOf("@") > 0 ? r.host.split("@") : !1;
    A && (r.auth = A.shift(), r.host = r.hostname = A.shift());
  }
  return _ = _ || r.host && w.length, _ && !ae && w.unshift(""), w.length ? r.pathname = w.join("/") : (r.pathname = null, r.path = null), (!Gn.isNull(r.pathname) || !Gn.isNull(r.search)) && (r.path = (r.pathname ? r.pathname : "") + (r.search ? r.search : "")), r.auth = e.auth || r.auth, r.slashes = r.slashes || e.slashes, r.href = r.format(), r;
};
mn.prototype.parseHost = function() {
  var e = this.host, t = F5.exec(e);
  t && (t = t[0], t !== ":" && (this.port = t.substr(1)), e = e.substr(0, e.length - t.length)), e && (this.hostname = e);
};
function Y5(e, t) {
  for (var r = 0, n = e.length - 1; n >= 0; n--) {
    var i = e[n];
    i === "." ? e.splice(n, 1) : i === ".." ? (e.splice(n, 1), r++) : r && (e.splice(n, 1), r--);
  }
  if (t)
    for (; r--; r)
      e.unshift("..");
  return e;
}
function J5() {
  for (var e = "", t = !1, r = arguments.length - 1; r >= -1 && !t; r--) {
    var n = r >= 0 ? arguments[r] : "/";
    if (typeof n != "string")
      throw new TypeError("Arguments to path.resolve must be strings");
    if (!n)
      continue;
    e = n + "/" + e, t = n.charAt(0) === "/";
  }
  return e = Y5(X5(e.split("/"), function(i) {
    return !!i;
  }), !t).join("/"), (t ? "/" : "") + e || ".";
}
function X5(e, t) {
  if (e.filter)
    return e.filter(t);
  for (var r = [], n = 0; n < e.length; n++)
    t(e[n], n, e) && r.push(e[n]);
  return r;
}
var cx = function(e) {
  function t() {
    var n = this || self;
    return delete e.prototype.__magic__, n;
  }
  if (typeof globalThis == "object")
    return globalThis;
  if (this)
    return t();
  e.defineProperty(e.prototype, "__magic__", {
    configurable: !0,
    get: t
  });
  var r = __magic__;
  return r;
}(Object), Q5 = (
  /** @type {formatImport}*/
  D5
), lx = (
  /** @type {parseImport}*/
  M5
), fx = (
  /** @type {resolveImport}*/
  N5
), dx = (
  /** @type {UrlImport}*/
  L5
), ps = cx.URL, px = cx.URLSearchParams, eD = /%/g, tD = /\\/g, rD = /\n/g, nD = /\r/g, iD = /\t/g, sD = 47;
function aD(e) {
  var t = (
    /** @type {URL|null} */
    e ?? null
  );
  return !!(t !== null && (t != null && t.href) && (t != null && t.origin));
}
function oD(e) {
  if (e.hostname !== "")
    throw new TypeError('File URL host must be "localhost" or empty on browser');
  for (var t = e.pathname, r = 0; r < t.length; r++)
    if (t[r] === "%") {
      var n = t.codePointAt(r + 2) | 32;
      if (t[r + 1] === "2" && n === 102)
        throw new TypeError("File URL path must not include encoded / characters");
    }
  return decodeURIComponent(t);
}
function uD(e) {
  return e.includes("%") && (e = e.replace(eD, "%25")), e.includes("\\") && (e = e.replace(tD, "%5C")), e.includes(`
`) && (e = e.replace(rD, "%0A")), e.includes("\r") && (e = e.replace(nD, "%0D")), e.includes("	") && (e = e.replace(iD, "%09")), e;
}
var hx = (
  /**
   * @type {domainToASCII}
   */
  function(t) {
    if (typeof t > "u")
      throw new TypeError('The "domain" argument must be specified');
    return new ps("http://" + t).hostname;
  }
), mx = (
  /**
   * @type {domainToUnicode}
   */
  function(t) {
    if (typeof t > "u")
      throw new TypeError('The "domain" argument must be specified');
    return new ps("http://" + t).hostname;
  }
), yx = (
  /**
   * @type {(url: string) => URL}
   */
  function(t) {
    var r = new ps("file://"), n = J5(t), i = t.charCodeAt(t.length - 1);
    return i === sD && n[n.length - 1] !== "/" && (n += "/"), r.pathname = uD(n), r;
  }
), gx = (
  /**
   * @type {fileURLToPath & ((path: string | URL) => string)}
   */
  function(t) {
    if (!aD(t) && typeof t != "string")
      throw new TypeError('The "path" argument must be of type string or an instance of URL. Received type ' + typeof t + " (" + t + ")");
    var r = new ps(t);
    if (r.protocol !== "file:")
      throw new TypeError("The URL must be of scheme file");
    return oD(r);
  }
), vx = (
  /**
   * @type {(
   *   ((urlObject: URL, options?: URLFormatOptions) => string) &
   *   ((urlObject: UrlObject | string, options?: never) => string)
   * )}
   */
  function(t, r) {
    var n, i, s;
    if (r === void 0 && (r = {}), !(t instanceof ps))
      return Q5(t);
    if (typeof r != "object" || r === null)
      throw new TypeError('The "options" argument must be of type object.');
    var a = (n = r.auth) != null ? n : !0, u = (i = r.fragment) != null ? i : !0, c = (s = r.search) != null ? s : !0, l = new ps(t.toString());
    return a || (l.username = "", l.password = ""), u || (l.hash = ""), c || (l.search = ""), l.toString();
  }
), cD = {
  format: vx,
  parse: lx,
  resolve: fx,
  resolveObject: ux,
  Url: dx,
  URL: ps,
  URLSearchParams: px,
  domainToASCII: hx,
  domainToUnicode: mx,
  pathToFileURL: yx,
  fileURLToPath: gx
};
const lD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  URL: ps,
  URLSearchParams: px,
  Url: dx,
  default: cD,
  domainToASCII: hx,
  domainToUnicode: mx,
  fileURLToPath: gx,
  format: vx,
  parse: lx,
  pathToFileURL: yx,
  resolve: fx,
  resolveObject: ux
}, Symbol.toStringTag, { value: "Module" })), Iu = /* @__PURE__ */ If(lD);
(function(e, t) {
  const r = /^win/.test(Me.process.platform), n = /\//g, i = /^(\w{2,}):\/\//i, s = e.exports, a = /~1/g, u = /~0/g, c = [
    /\?/g,
    "%3F",
    /#/g,
    "%23"
  ], l = [
    /%23/g,
    "#",
    /%24/g,
    "$",
    /%26/g,
    "&",
    /%2C/g,
    ",",
    /%40/g,
    "@"
  ];
  t.parse = Iu.parse, t.resolve = Iu.resolve, t.cwd = function() {
    if (Me.process.browser)
      return location.href;
    const p = Me.process.cwd(), h = p.slice(-1);
    return h === "/" || h === "\\" ? p : `${p}/`;
  }, t.getProtocol = function(p) {
    const h = i.exec(p);
    if (h)
      return h[1].toLowerCase();
  }, t.getExtension = function(p) {
    const h = p.lastIndexOf(".");
    return h >= 0 ? s.stripQuery(p.substr(h).toLowerCase()) : "";
  }, t.stripQuery = function(p) {
    const h = p.indexOf("?");
    return h >= 0 && (p = p.substr(0, h)), p;
  }, t.getHash = function(p) {
    const h = p.indexOf("#");
    return h >= 0 ? p.substr(h) : "#";
  }, t.stripHash = function(p) {
    const h = p.indexOf("#");
    return h >= 0 ? p.substr(0, h) : p;
  }, t.isHttp = function(p) {
    const h = s.getProtocol(p);
    return h === "http" || h === "https" ? !0 : h === void 0 ? Me.process.browser : !1;
  }, t.isFileSystemPath = function(p) {
    if (Me.process.browser)
      return !1;
    const h = s.getProtocol(p);
    return h === void 0 || h === "file";
  }, t.fromFileSystemPath = function(p) {
    r && (p = p.replace(/\\/g, "/")), p = encodeURI(p);
    for (let h = 0; h < c.length; h += 2)
      p = p.replace(c[h], c[h + 1]);
    return p;
  }, t.toFileSystemPath = function(p, h) {
    p = decodeURI(p);
    for (let y = 0; y < l.length; y += 2)
      p = p.replace(l[y], l[y + 1]);
    let v = p.substr(0, 7).toLowerCase() === "file://";
    return v && (p = p[7] === "/" ? p.substr(8) : p.substr(7), r && p[1] === "/" && (p = `${p[0]}:${p.substr(1)}`), h ? p = `file:///${p}` : (v = !1, p = r ? p : `/${p}`)), r && !v && (p = p.replace(n, "\\"), p.substr(1, 2) === ":\\" && (p = p[0].toUpperCase() + p.substr(1))), p;
  }, t.safePointerToPath = function(p) {
    return p.length <= 1 || p[0] !== "#" || p[1] !== "/" ? [] : p.slice(2).split("/").map((h) => decodeURIComponent(h).replace(a, "/").replace(u, "~"));
  };
})(vy, vy.exports);
var gn = vy.exports;
const { Ono: bx } = Nn, { stripHash: _x, toFileSystemPath: fD } = gn;
function vs(e) {
  Object.defineProperty(e.prototype, "name", {
    value: e.name,
    enumerable: !0
  });
}
const ji = class extends Error {
  constructor(t, r) {
    super(), this.code = "EUNKNOWN", this.message = t, this.source = r, this.path = null, bx.extend(this);
  }
  get footprint() {
    return `${this.path}+${this.source}+${this.code}+${this.message}`;
  }
};
or.JSONParserError = ji;
vs(ji);
const Sg = class wx extends Error {
  constructor(t) {
    super(), this.files = t, this.message = `${this.errors.length} error${this.errors.length > 1 ? "s" : ""} occurred while reading '${fD(t.$refs._root$Ref.path)}'`, bx.extend(this);
  }
  static getParserErrors(t) {
    const r = [];
    for (const n of Object.values(t.$refs._$refs))
      n.errors && r.push(...n.errors);
    return r;
  }
  get errors() {
    return wx.getParserErrors(this.files);
  }
};
or.JSONParserErrorGroup = Sg;
vs(Sg);
const $x = class extends ji {
  constructor(t, r) {
    super(`Error parsing ${r}: ${t}`, r), this.code = "EPARSER";
  }
};
or.ParserError = $x;
vs($x);
const Ex = class extends ji {
  constructor(t) {
    super(`Could not find parser for "${t}"`, t), this.code = "EUNMATCHEDPARSER";
  }
};
or.UnmatchedParserError = Ex;
vs(Ex);
const xx = class extends ji {
  constructor(t, r) {
    super(t.message || `Error reading file "${r}"`, r), this.code = "ERESOLVER", "code" in t && (this.ioErrorCode = String(t.code));
  }
};
or.ResolverError = xx;
vs(xx);
const Ox = class extends ji {
  constructor(t) {
    super(`Could not find resolver for "${t}"`, t), this.code = "EUNMATCHEDRESOLVER";
  }
};
or.UnmatchedResolverError = Ox;
vs(Ox);
const Px = class extends ji {
  constructor(t, r) {
    super(`Token "${t}" does not exist.`, _x(r)), this.code = "EMISSINGPOINTER";
  }
};
or.MissingPointerError = Px;
vs(Px);
const Sx = class extends ji {
  constructor(t, r) {
    super(`Invalid $ref pointer "${t}". Pointers must begin with "#/"`, _x(r)), this.code = "EINVALIDPOINTER";
  }
};
or.InvalidPointerError = Sx;
vs(Sx);
or.isHandledError = function(e) {
  return e instanceof ji || e instanceof Sg;
};
or.normalizeError = function(e) {
  return e.path === null && (e.path = []), e;
};
var Dp, N1;
function Vf() {
  if (N1)
    return Dp;
  N1 = 1;
  const e = Xu(), { JSONParserError: t, InvalidPointerError: r, MissingPointerError: n, isHandledError: i } = or, s = gn, a = /\//g, u = /~/g, c = /~1/g, l = /~0/g;
  Dp = d;
  function d(y, g, _) {
    this.$ref = y, this.path = g, this.originalPath = _ || g, this.value = void 0, this.circular = !1, this.indirections = 0;
  }
  d.prototype.resolve = function(y, g, _) {
    const m = d.parse(this.path, this.originalPath);
    this.value = v(y);
    for (let w = 0; w < m.length; w++) {
      if (p(this, g) && (this.path = d.join(this.path, m.slice(w))), typeof this.value == "object" && this.value !== null && "$ref" in this.value)
        return this;
      const $ = m[w];
      if (this.value[$] === void 0 || this.value[$] === null)
        throw this.value = null, new n($, this.originalPath);
      this.value = this.value[$];
    }
    return (!this.value || this.value.$ref && s.resolve(this.path, this.value.$ref) !== _) && p(this, g), this;
  }, d.prototype.set = function(y, g, _) {
    const m = d.parse(this.path);
    let w;
    if (m.length === 0)
      return this.value = g, g;
    this.value = v(y);
    for (let $ = 0; $ < m.length - 1; $++)
      p(this, _), w = m[$], this.value && this.value[w] !== void 0 ? this.value = this.value[w] : this.value = h(this, w, {});
    return p(this, _), w = m[m.length - 1], h(this, w, g), y;
  }, d.parse = function(y, g) {
    let _ = s.getHash(y).substr(1);
    if (!_)
      return [];
    _ = _.split("/");
    for (let m = 0; m < _.length; m++)
      _[m] = decodeURIComponent(_[m].replace(c, "/").replace(l, "~"));
    if (_[0] !== "")
      throw new r(_, g === void 0 ? y : g);
    return _.slice(1);
  }, d.join = function(y, g) {
    y.indexOf("#") === -1 && (y += "#"), g = Array.isArray(g) ? g : [g];
    for (let _ = 0; _ < g.length; _++) {
      const m = g[_];
      y += `/${encodeURIComponent(m.replace(u, "~0").replace(a, "~1"))}`;
    }
    return y;
  };
  function p(y, g) {
    if (e.isAllowed$Ref(y.value, g)) {
      const _ = s.resolve(y.path, y.value.$ref);
      if (_ === y.path)
        y.circular = !0;
      else {
        const m = y.$ref.$refs._resolve(_, y.path, g);
        return m === null ? !1 : (y.indirections += m.indirections + 1, e.isExtended$Ref(y.value) ? (y.value = e.dereference(y.value, m.value), !1) : (y.$ref = m.$ref, y.path = m.path, y.value = m.value, !0));
      }
    }
  }
  function h(y, g, _) {
    if (y.value && typeof y.value == "object")
      g === "-" && Array.isArray(y.value) ? y.value.push(_) : y.value[g] = _;
    else
      throw new t(
        `Error assigning $ref pointer "${y.path}". 
Cannot set "${g}" of a non-object.`
      );
    return _;
  }
  function v(y) {
    if (i(y))
      throw y;
    return y;
  }
  return Dp;
}
var Lp, D1;
function Xu() {
  if (D1)
    return Lp;
  D1 = 1, Lp = u;
  const e = Vf(), { InvalidPointerError: t, isHandledError: r, normalizeError: n } = or, { safePointerToPath: i, stripHash: s, getHash: a } = gn;
  function u() {
    this.path = void 0, this.value = void 0, this.$refs = void 0, this.pathType = void 0, this.errors = void 0;
  }
  return u.prototype.addError = function(c) {
    this.errors === void 0 && (this.errors = []);
    const l = this.errors.map(({ footprint: d }) => d);
    Array.isArray(c.errors) ? this.errors.push(...c.errors.map(n).filter(({ footprint: d }) => !l.includes(d))) : l.includes(c.footprint) || this.errors.push(n(c));
  }, u.prototype.exists = function(c, l) {
    try {
      return this.resolve(c, l), !0;
    } catch {
      return !1;
    }
  }, u.prototype.get = function(c, l) {
    return this.resolve(c, l).value;
  }, u.prototype.resolve = function(c, l, d, p) {
    const h = new e(this, c, d);
    try {
      return h.resolve(this.value, l, p);
    } catch (v) {
      if (!l || !l.continueOnError || !r(v))
        throw v;
      return v.path === null && (v.path = i(a(p))), v instanceof t && (v.source = s(p)), this.addError(v), null;
    }
  }, u.prototype.set = function(c, l) {
    const d = new e(this, c);
    this.value = d.set(this.value, l);
  }, u.is$Ref = function(c) {
    return c && typeof c == "object" && typeof c.$ref == "string" && c.$ref.length > 0;
  }, u.isExternal$Ref = function(c) {
    return u.is$Ref(c) && c.$ref[0] !== "#";
  }, u.isAllowed$Ref = function(c, l) {
    if (u.is$Ref(c)) {
      if (c.$ref.substr(0, 2) === "#/" || c.$ref === "#")
        return !0;
      if (c.$ref[0] !== "#" && (!l || l.resolve.external))
        return !0;
    }
  }, u.isExtended$Ref = function(c) {
    return u.is$Ref(c) && Object.keys(c).length > 1;
  }, u.dereference = function(c, l) {
    if (l && typeof l == "object" && u.isExtended$Ref(c)) {
      const d = {};
      for (const p of Object.keys(c))
        p !== "$ref" && (d[p] = c[p]);
      for (const p of Object.keys(l))
        p in d || (d[p] = l[p]);
      return d;
    }
    return l;
  }, Lp;
}
const cf = Xu(), ju = Vf(), qp = gn;
var dD = function(t, r) {
  const n = [];
  Ag(t, "schema", `${t.$refs._root$Ref.path}#`, "#", 0, n, t.$refs, r), pD(n);
};
function Ag(e, t, r, n, i, s, a, u) {
  const c = t === null ? e : e[t];
  if (c && typeof c == "object" && !ArrayBuffer.isView(c))
    if (cf.isAllowed$Ref(c))
      L1(e, t, r, n, i, s, a, u);
    else {
      const l = Object.keys(c).sort((d, p) => d === "definitions" ? -1 : p === "definitions" ? 1 : d.length - p.length);
      for (const d of l) {
        const p = ju.join(r, d), h = ju.join(n, d), v = c[d];
        cf.isAllowed$Ref(v) ? L1(c, d, r, h, i, s, a, u) : Ag(c, d, p, h, i, s, a, u);
      }
    }
}
function L1(e, t, r, n, i, s, a, u) {
  const c = t === null ? e : e[t], l = qp.resolve(r, c.$ref), d = a._resolve(l, n, u);
  if (d === null)
    return;
  const p = ju.parse(n).length, h = qp.stripHash(d.path), v = qp.getHash(d.path), y = h !== a._root$Ref.path, g = cf.isExtended$Ref(c);
  i += d.indirections;
  const _ = hD(s, e, t);
  if (_)
    if (p < _.depth || i < _.indirections)
      mD(s, _);
    else
      return;
  s.push({
    $ref: c,
    // The JSON Reference (e.g. {$ref: string})
    parent: e,
    // The object that contains this $ref pointer
    key: t,
    // The key in `parent` that is the $ref pointer
    pathFromRoot: n,
    // The path to the $ref pointer, from the JSON Schema root
    depth: p,
    // How far from the JSON Schema root is this $ref pointer?
    file: h,
    // The file that the $ref pointer resolves to
    hash: v,
    // The hash within `file` that the $ref pointer resolves to
    value: d.value,
    // The resolved value of the $ref pointer
    circular: d.circular,
    // Is this $ref pointer DIRECTLY circular? (i.e. it references itself)
    extended: g,
    // Does this $ref extend its resolved value? (i.e. it has extra properties, in addition to "$ref")
    external: y,
    // Does this $ref pointer point to a file other than the main JSON Schema file?
    indirections: i
    // The number of indirect references that were traversed to resolve the value
  }), _ || Ag(d.value, null, d.path, n, i + 1, s, a, u);
}
function pD(e) {
  e.sort((i, s) => {
    if (i.file !== s.file)
      return i.file < s.file ? -1 : 1;
    if (i.hash !== s.hash)
      return i.hash < s.hash ? -1 : 1;
    if (i.circular !== s.circular)
      return i.circular ? -1 : 1;
    if (i.extended !== s.extended)
      return i.extended ? 1 : -1;
    if (i.indirections !== s.indirections)
      return i.indirections - s.indirections;
    if (i.depth !== s.depth)
      return i.depth - s.depth;
    const a = i.pathFromRoot.lastIndexOf("/definitions"), u = s.pathFromRoot.lastIndexOf("/definitions");
    return a !== u ? u - a : i.pathFromRoot.length - s.pathFromRoot.length;
  });
  let t, r, n;
  for (const i of e)
    i.external ? i.file === t && i.hash === r ? i.$ref.$ref = n : i.file === t && i.hash.indexOf(`${r}/`) === 0 ? i.$ref.$ref = ju.join(n, ju.parse(i.hash.replace(r, "#"))) : (t = i.file, r = i.hash, n = i.pathFromRoot, i.parent[i.key] = cf.dereference(i.$ref, i.value), i.$ref = i.parent[i.key], i.circular && (i.$ref.$ref = i.pathFromRoot)) : i.$ref.$ref = i.hash;
}
function hD(e, t, r) {
  for (let n = 0; n < e.length; n++) {
    const i = e[n];
    if (i.parent === t && i.key === r)
      return i;
  }
}
function mD(e, t) {
  const r = e.indexOf(t);
  e.splice(r, 1);
}
const { ono: yD } = Nn, q1 = Vf(), $y = Xu(), gD = gn;
var Ax = function(t, r) {
  const n = Cg(
    t.schema,
    t.$refs._root$Ref.path,
    "#",
    /* @__PURE__ */ new Set(),
    /* @__PURE__ */ new Set(),
    /* @__PURE__ */ new Map(),
    t.$refs,
    r
  );
  t.$refs.circular = n.circular, t.schema = n.value;
};
function Cg(e, t, r, n, i, s, a, u) {
  let c;
  const l = {
    value: e,
    circular: !1
  };
  if ((u.dereference.circular === "ignore" || !i.has(e)) && e && typeof e == "object" && !ArrayBuffer.isView(e)) {
    if (n.add(e), i.add(e), $y.isAllowed$Ref(e, u))
      c = F1(
        e,
        t,
        r,
        n,
        i,
        s,
        a,
        u
      ), l.circular = c.circular, l.value = c.value, e.description && (l.value.description = e.description), e.summary && (l.value.summary = e.summary);
    else
      for (const d of Object.keys(e)) {
        const p = q1.join(t, d), h = q1.join(r, d), v = e[d];
        let y = !1;
        $y.isAllowed$Ref(v, u) ? (c = F1(
          v,
          p,
          h,
          n,
          i,
          s,
          a,
          u
        ), y = c.circular, e[d] !== c.value && (e[d] = c.value, v.description && (e[d].description = v.description), v.summary && (e[d].summary = v.summary))) : n.has(v) ? y = Cx(p, a, u) : (c = Cg(
          v,
          p,
          h,
          n,
          i,
          s,
          a,
          u
        ), y = c.circular, e[d] !== c.value && (e[d] = c.value)), l.circular = l.circular || y;
      }
    n.delete(e);
  }
  return l;
}
function F1(e, t, r, n, i, s, a, u) {
  const c = gD.resolve(t, e.$ref), l = s.get(c);
  if (l) {
    const g = Object.keys(e);
    if (g.length > 1) {
      const _ = {};
      for (const m of g)
        m !== "$ref" && !(m in l.value) && (_[m] = e[m]);
      return {
        circular: l.circular,
        value: { ...l.value, ..._ }
      };
    }
    return l;
  }
  const d = a._resolve(c, t, u);
  if (d === null)
    return {
      circular: !1,
      value: null
    };
  const p = d.circular;
  let h = p || n.has(d.value);
  h && Cx(t, a, u);
  let v = $y.dereference(e, d.value);
  if (!h) {
    const g = Cg(
      v,
      d.path,
      r,
      n,
      i,
      s,
      a,
      u
    );
    h = g.circular, v = g.value;
  }
  h && !p && u.dereference.circular === "ignore" && (v = e), p && (v.$ref = r);
  const y = {
    circular: h,
    value: v
  };
  return Object.keys(e).length === 1 && s.set(c, y), y;
}
function Cx(e, t, r) {
  if (t.circular = !0, t.circularRefs.push(e), !r.dereference.circular)
    throw yD.reference(`Circular $ref pointer found at ${e}`);
  return !0;
}
const vD = /\.(jpeg|jpg|gif|png|bmp|ico)$/i;
var bD = {
  /**
   * The order that this parser will run, in relation to other parsers.
   *
   * @type {number}
   */
  order: 400,
  /**
   * Whether to allow "empty" files (zero bytes).
   *
   * @type {boolean}
   */
  allowEmpty: !0,
  /**
   * Determines whether this parser can parse a given file reference.
   * Parsers that return true will be tried, in order, until one successfully parses the file.
   * Parsers that return false will be skipped, UNLESS all parsers returned false, in which case
   * every parser will be tried.
   *
   * @param {object} file           - An object containing information about the referenced file
   * @param {string} file.url       - The full URL of the referenced file
   * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
   * @returns {boolean}
   */
  canParse(e) {
    return Me.Buffer.isBuffer(e.data) && vD.test(e.url);
  },
  /**
   * Parses the given data as a Buffer (byte array).
   *
   * @param {object} file           - An object containing information about the referenced file
   * @param {string} file.url       - The full URL of the referenced file
   * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
   * @returns {Buffer}
   */
  parse(e) {
    return Me.Buffer.isBuffer(e.data) ? e.data : Me.Buffer.from(e.data);
  }
};
const { ParserError: _D } = or;
var wD = {
  /**
   * The order that this parser will run, in relation to other parsers.
   *
   * @type {number}
   */
  order: 100,
  /**
   * Whether to allow "empty" files. This includes zero-byte files, as well as empty JSON objects.
   *
   * @type {boolean}
   */
  allowEmpty: !0,
  /**
   * Determines whether this parser can parse a given file reference.
   * Parsers that match will be tried, in order, until one successfully parses the file.
   * Parsers that don't match will be skipped, UNLESS none of the parsers match, in which case
   * every parser will be tried.
   *
   * @type {RegExp|string|string[]|function}
   */
  canParse: ".json",
  /**
   * Parses the given file as JSON
   *
   * @param {object} file           - An object containing information about the referenced file
   * @param {string} file.url       - The full URL of the referenced file
   * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
   * @returns {Promise}
   */
  // eslint-disable-next-line require-await
  async parse(e) {
    let t = e.data;
    if (Me.Buffer.isBuffer(t) && (t = t.toString()), typeof t == "string") {
      if (t.trim().length === 0)
        return;
      try {
        return JSON.parse(t);
      } catch (r) {
        throw new _D(r.message, e.url);
      }
    }
    return t;
  }
};
const { ParserError: $D } = or, ED = /\.(txt|htm|html|md|xml|js|min|map|css|scss|less|svg)$/i;
var xD = {
  /**
   * The order that this parser will run, in relation to other parsers.
   *
   * @type {number}
   */
  order: 300,
  /**
   * Whether to allow "empty" files (zero bytes).
   *
   * @type {boolean}
   */
  allowEmpty: !0,
  /**
   * The encoding that the text is expected to be in.
   *
   * @type {string}
   */
  encoding: "utf8",
  /**
   * Determines whether this parser can parse a given file reference.
   * Parsers that return true will be tried, in order, until one successfully parses the file.
   * Parsers that return false will be skipped, UNLESS all parsers returned false, in which case
   * every parser will be tried.
   *
   * @param {object} file           - An object containing information about the referenced file
   * @param {string} file.url       - The full URL of the referenced file
   * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
   * @returns {boolean}
   */
  canParse(e) {
    return (typeof e.data == "string" || Me.Buffer.isBuffer(e.data)) && ED.test(e.url);
  },
  /**
   * Parses the given file as text
   *
   * @param {object} file           - An object containing information about the referenced file
   * @param {string} file.url       - The full URL of the referenced file
   * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
   * @returns {string}
   */
  parse(e) {
    if (typeof e.data == "string")
      return e.data;
    if (Me.Buffer.isBuffer(e.data))
      return e.data.toString(this.encoding);
    throw new $D("data is not text", e.url);
  }
}, _r = {}, Rg = {}, Dn = {};
function Rx(e) {
  return typeof e > "u" || e === null;
}
function OD(e) {
  return typeof e == "object" && e !== null;
}
function PD(e) {
  return Array.isArray(e) ? e : Rx(e) ? [] : [e];
}
function SD(e, t) {
  var r, n, i, s;
  if (t)
    for (s = Object.keys(t), r = 0, n = s.length; r < n; r += 1)
      i = s[r], e[i] = t[i];
  return e;
}
function AD(e, t) {
  var r = "", n;
  for (n = 0; n < t; n += 1)
    r += e;
  return r;
}
function CD(e) {
  return e === 0 && Number.NEGATIVE_INFINITY === 1 / e;
}
Dn.isNothing = Rx;
Dn.isObject = OD;
Dn.toArray = PD;
Dn.repeat = AD;
Dn.isNegativeZero = CD;
Dn.extend = SD;
function Tx(e, t) {
  var r = "", n = e.reason || "(unknown reason)";
  return e.mark ? (e.mark.name && (r += 'in "' + e.mark.name + '" '), r += "(" + (e.mark.line + 1) + ":" + (e.mark.column + 1) + ")", !t && e.mark.snippet && (r += `

` + e.mark.snippet), n + " " + r) : n;
}
function ku(e, t) {
  Error.call(this), this.name = "YAMLException", this.reason = e, this.mark = t, this.message = Tx(this, !1), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack || "";
}
ku.prototype = Object.create(Error.prototype);
ku.prototype.constructor = ku;
ku.prototype.toString = function(t) {
  return this.name + ": " + Tx(this, t);
};
var Qu = ku, ru = Dn;
function Fp(e, t, r, n, i) {
  var s = "", a = "", u = Math.floor(i / 2) - 1;
  return n - t > u && (s = " ... ", t = n - u + s.length), r - n > u && (a = " ...", r = n + u - a.length), {
    str: s + e.slice(t, r).replace(/\t/g, "") + a,
    pos: n - t + s.length
    // relative position
  };
}
function Up(e, t) {
  return ru.repeat(" ", t - e.length) + e;
}
function RD(e, t) {
  if (t = Object.create(t || null), !e.buffer)
    return null;
  t.maxLength || (t.maxLength = 79), typeof t.indent != "number" && (t.indent = 1), typeof t.linesBefore != "number" && (t.linesBefore = 3), typeof t.linesAfter != "number" && (t.linesAfter = 2);
  for (var r = /\r?\n|\r|\0/g, n = [0], i = [], s, a = -1; s = r.exec(e.buffer); )
    i.push(s.index), n.push(s.index + s[0].length), e.position <= s.index && a < 0 && (a = n.length - 2);
  a < 0 && (a = n.length - 1);
  var u = "", c, l, d = Math.min(e.line + t.linesAfter, i.length).toString().length, p = t.maxLength - (t.indent + d + 3);
  for (c = 1; c <= t.linesBefore && !(a - c < 0); c++)
    l = Fp(
      e.buffer,
      n[a - c],
      i[a - c],
      e.position - (n[a] - n[a - c]),
      p
    ), u = ru.repeat(" ", t.indent) + Up((e.line - c + 1).toString(), d) + " | " + l.str + `
` + u;
  for (l = Fp(e.buffer, n[a], i[a], e.position, p), u += ru.repeat(" ", t.indent) + Up((e.line + 1).toString(), d) + " | " + l.str + `
`, u += ru.repeat("-", t.indent + d + 3 + l.pos) + `^
`, c = 1; c <= t.linesAfter && !(a + c >= i.length); c++)
    l = Fp(
      e.buffer,
      n[a + c],
      i[a + c],
      e.position - (n[a] - n[a + c]),
      p
    ), u += ru.repeat(" ", t.indent) + Up((e.line + c + 1).toString(), d) + " | " + l.str + `
`;
  return u.replace(/\n$/, "");
}
var TD = RD, U1 = Qu, ID = [
  "kind",
  "multi",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "representName",
  "defaultStyle",
  "styleAliases"
], jD = [
  "scalar",
  "sequence",
  "mapping"
];
function kD(e) {
  var t = {};
  return e !== null && Object.keys(e).forEach(function(r) {
    e[r].forEach(function(n) {
      t[String(n)] = r;
    });
  }), t;
}
function MD(e, t) {
  if (t = t || {}, Object.keys(t).forEach(function(r) {
    if (ID.indexOf(r) === -1)
      throw new U1('Unknown option "' + r + '" is met in definition of "' + e + '" YAML type.');
  }), this.options = t, this.tag = e, this.kind = t.kind || null, this.resolve = t.resolve || function() {
    return !0;
  }, this.construct = t.construct || function(r) {
    return r;
  }, this.instanceOf = t.instanceOf || null, this.predicate = t.predicate || null, this.represent = t.represent || null, this.representName = t.representName || null, this.defaultStyle = t.defaultStyle || null, this.multi = t.multi || !1, this.styleAliases = kD(t.styleAliases || null), jD.indexOf(this.kind) === -1)
    throw new U1('Unknown kind "' + this.kind + '" is specified for "' + e + '" YAML type.');
}
var Fr = MD, Zo = Qu, Bp = Fr;
function B1(e, t) {
  var r = [];
  return e[t].forEach(function(n) {
    var i = r.length;
    r.forEach(function(s, a) {
      s.tag === n.tag && s.kind === n.kind && s.multi === n.multi && (i = a);
    }), r[i] = n;
  }), r;
}
function ND() {
  var e = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, t, r;
  function n(i) {
    i.multi ? (e.multi[i.kind].push(i), e.multi.fallback.push(i)) : e[i.kind][i.tag] = e.fallback[i.tag] = i;
  }
  for (t = 0, r = arguments.length; t < r; t += 1)
    arguments[t].forEach(n);
  return e;
}
function Ey(e) {
  return this.extend(e);
}
Ey.prototype.extend = function(t) {
  var r = [], n = [];
  if (t instanceof Bp)
    n.push(t);
  else if (Array.isArray(t))
    n = n.concat(t);
  else if (t && (Array.isArray(t.implicit) || Array.isArray(t.explicit)))
    t.implicit && (r = r.concat(t.implicit)), t.explicit && (n = n.concat(t.explicit));
  else
    throw new Zo("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  r.forEach(function(s) {
    if (!(s instanceof Bp))
      throw new Zo("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    if (s.loadKind && s.loadKind !== "scalar")
      throw new Zo("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    if (s.multi)
      throw new Zo("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
  }), n.forEach(function(s) {
    if (!(s instanceof Bp))
      throw new Zo("Specified list of YAML types (or a single Type object) contains a non-Type object.");
  });
  var i = Object.create(Ey.prototype);
  return i.implicit = (this.implicit || []).concat(r), i.explicit = (this.explicit || []).concat(n), i.compiledImplicit = B1(i, "implicit"), i.compiledExplicit = B1(i, "explicit"), i.compiledTypeMap = ND(i.compiledImplicit, i.compiledExplicit), i;
};
var Ix = Ey, DD = Fr, jx = new DD("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: function(e) {
    return e !== null ? e : "";
  }
}), LD = Fr, kx = new LD("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: function(e) {
    return e !== null ? e : [];
  }
}), qD = Fr, Mx = new qD("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: function(e) {
    return e !== null ? e : {};
  }
}), FD = Ix, Nx = new FD({
  explicit: [
    jx,
    kx,
    Mx
  ]
}), UD = Fr;
function BD(e) {
  if (e === null)
    return !0;
  var t = e.length;
  return t === 1 && e === "~" || t === 4 && (e === "null" || e === "Null" || e === "NULL");
}
function VD() {
  return null;
}
function ZD(e) {
  return e === null;
}
var Dx = new UD("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: BD,
  construct: VD,
  predicate: ZD,
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    },
    empty: function() {
      return "";
    }
  },
  defaultStyle: "lowercase"
}), zD = Fr;
function WD(e) {
  if (e === null)
    return !1;
  var t = e.length;
  return t === 4 && (e === "true" || e === "True" || e === "TRUE") || t === 5 && (e === "false" || e === "False" || e === "FALSE");
}
function HD(e) {
  return e === "true" || e === "True" || e === "TRUE";
}
function GD(e) {
  return Object.prototype.toString.call(e) === "[object Boolean]";
}
var Lx = new zD("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: WD,
  construct: HD,
  predicate: GD,
  represent: {
    lowercase: function(e) {
      return e ? "true" : "false";
    },
    uppercase: function(e) {
      return e ? "TRUE" : "FALSE";
    },
    camelcase: function(e) {
      return e ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
}), KD = Dn, YD = Fr;
function JD(e) {
  return 48 <= e && e <= 57 || 65 <= e && e <= 70 || 97 <= e && e <= 102;
}
function XD(e) {
  return 48 <= e && e <= 55;
}
function QD(e) {
  return 48 <= e && e <= 57;
}
function eL(e) {
  if (e === null)
    return !1;
  var t = e.length, r = 0, n = !1, i;
  if (!t)
    return !1;
  if (i = e[r], (i === "-" || i === "+") && (i = e[++r]), i === "0") {
    if (r + 1 === t)
      return !0;
    if (i = e[++r], i === "b") {
      for (r++; r < t; r++)
        if (i = e[r], i !== "_") {
          if (i !== "0" && i !== "1")
            return !1;
          n = !0;
        }
      return n && i !== "_";
    }
    if (i === "x") {
      for (r++; r < t; r++)
        if (i = e[r], i !== "_") {
          if (!JD(e.charCodeAt(r)))
            return !1;
          n = !0;
        }
      return n && i !== "_";
    }
    if (i === "o") {
      for (r++; r < t; r++)
        if (i = e[r], i !== "_") {
          if (!XD(e.charCodeAt(r)))
            return !1;
          n = !0;
        }
      return n && i !== "_";
    }
  }
  if (i === "_")
    return !1;
  for (; r < t; r++)
    if (i = e[r], i !== "_") {
      if (!QD(e.charCodeAt(r)))
        return !1;
      n = !0;
    }
  return !(!n || i === "_");
}
function tL(e) {
  var t = e, r = 1, n;
  if (t.indexOf("_") !== -1 && (t = t.replace(/_/g, "")), n = t[0], (n === "-" || n === "+") && (n === "-" && (r = -1), t = t.slice(1), n = t[0]), t === "0")
    return 0;
  if (n === "0") {
    if (t[1] === "b")
      return r * parseInt(t.slice(2), 2);
    if (t[1] === "x")
      return r * parseInt(t.slice(2), 16);
    if (t[1] === "o")
      return r * parseInt(t.slice(2), 8);
  }
  return r * parseInt(t, 10);
}
function rL(e) {
  return Object.prototype.toString.call(e) === "[object Number]" && e % 1 === 0 && !KD.isNegativeZero(e);
}
var qx = new YD("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: eL,
  construct: tL,
  predicate: rL,
  represent: {
    binary: function(e) {
      return e >= 0 ? "0b" + e.toString(2) : "-0b" + e.toString(2).slice(1);
    },
    octal: function(e) {
      return e >= 0 ? "0o" + e.toString(8) : "-0o" + e.toString(8).slice(1);
    },
    decimal: function(e) {
      return e.toString(10);
    },
    /* eslint-disable max-len */
    hexadecimal: function(e) {
      return e >= 0 ? "0x" + e.toString(16).toUpperCase() : "-0x" + e.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
}), Fx = Dn, nL = Fr, iL = new RegExp(
  // 2.5e4, 2.5 and integers
  "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function sL(e) {
  return !(e === null || !iL.test(e) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  e[e.length - 1] === "_");
}
function aL(e) {
  var t, r;
  return t = e.replace(/_/g, "").toLowerCase(), r = t[0] === "-" ? -1 : 1, "+-".indexOf(t[0]) >= 0 && (t = t.slice(1)), t === ".inf" ? r === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY : t === ".nan" ? NaN : r * parseFloat(t, 10);
}
var oL = /^[-+]?[0-9]+e/;
function uL(e, t) {
  var r;
  if (isNaN(e))
    switch (t) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  else if (Number.POSITIVE_INFINITY === e)
    switch (t) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  else if (Number.NEGATIVE_INFINITY === e)
    switch (t) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  else if (Fx.isNegativeZero(e))
    return "-0.0";
  return r = e.toString(10), oL.test(r) ? r.replace("e", ".e") : r;
}
function cL(e) {
  return Object.prototype.toString.call(e) === "[object Number]" && (e % 1 !== 0 || Fx.isNegativeZero(e));
}
var Ux = new nL("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: sL,
  construct: aL,
  predicate: cL,
  represent: uL,
  defaultStyle: "lowercase"
}), Bx = Nx.extend({
  implicit: [
    Dx,
    Lx,
    qx,
    Ux
  ]
}), Vx = Bx, lL = Fr, Zx = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
), zx = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
);
function fL(e) {
  return e === null ? !1 : Zx.exec(e) !== null || zx.exec(e) !== null;
}
function dL(e) {
  var t, r, n, i, s, a, u, c = 0, l = null, d, p, h;
  if (t = Zx.exec(e), t === null && (t = zx.exec(e)), t === null)
    throw new Error("Date resolve error");
  if (r = +t[1], n = +t[2] - 1, i = +t[3], !t[4])
    return new Date(Date.UTC(r, n, i));
  if (s = +t[4], a = +t[5], u = +t[6], t[7]) {
    for (c = t[7].slice(0, 3); c.length < 3; )
      c += "0";
    c = +c;
  }
  return t[9] && (d = +t[10], p = +(t[11] || 0), l = (d * 60 + p) * 6e4, t[9] === "-" && (l = -l)), h = new Date(Date.UTC(r, n, i, s, a, u, c)), l && h.setTime(h.getTime() - l), h;
}
function pL(e) {
  return e.toISOString();
}
var Wx = new lL("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: fL,
  construct: dL,
  instanceOf: Date,
  represent: pL
}), hL = Fr;
function mL(e) {
  return e === "<<" || e === null;
}
var Hx = new hL("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: mL
}), yL = Fr, Tg = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`;
function gL(e) {
  if (e === null)
    return !1;
  var t, r, n = 0, i = e.length, s = Tg;
  for (r = 0; r < i; r++)
    if (t = s.indexOf(e.charAt(r)), !(t > 64)) {
      if (t < 0)
        return !1;
      n += 6;
    }
  return n % 8 === 0;
}
function vL(e) {
  var t, r, n = e.replace(/[\r\n=]/g, ""), i = n.length, s = Tg, a = 0, u = [];
  for (t = 0; t < i; t++)
    t % 4 === 0 && t && (u.push(a >> 16 & 255), u.push(a >> 8 & 255), u.push(a & 255)), a = a << 6 | s.indexOf(n.charAt(t));
  return r = i % 4 * 6, r === 0 ? (u.push(a >> 16 & 255), u.push(a >> 8 & 255), u.push(a & 255)) : r === 18 ? (u.push(a >> 10 & 255), u.push(a >> 2 & 255)) : r === 12 && u.push(a >> 4 & 255), new Uint8Array(u);
}
function bL(e) {
  var t = "", r = 0, n, i, s = e.length, a = Tg;
  for (n = 0; n < s; n++)
    n % 3 === 0 && n && (t += a[r >> 18 & 63], t += a[r >> 12 & 63], t += a[r >> 6 & 63], t += a[r & 63]), r = (r << 8) + e[n];
  return i = s % 3, i === 0 ? (t += a[r >> 18 & 63], t += a[r >> 12 & 63], t += a[r >> 6 & 63], t += a[r & 63]) : i === 2 ? (t += a[r >> 10 & 63], t += a[r >> 4 & 63], t += a[r << 2 & 63], t += a[64]) : i === 1 && (t += a[r >> 2 & 63], t += a[r << 4 & 63], t += a[64], t += a[64]), t;
}
function _L(e) {
  return Object.prototype.toString.call(e) === "[object Uint8Array]";
}
var Gx = new yL("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: gL,
  construct: vL,
  predicate: _L,
  represent: bL
}), wL = Fr, $L = Object.prototype.hasOwnProperty, EL = Object.prototype.toString;
function xL(e) {
  if (e === null)
    return !0;
  var t = [], r, n, i, s, a, u = e;
  for (r = 0, n = u.length; r < n; r += 1) {
    if (i = u[r], a = !1, EL.call(i) !== "[object Object]")
      return !1;
    for (s in i)
      if ($L.call(i, s))
        if (!a)
          a = !0;
        else
          return !1;
    if (!a)
      return !1;
    if (t.indexOf(s) === -1)
      t.push(s);
    else
      return !1;
  }
  return !0;
}
function OL(e) {
  return e !== null ? e : [];
}
var Kx = new wL("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: xL,
  construct: OL
}), PL = Fr, SL = Object.prototype.toString;
function AL(e) {
  if (e === null)
    return !0;
  var t, r, n, i, s, a = e;
  for (s = new Array(a.length), t = 0, r = a.length; t < r; t += 1) {
    if (n = a[t], SL.call(n) !== "[object Object]" || (i = Object.keys(n), i.length !== 1))
      return !1;
    s[t] = [i[0], n[i[0]]];
  }
  return !0;
}
function CL(e) {
  if (e === null)
    return [];
  var t, r, n, i, s, a = e;
  for (s = new Array(a.length), t = 0, r = a.length; t < r; t += 1)
    n = a[t], i = Object.keys(n), s[t] = [i[0], n[i[0]]];
  return s;
}
var Yx = new PL("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: AL,
  construct: CL
}), RL = Fr, TL = Object.prototype.hasOwnProperty;
function IL(e) {
  if (e === null)
    return !0;
  var t, r = e;
  for (t in r)
    if (TL.call(r, t) && r[t] !== null)
      return !1;
  return !0;
}
function jL(e) {
  return e !== null ? e : {};
}
var Jx = new RL("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: IL,
  construct: jL
}), Ig = Vx.extend({
  implicit: [
    Wx,
    Hx
  ],
  explicit: [
    Gx,
    Kx,
    Yx,
    Jx
  ]
}), Ds = Dn, Xx = Qu, kL = TD, ML = Ig, hs = Object.prototype.hasOwnProperty, lf = 1, Qx = 2, eO = 3, ff = 4, Vp = 1, NL = 2, V1 = 3, DL = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, LL = /[\x85\u2028\u2029]/, qL = /[,\[\]\{\}]/, tO = /^(?:!|!!|![a-z\-]+!)$/i, rO = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function Z1(e) {
  return Object.prototype.toString.call(e);
}
function ti(e) {
  return e === 10 || e === 13;
}
function Gs(e) {
  return e === 9 || e === 32;
}
function Hr(e) {
  return e === 9 || e === 32 || e === 10 || e === 13;
}
function Ba(e) {
  return e === 44 || e === 91 || e === 93 || e === 123 || e === 125;
}
function FL(e) {
  var t;
  return 48 <= e && e <= 57 ? e - 48 : (t = e | 32, 97 <= t && t <= 102 ? t - 97 + 10 : -1);
}
function UL(e) {
  return e === 120 ? 2 : e === 117 ? 4 : e === 85 ? 8 : 0;
}
function BL(e) {
  return 48 <= e && e <= 57 ? e - 48 : -1;
}
function z1(e) {
  return e === 48 ? "\0" : e === 97 ? "\x07" : e === 98 ? "\b" : e === 116 || e === 9 ? "	" : e === 110 ? `
` : e === 118 ? "\v" : e === 102 ? "\f" : e === 114 ? "\r" : e === 101 ? "\x1B" : e === 32 ? " " : e === 34 ? '"' : e === 47 ? "/" : e === 92 ? "\\" : e === 78 ? "" : e === 95 ? "" : e === 76 ? "\u2028" : e === 80 ? "\u2029" : "";
}
function VL(e) {
  return e <= 65535 ? String.fromCharCode(e) : String.fromCharCode(
    (e - 65536 >> 10) + 55296,
    (e - 65536 & 1023) + 56320
  );
}
var nO = new Array(256), iO = new Array(256);
for (var Aa = 0; Aa < 256; Aa++)
  nO[Aa] = z1(Aa) ? 1 : 0, iO[Aa] = z1(Aa);
function ZL(e, t) {
  this.input = e, this.filename = t.filename || null, this.schema = t.schema || ML, this.onWarning = t.onWarning || null, this.legacy = t.legacy || !1, this.json = t.json || !1, this.listener = t.listener || null, this.implicitTypes = this.schema.compiledImplicit, this.typeMap = this.schema.compiledTypeMap, this.length = e.length, this.position = 0, this.line = 0, this.lineStart = 0, this.lineIndent = 0, this.firstTabInLine = -1, this.documents = [];
}
function sO(e, t) {
  var r = {
    name: e.filename,
    buffer: e.input.slice(0, -1),
    // omit trailing \0
    position: e.position,
    line: e.line,
    column: e.position - e.lineStart
  };
  return r.snippet = kL(r), new Xx(t, r);
}
function et(e, t) {
  throw sO(e, t);
}
function df(e, t) {
  e.onWarning && e.onWarning.call(null, sO(e, t));
}
var W1 = {
  YAML: function(t, r, n) {
    var i, s, a;
    t.version !== null && et(t, "duplication of %YAML directive"), n.length !== 1 && et(t, "YAML directive accepts exactly one argument"), i = /^([0-9]+)\.([0-9]+)$/.exec(n[0]), i === null && et(t, "ill-formed argument of the YAML directive"), s = parseInt(i[1], 10), a = parseInt(i[2], 10), s !== 1 && et(t, "unacceptable YAML version of the document"), t.version = n[0], t.checkLineBreaks = a < 2, a !== 1 && a !== 2 && df(t, "unsupported YAML version of the document");
  },
  TAG: function(t, r, n) {
    var i, s;
    n.length !== 2 && et(t, "TAG directive accepts exactly two arguments"), i = n[0], s = n[1], tO.test(i) || et(t, "ill-formed tag handle (first argument) of the TAG directive"), hs.call(t.tagMap, i) && et(t, 'there is a previously declared suffix for "' + i + '" tag handle'), rO.test(s) || et(t, "ill-formed tag prefix (second argument) of the TAG directive");
    try {
      s = decodeURIComponent(s);
    } catch {
      et(t, "tag prefix is malformed: " + s);
    }
    t.tagMap[i] = s;
  }
};
function os(e, t, r, n) {
  var i, s, a, u;
  if (t < r) {
    if (u = e.input.slice(t, r), n)
      for (i = 0, s = u.length; i < s; i += 1)
        a = u.charCodeAt(i), a === 9 || 32 <= a && a <= 1114111 || et(e, "expected valid JSON character");
    else
      DL.test(u) && et(e, "the stream contains non-printable characters");
    e.result += u;
  }
}
function H1(e, t, r, n) {
  var i, s, a, u;
  for (Ds.isObject(r) || et(e, "cannot merge mappings; the provided source object is unacceptable"), i = Object.keys(r), a = 0, u = i.length; a < u; a += 1)
    s = i[a], hs.call(t, s) || (t[s] = r[s], n[s] = !0);
}
function Va(e, t, r, n, i, s, a, u, c) {
  var l, d;
  if (Array.isArray(i))
    for (i = Array.prototype.slice.call(i), l = 0, d = i.length; l < d; l += 1)
      Array.isArray(i[l]) && et(e, "nested arrays are not supported inside keys"), typeof i == "object" && Z1(i[l]) === "[object Object]" && (i[l] = "[object Object]");
  if (typeof i == "object" && Z1(i) === "[object Object]" && (i = "[object Object]"), i = String(i), t === null && (t = {}), n === "tag:yaml.org,2002:merge")
    if (Array.isArray(s))
      for (l = 0, d = s.length; l < d; l += 1)
        H1(e, t, s[l], r);
    else
      H1(e, t, s, r);
  else
    !e.json && !hs.call(r, i) && hs.call(t, i) && (e.line = a || e.line, e.lineStart = u || e.lineStart, e.position = c || e.position, et(e, "duplicated mapping key")), i === "__proto__" ? Object.defineProperty(t, i, {
      configurable: !0,
      enumerable: !0,
      writable: !0,
      value: s
    }) : t[i] = s, delete r[i];
  return t;
}
function jg(e) {
  var t;
  t = e.input.charCodeAt(e.position), t === 10 ? e.position++ : t === 13 ? (e.position++, e.input.charCodeAt(e.position) === 10 && e.position++) : et(e, "a line break is expected"), e.line += 1, e.lineStart = e.position, e.firstTabInLine = -1;
}
function ar(e, t, r) {
  for (var n = 0, i = e.input.charCodeAt(e.position); i !== 0; ) {
    for (; Gs(i); )
      i === 9 && e.firstTabInLine === -1 && (e.firstTabInLine = e.position), i = e.input.charCodeAt(++e.position);
    if (t && i === 35)
      do
        i = e.input.charCodeAt(++e.position);
      while (i !== 10 && i !== 13 && i !== 0);
    if (ti(i))
      for (jg(e), i = e.input.charCodeAt(e.position), n++, e.lineIndent = 0; i === 32; )
        e.lineIndent++, i = e.input.charCodeAt(++e.position);
    else
      break;
  }
  return r !== -1 && n !== 0 && e.lineIndent < r && df(e, "deficient indentation"), n;
}
function Zf(e) {
  var t = e.position, r;
  return r = e.input.charCodeAt(t), !!((r === 45 || r === 46) && r === e.input.charCodeAt(t + 1) && r === e.input.charCodeAt(t + 2) && (t += 3, r = e.input.charCodeAt(t), r === 0 || Hr(r)));
}
function kg(e, t) {
  t === 1 ? e.result += " " : t > 1 && (e.result += Ds.repeat(`
`, t - 1));
}
function zL(e, t, r) {
  var n, i, s, a, u, c, l, d, p = e.kind, h = e.result, v;
  if (v = e.input.charCodeAt(e.position), Hr(v) || Ba(v) || v === 35 || v === 38 || v === 42 || v === 33 || v === 124 || v === 62 || v === 39 || v === 34 || v === 37 || v === 64 || v === 96 || (v === 63 || v === 45) && (i = e.input.charCodeAt(e.position + 1), Hr(i) || r && Ba(i)))
    return !1;
  for (e.kind = "scalar", e.result = "", s = a = e.position, u = !1; v !== 0; ) {
    if (v === 58) {
      if (i = e.input.charCodeAt(e.position + 1), Hr(i) || r && Ba(i))
        break;
    } else if (v === 35) {
      if (n = e.input.charCodeAt(e.position - 1), Hr(n))
        break;
    } else {
      if (e.position === e.lineStart && Zf(e) || r && Ba(v))
        break;
      if (ti(v))
        if (c = e.line, l = e.lineStart, d = e.lineIndent, ar(e, !1, -1), e.lineIndent >= t) {
          u = !0, v = e.input.charCodeAt(e.position);
          continue;
        } else {
          e.position = a, e.line = c, e.lineStart = l, e.lineIndent = d;
          break;
        }
    }
    u && (os(e, s, a, !1), kg(e, e.line - c), s = a = e.position, u = !1), Gs(v) || (a = e.position + 1), v = e.input.charCodeAt(++e.position);
  }
  return os(e, s, a, !1), e.result ? !0 : (e.kind = p, e.result = h, !1);
}
function WL(e, t) {
  var r, n, i;
  if (r = e.input.charCodeAt(e.position), r !== 39)
    return !1;
  for (e.kind = "scalar", e.result = "", e.position++, n = i = e.position; (r = e.input.charCodeAt(e.position)) !== 0; )
    if (r === 39)
      if (os(e, n, e.position, !0), r = e.input.charCodeAt(++e.position), r === 39)
        n = e.position, e.position++, i = e.position;
      else
        return !0;
    else
      ti(r) ? (os(e, n, i, !0), kg(e, ar(e, !1, t)), n = i = e.position) : e.position === e.lineStart && Zf(e) ? et(e, "unexpected end of the document within a single quoted scalar") : (e.position++, i = e.position);
  et(e, "unexpected end of the stream within a single quoted scalar");
}
function HL(e, t) {
  var r, n, i, s, a, u;
  if (u = e.input.charCodeAt(e.position), u !== 34)
    return !1;
  for (e.kind = "scalar", e.result = "", e.position++, r = n = e.position; (u = e.input.charCodeAt(e.position)) !== 0; ) {
    if (u === 34)
      return os(e, r, e.position, !0), e.position++, !0;
    if (u === 92) {
      if (os(e, r, e.position, !0), u = e.input.charCodeAt(++e.position), ti(u))
        ar(e, !1, t);
      else if (u < 256 && nO[u])
        e.result += iO[u], e.position++;
      else if ((a = UL(u)) > 0) {
        for (i = a, s = 0; i > 0; i--)
          u = e.input.charCodeAt(++e.position), (a = FL(u)) >= 0 ? s = (s << 4) + a : et(e, "expected hexadecimal character");
        e.result += VL(s), e.position++;
      } else
        et(e, "unknown escape sequence");
      r = n = e.position;
    } else
      ti(u) ? (os(e, r, n, !0), kg(e, ar(e, !1, t)), r = n = e.position) : e.position === e.lineStart && Zf(e) ? et(e, "unexpected end of the document within a double quoted scalar") : (e.position++, n = e.position);
  }
  et(e, "unexpected end of the stream within a double quoted scalar");
}
function GL(e, t) {
  var r = !0, n, i, s, a = e.tag, u, c = e.anchor, l, d, p, h, v, y = /* @__PURE__ */ Object.create(null), g, _, m, w;
  if (w = e.input.charCodeAt(e.position), w === 91)
    d = 93, v = !1, u = [];
  else if (w === 123)
    d = 125, v = !0, u = {};
  else
    return !1;
  for (e.anchor !== null && (e.anchorMap[e.anchor] = u), w = e.input.charCodeAt(++e.position); w !== 0; ) {
    if (ar(e, !0, t), w = e.input.charCodeAt(e.position), w === d)
      return e.position++, e.tag = a, e.anchor = c, e.kind = v ? "mapping" : "sequence", e.result = u, !0;
    r ? w === 44 && et(e, "expected the node content, but found ','") : et(e, "missed comma between flow collection entries"), _ = g = m = null, p = h = !1, w === 63 && (l = e.input.charCodeAt(e.position + 1), Hr(l) && (p = h = !0, e.position++, ar(e, !0, t))), n = e.line, i = e.lineStart, s = e.position, io(e, t, lf, !1, !0), _ = e.tag, g = e.result, ar(e, !0, t), w = e.input.charCodeAt(e.position), (h || e.line === n) && w === 58 && (p = !0, w = e.input.charCodeAt(++e.position), ar(e, !0, t), io(e, t, lf, !1, !0), m = e.result), v ? Va(e, u, y, _, g, m, n, i, s) : p ? u.push(Va(e, null, y, _, g, m, n, i, s)) : u.push(g), ar(e, !0, t), w = e.input.charCodeAt(e.position), w === 44 ? (r = !0, w = e.input.charCodeAt(++e.position)) : r = !1;
  }
  et(e, "unexpected end of the stream within a flow collection");
}
function KL(e, t) {
  var r, n, i = Vp, s = !1, a = !1, u = t, c = 0, l = !1, d, p;
  if (p = e.input.charCodeAt(e.position), p === 124)
    n = !1;
  else if (p === 62)
    n = !0;
  else
    return !1;
  for (e.kind = "scalar", e.result = ""; p !== 0; )
    if (p = e.input.charCodeAt(++e.position), p === 43 || p === 45)
      Vp === i ? i = p === 43 ? V1 : NL : et(e, "repeat of a chomping mode identifier");
    else if ((d = BL(p)) >= 0)
      d === 0 ? et(e, "bad explicit indentation width of a block scalar; it cannot be less than one") : a ? et(e, "repeat of an indentation width identifier") : (u = t + d - 1, a = !0);
    else
      break;
  if (Gs(p)) {
    do
      p = e.input.charCodeAt(++e.position);
    while (Gs(p));
    if (p === 35)
      do
        p = e.input.charCodeAt(++e.position);
      while (!ti(p) && p !== 0);
  }
  for (; p !== 0; ) {
    for (jg(e), e.lineIndent = 0, p = e.input.charCodeAt(e.position); (!a || e.lineIndent < u) && p === 32; )
      e.lineIndent++, p = e.input.charCodeAt(++e.position);
    if (!a && e.lineIndent > u && (u = e.lineIndent), ti(p)) {
      c++;
      continue;
    }
    if (e.lineIndent < u) {
      i === V1 ? e.result += Ds.repeat(`
`, s ? 1 + c : c) : i === Vp && s && (e.result += `
`);
      break;
    }
    for (n ? Gs(p) ? (l = !0, e.result += Ds.repeat(`
`, s ? 1 + c : c)) : l ? (l = !1, e.result += Ds.repeat(`
`, c + 1)) : c === 0 ? s && (e.result += " ") : e.result += Ds.repeat(`
`, c) : e.result += Ds.repeat(`
`, s ? 1 + c : c), s = !0, a = !0, c = 0, r = e.position; !ti(p) && p !== 0; )
      p = e.input.charCodeAt(++e.position);
    os(e, r, e.position, !1);
  }
  return !0;
}
function G1(e, t) {
  var r, n = e.tag, i = e.anchor, s = [], a, u = !1, c;
  if (e.firstTabInLine !== -1)
    return !1;
  for (e.anchor !== null && (e.anchorMap[e.anchor] = s), c = e.input.charCodeAt(e.position); c !== 0 && (e.firstTabInLine !== -1 && (e.position = e.firstTabInLine, et(e, "tab characters must not be used in indentation")), !(c !== 45 || (a = e.input.charCodeAt(e.position + 1), !Hr(a)))); ) {
    if (u = !0, e.position++, ar(e, !0, -1) && e.lineIndent <= t) {
      s.push(null), c = e.input.charCodeAt(e.position);
      continue;
    }
    if (r = e.line, io(e, t, eO, !1, !0), s.push(e.result), ar(e, !0, -1), c = e.input.charCodeAt(e.position), (e.line === r || e.lineIndent > t) && c !== 0)
      et(e, "bad indentation of a sequence entry");
    else if (e.lineIndent < t)
      break;
  }
  return u ? (e.tag = n, e.anchor = i, e.kind = "sequence", e.result = s, !0) : !1;
}
function YL(e, t, r) {
  var n, i, s, a, u, c, l = e.tag, d = e.anchor, p = {}, h = /* @__PURE__ */ Object.create(null), v = null, y = null, g = null, _ = !1, m = !1, w;
  if (e.firstTabInLine !== -1)
    return !1;
  for (e.anchor !== null && (e.anchorMap[e.anchor] = p), w = e.input.charCodeAt(e.position); w !== 0; ) {
    if (!_ && e.firstTabInLine !== -1 && (e.position = e.firstTabInLine, et(e, "tab characters must not be used in indentation")), n = e.input.charCodeAt(e.position + 1), s = e.line, (w === 63 || w === 58) && Hr(n))
      w === 63 ? (_ && (Va(e, p, h, v, y, null, a, u, c), v = y = g = null), m = !0, _ = !0, i = !0) : _ ? (_ = !1, i = !0) : et(e, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"), e.position += 1, w = n;
    else {
      if (a = e.line, u = e.lineStart, c = e.position, !io(e, r, Qx, !1, !0))
        break;
      if (e.line === s) {
        for (w = e.input.charCodeAt(e.position); Gs(w); )
          w = e.input.charCodeAt(++e.position);
        if (w === 58)
          w = e.input.charCodeAt(++e.position), Hr(w) || et(e, "a whitespace character is expected after the key-value separator within a block mapping"), _ && (Va(e, p, h, v, y, null, a, u, c), v = y = g = null), m = !0, _ = !1, i = !1, v = e.tag, y = e.result;
        else if (m)
          et(e, "can not read an implicit mapping pair; a colon is missed");
        else
          return e.tag = l, e.anchor = d, !0;
      } else if (m)
        et(e, "can not read a block mapping entry; a multiline key may not be an implicit key");
      else
        return e.tag = l, e.anchor = d, !0;
    }
    if ((e.line === s || e.lineIndent > t) && (_ && (a = e.line, u = e.lineStart, c = e.position), io(e, t, ff, !0, i) && (_ ? y = e.result : g = e.result), _ || (Va(e, p, h, v, y, g, a, u, c), v = y = g = null), ar(e, !0, -1), w = e.input.charCodeAt(e.position)), (e.line === s || e.lineIndent > t) && w !== 0)
      et(e, "bad indentation of a mapping entry");
    else if (e.lineIndent < t)
      break;
  }
  return _ && Va(e, p, h, v, y, null, a, u, c), m && (e.tag = l, e.anchor = d, e.kind = "mapping", e.result = p), m;
}
function JL(e) {
  var t, r = !1, n = !1, i, s, a;
  if (a = e.input.charCodeAt(e.position), a !== 33)
    return !1;
  if (e.tag !== null && et(e, "duplication of a tag property"), a = e.input.charCodeAt(++e.position), a === 60 ? (r = !0, a = e.input.charCodeAt(++e.position)) : a === 33 ? (n = !0, i = "!!", a = e.input.charCodeAt(++e.position)) : i = "!", t = e.position, r) {
    do
      a = e.input.charCodeAt(++e.position);
    while (a !== 0 && a !== 62);
    e.position < e.length ? (s = e.input.slice(t, e.position), a = e.input.charCodeAt(++e.position)) : et(e, "unexpected end of the stream within a verbatim tag");
  } else {
    for (; a !== 0 && !Hr(a); )
      a === 33 && (n ? et(e, "tag suffix cannot contain exclamation marks") : (i = e.input.slice(t - 1, e.position + 1), tO.test(i) || et(e, "named tag handle cannot contain such characters"), n = !0, t = e.position + 1)), a = e.input.charCodeAt(++e.position);
    s = e.input.slice(t, e.position), qL.test(s) && et(e, "tag suffix cannot contain flow indicator characters");
  }
  s && !rO.test(s) && et(e, "tag name cannot contain such characters: " + s);
  try {
    s = decodeURIComponent(s);
  } catch {
    et(e, "tag name is malformed: " + s);
  }
  return r ? e.tag = s : hs.call(e.tagMap, i) ? e.tag = e.tagMap[i] + s : i === "!" ? e.tag = "!" + s : i === "!!" ? e.tag = "tag:yaml.org,2002:" + s : et(e, 'undeclared tag handle "' + i + '"'), !0;
}
function XL(e) {
  var t, r;
  if (r = e.input.charCodeAt(e.position), r !== 38)
    return !1;
  for (e.anchor !== null && et(e, "duplication of an anchor property"), r = e.input.charCodeAt(++e.position), t = e.position; r !== 0 && !Hr(r) && !Ba(r); )
    r = e.input.charCodeAt(++e.position);
  return e.position === t && et(e, "name of an anchor node must contain at least one character"), e.anchor = e.input.slice(t, e.position), !0;
}
function QL(e) {
  var t, r, n;
  if (n = e.input.charCodeAt(e.position), n !== 42)
    return !1;
  for (n = e.input.charCodeAt(++e.position), t = e.position; n !== 0 && !Hr(n) && !Ba(n); )
    n = e.input.charCodeAt(++e.position);
  return e.position === t && et(e, "name of an alias node must contain at least one character"), r = e.input.slice(t, e.position), hs.call(e.anchorMap, r) || et(e, 'unidentified alias "' + r + '"'), e.result = e.anchorMap[r], ar(e, !0, -1), !0;
}
function io(e, t, r, n, i) {
  var s, a, u, c = 1, l = !1, d = !1, p, h, v, y, g, _;
  if (e.listener !== null && e.listener("open", e), e.tag = null, e.anchor = null, e.kind = null, e.result = null, s = a = u = ff === r || eO === r, n && ar(e, !0, -1) && (l = !0, e.lineIndent > t ? c = 1 : e.lineIndent === t ? c = 0 : e.lineIndent < t && (c = -1)), c === 1)
    for (; JL(e) || XL(e); )
      ar(e, !0, -1) ? (l = !0, u = s, e.lineIndent > t ? c = 1 : e.lineIndent === t ? c = 0 : e.lineIndent < t && (c = -1)) : u = !1;
  if (u && (u = l || i), (c === 1 || ff === r) && (lf === r || Qx === r ? g = t : g = t + 1, _ = e.position - e.lineStart, c === 1 ? u && (G1(e, _) || YL(e, _, g)) || GL(e, g) ? d = !0 : (a && KL(e, g) || WL(e, g) || HL(e, g) ? d = !0 : QL(e) ? (d = !0, (e.tag !== null || e.anchor !== null) && et(e, "alias node should not have any properties")) : zL(e, g, lf === r) && (d = !0, e.tag === null && (e.tag = "?")), e.anchor !== null && (e.anchorMap[e.anchor] = e.result)) : c === 0 && (d = u && G1(e, _))), e.tag === null)
    e.anchor !== null && (e.anchorMap[e.anchor] = e.result);
  else if (e.tag === "?") {
    for (e.result !== null && e.kind !== "scalar" && et(e, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + e.kind + '"'), p = 0, h = e.implicitTypes.length; p < h; p += 1)
      if (y = e.implicitTypes[p], y.resolve(e.result)) {
        e.result = y.construct(e.result), e.tag = y.tag, e.anchor !== null && (e.anchorMap[e.anchor] = e.result);
        break;
      }
  } else if (e.tag !== "!") {
    if (hs.call(e.typeMap[e.kind || "fallback"], e.tag))
      y = e.typeMap[e.kind || "fallback"][e.tag];
    else
      for (y = null, v = e.typeMap.multi[e.kind || "fallback"], p = 0, h = v.length; p < h; p += 1)
        if (e.tag.slice(0, v[p].tag.length) === v[p].tag) {
          y = v[p];
          break;
        }
    y || et(e, "unknown tag !<" + e.tag + ">"), e.result !== null && y.kind !== e.kind && et(e, "unacceptable node kind for !<" + e.tag + '> tag; it should be "' + y.kind + '", not "' + e.kind + '"'), y.resolve(e.result, e.tag) ? (e.result = y.construct(e.result, e.tag), e.anchor !== null && (e.anchorMap[e.anchor] = e.result)) : et(e, "cannot resolve a node with !<" + e.tag + "> explicit tag");
  }
  return e.listener !== null && e.listener("close", e), e.tag !== null || e.anchor !== null || d;
}
function e6(e) {
  var t = e.position, r, n, i, s = !1, a;
  for (e.version = null, e.checkLineBreaks = e.legacy, e.tagMap = /* @__PURE__ */ Object.create(null), e.anchorMap = /* @__PURE__ */ Object.create(null); (a = e.input.charCodeAt(e.position)) !== 0 && (ar(e, !0, -1), a = e.input.charCodeAt(e.position), !(e.lineIndent > 0 || a !== 37)); ) {
    for (s = !0, a = e.input.charCodeAt(++e.position), r = e.position; a !== 0 && !Hr(a); )
      a = e.input.charCodeAt(++e.position);
    for (n = e.input.slice(r, e.position), i = [], n.length < 1 && et(e, "directive name must not be less than one character in length"); a !== 0; ) {
      for (; Gs(a); )
        a = e.input.charCodeAt(++e.position);
      if (a === 35) {
        do
          a = e.input.charCodeAt(++e.position);
        while (a !== 0 && !ti(a));
        break;
      }
      if (ti(a))
        break;
      for (r = e.position; a !== 0 && !Hr(a); )
        a = e.input.charCodeAt(++e.position);
      i.push(e.input.slice(r, e.position));
    }
    a !== 0 && jg(e), hs.call(W1, n) ? W1[n](e, n, i) : df(e, 'unknown document directive "' + n + '"');
  }
  if (ar(e, !0, -1), e.lineIndent === 0 && e.input.charCodeAt(e.position) === 45 && e.input.charCodeAt(e.position + 1) === 45 && e.input.charCodeAt(e.position + 2) === 45 ? (e.position += 3, ar(e, !0, -1)) : s && et(e, "directives end mark is expected"), io(e, e.lineIndent - 1, ff, !1, !0), ar(e, !0, -1), e.checkLineBreaks && LL.test(e.input.slice(t, e.position)) && df(e, "non-ASCII line breaks are interpreted as content"), e.documents.push(e.result), e.position === e.lineStart && Zf(e)) {
    e.input.charCodeAt(e.position) === 46 && (e.position += 3, ar(e, !0, -1));
    return;
  }
  if (e.position < e.length - 1)
    et(e, "end of the stream or a document separator is expected");
  else
    return;
}
function aO(e, t) {
  e = String(e), t = t || {}, e.length !== 0 && (e.charCodeAt(e.length - 1) !== 10 && e.charCodeAt(e.length - 1) !== 13 && (e += `
`), e.charCodeAt(0) === 65279 && (e = e.slice(1)));
  var r = new ZL(e, t), n = e.indexOf("\0");
  for (n !== -1 && (r.position = n, et(r, "null byte is not allowed in input")), r.input += "\0"; r.input.charCodeAt(r.position) === 32; )
    r.lineIndent += 1, r.position += 1;
  for (; r.position < r.length - 1; )
    e6(r);
  return r.documents;
}
function t6(e, t, r) {
  t !== null && typeof t == "object" && typeof r > "u" && (r = t, t = null);
  var n = aO(e, r);
  if (typeof t != "function")
    return n;
  for (var i = 0, s = n.length; i < s; i += 1)
    t(n[i]);
}
function r6(e, t) {
  var r = aO(e, t);
  if (r.length !== 0) {
    if (r.length === 1)
      return r[0];
    throw new Xx("expected a single document in the stream, but found more");
  }
}
Rg.loadAll = t6;
Rg.load = r6;
var oO = {}, zf = Dn, ec = Qu, n6 = Ig, uO = Object.prototype.toString, cO = Object.prototype.hasOwnProperty, Mg = 65279, i6 = 9, Mu = 10, s6 = 13, a6 = 32, o6 = 33, u6 = 34, xy = 35, c6 = 37, l6 = 38, f6 = 39, d6 = 42, lO = 44, p6 = 45, pf = 58, h6 = 61, m6 = 62, y6 = 63, g6 = 64, fO = 91, dO = 93, v6 = 96, pO = 123, b6 = 124, hO = 125, Rr = {};
Rr[0] = "\\0";
Rr[7] = "\\a";
Rr[8] = "\\b";
Rr[9] = "\\t";
Rr[10] = "\\n";
Rr[11] = "\\v";
Rr[12] = "\\f";
Rr[13] = "\\r";
Rr[27] = "\\e";
Rr[34] = '\\"';
Rr[92] = "\\\\";
Rr[133] = "\\N";
Rr[160] = "\\_";
Rr[8232] = "\\L";
Rr[8233] = "\\P";
var _6 = [
  "y",
  "Y",
  "yes",
  "Yes",
  "YES",
  "on",
  "On",
  "ON",
  "n",
  "N",
  "no",
  "No",
  "NO",
  "off",
  "Off",
  "OFF"
], w6 = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function $6(e, t) {
  var r, n, i, s, a, u, c;
  if (t === null)
    return {};
  for (r = {}, n = Object.keys(t), i = 0, s = n.length; i < s; i += 1)
    a = n[i], u = String(t[a]), a.slice(0, 2) === "!!" && (a = "tag:yaml.org,2002:" + a.slice(2)), c = e.compiledTypeMap.fallback[a], c && cO.call(c.styleAliases, u) && (u = c.styleAliases[u]), r[a] = u;
  return r;
}
function E6(e) {
  var t, r, n;
  if (t = e.toString(16).toUpperCase(), e <= 255)
    r = "x", n = 2;
  else if (e <= 65535)
    r = "u", n = 4;
  else if (e <= 4294967295)
    r = "U", n = 8;
  else
    throw new ec("code point within a string may not be greater than 0xFFFFFFFF");
  return "\\" + r + zf.repeat("0", n - t.length) + t;
}
var x6 = 1, Nu = 2;
function O6(e) {
  this.schema = e.schema || n6, this.indent = Math.max(1, e.indent || 2), this.noArrayIndent = e.noArrayIndent || !1, this.skipInvalid = e.skipInvalid || !1, this.flowLevel = zf.isNothing(e.flowLevel) ? -1 : e.flowLevel, this.styleMap = $6(this.schema, e.styles || null), this.sortKeys = e.sortKeys || !1, this.lineWidth = e.lineWidth || 80, this.noRefs = e.noRefs || !1, this.noCompatMode = e.noCompatMode || !1, this.condenseFlow = e.condenseFlow || !1, this.quotingType = e.quotingType === '"' ? Nu : x6, this.forceQuotes = e.forceQuotes || !1, this.replacer = typeof e.replacer == "function" ? e.replacer : null, this.implicitTypes = this.schema.compiledImplicit, this.explicitTypes = this.schema.compiledExplicit, this.tag = null, this.result = "", this.duplicates = [], this.usedDuplicates = null;
}
function K1(e, t) {
  for (var r = zf.repeat(" ", t), n = 0, i = -1, s = "", a, u = e.length; n < u; )
    i = e.indexOf(`
`, n), i === -1 ? (a = e.slice(n), n = u) : (a = e.slice(n, i + 1), n = i + 1), a.length && a !== `
` && (s += r), s += a;
  return s;
}
function Oy(e, t) {
  return `
` + zf.repeat(" ", e.indent * t);
}
function P6(e, t) {
  var r, n, i;
  for (r = 0, n = e.implicitTypes.length; r < n; r += 1)
    if (i = e.implicitTypes[r], i.resolve(t))
      return !0;
  return !1;
}
function hf(e) {
  return e === a6 || e === i6;
}
function Du(e) {
  return 32 <= e && e <= 126 || 161 <= e && e <= 55295 && e !== 8232 && e !== 8233 || 57344 <= e && e <= 65533 && e !== Mg || 65536 <= e && e <= 1114111;
}
function Y1(e) {
  return Du(e) && e !== Mg && e !== s6 && e !== Mu;
}
function J1(e, t, r) {
  var n = Y1(e), i = n && !hf(e);
  return (
    // ns-plain-safe
    (r ? (
      // c = flow-in
      n
    ) : n && e !== lO && e !== fO && e !== dO && e !== pO && e !== hO) && e !== xy && !(t === pf && !i) || Y1(t) && !hf(t) && e === xy || t === pf && i
  );
}
function S6(e) {
  return Du(e) && e !== Mg && !hf(e) && e !== p6 && e !== y6 && e !== pf && e !== lO && e !== fO && e !== dO && e !== pO && e !== hO && e !== xy && e !== l6 && e !== d6 && e !== o6 && e !== b6 && e !== h6 && e !== m6 && e !== f6 && e !== u6 && e !== c6 && e !== g6 && e !== v6;
}
function A6(e) {
  return !hf(e) && e !== pf;
}
function nu(e, t) {
  var r = e.charCodeAt(t), n;
  return r >= 55296 && r <= 56319 && t + 1 < e.length && (n = e.charCodeAt(t + 1), n >= 56320 && n <= 57343) ? (r - 55296) * 1024 + n - 56320 + 65536 : r;
}
function mO(e) {
  var t = /^\n* /;
  return t.test(e);
}
var yO = 1, Py = 2, gO = 3, vO = 4, La = 5;
function C6(e, t, r, n, i, s, a, u) {
  var c, l = 0, d = null, p = !1, h = !1, v = n !== -1, y = -1, g = S6(nu(e, 0)) && A6(nu(e, e.length - 1));
  if (t || a)
    for (c = 0; c < e.length; l >= 65536 ? c += 2 : c++) {
      if (l = nu(e, c), !Du(l))
        return La;
      g = g && J1(l, d, u), d = l;
    }
  else {
    for (c = 0; c < e.length; l >= 65536 ? c += 2 : c++) {
      if (l = nu(e, c), l === Mu)
        p = !0, v && (h = h || // Foldable line = too long, and not more-indented.
        c - y - 1 > n && e[y + 1] !== " ", y = c);
      else if (!Du(l))
        return La;
      g = g && J1(l, d, u), d = l;
    }
    h = h || v && c - y - 1 > n && e[y + 1] !== " ";
  }
  return !p && !h ? g && !a && !i(e) ? yO : s === Nu ? La : Py : r > 9 && mO(e) ? La : a ? s === Nu ? La : Py : h ? vO : gO;
}
function R6(e, t, r, n, i) {
  e.dump = function() {
    if (t.length === 0)
      return e.quotingType === Nu ? '""' : "''";
    if (!e.noCompatMode && (_6.indexOf(t) !== -1 || w6.test(t)))
      return e.quotingType === Nu ? '"' + t + '"' : "'" + t + "'";
    var s = e.indent * Math.max(1, r), a = e.lineWidth === -1 ? -1 : Math.max(Math.min(e.lineWidth, 40), e.lineWidth - s), u = n || e.flowLevel > -1 && r >= e.flowLevel;
    function c(l) {
      return P6(e, l);
    }
    switch (C6(
      t,
      u,
      e.indent,
      a,
      c,
      e.quotingType,
      e.forceQuotes && !n,
      i
    )) {
      case yO:
        return t;
      case Py:
        return "'" + t.replace(/'/g, "''") + "'";
      case gO:
        return "|" + X1(t, e.indent) + Q1(K1(t, s));
      case vO:
        return ">" + X1(t, e.indent) + Q1(K1(T6(t, a), s));
      case La:
        return '"' + I6(t) + '"';
      default:
        throw new ec("impossible error: invalid scalar style");
    }
  }();
}
function X1(e, t) {
  var r = mO(e) ? String(t) : "", n = e[e.length - 1] === `
`, i = n && (e[e.length - 2] === `
` || e === `
`), s = i ? "+" : n ? "" : "-";
  return r + s + `
`;
}
function Q1(e) {
  return e[e.length - 1] === `
` ? e.slice(0, -1) : e;
}
function T6(e, t) {
  for (var r = /(\n+)([^\n]*)/g, n = function() {
    var l = e.indexOf(`
`);
    return l = l !== -1 ? l : e.length, r.lastIndex = l, e_(e.slice(0, l), t);
  }(), i = e[0] === `
` || e[0] === " ", s, a; a = r.exec(e); ) {
    var u = a[1], c = a[2];
    s = c[0] === " ", n += u + (!i && !s && c !== "" ? `
` : "") + e_(c, t), i = s;
  }
  return n;
}
function e_(e, t) {
  if (e === "" || e[0] === " ")
    return e;
  for (var r = / [^ ]/g, n, i = 0, s, a = 0, u = 0, c = ""; n = r.exec(e); )
    u = n.index, u - i > t && (s = a > i ? a : u, c += `
` + e.slice(i, s), i = s + 1), a = u;
  return c += `
`, e.length - i > t && a > i ? c += e.slice(i, a) + `
` + e.slice(a + 1) : c += e.slice(i), c.slice(1);
}
function I6(e) {
  for (var t = "", r = 0, n, i = 0; i < e.length; r >= 65536 ? i += 2 : i++)
    r = nu(e, i), n = Rr[r], !n && Du(r) ? (t += e[i], r >= 65536 && (t += e[i + 1])) : t += n || E6(r);
  return t;
}
function j6(e, t, r) {
  var n = "", i = e.tag, s, a, u;
  for (s = 0, a = r.length; s < a; s += 1)
    u = r[s], e.replacer && (u = e.replacer.call(r, String(s), u)), (Ri(e, t, u, !1, !1) || typeof u > "u" && Ri(e, t, null, !1, !1)) && (n !== "" && (n += "," + (e.condenseFlow ? "" : " ")), n += e.dump);
  e.tag = i, e.dump = "[" + n + "]";
}
function t_(e, t, r, n) {
  var i = "", s = e.tag, a, u, c;
  for (a = 0, u = r.length; a < u; a += 1)
    c = r[a], e.replacer && (c = e.replacer.call(r, String(a), c)), (Ri(e, t + 1, c, !0, !0, !1, !0) || typeof c > "u" && Ri(e, t + 1, null, !0, !0, !1, !0)) && ((!n || i !== "") && (i += Oy(e, t)), e.dump && Mu === e.dump.charCodeAt(0) ? i += "-" : i += "- ", i += e.dump);
  e.tag = s, e.dump = i || "[]";
}
function k6(e, t, r) {
  var n = "", i = e.tag, s = Object.keys(r), a, u, c, l, d;
  for (a = 0, u = s.length; a < u; a += 1)
    d = "", n !== "" && (d += ", "), e.condenseFlow && (d += '"'), c = s[a], l = r[c], e.replacer && (l = e.replacer.call(r, c, l)), Ri(e, t, c, !1, !1) && (e.dump.length > 1024 && (d += "? "), d += e.dump + (e.condenseFlow ? '"' : "") + ":" + (e.condenseFlow ? "" : " "), Ri(e, t, l, !1, !1) && (d += e.dump, n += d));
  e.tag = i, e.dump = "{" + n + "}";
}
function M6(e, t, r, n) {
  var i = "", s = e.tag, a = Object.keys(r), u, c, l, d, p, h;
  if (e.sortKeys === !0)
    a.sort();
  else if (typeof e.sortKeys == "function")
    a.sort(e.sortKeys);
  else if (e.sortKeys)
    throw new ec("sortKeys must be a boolean or a function");
  for (u = 0, c = a.length; u < c; u += 1)
    h = "", (!n || i !== "") && (h += Oy(e, t)), l = a[u], d = r[l], e.replacer && (d = e.replacer.call(r, l, d)), Ri(e, t + 1, l, !0, !0, !0) && (p = e.tag !== null && e.tag !== "?" || e.dump && e.dump.length > 1024, p && (e.dump && Mu === e.dump.charCodeAt(0) ? h += "?" : h += "? "), h += e.dump, p && (h += Oy(e, t)), Ri(e, t + 1, d, !0, p) && (e.dump && Mu === e.dump.charCodeAt(0) ? h += ":" : h += ": ", h += e.dump, i += h));
  e.tag = s, e.dump = i || "{}";
}
function r_(e, t, r) {
  var n, i, s, a, u, c;
  for (i = r ? e.explicitTypes : e.implicitTypes, s = 0, a = i.length; s < a; s += 1)
    if (u = i[s], (u.instanceOf || u.predicate) && (!u.instanceOf || typeof t == "object" && t instanceof u.instanceOf) && (!u.predicate || u.predicate(t))) {
      if (r ? u.multi && u.representName ? e.tag = u.representName(t) : e.tag = u.tag : e.tag = "?", u.represent) {
        if (c = e.styleMap[u.tag] || u.defaultStyle, uO.call(u.represent) === "[object Function]")
          n = u.represent(t, c);
        else if (cO.call(u.represent, c))
          n = u.represent[c](t, c);
        else
          throw new ec("!<" + u.tag + '> tag resolver accepts not "' + c + '" style');
        e.dump = n;
      }
      return !0;
    }
  return !1;
}
function Ri(e, t, r, n, i, s, a) {
  e.tag = null, e.dump = r, r_(e, r, !1) || r_(e, r, !0);
  var u = uO.call(e.dump), c = n, l;
  n && (n = e.flowLevel < 0 || e.flowLevel > t);
  var d = u === "[object Object]" || u === "[object Array]", p, h;
  if (d && (p = e.duplicates.indexOf(r), h = p !== -1), (e.tag !== null && e.tag !== "?" || h || e.indent !== 2 && t > 0) && (i = !1), h && e.usedDuplicates[p])
    e.dump = "*ref_" + p;
  else {
    if (d && h && !e.usedDuplicates[p] && (e.usedDuplicates[p] = !0), u === "[object Object]")
      n && Object.keys(e.dump).length !== 0 ? (M6(e, t, e.dump, i), h && (e.dump = "&ref_" + p + e.dump)) : (k6(e, t, e.dump), h && (e.dump = "&ref_" + p + " " + e.dump));
    else if (u === "[object Array]")
      n && e.dump.length !== 0 ? (e.noArrayIndent && !a && t > 0 ? t_(e, t - 1, e.dump, i) : t_(e, t, e.dump, i), h && (e.dump = "&ref_" + p + e.dump)) : (j6(e, t, e.dump), h && (e.dump = "&ref_" + p + " " + e.dump));
    else if (u === "[object String]")
      e.tag !== "?" && R6(e, e.dump, t, s, c);
    else {
      if (u === "[object Undefined]")
        return !1;
      if (e.skipInvalid)
        return !1;
      throw new ec("unacceptable kind of an object to dump " + u);
    }
    e.tag !== null && e.tag !== "?" && (l = encodeURI(
      e.tag[0] === "!" ? e.tag.slice(1) : e.tag
    ).replace(/!/g, "%21"), e.tag[0] === "!" ? l = "!" + l : l.slice(0, 18) === "tag:yaml.org,2002:" ? l = "!!" + l.slice(18) : l = "!<" + l + ">", e.dump = l + " " + e.dump);
  }
  return !0;
}
function N6(e, t) {
  var r = [], n = [], i, s;
  for (Sy(e, r, n), i = 0, s = n.length; i < s; i += 1)
    t.duplicates.push(r[n[i]]);
  t.usedDuplicates = new Array(s);
}
function Sy(e, t, r) {
  var n, i, s;
  if (e !== null && typeof e == "object")
    if (i = t.indexOf(e), i !== -1)
      r.indexOf(i) === -1 && r.push(i);
    else if (t.push(e), Array.isArray(e))
      for (i = 0, s = e.length; i < s; i += 1)
        Sy(e[i], t, r);
    else
      for (n = Object.keys(e), i = 0, s = n.length; i < s; i += 1)
        Sy(e[n[i]], t, r);
}
function D6(e, t) {
  t = t || {};
  var r = new O6(t);
  r.noRefs || N6(e, r);
  var n = e;
  return r.replacer && (n = r.replacer.call({ "": n }, "", n)), Ri(r, 0, n, !0, !0) ? r.dump + `
` : "";
}
oO.dump = D6;
var bO = Rg, L6 = oO;
function Ng(e, t) {
  return function() {
    throw new Error("Function yaml." + e + " is removed in js-yaml 4. Use yaml." + t + " instead, which is now safe by default.");
  };
}
_r.Type = Fr;
_r.Schema = Ix;
_r.FAILSAFE_SCHEMA = Nx;
_r.JSON_SCHEMA = Bx;
_r.CORE_SCHEMA = Vx;
_r.DEFAULT_SCHEMA = Ig;
_r.load = bO.load;
_r.loadAll = bO.loadAll;
_r.dump = L6.dump;
_r.YAMLException = Qu;
_r.types = {
  binary: Gx,
  float: Ux,
  map: Mx,
  null: Dx,
  pairs: Yx,
  set: Jx,
  timestamp: Wx,
  bool: Lx,
  int: qx,
  merge: Hx,
  omap: Kx,
  seq: kx,
  str: jx
};
_r.safeLoad = Ng("safeLoad", "load");
_r.safeLoadAll = Ng("safeLoadAll", "loadAll");
_r.safeDump = Ng("safeDump", "dump");
const q6 = _r, { JSON_SCHEMA: F6 } = _r, { ParserError: U6 } = or;
var B6 = {
  /**
   * The order that this parser will run, in relation to other parsers.
   *
   * @type {number}
   */
  order: 200,
  /**
   * Whether to allow "empty" files. This includes zero-byte files, as well as empty JSON objects.
   *
   * @type {boolean}
   */
  allowEmpty: !0,
  /**
   * Determines whether this parser can parse a given file reference.
   * Parsers that match will be tried, in order, until one successfully parses the file.
   * Parsers that don't match will be skipped, UNLESS none of the parsers match, in which case
   * every parser will be tried.
   *
   * @type {RegExp|string[]|function}
   */
  canParse: [".yaml", ".yml", ".json"],
  // JSON is valid YAML
  /**
   * Parses the given file as YAML
   *
   * @param {object} file           - An object containing information about the referenced file
   * @param {string} file.url       - The full URL of the referenced file
   * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
   * @returns {Promise}
   */
  // eslint-disable-next-line require-await
  async parse(e) {
    let t = e.data;
    if (Me.Buffer.isBuffer(t) && (t = t.toString()), typeof t == "string")
      try {
        return q6.load(t, { schema: F6 });
      } catch (r) {
        throw new U6(r.message, e.url);
      }
    return t;
  }
}, V6 = null;
const Z6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: V6
}, Symbol.toStringTag, { value: "Module" })), _O = /* @__PURE__ */ If(Z6), z6 = _O, { ono: Zp } = Nn, { ResolverError: zp } = or, n_ = gn;
var W6 = {
  /**
   * The order that this resolver will run, in relation to other resolvers.
   *
   * @type {number}
   */
  order: 100,
  /**
   * Determines whether this resolver can read a given file reference.
   * Resolvers that return true will be tried, in order, until one successfully resolves the file.
   * Resolvers that return false will not be given a chance to resolve the file.
   *
   * @param {object} file           - An object containing information about the referenced file
   * @param {string} file.url       - The full URL of the referenced file
   * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
   * @returns {boolean}
   */
  canRead(e) {
    return n_.isFileSystemPath(e.url);
  },
  /**
   * Reads the given file and returns its raw contents as a Buffer.
   *
   * @param {object} file           - An object containing information about the referenced file
   * @param {string} file.url       - The full URL of the referenced file
   * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
   * @returns {Promise<Buffer>}
   */
  read(e) {
    return new Promise((t, r) => {
      let n;
      try {
        n = n_.toFileSystemPath(e.url);
      } catch (i) {
        r(new zp(Zp.uri(i, `Malformed URI: ${e.url}`), e.url));
      }
      try {
        z6.readFile(n, (i, s) => {
          i ? r(new zp(Zp(i, `Error opening file "${n}"`), n)) : t(s);
        });
      } catch (i) {
        r(new zp(Zp(i, `Error opening file "${n}"`), n));
      }
    });
  }
}, Wf = {}, wO = { exports: {} }, Dg = {};
(function(e) {
  e.fetch = i(rt.fetch) && i(rt.ReadableStream), e.writableStream = i(rt.WritableStream), e.abortController = i(rt.AbortController);
  var t;
  function r() {
    if (t !== void 0)
      return t;
    if (rt.XMLHttpRequest) {
      t = new rt.XMLHttpRequest();
      try {
        t.open("GET", rt.XDomainRequest ? "/" : "https://example.com");
      } catch {
        t = null;
      }
    } else
      t = null;
    return t;
  }
  function n(s) {
    var a = r();
    if (!a)
      return !1;
    try {
      return a.responseType = s, a.responseType === s;
    } catch {
    }
    return !1;
  }
  e.arraybuffer = e.fetch || n("arraybuffer"), e.msstream = !e.fetch && n("ms-stream"), e.mozchunkedarraybuffer = !e.fetch && n("moz-chunked-arraybuffer"), e.overrideMimeType = e.fetch || (r() ? i(r().overrideMimeType) : !1);
  function i(s) {
    return typeof s == "function";
  }
  t = null;
})(Dg);
var Hf = {}, Ay = { exports: {} }, $O = hg.EventEmitter, Wp, i_;
function H6() {
  if (i_)
    return Wp;
  i_ = 1;
  function e(y, g) {
    var _ = Object.keys(y);
    if (Object.getOwnPropertySymbols) {
      var m = Object.getOwnPropertySymbols(y);
      g && (m = m.filter(function(w) {
        return Object.getOwnPropertyDescriptor(y, w).enumerable;
      })), _.push.apply(_, m);
    }
    return _;
  }
  function t(y) {
    for (var g = 1; g < arguments.length; g++) {
      var _ = arguments[g] != null ? arguments[g] : {};
      g % 2 ? e(Object(_), !0).forEach(function(m) {
        r(y, m, _[m]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(y, Object.getOwnPropertyDescriptors(_)) : e(Object(_)).forEach(function(m) {
        Object.defineProperty(y, m, Object.getOwnPropertyDescriptor(_, m));
      });
    }
    return y;
  }
  function r(y, g, _) {
    return g = a(g), g in y ? Object.defineProperty(y, g, { value: _, enumerable: !0, configurable: !0, writable: !0 }) : y[g] = _, y;
  }
  function n(y, g) {
    if (!(y instanceof g))
      throw new TypeError("Cannot call a class as a function");
  }
  function i(y, g) {
    for (var _ = 0; _ < g.length; _++) {
      var m = g[_];
      m.enumerable = m.enumerable || !1, m.configurable = !0, "value" in m && (m.writable = !0), Object.defineProperty(y, a(m.key), m);
    }
  }
  function s(y, g, _) {
    return g && i(y.prototype, g), _ && i(y, _), Object.defineProperty(y, "prototype", { writable: !1 }), y;
  }
  function a(y) {
    var g = u(y, "string");
    return typeof g == "symbol" ? g : String(g);
  }
  function u(y, g) {
    if (typeof y != "object" || y === null)
      return y;
    var _ = y[Symbol.toPrimitive];
    if (_ !== void 0) {
      var m = _.call(y, g || "default");
      if (typeof m != "object")
        return m;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (g === "string" ? String : Number)(y);
  }
  var c = co, l = c.Buffer, d = Ku, p = d.inspect, h = p && p.custom || "inspect";
  function v(y, g, _) {
    l.prototype.copy.call(y, g, _);
  }
  return Wp = /* @__PURE__ */ function() {
    function y() {
      n(this, y), this.head = null, this.tail = null, this.length = 0;
    }
    return s(y, [{
      key: "push",
      value: function(_) {
        var m = {
          data: _,
          next: null
        };
        this.length > 0 ? this.tail.next = m : this.head = m, this.tail = m, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(_) {
        var m = {
          data: _,
          next: this.head
        };
        this.length === 0 && (this.tail = m), this.head = m, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var _ = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, _;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(_) {
        if (this.length === 0)
          return "";
        for (var m = this.head, w = "" + m.data; m = m.next; )
          w += _ + m.data;
        return w;
      }
    }, {
      key: "concat",
      value: function(_) {
        if (this.length === 0)
          return l.alloc(0);
        for (var m = l.allocUnsafe(_ >>> 0), w = this.head, $ = 0; w; )
          v(w.data, m, $), $ += w.data.length, w = w.next;
        return m;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(_, m) {
        var w;
        return _ < this.head.data.length ? (w = this.head.data.slice(0, _), this.head.data = this.head.data.slice(_)) : _ === this.head.data.length ? w = this.shift() : w = m ? this._getString(_) : this._getBuffer(_), w;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(_) {
        var m = this.head, w = 1, $ = m.data;
        for (_ -= $.length; m = m.next; ) {
          var E = m.data, A = _ > E.length ? E.length : _;
          if (A === E.length ? $ += E : $ += E.slice(0, _), _ -= A, _ === 0) {
            A === E.length ? (++w, m.next ? this.head = m.next : this.head = this.tail = null) : (this.head = m, m.data = E.slice(A));
            break;
          }
          ++w;
        }
        return this.length -= w, $;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(_) {
        var m = l.allocUnsafe(_), w = this.head, $ = 1;
        for (w.data.copy(m), _ -= w.data.length; w = w.next; ) {
          var E = w.data, A = _ > E.length ? E.length : _;
          if (E.copy(m, m.length - _, 0, A), _ -= A, _ === 0) {
            A === E.length ? (++$, w.next ? this.head = w.next : this.head = this.tail = null) : (this.head = w, w.data = E.slice(A));
            break;
          }
          ++$;
        }
        return this.length -= $, m;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: h,
      value: function(_, m) {
        return p(this, t(t({}, m), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), y;
  }(), Wp;
}
function G6(e, t) {
  var r = this, n = this._readableState && this._readableState.destroyed, i = this._writableState && this._writableState.destroyed;
  return n || i ? (t ? t(e) : e && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, Me.process.nextTick(Cy, this, e)) : Me.process.nextTick(Cy, this, e)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(e || null, function(s) {
    !t && s ? r._writableState ? r._writableState.errorEmitted ? Me.process.nextTick(Tl, r) : (r._writableState.errorEmitted = !0, Me.process.nextTick(s_, r, s)) : Me.process.nextTick(s_, r, s) : t ? (Me.process.nextTick(Tl, r), t(s)) : Me.process.nextTick(Tl, r);
  }), this);
}
function s_(e, t) {
  Cy(e, t), Tl(e);
}
function Tl(e) {
  e._writableState && !e._writableState.emitClose || e._readableState && !e._readableState.emitClose || e.emit("close");
}
function K6() {
  this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
}
function Cy(e, t) {
  e.emit("error", t);
}
function Y6(e, t) {
  var r = e._readableState, n = e._writableState;
  r && r.autoDestroy || n && n.autoDestroy ? e.destroy(t) : e.emit("error", t);
}
var EO = {
  destroy: G6,
  undestroy: K6,
  errorOrDestroy: Y6
}, ta = {};
function J6(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e.__proto__ = t;
}
var xO = {};
function vn(e, t, r) {
  r || (r = Error);
  function n(s, a, u) {
    return typeof t == "string" ? t : t(s, a, u);
  }
  var i = /* @__PURE__ */ function(s) {
    J6(a, s);
    function a(u, c, l) {
      return s.call(this, n(u, c, l)) || this;
    }
    return a;
  }(r);
  i.prototype.name = r.name, i.prototype.code = e, xO[e] = i;
}
function a_(e, t) {
  if (Array.isArray(e)) {
    var r = e.length;
    return e = e.map(function(n) {
      return String(n);
    }), r > 2 ? "one of ".concat(t, " ").concat(e.slice(0, r - 1).join(", "), ", or ") + e[r - 1] : r === 2 ? "one of ".concat(t, " ").concat(e[0], " or ").concat(e[1]) : "of ".concat(t, " ").concat(e[0]);
  } else
    return "of ".concat(t, " ").concat(String(e));
}
function X6(e, t, r) {
  return e.substr(!r || r < 0 ? 0 : +r, t.length) === t;
}
function Q6(e, t, r) {
  return (r === void 0 || r > e.length) && (r = e.length), e.substring(r - t.length, r) === t;
}
function e4(e, t, r) {
  return typeof r != "number" && (r = 0), r + t.length > e.length ? !1 : e.indexOf(t, r) !== -1;
}
vn("ERR_INVALID_OPT_VALUE", function(e, t) {
  return 'The value "' + t + '" is invalid for option "' + e + '"';
}, TypeError);
vn("ERR_INVALID_ARG_TYPE", function(e, t, r) {
  var n;
  typeof t == "string" && X6(t, "not ") ? (n = "must not be", t = t.replace(/^not /, "")) : n = "must be";
  var i;
  if (Q6(e, " argument"))
    i = "The ".concat(e, " ").concat(n, " ").concat(a_(t, "type"));
  else {
    var s = e4(e, ".") ? "property" : "argument";
    i = 'The "'.concat(e, '" ').concat(s, " ").concat(n, " ").concat(a_(t, "type"));
  }
  return i += ". Received type ".concat(typeof r), i;
}, TypeError);
vn("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
vn("ERR_METHOD_NOT_IMPLEMENTED", function(e) {
  return "The " + e + " method is not implemented";
});
vn("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
vn("ERR_STREAM_DESTROYED", function(e) {
  return "Cannot call " + e + " after a stream was destroyed";
});
vn("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
vn("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
vn("ERR_STREAM_WRITE_AFTER_END", "write after end");
vn("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
vn("ERR_UNKNOWN_ENCODING", function(e) {
  return "Unknown encoding: " + e;
}, TypeError);
vn("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
ta.codes = xO;
var t4 = ta.codes.ERR_INVALID_OPT_VALUE;
function r4(e, t, r) {
  return e.highWaterMark != null ? e.highWaterMark : t ? e[r] : null;
}
function n4(e, t, r, n) {
  var i = r4(t, n, r);
  if (i != null) {
    if (!(isFinite(i) && Math.floor(i) === i) || i < 0) {
      var s = n ? r : "highWaterMark";
      throw new t4(s, i);
    }
    return Math.floor(i);
  }
  return e.objectMode ? 16 : 16 * 1024;
}
var OO = {
  getHighWaterMark: n4
}, i4 = s4;
function s4(e, t) {
  if (Hp("noDeprecation"))
    return e;
  var r = !1;
  function n() {
    if (!r) {
      if (Hp("throwDeprecation"))
        throw new Error(t);
      Hp("traceDeprecation") ? console.trace(t) : console.warn(t), r = !0;
    }
    return e.apply(this, arguments);
  }
  return n;
}
function Hp(e) {
  try {
    if (!rt.localStorage)
      return !1;
  } catch {
    return !1;
  }
  var t = rt.localStorage[e];
  return t == null ? !1 : String(t).toLowerCase() === "true";
}
var Gp, o_;
function PO() {
  if (o_)
    return Gp;
  o_ = 1, Gp = D;
  function e(N) {
    var F = this;
    this.next = null, this.entry = null, this.finish = function() {
      q(F, N);
    };
  }
  var t;
  D.WritableState = R;
  var r = {
    deprecate: i4
  }, n = $O, i = co.Buffer, s = (typeof rt < "u" ? rt : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function a(N) {
    return i.from(N);
  }
  function u(N) {
    return i.isBuffer(N) || N instanceof s;
  }
  var c = EO, l = OO, d = l.getHighWaterMark, p = ta.codes, h = p.ERR_INVALID_ARG_TYPE, v = p.ERR_METHOD_NOT_IMPLEMENTED, y = p.ERR_MULTIPLE_CALLBACK, g = p.ERR_STREAM_CANNOT_PIPE, _ = p.ERR_STREAM_DESTROYED, m = p.ERR_STREAM_NULL_VALUES, w = p.ERR_STREAM_WRITE_AFTER_END, $ = p.ERR_UNKNOWN_ENCODING, E = c.errorOrDestroy;
  gs(D, n);
  function A() {
  }
  function R(N, F, T) {
    t = t || so(), N = N || {}, typeof T != "boolean" && (T = F instanceof t), this.objectMode = !!N.objectMode, T && (this.objectMode = this.objectMode || !!N.writableObjectMode), this.highWaterMark = d(this, N, "writableHighWaterMark", T), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var Z = N.decodeStrings === !1;
    this.decodeStrings = !Z, this.defaultEncoding = N.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(Y) {
      le(F, Y);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = N.emitClose !== !1, this.autoDestroy = !!N.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new e(this);
  }
  R.prototype.getBuffer = function() {
    for (var F = this.bufferedRequest, T = []; F; )
      T.push(F), F = F.next;
    return T;
  }, function() {
    try {
      Object.defineProperty(R.prototype, "buffer", {
        get: r.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var I;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (I = Function.prototype[Symbol.hasInstance], Object.defineProperty(D, Symbol.hasInstance, {
    value: function(F) {
      return I.call(this, F) ? !0 : this !== D ? !1 : F && F._writableState instanceof R;
    }
  })) : I = function(F) {
    return F instanceof this;
  };
  function D(N) {
    t = t || so();
    var F = this instanceof t;
    if (!F && !I.call(D, this))
      return new D(N);
    this._writableState = new R(N, this, F), this.writable = !0, N && (typeof N.write == "function" && (this._write = N.write), typeof N.writev == "function" && (this._writev = N.writev), typeof N.destroy == "function" && (this._destroy = N.destroy), typeof N.final == "function" && (this._final = N.final)), n.call(this);
  }
  D.prototype.pipe = function() {
    E(this, new g());
  };
  function J(N, F) {
    var T = new w();
    E(N, T), Me.process.nextTick(F, T);
  }
  function ae(N, F, T, Z) {
    var Y;
    return T === null ? Y = new m() : typeof T != "string" && !F.objectMode && (Y = new h("chunk", ["string", "Buffer"], T)), Y ? (E(N, Y), Me.process.nextTick(Z, Y), !1) : !0;
  }
  D.prototype.write = function(N, F, T) {
    var Z = this._writableState, Y = !1, k = !Z.objectMode && u(N);
    return k && !i.isBuffer(N) && (N = a(N)), typeof F == "function" && (T = F, F = null), k ? F = "buffer" : F || (F = Z.defaultEncoding), typeof T != "function" && (T = A), Z.ending ? J(this, T) : (k || ae(this, Z, N, T)) && (Z.pendingcb++, Y = xe(this, Z, k, N, F, T)), Y;
  }, D.prototype.cork = function() {
    this._writableState.corked++;
  }, D.prototype.uncork = function() {
    var N = this._writableState;
    N.corked && (N.corked--, !N.writing && !N.corked && !N.bufferProcessing && N.bufferedRequest && _e(this, N));
  }, D.prototype.setDefaultEncoding = function(F) {
    if (typeof F == "string" && (F = F.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((F + "").toLowerCase()) > -1))
      throw new $(F);
    return this._writableState.defaultEncoding = F, this;
  }, Object.defineProperty(D.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function ye(N, F, T) {
    return !N.objectMode && N.decodeStrings !== !1 && typeof F == "string" && (F = i.from(F, T)), F;
  }
  Object.defineProperty(D.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function xe(N, F, T, Z, Y, k) {
    if (!T) {
      var U = ye(F, Z, Y);
      Z !== U && (T = !0, Y = "buffer", Z = U);
    }
    var pe = F.objectMode ? 1 : Z.length;
    F.length += pe;
    var we = F.length < F.highWaterMark;
    if (we || (F.needDrain = !0), F.writing || F.corked) {
      var He = F.lastBufferedRequest;
      F.lastBufferedRequest = {
        chunk: Z,
        encoding: Y,
        isBuf: T,
        callback: k,
        next: null
      }, He ? He.next = F.lastBufferedRequest : F.bufferedRequest = F.lastBufferedRequest, F.bufferedRequestCount += 1;
    } else
      je(N, F, !1, pe, Z, Y, k);
    return we;
  }
  function je(N, F, T, Z, Y, k, U) {
    F.writelen = Z, F.writecb = U, F.writing = !0, F.sync = !0, F.destroyed ? F.onwrite(new _("write")) : T ? N._writev(Y, F.onwrite) : N._write(Y, k, F.onwrite), F.sync = !1;
  }
  function re(N, F, T, Z, Y) {
    --F.pendingcb, T ? (Me.process.nextTick(Y, Z), Me.process.nextTick(z, N, F), N._writableState.errorEmitted = !0, E(N, Z)) : (Y(Z), N._writableState.errorEmitted = !0, E(N, Z), z(N, F));
  }
  function fe(N) {
    N.writing = !1, N.writecb = null, N.length -= N.writelen, N.writelen = 0;
  }
  function le(N, F) {
    var T = N._writableState, Z = T.sync, Y = T.writecb;
    if (typeof Y != "function")
      throw new y();
    if (fe(T), F)
      re(N, T, Z, F, Y);
    else {
      var k = ie(T) || N.destroyed;
      !k && !T.corked && !T.bufferProcessing && T.bufferedRequest && _e(N, T), Z ? Me.process.nextTick($e, N, T, k, Y) : $e(N, T, k, Y);
    }
  }
  function $e(N, F, T, Z) {
    T || Ae(N, F), F.pendingcb--, Z(), z(N, F);
  }
  function Ae(N, F) {
    F.length === 0 && F.needDrain && (F.needDrain = !1, N.emit("drain"));
  }
  function _e(N, F) {
    F.bufferProcessing = !0;
    var T = F.bufferedRequest;
    if (N._writev && T && T.next) {
      var Z = F.bufferedRequestCount, Y = new Array(Z), k = F.corkedRequestsFree;
      k.entry = T;
      for (var U = 0, pe = !0; T; )
        Y[U] = T, T.isBuf || (pe = !1), T = T.next, U += 1;
      Y.allBuffers = pe, je(N, F, !0, F.length, Y, "", k.finish), F.pendingcb++, F.lastBufferedRequest = null, k.next ? (F.corkedRequestsFree = k.next, k.next = null) : F.corkedRequestsFree = new e(F), F.bufferedRequestCount = 0;
    } else {
      for (; T; ) {
        var we = T.chunk, He = T.encoding, Fe = T.callback, Ge = F.objectMode ? 1 : we.length;
        if (je(N, F, !1, Ge, we, He, Fe), T = T.next, F.bufferedRequestCount--, F.writing)
          break;
      }
      T === null && (F.lastBufferedRequest = null);
    }
    F.bufferedRequest = T, F.bufferProcessing = !1;
  }
  D.prototype._write = function(N, F, T) {
    T(new v("_write()"));
  }, D.prototype._writev = null, D.prototype.end = function(N, F, T) {
    var Z = this._writableState;
    return typeof N == "function" ? (T = N, N = null, F = null) : typeof F == "function" && (T = F, F = null), N != null && this.write(N, F), Z.corked && (Z.corked = 1, this.uncork()), Z.ending || C(this, Z, T), this;
  }, Object.defineProperty(D.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function ie(N) {
    return N.ending && N.length === 0 && N.bufferedRequest === null && !N.finished && !N.writing;
  }
  function K(N, F) {
    N._final(function(T) {
      F.pendingcb--, T && E(N, T), F.prefinished = !0, N.emit("prefinish"), z(N, F);
    });
  }
  function V(N, F) {
    !F.prefinished && !F.finalCalled && (typeof N._final == "function" && !F.destroyed ? (F.pendingcb++, F.finalCalled = !0, Me.process.nextTick(K, N, F)) : (F.prefinished = !0, N.emit("prefinish")));
  }
  function z(N, F) {
    var T = ie(F);
    if (T && (V(N, F), F.pendingcb === 0 && (F.finished = !0, N.emit("finish"), F.autoDestroy))) {
      var Z = N._readableState;
      (!Z || Z.autoDestroy && Z.endEmitted) && N.destroy();
    }
    return T;
  }
  function C(N, F, T) {
    F.ending = !0, z(N, F), T && (F.finished ? Me.process.nextTick(T) : N.once("finish", T)), F.ended = !0, N.writable = !1;
  }
  function q(N, F, T) {
    var Z = N.entry;
    for (N.entry = null; Z; ) {
      var Y = Z.callback;
      F.pendingcb--, Y(T), Z = Z.next;
    }
    F.corkedRequestsFree.next = N;
  }
  return Object.defineProperty(D.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(F) {
      this._writableState && (this._writableState.destroyed = F);
    }
  }), D.prototype.destroy = c.destroy, D.prototype._undestroy = c.undestroy, D.prototype._destroy = function(N, F) {
    F(N);
  }, Gp;
}
var Kp, u_;
function so() {
  if (u_)
    return Kp;
  u_ = 1;
  var e = Object.keys || function(l) {
    var d = [];
    for (var p in l)
      d.push(p);
    return d;
  };
  Kp = a;
  var t = AO(), r = PO();
  gs(a, t);
  for (var n = e(r.prototype), i = 0; i < n.length; i++) {
    var s = n[i];
    a.prototype[s] || (a.prototype[s] = r.prototype[s]);
  }
  function a(l) {
    if (!(this instanceof a))
      return new a(l);
    t.call(this, l), r.call(this, l), this.allowHalfOpen = !0, l && (l.readable === !1 && (this.readable = !1), l.writable === !1 && (this.writable = !1), l.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", u)));
  }
  Object.defineProperty(a.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(a.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(a.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function u() {
    this._writableState.ended || Me.process.nextTick(c, this);
  }
  function c(l) {
    l.end();
  }
  return Object.defineProperty(a.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(d) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = d, this._writableState.destroyed = d);
    }
  }), Kp;
}
var Yp = {}, Xc = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var c_;
function a4() {
  return c_ || (c_ = 1, function(e, t) {
    var r = co, n = r.Buffer;
    function i(a, u) {
      for (var c in a)
        u[c] = a[c];
    }
    n.from && n.alloc && n.allocUnsafe && n.allocUnsafeSlow ? e.exports = r : (i(r, t), t.Buffer = s);
    function s(a, u, c) {
      return n(a, u, c);
    }
    s.prototype = Object.create(n.prototype), i(n, s), s.from = function(a, u, c) {
      if (typeof a == "number")
        throw new TypeError("Argument must not be a number");
      return n(a, u, c);
    }, s.alloc = function(a, u, c) {
      if (typeof a != "number")
        throw new TypeError("Argument must be a number");
      var l = n(a);
      return u !== void 0 ? typeof c == "string" ? l.fill(u, c) : l.fill(u) : l.fill(0), l;
    }, s.allocUnsafe = function(a) {
      if (typeof a != "number")
        throw new TypeError("Argument must be a number");
      return n(a);
    }, s.allocUnsafeSlow = function(a) {
      if (typeof a != "number")
        throw new TypeError("Argument must be a number");
      return r.SlowBuffer(a);
    };
  }(Xc, Xc.exports)), Xc.exports;
}
var l_;
function f_() {
  if (l_)
    return Yp;
  l_ = 1;
  var e = a4().Buffer, t = e.isEncoding || function(m) {
    switch (m = "" + m, m && m.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return !0;
      default:
        return !1;
    }
  };
  function r(m) {
    if (!m)
      return "utf8";
    for (var w; ; )
      switch (m) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return m;
        default:
          if (w)
            return;
          m = ("" + m).toLowerCase(), w = !0;
      }
  }
  function n(m) {
    var w = r(m);
    if (typeof w != "string" && (e.isEncoding === t || !t(m)))
      throw new Error("Unknown encoding: " + m);
    return w || m;
  }
  Yp.StringDecoder = i;
  function i(m) {
    this.encoding = n(m);
    var w;
    switch (this.encoding) {
      case "utf16le":
        this.text = p, this.end = h, w = 4;
        break;
      case "utf8":
        this.fillLast = c, w = 4;
        break;
      case "base64":
        this.text = v, this.end = y, w = 3;
        break;
      default:
        this.write = g, this.end = _;
        return;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = e.allocUnsafe(w);
  }
  i.prototype.write = function(m) {
    if (m.length === 0)
      return "";
    var w, $;
    if (this.lastNeed) {
      if (w = this.fillLast(m), w === void 0)
        return "";
      $ = this.lastNeed, this.lastNeed = 0;
    } else
      $ = 0;
    return $ < m.length ? w ? w + this.text(m, $) : this.text(m, $) : w || "";
  }, i.prototype.end = d, i.prototype.text = l, i.prototype.fillLast = function(m) {
    if (this.lastNeed <= m.length)
      return m.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    m.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, m.length), this.lastNeed -= m.length;
  };
  function s(m) {
    return m <= 127 ? 0 : m >> 5 === 6 ? 2 : m >> 4 === 14 ? 3 : m >> 3 === 30 ? 4 : m >> 6 === 2 ? -1 : -2;
  }
  function a(m, w, $) {
    var E = w.length - 1;
    if (E < $)
      return 0;
    var A = s(w[E]);
    return A >= 0 ? (A > 0 && (m.lastNeed = A - 1), A) : --E < $ || A === -2 ? 0 : (A = s(w[E]), A >= 0 ? (A > 0 && (m.lastNeed = A - 2), A) : --E < $ || A === -2 ? 0 : (A = s(w[E]), A >= 0 ? (A > 0 && (A === 2 ? A = 0 : m.lastNeed = A - 3), A) : 0));
  }
  function u(m, w, $) {
    if ((w[0] & 192) !== 128)
      return m.lastNeed = 0, "";
    if (m.lastNeed > 1 && w.length > 1) {
      if ((w[1] & 192) !== 128)
        return m.lastNeed = 1, "";
      if (m.lastNeed > 2 && w.length > 2 && (w[2] & 192) !== 128)
        return m.lastNeed = 2, "";
    }
  }
  function c(m) {
    var w = this.lastTotal - this.lastNeed, $ = u(this, m);
    if ($ !== void 0)
      return $;
    if (this.lastNeed <= m.length)
      return m.copy(this.lastChar, w, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    m.copy(this.lastChar, w, 0, m.length), this.lastNeed -= m.length;
  }
  function l(m, w) {
    var $ = a(this, m, w);
    if (!this.lastNeed)
      return m.toString("utf8", w);
    this.lastTotal = $;
    var E = m.length - ($ - this.lastNeed);
    return m.copy(this.lastChar, 0, E), m.toString("utf8", w, E);
  }
  function d(m) {
    var w = m && m.length ? this.write(m) : "";
    return this.lastNeed ? w + "" : w;
  }
  function p(m, w) {
    if ((m.length - w) % 2 === 0) {
      var $ = m.toString("utf16le", w);
      if ($) {
        var E = $.charCodeAt($.length - 1);
        if (E >= 55296 && E <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = m[m.length - 2], this.lastChar[1] = m[m.length - 1], $.slice(0, -1);
      }
      return $;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = m[m.length - 1], m.toString("utf16le", w, m.length - 1);
  }
  function h(m) {
    var w = m && m.length ? this.write(m) : "";
    if (this.lastNeed) {
      var $ = this.lastTotal - this.lastNeed;
      return w + this.lastChar.toString("utf16le", 0, $);
    }
    return w;
  }
  function v(m, w) {
    var $ = (m.length - w) % 3;
    return $ === 0 ? m.toString("base64", w) : (this.lastNeed = 3 - $, this.lastTotal = 3, $ === 1 ? this.lastChar[0] = m[m.length - 1] : (this.lastChar[0] = m[m.length - 2], this.lastChar[1] = m[m.length - 1]), m.toString("base64", w, m.length - $));
  }
  function y(m) {
    var w = m && m.length ? this.write(m) : "";
    return this.lastNeed ? w + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : w;
  }
  function g(m) {
    return m.toString(this.encoding);
  }
  function _(m) {
    return m && m.length ? this.write(m) : "";
  }
  return Yp;
}
var d_ = ta.codes.ERR_STREAM_PREMATURE_CLOSE;
function o4(e) {
  var t = !1;
  return function() {
    if (!t) {
      t = !0;
      for (var r = arguments.length, n = new Array(r), i = 0; i < r; i++)
        n[i] = arguments[i];
      e.apply(this, n);
    }
  };
}
function u4() {
}
function c4(e) {
  return e.setHeader && typeof e.abort == "function";
}
function SO(e, t, r) {
  if (typeof t == "function")
    return SO(e, null, t);
  t || (t = {}), r = o4(r || u4);
  var n = t.readable || t.readable !== !1 && e.readable, i = t.writable || t.writable !== !1 && e.writable, s = function() {
    e.writable || u();
  }, a = e._writableState && e._writableState.finished, u = function() {
    i = !1, a = !0, n || r.call(e);
  }, c = e._readableState && e._readableState.endEmitted, l = function() {
    n = !1, c = !0, i || r.call(e);
  }, d = function(y) {
    r.call(e, y);
  }, p = function() {
    var y;
    if (n && !c)
      return (!e._readableState || !e._readableState.ended) && (y = new d_()), r.call(e, y);
    if (i && !a)
      return (!e._writableState || !e._writableState.ended) && (y = new d_()), r.call(e, y);
  }, h = function() {
    e.req.on("finish", u);
  };
  return c4(e) ? (e.on("complete", u), e.on("abort", p), e.req ? h() : e.on("request", h)) : i && !e._writableState && (e.on("end", s), e.on("close", s)), e.on("end", l), e.on("finish", u), t.error !== !1 && e.on("error", d), e.on("close", p), function() {
    e.removeListener("complete", u), e.removeListener("abort", p), e.removeListener("request", h), e.req && e.req.removeListener("finish", u), e.removeListener("end", s), e.removeListener("close", s), e.removeListener("finish", u), e.removeListener("end", l), e.removeListener("error", d), e.removeListener("close", p);
  };
}
var Lg = SO, Jp, p_;
function l4() {
  if (p_)
    return Jp;
  p_ = 1;
  var e;
  function t($, E, A) {
    return E = r(E), E in $ ? Object.defineProperty($, E, { value: A, enumerable: !0, configurable: !0, writable: !0 }) : $[E] = A, $;
  }
  function r($) {
    var E = n($, "string");
    return typeof E == "symbol" ? E : String(E);
  }
  function n($, E) {
    if (typeof $ != "object" || $ === null)
      return $;
    var A = $[Symbol.toPrimitive];
    if (A !== void 0) {
      var R = A.call($, E || "default");
      if (typeof R != "object")
        return R;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (E === "string" ? String : Number)($);
  }
  var i = Lg, s = Symbol("lastResolve"), a = Symbol("lastReject"), u = Symbol("error"), c = Symbol("ended"), l = Symbol("lastPromise"), d = Symbol("handlePromise"), p = Symbol("stream");
  function h($, E) {
    return {
      value: $,
      done: E
    };
  }
  function v($) {
    var E = $[s];
    if (E !== null) {
      var A = $[p].read();
      A !== null && ($[l] = null, $[s] = null, $[a] = null, E(h(A, !1)));
    }
  }
  function y($) {
    Me.process.nextTick(v, $);
  }
  function g($, E) {
    return function(A, R) {
      $.then(function() {
        if (E[c]) {
          A(h(void 0, !0));
          return;
        }
        E[d](A, R);
      }, R);
    };
  }
  var _ = Object.getPrototypeOf(function() {
  }), m = Object.setPrototypeOf((e = {
    get stream() {
      return this[p];
    },
    next: function() {
      var E = this, A = this[u];
      if (A !== null)
        return Promise.reject(A);
      if (this[c])
        return Promise.resolve(h(void 0, !0));
      if (this[p].destroyed)
        return new Promise(function(J, ae) {
          Me.process.nextTick(function() {
            E[u] ? ae(E[u]) : J(h(void 0, !0));
          });
        });
      var R = this[l], I;
      if (R)
        I = new Promise(g(R, this));
      else {
        var D = this[p].read();
        if (D !== null)
          return Promise.resolve(h(D, !1));
        I = new Promise(this[d]);
      }
      return this[l] = I, I;
    }
  }, t(e, Symbol.asyncIterator, function() {
    return this;
  }), t(e, "return", function() {
    var E = this;
    return new Promise(function(A, R) {
      E[p].destroy(null, function(I) {
        if (I) {
          R(I);
          return;
        }
        A(h(void 0, !0));
      });
    });
  }), e), _), w = function(E) {
    var A, R = Object.create(m, (A = {}, t(A, p, {
      value: E,
      writable: !0
    }), t(A, s, {
      value: null,
      writable: !0
    }), t(A, a, {
      value: null,
      writable: !0
    }), t(A, u, {
      value: null,
      writable: !0
    }), t(A, c, {
      value: E._readableState.endEmitted,
      writable: !0
    }), t(A, d, {
      value: function(D, J) {
        var ae = R[p].read();
        ae ? (R[l] = null, R[s] = null, R[a] = null, D(h(ae, !1))) : (R[s] = D, R[a] = J);
      },
      writable: !0
    }), A));
    return R[l] = null, i(E, function(I) {
      if (I && I.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var D = R[a];
        D !== null && (R[l] = null, R[s] = null, R[a] = null, D(I)), R[u] = I;
        return;
      }
      var J = R[s];
      J !== null && (R[l] = null, R[s] = null, R[a] = null, J(h(void 0, !0))), R[c] = !0;
    }), E.on("readable", y.bind(null, R)), R;
  };
  return Jp = w, Jp;
}
var Xp, h_;
function f4() {
  return h_ || (h_ = 1, Xp = function() {
    throw new Error("Readable.from is not available in the browser");
  }), Xp;
}
var Qp, m_;
function AO() {
  if (m_)
    return Qp;
  m_ = 1, Qp = J;
  var e;
  J.ReadableState = D, hg.EventEmitter;
  var t = function(U, pe) {
    return U.listeners(pe).length;
  }, r = $O, n = co.Buffer, i = (typeof rt < "u" ? rt : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function s(k) {
    return n.from(k);
  }
  function a(k) {
    return n.isBuffer(k) || k instanceof i;
  }
  var u = Ku, c;
  u && u.debuglog ? c = u.debuglog("stream") : c = function() {
  };
  var l = H6(), d = EO, p = OO, h = p.getHighWaterMark, v = ta.codes, y = v.ERR_INVALID_ARG_TYPE, g = v.ERR_STREAM_PUSH_AFTER_EOF, _ = v.ERR_METHOD_NOT_IMPLEMENTED, m = v.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, w, $, E;
  gs(J, r);
  var A = d.errorOrDestroy, R = ["error", "close", "destroy", "pause", "resume"];
  function I(k, U, pe) {
    if (typeof k.prependListener == "function")
      return k.prependListener(U, pe);
    !k._events || !k._events[U] ? k.on(U, pe) : Array.isArray(k._events[U]) ? k._events[U].unshift(pe) : k._events[U] = [pe, k._events[U]];
  }
  function D(k, U, pe) {
    e = e || so(), k = k || {}, typeof pe != "boolean" && (pe = U instanceof e), this.objectMode = !!k.objectMode, pe && (this.objectMode = this.objectMode || !!k.readableObjectMode), this.highWaterMark = h(this, k, "readableHighWaterMark", pe), this.buffer = new l(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = k.emitClose !== !1, this.autoDestroy = !!k.autoDestroy, this.destroyed = !1, this.defaultEncoding = k.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, k.encoding && (w || (w = f_().StringDecoder), this.decoder = new w(k.encoding), this.encoding = k.encoding);
  }
  function J(k) {
    if (e = e || so(), !(this instanceof J))
      return new J(k);
    var U = this instanceof e;
    this._readableState = new D(k, this, U), this.readable = !0, k && (typeof k.read == "function" && (this._read = k.read), typeof k.destroy == "function" && (this._destroy = k.destroy)), r.call(this);
  }
  Object.defineProperty(J.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(U) {
      this._readableState && (this._readableState.destroyed = U);
    }
  }), J.prototype.destroy = d.destroy, J.prototype._undestroy = d.undestroy, J.prototype._destroy = function(k, U) {
    U(k);
  }, J.prototype.push = function(k, U) {
    var pe = this._readableState, we;
    return pe.objectMode ? we = !0 : typeof k == "string" && (U = U || pe.defaultEncoding, U !== pe.encoding && (k = n.from(k, U), U = ""), we = !0), ae(this, k, U, !1, we);
  }, J.prototype.unshift = function(k) {
    return ae(this, k, null, !0, !1);
  };
  function ae(k, U, pe, we, He) {
    c("readableAddChunk", U);
    var Fe = k._readableState;
    if (U === null)
      Fe.reading = !1, le(k, Fe);
    else {
      var Ge;
      if (He || (Ge = xe(Fe, U)), Ge)
        A(k, Ge);
      else if (Fe.objectMode || U && U.length > 0)
        if (typeof U != "string" && !Fe.objectMode && Object.getPrototypeOf(U) !== n.prototype && (U = s(U)), we)
          Fe.endEmitted ? A(k, new m()) : ye(k, Fe, U, !0);
        else if (Fe.ended)
          A(k, new g());
        else {
          if (Fe.destroyed)
            return !1;
          Fe.reading = !1, Fe.decoder && !pe ? (U = Fe.decoder.write(U), Fe.objectMode || U.length !== 0 ? ye(k, Fe, U, !1) : _e(k, Fe)) : ye(k, Fe, U, !1);
        }
      else
        we || (Fe.reading = !1, _e(k, Fe));
    }
    return !Fe.ended && (Fe.length < Fe.highWaterMark || Fe.length === 0);
  }
  function ye(k, U, pe, we) {
    U.flowing && U.length === 0 && !U.sync ? (U.awaitDrain = 0, k.emit("data", pe)) : (U.length += U.objectMode ? 1 : pe.length, we ? U.buffer.unshift(pe) : U.buffer.push(pe), U.needReadable && $e(k)), _e(k, U);
  }
  function xe(k, U) {
    var pe;
    return !a(U) && typeof U != "string" && U !== void 0 && !k.objectMode && (pe = new y("chunk", ["string", "Buffer", "Uint8Array"], U)), pe;
  }
  J.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, J.prototype.setEncoding = function(k) {
    w || (w = f_().StringDecoder);
    var U = new w(k);
    this._readableState.decoder = U, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var pe = this._readableState.buffer.head, we = ""; pe !== null; )
      we += U.write(pe.data), pe = pe.next;
    return this._readableState.buffer.clear(), we !== "" && this._readableState.buffer.push(we), this._readableState.length = we.length, this;
  };
  var je = 1073741824;
  function re(k) {
    return k >= je ? k = je : (k--, k |= k >>> 1, k |= k >>> 2, k |= k >>> 4, k |= k >>> 8, k |= k >>> 16, k++), k;
  }
  function fe(k, U) {
    return k <= 0 || U.length === 0 && U.ended ? 0 : U.objectMode ? 1 : k !== k ? U.flowing && U.length ? U.buffer.head.data.length : U.length : (k > U.highWaterMark && (U.highWaterMark = re(k)), k <= U.length ? k : U.ended ? U.length : (U.needReadable = !0, 0));
  }
  J.prototype.read = function(k) {
    c("read", k), k = parseInt(k, 10);
    var U = this._readableState, pe = k;
    if (k !== 0 && (U.emittedReadable = !1), k === 0 && U.needReadable && ((U.highWaterMark !== 0 ? U.length >= U.highWaterMark : U.length > 0) || U.ended))
      return c("read: emitReadable", U.length, U.ended), U.length === 0 && U.ended ? T(this) : $e(this), null;
    if (k = fe(k, U), k === 0 && U.ended)
      return U.length === 0 && T(this), null;
    var we = U.needReadable;
    c("need readable", we), (U.length === 0 || U.length - k < U.highWaterMark) && (we = !0, c("length less than watermark", we)), U.ended || U.reading ? (we = !1, c("reading or ended", we)) : we && (c("do read"), U.reading = !0, U.sync = !0, U.length === 0 && (U.needReadable = !0), this._read(U.highWaterMark), U.sync = !1, U.reading || (k = fe(pe, U)));
    var He;
    return k > 0 ? He = F(k, U) : He = null, He === null ? (U.needReadable = U.length <= U.highWaterMark, k = 0) : (U.length -= k, U.awaitDrain = 0), U.length === 0 && (U.ended || (U.needReadable = !0), pe !== k && U.ended && T(this)), He !== null && this.emit("data", He), He;
  };
  function le(k, U) {
    if (c("onEofChunk"), !U.ended) {
      if (U.decoder) {
        var pe = U.decoder.end();
        pe && pe.length && (U.buffer.push(pe), U.length += U.objectMode ? 1 : pe.length);
      }
      U.ended = !0, U.sync ? $e(k) : (U.needReadable = !1, U.emittedReadable || (U.emittedReadable = !0, Ae(k)));
    }
  }
  function $e(k) {
    var U = k._readableState;
    c("emitReadable", U.needReadable, U.emittedReadable), U.needReadable = !1, U.emittedReadable || (c("emitReadable", U.flowing), U.emittedReadable = !0, Me.process.nextTick(Ae, k));
  }
  function Ae(k) {
    var U = k._readableState;
    c("emitReadable_", U.destroyed, U.length, U.ended), !U.destroyed && (U.length || U.ended) && (k.emit("readable"), U.emittedReadable = !1), U.needReadable = !U.flowing && !U.ended && U.length <= U.highWaterMark, N(k);
  }
  function _e(k, U) {
    U.readingMore || (U.readingMore = !0, Me.process.nextTick(ie, k, U));
  }
  function ie(k, U) {
    for (; !U.reading && !U.ended && (U.length < U.highWaterMark || U.flowing && U.length === 0); ) {
      var pe = U.length;
      if (c("maybeReadMore read 0"), k.read(0), pe === U.length)
        break;
    }
    U.readingMore = !1;
  }
  J.prototype._read = function(k) {
    A(this, new _("_read()"));
  }, J.prototype.pipe = function(k, U) {
    var pe = this, we = this._readableState;
    switch (we.pipesCount) {
      case 0:
        we.pipes = k;
        break;
      case 1:
        we.pipes = [we.pipes, k];
        break;
      default:
        we.pipes.push(k);
        break;
    }
    we.pipesCount += 1, c("pipe count=%d opts=%j", we.pipesCount, U);
    var He = (!U || U.end !== !1) && k !== Me.process.stdout && k !== Me.process.stderr, Fe = He ? jt : qe;
    we.endEmitted ? Me.process.nextTick(Fe) : pe.once("end", Fe), k.on("unpipe", Ge);
    function Ge(L, x) {
      c("onunpipe"), L === pe && x && x.hasUnpiped === !1 && (x.hasUnpiped = !0, St());
    }
    function jt() {
      c("onend"), k.end();
    }
    var Ee = K(pe);
    k.on("drain", Ee);
    var Mt = !1;
    function St() {
      c("cleanup"), k.removeListener("close", at), k.removeListener("finish", mt), k.removeListener("drain", Ee), k.removeListener("error", Le), k.removeListener("unpipe", Ge), pe.removeListener("end", jt), pe.removeListener("end", qe), pe.removeListener("data", Ne), Mt = !0, we.awaitDrain && (!k._writableState || k._writableState.needDrain) && Ee();
    }
    pe.on("data", Ne);
    function Ne(L) {
      c("ondata");
      var x = k.write(L);
      c("dest.write", x), x === !1 && ((we.pipesCount === 1 && we.pipes === k || we.pipesCount > 1 && Y(we.pipes, k) !== -1) && !Mt && (c("false write response, pause", we.awaitDrain), we.awaitDrain++), pe.pause());
    }
    function Le(L) {
      c("onerror", L), qe(), k.removeListener("error", Le), t(k, "error") === 0 && A(k, L);
    }
    I(k, "error", Le);
    function at() {
      k.removeListener("finish", mt), qe();
    }
    k.once("close", at);
    function mt() {
      c("onfinish"), k.removeListener("close", at), qe();
    }
    k.once("finish", mt);
    function qe() {
      c("unpipe"), pe.unpipe(k);
    }
    return k.emit("pipe", pe), we.flowing || (c("pipe resume"), pe.resume()), k;
  };
  function K(k) {
    return function() {
      var pe = k._readableState;
      c("pipeOnDrain", pe.awaitDrain), pe.awaitDrain && pe.awaitDrain--, pe.awaitDrain === 0 && t(k, "data") && (pe.flowing = !0, N(k));
    };
  }
  J.prototype.unpipe = function(k) {
    var U = this._readableState, pe = {
      hasUnpiped: !1
    };
    if (U.pipesCount === 0)
      return this;
    if (U.pipesCount === 1)
      return k && k !== U.pipes ? this : (k || (k = U.pipes), U.pipes = null, U.pipesCount = 0, U.flowing = !1, k && k.emit("unpipe", this, pe), this);
    if (!k) {
      var we = U.pipes, He = U.pipesCount;
      U.pipes = null, U.pipesCount = 0, U.flowing = !1;
      for (var Fe = 0; Fe < He; Fe++)
        we[Fe].emit("unpipe", this, {
          hasUnpiped: !1
        });
      return this;
    }
    var Ge = Y(U.pipes, k);
    return Ge === -1 ? this : (U.pipes.splice(Ge, 1), U.pipesCount -= 1, U.pipesCount === 1 && (U.pipes = U.pipes[0]), k.emit("unpipe", this, pe), this);
  }, J.prototype.on = function(k, U) {
    var pe = r.prototype.on.call(this, k, U), we = this._readableState;
    return k === "data" ? (we.readableListening = this.listenerCount("readable") > 0, we.flowing !== !1 && this.resume()) : k === "readable" && !we.endEmitted && !we.readableListening && (we.readableListening = we.needReadable = !0, we.flowing = !1, we.emittedReadable = !1, c("on readable", we.length, we.reading), we.length ? $e(this) : we.reading || Me.process.nextTick(z, this)), pe;
  }, J.prototype.addListener = J.prototype.on, J.prototype.removeListener = function(k, U) {
    var pe = r.prototype.removeListener.call(this, k, U);
    return k === "readable" && Me.process.nextTick(V, this), pe;
  }, J.prototype.removeAllListeners = function(k) {
    var U = r.prototype.removeAllListeners.apply(this, arguments);
    return (k === "readable" || k === void 0) && Me.process.nextTick(V, this), U;
  };
  function V(k) {
    var U = k._readableState;
    U.readableListening = k.listenerCount("readable") > 0, U.resumeScheduled && !U.paused ? U.flowing = !0 : k.listenerCount("data") > 0 && k.resume();
  }
  function z(k) {
    c("readable nexttick read 0"), k.read(0);
  }
  J.prototype.resume = function() {
    var k = this._readableState;
    return k.flowing || (c("resume"), k.flowing = !k.readableListening, C(this, k)), k.paused = !1, this;
  };
  function C(k, U) {
    U.resumeScheduled || (U.resumeScheduled = !0, Me.process.nextTick(q, k, U));
  }
  function q(k, U) {
    c("resume", U.reading), U.reading || k.read(0), U.resumeScheduled = !1, k.emit("resume"), N(k), U.flowing && !U.reading && k.read(0);
  }
  J.prototype.pause = function() {
    return c("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (c("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function N(k) {
    var U = k._readableState;
    for (c("flow", U.flowing); U.flowing && k.read() !== null; )
      ;
  }
  J.prototype.wrap = function(k) {
    var U = this, pe = this._readableState, we = !1;
    k.on("end", function() {
      if (c("wrapped end"), pe.decoder && !pe.ended) {
        var Ge = pe.decoder.end();
        Ge && Ge.length && U.push(Ge);
      }
      U.push(null);
    }), k.on("data", function(Ge) {
      if (c("wrapped data"), pe.decoder && (Ge = pe.decoder.write(Ge)), !(pe.objectMode && Ge == null) && !(!pe.objectMode && (!Ge || !Ge.length))) {
        var jt = U.push(Ge);
        jt || (we = !0, k.pause());
      }
    });
    for (var He in k)
      this[He] === void 0 && typeof k[He] == "function" && (this[He] = function(jt) {
        return function() {
          return k[jt].apply(k, arguments);
        };
      }(He));
    for (var Fe = 0; Fe < R.length; Fe++)
      k.on(R[Fe], this.emit.bind(this, R[Fe]));
    return this._read = function(Ge) {
      c("wrapped _read", Ge), we && (we = !1, k.resume());
    }, this;
  }, typeof Symbol == "function" && (J.prototype[Symbol.asyncIterator] = function() {
    return $ === void 0 && ($ = l4()), $(this);
  }), Object.defineProperty(J.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(J.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(J.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(U) {
      this._readableState && (this._readableState.flowing = U);
    }
  }), J._fromList = F, Object.defineProperty(J.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function F(k, U) {
    if (U.length === 0)
      return null;
    var pe;
    return U.objectMode ? pe = U.buffer.shift() : !k || k >= U.length ? (U.decoder ? pe = U.buffer.join("") : U.buffer.length === 1 ? pe = U.buffer.first() : pe = U.buffer.concat(U.length), U.buffer.clear()) : pe = U.buffer.consume(k, U.decoder), pe;
  }
  function T(k) {
    var U = k._readableState;
    c("endReadable", U.endEmitted), U.endEmitted || (U.ended = !0, Me.process.nextTick(Z, U, k));
  }
  function Z(k, U) {
    if (c("endReadableNT", k.endEmitted, k.length), !k.endEmitted && k.length === 0 && (k.endEmitted = !0, U.readable = !1, U.emit("end"), k.autoDestroy)) {
      var pe = U._writableState;
      (!pe || pe.autoDestroy && pe.finished) && U.destroy();
    }
  }
  typeof Symbol == "function" && (J.from = function(k, U) {
    return E === void 0 && (E = f4()), E(J, k, U);
  });
  function Y(k, U) {
    for (var pe = 0, we = k.length; pe < we; pe++)
      if (k[pe] === U)
        return pe;
    return -1;
  }
  return Qp;
}
var CO = Ti, Gf = ta.codes, d4 = Gf.ERR_METHOD_NOT_IMPLEMENTED, p4 = Gf.ERR_MULTIPLE_CALLBACK, h4 = Gf.ERR_TRANSFORM_ALREADY_TRANSFORMING, m4 = Gf.ERR_TRANSFORM_WITH_LENGTH_0, Kf = so();
gs(Ti, Kf);
function y4(e, t) {
  var r = this._transformState;
  r.transforming = !1;
  var n = r.writecb;
  if (n === null)
    return this.emit("error", new p4());
  r.writechunk = null, r.writecb = null, t != null && this.push(t), n(e);
  var i = this._readableState;
  i.reading = !1, (i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark);
}
function Ti(e) {
  if (!(this instanceof Ti))
    return new Ti(e);
  Kf.call(this, e), this._transformState = {
    afterTransform: y4.bind(this),
    needTransform: !1,
    transforming: !1,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }, this._readableState.needReadable = !0, this._readableState.sync = !1, e && (typeof e.transform == "function" && (this._transform = e.transform), typeof e.flush == "function" && (this._flush = e.flush)), this.on("prefinish", g4);
}
function g4() {
  var e = this;
  typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(t, r) {
    y_(e, t, r);
  }) : y_(this, null, null);
}
Ti.prototype.push = function(e, t) {
  return this._transformState.needTransform = !1, Kf.prototype.push.call(this, e, t);
};
Ti.prototype._transform = function(e, t, r) {
  r(new d4("_transform()"));
};
Ti.prototype._write = function(e, t, r) {
  var n = this._transformState;
  if (n.writecb = r, n.writechunk = e, n.writeencoding = t, !n.transforming) {
    var i = this._readableState;
    (n.needTransform || i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark);
  }
};
Ti.prototype._read = function(e) {
  var t = this._transformState;
  t.writechunk !== null && !t.transforming ? (t.transforming = !0, this._transform(t.writechunk, t.writeencoding, t.afterTransform)) : t.needTransform = !0;
};
Ti.prototype._destroy = function(e, t) {
  Kf.prototype._destroy.call(this, e, function(r) {
    t(r);
  });
};
function y_(e, t, r) {
  if (t)
    return e.emit("error", t);
  if (r != null && e.push(r), e._writableState.length)
    throw new m4();
  if (e._transformState.transforming)
    throw new h4();
  return e.push(null);
}
var v4 = Lu, RO = CO;
gs(Lu, RO);
function Lu(e) {
  if (!(this instanceof Lu))
    return new Lu(e);
  RO.call(this, e);
}
Lu.prototype._transform = function(e, t, r) {
  r(null, e);
};
var eh;
function b4(e) {
  var t = !1;
  return function() {
    t || (t = !0, e.apply(void 0, arguments));
  };
}
var TO = ta.codes, _4 = TO.ERR_MISSING_ARGS, w4 = TO.ERR_STREAM_DESTROYED;
function g_(e) {
  if (e)
    throw e;
}
function $4(e) {
  return e.setHeader && typeof e.abort == "function";
}
function E4(e, t, r, n) {
  n = b4(n);
  var i = !1;
  e.on("close", function() {
    i = !0;
  }), eh === void 0 && (eh = Lg), eh(e, {
    readable: t,
    writable: r
  }, function(a) {
    if (a)
      return n(a);
    i = !0, n();
  });
  var s = !1;
  return function(a) {
    if (!i && !s) {
      if (s = !0, $4(e))
        return e.abort();
      if (typeof e.destroy == "function")
        return e.destroy();
      n(a || new w4("pipe"));
    }
  };
}
function v_(e) {
  e();
}
function x4(e, t) {
  return e.pipe(t);
}
function O4(e) {
  return !e.length || typeof e[e.length - 1] != "function" ? g_ : e.pop();
}
function P4() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  var n = O4(t);
  if (Array.isArray(t[0]) && (t = t[0]), t.length < 2)
    throw new _4("streams");
  var i, s = t.map(function(a, u) {
    var c = u < t.length - 1, l = u > 0;
    return E4(a, c, l, function(d) {
      i || (i = d), d && s.forEach(v_), !c && (s.forEach(v_), n(i));
    });
  });
  return t.reduce(x4);
}
var S4 = P4;
(function(e, t) {
  t = e.exports = AO(), t.Stream = t, t.Readable = t, t.Writable = PO(), t.Duplex = so(), t.Transform = CO, t.PassThrough = v4, t.finished = Lg, t.pipeline = S4;
})(Ay, Ay.exports);
var IO = Ay.exports, b_ = Dg, A4 = gs, jO = IO, Qc = Hf.readyStates = {
  UNSENT: 0,
  OPENED: 1,
  HEADERS_RECEIVED: 2,
  LOADING: 3,
  DONE: 4
}, qg = Hf.IncomingMessage = function(e, t, r, n) {
  var i = this;
  if (jO.Readable.call(i), i._mode = r, i.headers = {}, i.rawHeaders = [], i.trailers = {}, i.rawTrailers = [], i.on("end", function() {
    Me.process.nextTick(function() {
      i.emit("close");
    });
  }), r === "fetch") {
    let d = function() {
      a.read().then(function(p) {
        if (!i._destroyed) {
          if (n(p.done), p.done) {
            i.push(null);
            return;
          }
          i.push(Me.Buffer.from(p.value)), d();
        }
      }).catch(function(p) {
        n(!0), i._destroyed || i.emit("error", p);
      });
    };
    if (i._fetchResponse = t, i.url = t.url, i.statusCode = t.status, i.statusMessage = t.statusText, t.headers.forEach(function(p, h) {
      i.headers[h.toLowerCase()] = p, i.rawHeaders.push(h, p);
    }), b_.writableStream) {
      var s = new WritableStream({
        write: function(p) {
          return n(!1), new Promise(function(h, v) {
            i._destroyed ? v() : i.push(Me.Buffer.from(p)) ? h() : i._resumeFetch = h;
          });
        },
        close: function() {
          n(!0), i._destroyed || i.push(null);
        },
        abort: function(p) {
          n(!0), i._destroyed || i.emit("error", p);
        }
      });
      try {
        t.body.pipeTo(s).catch(function(p) {
          n(!0), i._destroyed || i.emit("error", p);
        });
        return;
      } catch {
      }
    }
    var a = t.body.getReader();
    d();
  } else {
    i._xhr = e, i._pos = 0, i.url = e.responseURL, i.statusCode = e.status, i.statusMessage = e.statusText;
    var u = e.getAllResponseHeaders().split(/\r?\n/);
    if (u.forEach(function(d) {
      var p = d.match(/^([^:]+):\s*(.*)/);
      if (p) {
        var h = p[1].toLowerCase();
        h === "set-cookie" ? (i.headers[h] === void 0 && (i.headers[h] = []), i.headers[h].push(p[2])) : i.headers[h] !== void 0 ? i.headers[h] += ", " + p[2] : i.headers[h] = p[2], i.rawHeaders.push(p[1], p[2]);
      }
    }), i._charset = "x-user-defined", !b_.overrideMimeType) {
      var c = i.rawHeaders["mime-type"];
      if (c) {
        var l = c.match(/;\s*charset=([^;])(;|$)/);
        l && (i._charset = l[1].toLowerCase());
      }
      i._charset || (i._charset = "utf-8");
    }
  }
};
A4(qg, jO.Readable);
qg.prototype._read = function() {
  var e = this, t = e._resumeFetch;
  t && (e._resumeFetch = null, t());
};
qg.prototype._onXHRProgress = function(e) {
  var t = this, r = t._xhr, n = null;
  switch (t._mode) {
    case "text":
      if (n = r.responseText, n.length > t._pos) {
        var i = n.substr(t._pos);
        if (t._charset === "x-user-defined") {
          for (var s = Me.Buffer.alloc(i.length), a = 0; a < i.length; a++)
            s[a] = i.charCodeAt(a) & 255;
          t.push(s);
        } else
          t.push(i, t._charset);
        t._pos = n.length;
      }
      break;
    case "arraybuffer":
      if (r.readyState !== Qc.DONE || !r.response)
        break;
      n = r.response, t.push(Me.Buffer.from(new Uint8Array(n)));
      break;
    case "moz-chunked-arraybuffer":
      if (n = r.response, r.readyState !== Qc.LOADING || !n)
        break;
      t.push(Me.Buffer.from(new Uint8Array(n)));
      break;
    case "ms-stream":
      if (n = r.response, r.readyState !== Qc.LOADING)
        break;
      var u = new rt.MSStreamReader();
      u.onprogress = function() {
        u.result.byteLength > t._pos && (t.push(Me.Buffer.from(new Uint8Array(u.result.slice(t._pos)))), t._pos = u.result.byteLength);
      }, u.onload = function() {
        e(!0), t.push(null);
      }, u.readAsArrayBuffer(n);
      break;
  }
  t._xhr.readyState === Qc.DONE && t._mode !== "ms-stream" && (e(!0), t.push(null));
};
var Zs = Dg, C4 = gs, kO = Hf, Fg = IO, R4 = kO.IncomingMessage, __ = kO.readyStates;
function T4(e, t) {
  return Zs.fetch && t ? "fetch" : Zs.mozchunkedarraybuffer ? "moz-chunked-arraybuffer" : Zs.msstream ? "ms-stream" : Zs.arraybuffer && e ? "arraybuffer" : "text";
}
var Cr = wO.exports = function(e) {
  var t = this;
  Fg.Writable.call(t), t._opts = e, t._body = [], t._headers = {}, e.auth && t.setHeader("Authorization", "Basic " + Me.Buffer.from(e.auth).toString("base64")), Object.keys(e.headers).forEach(function(i) {
    t.setHeader(i, e.headers[i]);
  });
  var r, n = !0;
  if (e.mode === "disable-fetch" || "requestTimeout" in e && !Zs.abortController)
    n = !1, r = !0;
  else if (e.mode === "prefer-streaming")
    r = !1;
  else if (e.mode === "allow-wrong-content-type")
    r = !Zs.overrideMimeType;
  else if (!e.mode || e.mode === "default" || e.mode === "prefer-fast")
    r = !0;
  else
    throw new Error("Invalid value for opts.mode");
  t._mode = T4(r, n), t._fetchTimer = null, t._socketTimeout = null, t._socketTimer = null, t.on("finish", function() {
    t._onFinish();
  });
};
C4(Cr, Fg.Writable);
Cr.prototype.setHeader = function(e, t) {
  var r = this, n = e.toLowerCase();
  j4.indexOf(n) === -1 && (r._headers[n] = {
    name: e,
    value: t
  });
};
Cr.prototype.getHeader = function(e) {
  var t = this._headers[e.toLowerCase()];
  return t ? t.value : null;
};
Cr.prototype.removeHeader = function(e) {
  var t = this;
  delete t._headers[e.toLowerCase()];
};
Cr.prototype._onFinish = function() {
  var e = this;
  if (!e._destroyed) {
    var t = e._opts;
    "timeout" in t && t.timeout !== 0 && e.setTimeout(t.timeout);
    var r = e._headers, n = null;
    t.method !== "GET" && t.method !== "HEAD" && (n = new Blob(e._body, {
      type: (r["content-type"] || {}).value || ""
    }));
    var i = [];
    if (Object.keys(r).forEach(function(c) {
      var l = r[c].name, d = r[c].value;
      Array.isArray(d) ? d.forEach(function(p) {
        i.push([l, p]);
      }) : i.push([l, d]);
    }), e._mode === "fetch") {
      var s = null;
      if (Zs.abortController) {
        var a = new AbortController();
        s = a.signal, e._fetchAbortController = a, "requestTimeout" in t && t.requestTimeout !== 0 && (e._fetchTimer = rt.setTimeout(function() {
          e.emit("requestTimeout"), e._fetchAbortController && e._fetchAbortController.abort();
        }, t.requestTimeout));
      }
      rt.fetch(e._opts.url, {
        method: e._opts.method,
        headers: i,
        body: n || void 0,
        mode: "cors",
        credentials: t.withCredentials ? "include" : "same-origin",
        signal: s
      }).then(function(c) {
        e._fetchResponse = c, e._resetTimers(!1), e._connect();
      }, function(c) {
        e._resetTimers(!0), e._destroyed || e.emit("error", c);
      });
    } else {
      var u = e._xhr = new rt.XMLHttpRequest();
      try {
        u.open(e._opts.method, e._opts.url, !0);
      } catch (c) {
        Me.process.nextTick(function() {
          e.emit("error", c);
        });
        return;
      }
      "responseType" in u && (u.responseType = e._mode), "withCredentials" in u && (u.withCredentials = !!t.withCredentials), e._mode === "text" && "overrideMimeType" in u && u.overrideMimeType("text/plain; charset=x-user-defined"), "requestTimeout" in t && (u.timeout = t.requestTimeout, u.ontimeout = function() {
        e.emit("requestTimeout");
      }), i.forEach(function(c) {
        u.setRequestHeader(c[0], c[1]);
      }), e._response = null, u.onreadystatechange = function() {
        switch (u.readyState) {
          case __.LOADING:
          case __.DONE:
            e._onXHRProgress();
            break;
        }
      }, e._mode === "moz-chunked-arraybuffer" && (u.onprogress = function() {
        e._onXHRProgress();
      }), u.onerror = function() {
        e._destroyed || (e._resetTimers(!0), e.emit("error", new Error("XHR error")));
      };
      try {
        u.send(n);
      } catch (c) {
        Me.process.nextTick(function() {
          e.emit("error", c);
        });
        return;
      }
    }
  }
};
function I4(e) {
  try {
    var t = e.status;
    return t !== null && t !== 0;
  } catch {
    return !1;
  }
}
Cr.prototype._onXHRProgress = function() {
  var e = this;
  e._resetTimers(!1), !(!I4(e._xhr) || e._destroyed) && (e._response || e._connect(), e._response._onXHRProgress(e._resetTimers.bind(e)));
};
Cr.prototype._connect = function() {
  var e = this;
  e._destroyed || (e._response = new R4(e._xhr, e._fetchResponse, e._mode, e._resetTimers.bind(e)), e._response.on("error", function(t) {
    e.emit("error", t);
  }), e.emit("response", e._response));
};
Cr.prototype._write = function(e, t, r) {
  var n = this;
  n._body.push(e), r();
};
Cr.prototype._resetTimers = function(e) {
  var t = this;
  rt.clearTimeout(t._socketTimer), t._socketTimer = null, e ? (rt.clearTimeout(t._fetchTimer), t._fetchTimer = null) : t._socketTimeout && (t._socketTimer = rt.setTimeout(function() {
    t.emit("timeout");
  }, t._socketTimeout));
};
Cr.prototype.abort = Cr.prototype.destroy = function(e) {
  var t = this;
  t._destroyed = !0, t._resetTimers(!0), t._response && (t._response._destroyed = !0), t._xhr ? t._xhr.abort() : t._fetchAbortController && t._fetchAbortController.abort(), e && t.emit("error", e);
};
Cr.prototype.end = function(e, t, r) {
  var n = this;
  typeof e == "function" && (r = e, e = void 0), Fg.Writable.prototype.end.call(n, e, t, r);
};
Cr.prototype.setTimeout = function(e, t) {
  var r = this;
  t && r.once("timeout", t), r._socketTimeout = e, r._resetTimers(!1);
};
Cr.prototype.flushHeaders = function() {
};
Cr.prototype.setNoDelay = function() {
};
Cr.prototype.setSocketKeepAlive = function() {
};
var j4 = [
  "accept-charset",
  "accept-encoding",
  "access-control-request-headers",
  "access-control-request-method",
  "connection",
  "content-length",
  "cookie",
  "cookie2",
  "date",
  "dnt",
  "expect",
  "host",
  "keep-alive",
  "origin",
  "referer",
  "te",
  "trailer",
  "transfer-encoding",
  "upgrade",
  "via"
], k4 = wO.exports, M4 = D4, N4 = Object.prototype.hasOwnProperty;
function D4() {
  for (var e = {}, t = 0; t < arguments.length; t++) {
    var r = arguments[t];
    for (var n in r)
      N4.call(r, n) && (e[n] = r[n]);
  }
  return e;
}
var L4 = {
  100: "Continue",
  101: "Switching Protocols",
  102: "Processing",
  200: "OK",
  201: "Created",
  202: "Accepted",
  203: "Non-Authoritative Information",
  204: "No Content",
  205: "Reset Content",
  206: "Partial Content",
  207: "Multi-Status",
  208: "Already Reported",
  226: "IM Used",
  300: "Multiple Choices",
  301: "Moved Permanently",
  302: "Found",
  303: "See Other",
  304: "Not Modified",
  305: "Use Proxy",
  307: "Temporary Redirect",
  308: "Permanent Redirect",
  400: "Bad Request",
  401: "Unauthorized",
  402: "Payment Required",
  403: "Forbidden",
  404: "Not Found",
  405: "Method Not Allowed",
  406: "Not Acceptable",
  407: "Proxy Authentication Required",
  408: "Request Timeout",
  409: "Conflict",
  410: "Gone",
  411: "Length Required",
  412: "Precondition Failed",
  413: "Payload Too Large",
  414: "URI Too Long",
  415: "Unsupported Media Type",
  416: "Range Not Satisfiable",
  417: "Expectation Failed",
  418: "I'm a teapot",
  421: "Misdirected Request",
  422: "Unprocessable Entity",
  423: "Locked",
  424: "Failed Dependency",
  425: "Unordered Collection",
  426: "Upgrade Required",
  428: "Precondition Required",
  429: "Too Many Requests",
  431: "Request Header Fields Too Large",
  451: "Unavailable For Legal Reasons",
  500: "Internal Server Error",
  501: "Not Implemented",
  502: "Bad Gateway",
  503: "Service Unavailable",
  504: "Gateway Timeout",
  505: "HTTP Version Not Supported",
  506: "Variant Also Negotiates",
  507: "Insufficient Storage",
  508: "Loop Detected",
  509: "Bandwidth Limit Exceeded",
  510: "Not Extended",
  511: "Network Authentication Required"
};
(function(e) {
  var t = k4, r = Hf, n = M4, i = L4, s = Iu, a = e;
  a.request = function(u, c) {
    typeof u == "string" ? u = s.parse(u) : u = n(u);
    var l = rt.location.protocol.search(/^https?:$/) === -1 ? "http:" : "", d = u.protocol || l, p = u.hostname || u.host, h = u.port, v = u.path || "/";
    p && p.indexOf(":") !== -1 && (p = "[" + p + "]"), u.url = (p ? d + "//" + p : "") + (h ? ":" + h : "") + v, u.method = (u.method || "GET").toUpperCase(), u.headers = u.headers || {};
    var y = new t(u);
    return c && y.on("response", c), y;
  }, a.get = function(c, l) {
    var d = a.request(c, l);
    return d.end(), d;
  }, a.ClientRequest = t, a.IncomingMessage = r.IncomingMessage, a.Agent = function() {
  }, a.Agent.defaultMaxSockets = 4, a.globalAgent = new a.Agent(), a.STATUS_CODES = i, a.METHODS = [
    "CHECKOUT",
    "CONNECT",
    "COPY",
    "DELETE",
    "GET",
    "HEAD",
    "LOCK",
    "M-SEARCH",
    "MERGE",
    "MKACTIVITY",
    "MKCOL",
    "MOVE",
    "NOTIFY",
    "OPTIONS",
    "PATCH",
    "POST",
    "PROPFIND",
    "PROPPATCH",
    "PURGE",
    "PUT",
    "REPORT",
    "SEARCH",
    "SUBSCRIBE",
    "TRACE",
    "UNLOCK",
    "UNSUBSCRIBE"
  ];
})(Wf);
var MO = { exports: {} };
(function(e) {
  var t = Wf, r = Iu, n = e.exports;
  for (var i in t)
    t.hasOwnProperty(i) && (n[i] = t[i]);
  n.request = function(a, u) {
    return a = s(a), t.request.call(this, a, u);
  }, n.get = function(a, u) {
    return a = s(a), t.get.call(this, a, u);
  };
  function s(a) {
    if (typeof a == "string" && (a = r.parse(a)), a.protocol || (a.protocol = "https:"), a.protocol !== "https:")
      throw new Error('Protocol "' + a.protocol + '" not supported. Expected "https:"');
    return a;
  }
})(MO);
var NO = MO.exports;
const q4 = Wf, F4 = NO, { ono: el } = Nn, { ResolverError: w_ } = or, fu = gn;
function U4(e, t) {
  return new Promise((r, n) => {
    const s = (e.protocol === "https:" ? F4 : q4).get({
      hostname: e.hostname,
      port: e.port,
      path: e.path,
      auth: e.auth,
      protocol: e.protocol,
      headers: t.headers || {},
      withCredentials: t.withCredentials
    });
    typeof s.setTimeout == "function" && s.setTimeout(t.timeout), s.on("timeout", () => {
      s.abort();
    }), s.on("error", n), s.once("response", (a) => {
      a.body = Me.Buffer.alloc(0), a.on("data", (u) => {
        a.body = Me.Buffer.concat([a.body, Me.Buffer.from(u)]);
      }), a.on("error", n), a.on("end", () => {
        r(a);
      });
    });
  });
}
function DO(e, t, r) {
  return new Promise((n, i) => {
    e = fu.parse(e), r = r || [], r.push(e.href), U4(e, t).then((s) => {
      if (s.statusCode >= 400)
        throw el({ status: s.statusCode }, `HTTP ERROR ${s.statusCode}`);
      if (s.statusCode >= 300)
        if (r.length > t.redirects)
          i(
            new w_(
              el(
                { status: s.statusCode },
                `Error downloading ${r[0]}. 
Too many redirects: 
  ${r.join(` 
  `)}`
              )
            )
          );
        else if (s.headers.location) {
          const a = fu.resolve(e, s.headers.location);
          DO(a, t, r).then(n, i);
        } else
          throw el({ status: s.statusCode }, `HTTP ${s.statusCode} redirect with no location header`);
      else
        n(s.body || Me.Buffer.alloc(0));
    }).catch((s) => {
      i(new w_(el(s, `Error downloading ${e.href}`), e.href));
    });
  });
}
var B4 = {
  /**
   * The order that this resolver will run, in relation to other resolvers.
   *
   * @type {number}
   */
  order: 200,
  /**
   * HTTP headers to send when downloading files.
   *
   * @example:
   * {
   *   "User-Agent": "JSON Schema $Ref Parser",
   *   Accept: "application/json"
   * }
   *
   * @type {object}
   */
  headers: null,
  /**
   * HTTP request timeout (in milliseconds).
   *
   * @type {number}
   */
  timeout: 5e3,
  // 5 seconds
  /**
   * The maximum number of HTTP redirects to follow.
   * To disable automatic following of redirects, set this to zero.
   *
   * @type {number}
   */
  redirects: 5,
  /**
   * The `withCredentials` option of XMLHttpRequest.
   * Set this to `true` if you're downloading files from a CORS-enabled server that requires authentication
   *
   * @type {boolean}
   */
  withCredentials: !1,
  /**
   * Determines whether this resolver can read a given file reference.
   * Resolvers that return true will be tried in order, until one successfully resolves the file.
   * Resolvers that return false will not be given a chance to resolve the file.
   *
   * @param {object} file           - An object containing information about the referenced file
   * @param {string} file.url       - The full URL of the referenced file
   * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
   * @returns {boolean}
   */
  canRead(e) {
    return fu.isHttp(e.url);
  },
  /**
   * Reads the given URL and returns its raw contents as a Buffer.
   *
   * @param {object} file           - An object containing information about the referenced file
   * @param {string} file.url       - The full URL of the referenced file
   * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
   * @returns {Promise<Buffer>}
   */
  read(e) {
    const t = fu.parse(e.url);
    return Me.process.browser && !t.protocol && (t.protocol = fu.parse(location.href).protocol), DO(t, this);
  }
};
const V4 = bD, Z4 = wD, z4 = xD, W4 = B6, H4 = W6, G4 = B4;
var LO = Ug;
function Ug(e) {
  Ry(this, Ug.defaults), Ry(this, e);
}
Ug.defaults = {
  /**
   * Determines how different types of files will be parsed.
   *
   * You can add additional parsers of your own, replace an existing one with
   * your own implementation, or disable any parser by setting it to false.
   */
  parse: {
    json: Z4,
    yaml: W4,
    text: z4,
    binary: V4
  },
  /**
   * Determines how JSON References will be resolved.
   *
   * You can add additional resolvers of your own, replace an existing one with
   * your own implementation, or disable any resolver by setting it to false.
   */
  resolve: {
    file: H4,
    http: G4,
    /**
     * Determines whether external $ref pointers will be resolved.
     * If this option is disabled, then none of above resolvers will be called.
     * Instead, external $ref pointers will simply be ignored.
     *
     * @type {boolean}
     */
    external: !0
  },
  /**
   * By default, JSON Schema $Ref Parser throws the first error it encounters. Setting `continueOnError` to `true`
   * causes it to keep processing as much as possible and then throw a single error that contains all errors
   * that were encountered.
   */
  continueOnError: !1,
  /**
   * Determines the types of JSON references that are allowed.
   */
  dereference: {
    /**
     * Dereference circular (recursive) JSON references?
     * If false, then a {@link ReferenceError} will be thrown if a circular reference is found.
     * If "ignore", then circular references will not be dereferenced.
     *
     * @type {boolean|string}
     */
    circular: !0
  }
};
function Ry(e, t) {
  if ($_(t)) {
    const r = Object.keys(t);
    for (let n = 0; n < r.length; n++) {
      const i = r[n], s = t[i], a = e[i];
      $_(s) ? e[i] = Ry(a || {}, s) : s !== void 0 && (e[i] = s);
    }
  }
  return e;
}
function $_(e) {
  return e && typeof e == "object" && !Array.isArray(e) && !(e instanceof RegExp) && !(e instanceof Date);
}
const E_ = LO;
var qO = function(t) {
  let r, n, i, s;
  return t = Array.prototype.slice.call(t), typeof t[t.length - 1] == "function" && (s = t.pop()), typeof t[0] == "string" ? (r = t[0], typeof t[2] == "object" ? (n = t[1], i = t[2]) : (n = void 0, i = t[1])) : (r = "", n = t[0], i = t[1]), i instanceof E_ || (i = new E_(i)), {
    path: r,
    schema: n,
    options: i,
    callback: s
  };
}, tc = {};
tc.all = function(e) {
  return Object.keys(e).filter((t) => typeof e[t] == "object").map((t) => (e[t].name = t, e[t]));
};
tc.filter = function(e, t, r) {
  return e.filter((n) => !!FO(n, t, r));
};
tc.sort = function(e) {
  for (const t of e)
    t.order = t.order || Number.MAX_SAFE_INTEGER;
  return e.sort((t, r) => t.order - r.order);
};
tc.run = function(e, t, r, n) {
  let i, s, a = 0;
  return new Promise((u, c) => {
    l();
    function l() {
      if (i = e[a++], !i)
        return c(s);
      try {
        const v = FO(i, t, r, d, n);
        if (v && typeof v.then == "function")
          v.then(p, h);
        else if (v !== void 0)
          p(v);
        else if (a === e.length)
          throw new Error("No promise has been returned or callback has been called.");
      } catch (v) {
        h(v);
      }
    }
    function d(v, y) {
      v ? h(v) : p(y);
    }
    function p(v) {
      u({
        plugin: i,
        result: v
      });
    }
    function h(v) {
      s = {
        plugin: i,
        error: v
      }, l();
    }
  });
};
function FO(e, t, r, n, i) {
  const s = e[t];
  if (typeof s == "function")
    return s.apply(e, [r, n, i]);
  if (!n) {
    if (s instanceof RegExp)
      return s.test(r.url);
    if (typeof s == "string")
      return s === r.extension;
    if (Array.isArray(s))
      return s.indexOf(r.extension) !== -1;
  }
  return s;
}
const { ono: Ty } = Nn, {
  ResolverError: x_,
  ParserError: O_,
  UnmatchedParserError: K4,
  UnmatchedResolverError: Y4,
  isHandledError: J4
} = or, is = tc, P_ = gn;
var UO = async function(t, r, n) {
  t = P_.stripHash(t);
  const i = r._add(t), s = {
    url: t,
    extension: P_.getExtension(t)
  };
  try {
    const a = await X4(s, n, r);
    i.pathType = a.plugin.name, s.data = a.result;
    const u = await Q4(s, n, r);
    return i.value = u.result, u.result;
  } catch (a) {
    throw J4(a) && (i.value = a), a;
  }
};
function X4(e, t, r) {
  return new Promise((n, i) => {
    let s = is.all(t.resolve);
    s = is.filter(s, "canRead", e), is.sort(s), is.run(s, "read", e, r).then(n, a);
    function a(u) {
      !u && t.continueOnError ? i(new Y4(e.url)) : !u || !("error" in u) ? i(Ty.syntax(`Unable to resolve $ref pointer "${e.url}"`)) : u.error instanceof x_ ? i(u.error) : i(new x_(u, e.url));
    }
  });
}
function Q4(e, t, r) {
  return new Promise((n, i) => {
    const s = is.all(t.parse), a = is.filter(s, "canParse", e), u = a.length > 0 ? a : s;
    is.sort(u), is.run(u, "parse", e, r).then(c, l);
    function c(d) {
      !d.plugin.allowEmpty && eq(d.result) ? i(Ty.syntax(`Error parsing "${e.url}" as ${d.plugin.name}. 
Parsed value is empty`)) : n(d);
    }
    function l(d) {
      !d && t.continueOnError ? i(new K4(e.url)) : !d || !("error" in d) ? i(Ty.syntax(`Unable to parse ${e.url}`)) : d.error instanceof O_ ? i(d.error) : i(new O_(d.error.message, e.url));
    }
  });
}
function eq(e) {
  return e === void 0 || typeof e == "object" && Object.keys(e).length === 0 || typeof e == "string" && e.trim().length === 0 || Me.Buffer.isBuffer(e) && e.length === 0;
}
const { ono: BO } = Nn, tq = Xu(), ms = gn;
var rq = Mn;
function Mn() {
  this.circular = !1, this.circularRefs = [], this._$refs = {}, this._root$Ref = null;
}
Mn.prototype.paths = function(e) {
  return VO(this._$refs, arguments).map((r) => r.decoded);
};
Mn.prototype.values = function(e) {
  const t = this._$refs;
  return VO(t, arguments).reduce((n, i) => (n[i.decoded] = t[i.encoded].value, n), {});
};
Mn.prototype.toJSON = Mn.prototype.values;
Mn.prototype.exists = function(e, t) {
  try {
    return this._resolve(e, "", t), !0;
  } catch {
    return !1;
  }
};
Mn.prototype.get = function(e, t) {
  return this._resolve(e, "", t).value;
};
Mn.prototype.set = function(e, t) {
  const r = ms.resolve(this._root$Ref.path, e), n = ms.stripHash(r), i = this._$refs[n];
  if (!i)
    throw BO(`Error resolving $ref pointer "${e}". 
"${n}" not found.`);
  i.set(r, t);
};
Mn.prototype._add = function(e) {
  const t = ms.stripHash(e), r = new tq();
  return r.path = t, r.$refs = this, this._$refs[t] = r, this._root$Ref = this._root$Ref || r, r;
};
Mn.prototype._resolve = function(e, t, r) {
  const n = ms.resolve(this._root$Ref.path, e), i = ms.stripHash(n), s = this._$refs[i];
  if (!s)
    throw BO(`Error resolving $ref pointer "${e}". 
"${i}" not found.`);
  return s.resolve(n, r, e, t);
};
Mn.prototype._get$Ref = function(e) {
  e = ms.resolve(this._root$Ref.path, e);
  const t = ms.stripHash(e);
  return this._$refs[t];
};
function VO(e, t) {
  let r = Object.keys(e);
  return t = Array.isArray(t[0]) ? t[0] : Array.prototype.slice.call(t), t.length > 0 && t[0] && (r = r.filter((n) => t.indexOf(e[n].pathType) !== -1)), r.map((n) => ({
    encoded: n,
    decoded: e[n].pathType === "file" ? ms.toFileSystemPath(n, !0) : n
  }));
}
const nq = UO, iq = Vf(), S_ = Xu(), { isHandledError: sq } = or, zo = gn;
var aq = oq;
function oq(e, t) {
  if (!t.resolve.external)
    return Promise.resolve();
  try {
    const r = Bg(e.schema, `${e.$refs._root$Ref.path}#`, e.$refs, t);
    return Promise.all(r);
  } catch (r) {
    return Promise.reject(r);
  }
}
function Bg(e, t, r, n, i) {
  i = i || /* @__PURE__ */ new Set();
  let s = [];
  if (e && typeof e == "object" && !ArrayBuffer.isView(e) && !i.has(e))
    if (i.add(e), S_.isExternal$Ref(e))
      s.push(A_(e, t, r, n));
    else
      for (const a of Object.keys(e)) {
        const u = iq.join(t, a), c = e[a];
        S_.isExternal$Ref(c) ? s.push(A_(c, u, r, n)) : s = s.concat(Bg(c, u, r, n, i));
      }
  return s;
}
async function A_(e, t, r, n) {
  const i = zo.resolve(t, e.$ref), s = zo.stripHash(i);
  if (e = r._$refs[s], e)
    return Promise.resolve(e.value);
  try {
    const a = await nq(i, r, n), u = Bg(a, `${s}#`, r, n);
    return Promise.all(u);
  } catch (a) {
    if (!n.continueOnError || !sq(a))
      throw a;
    return r._$refs[s] && (a.source = zo.stripHash(t), a.path = zo.safePointerToPath(zo.getHash(t))), [];
  }
}
const { ono: C_ } = Nn, An = rx, uq = dD, cq = Ax, Yf = qO, lq = UO, ZO = rq, fq = aq, {
  JSONParserError: dq,
  InvalidPointerError: pq,
  MissingPointerError: hq,
  ResolverError: mq,
  ParserError: yq,
  UnmatchedParserError: gq,
  UnmatchedResolverError: vq,
  isHandledError: bq,
  JSONParserErrorGroup: R_
} = or, Ca = gn;
ai.exports = oi;
ai.exports.default = oi;
ai.exports.JSONParserError = dq;
ai.exports.InvalidPointerError = pq;
ai.exports.MissingPointerError = hq;
ai.exports.ResolverError = mq;
ai.exports.ParserError = yq;
ai.exports.UnmatchedParserError = gq;
ai.exports.UnmatchedResolverError = vq;
function oi() {
  this.schema = null, this.$refs = new ZO();
}
oi.parse = function(t, r, n, i) {
  const s = this, a = new s();
  return a.parse.apply(a, arguments);
};
oi.prototype.parse = async function(t, r, n, i) {
  const s = Yf(arguments);
  let a;
  if (!s.path && !s.schema) {
    const l = C_(`Expected a file path, URL, or object. Got ${s.path || s.schema}`);
    return An(s.callback, Promise.reject(l));
  }
  this.schema = null, this.$refs = new ZO();
  let u = "http";
  if (Ca.isFileSystemPath(s.path) && (s.path = Ca.fromFileSystemPath(s.path), u = "file"), s.path = Ca.resolve(Ca.cwd(), s.path), s.schema && typeof s.schema == "object") {
    const l = this.$refs._add(s.path);
    l.value = s.schema, l.pathType = u, a = Promise.resolve(s.schema);
  } else
    a = lq(s.path, this.$refs, s.options);
  const c = this;
  try {
    const l = await a;
    if (l !== null && typeof l == "object" && !Me.Buffer.isBuffer(l))
      return c.schema = l, An(s.callback, Promise.resolve(c.schema));
    if (s.options.continueOnError)
      return c.schema = null, An(s.callback, Promise.resolve(c.schema));
    throw C_.syntax(`"${c.$refs._root$Ref.path || l}" is not a valid JSON Schema`);
  } catch (l) {
    return !s.options.continueOnError || !bq(l) ? An(s.callback, Promise.reject(l)) : (this.$refs._$refs[Ca.stripHash(s.path)] && this.$refs._$refs[Ca.stripHash(s.path)].addError(l), An(s.callback, Promise.resolve(null)));
  }
};
oi.resolve = function(t, r, n, i) {
  const s = this, a = new s();
  return a.resolve.apply(a, arguments);
};
oi.prototype.resolve = async function(t, r, n, i) {
  const s = this, a = Yf(arguments);
  try {
    return await this.parse(a.path, a.schema, a.options), await fq(s, a.options), Vg(s), An(a.callback, Promise.resolve(s.$refs));
  } catch (u) {
    return An(a.callback, Promise.reject(u));
  }
};
oi.bundle = function(t, r, n, i) {
  const s = this, a = new s();
  return a.bundle.apply(a, arguments);
};
oi.prototype.bundle = async function(t, r, n, i) {
  const s = this, a = Yf(arguments);
  try {
    return await this.resolve(a.path, a.schema, a.options), uq(s, a.options), Vg(s), An(a.callback, Promise.resolve(s.schema));
  } catch (u) {
    return An(a.callback, Promise.reject(u));
  }
};
oi.dereference = function(t, r, n, i) {
  const s = this, a = new s();
  return a.dereference.apply(a, arguments);
};
oi.prototype.dereference = async function(t, r, n, i) {
  const s = this, a = Yf(arguments);
  try {
    return await this.resolve(a.path, a.schema, a.options), cq(s, a.options), Vg(s), An(a.callback, Promise.resolve(s.schema));
  } catch (u) {
    return An(a.callback, Promise.reject(u));
  }
};
function Vg(e) {
  if (R_.getParserErrors(e).length > 0)
    throw new R_(e);
}
var _q = ai.exports, ui = {};
const zO = Ku, wq = gn;
ui.format = zO.format;
ui.inherits = zO.inherits;
ui.swaggerParamRegExp = /\{([^/}]+)}/g;
const $q = ["get", "post", "put", "delete", "patch", "options", "head", "trace"];
function th(e, t) {
  if (e.url && e.url.startsWith("/")) {
    const r = wq.parse(t), n = `${r.protocol}//${r.hostname}${e.url}`;
    e.url = n;
  }
  return e;
}
function Eq(e, t) {
  e.openapi && t && (t.startsWith("http:") || t.startsWith("https:")) && (e.servers && e.servers.map((r) => th(r, t)), ["paths", "webhooks"].forEach((r) => {
    Object.keys(e[r] || []).forEach((n) => {
      const i = e[r][n];
      Object.keys(i).forEach((s) => {
        s === "servers" ? i[s].map((a) => th(a, t)) : $q.includes(s) && i[s].servers && i[s].servers.map((a) => th(a, t));
      });
    });
  }));
}
function xq(e) {
  return e.swagger ? "Swagger" : "OpenAPI";
}
ui.fixOasRelativeServers = Eq;
ui.getSpecificationName = xq;
var Iy = { exports: {} };
const Oq = "https://raw.githubusercontent.com/OAI/OpenAPI-Specification/master/schemas/v1.2/apiDeclaration.json#", Pq = "http://json-schema.org/draft-04/schema#", Sq = "object", Aq = [
  "swaggerVersion",
  "basePath",
  "apis"
], Cq = {
  swaggerVersion: {
    enum: [
      "1.2"
    ]
  },
  apiVersion: {
    type: "string"
  },
  basePath: {
    type: "string",
    format: "uri",
    pattern: "^https?://"
  },
  resourcePath: {
    type: "string",
    format: "uri",
    pattern: "^/"
  },
  apis: {
    type: "array",
    items: {
      $ref: "#/definitions/apiObject"
    }
  },
  models: {
    type: "object",
    additionalProperties: {
      $ref: "modelsObject.json#"
    }
  },
  produces: {
    $ref: "#/definitions/mimeTypeArray"
  },
  consumes: {
    $ref: "#/definitions/mimeTypeArray"
  },
  authorizations: {
    $ref: "authorizationObject.json#"
  }
}, Rq = !1, Tq = {
  apiObject: {
    type: "object",
    required: [
      "path",
      "operations"
    ],
    properties: {
      path: {
        type: "string",
        format: "uri-template",
        pattern: "^/"
      },
      description: {
        type: "string"
      },
      operations: {
        type: "array",
        items: {
          $ref: "operationObject.json#"
        }
      }
    },
    additionalProperties: !1
  },
  mimeTypeArray: {
    type: "array",
    items: {
      type: "string",
      format: "mime-type"
    },
    uniqueItems: !0
  }
}, Iq = {
  id: Oq,
  $schema: Pq,
  type: Sq,
  required: Aq,
  properties: Cq,
  additionalProperties: Rq,
  definitions: Tq
}, jq = "A JSON Schema for Swagger 2.0 API.", kq = "http://swagger.io/v2/schema.json#", Mq = "http://json-schema.org/draft-04/schema#", Nq = "object", Dq = [
  "swagger",
  "info",
  "paths"
], Lq = !1, qq = {
  "^x-": {
    $ref: "#/definitions/vendorExtension"
  }
}, Fq = {
  swagger: {
    type: "string",
    enum: [
      "2.0"
    ],
    description: "The Swagger version of this document."
  },
  info: {
    $ref: "#/definitions/info"
  },
  host: {
    type: "string",
    pattern: "^[^{}/ :\\\\]+(?::\\d+)?$",
    description: "The host (name or ip) of the API. Example: 'swagger.io'"
  },
  basePath: {
    type: "string",
    pattern: "^/",
    description: "The base path to the API. Example: '/api'."
  },
  schemes: {
    $ref: "#/definitions/schemesList"
  },
  consumes: {
    description: "A list of MIME types accepted by the API.",
    allOf: [
      {
        $ref: "#/definitions/mediaTypeList"
      }
    ]
  },
  produces: {
    description: "A list of MIME types the API can produce.",
    allOf: [
      {
        $ref: "#/definitions/mediaTypeList"
      }
    ]
  },
  paths: {
    $ref: "#/definitions/paths"
  },
  definitions: {
    $ref: "#/definitions/definitions"
  },
  parameters: {
    $ref: "#/definitions/parameterDefinitions"
  },
  responses: {
    $ref: "#/definitions/responseDefinitions"
  },
  security: {
    $ref: "#/definitions/security"
  },
  securityDefinitions: {
    $ref: "#/definitions/securityDefinitions"
  },
  tags: {
    type: "array",
    items: {
      $ref: "#/definitions/tag"
    },
    uniqueItems: !0
  },
  externalDocs: {
    $ref: "#/definitions/externalDocs"
  }
}, Uq = {
  info: {
    type: "object",
    description: "General information about the API.",
    required: [
      "version",
      "title"
    ],
    additionalProperties: !1,
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    },
    properties: {
      title: {
        type: "string",
        description: "A unique and precise title of the API."
      },
      version: {
        type: "string",
        description: "A semantic version number of the API."
      },
      description: {
        type: "string",
        description: "A longer description of the API. Should be different from the title.  GitHub Flavored Markdown is allowed."
      },
      termsOfService: {
        type: "string",
        description: "The terms of service for the API."
      },
      contact: {
        $ref: "#/definitions/contact"
      },
      license: {
        $ref: "#/definitions/license"
      }
    }
  },
  contact: {
    type: "object",
    description: "Contact information for the owners of the API.",
    additionalProperties: !1,
    properties: {
      name: {
        type: "string",
        description: "The identifying name of the contact person/organization."
      },
      url: {
        type: "string",
        description: "The URL pointing to the contact information.",
        format: "uri"
      },
      email: {
        type: "string",
        description: "The email address of the contact person/organization.",
        format: "email"
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  license: {
    type: "object",
    required: [
      "name"
    ],
    additionalProperties: !1,
    properties: {
      name: {
        type: "string",
        description: "The name of the license type. It's encouraged to use an OSI compatible license."
      },
      url: {
        type: "string",
        description: "The URL pointing to the license.",
        format: "uri"
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  paths: {
    type: "object",
    description: "Relative paths to the individual endpoints. They must be relative to the 'basePath'.",
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      },
      "^/": {
        $ref: "#/definitions/pathItem"
      }
    },
    additionalProperties: !1
  },
  definitions: {
    type: "object",
    additionalProperties: {
      $ref: "#/definitions/schema"
    },
    description: "One or more JSON objects describing the schemas being consumed and produced by the API."
  },
  parameterDefinitions: {
    type: "object",
    additionalProperties: {
      $ref: "#/definitions/parameter"
    },
    description: "One or more JSON representations for parameters"
  },
  responseDefinitions: {
    type: "object",
    additionalProperties: {
      $ref: "#/definitions/response"
    },
    description: "One or more JSON representations for responses"
  },
  externalDocs: {
    type: "object",
    additionalProperties: !1,
    description: "information about external documentation",
    required: [
      "url"
    ],
    properties: {
      description: {
        type: "string"
      },
      url: {
        type: "string",
        format: "uri"
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  examples: {
    type: "object",
    additionalProperties: !0
  },
  mimeType: {
    type: "string",
    description: "The MIME type of the HTTP message."
  },
  operation: {
    type: "object",
    required: [
      "responses"
    ],
    additionalProperties: !1,
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    },
    properties: {
      tags: {
        type: "array",
        items: {
          type: "string"
        },
        uniqueItems: !0
      },
      summary: {
        type: "string",
        description: "A brief summary of the operation."
      },
      description: {
        type: "string",
        description: "A longer description of the operation, GitHub Flavored Markdown is allowed."
      },
      externalDocs: {
        $ref: "#/definitions/externalDocs"
      },
      operationId: {
        type: "string",
        description: "A unique identifier of the operation."
      },
      produces: {
        description: "A list of MIME types the API can produce.",
        allOf: [
          {
            $ref: "#/definitions/mediaTypeList"
          }
        ]
      },
      consumes: {
        description: "A list of MIME types the API can consume.",
        allOf: [
          {
            $ref: "#/definitions/mediaTypeList"
          }
        ]
      },
      parameters: {
        $ref: "#/definitions/parametersList"
      },
      responses: {
        $ref: "#/definitions/responses"
      },
      schemes: {
        $ref: "#/definitions/schemesList"
      },
      deprecated: {
        type: "boolean",
        default: !1
      },
      security: {
        $ref: "#/definitions/security"
      }
    }
  },
  pathItem: {
    type: "object",
    additionalProperties: !1,
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    },
    properties: {
      $ref: {
        type: "string"
      },
      get: {
        $ref: "#/definitions/operation"
      },
      put: {
        $ref: "#/definitions/operation"
      },
      post: {
        $ref: "#/definitions/operation"
      },
      delete: {
        $ref: "#/definitions/operation"
      },
      options: {
        $ref: "#/definitions/operation"
      },
      head: {
        $ref: "#/definitions/operation"
      },
      patch: {
        $ref: "#/definitions/operation"
      },
      parameters: {
        $ref: "#/definitions/parametersList"
      }
    }
  },
  responses: {
    type: "object",
    description: "Response objects names can either be any valid HTTP status code or 'default'.",
    minProperties: 1,
    additionalProperties: !1,
    patternProperties: {
      "^([0-9]{3})$|^(default)$": {
        $ref: "#/definitions/responseValue"
      },
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    },
    not: {
      type: "object",
      additionalProperties: !1,
      patternProperties: {
        "^x-": {
          $ref: "#/definitions/vendorExtension"
        }
      }
    }
  },
  responseValue: {
    oneOf: [
      {
        $ref: "#/definitions/response"
      },
      {
        $ref: "#/definitions/jsonReference"
      }
    ]
  },
  response: {
    type: "object",
    required: [
      "description"
    ],
    properties: {
      description: {
        type: "string"
      },
      schema: {
        oneOf: [
          {
            $ref: "#/definitions/schema"
          },
          {
            $ref: "#/definitions/fileSchema"
          }
        ]
      },
      headers: {
        $ref: "#/definitions/headers"
      },
      examples: {
        $ref: "#/definitions/examples"
      }
    },
    additionalProperties: !1,
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  headers: {
    type: "object",
    additionalProperties: {
      $ref: "#/definitions/header"
    }
  },
  header: {
    type: "object",
    additionalProperties: !1,
    required: [
      "type"
    ],
    properties: {
      type: {
        type: "string",
        enum: [
          "string",
          "number",
          "integer",
          "boolean",
          "array"
        ]
      },
      format: {
        type: "string"
      },
      items: {
        $ref: "#/definitions/primitivesItems"
      },
      collectionFormat: {
        $ref: "#/definitions/collectionFormat"
      },
      default: {
        $ref: "#/definitions/default"
      },
      maximum: {
        $ref: "#/definitions/maximum"
      },
      exclusiveMaximum: {
        $ref: "#/definitions/exclusiveMaximum"
      },
      minimum: {
        $ref: "#/definitions/minimum"
      },
      exclusiveMinimum: {
        $ref: "#/definitions/exclusiveMinimum"
      },
      maxLength: {
        $ref: "#/definitions/maxLength"
      },
      minLength: {
        $ref: "#/definitions/minLength"
      },
      pattern: {
        $ref: "#/definitions/pattern"
      },
      maxItems: {
        $ref: "#/definitions/maxItems"
      },
      minItems: {
        $ref: "#/definitions/minItems"
      },
      uniqueItems: {
        $ref: "#/definitions/uniqueItems"
      },
      enum: {
        $ref: "#/definitions/enum"
      },
      multipleOf: {
        $ref: "#/definitions/multipleOf"
      },
      description: {
        type: "string"
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  vendorExtension: {
    description: "Any property starting with x- is valid.",
    additionalProperties: !0,
    additionalItems: !0
  },
  bodyParameter: {
    type: "object",
    required: [
      "name",
      "in",
      "schema"
    ],
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    },
    properties: {
      description: {
        type: "string",
        description: "A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed."
      },
      name: {
        type: "string",
        description: "The name of the parameter."
      },
      in: {
        type: "string",
        description: "Determines the location of the parameter.",
        enum: [
          "body"
        ]
      },
      required: {
        type: "boolean",
        description: "Determines whether or not this parameter is required or optional.",
        default: !1
      },
      schema: {
        $ref: "#/definitions/schema"
      }
    },
    additionalProperties: !1
  },
  headerParameterSubSchema: {
    additionalProperties: !1,
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    },
    properties: {
      required: {
        type: "boolean",
        description: "Determines whether or not this parameter is required or optional.",
        default: !1
      },
      in: {
        type: "string",
        description: "Determines the location of the parameter.",
        enum: [
          "header"
        ]
      },
      description: {
        type: "string",
        description: "A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed."
      },
      name: {
        type: "string",
        description: "The name of the parameter."
      },
      type: {
        type: "string",
        enum: [
          "string",
          "number",
          "boolean",
          "integer",
          "array"
        ]
      },
      format: {
        type: "string"
      },
      items: {
        $ref: "#/definitions/primitivesItems"
      },
      collectionFormat: {
        $ref: "#/definitions/collectionFormat"
      },
      default: {
        $ref: "#/definitions/default"
      },
      maximum: {
        $ref: "#/definitions/maximum"
      },
      exclusiveMaximum: {
        $ref: "#/definitions/exclusiveMaximum"
      },
      minimum: {
        $ref: "#/definitions/minimum"
      },
      exclusiveMinimum: {
        $ref: "#/definitions/exclusiveMinimum"
      },
      maxLength: {
        $ref: "#/definitions/maxLength"
      },
      minLength: {
        $ref: "#/definitions/minLength"
      },
      pattern: {
        $ref: "#/definitions/pattern"
      },
      maxItems: {
        $ref: "#/definitions/maxItems"
      },
      minItems: {
        $ref: "#/definitions/minItems"
      },
      uniqueItems: {
        $ref: "#/definitions/uniqueItems"
      },
      enum: {
        $ref: "#/definitions/enum"
      },
      multipleOf: {
        $ref: "#/definitions/multipleOf"
      }
    }
  },
  queryParameterSubSchema: {
    additionalProperties: !1,
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    },
    properties: {
      required: {
        type: "boolean",
        description: "Determines whether or not this parameter is required or optional.",
        default: !1
      },
      in: {
        type: "string",
        description: "Determines the location of the parameter.",
        enum: [
          "query"
        ]
      },
      description: {
        type: "string",
        description: "A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed."
      },
      name: {
        type: "string",
        description: "The name of the parameter."
      },
      allowEmptyValue: {
        type: "boolean",
        default: !1,
        description: "allows sending a parameter by name only or with an empty value."
      },
      type: {
        type: "string",
        enum: [
          "string",
          "number",
          "boolean",
          "integer",
          "array"
        ]
      },
      format: {
        type: "string"
      },
      items: {
        $ref: "#/definitions/primitivesItems"
      },
      collectionFormat: {
        $ref: "#/definitions/collectionFormatWithMulti"
      },
      default: {
        $ref: "#/definitions/default"
      },
      maximum: {
        $ref: "#/definitions/maximum"
      },
      exclusiveMaximum: {
        $ref: "#/definitions/exclusiveMaximum"
      },
      minimum: {
        $ref: "#/definitions/minimum"
      },
      exclusiveMinimum: {
        $ref: "#/definitions/exclusiveMinimum"
      },
      maxLength: {
        $ref: "#/definitions/maxLength"
      },
      minLength: {
        $ref: "#/definitions/minLength"
      },
      pattern: {
        $ref: "#/definitions/pattern"
      },
      maxItems: {
        $ref: "#/definitions/maxItems"
      },
      minItems: {
        $ref: "#/definitions/minItems"
      },
      uniqueItems: {
        $ref: "#/definitions/uniqueItems"
      },
      enum: {
        $ref: "#/definitions/enum"
      },
      multipleOf: {
        $ref: "#/definitions/multipleOf"
      }
    }
  },
  formDataParameterSubSchema: {
    additionalProperties: !1,
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    },
    properties: {
      required: {
        type: "boolean",
        description: "Determines whether or not this parameter is required or optional.",
        default: !1
      },
      in: {
        type: "string",
        description: "Determines the location of the parameter.",
        enum: [
          "formData"
        ]
      },
      description: {
        type: "string",
        description: "A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed."
      },
      name: {
        type: "string",
        description: "The name of the parameter."
      },
      allowEmptyValue: {
        type: "boolean",
        default: !1,
        description: "allows sending a parameter by name only or with an empty value."
      },
      type: {
        type: "string",
        enum: [
          "string",
          "number",
          "boolean",
          "integer",
          "array",
          "file"
        ]
      },
      format: {
        type: "string"
      },
      items: {
        $ref: "#/definitions/primitivesItems"
      },
      collectionFormat: {
        $ref: "#/definitions/collectionFormatWithMulti"
      },
      default: {
        $ref: "#/definitions/default"
      },
      maximum: {
        $ref: "#/definitions/maximum"
      },
      exclusiveMaximum: {
        $ref: "#/definitions/exclusiveMaximum"
      },
      minimum: {
        $ref: "#/definitions/minimum"
      },
      exclusiveMinimum: {
        $ref: "#/definitions/exclusiveMinimum"
      },
      maxLength: {
        $ref: "#/definitions/maxLength"
      },
      minLength: {
        $ref: "#/definitions/minLength"
      },
      pattern: {
        $ref: "#/definitions/pattern"
      },
      maxItems: {
        $ref: "#/definitions/maxItems"
      },
      minItems: {
        $ref: "#/definitions/minItems"
      },
      uniqueItems: {
        $ref: "#/definitions/uniqueItems"
      },
      enum: {
        $ref: "#/definitions/enum"
      },
      multipleOf: {
        $ref: "#/definitions/multipleOf"
      }
    }
  },
  pathParameterSubSchema: {
    additionalProperties: !1,
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    },
    required: [
      "required"
    ],
    properties: {
      required: {
        type: "boolean",
        enum: [
          !0
        ],
        description: "Determines whether or not this parameter is required or optional."
      },
      in: {
        type: "string",
        description: "Determines the location of the parameter.",
        enum: [
          "path"
        ]
      },
      description: {
        type: "string",
        description: "A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed."
      },
      name: {
        type: "string",
        description: "The name of the parameter."
      },
      type: {
        type: "string",
        enum: [
          "string",
          "number",
          "boolean",
          "integer",
          "array"
        ]
      },
      format: {
        type: "string"
      },
      items: {
        $ref: "#/definitions/primitivesItems"
      },
      collectionFormat: {
        $ref: "#/definitions/collectionFormat"
      },
      default: {
        $ref: "#/definitions/default"
      },
      maximum: {
        $ref: "#/definitions/maximum"
      },
      exclusiveMaximum: {
        $ref: "#/definitions/exclusiveMaximum"
      },
      minimum: {
        $ref: "#/definitions/minimum"
      },
      exclusiveMinimum: {
        $ref: "#/definitions/exclusiveMinimum"
      },
      maxLength: {
        $ref: "#/definitions/maxLength"
      },
      minLength: {
        $ref: "#/definitions/minLength"
      },
      pattern: {
        $ref: "#/definitions/pattern"
      },
      maxItems: {
        $ref: "#/definitions/maxItems"
      },
      minItems: {
        $ref: "#/definitions/minItems"
      },
      uniqueItems: {
        $ref: "#/definitions/uniqueItems"
      },
      enum: {
        $ref: "#/definitions/enum"
      },
      multipleOf: {
        $ref: "#/definitions/multipleOf"
      }
    }
  },
  nonBodyParameter: {
    type: "object",
    required: [
      "name",
      "in",
      "type"
    ],
    oneOf: [
      {
        $ref: "#/definitions/headerParameterSubSchema"
      },
      {
        $ref: "#/definitions/formDataParameterSubSchema"
      },
      {
        $ref: "#/definitions/queryParameterSubSchema"
      },
      {
        $ref: "#/definitions/pathParameterSubSchema"
      }
    ]
  },
  parameter: {
    oneOf: [
      {
        $ref: "#/definitions/bodyParameter"
      },
      {
        $ref: "#/definitions/nonBodyParameter"
      }
    ]
  },
  schema: {
    type: "object",
    description: "A deterministic version of a JSON Schema object.",
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    },
    properties: {
      $ref: {
        type: "string"
      },
      format: {
        type: "string"
      },
      title: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/title"
      },
      description: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/description"
      },
      default: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/default"
      },
      multipleOf: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/multipleOf"
      },
      maximum: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/maximum"
      },
      exclusiveMaximum: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/exclusiveMaximum"
      },
      minimum: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/minimum"
      },
      exclusiveMinimum: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/exclusiveMinimum"
      },
      maxLength: {
        $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveInteger"
      },
      minLength: {
        $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0"
      },
      pattern: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/pattern"
      },
      maxItems: {
        $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveInteger"
      },
      minItems: {
        $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0"
      },
      uniqueItems: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/uniqueItems"
      },
      maxProperties: {
        $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveInteger"
      },
      minProperties: {
        $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0"
      },
      required: {
        $ref: "http://json-schema.org/draft-04/schema#/definitions/stringArray"
      },
      enum: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/enum"
      },
      additionalProperties: {
        anyOf: [
          {
            $ref: "#/definitions/schema"
          },
          {
            type: "boolean"
          }
        ],
        default: {}
      },
      type: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/type"
      },
      items: {
        anyOf: [
          {
            $ref: "#/definitions/schema"
          },
          {
            type: "array",
            minItems: 1,
            items: {
              $ref: "#/definitions/schema"
            }
          }
        ],
        default: {}
      },
      allOf: {
        type: "array",
        minItems: 1,
        items: {
          $ref: "#/definitions/schema"
        }
      },
      properties: {
        type: "object",
        additionalProperties: {
          $ref: "#/definitions/schema"
        },
        default: {}
      },
      discriminator: {
        type: "string"
      },
      readOnly: {
        type: "boolean",
        default: !1
      },
      xml: {
        $ref: "#/definitions/xml"
      },
      externalDocs: {
        $ref: "#/definitions/externalDocs"
      },
      example: {}
    },
    additionalProperties: !1
  },
  fileSchema: {
    type: "object",
    description: "A deterministic version of a JSON Schema object.",
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    },
    required: [
      "type"
    ],
    properties: {
      format: {
        type: "string"
      },
      title: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/title"
      },
      description: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/description"
      },
      default: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/default"
      },
      required: {
        $ref: "http://json-schema.org/draft-04/schema#/definitions/stringArray"
      },
      type: {
        type: "string",
        enum: [
          "file"
        ]
      },
      readOnly: {
        type: "boolean",
        default: !1
      },
      externalDocs: {
        $ref: "#/definitions/externalDocs"
      },
      example: {}
    },
    additionalProperties: !1
  },
  primitivesItems: {
    type: "object",
    additionalProperties: !1,
    properties: {
      type: {
        type: "string",
        enum: [
          "string",
          "number",
          "integer",
          "boolean",
          "array"
        ]
      },
      format: {
        type: "string"
      },
      items: {
        $ref: "#/definitions/primitivesItems"
      },
      collectionFormat: {
        $ref: "#/definitions/collectionFormat"
      },
      default: {
        $ref: "#/definitions/default"
      },
      maximum: {
        $ref: "#/definitions/maximum"
      },
      exclusiveMaximum: {
        $ref: "#/definitions/exclusiveMaximum"
      },
      minimum: {
        $ref: "#/definitions/minimum"
      },
      exclusiveMinimum: {
        $ref: "#/definitions/exclusiveMinimum"
      },
      maxLength: {
        $ref: "#/definitions/maxLength"
      },
      minLength: {
        $ref: "#/definitions/minLength"
      },
      pattern: {
        $ref: "#/definitions/pattern"
      },
      maxItems: {
        $ref: "#/definitions/maxItems"
      },
      minItems: {
        $ref: "#/definitions/minItems"
      },
      uniqueItems: {
        $ref: "#/definitions/uniqueItems"
      },
      enum: {
        $ref: "#/definitions/enum"
      },
      multipleOf: {
        $ref: "#/definitions/multipleOf"
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  security: {
    type: "array",
    items: {
      $ref: "#/definitions/securityRequirement"
    },
    uniqueItems: !0
  },
  securityRequirement: {
    type: "object",
    additionalProperties: {
      type: "array",
      items: {
        type: "string"
      },
      uniqueItems: !0
    }
  },
  xml: {
    type: "object",
    additionalProperties: !1,
    properties: {
      name: {
        type: "string"
      },
      namespace: {
        type: "string"
      },
      prefix: {
        type: "string"
      },
      attribute: {
        type: "boolean",
        default: !1
      },
      wrapped: {
        type: "boolean",
        default: !1
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  tag: {
    type: "object",
    additionalProperties: !1,
    required: [
      "name"
    ],
    properties: {
      name: {
        type: "string"
      },
      description: {
        type: "string"
      },
      externalDocs: {
        $ref: "#/definitions/externalDocs"
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  securityDefinitions: {
    type: "object",
    additionalProperties: {
      oneOf: [
        {
          $ref: "#/definitions/basicAuthenticationSecurity"
        },
        {
          $ref: "#/definitions/apiKeySecurity"
        },
        {
          $ref: "#/definitions/oauth2ImplicitSecurity"
        },
        {
          $ref: "#/definitions/oauth2PasswordSecurity"
        },
        {
          $ref: "#/definitions/oauth2ApplicationSecurity"
        },
        {
          $ref: "#/definitions/oauth2AccessCodeSecurity"
        }
      ]
    }
  },
  basicAuthenticationSecurity: {
    type: "object",
    additionalProperties: !1,
    required: [
      "type"
    ],
    properties: {
      type: {
        type: "string",
        enum: [
          "basic"
        ]
      },
      description: {
        type: "string"
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  apiKeySecurity: {
    type: "object",
    additionalProperties: !1,
    required: [
      "type",
      "name",
      "in"
    ],
    properties: {
      type: {
        type: "string",
        enum: [
          "apiKey"
        ]
      },
      name: {
        type: "string"
      },
      in: {
        type: "string",
        enum: [
          "header",
          "query"
        ]
      },
      description: {
        type: "string"
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  oauth2ImplicitSecurity: {
    type: "object",
    additionalProperties: !1,
    required: [
      "type",
      "flow",
      "authorizationUrl"
    ],
    properties: {
      type: {
        type: "string",
        enum: [
          "oauth2"
        ]
      },
      flow: {
        type: "string",
        enum: [
          "implicit"
        ]
      },
      scopes: {
        $ref: "#/definitions/oauth2Scopes"
      },
      authorizationUrl: {
        type: "string",
        format: "uri"
      },
      description: {
        type: "string"
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  oauth2PasswordSecurity: {
    type: "object",
    additionalProperties: !1,
    required: [
      "type",
      "flow",
      "tokenUrl"
    ],
    properties: {
      type: {
        type: "string",
        enum: [
          "oauth2"
        ]
      },
      flow: {
        type: "string",
        enum: [
          "password"
        ]
      },
      scopes: {
        $ref: "#/definitions/oauth2Scopes"
      },
      tokenUrl: {
        type: "string",
        format: "uri"
      },
      description: {
        type: "string"
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  oauth2ApplicationSecurity: {
    type: "object",
    additionalProperties: !1,
    required: [
      "type",
      "flow",
      "tokenUrl"
    ],
    properties: {
      type: {
        type: "string",
        enum: [
          "oauth2"
        ]
      },
      flow: {
        type: "string",
        enum: [
          "application"
        ]
      },
      scopes: {
        $ref: "#/definitions/oauth2Scopes"
      },
      tokenUrl: {
        type: "string",
        format: "uri"
      },
      description: {
        type: "string"
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  oauth2AccessCodeSecurity: {
    type: "object",
    additionalProperties: !1,
    required: [
      "type",
      "flow",
      "authorizationUrl",
      "tokenUrl"
    ],
    properties: {
      type: {
        type: "string",
        enum: [
          "oauth2"
        ]
      },
      flow: {
        type: "string",
        enum: [
          "accessCode"
        ]
      },
      scopes: {
        $ref: "#/definitions/oauth2Scopes"
      },
      authorizationUrl: {
        type: "string",
        format: "uri"
      },
      tokenUrl: {
        type: "string",
        format: "uri"
      },
      description: {
        type: "string"
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  oauth2Scopes: {
    type: "object",
    additionalProperties: {
      type: "string"
    }
  },
  mediaTypeList: {
    type: "array",
    items: {
      $ref: "#/definitions/mimeType"
    },
    uniqueItems: !0
  },
  parametersList: {
    type: "array",
    description: "The parameters needed to send a valid API call.",
    additionalItems: !1,
    items: {
      oneOf: [
        {
          $ref: "#/definitions/parameter"
        },
        {
          $ref: "#/definitions/jsonReference"
        }
      ]
    },
    uniqueItems: !0
  },
  schemesList: {
    type: "array",
    description: "The transfer protocol of the API.",
    items: {
      type: "string",
      enum: [
        "http",
        "https",
        "ws",
        "wss"
      ]
    },
    uniqueItems: !0
  },
  collectionFormat: {
    type: "string",
    enum: [
      "csv",
      "ssv",
      "tsv",
      "pipes"
    ],
    default: "csv"
  },
  collectionFormatWithMulti: {
    type: "string",
    enum: [
      "csv",
      "ssv",
      "tsv",
      "pipes",
      "multi"
    ],
    default: "csv"
  },
  title: {
    $ref: "http://json-schema.org/draft-04/schema#/properties/title"
  },
  description: {
    $ref: "http://json-schema.org/draft-04/schema#/properties/description"
  },
  default: {
    $ref: "http://json-schema.org/draft-04/schema#/properties/default"
  },
  multipleOf: {
    $ref: "http://json-schema.org/draft-04/schema#/properties/multipleOf"
  },
  maximum: {
    $ref: "http://json-schema.org/draft-04/schema#/properties/maximum"
  },
  exclusiveMaximum: {
    $ref: "http://json-schema.org/draft-04/schema#/properties/exclusiveMaximum"
  },
  minimum: {
    $ref: "http://json-schema.org/draft-04/schema#/properties/minimum"
  },
  exclusiveMinimum: {
    $ref: "http://json-schema.org/draft-04/schema#/properties/exclusiveMinimum"
  },
  maxLength: {
    $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveInteger"
  },
  minLength: {
    $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0"
  },
  pattern: {
    $ref: "http://json-schema.org/draft-04/schema#/properties/pattern"
  },
  maxItems: {
    $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveInteger"
  },
  minItems: {
    $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0"
  },
  uniqueItems: {
    $ref: "http://json-schema.org/draft-04/schema#/properties/uniqueItems"
  },
  enum: {
    $ref: "http://json-schema.org/draft-04/schema#/properties/enum"
  },
  jsonReference: {
    type: "object",
    required: [
      "$ref"
    ],
    additionalProperties: !1,
    properties: {
      $ref: {
        type: "string"
      }
    }
  }
}, Bq = {
  title: jq,
  id: kq,
  $schema: Mq,
  type: Nq,
  required: Dq,
  additionalProperties: Lq,
  patternProperties: qq,
  properties: Fq,
  definitions: Uq
}, Vq = "https://spec.openapis.org/oas/3.0/schema/2019-04-02", Zq = "http://json-schema.org/draft-04/schema#", zq = "Validation schema for OpenAPI Specification 3.0.X.", Wq = "object", Hq = [
  "openapi",
  "info",
  "paths"
], Gq = {
  openapi: {
    type: "string",
    pattern: "^3\\.0\\.\\d(-.+)?$"
  },
  info: {
    $ref: "#/definitions/Info"
  },
  externalDocs: {
    $ref: "#/definitions/ExternalDocumentation"
  },
  servers: {
    type: "array",
    items: {
      $ref: "#/definitions/Server"
    }
  },
  security: {
    type: "array",
    items: {
      $ref: "#/definitions/SecurityRequirement"
    }
  },
  tags: {
    type: "array",
    items: {
      $ref: "#/definitions/Tag"
    },
    uniqueItems: !0
  },
  paths: {
    $ref: "#/definitions/Paths"
  },
  components: {
    $ref: "#/definitions/Components"
  }
}, Kq = {
  "^x-": {}
}, Yq = !1, Jq = {
  Reference: {
    type: "object",
    required: [
      "$ref"
    ],
    patternProperties: {
      "^\\$ref$": {
        type: "string",
        format: "uri-reference"
      }
    }
  },
  Info: {
    type: "object",
    required: [
      "title",
      "version"
    ],
    properties: {
      title: {
        type: "string"
      },
      description: {
        type: "string"
      },
      termsOfService: {
        type: "string",
        format: "uri-reference"
      },
      contact: {
        $ref: "#/definitions/Contact"
      },
      license: {
        $ref: "#/definitions/License"
      },
      version: {
        type: "string"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  Contact: {
    type: "object",
    properties: {
      name: {
        type: "string"
      },
      url: {
        type: "string",
        format: "uri-reference"
      },
      email: {
        type: "string",
        format: "email"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  License: {
    type: "object",
    required: [
      "name"
    ],
    properties: {
      name: {
        type: "string"
      },
      url: {
        type: "string",
        format: "uri-reference"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  Server: {
    type: "object",
    required: [
      "url"
    ],
    properties: {
      url: {
        type: "string"
      },
      description: {
        type: "string"
      },
      variables: {
        type: "object",
        additionalProperties: {
          $ref: "#/definitions/ServerVariable"
        }
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  ServerVariable: {
    type: "object",
    required: [
      "default"
    ],
    properties: {
      enum: {
        type: "array",
        items: {
          type: "string"
        }
      },
      default: {
        type: "string"
      },
      description: {
        type: "string"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  Components: {
    type: "object",
    properties: {
      schemas: {
        type: "object",
        patternProperties: {
          "^[a-zA-Z0-9\\.\\-_]+$": {
            oneOf: [
              {
                $ref: "#/definitions/Schema"
              },
              {
                $ref: "#/definitions/Reference"
              }
            ]
          }
        }
      },
      responses: {
        type: "object",
        patternProperties: {
          "^[a-zA-Z0-9\\.\\-_]+$": {
            oneOf: [
              {
                $ref: "#/definitions/Reference"
              },
              {
                $ref: "#/definitions/Response"
              }
            ]
          }
        }
      },
      parameters: {
        type: "object",
        patternProperties: {
          "^[a-zA-Z0-9\\.\\-_]+$": {
            oneOf: [
              {
                $ref: "#/definitions/Reference"
              },
              {
                $ref: "#/definitions/Parameter"
              }
            ]
          }
        }
      },
      examples: {
        type: "object",
        patternProperties: {
          "^[a-zA-Z0-9\\.\\-_]+$": {
            oneOf: [
              {
                $ref: "#/definitions/Reference"
              },
              {
                $ref: "#/definitions/Example"
              }
            ]
          }
        }
      },
      requestBodies: {
        type: "object",
        patternProperties: {
          "^[a-zA-Z0-9\\.\\-_]+$": {
            oneOf: [
              {
                $ref: "#/definitions/Reference"
              },
              {
                $ref: "#/definitions/RequestBody"
              }
            ]
          }
        }
      },
      headers: {
        type: "object",
        patternProperties: {
          "^[a-zA-Z0-9\\.\\-_]+$": {
            oneOf: [
              {
                $ref: "#/definitions/Reference"
              },
              {
                $ref: "#/definitions/Header"
              }
            ]
          }
        }
      },
      securitySchemes: {
        type: "object",
        patternProperties: {
          "^[a-zA-Z0-9\\.\\-_]+$": {
            oneOf: [
              {
                $ref: "#/definitions/Reference"
              },
              {
                $ref: "#/definitions/SecurityScheme"
              }
            ]
          }
        }
      },
      links: {
        type: "object",
        patternProperties: {
          "^[a-zA-Z0-9\\.\\-_]+$": {
            oneOf: [
              {
                $ref: "#/definitions/Reference"
              },
              {
                $ref: "#/definitions/Link"
              }
            ]
          }
        }
      },
      callbacks: {
        type: "object",
        patternProperties: {
          "^[a-zA-Z0-9\\.\\-_]+$": {
            oneOf: [
              {
                $ref: "#/definitions/Reference"
              },
              {
                $ref: "#/definitions/Callback"
              }
            ]
          }
        }
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  Schema: {
    type: "object",
    properties: {
      title: {
        type: "string"
      },
      multipleOf: {
        type: "number",
        minimum: 0,
        exclusiveMinimum: !0
      },
      maximum: {
        type: "number"
      },
      exclusiveMaximum: {
        type: "boolean",
        default: !1
      },
      minimum: {
        type: "number"
      },
      exclusiveMinimum: {
        type: "boolean",
        default: !1
      },
      maxLength: {
        type: "integer",
        minimum: 0
      },
      minLength: {
        type: "integer",
        minimum: 0,
        default: 0
      },
      pattern: {
        type: "string",
        format: "regex"
      },
      maxItems: {
        type: "integer",
        minimum: 0
      },
      minItems: {
        type: "integer",
        minimum: 0,
        default: 0
      },
      uniqueItems: {
        type: "boolean",
        default: !1
      },
      maxProperties: {
        type: "integer",
        minimum: 0
      },
      minProperties: {
        type: "integer",
        minimum: 0,
        default: 0
      },
      required: {
        type: "array",
        items: {
          type: "string"
        },
        minItems: 1,
        uniqueItems: !0
      },
      enum: {
        type: "array",
        items: {},
        minItems: 1,
        uniqueItems: !1
      },
      type: {
        type: "string",
        enum: [
          "array",
          "boolean",
          "integer",
          "number",
          "object",
          "string"
        ]
      },
      not: {
        oneOf: [
          {
            $ref: "#/definitions/Schema"
          },
          {
            $ref: "#/definitions/Reference"
          }
        ]
      },
      allOf: {
        type: "array",
        items: {
          oneOf: [
            {
              $ref: "#/definitions/Schema"
            },
            {
              $ref: "#/definitions/Reference"
            }
          ]
        }
      },
      oneOf: {
        type: "array",
        items: {
          oneOf: [
            {
              $ref: "#/definitions/Schema"
            },
            {
              $ref: "#/definitions/Reference"
            }
          ]
        }
      },
      anyOf: {
        type: "array",
        items: {
          oneOf: [
            {
              $ref: "#/definitions/Schema"
            },
            {
              $ref: "#/definitions/Reference"
            }
          ]
        }
      },
      items: {
        oneOf: [
          {
            $ref: "#/definitions/Schema"
          },
          {
            $ref: "#/definitions/Reference"
          }
        ]
      },
      properties: {
        type: "object",
        additionalProperties: {
          oneOf: [
            {
              $ref: "#/definitions/Schema"
            },
            {
              $ref: "#/definitions/Reference"
            }
          ]
        }
      },
      additionalProperties: {
        oneOf: [
          {
            $ref: "#/definitions/Schema"
          },
          {
            $ref: "#/definitions/Reference"
          },
          {
            type: "boolean"
          }
        ],
        default: !0
      },
      description: {
        type: "string"
      },
      format: {
        type: "string"
      },
      default: {},
      nullable: {
        type: "boolean",
        default: !1
      },
      discriminator: {
        $ref: "#/definitions/Discriminator"
      },
      readOnly: {
        type: "boolean",
        default: !1
      },
      writeOnly: {
        type: "boolean",
        default: !1
      },
      example: {},
      externalDocs: {
        $ref: "#/definitions/ExternalDocumentation"
      },
      deprecated: {
        type: "boolean",
        default: !1
      },
      xml: {
        $ref: "#/definitions/XML"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  Discriminator: {
    type: "object",
    required: [
      "propertyName"
    ],
    properties: {
      propertyName: {
        type: "string"
      },
      mapping: {
        type: "object",
        additionalProperties: {
          type: "string"
        }
      }
    }
  },
  XML: {
    type: "object",
    properties: {
      name: {
        type: "string"
      },
      namespace: {
        type: "string",
        format: "uri"
      },
      prefix: {
        type: "string"
      },
      attribute: {
        type: "boolean",
        default: !1
      },
      wrapped: {
        type: "boolean",
        default: !1
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  Response: {
    type: "object",
    required: [
      "description"
    ],
    properties: {
      description: {
        type: "string"
      },
      headers: {
        type: "object",
        additionalProperties: {
          oneOf: [
            {
              $ref: "#/definitions/Header"
            },
            {
              $ref: "#/definitions/Reference"
            }
          ]
        }
      },
      content: {
        type: "object",
        additionalProperties: {
          $ref: "#/definitions/MediaType"
        }
      },
      links: {
        type: "object",
        additionalProperties: {
          oneOf: [
            {
              $ref: "#/definitions/Link"
            },
            {
              $ref: "#/definitions/Reference"
            }
          ]
        }
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  MediaType: {
    type: "object",
    properties: {
      schema: {
        oneOf: [
          {
            $ref: "#/definitions/Schema"
          },
          {
            $ref: "#/definitions/Reference"
          }
        ]
      },
      example: {},
      examples: {
        type: "object",
        additionalProperties: {
          oneOf: [
            {
              $ref: "#/definitions/Example"
            },
            {
              $ref: "#/definitions/Reference"
            }
          ]
        }
      },
      encoding: {
        type: "object",
        additionalProperties: {
          $ref: "#/definitions/Encoding"
        }
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1,
    allOf: [
      {
        $ref: "#/definitions/ExampleXORExamples"
      }
    ]
  },
  Example: {
    type: "object",
    properties: {
      summary: {
        type: "string"
      },
      description: {
        type: "string"
      },
      value: {},
      externalValue: {
        type: "string",
        format: "uri-reference"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  Header: {
    type: "object",
    properties: {
      description: {
        type: "string"
      },
      required: {
        type: "boolean",
        default: !1
      },
      deprecated: {
        type: "boolean",
        default: !1
      },
      allowEmptyValue: {
        type: "boolean",
        default: !1
      },
      style: {
        type: "string",
        enum: [
          "simple"
        ],
        default: "simple"
      },
      explode: {
        type: "boolean"
      },
      allowReserved: {
        type: "boolean",
        default: !1
      },
      schema: {
        oneOf: [
          {
            $ref: "#/definitions/Schema"
          },
          {
            $ref: "#/definitions/Reference"
          }
        ]
      },
      content: {
        type: "object",
        additionalProperties: {
          $ref: "#/definitions/MediaType"
        },
        minProperties: 1,
        maxProperties: 1
      },
      example: {},
      examples: {
        type: "object",
        additionalProperties: {
          oneOf: [
            {
              $ref: "#/definitions/Example"
            },
            {
              $ref: "#/definitions/Reference"
            }
          ]
        }
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1,
    allOf: [
      {
        $ref: "#/definitions/ExampleXORExamples"
      },
      {
        $ref: "#/definitions/SchemaXORContent"
      }
    ]
  },
  Paths: {
    type: "object",
    patternProperties: {
      "^\\/": {
        $ref: "#/definitions/PathItem"
      },
      "^x-": {}
    },
    additionalProperties: !1
  },
  PathItem: {
    type: "object",
    properties: {
      $ref: {
        type: "string"
      },
      summary: {
        type: "string"
      },
      description: {
        type: "string"
      },
      servers: {
        type: "array",
        items: {
          $ref: "#/definitions/Server"
        }
      },
      parameters: {
        type: "array",
        items: {
          oneOf: [
            {
              $ref: "#/definitions/Parameter"
            },
            {
              $ref: "#/definitions/Reference"
            }
          ]
        },
        uniqueItems: !0
      }
    },
    patternProperties: {
      "^(get|put|post|delete|options|head|patch|trace)$": {
        $ref: "#/definitions/Operation"
      },
      "^x-": {}
    },
    additionalProperties: !1
  },
  Operation: {
    type: "object",
    required: [
      "responses"
    ],
    properties: {
      tags: {
        type: "array",
        items: {
          type: "string"
        }
      },
      summary: {
        type: "string"
      },
      description: {
        type: "string"
      },
      externalDocs: {
        $ref: "#/definitions/ExternalDocumentation"
      },
      operationId: {
        type: "string"
      },
      parameters: {
        type: "array",
        items: {
          oneOf: [
            {
              $ref: "#/definitions/Parameter"
            },
            {
              $ref: "#/definitions/Reference"
            }
          ]
        },
        uniqueItems: !0
      },
      requestBody: {
        oneOf: [
          {
            $ref: "#/definitions/RequestBody"
          },
          {
            $ref: "#/definitions/Reference"
          }
        ]
      },
      responses: {
        $ref: "#/definitions/Responses"
      },
      callbacks: {
        type: "object",
        additionalProperties: {
          oneOf: [
            {
              $ref: "#/definitions/Callback"
            },
            {
              $ref: "#/definitions/Reference"
            }
          ]
        }
      },
      deprecated: {
        type: "boolean",
        default: !1
      },
      security: {
        type: "array",
        items: {
          $ref: "#/definitions/SecurityRequirement"
        }
      },
      servers: {
        type: "array",
        items: {
          $ref: "#/definitions/Server"
        }
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  Responses: {
    type: "object",
    properties: {
      default: {
        oneOf: [
          {
            $ref: "#/definitions/Response"
          },
          {
            $ref: "#/definitions/Reference"
          }
        ]
      }
    },
    patternProperties: {
      "^[1-5](?:\\d{2}|XX)$": {
        oneOf: [
          {
            $ref: "#/definitions/Response"
          },
          {
            $ref: "#/definitions/Reference"
          }
        ]
      },
      "^x-": {}
    },
    minProperties: 1,
    additionalProperties: !1
  },
  SecurityRequirement: {
    type: "object",
    additionalProperties: {
      type: "array",
      items: {
        type: "string"
      }
    }
  },
  Tag: {
    type: "object",
    required: [
      "name"
    ],
    properties: {
      name: {
        type: "string"
      },
      description: {
        type: "string"
      },
      externalDocs: {
        $ref: "#/definitions/ExternalDocumentation"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  ExternalDocumentation: {
    type: "object",
    required: [
      "url"
    ],
    properties: {
      description: {
        type: "string"
      },
      url: {
        type: "string",
        format: "uri-reference"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  ExampleXORExamples: {
    description: "Example and examples are mutually exclusive",
    not: {
      required: [
        "example",
        "examples"
      ]
    }
  },
  SchemaXORContent: {
    description: "Schema and content are mutually exclusive, at least one is required",
    not: {
      required: [
        "schema",
        "content"
      ]
    },
    oneOf: [
      {
        required: [
          "schema"
        ]
      },
      {
        required: [
          "content"
        ],
        description: "Some properties are not allowed if content is present",
        allOf: [
          {
            not: {
              required: [
                "style"
              ]
            }
          },
          {
            not: {
              required: [
                "explode"
              ]
            }
          },
          {
            not: {
              required: [
                "allowReserved"
              ]
            }
          },
          {
            not: {
              required: [
                "example"
              ]
            }
          },
          {
            not: {
              required: [
                "examples"
              ]
            }
          }
        ]
      }
    ]
  },
  Parameter: {
    type: "object",
    properties: {
      name: {
        type: "string"
      },
      in: {
        type: "string"
      },
      description: {
        type: "string"
      },
      required: {
        type: "boolean",
        default: !1
      },
      deprecated: {
        type: "boolean",
        default: !1
      },
      allowEmptyValue: {
        type: "boolean",
        default: !1
      },
      style: {
        type: "string"
      },
      explode: {
        type: "boolean"
      },
      allowReserved: {
        type: "boolean",
        default: !1
      },
      schema: {
        oneOf: [
          {
            $ref: "#/definitions/Schema"
          },
          {
            $ref: "#/definitions/Reference"
          }
        ]
      },
      content: {
        type: "object",
        additionalProperties: {
          $ref: "#/definitions/MediaType"
        },
        minProperties: 1,
        maxProperties: 1
      },
      example: {},
      examples: {
        type: "object",
        additionalProperties: {
          oneOf: [
            {
              $ref: "#/definitions/Example"
            },
            {
              $ref: "#/definitions/Reference"
            }
          ]
        }
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1,
    required: [
      "name",
      "in"
    ],
    allOf: [
      {
        $ref: "#/definitions/ExampleXORExamples"
      },
      {
        $ref: "#/definitions/SchemaXORContent"
      },
      {
        $ref: "#/definitions/ParameterLocation"
      }
    ]
  },
  ParameterLocation: {
    description: "Parameter location",
    oneOf: [
      {
        description: "Parameter in path",
        required: [
          "required"
        ],
        properties: {
          in: {
            enum: [
              "path"
            ]
          },
          style: {
            enum: [
              "matrix",
              "label",
              "simple"
            ],
            default: "simple"
          },
          required: {
            enum: [
              !0
            ]
          }
        }
      },
      {
        description: "Parameter in query",
        properties: {
          in: {
            enum: [
              "query"
            ]
          },
          style: {
            enum: [
              "form",
              "spaceDelimited",
              "pipeDelimited",
              "deepObject"
            ],
            default: "form"
          }
        }
      },
      {
        description: "Parameter in header",
        properties: {
          in: {
            enum: [
              "header"
            ]
          },
          style: {
            enum: [
              "simple"
            ],
            default: "simple"
          }
        }
      },
      {
        description: "Parameter in cookie",
        properties: {
          in: {
            enum: [
              "cookie"
            ]
          },
          style: {
            enum: [
              "form"
            ],
            default: "form"
          }
        }
      }
    ]
  },
  RequestBody: {
    type: "object",
    required: [
      "content"
    ],
    properties: {
      description: {
        type: "string"
      },
      content: {
        type: "object",
        additionalProperties: {
          $ref: "#/definitions/MediaType"
        }
      },
      required: {
        type: "boolean",
        default: !1
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  SecurityScheme: {
    oneOf: [
      {
        $ref: "#/definitions/APIKeySecurityScheme"
      },
      {
        $ref: "#/definitions/HTTPSecurityScheme"
      },
      {
        $ref: "#/definitions/OAuth2SecurityScheme"
      },
      {
        $ref: "#/definitions/OpenIdConnectSecurityScheme"
      }
    ]
  },
  APIKeySecurityScheme: {
    type: "object",
    required: [
      "type",
      "name",
      "in"
    ],
    properties: {
      type: {
        type: "string",
        enum: [
          "apiKey"
        ]
      },
      name: {
        type: "string"
      },
      in: {
        type: "string",
        enum: [
          "header",
          "query",
          "cookie"
        ]
      },
      description: {
        type: "string"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  HTTPSecurityScheme: {
    type: "object",
    required: [
      "scheme",
      "type"
    ],
    properties: {
      scheme: {
        type: "string"
      },
      bearerFormat: {
        type: "string"
      },
      description: {
        type: "string"
      },
      type: {
        type: "string",
        enum: [
          "http"
        ]
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1,
    oneOf: [
      {
        description: "Bearer",
        properties: {
          scheme: {
            enum: [
              "bearer"
            ]
          }
        }
      },
      {
        description: "Non Bearer",
        not: {
          required: [
            "bearerFormat"
          ]
        },
        properties: {
          scheme: {
            not: {
              enum: [
                "bearer"
              ]
            }
          }
        }
      }
    ]
  },
  OAuth2SecurityScheme: {
    type: "object",
    required: [
      "type",
      "flows"
    ],
    properties: {
      type: {
        type: "string",
        enum: [
          "oauth2"
        ]
      },
      flows: {
        $ref: "#/definitions/OAuthFlows"
      },
      description: {
        type: "string"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  OpenIdConnectSecurityScheme: {
    type: "object",
    required: [
      "type",
      "openIdConnectUrl"
    ],
    properties: {
      type: {
        type: "string",
        enum: [
          "openIdConnect"
        ]
      },
      openIdConnectUrl: {
        type: "string",
        format: "uri-reference"
      },
      description: {
        type: "string"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  OAuthFlows: {
    type: "object",
    properties: {
      implicit: {
        $ref: "#/definitions/ImplicitOAuthFlow"
      },
      password: {
        $ref: "#/definitions/PasswordOAuthFlow"
      },
      clientCredentials: {
        $ref: "#/definitions/ClientCredentialsFlow"
      },
      authorizationCode: {
        $ref: "#/definitions/AuthorizationCodeOAuthFlow"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  ImplicitOAuthFlow: {
    type: "object",
    required: [
      "authorizationUrl",
      "scopes"
    ],
    properties: {
      authorizationUrl: {
        type: "string",
        format: "uri-reference"
      },
      refreshUrl: {
        type: "string",
        format: "uri-reference"
      },
      scopes: {
        type: "object",
        additionalProperties: {
          type: "string"
        }
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  PasswordOAuthFlow: {
    type: "object",
    required: [
      "tokenUrl"
    ],
    properties: {
      tokenUrl: {
        type: "string",
        format: "uri-reference"
      },
      refreshUrl: {
        type: "string",
        format: "uri-reference"
      },
      scopes: {
        type: "object",
        additionalProperties: {
          type: "string"
        }
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  ClientCredentialsFlow: {
    type: "object",
    required: [
      "tokenUrl"
    ],
    properties: {
      tokenUrl: {
        type: "string",
        format: "uri-reference"
      },
      refreshUrl: {
        type: "string",
        format: "uri-reference"
      },
      scopes: {
        type: "object",
        additionalProperties: {
          type: "string"
        }
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  AuthorizationCodeOAuthFlow: {
    type: "object",
    required: [
      "authorizationUrl",
      "tokenUrl"
    ],
    properties: {
      authorizationUrl: {
        type: "string",
        format: "uri-reference"
      },
      tokenUrl: {
        type: "string",
        format: "uri-reference"
      },
      refreshUrl: {
        type: "string",
        format: "uri-reference"
      },
      scopes: {
        type: "object",
        additionalProperties: {
          type: "string"
        }
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  Link: {
    type: "object",
    properties: {
      operationId: {
        type: "string"
      },
      operationRef: {
        type: "string",
        format: "uri-reference"
      },
      parameters: {
        type: "object",
        additionalProperties: {}
      },
      requestBody: {},
      description: {
        type: "string"
      },
      server: {
        $ref: "#/definitions/Server"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1,
    not: {
      description: "Operation Id and Operation Ref are mutually exclusive",
      required: [
        "operationId",
        "operationRef"
      ]
    }
  },
  Callback: {
    type: "object",
    additionalProperties: {
      $ref: "#/definitions/PathItem"
    },
    patternProperties: {
      "^x-": {}
    }
  },
  Encoding: {
    type: "object",
    properties: {
      contentType: {
        type: "string"
      },
      headers: {
        type: "object",
        additionalProperties: {
          $ref: "#/definitions/Header"
        }
      },
      style: {
        type: "string",
        enum: [
          "form",
          "spaceDelimited",
          "pipeDelimited",
          "deepObject"
        ]
      },
      explode: {
        type: "boolean"
      },
      allowReserved: {
        type: "boolean",
        default: !1
      }
    },
    additionalProperties: !1
  }
}, Xq = {
  id: Vq,
  $schema: Zq,
  description: zq,
  type: Wq,
  required: Hq,
  properties: Gq,
  patternProperties: Kq,
  additionalProperties: Yq,
  definitions: Jq
}, Qq = "https://spec.openapis.org/oas/3.1/schema/2021-04-15", e8 = "https://json-schema.org/draft/2020-12/schema", t8 = "object", r8 = {
  openapi: {
    type: "string",
    pattern: "^3\\.1\\.\\d+(-.+)?$"
  },
  info: {
    $ref: "#/$defs/info"
  },
  jsonSchemaDialect: {
    $ref: "#/$defs/uri",
    default: "https://spec.openapis.org/oas/3.1/dialect/base"
  },
  servers: {
    type: "array",
    items: {
      $ref: "#/$defs/server"
    }
  },
  paths: {
    $ref: "#/$defs/paths"
  },
  webhooks: {
    type: "object",
    additionalProperties: {
      $ref: "#/$defs/path-item-or-reference"
    }
  },
  components: {
    $ref: "#/$defs/components"
  },
  security: {
    type: "array",
    items: {
      $ref: "#/$defs/security-requirement"
    }
  },
  tags: {
    type: "array",
    items: {
      $ref: "#/$defs/tag"
    }
  },
  externalDocs: {
    $ref: "#/$defs/external-documentation"
  }
}, n8 = [
  "openapi",
  "info"
], i8 = [
  {
    required: [
      "paths"
    ]
  },
  {
    required: [
      "components"
    ]
  },
  {
    required: [
      "webhooks"
    ]
  }
], s8 = "#/$defs/specification-extensions", a8 = !1, o8 = {
  info: {
    type: "object",
    properties: {
      title: {
        type: "string"
      },
      summary: {
        type: "string"
      },
      description: {
        type: "string"
      },
      termsOfService: {
        type: "string"
      },
      contact: {
        $ref: "#/$defs/contact"
      },
      license: {
        $ref: "#/$defs/license"
      },
      version: {
        type: "string"
      }
    },
    required: [
      "title",
      "version"
    ],
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  contact: {
    type: "object",
    properties: {
      name: {
        type: "string"
      },
      url: {
        type: "string"
      },
      email: {
        type: "string"
      }
    },
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  license: {
    type: "object",
    properties: {
      name: {
        type: "string"
      },
      identifier: {
        type: "string"
      },
      url: {
        $ref: "#/$defs/uri"
      }
    },
    required: [
      "name"
    ],
    oneOf: [
      {
        required: [
          "identifier"
        ]
      },
      {
        required: [
          "url"
        ]
      }
    ],
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  server: {
    type: "object",
    properties: {
      url: {
        $ref: "#/$defs/uri"
      },
      description: {
        type: "string"
      },
      variables: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/server-variable"
        }
      }
    },
    required: [
      "url"
    ],
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  "server-variable": {
    type: "object",
    properties: {
      enum: {
        type: "array",
        items: {
          type: "string"
        },
        minItems: 1
      },
      default: {
        type: "string"
      },
      descriptions: {
        type: "string"
      }
    },
    required: [
      "default"
    ],
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  components: {
    type: "object",
    properties: {
      schemas: {
        type: "object",
        additionalProperties: {
          $dynamicRef: "#meta"
        }
      },
      responses: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/response-or-reference"
        }
      },
      parameters: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/parameter-or-reference"
        }
      },
      examples: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/example-or-reference"
        }
      },
      requestBodies: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/request-body-or-reference"
        }
      },
      headers: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/header-or-reference"
        }
      },
      securitySchemes: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/security-scheme-or-reference"
        }
      },
      links: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/link-or-reference"
        }
      },
      callbacks: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/callbacks-or-reference"
        }
      },
      pathItems: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/path-item-or-reference"
        }
      }
    },
    patternProperties: {
      "^(schemas|responses|parameters|examples|requestBodies|headers|securitySchemes|links|callbacks|pathItems)$": {
        $comment: "Enumerating all of the property names in the regex above is necessary for unevaluatedProperties to work as expected",
        propertyNames: {
          pattern: "^[a-zA-Z0-9._-]+$"
        }
      }
    },
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  paths: {
    type: "object",
    patternProperties: {
      "^/": {
        $ref: "#/$defs/path-item"
      }
    },
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  "path-item": {
    type: "object",
    properties: {
      summary: {
        type: "string"
      },
      description: {
        type: "string"
      },
      servers: {
        type: "array",
        items: {
          $ref: "#/$defs/server"
        }
      },
      parameters: {
        type: "array",
        items: {
          $ref: "#/$defs/parameter-or-reference"
        }
      }
    },
    patternProperties: {
      "^(get|put|post|delete|options|head|patch|trace)$": {
        $ref: "#/$defs/operation"
      }
    },
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  "path-item-or-reference": {
    if: {
      required: [
        "$ref"
      ]
    },
    then: {
      $ref: "#/$defs/reference"
    },
    else: {
      $ref: "#/$defs/path-item"
    }
  },
  operation: {
    type: "object",
    properties: {
      tags: {
        type: "array",
        items: {
          type: "string"
        }
      },
      summary: {
        type: "string"
      },
      description: {
        type: "string"
      },
      externalDocs: {
        $ref: "#/$defs/external-documentation"
      },
      operationId: {
        type: "string"
      },
      parameters: {
        type: "array",
        items: {
          $ref: "#/$defs/parameter-or-reference"
        }
      },
      requestBody: {
        $ref: "#/$defs/request-body-or-reference"
      },
      responses: {
        $ref: "#/$defs/responses"
      },
      callbacks: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/callbacks-or-reference"
        }
      },
      deprecated: {
        default: !1,
        type: "boolean"
      },
      security: {
        type: "array",
        items: {
          $ref: "#/$defs/security-requirement"
        }
      },
      servers: {
        type: "array",
        items: {
          $ref: "#/$defs/server"
        }
      }
    },
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  "external-documentation": {
    type: "object",
    properties: {
      description: {
        type: "string"
      },
      url: {
        $ref: "#/$defs/uri"
      }
    },
    required: [
      "url"
    ],
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  parameter: {
    type: "object",
    properties: {
      name: {
        type: "string"
      },
      in: {
        enum: [
          "query",
          "header",
          "path",
          "cookie"
        ]
      },
      description: {
        type: "string"
      },
      required: {
        default: !1,
        type: "boolean"
      },
      deprecated: {
        default: !1,
        type: "boolean"
      },
      allowEmptyValue: {
        default: !1,
        type: "boolean"
      },
      schema: {
        $dynamicRef: "#meta"
      },
      content: {
        $ref: "#/$defs/content"
      }
    },
    required: [
      "in"
    ],
    oneOf: [
      {
        required: [
          "schema"
        ]
      },
      {
        required: [
          "content"
        ]
      }
    ],
    dependentSchemas: {
      schema: {
        properties: {
          style: {
            type: "string"
          },
          explode: {
            type: "boolean"
          },
          allowReserved: {
            default: !1,
            type: "boolean"
          }
        },
        allOf: [
          {
            $ref: "#/$defs/examples"
          },
          {
            $ref: "#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-path"
          },
          {
            $ref: "#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-header"
          },
          {
            $ref: "#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-query"
          },
          {
            $ref: "#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-cookie"
          },
          {
            $ref: "#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-form"
          }
        ],
        $defs: {
          "styles-for-path": {
            if: {
              properties: {
                in: {
                  const: "path"
                }
              },
              required: [
                "in"
              ]
            },
            then: {
              properties: {
                style: {
                  default: "simple",
                  enum: [
                    "matrix",
                    "label",
                    "simple"
                  ]
                },
                required: {
                  const: !0
                }
              },
              required: [
                "required"
              ]
            }
          },
          "styles-for-header": {
            if: {
              properties: {
                in: {
                  const: "header"
                }
              },
              required: [
                "in"
              ]
            },
            then: {
              properties: {
                style: {
                  default: "simple",
                  enum: [
                    "simple"
                  ]
                }
              }
            }
          },
          "styles-for-query": {
            if: {
              properties: {
                in: {
                  const: "query"
                }
              },
              required: [
                "in"
              ]
            },
            then: {
              properties: {
                style: {
                  default: "form",
                  enum: [
                    "form",
                    "spaceDelimited",
                    "pipeDelimited",
                    "deepObject"
                  ]
                }
              }
            }
          },
          "styles-for-cookie": {
            if: {
              properties: {
                in: {
                  const: "cookie"
                }
              },
              required: [
                "in"
              ]
            },
            then: {
              properties: {
                style: {
                  default: "form",
                  enum: [
                    "form"
                  ]
                }
              }
            }
          },
          "styles-for-form": {
            if: {
              properties: {
                style: {
                  const: "form"
                }
              },
              required: [
                "style"
              ]
            },
            then: {
              properties: {
                explode: {
                  default: !0
                }
              }
            },
            else: {
              properties: {
                explode: {
                  default: !1
                }
              }
            }
          }
        }
      }
    },
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  "parameter-or-reference": {
    if: {
      required: [
        "$ref"
      ]
    },
    then: {
      $ref: "#/$defs/reference"
    },
    else: {
      $ref: "#/$defs/parameter"
    }
  },
  "request-body": {
    type: "object",
    properties: {
      description: {
        type: "string"
      },
      content: {
        $ref: "#/$defs/content"
      },
      required: {
        default: !1,
        type: "boolean"
      }
    },
    required: [
      "content"
    ],
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  "request-body-or-reference": {
    if: {
      required: [
        "$ref"
      ]
    },
    then: {
      $ref: "#/$defs/reference"
    },
    else: {
      $ref: "#/$defs/request-body"
    }
  },
  content: {
    type: "object",
    additionalProperties: {
      $ref: "#/$defs/media-type"
    },
    propertyNames: {
      format: "media-range"
    }
  },
  "media-type": {
    type: "object",
    properties: {
      schema: {
        $dynamicRef: "#meta"
      },
      encoding: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/encoding"
        }
      }
    },
    allOf: [
      {
        $ref: "#/$defs/specification-extensions"
      },
      {
        $ref: "#/$defs/examples"
      }
    ],
    unevaluatedProperties: !1
  },
  encoding: {
    type: "object",
    properties: {
      contentType: {
        type: "string",
        format: "media-range"
      },
      headers: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/header-or-reference"
        }
      },
      style: {
        default: "form",
        enum: [
          "form",
          "spaceDelimited",
          "pipeDelimited",
          "deepObject"
        ]
      },
      explode: {
        type: "boolean"
      },
      allowReserved: {
        default: !1,
        type: "boolean"
      }
    },
    allOf: [
      {
        $ref: "#/$defs/specification-extensions"
      },
      {
        $ref: "#/$defs/encoding/$defs/explode-default"
      }
    ],
    unevaluatedProperties: !1,
    $defs: {
      "explode-default": {
        if: {
          properties: {
            style: {
              const: "form"
            }
          },
          required: [
            "style"
          ]
        },
        then: {
          properties: {
            explode: {
              default: !0
            }
          }
        },
        else: {
          properties: {
            explode: {
              default: !1
            }
          }
        }
      }
    }
  },
  responses: {
    type: "object",
    properties: {
      default: {
        $ref: "#/$defs/response-or-reference"
      }
    },
    patternProperties: {
      "^[1-5][0-9X]{2}$": {
        $ref: "#/$defs/response-or-reference"
      }
    },
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  response: {
    type: "object",
    properties: {
      description: {
        type: "string"
      },
      headers: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/header-or-reference"
        }
      },
      content: {
        $ref: "#/$defs/content"
      },
      links: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/link-or-reference"
        }
      }
    },
    required: [
      "description"
    ],
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  "response-or-reference": {
    if: {
      required: [
        "$ref"
      ]
    },
    then: {
      $ref: "#/$defs/reference"
    },
    else: {
      $ref: "#/$defs/response"
    }
  },
  callbacks: {
    type: "object",
    $ref: "#/$defs/specification-extensions",
    additionalProperties: {
      $ref: "#/$defs/path-item-or-reference"
    }
  },
  "callbacks-or-reference": {
    if: {
      required: [
        "$ref"
      ]
    },
    then: {
      $ref: "#/$defs/reference"
    },
    else: {
      $ref: "#/$defs/callbacks"
    }
  },
  example: {
    type: "object",
    properties: {
      summary: {
        type: "string"
      },
      description: {
        type: "string"
      },
      value: !0,
      externalValue: {
        $ref: "#/$defs/uri"
      }
    },
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  "example-or-reference": {
    if: {
      required: [
        "$ref"
      ]
    },
    then: {
      $ref: "#/$defs/reference"
    },
    else: {
      $ref: "#/$defs/example"
    }
  },
  link: {
    type: "object",
    properties: {
      operationRef: {
        $ref: "#/$defs/uri"
      },
      operationId: !0,
      parameters: {
        $ref: "#/$defs/map-of-strings"
      },
      requestBody: !0,
      description: {
        type: "string"
      },
      body: {
        $ref: "#/$defs/server"
      }
    },
    oneOf: [
      {
        required: [
          "operationRef"
        ]
      },
      {
        required: [
          "operationId"
        ]
      }
    ],
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  "link-or-reference": {
    if: {
      required: [
        "$ref"
      ]
    },
    then: {
      $ref: "#/$defs/reference"
    },
    else: {
      $ref: "#/$defs/link"
    }
  },
  header: {
    type: "object",
    properties: {
      description: {
        type: "string"
      },
      required: {
        default: !1,
        type: "boolean"
      },
      deprecated: {
        default: !1,
        type: "boolean"
      },
      allowEmptyValue: {
        default: !1,
        type: "boolean"
      }
    },
    dependentSchemas: {
      schema: {
        properties: {
          style: {
            default: "simple",
            enum: [
              "simple"
            ]
          },
          explode: {
            default: !1,
            type: "boolean"
          },
          allowReserved: {
            default: !1,
            type: "boolean"
          },
          schema: {
            $dynamicRef: "#meta"
          }
        },
        $ref: "#/$defs/examples"
      },
      content: {
        properties: {
          content: {
            $ref: "#/$defs/content"
          }
        }
      }
    },
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  "header-or-reference": {
    if: {
      required: [
        "$ref"
      ]
    },
    then: {
      $ref: "#/$defs/reference"
    },
    else: {
      $ref: "#/$defs/header"
    }
  },
  tag: {
    type: "object",
    properties: {
      name: {
        type: "string"
      },
      description: {
        type: "string"
      },
      externalDocs: {
        $ref: "#/$defs/external-documentation"
      }
    },
    required: [
      "name"
    ],
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  reference: {
    type: "object",
    properties: {
      $ref: {
        $ref: "#/$defs/uri"
      },
      summary: {
        type: "string"
      },
      description: {
        type: "string"
      }
    },
    unevaluatedProperties: !1
  },
  schema: {
    $dynamicAnchor: "meta",
    type: [
      "object",
      "boolean"
    ]
  },
  "security-scheme": {
    type: "object",
    properties: {
      type: {
        enum: [
          "apiKey",
          "http",
          "mutualTLS",
          "oauth2",
          "openIdConnect"
        ]
      },
      description: {
        type: "string"
      }
    },
    required: [
      "type"
    ],
    allOf: [
      {
        $ref: "#/$defs/specification-extensions"
      },
      {
        $ref: "#/$defs/security-scheme/$defs/type-apikey"
      },
      {
        $ref: "#/$defs/security-scheme/$defs/type-http"
      },
      {
        $ref: "#/$defs/security-scheme/$defs/type-http-bearer"
      },
      {
        $ref: "#/$defs/security-scheme/$defs/type-oauth2"
      },
      {
        $ref: "#/$defs/security-scheme/$defs/type-oidc"
      }
    ],
    unevaluatedProperties: !1,
    $defs: {
      "type-apikey": {
        if: {
          properties: {
            type: {
              const: "apiKey"
            }
          },
          required: [
            "type"
          ]
        },
        then: {
          properties: {
            name: {
              type: "string"
            },
            in: {
              enum: [
                "query",
                "header",
                "cookie"
              ]
            }
          },
          required: [
            "name",
            "in"
          ]
        }
      },
      "type-http": {
        if: {
          properties: {
            type: {
              const: "http"
            }
          },
          required: [
            "type"
          ]
        },
        then: {
          properties: {
            scheme: {
              type: "string"
            }
          },
          required: [
            "scheme"
          ]
        }
      },
      "type-http-bearer": {
        if: {
          properties: {
            type: {
              const: "http"
            },
            scheme: {
              const: "bearer"
            }
          },
          required: [
            "type",
            "scheme"
          ]
        },
        then: {
          properties: {
            bearerFormat: {
              type: "string"
            }
          },
          required: [
            "scheme"
          ]
        }
      },
      "type-oauth2": {
        if: {
          properties: {
            type: {
              const: "oauth2"
            }
          },
          required: [
            "type"
          ]
        },
        then: {
          properties: {
            flows: {
              $ref: "#/$defs/oauth-flows"
            }
          },
          required: [
            "flows"
          ]
        }
      },
      "type-oidc": {
        if: {
          properties: {
            type: {
              const: "openIdConnect"
            }
          },
          required: [
            "type"
          ]
        },
        then: {
          properties: {
            openIdConnectUrl: {
              $ref: "#/$defs/uri"
            }
          },
          required: [
            "openIdConnectUrl"
          ]
        }
      }
    }
  },
  "security-scheme-or-reference": {
    if: {
      required: [
        "$ref"
      ]
    },
    then: {
      $ref: "#/$defs/reference"
    },
    else: {
      $ref: "#/$defs/security-scheme"
    }
  },
  "oauth-flows": {
    type: "object",
    properties: {
      implicit: {
        $ref: "#/$defs/oauth-flows/$defs/implicit"
      },
      password: {
        $ref: "#/$defs/oauth-flows/$defs/password"
      },
      clientCredentials: {
        $ref: "#/$defs/oauth-flows/$defs/client-credentials"
      },
      authorizationCode: {
        $ref: "#/$defs/oauth-flows/$defs/authorization-code"
      }
    },
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1,
    $defs: {
      implicit: {
        type: "object",
        properties: {
          authorizationUrl: {
            type: "string"
          },
          refreshUrl: {
            type: "string"
          },
          scopes: {
            $ref: "#/$defs/map-of-strings"
          }
        },
        required: [
          "authorizationUrl",
          "scopes"
        ],
        $ref: "#/$defs/specification-extensions",
        unevaluatedProperties: !1
      },
      password: {
        type: "object",
        properties: {
          tokenUrl: {
            type: "string"
          },
          refreshUrl: {
            type: "string"
          },
          scopes: {
            $ref: "#/$defs/map-of-strings"
          }
        },
        required: [
          "tokenUrl",
          "scopes"
        ],
        $ref: "#/$defs/specification-extensions",
        unevaluatedProperties: !1
      },
      "client-credentials": {
        type: "object",
        properties: {
          tokenUrl: {
            type: "string"
          },
          refreshUrl: {
            type: "string"
          },
          scopes: {
            $ref: "#/$defs/map-of-strings"
          }
        },
        required: [
          "tokenUrl",
          "scopes"
        ],
        $ref: "#/$defs/specification-extensions",
        unevaluatedProperties: !1
      },
      "authorization-code": {
        type: "object",
        properties: {
          authorizationUrl: {
            type: "string"
          },
          tokenUrl: {
            type: "string"
          },
          refreshUrl: {
            type: "string"
          },
          scopes: {
            $ref: "#/$defs/map-of-strings"
          }
        },
        required: [
          "authorizationUrl",
          "tokenUrl",
          "scopes"
        ],
        $ref: "#/$defs/specification-extensions",
        unevaluatedProperties: !1
      }
    }
  },
  "security-requirement": {
    type: "object",
    additionalProperties: {
      type: "array",
      items: {
        type: "string"
      }
    }
  },
  "specification-extensions": {
    patternProperties: {
      "^x-": !0
    }
  },
  examples: {
    properties: {
      example: !0,
      examples: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/example-or-reference"
        }
      }
    }
  },
  uri: {
    type: "string",
    format: "uri"
  },
  "map-of-strings": {
    type: "object",
    additionalProperties: {
      type: "string"
    }
  }
}, u8 = {
  $id: Qq,
  $schema: e8,
  type: t8,
  properties: r8,
  required: n8,
  anyOf: i8,
  $ref: s8,
  unevaluatedProperties: a8,
  $defs: o8
};
(function(e, t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.openapi = t.openapiV31 = t.openapiV3 = t.openapiV2 = t.openapiV1 = void 0, t.openapiV1 = Iq, t.openapiV2 = Bq, t.openapiV3 = Xq, t.openapiV31 = u8, t.openapi = {
    v1: t.openapiV1,
    v2: t.openapiV2,
    v3: t.openapiV3,
    v31: t.openapiV31
  }, t.default = t.openapi, e.exports = Object.assign(e.exports.default, e.exports);
})(Iy, Iy.exports);
var c8 = Iy.exports, jy = { exports: {} }, WO = { exports: {} };
(function(e) {
  function t(r) {
    return r && r.__esModule ? r : {
      default: r
    };
  }
  e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports;
})(WO);
var Ln = WO.exports, ki = {};
Object.defineProperty(ki, "__esModule", { value: !0 });
const l8 = "[", f8 = "]", d8 = "{", p8 = "}", h8 = ":", m8 = ",", HO = "true", GO = "false", KO = "null", T_ = '"', y8 = /* @__PURE__ */ new Map([
  ["t", HO],
  ["f", GO],
  ["n", KO]
]), ky = /* @__PURE__ */ new Map([
  [T_, T_],
  ["\\", "\\"],
  ["/", "/"],
  ["b", "\b"],
  ["n", `
`],
  ["f", "\f"],
  ["r", "\r"],
  ["t", "	"]
]), rh = /* @__PURE__ */ new Map([
  [l8, "Punctuator"],
  [f8, "Punctuator"],
  [d8, "Punctuator"],
  [p8, "Punctuator"],
  [h8, "Punctuator"],
  [m8, "Punctuator"],
  [HO, "Boolean"],
  [GO, "Boolean"],
  [KO, "Null"]
]);
class qu extends Error {
  /**
   * 
   * @param {string} message The error message to report. 
   * @param {int} loc.line The line on which the error occurred.
   * @param {int} loc.column The column in the line where the error occurrred.
   * @param {int} loc.index The index in the string where the error occurred.
   */
  constructor(t, { line: r, column: n, index: i }) {
    super(`${t} (${r}:${n})`), this.line = r, this.column = n, this.index = i;
  }
}
class g8 extends qu {
  /**
   * Creates a new instance.
   * @param {string} unexpected The character that was found.
   * @param {Object} loc The location information for the found character.
   */
  constructor(t, r) {
    super(`Unexpected character ${t} found.`, r);
  }
}
class tl extends qu {
  /**
   * Creates a new instance.
   * @param {string} expected The character that was expected. 
   * @param {string} unexpected The character that was found.
   * @param {Object} loc The location information for the found character.
   */
  constructor(t) {
    super(`Unexpected token ${t.type}(${t.value}) found.`, t.loc.start);
  }
}
class v8 extends qu {
  /**
   * Creates a new instance.
   * @param {Object} loc The location information for the found character.
   */
  constructor(t) {
    super("Unexpected end of input found.", t);
  }
}
const I_ = '"', j_ = "/", k_ = "*", b8 = {
  comments: !1,
  ranges: !1
};
function _8(e) {
  return /[\s\n]/.test(e);
}
function ts(e) {
  return e >= "0" && e <= "9";
}
function w8(e) {
  return ts(e) || /[a-f]/i.test(e);
}
function $8(e) {
  return e >= "1" && e <= "9";
}
function E8(e) {
  return /[tfn]/.test(e);
}
function x8(e) {
  return ts(e) || e === "." || e === "-";
}
function YO(e, t) {
  t = Object.freeze({
    ...b8,
    ...t
  });
  let r = -1, n = 1, i = 0, s = !1;
  const a = [];
  function u(m, w, $, E) {
    const A = $.offset + w.length;
    let R = t.ranges ? {
      range: [$.offset, A]
    } : void 0;
    return {
      type: m,
      value: w,
      loc: {
        start: $,
        end: E || {
          line: $.line,
          column: $.column + w.length,
          offset: A
        }
      },
      ...R
    };
  }
  function c() {
    let m = e.charAt(++r);
    return s ? (n++, i = 1, s = !1) : i++, m === "\r" ? (s = !0, e.charAt(r + 1) === `
` && r++) : m === `
` && (s = !0), m;
  }
  function l() {
    return {
      line: n,
      column: i,
      offset: r
    };
  }
  function d(m) {
    let w = y8.get(m);
    if (e.slice(r, r + w.length) === w)
      return r += w.length - 1, i += w.length - 1, { value: w, c: c() };
    for (let $ = 1; $ < w.length; $++)
      w[$] !== e.charAt(r + $) && y(c());
  }
  function p(m) {
    let w = m;
    for (m = c(); m && m !== I_; ) {
      if (m === "\\")
        if (w += m, m = c(), ky.has(m))
          w += m;
        else if (m === "u") {
          w += m;
          for (let $ = 0; $ < 4; $++)
            m = c(), w8(m) ? w += m : y(m);
        } else
          y(m);
      else
        w += m;
      m = c();
    }
    return m || g(), w += m, { value: w, c: c() };
  }
  function h(m) {
    let w = "";
    if (m === "-" && (w += m, m = c(), ts(m) || y(m)), m === "0")
      w += m, m = c(), ts(m) && y(m);
    else {
      $8(m) || y(m);
      do
        w += m, m = c();
      while (ts(m));
    }
    if (m === ".")
      do
        w += m, m = c();
      while (ts(m));
    if (m === "e" || m === "E")
      for (w += m, m = c(), (m === "+" || m === "-") && (w += m, m = c()), ts(m) || y(m); ts(m); )
        w += m, m = c();
    return { value: w, c: m };
  }
  function v(m) {
    let w = m;
    if (m = c(), m === "/") {
      do
        w += m, m = c();
      while (m && m !== "\r" && m !== `
`);
      return { value: w, c: m };
    }
    if (m === k_) {
      for (; m; )
        if (w += m, m = c(), m === k_ && (w += m, m = c(), m === j_))
          return w += m, m = c(), { value: w, c: m };
      g();
    }
    y(m);
  }
  function y(m) {
    throw new g8(m, l());
  }
  function g() {
    throw new v8(l());
  }
  let _ = c();
  for (; r < e.length; ) {
    for (; _8(_); )
      _ = c();
    if (!_)
      break;
    const m = l();
    if (rh.has(_))
      a.push(u(rh.get(_), _, m)), _ = c();
    else if (E8(_)) {
      const w = d(_);
      let $ = w.value;
      _ = w.c, a.push(u(rh.get($), $, m));
    } else if (x8(_)) {
      const w = h(_);
      let $ = w.value;
      _ = w.c, a.push(u("Number", $, m));
    } else if (_ === I_) {
      const w = p(_);
      let $ = w.value;
      _ = w.c, a.push(u("String", $, m));
    } else if (_ === j_ && t.comments) {
      const w = v(_);
      let $ = w.value;
      _ = w.c, a.push(u($.startsWith("//") ? "LineComment" : "BlockComment", $, m, l()));
    } else
      y(_);
  }
  return a;
}
const iu = {
  document(e, t = {}) {
    return {
      type: "Document",
      body: e,
      ...t
    };
  },
  string(e, t = {}) {
    return {
      type: "String",
      value: e,
      ...t
    };
  },
  number(e, t = {}) {
    return {
      type: "Number",
      value: e,
      ...t
    };
  },
  boolean(e, t = {}) {
    return {
      type: "Boolean",
      value: e,
      ...t
    };
  },
  null(e = {}) {
    return {
      type: "Null",
      value: "null",
      ...e
    };
  },
  array(e, t = {}) {
    return {
      type: "Array",
      elements: e,
      ...t
    };
  },
  object(e, t = {}) {
    return {
      type: "Object",
      members: e,
      ...t
    };
  },
  member(e, t, r = {}) {
    return {
      type: "Member",
      name: e,
      value: t,
      ...r
    };
  }
}, O8 = {
  tokens: !1,
  comments: !1,
  ranges: !1
};
function P8(e) {
  let t = e.value.slice(1, -1), r = "", n = t.indexOf("\\"), i = 0;
  for (; n >= 0; ) {
    r += t.slice(i, n);
    const s = t.charAt(n + 1);
    if (ky.has(s))
      r += ky.get(s), i = n + 2;
    else if (s === "u") {
      const a = t.slice(n + 2, n + 6);
      if (a.length < 4 || /[^0-9a-f]/i.test(a))
        throw new qu(
          `Invalid unicode escape \\u${a}.`,
          {
            line: e.loc.start.line,
            column: e.loc.start.column + n,
            offset: e.loc.start.offset + n
          }
        );
      r += String.fromCharCode(parseInt(a, 16)), i = n + 6;
    } else
      throw new qu(
        `Invalid escape \\${s}.`,
        {
          line: e.loc.start.line,
          column: e.loc.start.column + n,
          offset: e.loc.start.offset + n
        }
      );
    n = t.indexOf("\\", i);
  }
  return r += t.slice(i), r;
}
function S8(e) {
  switch (e.type) {
    case "Boolean":
      return e.value === "true";
    case "Number":
      return Number(e.value);
    case "Null":
      return null;
    case "String":
      return P8(e);
  }
}
function A8(e, t) {
  t = Object.freeze({
    ...O8,
    ...t
  });
  const r = YO(e, {
    comments: !!t.comments,
    ranges: !!t.ranges
  });
  let n = 0;
  function i() {
    return r[n++];
  }
  function s() {
    const w = r[n++];
    return w && w.type.endsWith("Comment") ? s() : w;
  }
  const a = t.comments ? s : i;
  function u(w, $) {
    if (!w || w.value !== $)
      throw new tl(w);
  }
  function c(w, $) {
    if (!w || w.type !== $)
      throw new tl(w);
  }
  function l(w, $) {
    return t.ranges ? {
      range: [w.offset, $.offset]
    } : void 0;
  }
  function d(w) {
    const $ = l(w.loc.start, w.loc.end);
    return {
      type: w.type,
      value: S8(w),
      loc: {
        start: {
          ...w.loc.start
        },
        end: {
          ...w.loc.end
        }
      },
      ...$
    };
  }
  function p(w) {
    c(w, "String");
    const $ = d(w);
    w = a(), u(w, ":");
    const E = y(), A = l($.loc.start, E.loc.end);
    return iu.member($, E, {
      loc: {
        start: {
          ...$.loc.start
        },
        end: {
          ...E.loc.end
        }
      },
      ...A
    });
  }
  function h(w) {
    u(w, "{");
    const $ = [];
    let E = a();
    if (E && E.value !== "}")
      do
        if ($.push(p(E)), E = a(), E.value === ",")
          E = a();
        else
          break;
      while (E);
    u(E, "}");
    const A = l(w.loc.start, E.loc.end);
    return iu.object($, {
      loc: {
        start: {
          ...w.loc.start
        },
        end: {
          ...E.loc.end
        }
      },
      ...A
    });
  }
  function v(w) {
    u(w, "[");
    const $ = [];
    let E = a();
    if (E && E.value !== "]")
      do
        if ($.push(y(E)), E = a(), E.value === ",")
          E = a();
        else
          break;
      while (E);
    u(E, "]");
    const A = l(w.loc.start, E.loc.end);
    return iu.array($, {
      type: "Array",
      elements: $,
      loc: {
        start: {
          ...w.loc.start
        },
        end: {
          ...E.loc.end
        }
      },
      ...A
    });
  }
  function y(w) {
    switch (w = w || a(), w.type) {
      case "String":
      case "Boolean":
      case "Number":
      case "Null":
        return d(w);
      case "Punctuator":
        if (w.value === "{")
          return h(w);
        if (w.value === "[")
          return v(w);
      default:
        throw new tl(w);
    }
  }
  const g = y(), _ = a();
  if (_)
    throw new tl(_);
  const m = {
    loc: {
      start: {
        line: 1,
        column: 1,
        offset: 0
      },
      end: {
        ...g.loc.end
      }
    }
  };
  return t.tokens && (m.tokens = r), t.ranges && (m.range = l(m.loc.start, m.loc.end)), iu.document(g, m);
}
const C8 = /* @__PURE__ */ new Map([
  ["Document", ["body"]],
  ["Object", ["members"]],
  ["Member", ["name", "value"]],
  ["Array", ["elements"]],
  ["String", []],
  ["Number", []],
  ["Boolean", []],
  ["Null", []]
]);
function JO(e) {
  return e && typeof e == "object";
}
function R8(e) {
  return JO(e) && typeof e.type == "string";
}
function XO(e, t) {
  function r(n, i) {
    typeof t.enter == "function" && t.enter(n, i);
    for (const s of C8.get(n.type)) {
      const a = n[s];
      JO(a) && (Array.isArray(a) ? a.forEach((u) => r(u, n)) : R8(a) && r(a, n));
    }
    typeof t.exit == "function" && t.exit(n, i);
  }
  r(e);
}
function T8(e, t = () => !0) {
  const r = [];
  return XO(e, {
    enter(n, i) {
      r.push({ node: n, parent: i, phase: "enter" });
    },
    exit(n, i) {
      r.push({ node: n, parent: i, phase: "exit" });
    }
  }), r.filter(t).values();
}
function Za(e) {
  switch (e.type) {
    case "String":
    case "Number":
    case "Boolean":
      return e.value;
    case "Null":
      return null;
    case "Array":
      return e.elements.map(Za);
    case "Object": {
      const t = {};
      return e.members.forEach((r) => {
        t[Za(r.name)] = Za(r.value);
      }), t;
    }
    case "Document":
      return Za(e.body);
    case "Property":
      throw new Error("Cannot evaluate object property outside of an object.");
    default:
      throw new Error(`Unknown node type ${e.type}.`);
  }
}
function I8(e, { indent: t = 0 } = {}) {
  const r = Za(e);
  return JSON.stringify(r, null, t);
}
ki.evaluate = Za;
ki.iterator = T8;
ki.parse = A8;
ki.print = I8;
ki.tokenize = YO;
ki.traverse = XO;
ki.types = iu;
var nh = {}, ih = { exports: {} }, sh = { exports: {} }, ah = { exports: {} }, M_;
function Zg() {
  return M_ || (M_ = 1, function(e) {
    function t(r) {
      "@babel/helpers - typeof";
      return e.exports = t = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(n) {
        return typeof n;
      } : function(n) {
        return n && typeof Symbol == "function" && n.constructor === Symbol && n !== Symbol.prototype ? "symbol" : typeof n;
      }, e.exports.__esModule = !0, e.exports.default = e.exports, t(r);
    }
    e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(ah)), ah.exports;
}
var oh = { exports: {} }, N_;
function j8() {
  return N_ || (N_ = 1, function(e) {
    var t = Zg().default;
    function r(n, i) {
      if (t(n) !== "object" || n === null)
        return n;
      var s = n[Symbol.toPrimitive];
      if (s !== void 0) {
        var a = s.call(n, i || "default");
        if (t(a) !== "object")
          return a;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (i === "string" ? String : Number)(n);
    }
    e.exports = r, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(oh)), oh.exports;
}
var D_;
function QO() {
  return D_ || (D_ = 1, function(e) {
    var t = Zg().default, r = j8();
    function n(i) {
      var s = r(i, "string");
      return t(s) === "symbol" ? s : String(s);
    }
    e.exports = n, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(sh)), sh.exports;
}
var L_;
function ra() {
  return L_ || (L_ = 1, function(e) {
    var t = QO();
    function r(n, i, s) {
      return i = t(i), i in n ? Object.defineProperty(n, i, {
        value: s,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }) : n[i] = s, n;
    }
    e.exports = r, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(ih)), ih.exports;
}
var uh = { exports: {} }, ch = { exports: {} }, lh = { exports: {} }, q_;
function eP() {
  return q_ || (q_ = 1, function(e) {
    function t(r, n) {
      (n == null || n > r.length) && (n = r.length);
      for (var i = 0, s = new Array(n); i < n; i++)
        s[i] = r[i];
      return s;
    }
    e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(lh)), lh.exports;
}
var F_;
function k8() {
  return F_ || (F_ = 1, function(e) {
    var t = eP();
    function r(n) {
      if (Array.isArray(n))
        return t(n);
    }
    e.exports = r, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(ch)), ch.exports;
}
var fh = { exports: {} }, U_;
function M8() {
  return U_ || (U_ = 1, function(e) {
    function t(r) {
      if (typeof Symbol < "u" && r[Symbol.iterator] != null || r["@@iterator"] != null)
        return Array.from(r);
    }
    e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(fh)), fh.exports;
}
var dh = { exports: {} }, B_;
function tP() {
  return B_ || (B_ = 1, function(e) {
    var t = eP();
    function r(n, i) {
      if (n) {
        if (typeof n == "string")
          return t(n, i);
        var s = Object.prototype.toString.call(n).slice(8, -1);
        if (s === "Object" && n.constructor && (s = n.constructor.name), s === "Map" || s === "Set")
          return Array.from(n);
        if (s === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(s))
          return t(n, i);
      }
    }
    e.exports = r, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(dh)), dh.exports;
}
var ph = { exports: {} }, V_;
function N8() {
  return V_ || (V_ = 1, function(e) {
    function t() {
      throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(ph)), ph.exports;
}
var Z_;
function D8() {
  return Z_ || (Z_ = 1, function(e) {
    var t = k8(), r = M8(), n = tP(), i = N8();
    function s(a) {
      return t(a) || r(a) || n(a) || i();
    }
    e.exports = s, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(uh)), uh.exports;
}
var hh = { exports: {} }, mh = { exports: {} }, z_;
function L8() {
  return z_ || (z_ = 1, function(e) {
    function t(r) {
      if (Array.isArray(r))
        return r;
    }
    e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(mh)), mh.exports;
}
var yh = { exports: {} }, W_;
function q8() {
  return W_ || (W_ = 1, function(e) {
    function t(r, n) {
      var i = r == null ? null : typeof Symbol < "u" && r[Symbol.iterator] || r["@@iterator"];
      if (i != null) {
        var s, a, u, c, l = [], d = !0, p = !1;
        try {
          if (u = (i = i.call(r)).next, n === 0) {
            if (Object(i) !== i)
              return;
            d = !1;
          } else
            for (; !(d = (s = u.call(i)).done) && (l.push(s.value), l.length !== n); d = !0)
              ;
        } catch (h) {
          p = !0, a = h;
        } finally {
          try {
            if (!d && i.return != null && (c = i.return(), Object(c) !== c))
              return;
          } finally {
            if (p)
              throw a;
          }
        }
        return l;
      }
    }
    e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(yh)), yh.exports;
}
var gh = { exports: {} }, H_;
function F8() {
  return H_ || (H_ = 1, function(e) {
    function t() {
      throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(gh)), gh.exports;
}
var G_;
function U8() {
  return G_ || (G_ = 1, function(e) {
    var t = L8(), r = q8(), n = tP(), i = F8();
    function s(a, u) {
      return t(a) || r(a, u) || n(a, u) || i();
    }
    e.exports = s, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(hh)), hh.exports;
}
var lr = {}, K_;
function B8() {
  if (K_)
    return lr;
  K_ = 1, Object.defineProperty(lr, "__esModule", {
    value: !0
  }), lr.notUndefined = lr.isRequiredError = lr.isEnumError = lr.isAnyOfError = lr.getSiblings = lr.getErrors = lr.getChildren = lr.concatAll = void 0;
  var e = function(v) {
    return function(y) {
      return v === y;
    };
  }, t = function(v) {
    return function(y) {
      return !v(y);
    };
  }, r = function(v) {
    return Object.values(v);
  }, n = function(v) {
    return v !== void 0;
  };
  lr.notUndefined = n;
  var i = function(v) {
    return function(y) {
      return y.keyword === v;
    };
  }, s = i("required");
  lr.isRequiredError = s;
  var a = i("anyOf");
  lr.isAnyOfError = a;
  var u = i("enum");
  lr.isEnumError = u;
  var c = function(v) {
    return v && v.errors || [];
  };
  lr.getErrors = c;
  var l = function(v) {
    return v && r(v.children) || [];
  };
  lr.getChildren = l;
  var d = function(v) {
    return function(y) {
      return l(v).filter(t(e(y)));
    };
  };
  lr.getSiblings = d;
  var p = (
    /* ::<T> */
    function(v) {
      return function(y) {
        return y.reduce(function(g, _) {
          return g.concat(_);
        }, v);
      };
    }
  );
  return lr.concatAll = p, lr;
}
var vh = {}, rl = { exports: {} }, bh = { exports: {} }, Y_;
function lo() {
  return Y_ || (Y_ = 1, function(e) {
    function t(r, n) {
      return n || (n = r.slice(0)), Object.freeze(Object.defineProperties(r, {
        raw: {
          value: Object.freeze(n)
        }
      }));
    }
    e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(bh)), bh.exports;
}
var _h = { exports: {} }, J_;
function na() {
  return J_ || (J_ = 1, function(e) {
    function t(r, n) {
      if (!(r instanceof n))
        throw new TypeError("Cannot call a class as a function");
    }
    e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(_h)), _h.exports;
}
var wh = { exports: {} }, X_;
function ia() {
  return X_ || (X_ = 1, function(e) {
    var t = QO();
    function r(i, s) {
      for (var a = 0; a < s.length; a++) {
        var u = s[a];
        u.enumerable = u.enumerable || !1, u.configurable = !0, "value" in u && (u.writable = !0), Object.defineProperty(i, t(u.key), u);
      }
    }
    function n(i, s, a) {
      return s && r(i.prototype, s), a && r(i, a), Object.defineProperty(i, "prototype", {
        writable: !1
      }), i;
    }
    e.exports = n, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(wh)), wh.exports;
}
var $h = { exports: {} }, Eh = { exports: {} }, Q_;
function V8() {
  return Q_ || (Q_ = 1, function(e) {
    function t(r, n) {
      return e.exports = t = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(s, a) {
        return s.__proto__ = a, s;
      }, e.exports.__esModule = !0, e.exports.default = e.exports, t(r, n);
    }
    e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(Eh)), Eh.exports;
}
var ew;
function fo() {
  return ew || (ew = 1, function(e) {
    var t = V8();
    function r(n, i) {
      if (typeof i != "function" && i !== null)
        throw new TypeError("Super expression must either be null or a function");
      n.prototype = Object.create(i && i.prototype, {
        constructor: {
          value: n,
          writable: !0,
          configurable: !0
        }
      }), Object.defineProperty(n, "prototype", {
        writable: !1
      }), i && t(n, i);
    }
    e.exports = r, e.exports.__esModule = !0, e.exports.default = e.exports;
  }($h)), $h.exports;
}
var xh = { exports: {} }, Oh = { exports: {} }, tw;
function Z8() {
  return tw || (tw = 1, function(e) {
    function t(r) {
      if (r === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return r;
    }
    e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(Oh)), Oh.exports;
}
var rw;
function po() {
  return rw || (rw = 1, function(e) {
    var t = Zg().default, r = Z8();
    function n(i, s) {
      if (s && (t(s) === "object" || typeof s == "function"))
        return s;
      if (s !== void 0)
        throw new TypeError("Derived constructors may only return object or undefined");
      return r(i);
    }
    e.exports = n, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(xh)), xh.exports;
}
var Ph = { exports: {} }, nw;
function sa() {
  return nw || (nw = 1, function(e) {
    function t(r) {
      return e.exports = t = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(i) {
        return i.__proto__ || Object.getPrototypeOf(i);
      }, e.exports.__esModule = !0, e.exports.default = e.exports, t(r);
    }
    e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(Ph)), Ph.exports;
}
var nl = { exports: {} }, Wo = {}, Ra = {}, Ho = {}, iw;
function z8() {
  return iw || (iw = 1, Object.defineProperty(Ho, "__esModule", {
    value: !0
  }), Ho.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g, Ho.matchToToken = function(e) {
    var t = { type: "invalid", value: e[0], closed: void 0 };
    return e[1] ? (t.type = "string", t.closed = !!(e[3] || e[4])) : e[5] ? t.type = "comment" : e[6] ? (t.type = "comment", t.closed = !!e[7]) : e[8] ? t.type = "regex" : e[9] ? t.type = "number" : e[10] ? t.type = "name" : e[11] ? t.type = "punctuator" : e[12] && (t.type = "whitespace"), t;
  }), Ho;
}
var Sh = {}, Ta = {}, sw;
function W8() {
  if (sw)
    return Ta;
  sw = 1, Object.defineProperty(Ta, "__esModule", {
    value: !0
  }), Ta.isIdentifierChar = c, Ta.isIdentifierName = l, Ta.isIdentifierStart = u;
  let e = "------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------", t = "-----------------------------------------------------------------------------------------------------------------------------------------------------";
  const r = new RegExp("[" + e + "]"), n = new RegExp("[" + e + t + "]");
  e = t = null;
  const i = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938, 6, 4191], s = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function a(d, p) {
    let h = 65536;
    for (let v = 0, y = p.length; v < y; v += 2) {
      if (h += p[v], h > d)
        return !1;
      if (h += p[v + 1], h >= d)
        return !0;
    }
    return !1;
  }
  function u(d) {
    return d < 65 ? d === 36 : d <= 90 ? !0 : d < 97 ? d === 95 : d <= 122 ? !0 : d <= 65535 ? d >= 170 && r.test(String.fromCharCode(d)) : a(d, i);
  }
  function c(d) {
    return d < 48 ? d === 36 : d < 58 ? !0 : d < 65 ? !1 : d <= 90 ? !0 : d < 97 ? d === 95 : d <= 122 ? !0 : d <= 65535 ? d >= 170 && n.test(String.fromCharCode(d)) : a(d, i) || a(d, s);
  }
  function l(d) {
    let p = !0;
    for (let h = 0; h < d.length; h++) {
      let v = d.charCodeAt(h);
      if ((v & 64512) === 55296 && h + 1 < d.length) {
        const y = d.charCodeAt(++h);
        (y & 64512) === 56320 && (v = 65536 + ((v & 1023) << 10) + (y & 1023));
      }
      if (p) {
        if (p = !1, !u(v))
          return !1;
      } else if (!c(v))
        return !1;
    }
    return !p;
  }
  return Ta;
}
var Yi = {}, aw;
function H8() {
  if (aw)
    return Yi;
  aw = 1, Object.defineProperty(Yi, "__esModule", {
    value: !0
  }), Yi.isKeyword = c, Yi.isReservedWord = i, Yi.isStrictBindOnlyReservedWord = a, Yi.isStrictBindReservedWord = u, Yi.isStrictReservedWord = s;
  const e = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  }, t = new Set(e.keyword), r = new Set(e.strict), n = new Set(e.strictBind);
  function i(l, d) {
    return d && l === "await" || l === "enum";
  }
  function s(l, d) {
    return i(l, d) || r.has(l);
  }
  function a(l) {
    return n.has(l);
  }
  function u(l, d) {
    return s(l, d) || a(l);
  }
  function c(l) {
    return t.has(l);
  }
  return Yi;
}
var ow;
function G8() {
  return ow || (ow = 1, function(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), Object.defineProperty(e, "isIdentifierChar", {
      enumerable: !0,
      get: function() {
        return t.isIdentifierChar;
      }
    }), Object.defineProperty(e, "isIdentifierName", {
      enumerable: !0,
      get: function() {
        return t.isIdentifierName;
      }
    }), Object.defineProperty(e, "isIdentifierStart", {
      enumerable: !0,
      get: function() {
        return t.isIdentifierStart;
      }
    }), Object.defineProperty(e, "isKeyword", {
      enumerable: !0,
      get: function() {
        return r.isKeyword;
      }
    }), Object.defineProperty(e, "isReservedWord", {
      enumerable: !0,
      get: function() {
        return r.isReservedWord;
      }
    }), Object.defineProperty(e, "isStrictBindOnlyReservedWord", {
      enumerable: !0,
      get: function() {
        return r.isStrictBindOnlyReservedWord;
      }
    }), Object.defineProperty(e, "isStrictBindReservedWord", {
      enumerable: !0,
      get: function() {
        return r.isStrictBindReservedWord;
      }
    }), Object.defineProperty(e, "isStrictReservedWord", {
      enumerable: !0,
      get: function() {
        return r.isStrictReservedWord;
      }
    });
    var t = W8(), r = H8();
  }(Sh)), Sh;
}
var Ah = { exports: {} }, Ch, uw;
function K8() {
  if (uw)
    return Ch;
  uw = 1;
  var e = /[|\\{}()[\]^$+*?.]/g;
  return Ch = function(t) {
    if (typeof t != "string")
      throw new TypeError("Expected a string");
    return t.replace(e, "\\$&");
  }, Ch;
}
var Il = { exports: {} }, Rh = { exports: {} }, Th, cw;
function Y8() {
  return cw || (cw = 1, Th = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  }), Th;
}
var lw;
function rP() {
  if (lw)
    return Rh.exports;
  lw = 1;
  var e = Y8(), t = {};
  for (var r in e)
    e.hasOwnProperty(r) && (t[e[r]] = r);
  var n = Rh.exports = {
    rgb: { channels: 3, labels: "rgb" },
    hsl: { channels: 3, labels: "hsl" },
    hsv: { channels: 3, labels: "hsv" },
    hwb: { channels: 3, labels: "hwb" },
    cmyk: { channels: 4, labels: "cmyk" },
    xyz: { channels: 3, labels: "xyz" },
    lab: { channels: 3, labels: "lab" },
    lch: { channels: 3, labels: "lch" },
    hex: { channels: 1, labels: ["hex"] },
    keyword: { channels: 1, labels: ["keyword"] },
    ansi16: { channels: 1, labels: ["ansi16"] },
    ansi256: { channels: 1, labels: ["ansi256"] },
    hcg: { channels: 3, labels: ["h", "c", "g"] },
    apple: { channels: 3, labels: ["r16", "g16", "b16"] },
    gray: { channels: 1, labels: ["gray"] }
  };
  for (var i in n)
    if (n.hasOwnProperty(i)) {
      if (!("channels" in n[i]))
        throw new Error("missing channels property: " + i);
      if (!("labels" in n[i]))
        throw new Error("missing channel labels property: " + i);
      if (n[i].labels.length !== n[i].channels)
        throw new Error("channel and label counts mismatch: " + i);
      var s = n[i].channels, a = n[i].labels;
      delete n[i].channels, delete n[i].labels, Object.defineProperty(n[i], "channels", { value: s }), Object.defineProperty(n[i], "labels", { value: a });
    }
  n.rgb.hsl = function(c) {
    var l = c[0] / 255, d = c[1] / 255, p = c[2] / 255, h = Math.min(l, d, p), v = Math.max(l, d, p), y = v - h, g, _, m;
    return v === h ? g = 0 : l === v ? g = (d - p) / y : d === v ? g = 2 + (p - l) / y : p === v && (g = 4 + (l - d) / y), g = Math.min(g * 60, 360), g < 0 && (g += 360), m = (h + v) / 2, v === h ? _ = 0 : m <= 0.5 ? _ = y / (v + h) : _ = y / (2 - v - h), [g, _ * 100, m * 100];
  }, n.rgb.hsv = function(c) {
    var l, d, p, h, v, y = c[0] / 255, g = c[1] / 255, _ = c[2] / 255, m = Math.max(y, g, _), w = m - Math.min(y, g, _), $ = function(E) {
      return (m - E) / 6 / w + 1 / 2;
    };
    return w === 0 ? h = v = 0 : (v = w / m, l = $(y), d = $(g), p = $(_), y === m ? h = p - d : g === m ? h = 1 / 3 + l - p : _ === m && (h = 2 / 3 + d - l), h < 0 ? h += 1 : h > 1 && (h -= 1)), [
      h * 360,
      v * 100,
      m * 100
    ];
  }, n.rgb.hwb = function(c) {
    var l = c[0], d = c[1], p = c[2], h = n.rgb.hsl(c)[0], v = 1 / 255 * Math.min(l, Math.min(d, p));
    return p = 1 - 1 / 255 * Math.max(l, Math.max(d, p)), [h, v * 100, p * 100];
  }, n.rgb.cmyk = function(c) {
    var l = c[0] / 255, d = c[1] / 255, p = c[2] / 255, h, v, y, g;
    return g = Math.min(1 - l, 1 - d, 1 - p), h = (1 - l - g) / (1 - g) || 0, v = (1 - d - g) / (1 - g) || 0, y = (1 - p - g) / (1 - g) || 0, [h * 100, v * 100, y * 100, g * 100];
  };
  function u(c, l) {
    return Math.pow(c[0] - l[0], 2) + Math.pow(c[1] - l[1], 2) + Math.pow(c[2] - l[2], 2);
  }
  return n.rgb.keyword = function(c) {
    var l = t[c];
    if (l)
      return l;
    var d = 1 / 0, p;
    for (var h in e)
      if (e.hasOwnProperty(h)) {
        var v = e[h], y = u(c, v);
        y < d && (d = y, p = h);
      }
    return p;
  }, n.keyword.rgb = function(c) {
    return e[c];
  }, n.rgb.xyz = function(c) {
    var l = c[0] / 255, d = c[1] / 255, p = c[2] / 255;
    l = l > 0.04045 ? Math.pow((l + 0.055) / 1.055, 2.4) : l / 12.92, d = d > 0.04045 ? Math.pow((d + 0.055) / 1.055, 2.4) : d / 12.92, p = p > 0.04045 ? Math.pow((p + 0.055) / 1.055, 2.4) : p / 12.92;
    var h = l * 0.4124 + d * 0.3576 + p * 0.1805, v = l * 0.2126 + d * 0.7152 + p * 0.0722, y = l * 0.0193 + d * 0.1192 + p * 0.9505;
    return [h * 100, v * 100, y * 100];
  }, n.rgb.lab = function(c) {
    var l = n.rgb.xyz(c), d = l[0], p = l[1], h = l[2], v, y, g;
    return d /= 95.047, p /= 100, h /= 108.883, d = d > 8856e-6 ? Math.pow(d, 1 / 3) : 7.787 * d + 16 / 116, p = p > 8856e-6 ? Math.pow(p, 1 / 3) : 7.787 * p + 16 / 116, h = h > 8856e-6 ? Math.pow(h, 1 / 3) : 7.787 * h + 16 / 116, v = 116 * p - 16, y = 500 * (d - p), g = 200 * (p - h), [v, y, g];
  }, n.hsl.rgb = function(c) {
    var l = c[0] / 360, d = c[1] / 100, p = c[2] / 100, h, v, y, g, _;
    if (d === 0)
      return _ = p * 255, [_, _, _];
    p < 0.5 ? v = p * (1 + d) : v = p + d - p * d, h = 2 * p - v, g = [0, 0, 0];
    for (var m = 0; m < 3; m++)
      y = l + 1 / 3 * -(m - 1), y < 0 && y++, y > 1 && y--, 6 * y < 1 ? _ = h + (v - h) * 6 * y : 2 * y < 1 ? _ = v : 3 * y < 2 ? _ = h + (v - h) * (2 / 3 - y) * 6 : _ = h, g[m] = _ * 255;
    return g;
  }, n.hsl.hsv = function(c) {
    var l = c[0], d = c[1] / 100, p = c[2] / 100, h = d, v = Math.max(p, 0.01), y, g;
    return p *= 2, d *= p <= 1 ? p : 2 - p, h *= v <= 1 ? v : 2 - v, g = (p + d) / 2, y = p === 0 ? 2 * h / (v + h) : 2 * d / (p + d), [l, y * 100, g * 100];
  }, n.hsv.rgb = function(c) {
    var l = c[0] / 60, d = c[1] / 100, p = c[2] / 100, h = Math.floor(l) % 6, v = l - Math.floor(l), y = 255 * p * (1 - d), g = 255 * p * (1 - d * v), _ = 255 * p * (1 - d * (1 - v));
    switch (p *= 255, h) {
      case 0:
        return [p, _, y];
      case 1:
        return [g, p, y];
      case 2:
        return [y, p, _];
      case 3:
        return [y, g, p];
      case 4:
        return [_, y, p];
      case 5:
        return [p, y, g];
    }
  }, n.hsv.hsl = function(c) {
    var l = c[0], d = c[1] / 100, p = c[2] / 100, h = Math.max(p, 0.01), v, y, g;
    return g = (2 - d) * p, v = (2 - d) * h, y = d * h, y /= v <= 1 ? v : 2 - v, y = y || 0, g /= 2, [l, y * 100, g * 100];
  }, n.hwb.rgb = function(c) {
    var l = c[0] / 360, d = c[1] / 100, p = c[2] / 100, h = d + p, v, y, g, _;
    h > 1 && (d /= h, p /= h), v = Math.floor(6 * l), y = 1 - p, g = 6 * l - v, v & 1 && (g = 1 - g), _ = d + g * (y - d);
    var m, w, $;
    switch (v) {
      default:
      case 6:
      case 0:
        m = y, w = _, $ = d;
        break;
      case 1:
        m = _, w = y, $ = d;
        break;
      case 2:
        m = d, w = y, $ = _;
        break;
      case 3:
        m = d, w = _, $ = y;
        break;
      case 4:
        m = _, w = d, $ = y;
        break;
      case 5:
        m = y, w = d, $ = _;
        break;
    }
    return [m * 255, w * 255, $ * 255];
  }, n.cmyk.rgb = function(c) {
    var l = c[0] / 100, d = c[1] / 100, p = c[2] / 100, h = c[3] / 100, v, y, g;
    return v = 1 - Math.min(1, l * (1 - h) + h), y = 1 - Math.min(1, d * (1 - h) + h), g = 1 - Math.min(1, p * (1 - h) + h), [v * 255, y * 255, g * 255];
  }, n.xyz.rgb = function(c) {
    var l = c[0] / 100, d = c[1] / 100, p = c[2] / 100, h, v, y;
    return h = l * 3.2406 + d * -1.5372 + p * -0.4986, v = l * -0.9689 + d * 1.8758 + p * 0.0415, y = l * 0.0557 + d * -0.204 + p * 1.057, h = h > 31308e-7 ? 1.055 * Math.pow(h, 1 / 2.4) - 0.055 : h * 12.92, v = v > 31308e-7 ? 1.055 * Math.pow(v, 1 / 2.4) - 0.055 : v * 12.92, y = y > 31308e-7 ? 1.055 * Math.pow(y, 1 / 2.4) - 0.055 : y * 12.92, h = Math.min(Math.max(0, h), 1), v = Math.min(Math.max(0, v), 1), y = Math.min(Math.max(0, y), 1), [h * 255, v * 255, y * 255];
  }, n.xyz.lab = function(c) {
    var l = c[0], d = c[1], p = c[2], h, v, y;
    return l /= 95.047, d /= 100, p /= 108.883, l = l > 8856e-6 ? Math.pow(l, 1 / 3) : 7.787 * l + 16 / 116, d = d > 8856e-6 ? Math.pow(d, 1 / 3) : 7.787 * d + 16 / 116, p = p > 8856e-6 ? Math.pow(p, 1 / 3) : 7.787 * p + 16 / 116, h = 116 * d - 16, v = 500 * (l - d), y = 200 * (d - p), [h, v, y];
  }, n.lab.xyz = function(c) {
    var l = c[0], d = c[1], p = c[2], h, v, y;
    v = (l + 16) / 116, h = d / 500 + v, y = v - p / 200;
    var g = Math.pow(v, 3), _ = Math.pow(h, 3), m = Math.pow(y, 3);
    return v = g > 8856e-6 ? g : (v - 16 / 116) / 7.787, h = _ > 8856e-6 ? _ : (h - 16 / 116) / 7.787, y = m > 8856e-6 ? m : (y - 16 / 116) / 7.787, h *= 95.047, v *= 100, y *= 108.883, [h, v, y];
  }, n.lab.lch = function(c) {
    var l = c[0], d = c[1], p = c[2], h, v, y;
    return h = Math.atan2(p, d), v = h * 360 / 2 / Math.PI, v < 0 && (v += 360), y = Math.sqrt(d * d + p * p), [l, y, v];
  }, n.lch.lab = function(c) {
    var l = c[0], d = c[1], p = c[2], h, v, y;
    return y = p / 360 * 2 * Math.PI, h = d * Math.cos(y), v = d * Math.sin(y), [l, h, v];
  }, n.rgb.ansi16 = function(c) {
    var l = c[0], d = c[1], p = c[2], h = 1 in arguments ? arguments[1] : n.rgb.hsv(c)[2];
    if (h = Math.round(h / 50), h === 0)
      return 30;
    var v = 30 + (Math.round(p / 255) << 2 | Math.round(d / 255) << 1 | Math.round(l / 255));
    return h === 2 && (v += 60), v;
  }, n.hsv.ansi16 = function(c) {
    return n.rgb.ansi16(n.hsv.rgb(c), c[2]);
  }, n.rgb.ansi256 = function(c) {
    var l = c[0], d = c[1], p = c[2];
    if (l === d && d === p)
      return l < 8 ? 16 : l > 248 ? 231 : Math.round((l - 8) / 247 * 24) + 232;
    var h = 16 + 36 * Math.round(l / 255 * 5) + 6 * Math.round(d / 255 * 5) + Math.round(p / 255 * 5);
    return h;
  }, n.ansi16.rgb = function(c) {
    var l = c % 10;
    if (l === 0 || l === 7)
      return c > 50 && (l += 3.5), l = l / 10.5 * 255, [l, l, l];
    var d = (~~(c > 50) + 1) * 0.5, p = (l & 1) * d * 255, h = (l >> 1 & 1) * d * 255, v = (l >> 2 & 1) * d * 255;
    return [p, h, v];
  }, n.ansi256.rgb = function(c) {
    if (c >= 232) {
      var l = (c - 232) * 10 + 8;
      return [l, l, l];
    }
    c -= 16;
    var d, p = Math.floor(c / 36) / 5 * 255, h = Math.floor((d = c % 36) / 6) / 5 * 255, v = d % 6 / 5 * 255;
    return [p, h, v];
  }, n.rgb.hex = function(c) {
    var l = ((Math.round(c[0]) & 255) << 16) + ((Math.round(c[1]) & 255) << 8) + (Math.round(c[2]) & 255), d = l.toString(16).toUpperCase();
    return "000000".substring(d.length) + d;
  }, n.hex.rgb = function(c) {
    var l = c.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!l)
      return [0, 0, 0];
    var d = l[0];
    l[0].length === 3 && (d = d.split("").map(function(g) {
      return g + g;
    }).join(""));
    var p = parseInt(d, 16), h = p >> 16 & 255, v = p >> 8 & 255, y = p & 255;
    return [h, v, y];
  }, n.rgb.hcg = function(c) {
    var l = c[0] / 255, d = c[1] / 255, p = c[2] / 255, h = Math.max(Math.max(l, d), p), v = Math.min(Math.min(l, d), p), y = h - v, g, _;
    return y < 1 ? g = v / (1 - y) : g = 0, y <= 0 ? _ = 0 : h === l ? _ = (d - p) / y % 6 : h === d ? _ = 2 + (p - l) / y : _ = 4 + (l - d) / y + 4, _ /= 6, _ %= 1, [_ * 360, y * 100, g * 100];
  }, n.hsl.hcg = function(c) {
    var l = c[1] / 100, d = c[2] / 100, p = 1, h = 0;
    return d < 0.5 ? p = 2 * l * d : p = 2 * l * (1 - d), p < 1 && (h = (d - 0.5 * p) / (1 - p)), [c[0], p * 100, h * 100];
  }, n.hsv.hcg = function(c) {
    var l = c[1] / 100, d = c[2] / 100, p = l * d, h = 0;
    return p < 1 && (h = (d - p) / (1 - p)), [c[0], p * 100, h * 100];
  }, n.hcg.rgb = function(c) {
    var l = c[0] / 360, d = c[1] / 100, p = c[2] / 100;
    if (d === 0)
      return [p * 255, p * 255, p * 255];
    var h = [0, 0, 0], v = l % 1 * 6, y = v % 1, g = 1 - y, _ = 0;
    switch (Math.floor(v)) {
      case 0:
        h[0] = 1, h[1] = y, h[2] = 0;
        break;
      case 1:
        h[0] = g, h[1] = 1, h[2] = 0;
        break;
      case 2:
        h[0] = 0, h[1] = 1, h[2] = y;
        break;
      case 3:
        h[0] = 0, h[1] = g, h[2] = 1;
        break;
      case 4:
        h[0] = y, h[1] = 0, h[2] = 1;
        break;
      default:
        h[0] = 1, h[1] = 0, h[2] = g;
    }
    return _ = (1 - d) * p, [
      (d * h[0] + _) * 255,
      (d * h[1] + _) * 255,
      (d * h[2] + _) * 255
    ];
  }, n.hcg.hsv = function(c) {
    var l = c[1] / 100, d = c[2] / 100, p = l + d * (1 - l), h = 0;
    return p > 0 && (h = l / p), [c[0], h * 100, p * 100];
  }, n.hcg.hsl = function(c) {
    var l = c[1] / 100, d = c[2] / 100, p = d * (1 - l) + 0.5 * l, h = 0;
    return p > 0 && p < 0.5 ? h = l / (2 * p) : p >= 0.5 && p < 1 && (h = l / (2 * (1 - p))), [c[0], h * 100, p * 100];
  }, n.hcg.hwb = function(c) {
    var l = c[1] / 100, d = c[2] / 100, p = l + d * (1 - l);
    return [c[0], (p - l) * 100, (1 - p) * 100];
  }, n.hwb.hcg = function(c) {
    var l = c[1] / 100, d = c[2] / 100, p = 1 - d, h = p - l, v = 0;
    return h < 1 && (v = (p - h) / (1 - h)), [c[0], h * 100, v * 100];
  }, n.apple.rgb = function(c) {
    return [c[0] / 65535 * 255, c[1] / 65535 * 255, c[2] / 65535 * 255];
  }, n.rgb.apple = function(c) {
    return [c[0] / 255 * 65535, c[1] / 255 * 65535, c[2] / 255 * 65535];
  }, n.gray.rgb = function(c) {
    return [c[0] / 100 * 255, c[0] / 100 * 255, c[0] / 100 * 255];
  }, n.gray.hsl = n.gray.hsv = function(c) {
    return [0, 0, c[0]];
  }, n.gray.hwb = function(c) {
    return [0, 100, c[0]];
  }, n.gray.cmyk = function(c) {
    return [0, 0, 0, c[0]];
  }, n.gray.lab = function(c) {
    return [c[0], 0, 0];
  }, n.gray.hex = function(c) {
    var l = Math.round(c[0] / 100 * 255) & 255, d = (l << 16) + (l << 8) + l, p = d.toString(16).toUpperCase();
    return "000000".substring(p.length) + p;
  }, n.rgb.gray = function(c) {
    var l = (c[0] + c[1] + c[2]) / 3;
    return [l / 255 * 100];
  }, Rh.exports;
}
var Ih, fw;
function J8() {
  if (fw)
    return Ih;
  fw = 1;
  var e = rP();
  function t() {
    for (var s = {}, a = Object.keys(e), u = a.length, c = 0; c < u; c++)
      s[a[c]] = {
        // http://jsperf.com/1-vs-infinity
        // micro-opt, but this is simple.
        distance: -1,
        parent: null
      };
    return s;
  }
  function r(s) {
    var a = t(), u = [s];
    for (a[s].distance = 0; u.length; )
      for (var c = u.pop(), l = Object.keys(e[c]), d = l.length, p = 0; p < d; p++) {
        var h = l[p], v = a[h];
        v.distance === -1 && (v.distance = a[c].distance + 1, v.parent = c, u.unshift(h));
      }
    return a;
  }
  function n(s, a) {
    return function(u) {
      return a(s(u));
    };
  }
  function i(s, a) {
    for (var u = [a[s].parent, s], c = e[a[s].parent][s], l = a[s].parent; a[l].parent; )
      u.unshift(a[l].parent), c = n(e[a[l].parent][l], c), l = a[l].parent;
    return c.conversion = u, c;
  }
  return Ih = function(s) {
    for (var a = r(s), u = {}, c = Object.keys(a), l = c.length, d = 0; d < l; d++) {
      var p = c[d], h = a[p];
      h.parent !== null && (u[p] = i(p, a));
    }
    return u;
  }, Ih;
}
var jh, dw;
function X8() {
  if (dw)
    return jh;
  dw = 1;
  var e = rP(), t = J8(), r = {}, n = Object.keys(e);
  function i(a) {
    var u = function(c) {
      return c == null ? c : (arguments.length > 1 && (c = Array.prototype.slice.call(arguments)), a(c));
    };
    return "conversion" in a && (u.conversion = a.conversion), u;
  }
  function s(a) {
    var u = function(c) {
      if (c == null)
        return c;
      arguments.length > 1 && (c = Array.prototype.slice.call(arguments));
      var l = a(c);
      if (typeof l == "object")
        for (var d = l.length, p = 0; p < d; p++)
          l[p] = Math.round(l[p]);
      return l;
    };
    return "conversion" in a && (u.conversion = a.conversion), u;
  }
  return n.forEach(function(a) {
    r[a] = {}, Object.defineProperty(r[a], "channels", { value: e[a].channels }), Object.defineProperty(r[a], "labels", { value: e[a].labels });
    var u = t(a), c = Object.keys(u);
    c.forEach(function(l) {
      var d = u[l];
      r[a][l] = s(d), r[a][l].raw = i(d);
    });
  }), jh = r, jh;
}
Il.exports;
var pw;
function Q8() {
  return pw || (pw = 1, function(e) {
    const t = X8(), r = (a, u) => function() {
      return `\x1B[${a.apply(t, arguments) + u}m`;
    }, n = (a, u) => function() {
      const c = a.apply(t, arguments);
      return `\x1B[${38 + u};5;${c}m`;
    }, i = (a, u) => function() {
      const c = a.apply(t, arguments);
      return `\x1B[${38 + u};2;${c[0]};${c[1]};${c[2]}m`;
    };
    function s() {
      const a = /* @__PURE__ */ new Map(), u = {
        modifier: {
          reset: [0, 0],
          // 21 isn't widely supported and 22 does the same thing
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          gray: [90, 39],
          // Bright color
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          // Bright color
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      u.color.grey = u.color.gray;
      for (const d of Object.keys(u)) {
        const p = u[d];
        for (const h of Object.keys(p)) {
          const v = p[h];
          u[h] = {
            open: `\x1B[${v[0]}m`,
            close: `\x1B[${v[1]}m`
          }, p[h] = u[h], a.set(v[0], v[1]);
        }
        Object.defineProperty(u, d, {
          value: p,
          enumerable: !1
        }), Object.defineProperty(u, "codes", {
          value: a,
          enumerable: !1
        });
      }
      const c = (d) => d, l = (d, p, h) => [d, p, h];
      u.color.close = "\x1B[39m", u.bgColor.close = "\x1B[49m", u.color.ansi = {
        ansi: r(c, 0)
      }, u.color.ansi256 = {
        ansi256: n(c, 0)
      }, u.color.ansi16m = {
        rgb: i(l, 0)
      }, u.bgColor.ansi = {
        ansi: r(c, 10)
      }, u.bgColor.ansi256 = {
        ansi256: n(c, 10)
      }, u.bgColor.ansi16m = {
        rgb: i(l, 10)
      };
      for (let d of Object.keys(t)) {
        if (typeof t[d] != "object")
          continue;
        const p = t[d];
        d === "ansi16" && (d = "ansi"), "ansi16" in p && (u.color.ansi[d] = r(p.ansi16, 0), u.bgColor.ansi[d] = r(p.ansi16, 10)), "ansi256" in p && (u.color.ansi256[d] = n(p.ansi256, 0), u.bgColor.ansi256[d] = n(p.ansi256, 10)), "rgb" in p && (u.color.ansi16m[d] = i(p.rgb, 0), u.bgColor.ansi16m[d] = i(p.rgb, 10));
      }
      return u;
    }
    Object.defineProperty(e, "exports", {
      enumerable: !0,
      get: s
    });
  }(Il)), Il.exports;
}
var kh, hw;
function eF() {
  return hw || (hw = 1, kh = {
    stdout: !1,
    stderr: !1
  }), kh;
}
var Mh, mw;
function tF() {
  if (mw)
    return Mh;
  mw = 1;
  const e = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi, t = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, r = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, n = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi, i = /* @__PURE__ */ new Map([
    ["n", `
`],
    ["r", "\r"],
    ["t", "	"],
    ["b", "\b"],
    ["f", "\f"],
    ["v", "\v"],
    ["0", "\0"],
    ["\\", "\\"],
    ["e", "\x1B"],
    ["a", "\x07"]
  ]);
  function s(l) {
    return l[0] === "u" && l.length === 5 || l[0] === "x" && l.length === 3 ? String.fromCharCode(parseInt(l.slice(1), 16)) : i.get(l) || l;
  }
  function a(l, d) {
    const p = [], h = d.trim().split(/\s*,\s*/g);
    let v;
    for (const y of h)
      if (!isNaN(y))
        p.push(Number(y));
      else if (v = y.match(r))
        p.push(v[2].replace(n, (g, _, m) => _ ? s(_) : m));
      else
        throw new Error(`Invalid Chalk template style argument: ${y} (in style '${l}')`);
    return p;
  }
  function u(l) {
    t.lastIndex = 0;
    const d = [];
    let p;
    for (; (p = t.exec(l)) !== null; ) {
      const h = p[1];
      if (p[2]) {
        const v = a(h, p[2]);
        d.push([h].concat(v));
      } else
        d.push([h]);
    }
    return d;
  }
  function c(l, d) {
    const p = {};
    for (const v of d)
      for (const y of v.styles)
        p[y[0]] = v.inverse ? null : y.slice(1);
    let h = l;
    for (const v of Object.keys(p))
      if (Array.isArray(p[v])) {
        if (!(v in h))
          throw new Error(`Unknown Chalk style: ${v}`);
        p[v].length > 0 ? h = h[v].apply(h, p[v]) : h = h[v];
      }
    return h;
  }
  return Mh = (l, d) => {
    const p = [], h = [];
    let v = [];
    if (d.replace(e, (y, g, _, m, w, $) => {
      if (g)
        v.push(s(g));
      else if (m) {
        const E = v.join("");
        v = [], h.push(p.length === 0 ? E : c(l, p)(E)), p.push({ inverse: _, styles: u(m) });
      } else if (w) {
        if (p.length === 0)
          throw new Error("Found extraneous } in Chalk template literal");
        h.push(c(l, p)(v.join(""))), v = [], p.pop();
      } else
        v.push($);
    }), h.push(v.join("")), p.length > 0) {
      const y = `Chalk template literal is missing ${p.length} closing bracket${p.length === 1 ? "" : "s"} (\`}\`)`;
      throw new Error(y);
    }
    return h.join("");
  }, Mh;
}
var yw;
function nP() {
  return yw || (yw = 1, function(e) {
    const t = K8(), r = Q8(), n = eF().stdout, i = tF(), s = Me.process.platform === "win32" && !(Me.process.env.TERM || "").toLowerCase().startsWith("xterm"), a = ["ansi", "ansi", "ansi256", "ansi16m"], u = /* @__PURE__ */ new Set(["gray"]), c = /* @__PURE__ */ Object.create(null);
    function l(g, _) {
      _ = _ || {};
      const m = n ? n.level : 0;
      g.level = _.level === void 0 ? m : _.level, g.enabled = "enabled" in _ ? _.enabled : g.level > 0;
    }
    function d(g) {
      if (!this || !(this instanceof d) || this.template) {
        const _ = {};
        return l(_, g), _.template = function() {
          const m = [].slice.call(arguments);
          return y.apply(null, [_.template].concat(m));
        }, Object.setPrototypeOf(_, d.prototype), Object.setPrototypeOf(_.template, _), _.template.constructor = d, _.template;
      }
      l(this, g);
    }
    s && (r.blue.open = "\x1B[94m");
    for (const g of Object.keys(r))
      r[g].closeRe = new RegExp(t(r[g].close), "g"), c[g] = {
        get() {
          const _ = r[g];
          return h.call(this, this._styles ? this._styles.concat(_) : [_], this._empty, g);
        }
      };
    c.visible = {
      get() {
        return h.call(this, this._styles || [], !0, "visible");
      }
    }, r.color.closeRe = new RegExp(t(r.color.close), "g");
    for (const g of Object.keys(r.color.ansi))
      u.has(g) || (c[g] = {
        get() {
          const _ = this.level;
          return function() {
            const w = {
              open: r.color[a[_]][g].apply(null, arguments),
              close: r.color.close,
              closeRe: r.color.closeRe
            };
            return h.call(this, this._styles ? this._styles.concat(w) : [w], this._empty, g);
          };
        }
      });
    r.bgColor.closeRe = new RegExp(t(r.bgColor.close), "g");
    for (const g of Object.keys(r.bgColor.ansi)) {
      if (u.has(g))
        continue;
      const _ = "bg" + g[0].toUpperCase() + g.slice(1);
      c[_] = {
        get() {
          const m = this.level;
          return function() {
            const $ = {
              open: r.bgColor[a[m]][g].apply(null, arguments),
              close: r.bgColor.close,
              closeRe: r.bgColor.closeRe
            };
            return h.call(this, this._styles ? this._styles.concat($) : [$], this._empty, g);
          };
        }
      };
    }
    const p = Object.defineProperties(() => {
    }, c);
    function h(g, _, m) {
      const w = function() {
        return v.apply(w, arguments);
      };
      w._styles = g, w._empty = _;
      const $ = this;
      return Object.defineProperty(w, "level", {
        enumerable: !0,
        get() {
          return $.level;
        },
        set(E) {
          $.level = E;
        }
      }), Object.defineProperty(w, "enabled", {
        enumerable: !0,
        get() {
          return $.enabled;
        },
        set(E) {
          $.enabled = E;
        }
      }), w.hasGrey = this.hasGrey || m === "gray" || m === "grey", w.__proto__ = p, w;
    }
    function v() {
      const g = arguments, _ = g.length;
      let m = String(arguments[0]);
      if (_ === 0)
        return "";
      if (_ > 1)
        for (let $ = 1; $ < _; $++)
          m += " " + g[$];
      if (!this.enabled || this.level <= 0 || !m)
        return this._empty ? "" : m;
      const w = r.dim.open;
      s && this.hasGrey && (r.dim.open = "");
      for (const $ of this._styles.slice().reverse())
        m = $.open + m.replace($.closeRe, $.open) + $.close, m = m.replace(/\r?\n/g, `${$.close}$&${$.open}`);
      return r.dim.open = w, m;
    }
    function y(g, _) {
      if (!Array.isArray(_))
        return [].slice.call(arguments, 1).join(" ");
      const m = [].slice.call(arguments, 2), w = [_.raw[0]];
      for (let $ = 1; $ < _.length; $++)
        w.push(String(m[$ - 1]).replace(/[{}\\]/g, "\\$&")), w.push(String(_.raw[$]));
      return i(g, w.join(""));
    }
    Object.defineProperties(d.prototype, c), e.exports = d(), e.exports.supportsColor = n, e.exports.default = e.exports;
  }(Ah)), Ah.exports;
}
var gw;
function rF() {
  if (gw)
    return Ra;
  gw = 1, Object.defineProperty(Ra, "__esModule", {
    value: !0
  }), Ra.default = y, Ra.shouldHighlight = p;
  var e = z8(), t = G8(), r = i(nP(), !0);
  function n(g) {
    if (typeof WeakMap != "function")
      return null;
    var _ = /* @__PURE__ */ new WeakMap(), m = /* @__PURE__ */ new WeakMap();
    return (n = function(w) {
      return w ? m : _;
    })(g);
  }
  function i(g, _) {
    if (!_ && g && g.__esModule)
      return g;
    if (g === null || typeof g != "object" && typeof g != "function")
      return { default: g };
    var m = n(_);
    if (m && m.has(g))
      return m.get(g);
    var w = {}, $ = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var E in g)
      if (E !== "default" && Object.prototype.hasOwnProperty.call(g, E)) {
        var A = $ ? Object.getOwnPropertyDescriptor(g, E) : null;
        A && (A.get || A.set) ? Object.defineProperty(w, E, A) : w[E] = g[E];
      }
    return w.default = g, m && m.set(g, w), w;
  }
  const s = /* @__PURE__ */ new Set(["as", "async", "from", "get", "of", "set"]);
  function a(g) {
    return {
      keyword: g.cyan,
      capitalized: g.yellow,
      jsxIdentifier: g.yellow,
      punctuator: g.yellow,
      number: g.magenta,
      string: g.green,
      regex: g.magenta,
      comment: g.grey,
      invalid: g.white.bgRed.bold
    };
  }
  const u = /\r\n|[\n\r\u2028\u2029]/, c = /^[()[\]{}]$/;
  let l;
  {
    const g = /^[a-z][\w-]*$/i, _ = function(m, w, $) {
      if (m.type === "name") {
        if ((0, t.isKeyword)(m.value) || (0, t.isStrictReservedWord)(m.value, !0) || s.has(m.value))
          return "keyword";
        if (g.test(m.value) && ($[w - 1] === "<" || $.slice(w - 2, w) == "</"))
          return "jsxIdentifier";
        if (m.value[0] !== m.value[0].toLowerCase())
          return "capitalized";
      }
      return m.type === "punctuator" && c.test(m.value) ? "bracket" : m.type === "invalid" && (m.value === "@" || m.value === "#") ? "punctuator" : m.type;
    };
    l = function* (m) {
      let w;
      for (; w = e.default.exec(m); ) {
        const $ = e.matchToToken(w);
        yield {
          type: _($, w.index, m),
          value: $.value
        };
      }
    };
  }
  function d(g, _) {
    let m = "";
    for (const {
      type: w,
      value: $
    } of l(_)) {
      const E = g[w];
      E ? m += $.split(u).map((A) => E(A)).join(`
`) : m += $;
    }
    return m;
  }
  function p(g) {
    return r.default.level > 0 || g.forceColor;
  }
  let h;
  function v(g) {
    if (g) {
      var _;
      return (_ = h) != null || (h = new r.default.constructor({
        enabled: !0,
        level: 1
      })), h;
    }
    return r.default;
  }
  Ra.getChalk = (g) => v(g.forceColor);
  function y(g, _ = {}) {
    if (g !== "" && p(_)) {
      const m = a(v(_.forceColor));
      return d(m, g);
    } else
      return g;
  }
  return Ra;
}
var vw;
function nF() {
  if (vw)
    return Wo;
  vw = 1, Object.defineProperty(Wo, "__esModule", {
    value: !0
  }), Wo.codeFrameColumns = d, Wo.default = p;
  var e = rF(), t = n(nP(), !0);
  function r(h) {
    if (typeof WeakMap != "function")
      return null;
    var v = /* @__PURE__ */ new WeakMap(), y = /* @__PURE__ */ new WeakMap();
    return (r = function(g) {
      return g ? y : v;
    })(h);
  }
  function n(h, v) {
    if (!v && h && h.__esModule)
      return h;
    if (h === null || typeof h != "object" && typeof h != "function")
      return { default: h };
    var y = r(v);
    if (y && y.has(h))
      return y.get(h);
    var g = {}, _ = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var m in h)
      if (m !== "default" && Object.prototype.hasOwnProperty.call(h, m)) {
        var w = _ ? Object.getOwnPropertyDescriptor(h, m) : null;
        w && (w.get || w.set) ? Object.defineProperty(g, m, w) : g[m] = h[m];
      }
    return g.default = h, y && y.set(h, g), g;
  }
  let i;
  function s(h) {
    if (h) {
      var v;
      return (v = i) != null || (i = new t.default.constructor({
        enabled: !0,
        level: 1
      })), i;
    }
    return t.default;
  }
  let a = !1;
  function u(h) {
    return {
      gutter: h.grey,
      marker: h.red.bold,
      message: h.red.bold
    };
  }
  const c = /\r\n|[\n\r\u2028\u2029]/;
  function l(h, v, y) {
    const g = Object.assign({
      column: 0,
      line: -1
    }, h.start), _ = Object.assign({}, g, h.end), {
      linesAbove: m = 2,
      linesBelow: w = 3
    } = y || {}, $ = g.line, E = g.column, A = _.line, R = _.column;
    let I = Math.max($ - (m + 1), 0), D = Math.min(v.length, A + w);
    $ === -1 && (I = 0), A === -1 && (D = v.length);
    const J = A - $, ae = {};
    if (J)
      for (let ye = 0; ye <= J; ye++) {
        const xe = ye + $;
        if (!E)
          ae[xe] = !0;
        else if (ye === 0) {
          const je = v[xe - 1].length;
          ae[xe] = [E, je - E + 1];
        } else if (ye === J)
          ae[xe] = [0, R];
        else {
          const je = v[xe - ye].length;
          ae[xe] = [0, je];
        }
      }
    else
      E === R ? E ? ae[$] = [E, 0] : ae[$] = !0 : ae[$] = [E, R - E];
    return {
      start: I,
      end: D,
      markerLines: ae
    };
  }
  function d(h, v, y = {}) {
    const g = (y.highlightCode || y.forceColor) && (0, e.shouldHighlight)(y), _ = s(y.forceColor), m = u(_), w = (ye, xe) => g ? ye(xe) : xe, $ = h.split(c), {
      start: E,
      end: A,
      markerLines: R
    } = l(v, $, y), I = v.start && typeof v.start.column == "number", D = String(A).length;
    let ae = (g ? (0, e.default)(h, y) : h).split(c, A).slice(E, A).map((ye, xe) => {
      const je = E + 1 + xe, fe = ` ${` ${je}`.slice(-D)} |`, le = R[je], $e = !R[je + 1];
      if (le) {
        let Ae = "";
        if (Array.isArray(le)) {
          const _e = ye.slice(0, Math.max(le[0] - 1, 0)).replace(/[^\t]/g, " "), ie = le[1] || 1;
          Ae = [`
 `, w(m.gutter, fe.replace(/\d/g, " ")), " ", _e, w(m.marker, "^").repeat(ie)].join(""), $e && y.message && (Ae += " " + w(m.message, y.message));
        }
        return [w(m.marker, ">"), w(m.gutter, fe), ye.length > 0 ? ` ${ye}` : "", Ae].join("");
      } else
        return ` ${w(m.gutter, fe)}${ye.length > 0 ? ` ${ye}` : ""}`;
    }).join(`
`);
    return y.message && !I && (ae = `${" ".repeat(D + 1)}${y.message}
${ae}`), g ? _.reset(ae) : ae;
  }
  function p(h, v, y, g = {}) {
    if (!a) {
      a = !0;
      const m = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
      if (Me.process.emitWarning)
        Me.process.emitWarning(m, "DeprecationWarning");
      else {
        const w = new Error(m);
        w.name = "DeprecationWarning", console.warn(new Error(m));
      }
    }
    return y = Math.max(y, 0), d(h, {
      start: {
        column: y,
        line: v
      }
    }, g);
  }
  return Wo;
}
var jl = { exports: {} }, Nh, bw;
function iF() {
  return bw || (bw = 1, Nh = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  }), Nh;
}
var Dh, _w;
function iP() {
  if (_w)
    return Dh;
  _w = 1;
  const e = iF(), t = {};
  for (const i of Object.keys(e))
    t[e[i]] = i;
  const r = {
    rgb: { channels: 3, labels: "rgb" },
    hsl: { channels: 3, labels: "hsl" },
    hsv: { channels: 3, labels: "hsv" },
    hwb: { channels: 3, labels: "hwb" },
    cmyk: { channels: 4, labels: "cmyk" },
    xyz: { channels: 3, labels: "xyz" },
    lab: { channels: 3, labels: "lab" },
    lch: { channels: 3, labels: "lch" },
    hex: { channels: 1, labels: ["hex"] },
    keyword: { channels: 1, labels: ["keyword"] },
    ansi16: { channels: 1, labels: ["ansi16"] },
    ansi256: { channels: 1, labels: ["ansi256"] },
    hcg: { channels: 3, labels: ["h", "c", "g"] },
    apple: { channels: 3, labels: ["r16", "g16", "b16"] },
    gray: { channels: 1, labels: ["gray"] }
  };
  Dh = r;
  for (const i of Object.keys(r)) {
    if (!("channels" in r[i]))
      throw new Error("missing channels property: " + i);
    if (!("labels" in r[i]))
      throw new Error("missing channel labels property: " + i);
    if (r[i].labels.length !== r[i].channels)
      throw new Error("channel and label counts mismatch: " + i);
    const { channels: s, labels: a } = r[i];
    delete r[i].channels, delete r[i].labels, Object.defineProperty(r[i], "channels", { value: s }), Object.defineProperty(r[i], "labels", { value: a });
  }
  r.rgb.hsl = function(i) {
    const s = i[0] / 255, a = i[1] / 255, u = i[2] / 255, c = Math.min(s, a, u), l = Math.max(s, a, u), d = l - c;
    let p, h;
    l === c ? p = 0 : s === l ? p = (a - u) / d : a === l ? p = 2 + (u - s) / d : u === l && (p = 4 + (s - a) / d), p = Math.min(p * 60, 360), p < 0 && (p += 360);
    const v = (c + l) / 2;
    return l === c ? h = 0 : v <= 0.5 ? h = d / (l + c) : h = d / (2 - l - c), [p, h * 100, v * 100];
  }, r.rgb.hsv = function(i) {
    let s, a, u, c, l;
    const d = i[0] / 255, p = i[1] / 255, h = i[2] / 255, v = Math.max(d, p, h), y = v - Math.min(d, p, h), g = function(_) {
      return (v - _) / 6 / y + 1 / 2;
    };
    return y === 0 ? (c = 0, l = 0) : (l = y / v, s = g(d), a = g(p), u = g(h), d === v ? c = u - a : p === v ? c = 1 / 3 + s - u : h === v && (c = 2 / 3 + a - s), c < 0 ? c += 1 : c > 1 && (c -= 1)), [
      c * 360,
      l * 100,
      v * 100
    ];
  }, r.rgb.hwb = function(i) {
    const s = i[0], a = i[1];
    let u = i[2];
    const c = r.rgb.hsl(i)[0], l = 1 / 255 * Math.min(s, Math.min(a, u));
    return u = 1 - 1 / 255 * Math.max(s, Math.max(a, u)), [c, l * 100, u * 100];
  }, r.rgb.cmyk = function(i) {
    const s = i[0] / 255, a = i[1] / 255, u = i[2] / 255, c = Math.min(1 - s, 1 - a, 1 - u), l = (1 - s - c) / (1 - c) || 0, d = (1 - a - c) / (1 - c) || 0, p = (1 - u - c) / (1 - c) || 0;
    return [l * 100, d * 100, p * 100, c * 100];
  };
  function n(i, s) {
    return (i[0] - s[0]) ** 2 + (i[1] - s[1]) ** 2 + (i[2] - s[2]) ** 2;
  }
  return r.rgb.keyword = function(i) {
    const s = t[i];
    if (s)
      return s;
    let a = 1 / 0, u;
    for (const c of Object.keys(e)) {
      const l = e[c], d = n(i, l);
      d < a && (a = d, u = c);
    }
    return u;
  }, r.keyword.rgb = function(i) {
    return e[i];
  }, r.rgb.xyz = function(i) {
    let s = i[0] / 255, a = i[1] / 255, u = i[2] / 255;
    s = s > 0.04045 ? ((s + 0.055) / 1.055) ** 2.4 : s / 12.92, a = a > 0.04045 ? ((a + 0.055) / 1.055) ** 2.4 : a / 12.92, u = u > 0.04045 ? ((u + 0.055) / 1.055) ** 2.4 : u / 12.92;
    const c = s * 0.4124 + a * 0.3576 + u * 0.1805, l = s * 0.2126 + a * 0.7152 + u * 0.0722, d = s * 0.0193 + a * 0.1192 + u * 0.9505;
    return [c * 100, l * 100, d * 100];
  }, r.rgb.lab = function(i) {
    const s = r.rgb.xyz(i);
    let a = s[0], u = s[1], c = s[2];
    a /= 95.047, u /= 100, c /= 108.883, a = a > 8856e-6 ? a ** (1 / 3) : 7.787 * a + 16 / 116, u = u > 8856e-6 ? u ** (1 / 3) : 7.787 * u + 16 / 116, c = c > 8856e-6 ? c ** (1 / 3) : 7.787 * c + 16 / 116;
    const l = 116 * u - 16, d = 500 * (a - u), p = 200 * (u - c);
    return [l, d, p];
  }, r.hsl.rgb = function(i) {
    const s = i[0] / 360, a = i[1] / 100, u = i[2] / 100;
    let c, l, d;
    if (a === 0)
      return d = u * 255, [d, d, d];
    u < 0.5 ? c = u * (1 + a) : c = u + a - u * a;
    const p = 2 * u - c, h = [0, 0, 0];
    for (let v = 0; v < 3; v++)
      l = s + 1 / 3 * -(v - 1), l < 0 && l++, l > 1 && l--, 6 * l < 1 ? d = p + (c - p) * 6 * l : 2 * l < 1 ? d = c : 3 * l < 2 ? d = p + (c - p) * (2 / 3 - l) * 6 : d = p, h[v] = d * 255;
    return h;
  }, r.hsl.hsv = function(i) {
    const s = i[0];
    let a = i[1] / 100, u = i[2] / 100, c = a;
    const l = Math.max(u, 0.01);
    u *= 2, a *= u <= 1 ? u : 2 - u, c *= l <= 1 ? l : 2 - l;
    const d = (u + a) / 2, p = u === 0 ? 2 * c / (l + c) : 2 * a / (u + a);
    return [s, p * 100, d * 100];
  }, r.hsv.rgb = function(i) {
    const s = i[0] / 60, a = i[1] / 100;
    let u = i[2] / 100;
    const c = Math.floor(s) % 6, l = s - Math.floor(s), d = 255 * u * (1 - a), p = 255 * u * (1 - a * l), h = 255 * u * (1 - a * (1 - l));
    switch (u *= 255, c) {
      case 0:
        return [u, h, d];
      case 1:
        return [p, u, d];
      case 2:
        return [d, u, h];
      case 3:
        return [d, p, u];
      case 4:
        return [h, d, u];
      case 5:
        return [u, d, p];
    }
  }, r.hsv.hsl = function(i) {
    const s = i[0], a = i[1] / 100, u = i[2] / 100, c = Math.max(u, 0.01);
    let l, d;
    d = (2 - a) * u;
    const p = (2 - a) * c;
    return l = a * c, l /= p <= 1 ? p : 2 - p, l = l || 0, d /= 2, [s, l * 100, d * 100];
  }, r.hwb.rgb = function(i) {
    const s = i[0] / 360;
    let a = i[1] / 100, u = i[2] / 100;
    const c = a + u;
    let l;
    c > 1 && (a /= c, u /= c);
    const d = Math.floor(6 * s), p = 1 - u;
    l = 6 * s - d, d & 1 && (l = 1 - l);
    const h = a + l * (p - a);
    let v, y, g;
    switch (d) {
      default:
      case 6:
      case 0:
        v = p, y = h, g = a;
        break;
      case 1:
        v = h, y = p, g = a;
        break;
      case 2:
        v = a, y = p, g = h;
        break;
      case 3:
        v = a, y = h, g = p;
        break;
      case 4:
        v = h, y = a, g = p;
        break;
      case 5:
        v = p, y = a, g = h;
        break;
    }
    return [v * 255, y * 255, g * 255];
  }, r.cmyk.rgb = function(i) {
    const s = i[0] / 100, a = i[1] / 100, u = i[2] / 100, c = i[3] / 100, l = 1 - Math.min(1, s * (1 - c) + c), d = 1 - Math.min(1, a * (1 - c) + c), p = 1 - Math.min(1, u * (1 - c) + c);
    return [l * 255, d * 255, p * 255];
  }, r.xyz.rgb = function(i) {
    const s = i[0] / 100, a = i[1] / 100, u = i[2] / 100;
    let c, l, d;
    return c = s * 3.2406 + a * -1.5372 + u * -0.4986, l = s * -0.9689 + a * 1.8758 + u * 0.0415, d = s * 0.0557 + a * -0.204 + u * 1.057, c = c > 31308e-7 ? 1.055 * c ** (1 / 2.4) - 0.055 : c * 12.92, l = l > 31308e-7 ? 1.055 * l ** (1 / 2.4) - 0.055 : l * 12.92, d = d > 31308e-7 ? 1.055 * d ** (1 / 2.4) - 0.055 : d * 12.92, c = Math.min(Math.max(0, c), 1), l = Math.min(Math.max(0, l), 1), d = Math.min(Math.max(0, d), 1), [c * 255, l * 255, d * 255];
  }, r.xyz.lab = function(i) {
    let s = i[0], a = i[1], u = i[2];
    s /= 95.047, a /= 100, u /= 108.883, s = s > 8856e-6 ? s ** (1 / 3) : 7.787 * s + 16 / 116, a = a > 8856e-6 ? a ** (1 / 3) : 7.787 * a + 16 / 116, u = u > 8856e-6 ? u ** (1 / 3) : 7.787 * u + 16 / 116;
    const c = 116 * a - 16, l = 500 * (s - a), d = 200 * (a - u);
    return [c, l, d];
  }, r.lab.xyz = function(i) {
    const s = i[0], a = i[1], u = i[2];
    let c, l, d;
    l = (s + 16) / 116, c = a / 500 + l, d = l - u / 200;
    const p = l ** 3, h = c ** 3, v = d ** 3;
    return l = p > 8856e-6 ? p : (l - 16 / 116) / 7.787, c = h > 8856e-6 ? h : (c - 16 / 116) / 7.787, d = v > 8856e-6 ? v : (d - 16 / 116) / 7.787, c *= 95.047, l *= 100, d *= 108.883, [c, l, d];
  }, r.lab.lch = function(i) {
    const s = i[0], a = i[1], u = i[2];
    let c;
    c = Math.atan2(u, a) * 360 / 2 / Math.PI, c < 0 && (c += 360);
    const d = Math.sqrt(a * a + u * u);
    return [s, d, c];
  }, r.lch.lab = function(i) {
    const s = i[0], a = i[1], c = i[2] / 360 * 2 * Math.PI, l = a * Math.cos(c), d = a * Math.sin(c);
    return [s, l, d];
  }, r.rgb.ansi16 = function(i, s = null) {
    const [a, u, c] = i;
    let l = s === null ? r.rgb.hsv(i)[2] : s;
    if (l = Math.round(l / 50), l === 0)
      return 30;
    let d = 30 + (Math.round(c / 255) << 2 | Math.round(u / 255) << 1 | Math.round(a / 255));
    return l === 2 && (d += 60), d;
  }, r.hsv.ansi16 = function(i) {
    return r.rgb.ansi16(r.hsv.rgb(i), i[2]);
  }, r.rgb.ansi256 = function(i) {
    const s = i[0], a = i[1], u = i[2];
    return s === a && a === u ? s < 8 ? 16 : s > 248 ? 231 : Math.round((s - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(s / 255 * 5) + 6 * Math.round(a / 255 * 5) + Math.round(u / 255 * 5);
  }, r.ansi16.rgb = function(i) {
    let s = i % 10;
    if (s === 0 || s === 7)
      return i > 50 && (s += 3.5), s = s / 10.5 * 255, [s, s, s];
    const a = (~~(i > 50) + 1) * 0.5, u = (s & 1) * a * 255, c = (s >> 1 & 1) * a * 255, l = (s >> 2 & 1) * a * 255;
    return [u, c, l];
  }, r.ansi256.rgb = function(i) {
    if (i >= 232) {
      const l = (i - 232) * 10 + 8;
      return [l, l, l];
    }
    i -= 16;
    let s;
    const a = Math.floor(i / 36) / 5 * 255, u = Math.floor((s = i % 36) / 6) / 5 * 255, c = s % 6 / 5 * 255;
    return [a, u, c];
  }, r.rgb.hex = function(i) {
    const a = (((Math.round(i[0]) & 255) << 16) + ((Math.round(i[1]) & 255) << 8) + (Math.round(i[2]) & 255)).toString(16).toUpperCase();
    return "000000".substring(a.length) + a;
  }, r.hex.rgb = function(i) {
    const s = i.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!s)
      return [0, 0, 0];
    let a = s[0];
    s[0].length === 3 && (a = a.split("").map((p) => p + p).join(""));
    const u = parseInt(a, 16), c = u >> 16 & 255, l = u >> 8 & 255, d = u & 255;
    return [c, l, d];
  }, r.rgb.hcg = function(i) {
    const s = i[0] / 255, a = i[1] / 255, u = i[2] / 255, c = Math.max(Math.max(s, a), u), l = Math.min(Math.min(s, a), u), d = c - l;
    let p, h;
    return d < 1 ? p = l / (1 - d) : p = 0, d <= 0 ? h = 0 : c === s ? h = (a - u) / d % 6 : c === a ? h = 2 + (u - s) / d : h = 4 + (s - a) / d, h /= 6, h %= 1, [h * 360, d * 100, p * 100];
  }, r.hsl.hcg = function(i) {
    const s = i[1] / 100, a = i[2] / 100, u = a < 0.5 ? 2 * s * a : 2 * s * (1 - a);
    let c = 0;
    return u < 1 && (c = (a - 0.5 * u) / (1 - u)), [i[0], u * 100, c * 100];
  }, r.hsv.hcg = function(i) {
    const s = i[1] / 100, a = i[2] / 100, u = s * a;
    let c = 0;
    return u < 1 && (c = (a - u) / (1 - u)), [i[0], u * 100, c * 100];
  }, r.hcg.rgb = function(i) {
    const s = i[0] / 360, a = i[1] / 100, u = i[2] / 100;
    if (a === 0)
      return [u * 255, u * 255, u * 255];
    const c = [0, 0, 0], l = s % 1 * 6, d = l % 1, p = 1 - d;
    let h = 0;
    switch (Math.floor(l)) {
      case 0:
        c[0] = 1, c[1] = d, c[2] = 0;
        break;
      case 1:
        c[0] = p, c[1] = 1, c[2] = 0;
        break;
      case 2:
        c[0] = 0, c[1] = 1, c[2] = d;
        break;
      case 3:
        c[0] = 0, c[1] = p, c[2] = 1;
        break;
      case 4:
        c[0] = d, c[1] = 0, c[2] = 1;
        break;
      default:
        c[0] = 1, c[1] = 0, c[2] = p;
    }
    return h = (1 - a) * u, [
      (a * c[0] + h) * 255,
      (a * c[1] + h) * 255,
      (a * c[2] + h) * 255
    ];
  }, r.hcg.hsv = function(i) {
    const s = i[1] / 100, a = i[2] / 100, u = s + a * (1 - s);
    let c = 0;
    return u > 0 && (c = s / u), [i[0], c * 100, u * 100];
  }, r.hcg.hsl = function(i) {
    const s = i[1] / 100, u = i[2] / 100 * (1 - s) + 0.5 * s;
    let c = 0;
    return u > 0 && u < 0.5 ? c = s / (2 * u) : u >= 0.5 && u < 1 && (c = s / (2 * (1 - u))), [i[0], c * 100, u * 100];
  }, r.hcg.hwb = function(i) {
    const s = i[1] / 100, a = i[2] / 100, u = s + a * (1 - s);
    return [i[0], (u - s) * 100, (1 - u) * 100];
  }, r.hwb.hcg = function(i) {
    const s = i[1] / 100, u = 1 - i[2] / 100, c = u - s;
    let l = 0;
    return c < 1 && (l = (u - c) / (1 - c)), [i[0], c * 100, l * 100];
  }, r.apple.rgb = function(i) {
    return [i[0] / 65535 * 255, i[1] / 65535 * 255, i[2] / 65535 * 255];
  }, r.rgb.apple = function(i) {
    return [i[0] / 255 * 65535, i[1] / 255 * 65535, i[2] / 255 * 65535];
  }, r.gray.rgb = function(i) {
    return [i[0] / 100 * 255, i[0] / 100 * 255, i[0] / 100 * 255];
  }, r.gray.hsl = function(i) {
    return [0, 0, i[0]];
  }, r.gray.hsv = r.gray.hsl, r.gray.hwb = function(i) {
    return [0, 100, i[0]];
  }, r.gray.cmyk = function(i) {
    return [0, 0, 0, i[0]];
  }, r.gray.lab = function(i) {
    return [i[0], 0, 0];
  }, r.gray.hex = function(i) {
    const s = Math.round(i[0] / 100 * 255) & 255, u = ((s << 16) + (s << 8) + s).toString(16).toUpperCase();
    return "000000".substring(u.length) + u;
  }, r.rgb.gray = function(i) {
    return [(i[0] + i[1] + i[2]) / 3 / 255 * 100];
  }, Dh;
}
var Lh, ww;
function sF() {
  if (ww)
    return Lh;
  ww = 1;
  const e = iP();
  function t() {
    const s = {}, a = Object.keys(e);
    for (let u = a.length, c = 0; c < u; c++)
      s[a[c]] = {
        // http://jsperf.com/1-vs-infinity
        // micro-opt, but this is simple.
        distance: -1,
        parent: null
      };
    return s;
  }
  function r(s) {
    const a = t(), u = [s];
    for (a[s].distance = 0; u.length; ) {
      const c = u.pop(), l = Object.keys(e[c]);
      for (let d = l.length, p = 0; p < d; p++) {
        const h = l[p], v = a[h];
        v.distance === -1 && (v.distance = a[c].distance + 1, v.parent = c, u.unshift(h));
      }
    }
    return a;
  }
  function n(s, a) {
    return function(u) {
      return a(s(u));
    };
  }
  function i(s, a) {
    const u = [a[s].parent, s];
    let c = e[a[s].parent][s], l = a[s].parent;
    for (; a[l].parent; )
      u.unshift(a[l].parent), c = n(e[a[l].parent][l], c), l = a[l].parent;
    return c.conversion = u, c;
  }
  return Lh = function(s) {
    const a = r(s), u = {}, c = Object.keys(a);
    for (let l = c.length, d = 0; d < l; d++) {
      const p = c[d];
      a[p].parent !== null && (u[p] = i(p, a));
    }
    return u;
  }, Lh;
}
var qh, $w;
function aF() {
  if ($w)
    return qh;
  $w = 1;
  const e = iP(), t = sF(), r = {}, n = Object.keys(e);
  function i(a) {
    const u = function(...c) {
      const l = c[0];
      return l == null ? l : (l.length > 1 && (c = l), a(c));
    };
    return "conversion" in a && (u.conversion = a.conversion), u;
  }
  function s(a) {
    const u = function(...c) {
      const l = c[0];
      if (l == null)
        return l;
      l.length > 1 && (c = l);
      const d = a(c);
      if (typeof d == "object")
        for (let p = d.length, h = 0; h < p; h++)
          d[h] = Math.round(d[h]);
      return d;
    };
    return "conversion" in a && (u.conversion = a.conversion), u;
  }
  return n.forEach((a) => {
    r[a] = {}, Object.defineProperty(r[a], "channels", { value: e[a].channels }), Object.defineProperty(r[a], "labels", { value: e[a].labels });
    const u = t(a);
    Object.keys(u).forEach((l) => {
      const d = u[l];
      r[a][l] = s(d), r[a][l].raw = i(d);
    });
  }), qh = r, qh;
}
jl.exports;
var Ew;
function oF() {
  return Ew || (Ew = 1, function(e) {
    const t = (d, p) => (...h) => `\x1B[${d(...h) + p}m`, r = (d, p) => (...h) => {
      const v = d(...h);
      return `\x1B[${38 + p};5;${v}m`;
    }, n = (d, p) => (...h) => {
      const v = d(...h);
      return `\x1B[${38 + p};2;${v[0]};${v[1]};${v[2]}m`;
    }, i = (d) => d, s = (d, p, h) => [d, p, h], a = (d, p, h) => {
      Object.defineProperty(d, p, {
        get: () => {
          const v = h();
          return Object.defineProperty(d, p, {
            value: v,
            enumerable: !0,
            configurable: !0
          }), v;
        },
        enumerable: !0,
        configurable: !0
      });
    };
    let u;
    const c = (d, p, h, v) => {
      u === void 0 && (u = aF());
      const y = v ? 10 : 0, g = {};
      for (const [_, m] of Object.entries(u)) {
        const w = _ === "ansi16" ? "ansi" : _;
        _ === p ? g[w] = d(h, y) : typeof m == "object" && (g[w] = d(m[p], y));
      }
      return g;
    };
    function l() {
      const d = /* @__PURE__ */ new Map(), p = {
        modifier: {
          reset: [0, 0],
          // 21 isn't widely supported and 22 does the same thing
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          // Bright color
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          // Bright color
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      p.color.gray = p.color.blackBright, p.bgColor.bgGray = p.bgColor.bgBlackBright, p.color.grey = p.color.blackBright, p.bgColor.bgGrey = p.bgColor.bgBlackBright;
      for (const [h, v] of Object.entries(p)) {
        for (const [y, g] of Object.entries(v))
          p[y] = {
            open: `\x1B[${g[0]}m`,
            close: `\x1B[${g[1]}m`
          }, v[y] = p[y], d.set(g[0], g[1]);
        Object.defineProperty(p, h, {
          value: v,
          enumerable: !1
        });
      }
      return Object.defineProperty(p, "codes", {
        value: d,
        enumerable: !1
      }), p.color.close = "\x1B[39m", p.bgColor.close = "\x1B[49m", a(p.color, "ansi", () => c(t, "ansi16", i, !1)), a(p.color, "ansi256", () => c(r, "ansi256", i, !1)), a(p.color, "ansi16m", () => c(n, "rgb", s, !1)), a(p.bgColor, "ansi", () => c(t, "ansi16", i, !0)), a(p.bgColor, "ansi256", () => c(r, "ansi256", i, !0)), a(p.bgColor, "ansi16m", () => c(n, "rgb", s, !0)), p;
    }
    Object.defineProperty(e, "exports", {
      enumerable: !0,
      get: l
    });
  }(jl)), jl.exports;
}
var Fh, xw;
function uF() {
  return xw || (xw = 1, Fh = {
    stdout: !1,
    stderr: !1
  }), Fh;
}
var Uh, Ow;
function cF() {
  return Ow || (Ow = 1, Uh = {
    stringReplaceAll: (r, n, i) => {
      let s = r.indexOf(n);
      if (s === -1)
        return r;
      const a = n.length;
      let u = 0, c = "";
      do
        c += r.substr(u, s - u) + n + i, u = s + a, s = r.indexOf(n, u);
      while (s !== -1);
      return c += r.substr(u), c;
    },
    stringEncaseCRLFWithFirstIndex: (r, n, i, s) => {
      let a = 0, u = "";
      do {
        const c = r[s - 1] === "\r";
        u += r.substr(a, (c ? s - 1 : s) - a) + n + (c ? `\r
` : `
`) + i, a = s + 1, s = r.indexOf(`
`, a);
      } while (s !== -1);
      return u += r.substr(a), u;
    }
  }), Uh;
}
var Bh, Pw;
function lF() {
  if (Pw)
    return Bh;
  Pw = 1;
  const e = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi, t = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, r = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, n = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi, i = /* @__PURE__ */ new Map([
    ["n", `
`],
    ["r", "\r"],
    ["t", "	"],
    ["b", "\b"],
    ["f", "\f"],
    ["v", "\v"],
    ["0", "\0"],
    ["\\", "\\"],
    ["e", "\x1B"],
    ["a", "\x07"]
  ]);
  function s(l) {
    const d = l[0] === "u", p = l[1] === "{";
    return d && !p && l.length === 5 || l[0] === "x" && l.length === 3 ? String.fromCharCode(parseInt(l.slice(1), 16)) : d && p ? String.fromCodePoint(parseInt(l.slice(2, -1), 16)) : i.get(l) || l;
  }
  function a(l, d) {
    const p = [], h = d.trim().split(/\s*,\s*/g);
    let v;
    for (const y of h) {
      const g = Number(y);
      if (!Number.isNaN(g))
        p.push(g);
      else if (v = y.match(r))
        p.push(v[2].replace(n, (_, m, w) => m ? s(m) : w));
      else
        throw new Error(`Invalid Chalk template style argument: ${y} (in style '${l}')`);
    }
    return p;
  }
  function u(l) {
    t.lastIndex = 0;
    const d = [];
    let p;
    for (; (p = t.exec(l)) !== null; ) {
      const h = p[1];
      if (p[2]) {
        const v = a(h, p[2]);
        d.push([h].concat(v));
      } else
        d.push([h]);
    }
    return d;
  }
  function c(l, d) {
    const p = {};
    for (const v of d)
      for (const y of v.styles)
        p[y[0]] = v.inverse ? null : y.slice(1);
    let h = l;
    for (const [v, y] of Object.entries(p))
      if (Array.isArray(y)) {
        if (!(v in h))
          throw new Error(`Unknown Chalk style: ${v}`);
        h = y.length > 0 ? h[v](...y) : h[v];
      }
    return h;
  }
  return Bh = (l, d) => {
    const p = [], h = [];
    let v = [];
    if (d.replace(e, (y, g, _, m, w, $) => {
      if (g)
        v.push(s(g));
      else if (m) {
        const E = v.join("");
        v = [], h.push(p.length === 0 ? E : c(l, p)(E)), p.push({ inverse: _, styles: u(m) });
      } else if (w) {
        if (p.length === 0)
          throw new Error("Found extraneous } in Chalk template literal");
        h.push(c(l, p)(v.join(""))), v = [], p.pop();
      } else
        v.push($);
    }), h.push(v.join("")), p.length > 0) {
      const y = `Chalk template literal is missing ${p.length} closing bracket${p.length === 1 ? "" : "s"} (\`}\`)`;
      throw new Error(y);
    }
    return h.join("");
  }, Bh;
}
var Vh, Sw;
function fF() {
  if (Sw)
    return Vh;
  Sw = 1;
  const e = oF(), { stdout: t, stderr: r } = uF(), {
    stringReplaceAll: n,
    stringEncaseCRLFWithFirstIndex: i
  } = cF(), { isArray: s } = Array, a = [
    "ansi",
    "ansi",
    "ansi256",
    "ansi16m"
  ], u = /* @__PURE__ */ Object.create(null), c = (E, A = {}) => {
    if (A.level && !(Number.isInteger(A.level) && A.level >= 0 && A.level <= 3))
      throw new Error("The `level` option should be an integer from 0 to 3");
    const R = t ? t.level : 0;
    E.level = A.level === void 0 ? R : A.level;
  };
  class l {
    constructor(A) {
      return d(A);
    }
  }
  const d = (E) => {
    const A = {};
    return c(A, E), A.template = (...R) => w(A.template, ...R), Object.setPrototypeOf(A, p.prototype), Object.setPrototypeOf(A.template, A), A.template.constructor = () => {
      throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
    }, A.template.Instance = l, A.template;
  };
  function p(E) {
    return d(E);
  }
  for (const [E, A] of Object.entries(e))
    u[E] = {
      get() {
        const R = g(this, y(A.open, A.close, this._styler), this._isEmpty);
        return Object.defineProperty(this, E, { value: R }), R;
      }
    };
  u.visible = {
    get() {
      const E = g(this, this._styler, !0);
      return Object.defineProperty(this, "visible", { value: E }), E;
    }
  };
  const h = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
  for (const E of h)
    u[E] = {
      get() {
        const { level: A } = this;
        return function(...R) {
          const I = y(e.color[a[A]][E](...R), e.color.close, this._styler);
          return g(this, I, this._isEmpty);
        };
      }
    };
  for (const E of h) {
    const A = "bg" + E[0].toUpperCase() + E.slice(1);
    u[A] = {
      get() {
        const { level: R } = this;
        return function(...I) {
          const D = y(e.bgColor[a[R]][E](...I), e.bgColor.close, this._styler);
          return g(this, D, this._isEmpty);
        };
      }
    };
  }
  const v = Object.defineProperties(() => {
  }, {
    ...u,
    level: {
      enumerable: !0,
      get() {
        return this._generator.level;
      },
      set(E) {
        this._generator.level = E;
      }
    }
  }), y = (E, A, R) => {
    let I, D;
    return R === void 0 ? (I = E, D = A) : (I = R.openAll + E, D = A + R.closeAll), {
      open: E,
      close: A,
      openAll: I,
      closeAll: D,
      parent: R
    };
  }, g = (E, A, R) => {
    const I = (...D) => s(D[0]) && s(D[0].raw) ? _(I, w(I, ...D)) : _(I, D.length === 1 ? "" + D[0] : D.join(" "));
    return Object.setPrototypeOf(I, v), I._generator = E, I._styler = A, I._isEmpty = R, I;
  }, _ = (E, A) => {
    if (E.level <= 0 || !A)
      return E._isEmpty ? "" : A;
    let R = E._styler;
    if (R === void 0)
      return A;
    const { openAll: I, closeAll: D } = R;
    if (A.indexOf("\x1B") !== -1)
      for (; R !== void 0; )
        A = n(A, R.close, R.open), R = R.parent;
    const J = A.indexOf(`
`);
    return J !== -1 && (A = i(A, D, I, J)), I + A + D;
  };
  let m;
  const w = (E, ...A) => {
    const [R] = A;
    if (!s(R) || !s(R.raw))
      return A.join(" ");
    const I = A.slice(1), D = [R.raw[0]];
    for (let J = 1; J < R.length; J++)
      D.push(
        String(I[J - 1]).replace(/[{}\\]/g, "\\$&"),
        String(R.raw[J])
      );
    return m === void 0 && (m = lF()), m(E, D.join(""));
  };
  Object.defineProperties(p.prototype, u);
  const $ = p();
  return $.supportsColor = t, $.stderr = p({ level: r ? r.level : 0 }), $.stderr.supportsColor = r, Vh = $, Vh;
}
var Zh = {}, il = { exports: {} }, Go = {}, Aw;
function sP() {
  if (Aw)
    return Go;
  Aw = 1, Object.defineProperty(Go, "__esModule", {
    value: !0
  }), Go.getPointers = void 0;
  var e = function(r) {
    var n = r.split("/").slice(1);
    for (var i in n)
      n[i] = n[i].split("~1").join("/").split("~0").join("~");
    return n;
  };
  return Go.getPointers = e, Go;
}
var Cw;
function dF() {
  return Cw || (Cw = 1, function(e, t) {
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = n;
    var r = sP();
    function n(i, s, a) {
      var u = (0, r.getPointers)(s), c = u.length - 1;
      return u.reduce(function(l, d, p) {
        switch (l.type) {
          case "Object": {
            var h = l.members.filter(function(_) {
              return _.name.value === d;
            });
            if (h.length !== 1)
              throw new Error("Couldn't find property ".concat(d, " of ").concat(s));
            var v = h[0], y = v.name, g = v.value;
            return a && p === c ? y : g;
          }
          case "Array":
            return l.elements[d];
          default:
            console.log(l);
        }
      }, i.body);
    }
    e.exports = t.default;
  }(il, il.exports)), il.exports;
}
var sl = { exports: {} }, Rw;
function pF() {
  return Rw || (Rw = 1, function(e, t) {
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = i;
    var r = sP();
    function n(s) {
      if (!s || !s.elements)
        return "";
      var a = s.elements.filter(function(u) {
        return u && u.name && u.name.value === "type";
      });
      return a.length && a[0].value && ":".concat(a[0].value.value) || "";
    }
    function i(s, a) {
      var u = "";
      return (0, r.getPointers)(a).reduce(function(c, l) {
        switch (c.type) {
          case "Object": {
            u += "/".concat(l);
            var d = c.members.filter(function(p) {
              return p.name.value === l;
            });
            if (d.length !== 1)
              throw new Error("Couldn't find property ".concat(l, " of ").concat(a));
            return d[0].value;
          }
          case "Array":
            return u += "/".concat(l).concat(n(c.elements[l])), c.elements[l];
          default:
            console.log(c);
        }
      }, s.body), u;
    }
    e.exports = t.default;
  }(sl, sl.exports)), sl.exports;
}
var Tw;
function hF() {
  return Tw || (Tw = 1, function(e) {
    var t = Ln;
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), Object.defineProperty(e, "getDecoratedDataPath", {
      enumerable: !0,
      get: function() {
        return n.default;
      }
    }), Object.defineProperty(e, "getMetaFromPath", {
      enumerable: !0,
      get: function() {
        return r.default;
      }
    });
    var r = t(dF()), n = t(pF());
  }(Zh)), Zh;
}
var Iw;
function ho() {
  return Iw || (Iw = 1, function(e, t) {
    var r = Ln;
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = void 0;
    var n = r(na()), i = r(ia()), s = nF(), a = r(fF()), u = hF(), c = /* @__PURE__ */ function() {
      function l() {
        var d = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
          isIdentifierLocation: !1
        }, p = arguments.length > 1 ? arguments[1] : void 0, h = p.colorize, v = p.data, y = p.schema, g = p.jsonAst, _ = p.jsonRaw;
        (0, n.default)(this, l), this.options = d, this.colorize = !!(h || h === void 0), this.data = v, this.schema = y, this.jsonAst = g, this.jsonRaw = _;
      }
      return (0, i.default)(l, [{
        key: "getChalk",
        value: function() {
          return this.colorize ? a.default : new a.default.Instance({
            level: 0
          });
        }
      }, {
        key: "getLocation",
        value: function() {
          var p = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.instancePath, h = this.options, v = h.isIdentifierLocation, y = h.isSkipEndLocation, g = (0, u.getMetaFromPath)(this.jsonAst, p, v), _ = g.loc;
          return {
            start: _.start,
            end: y ? void 0 : _.end
          };
        }
      }, {
        key: "getDecoratedPath",
        value: function() {
          var p = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.instancePath;
          return (0, u.getDecoratedDataPath)(this.jsonAst, p);
        }
      }, {
        key: "getCodeFrame",
        value: function(p) {
          var h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.instancePath;
          return (0, s.codeFrameColumns)(this.jsonRaw, this.getLocation(h), {
            /**
             * `@babel/highlight`, by way of `@babel/code-frame`, highlights out entire block of raw JSON
             * instead of just our `location` block -- so if you have a block of raw JSON that's upwards
             * of 2mb+ and have a lot of errors to generate code frames for then we're re-highlighting
             * the same huge chunk of code over and over and over and over again, all just so
             * `@babel/code-frame` will eventually extract a small <10 line chunk out of it to return to
             * us.
             *
             * Disabling `highlightCode` here will only disable highlighting the code we're showing users;
             * if `options.colorize` is supplied to this library then the error message we're adding will
             * still be highlighted.
             */
            highlightCode: !1,
            message: p
          });
        }
        /**
         * @return {string}
         */
      }, {
        key: "instancePath",
        get: function() {
          return typeof this.options.instancePath < "u" ? this.options.instancePath : this.options.dataPath;
        }
      }, {
        key: "print",
        value: function() {
          throw new Error("Implement the 'print' method inside ".concat(this.constructor.name, "!"));
        }
      }, {
        key: "getError",
        value: function() {
          throw new Error("Implement the 'getError' method inside ".concat(this.constructor.name, "!"));
        }
      }]), l;
    }();
    t.default = c, e.exports = t.default;
  }(nl, nl.exports)), nl.exports;
}
var jw;
function mF() {
  return jw || (jw = 1, function(e, t) {
    var r = Ln;
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = void 0;
    var n = r(ra()), i = r(lo()), s = r(na()), a = r(ia()), u = r(fo()), c = r(po()), l = r(sa()), d = r(ho()), p, h;
    function v(w, $) {
      var E = Object.keys(w);
      if (Object.getOwnPropertySymbols) {
        var A = Object.getOwnPropertySymbols(w);
        $ && (A = A.filter(function(R) {
          return Object.getOwnPropertyDescriptor(w, R).enumerable;
        })), E.push.apply(E, A);
      }
      return E;
    }
    function y(w) {
      for (var $ = 1; $ < arguments.length; $++) {
        var E = arguments[$] != null ? arguments[$] : {};
        $ % 2 ? v(Object(E), !0).forEach(function(A) {
          (0, n.default)(w, A, E[A]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(w, Object.getOwnPropertyDescriptors(E)) : v(Object(E)).forEach(function(A) {
          Object.defineProperty(w, A, Object.getOwnPropertyDescriptor(E, A));
        });
      }
      return w;
    }
    function g(w) {
      var $ = _();
      return function() {
        var A = (0, l.default)(w), R;
        if ($) {
          var I = (0, l.default)(this).constructor;
          R = Reflect.construct(A, arguments, I);
        } else
          R = A.apply(this, arguments);
        return (0, c.default)(this, R);
      };
    }
    function _() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    var m = /* @__PURE__ */ function(w) {
      (0, u.default)(E, w);
      var $ = g(E);
      function E() {
        var A;
        (0, s.default)(this, E);
        for (var R = arguments.length, I = new Array(R), D = 0; D < R; D++)
          I[D] = arguments[D];
        return A = $.call.apply($, [this].concat(I)), A.name = "AdditionalPropValidationError", A.options.isIdentifierLocation = !0, A;
      }
      return (0, a.default)(E, [{
        key: "print",
        value: function() {
          var R = this.options, I = R.message, D = R.params, J = this.getChalk(), ae = [J(p || (p = (0, i.default)(["{red {bold ADDITIONAL PROPERTY} ", `}
`], ["{red {bold ADDITIONAL PROPERTY} ", "}\\n"])), I)];
          return ae.concat(this.getCodeFrame(J(h || (h = (0, i.default)(["  {magentaBright ", "} is not expected to be here!"])), D.additionalProperty), "".concat(this.instancePath, "/").concat(D.additionalProperty)));
        }
      }, {
        key: "getError",
        value: function() {
          var R = this.options.params;
          return y(y({}, this.getLocation("".concat(this.instancePath, "/").concat(R.additionalProperty))), {}, {
            error: "".concat(this.getDecoratedPath(), " Property ").concat(R.additionalProperty, " is not expected to be here"),
            path: this.instancePath
          });
        }
      }]), E;
    }(d.default);
    t.default = m, e.exports = t.default;
  }(rl, rl.exports)), rl.exports;
}
var al = { exports: {} }, kw;
function yF() {
  return kw || (kw = 1, function(e, t) {
    var r = Ln;
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = void 0;
    var n = r(ra()), i = r(lo()), s = r(na()), a = r(ia()), u = r(fo()), c = r(po()), l = r(sa()), d = r(ho()), p, h;
    function v(w, $) {
      var E = Object.keys(w);
      if (Object.getOwnPropertySymbols) {
        var A = Object.getOwnPropertySymbols(w);
        $ && (A = A.filter(function(R) {
          return Object.getOwnPropertyDescriptor(w, R).enumerable;
        })), E.push.apply(E, A);
      }
      return E;
    }
    function y(w) {
      for (var $ = 1; $ < arguments.length; $++) {
        var E = arguments[$] != null ? arguments[$] : {};
        $ % 2 ? v(Object(E), !0).forEach(function(A) {
          (0, n.default)(w, A, E[A]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(w, Object.getOwnPropertyDescriptors(E)) : v(Object(E)).forEach(function(A) {
          Object.defineProperty(w, A, Object.getOwnPropertyDescriptor(E, A));
        });
      }
      return w;
    }
    function g(w) {
      var $ = _();
      return function() {
        var A = (0, l.default)(w), R;
        if ($) {
          var I = (0, l.default)(this).constructor;
          R = Reflect.construct(A, arguments, I);
        } else
          R = A.apply(this, arguments);
        return (0, c.default)(this, R);
      };
    }
    function _() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    var m = /* @__PURE__ */ function(w) {
      (0, u.default)(E, w);
      var $ = g(E);
      function E() {
        var A;
        (0, s.default)(this, E);
        for (var R = arguments.length, I = new Array(R), D = 0; D < R; D++)
          I[D] = arguments[D];
        return A = $.call.apply($, [this].concat(I)), A.name = "DefaultValidationError", A.options.isSkipEndLocation = !0, A;
      }
      return (0, a.default)(E, [{
        key: "print",
        value: function() {
          var R = this.options, I = R.keyword, D = R.message, J = this.getChalk(), ae = [J(p || (p = (0, i.default)(["{red {bold ", "} ", `}
`], ["{red {bold ", "} ", "}\\n"])), I.toUpperCase(), D)];
          return ae.concat(this.getCodeFrame(J(h || (h = (0, i.default)(["  {magentaBright ", "} ", ""])), I, D)));
        }
      }, {
        key: "getError",
        value: function() {
          var R = this.options, I = R.keyword, D = R.message;
          return y(y({}, this.getLocation()), {}, {
            error: "".concat(this.getDecoratedPath(), ": ").concat(I, " ").concat(D),
            path: this.instancePath
          });
        }
      }]), E;
    }(d.default);
    t.default = m, e.exports = t.default;
  }(al, al.exports)), al.exports;
}
var ol = { exports: {} }, Ko = {}, Mw;
function gF() {
  if (Mw)
    return Ko;
  Mw = 1;
  var e = /~/, t = /~[01]/g;
  function r(l) {
    switch (l) {
      case "~1":
        return "/";
      case "~0":
        return "~";
    }
    throw new Error("Invalid tilde escape: " + l);
  }
  function n(l) {
    return e.test(l) ? l.replace(t, r) : l;
  }
  function i(l, d, p) {
    for (var h, v, y = 1, g = d.length; y < g; ) {
      if (d[y] === "constructor" || d[y] === "prototype" || d[y] === "__proto__")
        return l;
      if (h = n(d[y++]), v = g > y, typeof l[h] > "u" && (Array.isArray(l) && h === "-" && (h = l.length), v && (d[y] !== "" && d[y] < 1 / 0 || d[y] === "-" ? l[h] = [] : l[h] = {})), !v)
        break;
      l = l[h];
    }
    var _ = l[h];
    return p === void 0 ? delete l[h] : l[h] = p, _;
  }
  function s(l) {
    if (typeof l == "string") {
      if (l = l.split("/"), l[0] === "")
        return l;
      throw new Error("Invalid JSON pointer.");
    } else if (Array.isArray(l)) {
      for (const d of l)
        if (typeof d != "string" && typeof d != "number")
          throw new Error("Invalid JSON pointer. Must be of type string or number.");
      return l;
    }
    throw new Error("Invalid JSON pointer.");
  }
  function a(l, d) {
    if (typeof l != "object")
      throw new Error("Invalid input object.");
    d = s(d);
    var p = d.length;
    if (p === 1)
      return l;
    for (var h = 1; h < p; ) {
      if (l = l[n(d[h++])], p === h)
        return l;
      if (typeof l != "object" || l === null)
        return;
    }
  }
  function u(l, d, p) {
    if (typeof l != "object")
      throw new Error("Invalid input object.");
    if (d = s(d), d.length === 0)
      throw new Error("Invalid JSON pointer for set.");
    return i(l, d, p);
  }
  function c(l) {
    var d = s(l);
    return {
      get: function(p) {
        return a(p, d);
      },
      set: function(p, h) {
        return u(p, d, h);
      }
    };
  }
  return Ko.get = a, Ko.set = u, Ko.compile = c, Ko;
}
var ul = { exports: {} }, Nw;
function vF() {
  if (Nw)
    return ul.exports;
  Nw = 1;
  const e = [], t = [], r = (n, i) => {
    if (n === i)
      return 0;
    const s = n;
    n.length > i.length && (n = i, i = s);
    let a = n.length, u = i.length;
    for (; a > 0 && n.charCodeAt(~-a) === i.charCodeAt(~-u); )
      a--, u--;
    let c = 0;
    for (; c < a && n.charCodeAt(c) === i.charCodeAt(c); )
      c++;
    if (a -= c, u -= c, a === 0)
      return u;
    let l, d, p, h, v = 0, y = 0;
    for (; v < a; )
      t[v] = n.charCodeAt(c + v), e[v] = ++v;
    for (; y < u; )
      for (l = i.charCodeAt(c + y), p = y++, d = y, v = 0; v < a; v++)
        h = l === t[v] ? p : p + 1, p = e[v], d = e[v] = p > d ? h > d ? d + 1 : h : h > p ? p + 1 : h;
    return d;
  };
  return ul.exports = r, ul.exports.default = r, ul.exports;
}
var Dw;
function bF() {
  return Dw || (Dw = 1, function(e, t) {
    var r = Ln;
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = void 0;
    var n = r(ra()), i = r(lo()), s = r(na()), a = r(ia()), u = r(fo()), c = r(po()), l = r(sa()), d = r(gF()), p = r(vF()), h = r(ho()), v, y, g, _;
    function m(R, I) {
      var D = Object.keys(R);
      if (Object.getOwnPropertySymbols) {
        var J = Object.getOwnPropertySymbols(R);
        I && (J = J.filter(function(ae) {
          return Object.getOwnPropertyDescriptor(R, ae).enumerable;
        })), D.push.apply(D, J);
      }
      return D;
    }
    function w(R) {
      for (var I = 1; I < arguments.length; I++) {
        var D = arguments[I] != null ? arguments[I] : {};
        I % 2 ? m(Object(D), !0).forEach(function(J) {
          (0, n.default)(R, J, D[J]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(R, Object.getOwnPropertyDescriptors(D)) : m(Object(D)).forEach(function(J) {
          Object.defineProperty(R, J, Object.getOwnPropertyDescriptor(D, J));
        });
      }
      return R;
    }
    function $(R) {
      var I = E();
      return function() {
        var J = (0, l.default)(R), ae;
        if (I) {
          var ye = (0, l.default)(this).constructor;
          ae = Reflect.construct(J, arguments, ye);
        } else
          ae = J.apply(this, arguments);
        return (0, c.default)(this, ae);
      };
    }
    function E() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    var A = /* @__PURE__ */ function(R) {
      (0, u.default)(D, R);
      var I = $(D);
      function D() {
        var J;
        (0, s.default)(this, D);
        for (var ae = arguments.length, ye = new Array(ae), xe = 0; xe < ae; xe++)
          ye[xe] = arguments[xe];
        return J = I.call.apply(I, [this].concat(ye)), J.name = "EnumValidationError", J;
      }
      return (0, a.default)(D, [{
        key: "print",
        value: function() {
          var ae = this.options, ye = ae.message, xe = ae.params.allowedValues, je = this.getChalk(), re = this.findBestMatch(), fe = [je(v || (v = (0, i.default)(["{red {bold ENUM} ", "}"])), ye), je(y || (y = (0, i.default)(["{red (", `)}
`], ["{red (", ")}\\n"])), xe.join(", "))];
          return fe.concat(this.getCodeFrame(re !== null ? je(g || (g = (0, i.default)(["  Did you mean {magentaBright ", "} here?"])), re) : je(_ || (_ = (0, i.default)(["  Unexpected value, should be equal to one of the allowed values"])))));
        }
      }, {
        key: "getError",
        value: function() {
          var ae = this.options, ye = ae.message, xe = ae.params, je = this.findBestMatch(), re = xe.allowedValues.join(", "), fe = w(w({}, this.getLocation()), {}, {
            error: "".concat(this.getDecoratedPath(), " ").concat(ye, ": ").concat(re),
            path: this.instancePath
          });
          return je !== null && (fe.suggestion = "Did you mean ".concat(je, "?")), fe;
        }
      }, {
        key: "findBestMatch",
        value: function() {
          var ae = this.options.params.allowedValues, ye = this.instancePath === "" ? this.data : d.default.get(this.data, this.instancePath);
          if (!ye)
            return null;
          var xe = ae.map(function(je) {
            return {
              value: je,
              weight: (0, p.default)(je, ye.toString())
            };
          }).sort(function(je, re) {
            return je.weight > re.weight ? 1 : je.weight < re.weight ? -1 : 0;
          })[0];
          return ae.length === 1 || xe.weight < xe.value.length ? xe.value : null;
        }
      }]), D;
    }(h.default);
    t.default = A, e.exports = t.default;
  }(ol, ol.exports)), ol.exports;
}
var cl = { exports: {} }, Lw;
function _F() {
  return Lw || (Lw = 1, function(e, t) {
    var r = Ln;
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = void 0;
    var n = r(ra()), i = r(lo()), s = r(na()), a = r(ia()), u = r(fo()), c = r(po()), l = r(sa()), d = r(ho()), p, h;
    function v(w, $) {
      var E = Object.keys(w);
      if (Object.getOwnPropertySymbols) {
        var A = Object.getOwnPropertySymbols(w);
        $ && (A = A.filter(function(R) {
          return Object.getOwnPropertyDescriptor(w, R).enumerable;
        })), E.push.apply(E, A);
      }
      return E;
    }
    function y(w) {
      for (var $ = 1; $ < arguments.length; $++) {
        var E = arguments[$] != null ? arguments[$] : {};
        $ % 2 ? v(Object(E), !0).forEach(function(A) {
          (0, n.default)(w, A, E[A]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(w, Object.getOwnPropertyDescriptors(E)) : v(Object(E)).forEach(function(A) {
          Object.defineProperty(w, A, Object.getOwnPropertyDescriptor(E, A));
        });
      }
      return w;
    }
    function g(w) {
      var $ = _();
      return function() {
        var A = (0, l.default)(w), R;
        if ($) {
          var I = (0, l.default)(this).constructor;
          R = Reflect.construct(A, arguments, I);
        } else
          R = A.apply(this, arguments);
        return (0, c.default)(this, R);
      };
    }
    function _() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    var m = /* @__PURE__ */ function(w) {
      (0, u.default)(E, w);
      var $ = g(E);
      function E() {
        var A;
        (0, s.default)(this, E);
        for (var R = arguments.length, I = new Array(R), D = 0; D < R; D++)
          I[D] = arguments[D];
        return A = $.call.apply($, [this].concat(I)), A.name = "PatternValidationError", A.options.isIdentifierLocation = !0, A;
      }
      return (0, a.default)(E, [{
        key: "print",
        value: function() {
          var R = this.options, I = R.message, D = R.params, J = R.propertyName, ae = this.getChalk(), ye = [ae(p || (p = (0, i.default)(["{red {bold PROPERTY} ", `}
`], ["{red {bold PROPERTY} ", "}\\n"])), I)];
          return ye.concat(this.getCodeFrame(ae(h || (h = (0, i.default)(["  must match pattern {magentaBright ", "}"])), D.pattern), "".concat(this.instancePath, "/").concat(J)));
        }
      }, {
        key: "getError",
        value: function() {
          var R = this.options, I = R.params, D = R.propertyName;
          return y(y({}, this.getLocation()), {}, {
            error: "".concat(this.getDecoratedPath(), ' Property "').concat(D, '" must match pattern ').concat(I.pattern),
            path: this.instancePath
          });
        }
      }]), E;
    }(d.default);
    t.default = m, e.exports = t.default;
  }(cl, cl.exports)), cl.exports;
}
var ll = { exports: {} }, zh = { exports: {} }, Wh = { exports: {} }, qw;
function wF() {
  return qw || (qw = 1, function(e) {
    var t = sa();
    function r(n, i) {
      for (; !Object.prototype.hasOwnProperty.call(n, i) && (n = t(n), n !== null); )
        ;
      return n;
    }
    e.exports = r, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(Wh)), Wh.exports;
}
var Fw;
function $F() {
  return Fw || (Fw = 1, function(e) {
    var t = wF();
    function r() {
      return typeof Reflect < "u" && Reflect.get ? (e.exports = r = Reflect.get.bind(), e.exports.__esModule = !0, e.exports.default = e.exports) : (e.exports = r = function(i, s, a) {
        var u = t(i, s);
        if (u) {
          var c = Object.getOwnPropertyDescriptor(u, s);
          return c.get ? c.get.call(arguments.length < 3 ? i : a) : c.value;
        }
      }, e.exports.__esModule = !0, e.exports.default = e.exports), r.apply(this, arguments);
    }
    e.exports = r, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(zh)), zh.exports;
}
var Uw;
function EF() {
  return Uw || (Uw = 1, function(e, t) {
    var r = Ln;
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = void 0;
    var n = r(ra()), i = r(lo()), s = r(na()), a = r(ia()), u = r($F()), c = r(fo()), l = r(po()), d = r(sa()), p = r(ho()), h, v;
    function y($, E) {
      var A = Object.keys($);
      if (Object.getOwnPropertySymbols) {
        var R = Object.getOwnPropertySymbols($);
        E && (R = R.filter(function(I) {
          return Object.getOwnPropertyDescriptor($, I).enumerable;
        })), A.push.apply(A, R);
      }
      return A;
    }
    function g($) {
      for (var E = 1; E < arguments.length; E++) {
        var A = arguments[E] != null ? arguments[E] : {};
        E % 2 ? y(Object(A), !0).forEach(function(R) {
          (0, n.default)($, R, A[R]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties($, Object.getOwnPropertyDescriptors(A)) : y(Object(A)).forEach(function(R) {
          Object.defineProperty($, R, Object.getOwnPropertyDescriptor(A, R));
        });
      }
      return $;
    }
    function _($) {
      var E = m();
      return function() {
        var R = (0, d.default)($), I;
        if (E) {
          var D = (0, d.default)(this).constructor;
          I = Reflect.construct(R, arguments, D);
        } else
          I = R.apply(this, arguments);
        return (0, l.default)(this, I);
      };
    }
    function m() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    var w = /* @__PURE__ */ function($) {
      (0, c.default)(A, $);
      var E = _(A);
      function A() {
        var R;
        (0, s.default)(this, A);
        for (var I = arguments.length, D = new Array(I), J = 0; J < I; J++)
          D[J] = arguments[J];
        return R = E.call.apply(E, [this].concat(D)), R.name = "RequiredValidationError", R;
      }
      return (0, a.default)(A, [{
        key: "getLocation",
        value: function() {
          var I = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.instancePath, D = (0, u.default)((0, d.default)(A.prototype), "getLocation", this).call(this, I), J = D.start;
          return {
            start: J
          };
        }
      }, {
        key: "print",
        value: function() {
          var I = this.options, D = I.message, J = I.params, ae = this.getChalk(), ye = [ae(h || (h = (0, i.default)(["{red {bold REQUIRED} ", `}
`], ["{red {bold REQUIRED} ", "}\\n"])), D)];
          return ye.concat(this.getCodeFrame(ae(v || (v = (0, i.default)(["  {magentaBright ", "} is missing here!"])), J.missingProperty)));
        }
      }, {
        key: "getError",
        value: function() {
          var I = this.options.message;
          return g(g({}, this.getLocation()), {}, {
            error: "".concat(this.getDecoratedPath(), " ").concat(I),
            path: this.instancePath
          });
        }
      }]), A;
    }(p.default);
    t.default = w, e.exports = t.default;
  }(ll, ll.exports)), ll.exports;
}
var fl = { exports: {} }, Bw;
function xF() {
  return Bw || (Bw = 1, function(e, t) {
    var r = Ln;
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = void 0;
    var n = r(ra()), i = r(lo()), s = r(na()), a = r(ia()), u = r(fo()), c = r(po()), l = r(sa()), d = r(ho()), p, h;
    function v(w, $) {
      var E = Object.keys(w);
      if (Object.getOwnPropertySymbols) {
        var A = Object.getOwnPropertySymbols(w);
        $ && (A = A.filter(function(R) {
          return Object.getOwnPropertyDescriptor(w, R).enumerable;
        })), E.push.apply(E, A);
      }
      return E;
    }
    function y(w) {
      for (var $ = 1; $ < arguments.length; $++) {
        var E = arguments[$] != null ? arguments[$] : {};
        $ % 2 ? v(Object(E), !0).forEach(function(A) {
          (0, n.default)(w, A, E[A]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(w, Object.getOwnPropertyDescriptors(E)) : v(Object(E)).forEach(function(A) {
          Object.defineProperty(w, A, Object.getOwnPropertyDescriptor(E, A));
        });
      }
      return w;
    }
    function g(w) {
      var $ = _();
      return function() {
        var A = (0, l.default)(w), R;
        if ($) {
          var I = (0, l.default)(this).constructor;
          R = Reflect.construct(A, arguments, I);
        } else
          R = A.apply(this, arguments);
        return (0, c.default)(this, R);
      };
    }
    function _() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    var m = /* @__PURE__ */ function(w) {
      (0, u.default)(E, w);
      var $ = g(E);
      function E() {
        var A;
        (0, s.default)(this, E);
        for (var R = arguments.length, I = new Array(R), D = 0; D < R; D++)
          I[D] = arguments[D];
        return A = $.call.apply($, [this].concat(I)), A.name = "UnevaluatedPropValidationError", A.options.isIdentifierLocation = !0, A;
      }
      return (0, a.default)(E, [{
        key: "print",
        value: function() {
          var R = this.options, I = R.message, D = R.params, J = this.getChalk(), ae = [J(p || (p = (0, i.default)(["{red {bold UNEVALUATED PROPERTY} ", `}
`], ["{red {bold UNEVALUATED PROPERTY} ", "}\\n"])), I)];
          return ae.concat(this.getCodeFrame(J(h || (h = (0, i.default)(["  {magentaBright ", "} is not expected to be here!"])), D.unevaluatedProperty), "".concat(this.instancePath, "/").concat(D.unevaluatedProperty)));
        }
      }, {
        key: "getError",
        value: function() {
          var R = this.options.params;
          return y(y({}, this.getLocation("".concat(this.instancePath, "/").concat(R.unevaluatedProperty))), {}, {
            error: "".concat(this.getDecoratedPath(), " Property ").concat(R.unevaluatedProperty, " is not expected to be here"),
            path: this.instancePath
          });
        }
      }]), E;
    }(d.default);
    t.default = m, e.exports = t.default;
  }(fl, fl.exports)), fl.exports;
}
var Vw;
function OF() {
  return Vw || (Vw = 1, function(e) {
    var t = Ln;
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), Object.defineProperty(e, "AdditionalPropValidationError", {
      enumerable: !0,
      get: function() {
        return r.default;
      }
    }), Object.defineProperty(e, "DefaultValidationError", {
      enumerable: !0,
      get: function() {
        return n.default;
      }
    }), Object.defineProperty(e, "EnumValidationError", {
      enumerable: !0,
      get: function() {
        return i.default;
      }
    }), Object.defineProperty(e, "PatternValidationError", {
      enumerable: !0,
      get: function() {
        return s.default;
      }
    }), Object.defineProperty(e, "RequiredValidationError", {
      enumerable: !0,
      get: function() {
        return a.default;
      }
    }), Object.defineProperty(e, "UnevaluatedPropValidationError", {
      enumerable: !0,
      get: function() {
        return u.default;
      }
    });
    var r = t(mF()), n = t(yF()), i = t(bF()), s = t(_F()), a = t(EF()), u = t(xF());
  }(vh)), vh;
}
var Zw;
function PF() {
  return Zw || (Zw = 1, function(e) {
    var t = Ln;
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.createErrorInstances = h, e.default = v, e.filterRedundantErrors = p, e.makeTree = d;
    var r = t(ra()), n = t(D8()), i = t(U8()), s = B8(), a = OF();
    function u(y, g) {
      var _ = Object.keys(y);
      if (Object.getOwnPropertySymbols) {
        var m = Object.getOwnPropertySymbols(y);
        g && (m = m.filter(function(w) {
          return Object.getOwnPropertyDescriptor(y, w).enumerable;
        })), _.push.apply(_, m);
      }
      return _;
    }
    function c(y) {
      for (var g = 1; g < arguments.length; g++) {
        var _ = arguments[g] != null ? arguments[g] : {};
        g % 2 ? u(Object(_), !0).forEach(function(m) {
          (0, r.default)(y, m, _[m]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(y, Object.getOwnPropertyDescriptors(_)) : u(Object(_)).forEach(function(m) {
          Object.defineProperty(y, m, Object.getOwnPropertyDescriptor(_, m));
        });
      }
      return y;
    }
    var l = /\/[\w_-]+(\/\d+)?/g;
    function d() {
      var y = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], g = {
        children: {}
      };
      return y.forEach(function(_) {
        var m = typeof _.instancePath < "u" ? _.instancePath : _.dataPath, w = m === "" ? [""] : m.match(l);
        w && w.reduce(function($, E, A) {
          return $.children[E] = $.children[E] || {
            children: {},
            errors: []
          }, A === w.length - 1 && $.children[E].errors.push(_), $.children[E];
        }, g);
      }), g;
    }
    function p(y, g, _) {
      (0, s.getErrors)(y).forEach(function(m) {
        (0, s.isRequiredError)(m) && (y.errors = [m], y.children = {});
      }), (0, s.getErrors)(y).some(s.isAnyOfError) && Object.keys(y.children).length > 0 && delete y.errors, y.errors && y.errors.length && (0, s.getErrors)(y).every(s.isEnumError) && (0, s.getSiblings)(g)(y).filter(s.notUndefined).some(s.getErrors) && delete g.children[_], Object.entries(y.children).forEach(function(m) {
        var w = (0, i.default)(m, 2), $ = w[0], E = w[1];
        return p(E, y, $);
      });
    }
    function h(y, g) {
      var _ = (0, s.getErrors)(y);
      if (_.length && _.every(s.isEnumError)) {
        var m = new Set((0, s.concatAll)([])(_.map(function(E) {
          return E.params.allowedValues;
        }))), w = (0, n.default)(m), $ = _[0];
        return [new a.EnumValidationError(c(c({}, $), {}, {
          params: {
            allowedValues: w
          }
        }), g)];
      }
      return (0, s.concatAll)(_.reduce(function(E, A) {
        switch (A.keyword) {
          case "additionalProperties":
            return E.concat(new a.AdditionalPropValidationError(A, g));
          case "pattern":
            return E.concat(new a.PatternValidationError(A, g));
          case "required":
            return E.concat(new a.RequiredValidationError(A, g));
          case "unevaluatedProperties":
            return E.concat(new a.UnevaluatedPropValidationError(A, g));
          default:
            return E.concat(new a.DefaultValidationError(A, g));
        }
      }, []))((0, s.getChildren)(y).map(function(E) {
        return h(E, g);
      }));
    }
    function v(y, g) {
      var _ = d(y || []);
      return p(_), h(_, g);
    }
  }(nh)), nh;
}
(function(e, t) {
  var r = Ln;
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.default = s;
  var n = ki, i = r(PF());
  function s(a, u, c) {
    var l = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, d = l.colorize, p = d === void 0 ? !0 : d, h = l.format, v = h === void 0 ? "cli" : h, y = l.indent, g = y === void 0 ? null : y, _ = l.json, m = _ === void 0 ? null : _, w = m || JSON.stringify(u, null, g), $ = (0, n.parse)(w), E = function(D) {
      return D.print().join(`
`);
    }, A = function(D) {
      return D.getError();
    }, R = (0, i.default)(c, {
      colorize: p,
      data: u,
      schema: a,
      jsonAst: $,
      jsonRaw: w
    });
    return v === "cli" ? R.map(E).join(`

`) : R.map(A);
  }
  e.exports = t.default;
})(jy, jy.exports);
var SF = jy.exports, My = { exports: {} }, Ja = {}, jn = {}, ao = {}, rc = {}, ht = {}, Fu = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.regexpCode = e.getEsmExportName = e.getProperty = e.safeStringify = e.stringify = e.strConcat = e.addCodeArg = e.str = e._ = e.nil = e._Code = e.Name = e.IDENTIFIER = e._CodeOrName = void 0;
  class t {
  }
  e._CodeOrName = t, e.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
  class r extends t {
    constructor(w) {
      if (super(), !e.IDENTIFIER.test(w))
        throw new Error("CodeGen: name must be a valid identifier");
      this.str = w;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      return !1;
    }
    get names() {
      return { [this.str]: 1 };
    }
  }
  e.Name = r;
  class n extends t {
    constructor(w) {
      super(), this._items = typeof w == "string" ? [w] : w;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      if (this._items.length > 1)
        return !1;
      const w = this._items[0];
      return w === "" || w === '""';
    }
    get str() {
      var w;
      return (w = this._str) !== null && w !== void 0 ? w : this._str = this._items.reduce(($, E) => `${$}${E}`, "");
    }
    get names() {
      var w;
      return (w = this._names) !== null && w !== void 0 ? w : this._names = this._items.reduce(($, E) => (E instanceof r && ($[E.str] = ($[E.str] || 0) + 1), $), {});
    }
  }
  e._Code = n, e.nil = new n("");
  function i(m, ...w) {
    const $ = [m[0]];
    let E = 0;
    for (; E < w.length; )
      u($, w[E]), $.push(m[++E]);
    return new n($);
  }
  e._ = i;
  const s = new n("+");
  function a(m, ...w) {
    const $ = [v(m[0])];
    let E = 0;
    for (; E < w.length; )
      $.push(s), u($, w[E]), $.push(s, v(m[++E]));
    return c($), new n($);
  }
  e.str = a;
  function u(m, w) {
    w instanceof n ? m.push(...w._items) : w instanceof r ? m.push(w) : m.push(p(w));
  }
  e.addCodeArg = u;
  function c(m) {
    let w = 1;
    for (; w < m.length - 1; ) {
      if (m[w] === s) {
        const $ = l(m[w - 1], m[w + 1]);
        if ($ !== void 0) {
          m.splice(w - 1, 3, $);
          continue;
        }
        m[w++] = "+";
      }
      w++;
    }
  }
  function l(m, w) {
    if (w === '""')
      return m;
    if (m === '""')
      return w;
    if (typeof m == "string")
      return w instanceof r || m[m.length - 1] !== '"' ? void 0 : typeof w != "string" ? `${m.slice(0, -1)}${w}"` : w[0] === '"' ? m.slice(0, -1) + w.slice(1) : void 0;
    if (typeof w == "string" && w[0] === '"' && !(m instanceof r))
      return `"${m}${w.slice(1)}`;
  }
  function d(m, w) {
    return w.emptyStr() ? m : m.emptyStr() ? w : a`${m}${w}`;
  }
  e.strConcat = d;
  function p(m) {
    return typeof m == "number" || typeof m == "boolean" || m === null ? m : v(Array.isArray(m) ? m.join(",") : m);
  }
  function h(m) {
    return new n(v(m));
  }
  e.stringify = h;
  function v(m) {
    return JSON.stringify(m).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
  }
  e.safeStringify = v;
  function y(m) {
    return typeof m == "string" && e.IDENTIFIER.test(m) ? new n(`.${m}`) : i`[${m}]`;
  }
  e.getProperty = y;
  function g(m) {
    if (typeof m == "string" && e.IDENTIFIER.test(m))
      return new n(`${m}`);
    throw new Error(`CodeGen: invalid export name: ${m}, use explicit $id name mapping`);
  }
  e.getEsmExportName = g;
  function _(m) {
    return new n(m.toString());
  }
  e.regexpCode = _;
})(Fu);
var Ny = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.ValueScope = e.ValueScopeName = e.Scope = e.varKinds = e.UsedValueState = void 0;
  const t = Fu;
  class r extends Error {
    constructor(l) {
      super(`CodeGen: "code" for ${l} not defined`), this.value = l.value;
    }
  }
  var n;
  (function(c) {
    c[c.Started = 0] = "Started", c[c.Completed = 1] = "Completed";
  })(n = e.UsedValueState || (e.UsedValueState = {})), e.varKinds = {
    const: new t.Name("const"),
    let: new t.Name("let"),
    var: new t.Name("var")
  };
  class i {
    constructor({ prefixes: l, parent: d } = {}) {
      this._names = {}, this._prefixes = l, this._parent = d;
    }
    toName(l) {
      return l instanceof t.Name ? l : this.name(l);
    }
    name(l) {
      return new t.Name(this._newName(l));
    }
    _newName(l) {
      const d = this._names[l] || this._nameGroup(l);
      return `${l}${d.index++}`;
    }
    _nameGroup(l) {
      var d, p;
      if (!((p = (d = this._parent) === null || d === void 0 ? void 0 : d._prefixes) === null || p === void 0) && p.has(l) || this._prefixes && !this._prefixes.has(l))
        throw new Error(`CodeGen: prefix "${l}" is not allowed in this scope`);
      return this._names[l] = { prefix: l, index: 0 };
    }
  }
  e.Scope = i;
  class s extends t.Name {
    constructor(l, d) {
      super(d), this.prefix = l;
    }
    setValue(l, { property: d, itemIndex: p }) {
      this.value = l, this.scopePath = (0, t._)`.${new t.Name(d)}[${p}]`;
    }
  }
  e.ValueScopeName = s;
  const a = (0, t._)`\n`;
  class u extends i {
    constructor(l) {
      super(l), this._values = {}, this._scope = l.scope, this.opts = { ...l, _n: l.lines ? a : t.nil };
    }
    get() {
      return this._scope;
    }
    name(l) {
      return new s(l, this._newName(l));
    }
    value(l, d) {
      var p;
      if (d.ref === void 0)
        throw new Error("CodeGen: ref must be passed in value");
      const h = this.toName(l), { prefix: v } = h, y = (p = d.key) !== null && p !== void 0 ? p : d.ref;
      let g = this._values[v];
      if (g) {
        const w = g.get(y);
        if (w)
          return w;
      } else
        g = this._values[v] = /* @__PURE__ */ new Map();
      g.set(y, h);
      const _ = this._scope[v] || (this._scope[v] = []), m = _.length;
      return _[m] = d.ref, h.setValue(d, { property: v, itemIndex: m }), h;
    }
    getValue(l, d) {
      const p = this._values[l];
      if (p)
        return p.get(d);
    }
    scopeRefs(l, d = this._values) {
      return this._reduceValues(d, (p) => {
        if (p.scopePath === void 0)
          throw new Error(`CodeGen: name "${p}" has no value`);
        return (0, t._)`${l}${p.scopePath}`;
      });
    }
    scopeCode(l = this._values, d, p) {
      return this._reduceValues(l, (h) => {
        if (h.value === void 0)
          throw new Error(`CodeGen: name "${h}" has no value`);
        return h.value.code;
      }, d, p);
    }
    _reduceValues(l, d, p = {}, h) {
      let v = t.nil;
      for (const y in l) {
        const g = l[y];
        if (!g)
          continue;
        const _ = p[y] = p[y] || /* @__PURE__ */ new Map();
        g.forEach((m) => {
          if (_.has(m))
            return;
          _.set(m, n.Started);
          let w = d(m);
          if (w) {
            const $ = this.opts.es5 ? e.varKinds.var : e.varKinds.const;
            v = (0, t._)`${v}${$} ${m} = ${w};${this.opts._n}`;
          } else if (w = h == null ? void 0 : h(m))
            v = (0, t._)`${v}${w}${this.opts._n}`;
          else
            throw new r(m);
          _.set(m, n.Completed);
        });
      }
      return v;
    }
  }
  e.ValueScope = u;
})(Ny);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.or = e.and = e.not = e.CodeGen = e.operators = e.varKinds = e.ValueScopeName = e.ValueScope = e.Scope = e.Name = e.regexpCode = e.stringify = e.getProperty = e.nil = e.strConcat = e.str = e._ = void 0;
  const t = Fu, r = Ny;
  var n = Fu;
  Object.defineProperty(e, "_", { enumerable: !0, get: function() {
    return n._;
  } }), Object.defineProperty(e, "str", { enumerable: !0, get: function() {
    return n.str;
  } }), Object.defineProperty(e, "strConcat", { enumerable: !0, get: function() {
    return n.strConcat;
  } }), Object.defineProperty(e, "nil", { enumerable: !0, get: function() {
    return n.nil;
  } }), Object.defineProperty(e, "getProperty", { enumerable: !0, get: function() {
    return n.getProperty;
  } }), Object.defineProperty(e, "stringify", { enumerable: !0, get: function() {
    return n.stringify;
  } }), Object.defineProperty(e, "regexpCode", { enumerable: !0, get: function() {
    return n.regexpCode;
  } }), Object.defineProperty(e, "Name", { enumerable: !0, get: function() {
    return n.Name;
  } });
  var i = Ny;
  Object.defineProperty(e, "Scope", { enumerable: !0, get: function() {
    return i.Scope;
  } }), Object.defineProperty(e, "ValueScope", { enumerable: !0, get: function() {
    return i.ValueScope;
  } }), Object.defineProperty(e, "ValueScopeName", { enumerable: !0, get: function() {
    return i.ValueScopeName;
  } }), Object.defineProperty(e, "varKinds", { enumerable: !0, get: function() {
    return i.varKinds;
  } }), e.operators = {
    GT: new t._Code(">"),
    GTE: new t._Code(">="),
    LT: new t._Code("<"),
    LTE: new t._Code("<="),
    EQ: new t._Code("==="),
    NEQ: new t._Code("!=="),
    NOT: new t._Code("!"),
    OR: new t._Code("||"),
    AND: new t._Code("&&"),
    ADD: new t._Code("+")
  };
  class s {
    optimizeNodes() {
      return this;
    }
    optimizeNames(C, q) {
      return this;
    }
  }
  class a extends s {
    constructor(C, q, N) {
      super(), this.varKind = C, this.name = q, this.rhs = N;
    }
    render({ es5: C, _n: q }) {
      const N = C ? r.varKinds.var : this.varKind, F = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
      return `${N} ${this.name}${F};` + q;
    }
    optimizeNames(C, q) {
      if (C[this.name.str])
        return this.rhs && (this.rhs = re(this.rhs, C, q)), this;
    }
    get names() {
      return this.rhs instanceof t._CodeOrName ? this.rhs.names : {};
    }
  }
  class u extends s {
    constructor(C, q, N) {
      super(), this.lhs = C, this.rhs = q, this.sideEffects = N;
    }
    render({ _n: C }) {
      return `${this.lhs} = ${this.rhs};` + C;
    }
    optimizeNames(C, q) {
      if (!(this.lhs instanceof t.Name && !C[this.lhs.str] && !this.sideEffects))
        return this.rhs = re(this.rhs, C, q), this;
    }
    get names() {
      const C = this.lhs instanceof t.Name ? {} : { ...this.lhs.names };
      return je(C, this.rhs);
    }
  }
  class c extends u {
    constructor(C, q, N, F) {
      super(C, N, F), this.op = q;
    }
    render({ _n: C }) {
      return `${this.lhs} ${this.op}= ${this.rhs};` + C;
    }
  }
  class l extends s {
    constructor(C) {
      super(), this.label = C, this.names = {};
    }
    render({ _n: C }) {
      return `${this.label}:` + C;
    }
  }
  class d extends s {
    constructor(C) {
      super(), this.label = C, this.names = {};
    }
    render({ _n: C }) {
      return `break${this.label ? ` ${this.label}` : ""};` + C;
    }
  }
  class p extends s {
    constructor(C) {
      super(), this.error = C;
    }
    render({ _n: C }) {
      return `throw ${this.error};` + C;
    }
    get names() {
      return this.error.names;
    }
  }
  class h extends s {
    constructor(C) {
      super(), this.code = C;
    }
    render({ _n: C }) {
      return `${this.code};` + C;
    }
    optimizeNodes() {
      return `${this.code}` ? this : void 0;
    }
    optimizeNames(C, q) {
      return this.code = re(this.code, C, q), this;
    }
    get names() {
      return this.code instanceof t._CodeOrName ? this.code.names : {};
    }
  }
  class v extends s {
    constructor(C = []) {
      super(), this.nodes = C;
    }
    render(C) {
      return this.nodes.reduce((q, N) => q + N.render(C), "");
    }
    optimizeNodes() {
      const { nodes: C } = this;
      let q = C.length;
      for (; q--; ) {
        const N = C[q].optimizeNodes();
        Array.isArray(N) ? C.splice(q, 1, ...N) : N ? C[q] = N : C.splice(q, 1);
      }
      return C.length > 0 ? this : void 0;
    }
    optimizeNames(C, q) {
      const { nodes: N } = this;
      let F = N.length;
      for (; F--; ) {
        const T = N[F];
        T.optimizeNames(C, q) || (fe(C, T.names), N.splice(F, 1));
      }
      return N.length > 0 ? this : void 0;
    }
    get names() {
      return this.nodes.reduce((C, q) => xe(C, q.names), {});
    }
  }
  class y extends v {
    render(C) {
      return "{" + C._n + super.render(C) + "}" + C._n;
    }
  }
  class g extends v {
  }
  class _ extends y {
  }
  _.kind = "else";
  class m extends y {
    constructor(C, q) {
      super(q), this.condition = C;
    }
    render(C) {
      let q = `if(${this.condition})` + super.render(C);
      return this.else && (q += "else " + this.else.render(C)), q;
    }
    optimizeNodes() {
      super.optimizeNodes();
      const C = this.condition;
      if (C === !0)
        return this.nodes;
      let q = this.else;
      if (q) {
        const N = q.optimizeNodes();
        q = this.else = Array.isArray(N) ? new _(N) : N;
      }
      if (q)
        return C === !1 ? q instanceof m ? q : q.nodes : this.nodes.length ? this : new m(le(C), q instanceof m ? [q] : q.nodes);
      if (!(C === !1 || !this.nodes.length))
        return this;
    }
    optimizeNames(C, q) {
      var N;
      if (this.else = (N = this.else) === null || N === void 0 ? void 0 : N.optimizeNames(C, q), !!(super.optimizeNames(C, q) || this.else))
        return this.condition = re(this.condition, C, q), this;
    }
    get names() {
      const C = super.names;
      return je(C, this.condition), this.else && xe(C, this.else.names), C;
    }
  }
  m.kind = "if";
  class w extends y {
  }
  w.kind = "for";
  class $ extends w {
    constructor(C) {
      super(), this.iteration = C;
    }
    render(C) {
      return `for(${this.iteration})` + super.render(C);
    }
    optimizeNames(C, q) {
      if (super.optimizeNames(C, q))
        return this.iteration = re(this.iteration, C, q), this;
    }
    get names() {
      return xe(super.names, this.iteration.names);
    }
  }
  class E extends w {
    constructor(C, q, N, F) {
      super(), this.varKind = C, this.name = q, this.from = N, this.to = F;
    }
    render(C) {
      const q = C.es5 ? r.varKinds.var : this.varKind, { name: N, from: F, to: T } = this;
      return `for(${q} ${N}=${F}; ${N}<${T}; ${N}++)` + super.render(C);
    }
    get names() {
      const C = je(super.names, this.from);
      return je(C, this.to);
    }
  }
  class A extends w {
    constructor(C, q, N, F) {
      super(), this.loop = C, this.varKind = q, this.name = N, this.iterable = F;
    }
    render(C) {
      return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(C);
    }
    optimizeNames(C, q) {
      if (super.optimizeNames(C, q))
        return this.iterable = re(this.iterable, C, q), this;
    }
    get names() {
      return xe(super.names, this.iterable.names);
    }
  }
  class R extends y {
    constructor(C, q, N) {
      super(), this.name = C, this.args = q, this.async = N;
    }
    render(C) {
      return `${this.async ? "async " : ""}function ${this.name}(${this.args})` + super.render(C);
    }
  }
  R.kind = "func";
  class I extends v {
    render(C) {
      return "return " + super.render(C);
    }
  }
  I.kind = "return";
  class D extends y {
    render(C) {
      let q = "try" + super.render(C);
      return this.catch && (q += this.catch.render(C)), this.finally && (q += this.finally.render(C)), q;
    }
    optimizeNodes() {
      var C, q;
      return super.optimizeNodes(), (C = this.catch) === null || C === void 0 || C.optimizeNodes(), (q = this.finally) === null || q === void 0 || q.optimizeNodes(), this;
    }
    optimizeNames(C, q) {
      var N, F;
      return super.optimizeNames(C, q), (N = this.catch) === null || N === void 0 || N.optimizeNames(C, q), (F = this.finally) === null || F === void 0 || F.optimizeNames(C, q), this;
    }
    get names() {
      const C = super.names;
      return this.catch && xe(C, this.catch.names), this.finally && xe(C, this.finally.names), C;
    }
  }
  class J extends y {
    constructor(C) {
      super(), this.error = C;
    }
    render(C) {
      return `catch(${this.error})` + super.render(C);
    }
  }
  J.kind = "catch";
  class ae extends y {
    render(C) {
      return "finally" + super.render(C);
    }
  }
  ae.kind = "finally";
  class ye {
    constructor(C, q = {}) {
      this._values = {}, this._blockStarts = [], this._constants = {}, this.opts = { ...q, _n: q.lines ? `
` : "" }, this._extScope = C, this._scope = new r.Scope({ parent: C }), this._nodes = [new g()];
    }
    toString() {
      return this._root.render(this.opts);
    }
    // returns unique name in the internal scope
    name(C) {
      return this._scope.name(C);
    }
    // reserves unique name in the external scope
    scopeName(C) {
      return this._extScope.name(C);
    }
    // reserves unique name in the external scope and assigns value to it
    scopeValue(C, q) {
      const N = this._extScope.value(C, q);
      return (this._values[N.prefix] || (this._values[N.prefix] = /* @__PURE__ */ new Set())).add(N), N;
    }
    getScopeValue(C, q) {
      return this._extScope.getValue(C, q);
    }
    // return code that assigns values in the external scope to the names that are used internally
    // (same names that were returned by gen.scopeName or gen.scopeValue)
    scopeRefs(C) {
      return this._extScope.scopeRefs(C, this._values);
    }
    scopeCode() {
      return this._extScope.scopeCode(this._values);
    }
    _def(C, q, N, F) {
      const T = this._scope.toName(q);
      return N !== void 0 && F && (this._constants[T.str] = N), this._leafNode(new a(C, T, N)), T;
    }
    // `const` declaration (`var` in es5 mode)
    const(C, q, N) {
      return this._def(r.varKinds.const, C, q, N);
    }
    // `let` declaration with optional assignment (`var` in es5 mode)
    let(C, q, N) {
      return this._def(r.varKinds.let, C, q, N);
    }
    // `var` declaration with optional assignment
    var(C, q, N) {
      return this._def(r.varKinds.var, C, q, N);
    }
    // assignment code
    assign(C, q, N) {
      return this._leafNode(new u(C, q, N));
    }
    // `+=` code
    add(C, q) {
      return this._leafNode(new c(C, e.operators.ADD, q));
    }
    // appends passed SafeExpr to code or executes Block
    code(C) {
      return typeof C == "function" ? C() : C !== t.nil && this._leafNode(new h(C)), this;
    }
    // returns code for object literal for the passed argument list of key-value pairs
    object(...C) {
      const q = ["{"];
      for (const [N, F] of C)
        q.length > 1 && q.push(","), q.push(N), (N !== F || this.opts.es5) && (q.push(":"), (0, t.addCodeArg)(q, F));
      return q.push("}"), new t._Code(q);
    }
    // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
    if(C, q, N) {
      if (this._blockNode(new m(C)), q && N)
        this.code(q).else().code(N).endIf();
      else if (q)
        this.code(q).endIf();
      else if (N)
        throw new Error('CodeGen: "else" body without "then" body');
      return this;
    }
    // `else if` clause - invalid without `if` or after `else` clauses
    elseIf(C) {
      return this._elseNode(new m(C));
    }
    // `else` clause - only valid after `if` or `else if` clauses
    else() {
      return this._elseNode(new _());
    }
    // end `if` statement (needed if gen.if was used only with condition)
    endIf() {
      return this._endBlockNode(m, _);
    }
    _for(C, q) {
      return this._blockNode(C), q && this.code(q).endFor(), this;
    }
    // a generic `for` clause (or statement if `forBody` is passed)
    for(C, q) {
      return this._for(new $(C), q);
    }
    // `for` statement for a range of values
    forRange(C, q, N, F, T = this.opts.es5 ? r.varKinds.var : r.varKinds.let) {
      const Z = this._scope.toName(C);
      return this._for(new E(T, Z, q, N), () => F(Z));
    }
    // `for-of` statement (in es5 mode replace with a normal for loop)
    forOf(C, q, N, F = r.varKinds.const) {
      const T = this._scope.toName(C);
      if (this.opts.es5) {
        const Z = q instanceof t.Name ? q : this.var("_arr", q);
        return this.forRange("_i", 0, (0, t._)`${Z}.length`, (Y) => {
          this.var(T, (0, t._)`${Z}[${Y}]`), N(T);
        });
      }
      return this._for(new A("of", F, T, q), () => N(T));
    }
    // `for-in` statement.
    // With option `ownProperties` replaced with a `for-of` loop for object keys
    forIn(C, q, N, F = this.opts.es5 ? r.varKinds.var : r.varKinds.const) {
      if (this.opts.ownProperties)
        return this.forOf(C, (0, t._)`Object.keys(${q})`, N);
      const T = this._scope.toName(C);
      return this._for(new A("in", F, T, q), () => N(T));
    }
    // end `for` loop
    endFor() {
      return this._endBlockNode(w);
    }
    // `label` statement
    label(C) {
      return this._leafNode(new l(C));
    }
    // `break` statement
    break(C) {
      return this._leafNode(new d(C));
    }
    // `return` statement
    return(C) {
      const q = new I();
      if (this._blockNode(q), this.code(C), q.nodes.length !== 1)
        throw new Error('CodeGen: "return" should have one node');
      return this._endBlockNode(I);
    }
    // `try` statement
    try(C, q, N) {
      if (!q && !N)
        throw new Error('CodeGen: "try" without "catch" and "finally"');
      const F = new D();
      if (this._blockNode(F), this.code(C), q) {
        const T = this.name("e");
        this._currNode = F.catch = new J(T), q(T);
      }
      return N && (this._currNode = F.finally = new ae(), this.code(N)), this._endBlockNode(J, ae);
    }
    // `throw` statement
    throw(C) {
      return this._leafNode(new p(C));
    }
    // start self-balancing block
    block(C, q) {
      return this._blockStarts.push(this._nodes.length), C && this.code(C).endBlock(q), this;
    }
    // end the current self-balancing block
    endBlock(C) {
      const q = this._blockStarts.pop();
      if (q === void 0)
        throw new Error("CodeGen: not in self-balancing block");
      const N = this._nodes.length - q;
      if (N < 0 || C !== void 0 && N !== C)
        throw new Error(`CodeGen: wrong number of nodes: ${N} vs ${C} expected`);
      return this._nodes.length = q, this;
    }
    // `function` heading (or definition if funcBody is passed)
    func(C, q = t.nil, N, F) {
      return this._blockNode(new R(C, q, N)), F && this.code(F).endFunc(), this;
    }
    // end function definition
    endFunc() {
      return this._endBlockNode(R);
    }
    optimize(C = 1) {
      for (; C-- > 0; )
        this._root.optimizeNodes(), this._root.optimizeNames(this._root.names, this._constants);
    }
    _leafNode(C) {
      return this._currNode.nodes.push(C), this;
    }
    _blockNode(C) {
      this._currNode.nodes.push(C), this._nodes.push(C);
    }
    _endBlockNode(C, q) {
      const N = this._currNode;
      if (N instanceof C || q && N instanceof q)
        return this._nodes.pop(), this;
      throw new Error(`CodeGen: not in block "${q ? `${C.kind}/${q.kind}` : C.kind}"`);
    }
    _elseNode(C) {
      const q = this._currNode;
      if (!(q instanceof m))
        throw new Error('CodeGen: "else" without "if"');
      return this._currNode = q.else = C, this;
    }
    get _root() {
      return this._nodes[0];
    }
    get _currNode() {
      const C = this._nodes;
      return C[C.length - 1];
    }
    set _currNode(C) {
      const q = this._nodes;
      q[q.length - 1] = C;
    }
  }
  e.CodeGen = ye;
  function xe(z, C) {
    for (const q in C)
      z[q] = (z[q] || 0) + (C[q] || 0);
    return z;
  }
  function je(z, C) {
    return C instanceof t._CodeOrName ? xe(z, C.names) : z;
  }
  function re(z, C, q) {
    if (z instanceof t.Name)
      return N(z);
    if (!F(z))
      return z;
    return new t._Code(z._items.reduce((T, Z) => (Z instanceof t.Name && (Z = N(Z)), Z instanceof t._Code ? T.push(...Z._items) : T.push(Z), T), []));
    function N(T) {
      const Z = q[T.str];
      return Z === void 0 || C[T.str] !== 1 ? T : (delete C[T.str], Z);
    }
    function F(T) {
      return T instanceof t._Code && T._items.some((Z) => Z instanceof t.Name && C[Z.str] === 1 && q[Z.str] !== void 0);
    }
  }
  function fe(z, C) {
    for (const q in C)
      z[q] = (z[q] || 0) - (C[q] || 0);
  }
  function le(z) {
    return typeof z == "boolean" || typeof z == "number" || z === null ? !z : (0, t._)`!${V(z)}`;
  }
  e.not = le;
  const $e = K(e.operators.AND);
  function Ae(...z) {
    return z.reduce($e);
  }
  e.and = Ae;
  const _e = K(e.operators.OR);
  function ie(...z) {
    return z.reduce(_e);
  }
  e.or = ie;
  function K(z) {
    return (C, q) => C === t.nil ? q : q === t.nil ? C : (0, t._)`${V(C)} ${z} ${V(q)}`;
  }
  function V(z) {
    return z instanceof t.Name ? z : (0, t._)`(${z})`;
  }
})(ht);
var Pt = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.checkStrictMode = e.getErrorPath = e.Type = e.useFunc = e.setEvaluated = e.evaluatedPropsToName = e.mergeEvaluated = e.eachItem = e.unescapeJsonPointer = e.escapeJsonPointer = e.escapeFragment = e.unescapeFragment = e.schemaRefOrVal = e.schemaHasRulesButRef = e.schemaHasRules = e.checkUnknownRules = e.alwaysValidSchema = e.toHash = void 0;
  const t = ht, r = Fu;
  function n(R) {
    const I = {};
    for (const D of R)
      I[D] = !0;
    return I;
  }
  e.toHash = n;
  function i(R, I) {
    return typeof I == "boolean" ? I : Object.keys(I).length === 0 ? !0 : (s(R, I), !a(I, R.self.RULES.all));
  }
  e.alwaysValidSchema = i;
  function s(R, I = R.schema) {
    const { opts: D, self: J } = R;
    if (!D.strictSchema || typeof I == "boolean")
      return;
    const ae = J.RULES.keywords;
    for (const ye in I)
      ae[ye] || A(R, `unknown keyword: "${ye}"`);
  }
  e.checkUnknownRules = s;
  function a(R, I) {
    if (typeof R == "boolean")
      return !R;
    for (const D in R)
      if (I[D])
        return !0;
    return !1;
  }
  e.schemaHasRules = a;
  function u(R, I) {
    if (typeof R == "boolean")
      return !R;
    for (const D in R)
      if (D !== "$ref" && I.all[D])
        return !0;
    return !1;
  }
  e.schemaHasRulesButRef = u;
  function c({ topSchemaRef: R, schemaPath: I }, D, J, ae) {
    if (!ae) {
      if (typeof D == "number" || typeof D == "boolean")
        return D;
      if (typeof D == "string")
        return (0, t._)`${D}`;
    }
    return (0, t._)`${R}${I}${(0, t.getProperty)(J)}`;
  }
  e.schemaRefOrVal = c;
  function l(R) {
    return h(decodeURIComponent(R));
  }
  e.unescapeFragment = l;
  function d(R) {
    return encodeURIComponent(p(R));
  }
  e.escapeFragment = d;
  function p(R) {
    return typeof R == "number" ? `${R}` : R.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  e.escapeJsonPointer = p;
  function h(R) {
    return R.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  e.unescapeJsonPointer = h;
  function v(R, I) {
    if (Array.isArray(R))
      for (const D of R)
        I(D);
    else
      I(R);
  }
  e.eachItem = v;
  function y({ mergeNames: R, mergeToName: I, mergeValues: D, resultToName: J }) {
    return (ae, ye, xe, je) => {
      const re = xe === void 0 ? ye : xe instanceof t.Name ? (ye instanceof t.Name ? R(ae, ye, xe) : I(ae, ye, xe), xe) : ye instanceof t.Name ? (I(ae, xe, ye), ye) : D(ye, xe);
      return je === t.Name && !(re instanceof t.Name) ? J(ae, re) : re;
    };
  }
  e.mergeEvaluated = {
    props: y({
      mergeNames: (R, I, D) => R.if((0, t._)`${D} !== true && ${I} !== undefined`, () => {
        R.if((0, t._)`${I} === true`, () => R.assign(D, !0), () => R.assign(D, (0, t._)`${D} || {}`).code((0, t._)`Object.assign(${D}, ${I})`));
      }),
      mergeToName: (R, I, D) => R.if((0, t._)`${D} !== true`, () => {
        I === !0 ? R.assign(D, !0) : (R.assign(D, (0, t._)`${D} || {}`), _(R, D, I));
      }),
      mergeValues: (R, I) => R === !0 ? !0 : { ...R, ...I },
      resultToName: g
    }),
    items: y({
      mergeNames: (R, I, D) => R.if((0, t._)`${D} !== true && ${I} !== undefined`, () => R.assign(D, (0, t._)`${I} === true ? true : ${D} > ${I} ? ${D} : ${I}`)),
      mergeToName: (R, I, D) => R.if((0, t._)`${D} !== true`, () => R.assign(D, I === !0 ? !0 : (0, t._)`${D} > ${I} ? ${D} : ${I}`)),
      mergeValues: (R, I) => R === !0 ? !0 : Math.max(R, I),
      resultToName: (R, I) => R.var("items", I)
    })
  };
  function g(R, I) {
    if (I === !0)
      return R.var("props", !0);
    const D = R.var("props", (0, t._)`{}`);
    return I !== void 0 && _(R, D, I), D;
  }
  e.evaluatedPropsToName = g;
  function _(R, I, D) {
    Object.keys(D).forEach((J) => R.assign((0, t._)`${I}${(0, t.getProperty)(J)}`, !0));
  }
  e.setEvaluated = _;
  const m = {};
  function w(R, I) {
    return R.scopeValue("func", {
      ref: I,
      code: m[I.code] || (m[I.code] = new r._Code(I.code))
    });
  }
  e.useFunc = w;
  var $;
  (function(R) {
    R[R.Num = 0] = "Num", R[R.Str = 1] = "Str";
  })($ = e.Type || (e.Type = {}));
  function E(R, I, D) {
    if (R instanceof t.Name) {
      const J = I === $.Num;
      return D ? J ? (0, t._)`"[" + ${R} + "]"` : (0, t._)`"['" + ${R} + "']"` : J ? (0, t._)`"/" + ${R}` : (0, t._)`"/" + ${R}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
    }
    return D ? (0, t.getProperty)(R).toString() : "/" + p(R);
  }
  e.getErrorPath = E;
  function A(R, I, D = R.opts.strictSchema) {
    if (D) {
      if (I = `strict mode: ${I}`, D === !0)
        throw new Error(I);
      R.self.logger.warn(I);
    }
  }
  e.checkStrictMode = A;
})(Pt);
var nn = {};
Object.defineProperty(nn, "__esModule", { value: !0 });
const xr = ht, AF = {
  // validation function arguments
  data: new xr.Name("data"),
  // args passed from referencing schema
  valCxt: new xr.Name("valCxt"),
  instancePath: new xr.Name("instancePath"),
  parentData: new xr.Name("parentData"),
  parentDataProperty: new xr.Name("parentDataProperty"),
  rootData: new xr.Name("rootData"),
  dynamicAnchors: new xr.Name("dynamicAnchors"),
  // function scoped variables
  vErrors: new xr.Name("vErrors"),
  errors: new xr.Name("errors"),
  this: new xr.Name("this"),
  // "globals"
  self: new xr.Name("self"),
  scope: new xr.Name("scope"),
  // JTD serialize/parse name for JSON string and position
  json: new xr.Name("json"),
  jsonPos: new xr.Name("jsonPos"),
  jsonLen: new xr.Name("jsonLen"),
  jsonPart: new xr.Name("jsonPart")
};
nn.default = AF;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.extendErrors = e.resetErrorsCount = e.reportExtraError = e.reportError = e.keyword$DataError = e.keywordError = void 0;
  const t = ht, r = Pt, n = nn;
  e.keywordError = {
    message: ({ keyword: _ }) => (0, t.str)`must pass "${_}" keyword validation`
  }, e.keyword$DataError = {
    message: ({ keyword: _, schemaType: m }) => m ? (0, t.str)`"${_}" keyword must be ${m} ($data)` : (0, t.str)`"${_}" keyword is invalid ($data)`
  };
  function i(_, m = e.keywordError, w, $) {
    const { it: E } = _, { gen: A, compositeRule: R, allErrors: I } = E, D = p(_, m, w);
    $ ?? (R || I) ? c(A, D) : l(E, (0, t._)`[${D}]`);
  }
  e.reportError = i;
  function s(_, m = e.keywordError, w) {
    const { it: $ } = _, { gen: E, compositeRule: A, allErrors: R } = $, I = p(_, m, w);
    c(E, I), A || R || l($, n.default.vErrors);
  }
  e.reportExtraError = s;
  function a(_, m) {
    _.assign(n.default.errors, m), _.if((0, t._)`${n.default.vErrors} !== null`, () => _.if(m, () => _.assign((0, t._)`${n.default.vErrors}.length`, m), () => _.assign(n.default.vErrors, null)));
  }
  e.resetErrorsCount = a;
  function u({ gen: _, keyword: m, schemaValue: w, data: $, errsCount: E, it: A }) {
    if (E === void 0)
      throw new Error("ajv implementation error");
    const R = _.name("err");
    _.forRange("i", E, n.default.errors, (I) => {
      _.const(R, (0, t._)`${n.default.vErrors}[${I}]`), _.if((0, t._)`${R}.instancePath === undefined`, () => _.assign((0, t._)`${R}.instancePath`, (0, t.strConcat)(n.default.instancePath, A.errorPath))), _.assign((0, t._)`${R}.schemaPath`, (0, t.str)`${A.errSchemaPath}/${m}`), A.opts.verbose && (_.assign((0, t._)`${R}.schema`, w), _.assign((0, t._)`${R}.data`, $));
    });
  }
  e.extendErrors = u;
  function c(_, m) {
    const w = _.const("err", m);
    _.if((0, t._)`${n.default.vErrors} === null`, () => _.assign(n.default.vErrors, (0, t._)`[${w}]`), (0, t._)`${n.default.vErrors}.push(${w})`), _.code((0, t._)`${n.default.errors}++`);
  }
  function l(_, m) {
    const { gen: w, validateName: $, schemaEnv: E } = _;
    E.$async ? w.throw((0, t._)`new ${_.ValidationError}(${m})`) : (w.assign((0, t._)`${$}.errors`, m), w.return(!1));
  }
  const d = {
    keyword: new t.Name("keyword"),
    schemaPath: new t.Name("schemaPath"),
    params: new t.Name("params"),
    propertyName: new t.Name("propertyName"),
    message: new t.Name("message"),
    schema: new t.Name("schema"),
    parentSchema: new t.Name("parentSchema")
  };
  function p(_, m, w) {
    const { createErrors: $ } = _.it;
    return $ === !1 ? (0, t._)`{}` : h(_, m, w);
  }
  function h(_, m, w = {}) {
    const { gen: $, it: E } = _, A = [
      v(E, w),
      y(_, w)
    ];
    return g(_, m, A), $.object(...A);
  }
  function v({ errorPath: _ }, { instancePath: m }) {
    const w = m ? (0, t.str)`${_}${(0, r.getErrorPath)(m, r.Type.Str)}` : _;
    return [n.default.instancePath, (0, t.strConcat)(n.default.instancePath, w)];
  }
  function y({ keyword: _, it: { errSchemaPath: m } }, { schemaPath: w, parentSchema: $ }) {
    let E = $ ? m : (0, t.str)`${m}/${_}`;
    return w && (E = (0, t.str)`${E}${(0, r.getErrorPath)(w, r.Type.Str)}`), [d.schemaPath, E];
  }
  function g(_, { params: m, message: w }, $) {
    const { keyword: E, data: A, schemaValue: R, it: I } = _, { opts: D, propertyName: J, topSchemaRef: ae, schemaPath: ye } = I;
    $.push([d.keyword, E], [d.params, typeof m == "function" ? m(_) : m || (0, t._)`{}`]), D.messages && $.push([d.message, typeof w == "function" ? w(_) : w]), D.verbose && $.push([d.schema, R], [d.parentSchema, (0, t._)`${ae}${ye}`], [n.default.data, A]), J && $.push([d.propertyName, J]);
  }
})(rc);
Object.defineProperty(ao, "__esModule", { value: !0 });
ao.boolOrEmptySchema = ao.topBoolOrEmptySchema = void 0;
const CF = rc, RF = ht, TF = nn, IF = {
  message: "boolean schema is false"
};
function jF(e) {
  const { gen: t, schema: r, validateName: n } = e;
  r === !1 ? aP(e, !1) : typeof r == "object" && r.$async === !0 ? t.return(TF.default.data) : (t.assign((0, RF._)`${n}.errors`, null), t.return(!0));
}
ao.topBoolOrEmptySchema = jF;
function kF(e, t) {
  const { gen: r, schema: n } = e;
  n === !1 ? (r.var(t, !1), aP(e)) : r.var(t, !0);
}
ao.boolOrEmptySchema = kF;
function aP(e, t) {
  const { gen: r, data: n } = e, i = {
    gen: r,
    keyword: "false schema",
    data: n,
    schema: !1,
    schemaCode: !1,
    schemaValue: !1,
    params: {},
    it: e
  };
  (0, CF.reportError)(i, IF, void 0, t);
}
var nc = {}, Qs = {};
Object.defineProperty(Qs, "__esModule", { value: !0 });
Qs.getRules = Qs.isJSONType = void 0;
const MF = ["string", "number", "integer", "boolean", "null", "object", "array"], NF = new Set(MF);
function DF(e) {
  return typeof e == "string" && NF.has(e);
}
Qs.isJSONType = DF;
function LF() {
  const e = {
    number: { type: "number", rules: [] },
    string: { type: "string", rules: [] },
    array: { type: "array", rules: [] },
    object: { type: "object", rules: [] }
  };
  return {
    types: { ...e, integer: !0, boolean: !0, null: !0 },
    rules: [{ rules: [] }, e.number, e.string, e.array, e.object],
    post: { rules: [] },
    all: {},
    keywords: {}
  };
}
Qs.getRules = LF;
var Oi = {};
Object.defineProperty(Oi, "__esModule", { value: !0 });
Oi.shouldUseRule = Oi.shouldUseGroup = Oi.schemaHasRulesForType = void 0;
function qF({ schema: e, self: t }, r) {
  const n = t.RULES.types[r];
  return n && n !== !0 && oP(e, n);
}
Oi.schemaHasRulesForType = qF;
function oP(e, t) {
  return t.rules.some((r) => uP(e, r));
}
Oi.shouldUseGroup = oP;
function uP(e, t) {
  var r;
  return e[t.keyword] !== void 0 || ((r = t.definition.implements) === null || r === void 0 ? void 0 : r.some((n) => e[n] !== void 0));
}
Oi.shouldUseRule = uP;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.reportTypeError = e.checkDataTypes = e.checkDataType = e.coerceAndCheckDataType = e.getJSONTypes = e.getSchemaTypes = e.DataType = void 0;
  const t = Qs, r = Oi, n = rc, i = ht, s = Pt;
  var a;
  (function($) {
    $[$.Correct = 0] = "Correct", $[$.Wrong = 1] = "Wrong";
  })(a = e.DataType || (e.DataType = {}));
  function u($) {
    const E = c($.type);
    if (E.includes("null")) {
      if ($.nullable === !1)
        throw new Error("type: null contradicts nullable: false");
    } else {
      if (!E.length && $.nullable !== void 0)
        throw new Error('"nullable" cannot be used without "type"');
      $.nullable === !0 && E.push("null");
    }
    return E;
  }
  e.getSchemaTypes = u;
  function c($) {
    const E = Array.isArray($) ? $ : $ ? [$] : [];
    if (E.every(t.isJSONType))
      return E;
    throw new Error("type must be JSONType or JSONType[]: " + E.join(","));
  }
  e.getJSONTypes = c;
  function l($, E) {
    const { gen: A, data: R, opts: I } = $, D = p(E, I.coerceTypes), J = E.length > 0 && !(D.length === 0 && E.length === 1 && (0, r.schemaHasRulesForType)($, E[0]));
    if (J) {
      const ae = g(E, R, I.strictNumbers, a.Wrong);
      A.if(ae, () => {
        D.length ? h($, E, D) : m($);
      });
    }
    return J;
  }
  e.coerceAndCheckDataType = l;
  const d = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
  function p($, E) {
    return E ? $.filter((A) => d.has(A) || E === "array" && A === "array") : [];
  }
  function h($, E, A) {
    const { gen: R, data: I, opts: D } = $, J = R.let("dataType", (0, i._)`typeof ${I}`), ae = R.let("coerced", (0, i._)`undefined`);
    D.coerceTypes === "array" && R.if((0, i._)`${J} == 'object' && Array.isArray(${I}) && ${I}.length == 1`, () => R.assign(I, (0, i._)`${I}[0]`).assign(J, (0, i._)`typeof ${I}`).if(g(E, I, D.strictNumbers), () => R.assign(ae, I))), R.if((0, i._)`${ae} !== undefined`);
    for (const xe of A)
      (d.has(xe) || xe === "array" && D.coerceTypes === "array") && ye(xe);
    R.else(), m($), R.endIf(), R.if((0, i._)`${ae} !== undefined`, () => {
      R.assign(I, ae), v($, ae);
    });
    function ye(xe) {
      switch (xe) {
        case "string":
          R.elseIf((0, i._)`${J} == "number" || ${J} == "boolean"`).assign(ae, (0, i._)`"" + ${I}`).elseIf((0, i._)`${I} === null`).assign(ae, (0, i._)`""`);
          return;
        case "number":
          R.elseIf((0, i._)`${J} == "boolean" || ${I} === null
              || (${J} == "string" && ${I} && ${I} == +${I})`).assign(ae, (0, i._)`+${I}`);
          return;
        case "integer":
          R.elseIf((0, i._)`${J} === "boolean" || ${I} === null
              || (${J} === "string" && ${I} && ${I} == +${I} && !(${I} % 1))`).assign(ae, (0, i._)`+${I}`);
          return;
        case "boolean":
          R.elseIf((0, i._)`${I} === "false" || ${I} === 0 || ${I} === null`).assign(ae, !1).elseIf((0, i._)`${I} === "true" || ${I} === 1`).assign(ae, !0);
          return;
        case "null":
          R.elseIf((0, i._)`${I} === "" || ${I} === 0 || ${I} === false`), R.assign(ae, null);
          return;
        case "array":
          R.elseIf((0, i._)`${J} === "string" || ${J} === "number"
              || ${J} === "boolean" || ${I} === null`).assign(ae, (0, i._)`[${I}]`);
      }
    }
  }
  function v({ gen: $, parentData: E, parentDataProperty: A }, R) {
    $.if((0, i._)`${E} !== undefined`, () => $.assign((0, i._)`${E}[${A}]`, R));
  }
  function y($, E, A, R = a.Correct) {
    const I = R === a.Correct ? i.operators.EQ : i.operators.NEQ;
    let D;
    switch ($) {
      case "null":
        return (0, i._)`${E} ${I} null`;
      case "array":
        D = (0, i._)`Array.isArray(${E})`;
        break;
      case "object":
        D = (0, i._)`${E} && typeof ${E} == "object" && !Array.isArray(${E})`;
        break;
      case "integer":
        D = J((0, i._)`!(${E} % 1) && !isNaN(${E})`);
        break;
      case "number":
        D = J();
        break;
      default:
        return (0, i._)`typeof ${E} ${I} ${$}`;
    }
    return R === a.Correct ? D : (0, i.not)(D);
    function J(ae = i.nil) {
      return (0, i.and)((0, i._)`typeof ${E} == "number"`, ae, A ? (0, i._)`isFinite(${E})` : i.nil);
    }
  }
  e.checkDataType = y;
  function g($, E, A, R) {
    if ($.length === 1)
      return y($[0], E, A, R);
    let I;
    const D = (0, s.toHash)($);
    if (D.array && D.object) {
      const J = (0, i._)`typeof ${E} != "object"`;
      I = D.null ? J : (0, i._)`!${E} || ${J}`, delete D.null, delete D.array, delete D.object;
    } else
      I = i.nil;
    D.number && delete D.integer;
    for (const J in D)
      I = (0, i.and)(I, y(J, E, A, R));
    return I;
  }
  e.checkDataTypes = g;
  const _ = {
    message: ({ schema: $ }) => `must be ${$}`,
    params: ({ schema: $, schemaValue: E }) => typeof $ == "string" ? (0, i._)`{type: ${$}}` : (0, i._)`{type: ${E}}`
  };
  function m($) {
    const E = w($);
    (0, n.reportError)(E, _);
  }
  e.reportTypeError = m;
  function w($) {
    const { gen: E, data: A, schema: R } = $, I = (0, s.schemaRefOrVal)($, R, "type");
    return {
      gen: E,
      keyword: "type",
      data: A,
      schema: R.type,
      schemaCode: I,
      schemaValue: I,
      parentSchema: R,
      params: {},
      it: $
    };
  }
})(nc);
var Jf = {};
Object.defineProperty(Jf, "__esModule", { value: !0 });
Jf.assignDefaults = void 0;
const Ia = ht, FF = Pt;
function UF(e, t) {
  const { properties: r, items: n } = e.schema;
  if (t === "object" && r)
    for (const i in r)
      zw(e, i, r[i].default);
  else
    t === "array" && Array.isArray(n) && n.forEach((i, s) => zw(e, s, i.default));
}
Jf.assignDefaults = UF;
function zw(e, t, r) {
  const { gen: n, compositeRule: i, data: s, opts: a } = e;
  if (r === void 0)
    return;
  const u = (0, Ia._)`${s}${(0, Ia.getProperty)(t)}`;
  if (i) {
    (0, FF.checkStrictMode)(e, `default is ignored for: ${u}`);
    return;
  }
  let c = (0, Ia._)`${u} === undefined`;
  a.useDefaults === "empty" && (c = (0, Ia._)`${c} || ${u} === null || ${u} === ""`), n.if(c, (0, Ia._)`${u} = ${(0, Ia.stringify)(r)}`);
}
var Xn = {}, xt = {};
Object.defineProperty(xt, "__esModule", { value: !0 });
xt.validateUnion = xt.validateArray = xt.usePattern = xt.callValidateCode = xt.schemaProperties = xt.allSchemaProperties = xt.noPropertyInData = xt.propertyInData = xt.isOwnProperty = xt.hasPropFunc = xt.reportMissingProp = xt.checkMissingProp = xt.checkReportMissingProp = void 0;
const Gt = ht, zg = Pt, Ji = nn, BF = Pt;
function VF(e, t) {
  const { gen: r, data: n, it: i } = e;
  r.if(Hg(r, n, t, i.opts.ownProperties), () => {
    e.setParams({ missingProperty: (0, Gt._)`${t}` }, !0), e.error();
  });
}
xt.checkReportMissingProp = VF;
function ZF({ gen: e, data: t, it: { opts: r } }, n, i) {
  return (0, Gt.or)(...n.map((s) => (0, Gt.and)(Hg(e, t, s, r.ownProperties), (0, Gt._)`${i} = ${s}`)));
}
xt.checkMissingProp = ZF;
function zF(e, t) {
  e.setParams({ missingProperty: t }, !0), e.error();
}
xt.reportMissingProp = zF;
function cP(e) {
  return e.scopeValue("func", {
    // eslint-disable-next-line @typescript-eslint/unbound-method
    ref: Object.prototype.hasOwnProperty,
    code: (0, Gt._)`Object.prototype.hasOwnProperty`
  });
}
xt.hasPropFunc = cP;
function Wg(e, t, r) {
  return (0, Gt._)`${cP(e)}.call(${t}, ${r})`;
}
xt.isOwnProperty = Wg;
function WF(e, t, r, n) {
  const i = (0, Gt._)`${t}${(0, Gt.getProperty)(r)} !== undefined`;
  return n ? (0, Gt._)`${i} && ${Wg(e, t, r)}` : i;
}
xt.propertyInData = WF;
function Hg(e, t, r, n) {
  const i = (0, Gt._)`${t}${(0, Gt.getProperty)(r)} === undefined`;
  return n ? (0, Gt.or)(i, (0, Gt.not)(Wg(e, t, r))) : i;
}
xt.noPropertyInData = Hg;
function lP(e) {
  return e ? Object.keys(e).filter((t) => t !== "__proto__") : [];
}
xt.allSchemaProperties = lP;
function HF(e, t) {
  return lP(t).filter((r) => !(0, zg.alwaysValidSchema)(e, t[r]));
}
xt.schemaProperties = HF;
function GF({ schemaCode: e, data: t, it: { gen: r, topSchemaRef: n, schemaPath: i, errorPath: s }, it: a }, u, c, l) {
  const d = l ? (0, Gt._)`${e}, ${t}, ${n}${i}` : t, p = [
    [Ji.default.instancePath, (0, Gt.strConcat)(Ji.default.instancePath, s)],
    [Ji.default.parentData, a.parentData],
    [Ji.default.parentDataProperty, a.parentDataProperty],
    [Ji.default.rootData, Ji.default.rootData]
  ];
  a.opts.dynamicRef && p.push([Ji.default.dynamicAnchors, Ji.default.dynamicAnchors]);
  const h = (0, Gt._)`${d}, ${r.object(...p)}`;
  return c !== Gt.nil ? (0, Gt._)`${u}.call(${c}, ${h})` : (0, Gt._)`${u}(${h})`;
}
xt.callValidateCode = GF;
const KF = (0, Gt._)`new RegExp`;
function YF({ gen: e, it: { opts: t } }, r) {
  const n = t.unicodeRegExp ? "u" : "", { regExp: i } = t.code, s = i(r, n);
  return e.scopeValue("pattern", {
    key: s.toString(),
    ref: s,
    code: (0, Gt._)`${i.code === "new RegExp" ? KF : (0, BF.useFunc)(e, i)}(${r}, ${n})`
  });
}
xt.usePattern = YF;
function JF(e) {
  const { gen: t, data: r, keyword: n, it: i } = e, s = t.name("valid");
  if (i.allErrors) {
    const u = t.let("valid", !0);
    return a(() => t.assign(u, !1)), u;
  }
  return t.var(s, !0), a(() => t.break()), s;
  function a(u) {
    const c = t.const("len", (0, Gt._)`${r}.length`);
    t.forRange("i", 0, c, (l) => {
      e.subschema({
        keyword: n,
        dataProp: l,
        dataPropType: zg.Type.Num
      }, s), t.if((0, Gt.not)(s), u);
    });
  }
}
xt.validateArray = JF;
function XF(e) {
  const { gen: t, schema: r, keyword: n, it: i } = e;
  if (!Array.isArray(r))
    throw new Error("ajv implementation error");
  if (r.some((c) => (0, zg.alwaysValidSchema)(i, c)) && !i.opts.unevaluated)
    return;
  const a = t.let("valid", !1), u = t.name("_valid");
  t.block(() => r.forEach((c, l) => {
    const d = e.subschema({
      keyword: n,
      schemaProp: l,
      compositeRule: !0
    }, u);
    t.assign(a, (0, Gt._)`${a} || ${u}`), e.mergeValidEvaluated(d, u) || t.if((0, Gt.not)(a));
  })), e.result(a, () => e.reset(), () => e.error(!0));
}
xt.validateUnion = XF;
Object.defineProperty(Xn, "__esModule", { value: !0 });
Xn.validateKeywordUsage = Xn.validSchemaType = Xn.funcKeywordCode = Xn.macroKeywordCode = void 0;
const Mr = ht, Ls = nn, QF = xt, eU = rc;
function tU(e, t) {
  const { gen: r, keyword: n, schema: i, parentSchema: s, it: a } = e, u = t.macro.call(a.self, i, s, a), c = fP(r, n, u);
  a.opts.validateSchema !== !1 && a.self.validateSchema(u, !0);
  const l = r.name("valid");
  e.subschema({
    schema: u,
    schemaPath: Mr.nil,
    errSchemaPath: `${a.errSchemaPath}/${n}`,
    topSchemaRef: c,
    compositeRule: !0
  }, l), e.pass(l, () => e.error(!0));
}
Xn.macroKeywordCode = tU;
function rU(e, t) {
  var r;
  const { gen: n, keyword: i, schema: s, parentSchema: a, $data: u, it: c } = e;
  iU(c, t);
  const l = !u && t.compile ? t.compile.call(c.self, s, a, c) : t.validate, d = fP(n, i, l), p = n.let("valid");
  e.block$data(p, h), e.ok((r = t.valid) !== null && r !== void 0 ? r : p);
  function h() {
    if (t.errors === !1)
      g(), t.modifying && Ww(e), _(() => e.error());
    else {
      const m = t.async ? v() : y();
      t.modifying && Ww(e), _(() => nU(e, m));
    }
  }
  function v() {
    const m = n.let("ruleErrs", null);
    return n.try(() => g((0, Mr._)`await `), (w) => n.assign(p, !1).if((0, Mr._)`${w} instanceof ${c.ValidationError}`, () => n.assign(m, (0, Mr._)`${w}.errors`), () => n.throw(w))), m;
  }
  function y() {
    const m = (0, Mr._)`${d}.errors`;
    return n.assign(m, null), g(Mr.nil), m;
  }
  function g(m = t.async ? (0, Mr._)`await ` : Mr.nil) {
    const w = c.opts.passContext ? Ls.default.this : Ls.default.self, $ = !("compile" in t && !u || t.schema === !1);
    n.assign(p, (0, Mr._)`${m}${(0, QF.callValidateCode)(e, d, w, $)}`, t.modifying);
  }
  function _(m) {
    var w;
    n.if((0, Mr.not)((w = t.valid) !== null && w !== void 0 ? w : p), m);
  }
}
Xn.funcKeywordCode = rU;
function Ww(e) {
  const { gen: t, data: r, it: n } = e;
  t.if(n.parentData, () => t.assign(r, (0, Mr._)`${n.parentData}[${n.parentDataProperty}]`));
}
function nU(e, t) {
  const { gen: r } = e;
  r.if((0, Mr._)`Array.isArray(${t})`, () => {
    r.assign(Ls.default.vErrors, (0, Mr._)`${Ls.default.vErrors} === null ? ${t} : ${Ls.default.vErrors}.concat(${t})`).assign(Ls.default.errors, (0, Mr._)`${Ls.default.vErrors}.length`), (0, eU.extendErrors)(e);
  }, () => e.error());
}
function iU({ schemaEnv: e }, t) {
  if (t.async && !e.$async)
    throw new Error("async keyword in sync schema");
}
function fP(e, t, r) {
  if (r === void 0)
    throw new Error(`keyword "${t}" failed to compile`);
  return e.scopeValue("keyword", typeof r == "function" ? { ref: r } : { ref: r, code: (0, Mr.stringify)(r) });
}
function sU(e, t, r = !1) {
  return !t.length || t.some((n) => n === "array" ? Array.isArray(e) : n === "object" ? e && typeof e == "object" && !Array.isArray(e) : typeof e == n || r && typeof e > "u");
}
Xn.validSchemaType = sU;
function aU({ schema: e, opts: t, self: r, errSchemaPath: n }, i, s) {
  if (Array.isArray(i.keyword) ? !i.keyword.includes(s) : i.keyword !== s)
    throw new Error("ajv implementation error");
  const a = i.dependencies;
  if (a != null && a.some((u) => !Object.prototype.hasOwnProperty.call(e, u)))
    throw new Error(`parent schema must have dependencies of ${s}: ${a.join(",")}`);
  if (i.validateSchema && !i.validateSchema(e[s])) {
    const c = `keyword "${s}" value is invalid at path "${n}": ` + r.errorsText(i.validateSchema.errors);
    if (t.validateSchema === "log")
      r.logger.error(c);
    else
      throw new Error(c);
  }
}
Xn.validateKeywordUsage = aU;
var us = {};
Object.defineProperty(us, "__esModule", { value: !0 });
us.extendSubschemaMode = us.extendSubschemaData = us.getSubschema = void 0;
const Yn = ht, dP = Pt;
function oU(e, { keyword: t, schemaProp: r, schema: n, schemaPath: i, errSchemaPath: s, topSchemaRef: a }) {
  if (t !== void 0 && n !== void 0)
    throw new Error('both "keyword" and "schema" passed, only one allowed');
  if (t !== void 0) {
    const u = e.schema[t];
    return r === void 0 ? {
      schema: u,
      schemaPath: (0, Yn._)`${e.schemaPath}${(0, Yn.getProperty)(t)}`,
      errSchemaPath: `${e.errSchemaPath}/${t}`
    } : {
      schema: u[r],
      schemaPath: (0, Yn._)`${e.schemaPath}${(0, Yn.getProperty)(t)}${(0, Yn.getProperty)(r)}`,
      errSchemaPath: `${e.errSchemaPath}/${t}/${(0, dP.escapeFragment)(r)}`
    };
  }
  if (n !== void 0) {
    if (i === void 0 || s === void 0 || a === void 0)
      throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
    return {
      schema: n,
      schemaPath: i,
      topSchemaRef: a,
      errSchemaPath: s
    };
  }
  throw new Error('either "keyword" or "schema" must be passed');
}
us.getSubschema = oU;
function uU(e, t, { dataProp: r, dataPropType: n, data: i, dataTypes: s, propertyName: a }) {
  if (i !== void 0 && r !== void 0)
    throw new Error('both "data" and "dataProp" passed, only one allowed');
  const { gen: u } = t;
  if (r !== void 0) {
    const { errorPath: l, dataPathArr: d, opts: p } = t, h = u.let("data", (0, Yn._)`${t.data}${(0, Yn.getProperty)(r)}`, !0);
    c(h), e.errorPath = (0, Yn.str)`${l}${(0, dP.getErrorPath)(r, n, p.jsPropertySyntax)}`, e.parentDataProperty = (0, Yn._)`${r}`, e.dataPathArr = [...d, e.parentDataProperty];
  }
  if (i !== void 0) {
    const l = i instanceof Yn.Name ? i : u.let("data", i, !0);
    c(l), a !== void 0 && (e.propertyName = a);
  }
  s && (e.dataTypes = s);
  function c(l) {
    e.data = l, e.dataLevel = t.dataLevel + 1, e.dataTypes = [], t.definedProperties = /* @__PURE__ */ new Set(), e.parentData = t.data, e.dataNames = [...t.dataNames, l];
  }
}
us.extendSubschemaData = uU;
function cU(e, { jtdDiscriminator: t, jtdMetadata: r, compositeRule: n, createErrors: i, allErrors: s }) {
  n !== void 0 && (e.compositeRule = n), i !== void 0 && (e.createErrors = i), s !== void 0 && (e.allErrors = s), e.jtdDiscriminator = t, e.jtdMetadata = r;
}
us.extendSubschemaMode = cU;
var vr = {}, pP = function e(t, r) {
  if (t === r)
    return !0;
  if (t && r && typeof t == "object" && typeof r == "object") {
    if (t.constructor !== r.constructor)
      return !1;
    var n, i, s;
    if (Array.isArray(t)) {
      if (n = t.length, n != r.length)
        return !1;
      for (i = n; i-- !== 0; )
        if (!e(t[i], r[i]))
          return !1;
      return !0;
    }
    if (t.constructor === RegExp)
      return t.source === r.source && t.flags === r.flags;
    if (t.valueOf !== Object.prototype.valueOf)
      return t.valueOf() === r.valueOf();
    if (t.toString !== Object.prototype.toString)
      return t.toString() === r.toString();
    if (s = Object.keys(t), n = s.length, n !== Object.keys(r).length)
      return !1;
    for (i = n; i-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(r, s[i]))
        return !1;
    for (i = n; i-- !== 0; ) {
      var a = s[i];
      if (!e(t[a], r[a]))
        return !1;
    }
    return !0;
  }
  return t !== t && r !== r;
}, hP = { exports: {} }, ss = hP.exports = function(e, t, r) {
  typeof t == "function" && (r = t, t = {}), r = t.cb || r;
  var n = typeof r == "function" ? r : r.pre || function() {
  }, i = r.post || function() {
  };
  kl(t, n, i, e, "", e);
};
ss.keywords = {
  additionalItems: !0,
  items: !0,
  contains: !0,
  additionalProperties: !0,
  propertyNames: !0,
  not: !0,
  if: !0,
  then: !0,
  else: !0
};
ss.arrayKeywords = {
  items: !0,
  allOf: !0,
  anyOf: !0,
  oneOf: !0
};
ss.propsKeywords = {
  $defs: !0,
  definitions: !0,
  properties: !0,
  patternProperties: !0,
  dependencies: !0
};
ss.skipKeywords = {
  default: !0,
  enum: !0,
  const: !0,
  required: !0,
  maximum: !0,
  minimum: !0,
  exclusiveMaximum: !0,
  exclusiveMinimum: !0,
  multipleOf: !0,
  maxLength: !0,
  minLength: !0,
  pattern: !0,
  format: !0,
  maxItems: !0,
  minItems: !0,
  uniqueItems: !0,
  maxProperties: !0,
  minProperties: !0
};
function kl(e, t, r, n, i, s, a, u, c, l) {
  if (n && typeof n == "object" && !Array.isArray(n)) {
    t(n, i, s, a, u, c, l);
    for (var d in n) {
      var p = n[d];
      if (Array.isArray(p)) {
        if (d in ss.arrayKeywords)
          for (var h = 0; h < p.length; h++)
            kl(e, t, r, p[h], i + "/" + d + "/" + h, s, i, d, n, h);
      } else if (d in ss.propsKeywords) {
        if (p && typeof p == "object")
          for (var v in p)
            kl(e, t, r, p[v], i + "/" + d + "/" + lU(v), s, i, d, n, v);
      } else
        (d in ss.keywords || e.allKeys && !(d in ss.skipKeywords)) && kl(e, t, r, p, i + "/" + d, s, i, d, n);
    }
    r(n, i, s, a, u, c, l);
  }
}
function lU(e) {
  return e.replace(/~/g, "~0").replace(/\//g, "~1");
}
var fU = hP.exports;
Object.defineProperty(vr, "__esModule", { value: !0 });
vr.getSchemaRefs = vr.resolveUrl = vr.normalizeId = vr._getFullPath = vr.getFullPath = vr.inlineRef = void 0;
const dU = Pt, pU = pP, hU = fU, mU = /* @__PURE__ */ new Set([
  "type",
  "format",
  "pattern",
  "maxLength",
  "minLength",
  "maxProperties",
  "minProperties",
  "maxItems",
  "minItems",
  "maximum",
  "minimum",
  "uniqueItems",
  "multipleOf",
  "required",
  "enum",
  "const"
]);
function yU(e, t = !0) {
  return typeof e == "boolean" ? !0 : t === !0 ? !Dy(e) : t ? mP(e) <= t : !1;
}
vr.inlineRef = yU;
const gU = /* @__PURE__ */ new Set([
  "$ref",
  "$recursiveRef",
  "$recursiveAnchor",
  "$dynamicRef",
  "$dynamicAnchor"
]);
function Dy(e) {
  for (const t in e) {
    if (gU.has(t))
      return !0;
    const r = e[t];
    if (Array.isArray(r) && r.some(Dy) || typeof r == "object" && Dy(r))
      return !0;
  }
  return !1;
}
function mP(e) {
  let t = 0;
  for (const r in e) {
    if (r === "$ref")
      return 1 / 0;
    if (t++, !mU.has(r) && (typeof e[r] == "object" && (0, dU.eachItem)(e[r], (n) => t += mP(n)), t === 1 / 0))
      return 1 / 0;
  }
  return t;
}
function yP(e, t = "", r) {
  r !== !1 && (t = Xa(t));
  const n = e.parse(t);
  return gP(e, n);
}
vr.getFullPath = yP;
function gP(e, t) {
  return e.serialize(t).split("#")[0] + "#";
}
vr._getFullPath = gP;
const vU = /#\/?$/;
function Xa(e) {
  return e ? e.replace(vU, "") : "";
}
vr.normalizeId = Xa;
function bU(e, t, r) {
  return r = Xa(r), e.resolve(t, r);
}
vr.resolveUrl = bU;
const _U = /^[a-z_][-a-z0-9._]*$/i;
function wU(e, t) {
  if (typeof e == "boolean")
    return {};
  const { schemaId: r, uriResolver: n } = this.opts, i = Xa(e[r] || t), s = { "": i }, a = yP(n, i, !1), u = {}, c = /* @__PURE__ */ new Set();
  return hU(e, { allKeys: !0 }, (p, h, v, y) => {
    if (y === void 0)
      return;
    const g = a + h;
    let _ = s[y];
    typeof p[r] == "string" && (_ = m.call(this, p[r])), w.call(this, p.$anchor), w.call(this, p.$dynamicAnchor), s[h] = _;
    function m($) {
      const E = this.opts.uriResolver.resolve;
      if ($ = Xa(_ ? E(_, $) : $), c.has($))
        throw d($);
      c.add($);
      let A = this.refs[$];
      return typeof A == "string" && (A = this.refs[A]), typeof A == "object" ? l(p, A.schema, $) : $ !== Xa(g) && ($[0] === "#" ? (l(p, u[$], $), u[$] = p) : this.refs[$] = g), $;
    }
    function w($) {
      if (typeof $ == "string") {
        if (!_U.test($))
          throw new Error(`invalid anchor "${$}"`);
        m.call(this, `#${$}`);
      }
    }
  }), u;
  function l(p, h, v) {
    if (h !== void 0 && !pU(p, h))
      throw d(v);
  }
  function d(p) {
    return new Error(`reference "${p}" resolves to more than one schema`);
  }
}
vr.getSchemaRefs = wU;
Object.defineProperty(jn, "__esModule", { value: !0 });
jn.getData = jn.KeywordCxt = jn.validateFunctionCode = void 0;
const vP = ao, Hw = nc, Gg = Oi, mf = nc, $U = Jf, du = Xn, Hh = us, Qe = ht, lt = nn, EU = vr, Pi = Pt, Yo = rc;
function xU(e) {
  if (wP(e) && ($P(e), _P(e))) {
    SU(e);
    return;
  }
  bP(e, () => (0, vP.topBoolOrEmptySchema)(e));
}
jn.validateFunctionCode = xU;
function bP({ gen: e, validateName: t, schema: r, schemaEnv: n, opts: i }, s) {
  i.code.es5 ? e.func(t, (0, Qe._)`${lt.default.data}, ${lt.default.valCxt}`, n.$async, () => {
    e.code((0, Qe._)`"use strict"; ${Gw(r, i)}`), PU(e, i), e.code(s);
  }) : e.func(t, (0, Qe._)`${lt.default.data}, ${OU(i)}`, n.$async, () => e.code(Gw(r, i)).code(s));
}
function OU(e) {
  return (0, Qe._)`{${lt.default.instancePath}="", ${lt.default.parentData}, ${lt.default.parentDataProperty}, ${lt.default.rootData}=${lt.default.data}${e.dynamicRef ? (0, Qe._)`, ${lt.default.dynamicAnchors}={}` : Qe.nil}}={}`;
}
function PU(e, t) {
  e.if(lt.default.valCxt, () => {
    e.var(lt.default.instancePath, (0, Qe._)`${lt.default.valCxt}.${lt.default.instancePath}`), e.var(lt.default.parentData, (0, Qe._)`${lt.default.valCxt}.${lt.default.parentData}`), e.var(lt.default.parentDataProperty, (0, Qe._)`${lt.default.valCxt}.${lt.default.parentDataProperty}`), e.var(lt.default.rootData, (0, Qe._)`${lt.default.valCxt}.${lt.default.rootData}`), t.dynamicRef && e.var(lt.default.dynamicAnchors, (0, Qe._)`${lt.default.valCxt}.${lt.default.dynamicAnchors}`);
  }, () => {
    e.var(lt.default.instancePath, (0, Qe._)`""`), e.var(lt.default.parentData, (0, Qe._)`undefined`), e.var(lt.default.parentDataProperty, (0, Qe._)`undefined`), e.var(lt.default.rootData, lt.default.data), t.dynamicRef && e.var(lt.default.dynamicAnchors, (0, Qe._)`{}`);
  });
}
function SU(e) {
  const { schema: t, opts: r, gen: n } = e;
  bP(e, () => {
    r.$comment && t.$comment && xP(e), IU(e), n.let(lt.default.vErrors, null), n.let(lt.default.errors, 0), r.unevaluated && AU(e), EP(e), MU(e);
  });
}
function AU(e) {
  const { gen: t, validateName: r } = e;
  e.evaluated = t.const("evaluated", (0, Qe._)`${r}.evaluated`), t.if((0, Qe._)`${e.evaluated}.dynamicProps`, () => t.assign((0, Qe._)`${e.evaluated}.props`, (0, Qe._)`undefined`)), t.if((0, Qe._)`${e.evaluated}.dynamicItems`, () => t.assign((0, Qe._)`${e.evaluated}.items`, (0, Qe._)`undefined`));
}
function Gw(e, t) {
  const r = typeof e == "object" && e[t.schemaId];
  return r && (t.code.source || t.code.process) ? (0, Qe._)`/*# sourceURL=${r} */` : Qe.nil;
}
function CU(e, t) {
  if (wP(e) && ($P(e), _P(e))) {
    RU(e, t);
    return;
  }
  (0, vP.boolOrEmptySchema)(e, t);
}
function _P({ schema: e, self: t }) {
  if (typeof e == "boolean")
    return !e;
  for (const r in e)
    if (t.RULES.all[r])
      return !0;
  return !1;
}
function wP(e) {
  return typeof e.schema != "boolean";
}
function RU(e, t) {
  const { schema: r, gen: n, opts: i } = e;
  i.$comment && r.$comment && xP(e), jU(e), kU(e);
  const s = n.const("_errs", lt.default.errors);
  EP(e, s), n.var(t, (0, Qe._)`${s} === ${lt.default.errors}`);
}
function $P(e) {
  (0, Pi.checkUnknownRules)(e), TU(e);
}
function EP(e, t) {
  if (e.opts.jtd)
    return Kw(e, [], !1, t);
  const r = (0, Hw.getSchemaTypes)(e.schema), n = (0, Hw.coerceAndCheckDataType)(e, r);
  Kw(e, r, !n, t);
}
function TU(e) {
  const { schema: t, errSchemaPath: r, opts: n, self: i } = e;
  t.$ref && n.ignoreKeywordsWithRef && (0, Pi.schemaHasRulesButRef)(t, i.RULES) && i.logger.warn(`$ref: keywords ignored in schema at path "${r}"`);
}
function IU(e) {
  const { schema: t, opts: r } = e;
  t.default !== void 0 && r.useDefaults && r.strictSchema && (0, Pi.checkStrictMode)(e, "default is ignored in the schema root");
}
function jU(e) {
  const t = e.schema[e.opts.schemaId];
  t && (e.baseId = (0, EU.resolveUrl)(e.opts.uriResolver, e.baseId, t));
}
function kU(e) {
  if (e.schema.$async && !e.schemaEnv.$async)
    throw new Error("async schema in sync schema");
}
function xP({ gen: e, schemaEnv: t, schema: r, errSchemaPath: n, opts: i }) {
  const s = r.$comment;
  if (i.$comment === !0)
    e.code((0, Qe._)`${lt.default.self}.logger.log(${s})`);
  else if (typeof i.$comment == "function") {
    const a = (0, Qe.str)`${n}/$comment`, u = e.scopeValue("root", { ref: t.root });
    e.code((0, Qe._)`${lt.default.self}.opts.$comment(${s}, ${a}, ${u}.schema)`);
  }
}
function MU(e) {
  const { gen: t, schemaEnv: r, validateName: n, ValidationError: i, opts: s } = e;
  r.$async ? t.if((0, Qe._)`${lt.default.errors} === 0`, () => t.return(lt.default.data), () => t.throw((0, Qe._)`new ${i}(${lt.default.vErrors})`)) : (t.assign((0, Qe._)`${n}.errors`, lt.default.vErrors), s.unevaluated && NU(e), t.return((0, Qe._)`${lt.default.errors} === 0`));
}
function NU({ gen: e, evaluated: t, props: r, items: n }) {
  r instanceof Qe.Name && e.assign((0, Qe._)`${t}.props`, r), n instanceof Qe.Name && e.assign((0, Qe._)`${t}.items`, n);
}
function Kw(e, t, r, n) {
  const { gen: i, schema: s, data: a, allErrors: u, opts: c, self: l } = e, { RULES: d } = l;
  if (s.$ref && (c.ignoreKeywordsWithRef || !(0, Pi.schemaHasRulesButRef)(s, d))) {
    i.block(() => SP(e, "$ref", d.all.$ref.definition));
    return;
  }
  c.jtd || DU(e, t), i.block(() => {
    for (const h of d.rules)
      p(h);
    p(d.post);
  });
  function p(h) {
    (0, Gg.shouldUseGroup)(s, h) && (h.type ? (i.if((0, mf.checkDataType)(h.type, a, c.strictNumbers)), Yw(e, h), t.length === 1 && t[0] === h.type && r && (i.else(), (0, mf.reportTypeError)(e)), i.endIf()) : Yw(e, h), u || i.if((0, Qe._)`${lt.default.errors} === ${n || 0}`));
  }
}
function Yw(e, t) {
  const { gen: r, schema: n, opts: { useDefaults: i } } = e;
  i && (0, $U.assignDefaults)(e, t.type), r.block(() => {
    for (const s of t.rules)
      (0, Gg.shouldUseRule)(n, s) && SP(e, s.keyword, s.definition, t.type);
  });
}
function DU(e, t) {
  e.schemaEnv.meta || !e.opts.strictTypes || (LU(e, t), e.opts.allowUnionTypes || qU(e, t), FU(e, e.dataTypes));
}
function LU(e, t) {
  if (t.length) {
    if (!e.dataTypes.length) {
      e.dataTypes = t;
      return;
    }
    t.forEach((r) => {
      OP(e.dataTypes, r) || Kg(e, `type "${r}" not allowed by context "${e.dataTypes.join(",")}"`);
    }), BU(e, t);
  }
}
function qU(e, t) {
  t.length > 1 && !(t.length === 2 && t.includes("null")) && Kg(e, "use allowUnionTypes to allow union type keyword");
}
function FU(e, t) {
  const r = e.self.RULES.all;
  for (const n in r) {
    const i = r[n];
    if (typeof i == "object" && (0, Gg.shouldUseRule)(e.schema, i)) {
      const { type: s } = i.definition;
      s.length && !s.some((a) => UU(t, a)) && Kg(e, `missing type "${s.join(",")}" for keyword "${n}"`);
    }
  }
}
function UU(e, t) {
  return e.includes(t) || t === "number" && e.includes("integer");
}
function OP(e, t) {
  return e.includes(t) || t === "integer" && e.includes("number");
}
function BU(e, t) {
  const r = [];
  for (const n of e.dataTypes)
    OP(t, n) ? r.push(n) : t.includes("integer") && n === "number" && r.push("integer");
  e.dataTypes = r;
}
function Kg(e, t) {
  const r = e.schemaEnv.baseId + e.errSchemaPath;
  t += ` at "${r}" (strictTypes)`, (0, Pi.checkStrictMode)(e, t, e.opts.strictTypes);
}
class PP {
  constructor(t, r, n) {
    if ((0, du.validateKeywordUsage)(t, r, n), this.gen = t.gen, this.allErrors = t.allErrors, this.keyword = n, this.data = t.data, this.schema = t.schema[n], this.$data = r.$data && t.opts.$data && this.schema && this.schema.$data, this.schemaValue = (0, Pi.schemaRefOrVal)(t, this.schema, n, this.$data), this.schemaType = r.schemaType, this.parentSchema = t.schema, this.params = {}, this.it = t, this.def = r, this.$data)
      this.schemaCode = t.gen.const("vSchema", AP(this.$data, t));
    else if (this.schemaCode = this.schemaValue, !(0, du.validSchemaType)(this.schema, r.schemaType, r.allowUndefined))
      throw new Error(`${n} value must be ${JSON.stringify(r.schemaType)}`);
    ("code" in r ? r.trackErrors : r.errors !== !1) && (this.errsCount = t.gen.const("_errs", lt.default.errors));
  }
  result(t, r, n) {
    this.failResult((0, Qe.not)(t), r, n);
  }
  failResult(t, r, n) {
    this.gen.if(t), n ? n() : this.error(), r ? (this.gen.else(), r(), this.allErrors && this.gen.endIf()) : this.allErrors ? this.gen.endIf() : this.gen.else();
  }
  pass(t, r) {
    this.failResult((0, Qe.not)(t), void 0, r);
  }
  fail(t) {
    if (t === void 0) {
      this.error(), this.allErrors || this.gen.if(!1);
      return;
    }
    this.gen.if(t), this.error(), this.allErrors ? this.gen.endIf() : this.gen.else();
  }
  fail$data(t) {
    if (!this.$data)
      return this.fail(t);
    const { schemaCode: r } = this;
    this.fail((0, Qe._)`${r} !== undefined && (${(0, Qe.or)(this.invalid$data(), t)})`);
  }
  error(t, r, n) {
    if (r) {
      this.setParams(r), this._error(t, n), this.setParams({});
      return;
    }
    this._error(t, n);
  }
  _error(t, r) {
    (t ? Yo.reportExtraError : Yo.reportError)(this, this.def.error, r);
  }
  $dataError() {
    (0, Yo.reportError)(this, this.def.$dataError || Yo.keyword$DataError);
  }
  reset() {
    if (this.errsCount === void 0)
      throw new Error('add "trackErrors" to keyword definition');
    (0, Yo.resetErrorsCount)(this.gen, this.errsCount);
  }
  ok(t) {
    this.allErrors || this.gen.if(t);
  }
  setParams(t, r) {
    r ? Object.assign(this.params, t) : this.params = t;
  }
  block$data(t, r, n = Qe.nil) {
    this.gen.block(() => {
      this.check$data(t, n), r();
    });
  }
  check$data(t = Qe.nil, r = Qe.nil) {
    if (!this.$data)
      return;
    const { gen: n, schemaCode: i, schemaType: s, def: a } = this;
    n.if((0, Qe.or)((0, Qe._)`${i} === undefined`, r)), t !== Qe.nil && n.assign(t, !0), (s.length || a.validateSchema) && (n.elseIf(this.invalid$data()), this.$dataError(), t !== Qe.nil && n.assign(t, !1)), n.else();
  }
  invalid$data() {
    const { gen: t, schemaCode: r, schemaType: n, def: i, it: s } = this;
    return (0, Qe.or)(a(), u());
    function a() {
      if (n.length) {
        if (!(r instanceof Qe.Name))
          throw new Error("ajv implementation error");
        const c = Array.isArray(n) ? n : [n];
        return (0, Qe._)`${(0, mf.checkDataTypes)(c, r, s.opts.strictNumbers, mf.DataType.Wrong)}`;
      }
      return Qe.nil;
    }
    function u() {
      if (i.validateSchema) {
        const c = t.scopeValue("validate$data", { ref: i.validateSchema });
        return (0, Qe._)`!${c}(${r})`;
      }
      return Qe.nil;
    }
  }
  subschema(t, r) {
    const n = (0, Hh.getSubschema)(this.it, t);
    (0, Hh.extendSubschemaData)(n, this.it, t), (0, Hh.extendSubschemaMode)(n, t);
    const i = { ...this.it, ...n, items: void 0, props: void 0 };
    return CU(i, r), i;
  }
  mergeEvaluated(t, r) {
    const { it: n, gen: i } = this;
    n.opts.unevaluated && (n.props !== !0 && t.props !== void 0 && (n.props = Pi.mergeEvaluated.props(i, t.props, n.props, r)), n.items !== !0 && t.items !== void 0 && (n.items = Pi.mergeEvaluated.items(i, t.items, n.items, r)));
  }
  mergeValidEvaluated(t, r) {
    const { it: n, gen: i } = this;
    if (n.opts.unevaluated && (n.props !== !0 || n.items !== !0))
      return i.if(r, () => this.mergeEvaluated(t, Qe.Name)), !0;
  }
}
jn.KeywordCxt = PP;
function SP(e, t, r, n) {
  const i = new PP(e, r, t);
  "code" in r ? r.code(i, n) : i.$data && r.validate ? (0, du.funcKeywordCode)(i, r) : "macro" in r ? (0, du.macroKeywordCode)(i, r) : (r.compile || r.validate) && (0, du.funcKeywordCode)(i, r);
}
const VU = /^\/(?:[^~]|~0|~1)*$/, ZU = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function AP(e, { dataLevel: t, dataNames: r, dataPathArr: n }) {
  let i, s;
  if (e === "")
    return lt.default.rootData;
  if (e[0] === "/") {
    if (!VU.test(e))
      throw new Error(`Invalid JSON-pointer: ${e}`);
    i = e, s = lt.default.rootData;
  } else {
    const l = ZU.exec(e);
    if (!l)
      throw new Error(`Invalid JSON-pointer: ${e}`);
    const d = +l[1];
    if (i = l[2], i === "#") {
      if (d >= t)
        throw new Error(c("property/index", d));
      return n[t - d];
    }
    if (d > t)
      throw new Error(c("data", d));
    if (s = r[t - d], !i)
      return s;
  }
  let a = s;
  const u = i.split("/");
  for (const l of u)
    l && (s = (0, Qe._)`${s}${(0, Qe.getProperty)((0, Pi.unescapeJsonPointer)(l))}`, a = (0, Qe._)`${a} && ${s}`);
  return a;
  function c(l, d) {
    return `Cannot access ${l} ${d} levels up, current level is ${t}`;
  }
}
jn.getData = AP;
var ic = {};
Object.defineProperty(ic, "__esModule", { value: !0 });
class zU extends Error {
  constructor(t) {
    super("validation failed"), this.errors = t, this.ajv = this.validation = !0;
  }
}
ic.default = zU;
var sc = {};
Object.defineProperty(sc, "__esModule", { value: !0 });
const Gh = vr;
class WU extends Error {
  constructor(t, r, n, i) {
    super(i || `can't resolve reference ${n} from id ${r}`), this.missingRef = (0, Gh.resolveUrl)(t, r, n), this.missingSchema = (0, Gh.normalizeId)((0, Gh.getFullPath)(t, this.missingRef));
  }
}
sc.default = WU;
var Nr = {};
Object.defineProperty(Nr, "__esModule", { value: !0 });
Nr.resolveSchema = Nr.getCompilingSchema = Nr.resolveRef = Nr.compileSchema = Nr.SchemaEnv = void 0;
const xn = ht, HU = ic, Ms = nn, Cn = vr, Jw = Pt, GU = jn;
class Xf {
  constructor(t) {
    var r;
    this.refs = {}, this.dynamicAnchors = {};
    let n;
    typeof t.schema == "object" && (n = t.schema), this.schema = t.schema, this.schemaId = t.schemaId, this.root = t.root || this, this.baseId = (r = t.baseId) !== null && r !== void 0 ? r : (0, Cn.normalizeId)(n == null ? void 0 : n[t.schemaId || "$id"]), this.schemaPath = t.schemaPath, this.localRefs = t.localRefs, this.meta = t.meta, this.$async = n == null ? void 0 : n.$async, this.refs = {};
  }
}
Nr.SchemaEnv = Xf;
function Yg(e) {
  const t = CP.call(this, e);
  if (t)
    return t;
  const r = (0, Cn.getFullPath)(this.opts.uriResolver, e.root.baseId), { es5: n, lines: i } = this.opts.code, { ownProperties: s } = this.opts, a = new xn.CodeGen(this.scope, { es5: n, lines: i, ownProperties: s });
  let u;
  e.$async && (u = a.scopeValue("Error", {
    ref: HU.default,
    code: (0, xn._)`require("ajv/dist/runtime/validation_error").default`
  }));
  const c = a.scopeName("validate");
  e.validateName = c;
  const l = {
    gen: a,
    allErrors: this.opts.allErrors,
    data: Ms.default.data,
    parentData: Ms.default.parentData,
    parentDataProperty: Ms.default.parentDataProperty,
    dataNames: [Ms.default.data],
    dataPathArr: [xn.nil],
    dataLevel: 0,
    dataTypes: [],
    definedProperties: /* @__PURE__ */ new Set(),
    topSchemaRef: a.scopeValue("schema", this.opts.code.source === !0 ? { ref: e.schema, code: (0, xn.stringify)(e.schema) } : { ref: e.schema }),
    validateName: c,
    ValidationError: u,
    schema: e.schema,
    schemaEnv: e,
    rootId: r,
    baseId: e.baseId || r,
    schemaPath: xn.nil,
    errSchemaPath: e.schemaPath || (this.opts.jtd ? "" : "#"),
    errorPath: (0, xn._)`""`,
    opts: this.opts,
    self: this
  };
  let d;
  try {
    this._compilations.add(e), (0, GU.validateFunctionCode)(l), a.optimize(this.opts.code.optimize);
    const p = a.toString();
    d = `${a.scopeRefs(Ms.default.scope)}return ${p}`, this.opts.code.process && (d = this.opts.code.process(d, e));
    const v = new Function(`${Ms.default.self}`, `${Ms.default.scope}`, d)(this, this.scope.get());
    if (this.scope.value(c, { ref: v }), v.errors = null, v.schema = e.schema, v.schemaEnv = e, e.$async && (v.$async = !0), this.opts.code.source === !0 && (v.source = { validateName: c, validateCode: p, scopeValues: a._values }), this.opts.unevaluated) {
      const { props: y, items: g } = l;
      v.evaluated = {
        props: y instanceof xn.Name ? void 0 : y,
        items: g instanceof xn.Name ? void 0 : g,
        dynamicProps: y instanceof xn.Name,
        dynamicItems: g instanceof xn.Name
      }, v.source && (v.source.evaluated = (0, xn.stringify)(v.evaluated));
    }
    return e.validate = v, e;
  } catch (p) {
    throw delete e.validate, delete e.validateName, d && this.logger.error("Error compiling schema, function code:", d), p;
  } finally {
    this._compilations.delete(e);
  }
}
Nr.compileSchema = Yg;
function KU(e, t, r) {
  var n;
  r = (0, Cn.resolveUrl)(this.opts.uriResolver, t, r);
  const i = e.refs[r];
  if (i)
    return i;
  let s = XU.call(this, e, r);
  if (s === void 0) {
    const a = (n = e.localRefs) === null || n === void 0 ? void 0 : n[r], { schemaId: u } = this.opts;
    a && (s = new Xf({ schema: a, schemaId: u, root: e, baseId: t }));
  }
  if (s !== void 0)
    return e.refs[r] = YU.call(this, s);
}
Nr.resolveRef = KU;
function YU(e) {
  return (0, Cn.inlineRef)(e.schema, this.opts.inlineRefs) ? e.schema : e.validate ? e : Yg.call(this, e);
}
function CP(e) {
  for (const t of this._compilations)
    if (JU(t, e))
      return t;
}
Nr.getCompilingSchema = CP;
function JU(e, t) {
  return e.schema === t.schema && e.root === t.root && e.baseId === t.baseId;
}
function XU(e, t) {
  let r;
  for (; typeof (r = this.refs[t]) == "string"; )
    t = r;
  return r || this.schemas[t] || Qf.call(this, e, t);
}
function Qf(e, t) {
  const r = this.opts.uriResolver.parse(t), n = (0, Cn._getFullPath)(this.opts.uriResolver, r);
  let i = (0, Cn.getFullPath)(this.opts.uriResolver, e.baseId, void 0);
  if (Object.keys(e.schema).length > 0 && n === i)
    return Kh.call(this, r, e);
  const s = (0, Cn.normalizeId)(n), a = this.refs[s] || this.schemas[s];
  if (typeof a == "string") {
    const u = Qf.call(this, e, a);
    return typeof (u == null ? void 0 : u.schema) != "object" ? void 0 : Kh.call(this, r, u);
  }
  if (typeof (a == null ? void 0 : a.schema) == "object") {
    if (a.validate || Yg.call(this, a), s === (0, Cn.normalizeId)(t)) {
      const { schema: u } = a, { schemaId: c } = this.opts, l = u[c];
      return l && (i = (0, Cn.resolveUrl)(this.opts.uriResolver, i, l)), new Xf({ schema: u, schemaId: c, root: e, baseId: i });
    }
    return Kh.call(this, r, a);
  }
}
Nr.resolveSchema = Qf;
const QU = /* @__PURE__ */ new Set([
  "properties",
  "patternProperties",
  "enum",
  "dependencies",
  "definitions"
]);
function Kh(e, { baseId: t, schema: r, root: n }) {
  var i;
  if (((i = e.fragment) === null || i === void 0 ? void 0 : i[0]) !== "/")
    return;
  for (const u of e.fragment.slice(1).split("/")) {
    if (typeof r == "boolean")
      return;
    const c = r[(0, Jw.unescapeFragment)(u)];
    if (c === void 0)
      return;
    r = c;
    const l = typeof r == "object" && r[this.opts.schemaId];
    !QU.has(u) && l && (t = (0, Cn.resolveUrl)(this.opts.uriResolver, t, l));
  }
  let s;
  if (typeof r != "boolean" && r.$ref && !(0, Jw.schemaHasRulesButRef)(r, this.RULES)) {
    const u = (0, Cn.resolveUrl)(this.opts.uriResolver, t, r.$ref);
    s = Qf.call(this, n, u);
  }
  const { schemaId: a } = this.opts;
  if (s = s || new Xf({ schema: r, schemaId: a, root: n, baseId: t }), s.schema !== s.root.schema)
    return s;
}
const eB = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#", tB = "Meta-schema for $data reference (JSON AnySchema extension proposal)", rB = "object", nB = [
  "$data"
], iB = {
  $data: {
    type: "string",
    anyOf: [
      {
        format: "relative-json-pointer"
      },
      {
        format: "json-pointer"
      }
    ]
  }
}, sB = !1, aB = {
  $id: eB,
  description: tB,
  type: rB,
  required: nB,
  properties: iB,
  additionalProperties: sB
};
var Jg = {}, Ly = { exports: {} };
/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
(function(e, t) {
  (function(r, n) {
    n(t);
  })(rt, function(r) {
    function n() {
      for (var se = arguments.length, X = Array(se), ue = 0; ue < se; ue++)
        X[ue] = arguments[ue];
      if (X.length > 1) {
        X[0] = X[0].slice(0, -1);
        for (var ve = X.length - 1, ge = 1; ge < ve; ++ge)
          X[ge] = X[ge].slice(1, -1);
        return X[ve] = X[ve].slice(1), X.join("");
      } else
        return X[0];
    }
    function i(se) {
      return "(?:" + se + ")";
    }
    function s(se) {
      return se === void 0 ? "undefined" : se === null ? "null" : Object.prototype.toString.call(se).split(" ").pop().split("]").shift().toLowerCase();
    }
    function a(se) {
      return se.toUpperCase();
    }
    function u(se) {
      return se != null ? se instanceof Array ? se : typeof se.length != "number" || se.split || se.setInterval || se.call ? [se] : Array.prototype.slice.call(se) : [];
    }
    function c(se, X) {
      var ue = se;
      if (X)
        for (var ve in X)
          ue[ve] = X[ve];
      return ue;
    }
    function l(se) {
      var X = "[A-Za-z]", ue = "[0-9]", ve = n(ue, "[A-Fa-f]"), ge = i(i("%[EFef]" + ve + "%" + ve + ve + "%" + ve + ve) + "|" + i("%[89A-Fa-f]" + ve + "%" + ve + ve) + "|" + i("%" + ve + ve)), Ye = "[\\:\\/\\?\\#\\[\\]\\@]", Xe = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", Et = n(Ye, Xe), Lt = se ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", Wt = se ? "[\\uE000-\\uF8FF]" : "[]", vt = n(X, ue, "[\\-\\.\\_\\~]", Lt);
      i(X + n(X, ue, "[\\+\\-\\.]") + "*"), i(i(ge + "|" + n(vt, Xe, "[\\:]")) + "*");
      var Q = i(i("25[0-5]") + "|" + i("2[0-4]" + ue) + "|" + i("1" + ue + ue) + "|" + i("0?[1-9]" + ue) + "|0?0?" + ue), O = i(Q + "\\." + Q + "\\." + Q + "\\." + Q), j = i(ve + "{1,4}"), W = i(i(j + "\\:" + j) + "|" + O), ne = i(i(j + "\\:") + "{6}" + W), te = i("\\:\\:" + i(j + "\\:") + "{5}" + W), Ie = i(i(j) + "?\\:\\:" + i(j + "\\:") + "{4}" + W), Se = i(i(i(j + "\\:") + "{0,1}" + j) + "?\\:\\:" + i(j + "\\:") + "{3}" + W), Ke = i(i(i(j + "\\:") + "{0,2}" + j) + "?\\:\\:" + i(j + "\\:") + "{2}" + W), Ze = i(i(i(j + "\\:") + "{0,3}" + j) + "?\\:\\:" + j + "\\:" + W), ct = i(i(i(j + "\\:") + "{0,4}" + j) + "?\\:\\:" + W), Ut = i(i(i(j + "\\:") + "{0,5}" + j) + "?\\:\\:" + j), Ur = i(i(i(j + "\\:") + "{0,6}" + j) + "?\\:\\:"), Gr = i([ne, te, Ie, Se, Ke, Ze, ct, Ut, Ur].join("|")), bn = i(i(vt + "|" + ge) + "+");
      i("[vV]" + ve + "+\\." + n(vt, Xe, "[\\:]") + "+"), i(i(ge + "|" + n(vt, Xe)) + "*");
      var $s = i(ge + "|" + n(vt, Xe, "[\\:\\@]"));
      return i(i(ge + "|" + n(vt, Xe, "[\\@]")) + "+"), i(i($s + "|" + n("[\\/\\?]", Wt)) + "*"), {
        NOT_SCHEME: new RegExp(n("[^]", X, ue, "[\\+\\-\\.]"), "g"),
        NOT_USERINFO: new RegExp(n("[^\\%\\:]", vt, Xe), "g"),
        NOT_HOST: new RegExp(n("[^\\%\\[\\]\\:]", vt, Xe), "g"),
        NOT_PATH: new RegExp(n("[^\\%\\/\\:\\@]", vt, Xe), "g"),
        NOT_PATH_NOSCHEME: new RegExp(n("[^\\%\\/\\@]", vt, Xe), "g"),
        NOT_QUERY: new RegExp(n("[^\\%]", vt, Xe, "[\\:\\@\\/\\?]", Wt), "g"),
        NOT_FRAGMENT: new RegExp(n("[^\\%]", vt, Xe, "[\\:\\@\\/\\?]"), "g"),
        ESCAPE: new RegExp(n("[^]", vt, Xe), "g"),
        UNRESERVED: new RegExp(vt, "g"),
        OTHER_CHARS: new RegExp(n("[^\\%]", vt, Et), "g"),
        PCT_ENCODED: new RegExp(ge, "g"),
        IPV4ADDRESS: new RegExp("^(" + O + ")$"),
        IPV6ADDRESS: new RegExp("^\\[?(" + Gr + ")" + i(i("\\%25|\\%(?!" + ve + "{2})") + "(" + bn + ")") + "?\\]?$")
        //RFC 6874, with relaxed parsing rules
      };
    }
    var d = l(!1), p = l(!0), h = function() {
      function se(X, ue) {
        var ve = [], ge = !0, Ye = !1, Xe = void 0;
        try {
          for (var Et = X[Symbol.iterator](), Lt; !(ge = (Lt = Et.next()).done) && (ve.push(Lt.value), !(ue && ve.length === ue)); ge = !0)
            ;
        } catch (Wt) {
          Ye = !0, Xe = Wt;
        } finally {
          try {
            !ge && Et.return && Et.return();
          } finally {
            if (Ye)
              throw Xe;
          }
        }
        return ve;
      }
      return function(X, ue) {
        if (Array.isArray(X))
          return X;
        if (Symbol.iterator in Object(X))
          return se(X, ue);
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      };
    }(), v = function(se) {
      if (Array.isArray(se)) {
        for (var X = 0, ue = Array(se.length); X < se.length; X++)
          ue[X] = se[X];
        return ue;
      } else
        return Array.from(se);
    }, y = 2147483647, g = 36, _ = 1, m = 26, w = 38, $ = 700, E = 72, A = 128, R = "-", I = /^xn--/, D = /[^\0-\x7E]/, J = /[\x2E\u3002\uFF0E\uFF61]/g, ae = {
      overflow: "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    }, ye = g - _, xe = Math.floor, je = String.fromCharCode;
    function re(se) {
      throw new RangeError(ae[se]);
    }
    function fe(se, X) {
      for (var ue = [], ve = se.length; ve--; )
        ue[ve] = X(se[ve]);
      return ue;
    }
    function le(se, X) {
      var ue = se.split("@"), ve = "";
      ue.length > 1 && (ve = ue[0] + "@", se = ue[1]), se = se.replace(J, ".");
      var ge = se.split("."), Ye = fe(ge, X).join(".");
      return ve + Ye;
    }
    function $e(se) {
      for (var X = [], ue = 0, ve = se.length; ue < ve; ) {
        var ge = se.charCodeAt(ue++);
        if (ge >= 55296 && ge <= 56319 && ue < ve) {
          var Ye = se.charCodeAt(ue++);
          (Ye & 64512) == 56320 ? X.push(((ge & 1023) << 10) + (Ye & 1023) + 65536) : (X.push(ge), ue--);
        } else
          X.push(ge);
      }
      return X;
    }
    var Ae = function(X) {
      return String.fromCodePoint.apply(String, v(X));
    }, _e = function(X) {
      return X - 48 < 10 ? X - 22 : X - 65 < 26 ? X - 65 : X - 97 < 26 ? X - 97 : g;
    }, ie = function(X, ue) {
      return X + 22 + 75 * (X < 26) - ((ue != 0) << 5);
    }, K = function(X, ue, ve) {
      var ge = 0;
      for (
        X = ve ? xe(X / $) : X >> 1, X += xe(X / ue);
        /* no initialization */
        X > ye * m >> 1;
        ge += g
      )
        X = xe(X / ye);
      return xe(ge + (ye + 1) * X / (X + w));
    }, V = function(X) {
      var ue = [], ve = X.length, ge = 0, Ye = A, Xe = E, Et = X.lastIndexOf(R);
      Et < 0 && (Et = 0);
      for (var Lt = 0; Lt < Et; ++Lt)
        X.charCodeAt(Lt) >= 128 && re("not-basic"), ue.push(X.charCodeAt(Lt));
      for (var Wt = Et > 0 ? Et + 1 : 0; Wt < ve; ) {
        for (
          var vt = ge, Q = 1, O = g;
          ;
          /* no condition */
          O += g
        ) {
          Wt >= ve && re("invalid-input");
          var j = _e(X.charCodeAt(Wt++));
          (j >= g || j > xe((y - ge) / Q)) && re("overflow"), ge += j * Q;
          var W = O <= Xe ? _ : O >= Xe + m ? m : O - Xe;
          if (j < W)
            break;
          var ne = g - W;
          Q > xe(y / ne) && re("overflow"), Q *= ne;
        }
        var te = ue.length + 1;
        Xe = K(ge - vt, te, vt == 0), xe(ge / te) > y - Ye && re("overflow"), Ye += xe(ge / te), ge %= te, ue.splice(ge++, 0, Ye);
      }
      return String.fromCodePoint.apply(String, ue);
    }, z = function(X) {
      var ue = [];
      X = $e(X);
      var ve = X.length, ge = A, Ye = 0, Xe = E, Et = !0, Lt = !1, Wt = void 0;
      try {
        for (var vt = X[Symbol.iterator](), Q; !(Et = (Q = vt.next()).done); Et = !0) {
          var O = Q.value;
          O < 128 && ue.push(je(O));
        }
      } catch (Un) {
        Lt = !0, Wt = Un;
      } finally {
        try {
          !Et && vt.return && vt.return();
        } finally {
          if (Lt)
            throw Wt;
        }
      }
      var j = ue.length, W = j;
      for (j && ue.push(R); W < ve; ) {
        var ne = y, te = !0, Ie = !1, Se = void 0;
        try {
          for (var Ke = X[Symbol.iterator](), Ze; !(te = (Ze = Ke.next()).done); te = !0) {
            var ct = Ze.value;
            ct >= ge && ct < ne && (ne = ct);
          }
        } catch (Un) {
          Ie = !0, Se = Un;
        } finally {
          try {
            !te && Ke.return && Ke.return();
          } finally {
            if (Ie)
              throw Se;
          }
        }
        var Ut = W + 1;
        ne - ge > xe((y - Ye) / Ut) && re("overflow"), Ye += (ne - ge) * Ut, ge = ne;
        var Ur = !0, Gr = !1, bn = void 0;
        try {
          for (var $s = X[Symbol.iterator](), lc; !(Ur = (lc = $s.next()).done); Ur = !0) {
            var Po = lc.value;
            if (Po < ge && ++Ye > y && re("overflow"), Po == ge) {
              for (
                var Es = Ye, xs = g;
                ;
                /* no condition */
                xs += g
              ) {
                var Li = xs <= Xe ? _ : xs >= Xe + m ? m : xs - Xe;
                if (Es < Li)
                  break;
                var fc = Es - Li, So = g - Li;
                ue.push(je(ie(Li + fc % So, 0))), Es = xe(fc / So);
              }
              ue.push(je(ie(Es, 0))), Xe = K(Ye, Ut, W == j), Ye = 0, ++W;
            }
          }
        } catch (Un) {
          Gr = !0, bn = Un;
        } finally {
          try {
            !Ur && $s.return && $s.return();
          } finally {
            if (Gr)
              throw bn;
          }
        }
        ++Ye, ++ge;
      }
      return ue.join("");
    }, C = function(X) {
      return le(X, function(ue) {
        return I.test(ue) ? V(ue.slice(4).toLowerCase()) : ue;
      });
    }, q = function(X) {
      return le(X, function(ue) {
        return D.test(ue) ? "xn--" + z(ue) : ue;
      });
    }, N = {
      /**
       * A string representing the current Punycode.js version number.
       * @memberOf punycode
       * @type String
       */
      version: "2.1.0",
      /**
       * An object of methods to convert from JavaScript's internal character
       * representation (UCS-2) to Unicode code points, and back.
       * @see <https://mathiasbynens.be/notes/javascript-encoding>
       * @memberOf punycode
       * @type Object
       */
      ucs2: {
        decode: $e,
        encode: Ae
      },
      decode: V,
      encode: z,
      toASCII: q,
      toUnicode: C
    }, F = {};
    function T(se) {
      var X = se.charCodeAt(0), ue = void 0;
      return X < 16 ? ue = "%0" + X.toString(16).toUpperCase() : X < 128 ? ue = "%" + X.toString(16).toUpperCase() : X < 2048 ? ue = "%" + (X >> 6 | 192).toString(16).toUpperCase() + "%" + (X & 63 | 128).toString(16).toUpperCase() : ue = "%" + (X >> 12 | 224).toString(16).toUpperCase() + "%" + (X >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (X & 63 | 128).toString(16).toUpperCase(), ue;
    }
    function Z(se) {
      for (var X = "", ue = 0, ve = se.length; ue < ve; ) {
        var ge = parseInt(se.substr(ue + 1, 2), 16);
        if (ge < 128)
          X += String.fromCharCode(ge), ue += 3;
        else if (ge >= 194 && ge < 224) {
          if (ve - ue >= 6) {
            var Ye = parseInt(se.substr(ue + 4, 2), 16);
            X += String.fromCharCode((ge & 31) << 6 | Ye & 63);
          } else
            X += se.substr(ue, 6);
          ue += 6;
        } else if (ge >= 224) {
          if (ve - ue >= 9) {
            var Xe = parseInt(se.substr(ue + 4, 2), 16), Et = parseInt(se.substr(ue + 7, 2), 16);
            X += String.fromCharCode((ge & 15) << 12 | (Xe & 63) << 6 | Et & 63);
          } else
            X += se.substr(ue, 9);
          ue += 9;
        } else
          X += se.substr(ue, 3), ue += 3;
      }
      return X;
    }
    function Y(se, X) {
      function ue(ve) {
        var ge = Z(ve);
        return ge.match(X.UNRESERVED) ? ge : ve;
      }
      return se.scheme && (se.scheme = String(se.scheme).replace(X.PCT_ENCODED, ue).toLowerCase().replace(X.NOT_SCHEME, "")), se.userinfo !== void 0 && (se.userinfo = String(se.userinfo).replace(X.PCT_ENCODED, ue).replace(X.NOT_USERINFO, T).replace(X.PCT_ENCODED, a)), se.host !== void 0 && (se.host = String(se.host).replace(X.PCT_ENCODED, ue).toLowerCase().replace(X.NOT_HOST, T).replace(X.PCT_ENCODED, a)), se.path !== void 0 && (se.path = String(se.path).replace(X.PCT_ENCODED, ue).replace(se.scheme ? X.NOT_PATH : X.NOT_PATH_NOSCHEME, T).replace(X.PCT_ENCODED, a)), se.query !== void 0 && (se.query = String(se.query).replace(X.PCT_ENCODED, ue).replace(X.NOT_QUERY, T).replace(X.PCT_ENCODED, a)), se.fragment !== void 0 && (se.fragment = String(se.fragment).replace(X.PCT_ENCODED, ue).replace(X.NOT_FRAGMENT, T).replace(X.PCT_ENCODED, a)), se;
    }
    function k(se) {
      return se.replace(/^0*(.*)/, "$1") || "0";
    }
    function U(se, X) {
      var ue = se.match(X.IPV4ADDRESS) || [], ve = h(ue, 2), ge = ve[1];
      return ge ? ge.split(".").map(k).join(".") : se;
    }
    function pe(se, X) {
      var ue = se.match(X.IPV6ADDRESS) || [], ve = h(ue, 3), ge = ve[1], Ye = ve[2];
      if (ge) {
        for (var Xe = ge.toLowerCase().split("::").reverse(), Et = h(Xe, 2), Lt = Et[0], Wt = Et[1], vt = Wt ? Wt.split(":").map(k) : [], Q = Lt.split(":").map(k), O = X.IPV4ADDRESS.test(Q[Q.length - 1]), j = O ? 7 : 8, W = Q.length - j, ne = Array(j), te = 0; te < j; ++te)
          ne[te] = vt[te] || Q[W + te] || "";
        O && (ne[j - 1] = U(ne[j - 1], X));
        var Ie = ne.reduce(function(Ut, Ur, Gr) {
          if (!Ur || Ur === "0") {
            var bn = Ut[Ut.length - 1];
            bn && bn.index + bn.length === Gr ? bn.length++ : Ut.push({ index: Gr, length: 1 });
          }
          return Ut;
        }, []), Se = Ie.sort(function(Ut, Ur) {
          return Ur.length - Ut.length;
        })[0], Ke = void 0;
        if (Se && Se.length > 1) {
          var Ze = ne.slice(0, Se.index), ct = ne.slice(Se.index + Se.length);
          Ke = Ze.join(":") + "::" + ct.join(":");
        } else
          Ke = ne.join(":");
        return Ye && (Ke += "%" + Ye), Ke;
      } else
        return se;
    }
    var we = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i, He = "".match(/(){0}/)[1] === void 0;
    function Fe(se) {
      var X = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, ue = {}, ve = X.iri !== !1 ? p : d;
      X.reference === "suffix" && (se = (X.scheme ? X.scheme + ":" : "") + "//" + se);
      var ge = se.match(we);
      if (ge) {
        He ? (ue.scheme = ge[1], ue.userinfo = ge[3], ue.host = ge[4], ue.port = parseInt(ge[5], 10), ue.path = ge[6] || "", ue.query = ge[7], ue.fragment = ge[8], isNaN(ue.port) && (ue.port = ge[5])) : (ue.scheme = ge[1] || void 0, ue.userinfo = se.indexOf("@") !== -1 ? ge[3] : void 0, ue.host = se.indexOf("//") !== -1 ? ge[4] : void 0, ue.port = parseInt(ge[5], 10), ue.path = ge[6] || "", ue.query = se.indexOf("?") !== -1 ? ge[7] : void 0, ue.fragment = se.indexOf("#") !== -1 ? ge[8] : void 0, isNaN(ue.port) && (ue.port = se.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? ge[4] : void 0)), ue.host && (ue.host = pe(U(ue.host, ve), ve)), ue.scheme === void 0 && ue.userinfo === void 0 && ue.host === void 0 && ue.port === void 0 && !ue.path && ue.query === void 0 ? ue.reference = "same-document" : ue.scheme === void 0 ? ue.reference = "relative" : ue.fragment === void 0 ? ue.reference = "absolute" : ue.reference = "uri", X.reference && X.reference !== "suffix" && X.reference !== ue.reference && (ue.error = ue.error || "URI is not a " + X.reference + " reference.");
        var Ye = F[(X.scheme || ue.scheme || "").toLowerCase()];
        if (!X.unicodeSupport && (!Ye || !Ye.unicodeSupport)) {
          if (ue.host && (X.domainHost || Ye && Ye.domainHost))
            try {
              ue.host = N.toASCII(ue.host.replace(ve.PCT_ENCODED, Z).toLowerCase());
            } catch (Xe) {
              ue.error = ue.error || "Host's domain name can not be converted to ASCII via punycode: " + Xe;
            }
          Y(ue, d);
        } else
          Y(ue, ve);
        Ye && Ye.parse && Ye.parse(ue, X);
      } else
        ue.error = ue.error || "URI can not be parsed.";
      return ue;
    }
    function Ge(se, X) {
      var ue = X.iri !== !1 ? p : d, ve = [];
      return se.userinfo !== void 0 && (ve.push(se.userinfo), ve.push("@")), se.host !== void 0 && ve.push(pe(U(String(se.host), ue), ue).replace(ue.IPV6ADDRESS, function(ge, Ye, Xe) {
        return "[" + Ye + (Xe ? "%25" + Xe : "") + "]";
      })), (typeof se.port == "number" || typeof se.port == "string") && (ve.push(":"), ve.push(String(se.port))), ve.length ? ve.join("") : void 0;
    }
    var jt = /^\.\.?\//, Ee = /^\/\.(\/|$)/, Mt = /^\/\.\.(\/|$)/, St = /^\/?(?:.|\n)*?(?=\/|$)/;
    function Ne(se) {
      for (var X = []; se.length; )
        if (se.match(jt))
          se = se.replace(jt, "");
        else if (se.match(Ee))
          se = se.replace(Ee, "/");
        else if (se.match(Mt))
          se = se.replace(Mt, "/"), X.pop();
        else if (se === "." || se === "..")
          se = "";
        else {
          var ue = se.match(St);
          if (ue) {
            var ve = ue[0];
            se = se.slice(ve.length), X.push(ve);
          } else
            throw new Error("Unexpected dot segment condition");
        }
      return X.join("");
    }
    function Le(se) {
      var X = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, ue = X.iri ? p : d, ve = [], ge = F[(X.scheme || se.scheme || "").toLowerCase()];
      if (ge && ge.serialize && ge.serialize(se, X), se.host && !ue.IPV6ADDRESS.test(se.host)) {
        if (X.domainHost || ge && ge.domainHost)
          try {
            se.host = X.iri ? N.toUnicode(se.host) : N.toASCII(se.host.replace(ue.PCT_ENCODED, Z).toLowerCase());
          } catch (Et) {
            se.error = se.error || "Host's domain name can not be converted to " + (X.iri ? "Unicode" : "ASCII") + " via punycode: " + Et;
          }
      }
      Y(se, ue), X.reference !== "suffix" && se.scheme && (ve.push(se.scheme), ve.push(":"));
      var Ye = Ge(se, X);
      if (Ye !== void 0 && (X.reference !== "suffix" && ve.push("//"), ve.push(Ye), se.path && se.path.charAt(0) !== "/" && ve.push("/")), se.path !== void 0) {
        var Xe = se.path;
        !X.absolutePath && (!ge || !ge.absolutePath) && (Xe = Ne(Xe)), Ye === void 0 && (Xe = Xe.replace(/^\/\//, "/%2F")), ve.push(Xe);
      }
      return se.query !== void 0 && (ve.push("?"), ve.push(se.query)), se.fragment !== void 0 && (ve.push("#"), ve.push(se.fragment)), ve.join("");
    }
    function at(se, X) {
      var ue = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, ve = arguments[3], ge = {};
      return ve || (se = Fe(Le(se, ue), ue), X = Fe(Le(X, ue), ue)), ue = ue || {}, !ue.tolerant && X.scheme ? (ge.scheme = X.scheme, ge.userinfo = X.userinfo, ge.host = X.host, ge.port = X.port, ge.path = Ne(X.path || ""), ge.query = X.query) : (X.userinfo !== void 0 || X.host !== void 0 || X.port !== void 0 ? (ge.userinfo = X.userinfo, ge.host = X.host, ge.port = X.port, ge.path = Ne(X.path || ""), ge.query = X.query) : (X.path ? (X.path.charAt(0) === "/" ? ge.path = Ne(X.path) : ((se.userinfo !== void 0 || se.host !== void 0 || se.port !== void 0) && !se.path ? ge.path = "/" + X.path : se.path ? ge.path = se.path.slice(0, se.path.lastIndexOf("/") + 1) + X.path : ge.path = X.path, ge.path = Ne(ge.path)), ge.query = X.query) : (ge.path = se.path, X.query !== void 0 ? ge.query = X.query : ge.query = se.query), ge.userinfo = se.userinfo, ge.host = se.host, ge.port = se.port), ge.scheme = se.scheme), ge.fragment = X.fragment, ge;
    }
    function mt(se, X, ue) {
      var ve = c({ scheme: "null" }, ue);
      return Le(at(Fe(se, ve), Fe(X, ve), ve, !0), ve);
    }
    function qe(se, X) {
      return typeof se == "string" ? se = Le(Fe(se, X), X) : s(se) === "object" && (se = Fe(Le(se, X), X)), se;
    }
    function L(se, X, ue) {
      return typeof se == "string" ? se = Le(Fe(se, ue), ue) : s(se) === "object" && (se = Le(se, ue)), typeof X == "string" ? X = Le(Fe(X, ue), ue) : s(X) === "object" && (X = Le(X, ue)), se === X;
    }
    function x(se, X) {
      return se && se.toString().replace(!X || !X.iri ? d.ESCAPE : p.ESCAPE, T);
    }
    function S(se, X) {
      return se && se.toString().replace(!X || !X.iri ? d.PCT_ENCODED : p.PCT_ENCODED, Z);
    }
    var G = {
      scheme: "http",
      domainHost: !0,
      parse: function(X, ue) {
        return X.host || (X.error = X.error || "HTTP URIs must have a host."), X;
      },
      serialize: function(X, ue) {
        var ve = String(X.scheme).toLowerCase() === "https";
        return (X.port === (ve ? 443 : 80) || X.port === "") && (X.port = void 0), X.path || (X.path = "/"), X;
      }
    }, ce = {
      scheme: "https",
      domainHost: G.domainHost,
      parse: G.parse,
      serialize: G.serialize
    };
    function me(se) {
      return typeof se.secure == "boolean" ? se.secure : String(se.scheme).toLowerCase() === "wss";
    }
    var Oe = {
      scheme: "ws",
      domainHost: !0,
      parse: function(X, ue) {
        var ve = X;
        return ve.secure = me(ve), ve.resourceName = (ve.path || "/") + (ve.query ? "?" + ve.query : ""), ve.path = void 0, ve.query = void 0, ve;
      },
      serialize: function(X, ue) {
        if ((X.port === (me(X) ? 443 : 80) || X.port === "") && (X.port = void 0), typeof X.secure == "boolean" && (X.scheme = X.secure ? "wss" : "ws", X.secure = void 0), X.resourceName) {
          var ve = X.resourceName.split("?"), ge = h(ve, 2), Ye = ge[0], Xe = ge[1];
          X.path = Ye && Ye !== "/" ? Ye : void 0, X.query = Xe, X.resourceName = void 0;
        }
        return X.fragment = void 0, X;
      }
    }, ut = {
      scheme: "wss",
      domainHost: Oe.domainHost,
      parse: Oe.parse,
      serialize: Oe.serialize
    }, Dt = {}, Tt = "[A-Za-z0-9\\-\\.\\_\\~\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]", wt = "[0-9A-Fa-f]", It = i(i("%[EFef]" + wt + "%" + wt + wt + "%" + wt + wt) + "|" + i("%[89A-Fa-f]" + wt + "%" + wt + wt) + "|" + i("%" + wt + wt)), _o = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]", wo = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]", oa = n(wo, '[\\"\\\\]'), ua = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]", $o = new RegExp(Tt, "g"), Fn = new RegExp(It, "g"), Eo = new RegExp(n("[^]", _o, "[\\.]", '[\\"]', oa), "g"), ca = new RegExp(n("[^]", Tt, ua), "g"), la = ca;
    function ws(se) {
      var X = Z(se);
      return X.match($o) ? X : se;
    }
    var fa = {
      scheme: "mailto",
      parse: function(X, ue) {
        var ve = X, ge = ve.to = ve.path ? ve.path.split(",") : [];
        if (ve.path = void 0, ve.query) {
          for (var Ye = !1, Xe = {}, Et = ve.query.split("&"), Lt = 0, Wt = Et.length; Lt < Wt; ++Lt) {
            var vt = Et[Lt].split("=");
            switch (vt[0]) {
              case "to":
                for (var Q = vt[1].split(","), O = 0, j = Q.length; O < j; ++O)
                  ge.push(Q[O]);
                break;
              case "subject":
                ve.subject = S(vt[1], ue);
                break;
              case "body":
                ve.body = S(vt[1], ue);
                break;
              default:
                Ye = !0, Xe[S(vt[0], ue)] = S(vt[1], ue);
                break;
            }
          }
          Ye && (ve.headers = Xe);
        }
        ve.query = void 0;
        for (var W = 0, ne = ge.length; W < ne; ++W) {
          var te = ge[W].split("@");
          if (te[0] = S(te[0]), ue.unicodeSupport)
            te[1] = S(te[1], ue).toLowerCase();
          else
            try {
              te[1] = N.toASCII(S(te[1], ue).toLowerCase());
            } catch (Ie) {
              ve.error = ve.error || "Email address's domain name can not be converted to ASCII via punycode: " + Ie;
            }
          ge[W] = te.join("@");
        }
        return ve;
      },
      serialize: function(X, ue) {
        var ve = X, ge = u(X.to);
        if (ge) {
          for (var Ye = 0, Xe = ge.length; Ye < Xe; ++Ye) {
            var Et = String(ge[Ye]), Lt = Et.lastIndexOf("@"), Wt = Et.slice(0, Lt).replace(Fn, ws).replace(Fn, a).replace(Eo, T), vt = Et.slice(Lt + 1);
            try {
              vt = ue.iri ? N.toUnicode(vt) : N.toASCII(S(vt, ue).toLowerCase());
            } catch (W) {
              ve.error = ve.error || "Email address's domain name can not be converted to " + (ue.iri ? "Unicode" : "ASCII") + " via punycode: " + W;
            }
            ge[Ye] = Wt + "@" + vt;
          }
          ve.path = ge.join(",");
        }
        var Q = X.headers = X.headers || {};
        X.subject && (Q.subject = X.subject), X.body && (Q.body = X.body);
        var O = [];
        for (var j in Q)
          Q[j] !== Dt[j] && O.push(j.replace(Fn, ws).replace(Fn, a).replace(ca, T) + "=" + Q[j].replace(Fn, ws).replace(Fn, a).replace(la, T));
        return O.length && (ve.query = O.join("&")), ve;
      }
    }, xo = /^([^\:]+)\:(.*)/, Ni = {
      scheme: "urn",
      parse: function(X, ue) {
        var ve = X.path && X.path.match(xo), ge = X;
        if (ve) {
          var Ye = ue.scheme || ge.scheme || "urn", Xe = ve[1].toLowerCase(), Et = ve[2], Lt = Ye + ":" + (ue.nid || Xe), Wt = F[Lt];
          ge.nid = Xe, ge.nss = Et, ge.path = void 0, Wt && (ge = Wt.parse(ge, ue));
        } else
          ge.error = ge.error || "URN can not be parsed.";
        return ge;
      },
      serialize: function(X, ue) {
        var ve = ue.scheme || X.scheme || "urn", ge = X.nid, Ye = ve + ":" + (ue.nid || ge), Xe = F[Ye];
        Xe && (X = Xe.serialize(X, ue));
        var Et = X, Lt = X.nss;
        return Et.path = (ge || ue.nid) + ":" + Lt, Et;
      }
    }, Oo = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/, Di = {
      scheme: "urn:uuid",
      parse: function(X, ue) {
        var ve = X;
        return ve.uuid = ve.nss, ve.nss = void 0, !ue.tolerant && (!ve.uuid || !ve.uuid.match(Oo)) && (ve.error = ve.error || "UUID is not valid."), ve;
      },
      serialize: function(X, ue) {
        var ve = X;
        return ve.nss = (X.uuid || "").toLowerCase(), ve;
      }
    };
    F[G.scheme] = G, F[ce.scheme] = ce, F[Oe.scheme] = Oe, F[ut.scheme] = ut, F[fa.scheme] = fa, F[Ni.scheme] = Ni, F[Di.scheme] = Di, r.SCHEMES = F, r.pctEncChar = T, r.pctDecChars = Z, r.parse = Fe, r.removeDotSegments = Ne, r.serialize = Le, r.resolveComponents = at, r.resolve = mt, r.normalize = qe, r.equal = L, r.escapeComponent = x, r.unescapeComponent = S, Object.defineProperty(r, "__esModule", { value: !0 });
  });
})(Ly, Ly.exports);
var oB = Ly.exports;
Object.defineProperty(Jg, "__esModule", { value: !0 });
const RP = oB;
RP.code = 'require("ajv/dist/runtime/uri").default';
Jg.default = RP;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CodeGen = e.Name = e.nil = e.stringify = e.str = e._ = e.KeywordCxt = void 0;
  var t = jn;
  Object.defineProperty(e, "KeywordCxt", { enumerable: !0, get: function() {
    return t.KeywordCxt;
  } });
  var r = ht;
  Object.defineProperty(e, "_", { enumerable: !0, get: function() {
    return r._;
  } }), Object.defineProperty(e, "str", { enumerable: !0, get: function() {
    return r.str;
  } }), Object.defineProperty(e, "stringify", { enumerable: !0, get: function() {
    return r.stringify;
  } }), Object.defineProperty(e, "nil", { enumerable: !0, get: function() {
    return r.nil;
  } }), Object.defineProperty(e, "Name", { enumerable: !0, get: function() {
    return r.Name;
  } }), Object.defineProperty(e, "CodeGen", { enumerable: !0, get: function() {
    return r.CodeGen;
  } });
  const n = ic, i = sc, s = Qs, a = Nr, u = ht, c = vr, l = nc, d = Pt, p = aB, h = Jg, v = (ie, K) => new RegExp(ie, K);
  v.code = "new RegExp";
  const y = ["removeAdditional", "useDefaults", "coerceTypes"], g = /* @__PURE__ */ new Set([
    "validate",
    "serialize",
    "parse",
    "wrapper",
    "root",
    "schema",
    "keyword",
    "pattern",
    "formats",
    "validate$data",
    "func",
    "obj",
    "Error"
  ]), _ = {
    errorDataPath: "",
    format: "`validateFormats: false` can be used instead.",
    nullable: '"nullable" keyword is supported by default.',
    jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
    extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
    missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
    processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
    sourceCode: "Use option `code: {source: true}`",
    strictDefaults: "It is default now, see option `strict`.",
    strictKeywords: "It is default now, see option `strict`.",
    uniqueItems: '"uniqueItems" keyword is always validated.',
    unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
    cache: "Map is used as cache, schema object as key.",
    serialize: "Map is used as cache, schema object as key.",
    ajvErrors: "It is default now."
  }, m = {
    ignoreKeywordsWithRef: "",
    jsPropertySyntax: "",
    unicode: '"minLength"/"maxLength" account for unicode characters by default.'
  }, w = 200;
  function $(ie) {
    var K, V, z, C, q, N, F, T, Z, Y, k, U, pe, we, He, Fe, Ge, jt, Ee, Mt, St, Ne, Le, at, mt;
    const qe = ie.strict, L = (K = ie.code) === null || K === void 0 ? void 0 : K.optimize, x = L === !0 || L === void 0 ? 1 : L || 0, S = (z = (V = ie.code) === null || V === void 0 ? void 0 : V.regExp) !== null && z !== void 0 ? z : v, G = (C = ie.uriResolver) !== null && C !== void 0 ? C : h.default;
    return {
      strictSchema: (N = (q = ie.strictSchema) !== null && q !== void 0 ? q : qe) !== null && N !== void 0 ? N : !0,
      strictNumbers: (T = (F = ie.strictNumbers) !== null && F !== void 0 ? F : qe) !== null && T !== void 0 ? T : !0,
      strictTypes: (Y = (Z = ie.strictTypes) !== null && Z !== void 0 ? Z : qe) !== null && Y !== void 0 ? Y : "log",
      strictTuples: (U = (k = ie.strictTuples) !== null && k !== void 0 ? k : qe) !== null && U !== void 0 ? U : "log",
      strictRequired: (we = (pe = ie.strictRequired) !== null && pe !== void 0 ? pe : qe) !== null && we !== void 0 ? we : !1,
      code: ie.code ? { ...ie.code, optimize: x, regExp: S } : { optimize: x, regExp: S },
      loopRequired: (He = ie.loopRequired) !== null && He !== void 0 ? He : w,
      loopEnum: (Fe = ie.loopEnum) !== null && Fe !== void 0 ? Fe : w,
      meta: (Ge = ie.meta) !== null && Ge !== void 0 ? Ge : !0,
      messages: (jt = ie.messages) !== null && jt !== void 0 ? jt : !0,
      inlineRefs: (Ee = ie.inlineRefs) !== null && Ee !== void 0 ? Ee : !0,
      schemaId: (Mt = ie.schemaId) !== null && Mt !== void 0 ? Mt : "$id",
      addUsedSchema: (St = ie.addUsedSchema) !== null && St !== void 0 ? St : !0,
      validateSchema: (Ne = ie.validateSchema) !== null && Ne !== void 0 ? Ne : !0,
      validateFormats: (Le = ie.validateFormats) !== null && Le !== void 0 ? Le : !0,
      unicodeRegExp: (at = ie.unicodeRegExp) !== null && at !== void 0 ? at : !0,
      int32range: (mt = ie.int32range) !== null && mt !== void 0 ? mt : !0,
      uriResolver: G
    };
  }
  class E {
    constructor(K = {}) {
      this.schemas = {}, this.refs = {}, this.formats = {}, this._compilations = /* @__PURE__ */ new Set(), this._loading = {}, this._cache = /* @__PURE__ */ new Map(), K = this.opts = { ...K, ...$(K) };
      const { es5: V, lines: z } = this.opts.code;
      this.scope = new u.ValueScope({ scope: {}, prefixes: g, es5: V, lines: z }), this.logger = xe(K.logger);
      const C = K.validateFormats;
      K.validateFormats = !1, this.RULES = (0, s.getRules)(), A.call(this, _, K, "NOT SUPPORTED"), A.call(this, m, K, "DEPRECATED", "warn"), this._metaOpts = ae.call(this), K.formats && D.call(this), this._addVocabularies(), this._addDefaultMetaSchema(), K.keywords && J.call(this, K.keywords), typeof K.meta == "object" && this.addMetaSchema(K.meta), I.call(this), K.validateFormats = C;
    }
    _addVocabularies() {
      this.addKeyword("$async");
    }
    _addDefaultMetaSchema() {
      const { $data: K, meta: V, schemaId: z } = this.opts;
      let C = p;
      z === "id" && (C = { ...p }, C.id = C.$id, delete C.$id), V && K && this.addMetaSchema(C, C[z], !1);
    }
    defaultMeta() {
      const { meta: K, schemaId: V } = this.opts;
      return this.opts.defaultMeta = typeof K == "object" ? K[V] || K : void 0;
    }
    validate(K, V) {
      let z;
      if (typeof K == "string") {
        if (z = this.getSchema(K), !z)
          throw new Error(`no schema with key or ref "${K}"`);
      } else
        z = this.compile(K);
      const C = z(V);
      return "$async" in z || (this.errors = z.errors), C;
    }
    compile(K, V) {
      const z = this._addSchema(K, V);
      return z.validate || this._compileSchemaEnv(z);
    }
    compileAsync(K, V) {
      if (typeof this.opts.loadSchema != "function")
        throw new Error("options.loadSchema should be a function");
      const { loadSchema: z } = this.opts;
      return C.call(this, K, V);
      async function C(Y, k) {
        await q.call(this, Y.$schema);
        const U = this._addSchema(Y, k);
        return U.validate || N.call(this, U);
      }
      async function q(Y) {
        Y && !this.getSchema(Y) && await C.call(this, { $ref: Y }, !0);
      }
      async function N(Y) {
        try {
          return this._compileSchemaEnv(Y);
        } catch (k) {
          if (!(k instanceof i.default))
            throw k;
          return F.call(this, k), await T.call(this, k.missingSchema), N.call(this, Y);
        }
      }
      function F({ missingSchema: Y, missingRef: k }) {
        if (this.refs[Y])
          throw new Error(`AnySchema ${Y} is loaded but ${k} cannot be resolved`);
      }
      async function T(Y) {
        const k = await Z.call(this, Y);
        this.refs[Y] || await q.call(this, k.$schema), this.refs[Y] || this.addSchema(k, Y, V);
      }
      async function Z(Y) {
        const k = this._loading[Y];
        if (k)
          return k;
        try {
          return await (this._loading[Y] = z(Y));
        } finally {
          delete this._loading[Y];
        }
      }
    }
    // Adds schema to the instance
    addSchema(K, V, z, C = this.opts.validateSchema) {
      if (Array.isArray(K)) {
        for (const N of K)
          this.addSchema(N, void 0, z, C);
        return this;
      }
      let q;
      if (typeof K == "object") {
        const { schemaId: N } = this.opts;
        if (q = K[N], q !== void 0 && typeof q != "string")
          throw new Error(`schema ${N} must be string`);
      }
      return V = (0, c.normalizeId)(V || q), this._checkUnique(V), this.schemas[V] = this._addSchema(K, z, V, C, !0), this;
    }
    // Add schema that will be used to validate other schemas
    // options in META_IGNORE_OPTIONS are alway set to false
    addMetaSchema(K, V, z = this.opts.validateSchema) {
      return this.addSchema(K, V, !0, z), this;
    }
    //  Validate schema against its meta-schema
    validateSchema(K, V) {
      if (typeof K == "boolean")
        return !0;
      let z;
      if (z = K.$schema, z !== void 0 && typeof z != "string")
        throw new Error("$schema must be a string");
      if (z = z || this.opts.defaultMeta || this.defaultMeta(), !z)
        return this.logger.warn("meta-schema not available"), this.errors = null, !0;
      const C = this.validate(z, K);
      if (!C && V) {
        const q = "schema is invalid: " + this.errorsText();
        if (this.opts.validateSchema === "log")
          this.logger.error(q);
        else
          throw new Error(q);
      }
      return C;
    }
    // Get compiled schema by `key` or `ref`.
    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
    getSchema(K) {
      let V;
      for (; typeof (V = R.call(this, K)) == "string"; )
        K = V;
      if (V === void 0) {
        const { schemaId: z } = this.opts, C = new a.SchemaEnv({ schema: {}, schemaId: z });
        if (V = a.resolveSchema.call(this, C, K), !V)
          return;
        this.refs[K] = V;
      }
      return V.validate || this._compileSchemaEnv(V);
    }
    // Remove cached schema(s).
    // If no parameter is passed all schemas but meta-schemas are removed.
    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
    removeSchema(K) {
      if (K instanceof RegExp)
        return this._removeAllSchemas(this.schemas, K), this._removeAllSchemas(this.refs, K), this;
      switch (typeof K) {
        case "undefined":
          return this._removeAllSchemas(this.schemas), this._removeAllSchemas(this.refs), this._cache.clear(), this;
        case "string": {
          const V = R.call(this, K);
          return typeof V == "object" && this._cache.delete(V.schema), delete this.schemas[K], delete this.refs[K], this;
        }
        case "object": {
          const V = K;
          this._cache.delete(V);
          let z = K[this.opts.schemaId];
          return z && (z = (0, c.normalizeId)(z), delete this.schemas[z], delete this.refs[z]), this;
        }
        default:
          throw new Error("ajv.removeSchema: invalid parameter");
      }
    }
    // add "vocabulary" - a collection of keywords
    addVocabulary(K) {
      for (const V of K)
        this.addKeyword(V);
      return this;
    }
    addKeyword(K, V) {
      let z;
      if (typeof K == "string")
        z = K, typeof V == "object" && (this.logger.warn("these parameters are deprecated, see docs for addKeyword"), V.keyword = z);
      else if (typeof K == "object" && V === void 0) {
        if (V = K, z = V.keyword, Array.isArray(z) && !z.length)
          throw new Error("addKeywords: keyword must be string or non-empty array");
      } else
        throw new Error("invalid addKeywords parameters");
      if (re.call(this, z, V), !V)
        return (0, d.eachItem)(z, (q) => fe.call(this, q)), this;
      $e.call(this, V);
      const C = {
        ...V,
        type: (0, l.getJSONTypes)(V.type),
        schemaType: (0, l.getJSONTypes)(V.schemaType)
      };
      return (0, d.eachItem)(z, C.type.length === 0 ? (q) => fe.call(this, q, C) : (q) => C.type.forEach((N) => fe.call(this, q, C, N))), this;
    }
    getKeyword(K) {
      const V = this.RULES.all[K];
      return typeof V == "object" ? V.definition : !!V;
    }
    // Remove keyword
    removeKeyword(K) {
      const { RULES: V } = this;
      delete V.keywords[K], delete V.all[K];
      for (const z of V.rules) {
        const C = z.rules.findIndex((q) => q.keyword === K);
        C >= 0 && z.rules.splice(C, 1);
      }
      return this;
    }
    // Add format
    addFormat(K, V) {
      return typeof V == "string" && (V = new RegExp(V)), this.formats[K] = V, this;
    }
    errorsText(K = this.errors, { separator: V = ", ", dataVar: z = "data" } = {}) {
      return !K || K.length === 0 ? "No errors" : K.map((C) => `${z}${C.instancePath} ${C.message}`).reduce((C, q) => C + V + q);
    }
    $dataMetaSchema(K, V) {
      const z = this.RULES.all;
      K = JSON.parse(JSON.stringify(K));
      for (const C of V) {
        const q = C.split("/").slice(1);
        let N = K;
        for (const F of q)
          N = N[F];
        for (const F in z) {
          const T = z[F];
          if (typeof T != "object")
            continue;
          const { $data: Z } = T.definition, Y = N[F];
          Z && Y && (N[F] = _e(Y));
        }
      }
      return K;
    }
    _removeAllSchemas(K, V) {
      for (const z in K) {
        const C = K[z];
        (!V || V.test(z)) && (typeof C == "string" ? delete K[z] : C && !C.meta && (this._cache.delete(C.schema), delete K[z]));
      }
    }
    _addSchema(K, V, z, C = this.opts.validateSchema, q = this.opts.addUsedSchema) {
      let N;
      const { schemaId: F } = this.opts;
      if (typeof K == "object")
        N = K[F];
      else {
        if (this.opts.jtd)
          throw new Error("schema must be object");
        if (typeof K != "boolean")
          throw new Error("schema must be object or boolean");
      }
      let T = this._cache.get(K);
      if (T !== void 0)
        return T;
      z = (0, c.normalizeId)(N || z);
      const Z = c.getSchemaRefs.call(this, K, z);
      return T = new a.SchemaEnv({ schema: K, schemaId: F, meta: V, baseId: z, localRefs: Z }), this._cache.set(T.schema, T), q && !z.startsWith("#") && (z && this._checkUnique(z), this.refs[z] = T), C && this.validateSchema(K, !0), T;
    }
    _checkUnique(K) {
      if (this.schemas[K] || this.refs[K])
        throw new Error(`schema with key or id "${K}" already exists`);
    }
    _compileSchemaEnv(K) {
      if (K.meta ? this._compileMetaSchema(K) : a.compileSchema.call(this, K), !K.validate)
        throw new Error("ajv implementation error");
      return K.validate;
    }
    _compileMetaSchema(K) {
      const V = this.opts;
      this.opts = this._metaOpts;
      try {
        a.compileSchema.call(this, K);
      } finally {
        this.opts = V;
      }
    }
  }
  e.default = E, E.ValidationError = n.default, E.MissingRefError = i.default;
  function A(ie, K, V, z = "error") {
    for (const C in ie) {
      const q = C;
      q in K && this.logger[z](`${V}: option ${C}. ${ie[q]}`);
    }
  }
  function R(ie) {
    return ie = (0, c.normalizeId)(ie), this.schemas[ie] || this.refs[ie];
  }
  function I() {
    const ie = this.opts.schemas;
    if (ie)
      if (Array.isArray(ie))
        this.addSchema(ie);
      else
        for (const K in ie)
          this.addSchema(ie[K], K);
  }
  function D() {
    for (const ie in this.opts.formats) {
      const K = this.opts.formats[ie];
      K && this.addFormat(ie, K);
    }
  }
  function J(ie) {
    if (Array.isArray(ie)) {
      this.addVocabulary(ie);
      return;
    }
    this.logger.warn("keywords option as map is deprecated, pass array");
    for (const K in ie) {
      const V = ie[K];
      V.keyword || (V.keyword = K), this.addKeyword(V);
    }
  }
  function ae() {
    const ie = { ...this.opts };
    for (const K of y)
      delete ie[K];
    return ie;
  }
  const ye = { log() {
  }, warn() {
  }, error() {
  } };
  function xe(ie) {
    if (ie === !1)
      return ye;
    if (ie === void 0)
      return console;
    if (ie.log && ie.warn && ie.error)
      return ie;
    throw new Error("logger must implement log, warn and error methods");
  }
  const je = /^[a-z_$][a-z0-9_$:-]*$/i;
  function re(ie, K) {
    const { RULES: V } = this;
    if ((0, d.eachItem)(ie, (z) => {
      if (V.keywords[z])
        throw new Error(`Keyword ${z} is already defined`);
      if (!je.test(z))
        throw new Error(`Keyword ${z} has invalid name`);
    }), !!K && K.$data && !("code" in K || "validate" in K))
      throw new Error('$data keyword must have "code" or "validate" function');
  }
  function fe(ie, K, V) {
    var z;
    const C = K == null ? void 0 : K.post;
    if (V && C)
      throw new Error('keyword with "post" flag cannot have "type"');
    const { RULES: q } = this;
    let N = C ? q.post : q.rules.find(({ type: T }) => T === V);
    if (N || (N = { type: V, rules: [] }, q.rules.push(N)), q.keywords[ie] = !0, !K)
      return;
    const F = {
      keyword: ie,
      definition: {
        ...K,
        type: (0, l.getJSONTypes)(K.type),
        schemaType: (0, l.getJSONTypes)(K.schemaType)
      }
    };
    K.before ? le.call(this, N, F, K.before) : N.rules.push(F), q.all[ie] = F, (z = K.implements) === null || z === void 0 || z.forEach((T) => this.addKeyword(T));
  }
  function le(ie, K, V) {
    const z = ie.rules.findIndex((C) => C.keyword === V);
    z >= 0 ? ie.rules.splice(z, 0, K) : (ie.rules.push(K), this.logger.warn(`rule ${V} is not defined`));
  }
  function $e(ie) {
    let { metaSchema: K } = ie;
    K !== void 0 && (ie.$data && this.opts.$data && (K = _e(K)), ie.validateSchema = this.compile(K, !0));
  }
  const Ae = {
    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
  };
  function _e(ie) {
    return { anyOf: [ie, Ae] };
  }
})(Ja);
var Xg = {}, Qg = {}, e0 = {};
Object.defineProperty(e0, "__esModule", { value: !0 });
const uB = {
  keyword: "id",
  code() {
    throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
  }
};
e0.default = uB;
var ii = {};
Object.defineProperty(ii, "__esModule", { value: !0 });
ii.callRef = ii.getValidate = void 0;
const cB = sc, Xw = xt, Wr = ht, ja = nn, Qw = Nr, dl = Pt, lB = {
  keyword: "$ref",
  schemaType: "string",
  code(e) {
    const { gen: t, schema: r, it: n } = e, { baseId: i, schemaEnv: s, validateName: a, opts: u, self: c } = n, { root: l } = s;
    if ((r === "#" || r === "#/") && i === l.baseId)
      return p();
    const d = Qw.resolveRef.call(c, l, i, r);
    if (d === void 0)
      throw new cB.default(n.opts.uriResolver, i, r);
    if (d instanceof Qw.SchemaEnv)
      return h(d);
    return v(d);
    function p() {
      if (s === l)
        return Ml(e, a, s, s.$async);
      const y = t.scopeValue("root", { ref: l });
      return Ml(e, (0, Wr._)`${y}.validate`, l, l.$async);
    }
    function h(y) {
      const g = TP(e, y);
      Ml(e, g, y, y.$async);
    }
    function v(y) {
      const g = t.scopeValue("schema", u.code.source === !0 ? { ref: y, code: (0, Wr.stringify)(y) } : { ref: y }), _ = t.name("valid"), m = e.subschema({
        schema: y,
        dataTypes: [],
        schemaPath: Wr.nil,
        topSchemaRef: g,
        errSchemaPath: r
      }, _);
      e.mergeEvaluated(m), e.ok(_);
    }
  }
};
function TP(e, t) {
  const { gen: r } = e;
  return t.validate ? r.scopeValue("validate", { ref: t.validate }) : (0, Wr._)`${r.scopeValue("wrapper", { ref: t })}.validate`;
}
ii.getValidate = TP;
function Ml(e, t, r, n) {
  const { gen: i, it: s } = e, { allErrors: a, schemaEnv: u, opts: c } = s, l = c.passContext ? ja.default.this : Wr.nil;
  n ? d() : p();
  function d() {
    if (!u.$async)
      throw new Error("async schema referenced by sync schema");
    const y = i.let("valid");
    i.try(() => {
      i.code((0, Wr._)`await ${(0, Xw.callValidateCode)(e, t, l)}`), v(t), a || i.assign(y, !0);
    }, (g) => {
      i.if((0, Wr._)`!(${g} instanceof ${s.ValidationError})`, () => i.throw(g)), h(g), a || i.assign(y, !1);
    }), e.ok(y);
  }
  function p() {
    e.result((0, Xw.callValidateCode)(e, t, l), () => v(t), () => h(t));
  }
  function h(y) {
    const g = (0, Wr._)`${y}.errors`;
    i.assign(ja.default.vErrors, (0, Wr._)`${ja.default.vErrors} === null ? ${g} : ${ja.default.vErrors}.concat(${g})`), i.assign(ja.default.errors, (0, Wr._)`${ja.default.vErrors}.length`);
  }
  function v(y) {
    var g;
    if (!s.opts.unevaluated)
      return;
    const _ = (g = r == null ? void 0 : r.validate) === null || g === void 0 ? void 0 : g.evaluated;
    if (s.props !== !0)
      if (_ && !_.dynamicProps)
        _.props !== void 0 && (s.props = dl.mergeEvaluated.props(i, _.props, s.props));
      else {
        const m = i.var("props", (0, Wr._)`${y}.evaluated.props`);
        s.props = dl.mergeEvaluated.props(i, m, s.props, Wr.Name);
      }
    if (s.items !== !0)
      if (_ && !_.dynamicItems)
        _.items !== void 0 && (s.items = dl.mergeEvaluated.items(i, _.items, s.items));
      else {
        const m = i.var("items", (0, Wr._)`${y}.evaluated.items`);
        s.items = dl.mergeEvaluated.items(i, m, s.items, Wr.Name);
      }
  }
}
ii.callRef = Ml;
ii.default = lB;
Object.defineProperty(Qg, "__esModule", { value: !0 });
const fB = e0, dB = ii, pB = [
  "$schema",
  "$id",
  "$defs",
  "$vocabulary",
  { keyword: "$comment" },
  "definitions",
  fB.default,
  dB.default
];
Qg.default = pB;
var t0 = {}, r0 = {};
Object.defineProperty(r0, "__esModule", { value: !0 });
const yf = ht, Xi = yf.operators, gf = {
  maximum: { okStr: "<=", ok: Xi.LTE, fail: Xi.GT },
  minimum: { okStr: ">=", ok: Xi.GTE, fail: Xi.LT },
  exclusiveMaximum: { okStr: "<", ok: Xi.LT, fail: Xi.GTE },
  exclusiveMinimum: { okStr: ">", ok: Xi.GT, fail: Xi.LTE }
}, hB = {
  message: ({ keyword: e, schemaCode: t }) => (0, yf.str)`must be ${gf[e].okStr} ${t}`,
  params: ({ keyword: e, schemaCode: t }) => (0, yf._)`{comparison: ${gf[e].okStr}, limit: ${t}}`
}, mB = {
  keyword: Object.keys(gf),
  type: "number",
  schemaType: "number",
  $data: !0,
  error: hB,
  code(e) {
    const { keyword: t, data: r, schemaCode: n } = e;
    e.fail$data((0, yf._)`${r} ${gf[t].fail} ${n} || isNaN(${r})`);
  }
};
r0.default = mB;
var ed = {};
Object.defineProperty(ed, "__esModule", { value: !0 });
const pu = ht, yB = {
  message: ({ schemaCode: e }) => (0, pu.str)`must be multiple of ${e}`,
  params: ({ schemaCode: e }) => (0, pu._)`{multipleOf: ${e}}`
}, gB = {
  keyword: "multipleOf",
  type: "number",
  schemaType: "number",
  $data: !0,
  error: yB,
  code(e) {
    const { gen: t, data: r, schemaCode: n, it: i } = e, s = i.opts.multipleOfPrecision, a = t.let("res"), u = s ? (0, pu._)`Math.abs(Math.round(${a}) - ${a}) > 1e-${s}` : (0, pu._)`${a} !== parseInt(${a})`;
    e.fail$data((0, pu._)`(${n} === 0 || (${a} = ${r}/${n}, ${u}))`);
  }
};
ed.default = gB;
var td = {}, n0 = {};
Object.defineProperty(n0, "__esModule", { value: !0 });
function IP(e) {
  const t = e.length;
  let r = 0, n = 0, i;
  for (; n < t; )
    r++, i = e.charCodeAt(n++), i >= 55296 && i <= 56319 && n < t && (i = e.charCodeAt(n), (i & 64512) === 56320 && n++);
  return r;
}
n0.default = IP;
IP.code = 'require("ajv/dist/runtime/ucs2length").default';
Object.defineProperty(td, "__esModule", { value: !0 });
const qs = ht, vB = Pt, bB = n0, _B = {
  message({ keyword: e, schemaCode: t }) {
    const r = e === "maxLength" ? "more" : "fewer";
    return (0, qs.str)`must NOT have ${r} than ${t} characters`;
  },
  params: ({ schemaCode: e }) => (0, qs._)`{limit: ${e}}`
}, wB = {
  keyword: ["maxLength", "minLength"],
  type: "string",
  schemaType: "number",
  $data: !0,
  error: _B,
  code(e) {
    const { keyword: t, data: r, schemaCode: n, it: i } = e, s = t === "maxLength" ? qs.operators.GT : qs.operators.LT, a = i.opts.unicode === !1 ? (0, qs._)`${r}.length` : (0, qs._)`${(0, vB.useFunc)(e.gen, bB.default)}(${r})`;
    e.fail$data((0, qs._)`${a} ${s} ${n}`);
  }
};
td.default = wB;
var rd = {};
Object.defineProperty(rd, "__esModule", { value: !0 });
const $B = xt, vf = ht, EB = {
  message: ({ schemaCode: e }) => (0, vf.str)`must match pattern "${e}"`,
  params: ({ schemaCode: e }) => (0, vf._)`{pattern: ${e}}`
}, xB = {
  keyword: "pattern",
  type: "string",
  schemaType: "string",
  $data: !0,
  error: EB,
  code(e) {
    const { data: t, $data: r, schema: n, schemaCode: i, it: s } = e, a = s.opts.unicodeRegExp ? "u" : "", u = r ? (0, vf._)`(new RegExp(${i}, ${a}))` : (0, $B.usePattern)(e, n);
    e.fail$data((0, vf._)`!${u}.test(${t})`);
  }
};
rd.default = xB;
var nd = {};
Object.defineProperty(nd, "__esModule", { value: !0 });
const hu = ht, OB = {
  message({ keyword: e, schemaCode: t }) {
    const r = e === "maxProperties" ? "more" : "fewer";
    return (0, hu.str)`must NOT have ${r} than ${t} properties`;
  },
  params: ({ schemaCode: e }) => (0, hu._)`{limit: ${e}}`
}, PB = {
  keyword: ["maxProperties", "minProperties"],
  type: "object",
  schemaType: "number",
  $data: !0,
  error: OB,
  code(e) {
    const { keyword: t, data: r, schemaCode: n } = e, i = t === "maxProperties" ? hu.operators.GT : hu.operators.LT;
    e.fail$data((0, hu._)`Object.keys(${r}).length ${i} ${n}`);
  }
};
nd.default = PB;
var id = {};
Object.defineProperty(id, "__esModule", { value: !0 });
const Jo = xt, mu = ht, SB = Pt, AB = {
  message: ({ params: { missingProperty: e } }) => (0, mu.str)`must have required property '${e}'`,
  params: ({ params: { missingProperty: e } }) => (0, mu._)`{missingProperty: ${e}}`
}, CB = {
  keyword: "required",
  type: "object",
  schemaType: "array",
  $data: !0,
  error: AB,
  code(e) {
    const { gen: t, schema: r, schemaCode: n, data: i, $data: s, it: a } = e, { opts: u } = a;
    if (!s && r.length === 0)
      return;
    const c = r.length >= u.loopRequired;
    if (a.allErrors ? l() : d(), u.strictRequired) {
      const v = e.parentSchema.properties, { definedProperties: y } = e.it;
      for (const g of r)
        if ((v == null ? void 0 : v[g]) === void 0 && !y.has(g)) {
          const _ = a.schemaEnv.baseId + a.errSchemaPath, m = `required property "${g}" is not defined at "${_}" (strictRequired)`;
          (0, SB.checkStrictMode)(a, m, a.opts.strictRequired);
        }
    }
    function l() {
      if (c || s)
        e.block$data(mu.nil, p);
      else
        for (const v of r)
          (0, Jo.checkReportMissingProp)(e, v);
    }
    function d() {
      const v = t.let("missing");
      if (c || s) {
        const y = t.let("valid", !0);
        e.block$data(y, () => h(v, y)), e.ok(y);
      } else
        t.if((0, Jo.checkMissingProp)(e, r, v)), (0, Jo.reportMissingProp)(e, v), t.else();
    }
    function p() {
      t.forOf("prop", n, (v) => {
        e.setParams({ missingProperty: v }), t.if((0, Jo.noPropertyInData)(t, i, v, u.ownProperties), () => e.error());
      });
    }
    function h(v, y) {
      e.setParams({ missingProperty: v }), t.forOf(v, n, () => {
        t.assign(y, (0, Jo.propertyInData)(t, i, v, u.ownProperties)), t.if((0, mu.not)(y), () => {
          e.error(), t.break();
        });
      }, mu.nil);
    }
  }
};
id.default = CB;
var sd = {};
Object.defineProperty(sd, "__esModule", { value: !0 });
const yu = ht, RB = {
  message({ keyword: e, schemaCode: t }) {
    const r = e === "maxItems" ? "more" : "fewer";
    return (0, yu.str)`must NOT have ${r} than ${t} items`;
  },
  params: ({ schemaCode: e }) => (0, yu._)`{limit: ${e}}`
}, TB = {
  keyword: ["maxItems", "minItems"],
  type: "array",
  schemaType: "number",
  $data: !0,
  error: RB,
  code(e) {
    const { keyword: t, data: r, schemaCode: n } = e, i = t === "maxItems" ? yu.operators.GT : yu.operators.LT;
    e.fail$data((0, yu._)`${r}.length ${i} ${n}`);
  }
};
sd.default = TB;
var ad = {}, ac = {};
Object.defineProperty(ac, "__esModule", { value: !0 });
const jP = pP;
jP.code = 'require("ajv/dist/runtime/equal").default';
ac.default = jP;
Object.defineProperty(ad, "__esModule", { value: !0 });
const Yh = nc, gr = ht, IB = Pt, jB = ac, kB = {
  message: ({ params: { i: e, j: t } }) => (0, gr.str)`must NOT have duplicate items (items ## ${t} and ${e} are identical)`,
  params: ({ params: { i: e, j: t } }) => (0, gr._)`{i: ${e}, j: ${t}}`
}, MB = {
  keyword: "uniqueItems",
  type: "array",
  schemaType: "boolean",
  $data: !0,
  error: kB,
  code(e) {
    const { gen: t, data: r, $data: n, schema: i, parentSchema: s, schemaCode: a, it: u } = e;
    if (!n && !i)
      return;
    const c = t.let("valid"), l = s.items ? (0, Yh.getSchemaTypes)(s.items) : [];
    e.block$data(c, d, (0, gr._)`${a} === false`), e.ok(c);
    function d() {
      const y = t.let("i", (0, gr._)`${r}.length`), g = t.let("j");
      e.setParams({ i: y, j: g }), t.assign(c, !0), t.if((0, gr._)`${y} > 1`, () => (p() ? h : v)(y, g));
    }
    function p() {
      return l.length > 0 && !l.some((y) => y === "object" || y === "array");
    }
    function h(y, g) {
      const _ = t.name("item"), m = (0, Yh.checkDataTypes)(l, _, u.opts.strictNumbers, Yh.DataType.Wrong), w = t.const("indices", (0, gr._)`{}`);
      t.for((0, gr._)`;${y}--;`, () => {
        t.let(_, (0, gr._)`${r}[${y}]`), t.if(m, (0, gr._)`continue`), l.length > 1 && t.if((0, gr._)`typeof ${_} == "string"`, (0, gr._)`${_} += "_"`), t.if((0, gr._)`typeof ${w}[${_}] == "number"`, () => {
          t.assign(g, (0, gr._)`${w}[${_}]`), e.error(), t.assign(c, !1).break();
        }).code((0, gr._)`${w}[${_}] = ${y}`);
      });
    }
    function v(y, g) {
      const _ = (0, IB.useFunc)(t, jB.default), m = t.name("outer");
      t.label(m).for((0, gr._)`;${y}--;`, () => t.for((0, gr._)`${g} = ${y}; ${g}--;`, () => t.if((0, gr._)`${_}(${r}[${y}], ${r}[${g}])`, () => {
        e.error(), t.assign(c, !1).break(m);
      })));
    }
  }
};
ad.default = MB;
var od = {};
Object.defineProperty(od, "__esModule", { value: !0 });
const qy = ht, NB = Pt, DB = ac, LB = {
  message: "must be equal to constant",
  params: ({ schemaCode: e }) => (0, qy._)`{allowedValue: ${e}}`
}, qB = {
  keyword: "const",
  $data: !0,
  error: LB,
  code(e) {
    const { gen: t, data: r, $data: n, schemaCode: i, schema: s } = e;
    n || s && typeof s == "object" ? e.fail$data((0, qy._)`!${(0, NB.useFunc)(t, DB.default)}(${r}, ${i})`) : e.fail((0, qy._)`${s} !== ${r}`);
  }
};
od.default = qB;
var ud = {};
Object.defineProperty(ud, "__esModule", { value: !0 });
const su = ht, FB = Pt, UB = ac, BB = {
  message: "must be equal to one of the allowed values",
  params: ({ schemaCode: e }) => (0, su._)`{allowedValues: ${e}}`
}, VB = {
  keyword: "enum",
  schemaType: "array",
  $data: !0,
  error: BB,
  code(e) {
    const { gen: t, data: r, $data: n, schema: i, schemaCode: s, it: a } = e;
    if (!n && i.length === 0)
      throw new Error("enum must have non-empty array");
    const u = i.length >= a.opts.loopEnum;
    let c;
    const l = () => c ?? (c = (0, FB.useFunc)(t, UB.default));
    let d;
    if (u || n)
      d = t.let("valid"), e.block$data(d, p);
    else {
      if (!Array.isArray(i))
        throw new Error("ajv implementation error");
      const v = t.const("vSchema", s);
      d = (0, su.or)(...i.map((y, g) => h(v, g)));
    }
    e.pass(d);
    function p() {
      t.assign(d, !1), t.forOf("v", s, (v) => t.if((0, su._)`${l()}(${r}, ${v})`, () => t.assign(d, !0).break()));
    }
    function h(v, y) {
      const g = i[y];
      return typeof g == "object" && g !== null ? (0, su._)`${l()}(${r}, ${v}[${y}])` : (0, su._)`${r} === ${g}`;
    }
  }
};
ud.default = VB;
Object.defineProperty(t0, "__esModule", { value: !0 });
const ZB = r0, zB = ed, WB = td, HB = rd, GB = nd, KB = id, YB = sd, JB = ad, XB = od, QB = ud, e9 = [
  // number
  ZB.default,
  zB.default,
  // string
  WB.default,
  HB.default,
  // object
  GB.default,
  KB.default,
  // array
  YB.default,
  JB.default,
  // any
  { keyword: "type", schemaType: ["string", "array"] },
  { keyword: "nullable", schemaType: "boolean" },
  XB.default,
  QB.default
];
t0.default = e9;
var cd = {}, mo = {};
Object.defineProperty(mo, "__esModule", { value: !0 });
mo.validateAdditionalItems = void 0;
const Fs = ht, Fy = Pt, t9 = {
  message: ({ params: { len: e } }) => (0, Fs.str)`must NOT have more than ${e} items`,
  params: ({ params: { len: e } }) => (0, Fs._)`{limit: ${e}}`
}, r9 = {
  keyword: "additionalItems",
  type: "array",
  schemaType: ["boolean", "object"],
  before: "uniqueItems",
  error: t9,
  code(e) {
    const { parentSchema: t, it: r } = e, { items: n } = t;
    if (!Array.isArray(n)) {
      (0, Fy.checkStrictMode)(r, '"additionalItems" is ignored when "items" is not an array of schemas');
      return;
    }
    kP(e, n);
  }
};
function kP(e, t) {
  const { gen: r, schema: n, data: i, keyword: s, it: a } = e;
  a.items = !0;
  const u = r.const("len", (0, Fs._)`${i}.length`);
  if (n === !1)
    e.setParams({ len: t.length }), e.pass((0, Fs._)`${u} <= ${t.length}`);
  else if (typeof n == "object" && !(0, Fy.alwaysValidSchema)(a, n)) {
    const l = r.var("valid", (0, Fs._)`${u} <= ${t.length}`);
    r.if((0, Fs.not)(l), () => c(l)), e.ok(l);
  }
  function c(l) {
    r.forRange("i", t.length, u, (d) => {
      e.subschema({ keyword: s, dataProp: d, dataPropType: Fy.Type.Num }, l), a.allErrors || r.if((0, Fs.not)(l), () => r.break());
    });
  }
}
mo.validateAdditionalItems = kP;
mo.default = r9;
var i0 = {}, yo = {};
Object.defineProperty(yo, "__esModule", { value: !0 });
yo.validateTuple = void 0;
const e$ = ht, Nl = Pt, n9 = xt, i9 = {
  keyword: "items",
  type: "array",
  schemaType: ["object", "array", "boolean"],
  before: "uniqueItems",
  code(e) {
    const { schema: t, it: r } = e;
    if (Array.isArray(t))
      return MP(e, "additionalItems", t);
    r.items = !0, !(0, Nl.alwaysValidSchema)(r, t) && e.ok((0, n9.validateArray)(e));
  }
};
function MP(e, t, r = e.schema) {
  const { gen: n, parentSchema: i, data: s, keyword: a, it: u } = e;
  d(i), u.opts.unevaluated && r.length && u.items !== !0 && (u.items = Nl.mergeEvaluated.items(n, r.length, u.items));
  const c = n.name("valid"), l = n.const("len", (0, e$._)`${s}.length`);
  r.forEach((p, h) => {
    (0, Nl.alwaysValidSchema)(u, p) || (n.if((0, e$._)`${l} > ${h}`, () => e.subschema({
      keyword: a,
      schemaProp: h,
      dataProp: h
    }, c)), e.ok(c));
  });
  function d(p) {
    const { opts: h, errSchemaPath: v } = u, y = r.length, g = y === p.minItems && (y === p.maxItems || p[t] === !1);
    if (h.strictTuples && !g) {
      const _ = `"${a}" is ${y}-tuple, but minItems or maxItems/${t} are not specified or different at path "${v}"`;
      (0, Nl.checkStrictMode)(u, _, h.strictTuples);
    }
  }
}
yo.validateTuple = MP;
yo.default = i9;
Object.defineProperty(i0, "__esModule", { value: !0 });
const s9 = yo, a9 = {
  keyword: "prefixItems",
  type: "array",
  schemaType: ["array"],
  before: "uniqueItems",
  code: (e) => (0, s9.validateTuple)(e, "items")
};
i0.default = a9;
var s0 = {};
Object.defineProperty(s0, "__esModule", { value: !0 });
const t$ = ht, o9 = Pt, u9 = xt, c9 = mo, l9 = {
  message: ({ params: { len: e } }) => (0, t$.str)`must NOT have more than ${e} items`,
  params: ({ params: { len: e } }) => (0, t$._)`{limit: ${e}}`
}, f9 = {
  keyword: "items",
  type: "array",
  schemaType: ["object", "boolean"],
  before: "uniqueItems",
  error: l9,
  code(e) {
    const { schema: t, parentSchema: r, it: n } = e, { prefixItems: i } = r;
    n.items = !0, !(0, o9.alwaysValidSchema)(n, t) && (i ? (0, c9.validateAdditionalItems)(e, i) : e.ok((0, u9.validateArray)(e)));
  }
};
s0.default = f9;
var a0 = {};
Object.defineProperty(a0, "__esModule", { value: !0 });
const hn = ht, pl = Pt, d9 = {
  message: ({ params: { min: e, max: t } }) => t === void 0 ? (0, hn.str)`must contain at least ${e} valid item(s)` : (0, hn.str)`must contain at least ${e} and no more than ${t} valid item(s)`,
  params: ({ params: { min: e, max: t } }) => t === void 0 ? (0, hn._)`{minContains: ${e}}` : (0, hn._)`{minContains: ${e}, maxContains: ${t}}`
}, p9 = {
  keyword: "contains",
  type: "array",
  schemaType: ["object", "boolean"],
  before: "uniqueItems",
  trackErrors: !0,
  error: d9,
  code(e) {
    const { gen: t, schema: r, parentSchema: n, data: i, it: s } = e;
    let a, u;
    const { minContains: c, maxContains: l } = n;
    s.opts.next ? (a = c === void 0 ? 1 : c, u = l) : a = 1;
    const d = t.const("len", (0, hn._)`${i}.length`);
    if (e.setParams({ min: a, max: u }), u === void 0 && a === 0) {
      (0, pl.checkStrictMode)(s, '"minContains" == 0 without "maxContains": "contains" keyword ignored');
      return;
    }
    if (u !== void 0 && a > u) {
      (0, pl.checkStrictMode)(s, '"minContains" > "maxContains" is always invalid'), e.fail();
      return;
    }
    if ((0, pl.alwaysValidSchema)(s, r)) {
      let g = (0, hn._)`${d} >= ${a}`;
      u !== void 0 && (g = (0, hn._)`${g} && ${d} <= ${u}`), e.pass(g);
      return;
    }
    s.items = !0;
    const p = t.name("valid");
    u === void 0 && a === 1 ? v(p, () => t.if(p, () => t.break())) : a === 0 ? (t.let(p, !0), u !== void 0 && t.if((0, hn._)`${i}.length > 0`, h)) : (t.let(p, !1), h()), e.result(p, () => e.reset());
    function h() {
      const g = t.name("_valid"), _ = t.let("count", 0);
      v(g, () => t.if(g, () => y(_)));
    }
    function v(g, _) {
      t.forRange("i", 0, d, (m) => {
        e.subschema({
          keyword: "contains",
          dataProp: m,
          dataPropType: pl.Type.Num,
          compositeRule: !0
        }, g), _();
      });
    }
    function y(g) {
      t.code((0, hn._)`${g}++`), u === void 0 ? t.if((0, hn._)`${g} >= ${a}`, () => t.assign(p, !0).break()) : (t.if((0, hn._)`${g} > ${u}`, () => t.assign(p, !1).break()), a === 1 ? t.assign(p, !0) : t.if((0, hn._)`${g} >= ${a}`, () => t.assign(p, !0)));
    }
  }
};
a0.default = p9;
var ld = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.validateSchemaDeps = e.validatePropertyDeps = e.error = void 0;
  const t = ht, r = Pt, n = xt;
  e.error = {
    message: ({ params: { property: c, depsCount: l, deps: d } }) => {
      const p = l === 1 ? "property" : "properties";
      return (0, t.str)`must have ${p} ${d} when property ${c} is present`;
    },
    params: ({ params: { property: c, depsCount: l, deps: d, missingProperty: p } }) => (0, t._)`{property: ${c},
    missingProperty: ${p},
    depsCount: ${l},
    deps: ${d}}`
    // TODO change to reference
  };
  const i = {
    keyword: "dependencies",
    type: "object",
    schemaType: "object",
    error: e.error,
    code(c) {
      const [l, d] = s(c);
      a(c, l), u(c, d);
    }
  };
  function s({ schema: c }) {
    const l = {}, d = {};
    for (const p in c) {
      if (p === "__proto__")
        continue;
      const h = Array.isArray(c[p]) ? l : d;
      h[p] = c[p];
    }
    return [l, d];
  }
  function a(c, l = c.schema) {
    const { gen: d, data: p, it: h } = c;
    if (Object.keys(l).length === 0)
      return;
    const v = d.let("missing");
    for (const y in l) {
      const g = l[y];
      if (g.length === 0)
        continue;
      const _ = (0, n.propertyInData)(d, p, y, h.opts.ownProperties);
      c.setParams({
        property: y,
        depsCount: g.length,
        deps: g.join(", ")
      }), h.allErrors ? d.if(_, () => {
        for (const m of g)
          (0, n.checkReportMissingProp)(c, m);
      }) : (d.if((0, t._)`${_} && (${(0, n.checkMissingProp)(c, g, v)})`), (0, n.reportMissingProp)(c, v), d.else());
    }
  }
  e.validatePropertyDeps = a;
  function u(c, l = c.schema) {
    const { gen: d, data: p, keyword: h, it: v } = c, y = d.name("valid");
    for (const g in l)
      (0, r.alwaysValidSchema)(v, l[g]) || (d.if(
        (0, n.propertyInData)(d, p, g, v.opts.ownProperties),
        () => {
          const _ = c.subschema({ keyword: h, schemaProp: g }, y);
          c.mergeValidEvaluated(_, y);
        },
        () => d.var(y, !0)
        // TODO var
      ), c.ok(y));
  }
  e.validateSchemaDeps = u, e.default = i;
})(ld);
var o0 = {};
Object.defineProperty(o0, "__esModule", { value: !0 });
const NP = ht, h9 = Pt, m9 = {
  message: "property name must be valid",
  params: ({ params: e }) => (0, NP._)`{propertyName: ${e.propertyName}}`
}, y9 = {
  keyword: "propertyNames",
  type: "object",
  schemaType: ["object", "boolean"],
  error: m9,
  code(e) {
    const { gen: t, schema: r, data: n, it: i } = e;
    if ((0, h9.alwaysValidSchema)(i, r))
      return;
    const s = t.name("valid");
    t.forIn("key", n, (a) => {
      e.setParams({ propertyName: a }), e.subschema({
        keyword: "propertyNames",
        data: a,
        dataTypes: ["string"],
        propertyName: a,
        compositeRule: !0
      }, s), t.if((0, NP.not)(s), () => {
        e.error(!0), i.allErrors || t.break();
      });
    }), e.ok(s);
  }
};
o0.default = y9;
var fd = {};
Object.defineProperty(fd, "__esModule", { value: !0 });
const hl = xt, On = ht, g9 = nn, ml = Pt, v9 = {
  message: "must NOT have additional properties",
  params: ({ params: e }) => (0, On._)`{additionalProperty: ${e.additionalProperty}}`
}, b9 = {
  keyword: "additionalProperties",
  type: ["object"],
  schemaType: ["boolean", "object"],
  allowUndefined: !0,
  trackErrors: !0,
  error: v9,
  code(e) {
    const { gen: t, schema: r, parentSchema: n, data: i, errsCount: s, it: a } = e;
    if (!s)
      throw new Error("ajv implementation error");
    const { allErrors: u, opts: c } = a;
    if (a.props = !0, c.removeAdditional !== "all" && (0, ml.alwaysValidSchema)(a, r))
      return;
    const l = (0, hl.allSchemaProperties)(n.properties), d = (0, hl.allSchemaProperties)(n.patternProperties);
    p(), e.ok((0, On._)`${s} === ${g9.default.errors}`);
    function p() {
      t.forIn("key", i, (_) => {
        !l.length && !d.length ? y(_) : t.if(h(_), () => y(_));
      });
    }
    function h(_) {
      let m;
      if (l.length > 8) {
        const w = (0, ml.schemaRefOrVal)(a, n.properties, "properties");
        m = (0, hl.isOwnProperty)(t, w, _);
      } else
        l.length ? m = (0, On.or)(...l.map((w) => (0, On._)`${_} === ${w}`)) : m = On.nil;
      return d.length && (m = (0, On.or)(m, ...d.map((w) => (0, On._)`${(0, hl.usePattern)(e, w)}.test(${_})`))), (0, On.not)(m);
    }
    function v(_) {
      t.code((0, On._)`delete ${i}[${_}]`);
    }
    function y(_) {
      if (c.removeAdditional === "all" || c.removeAdditional && r === !1) {
        v(_);
        return;
      }
      if (r === !1) {
        e.setParams({ additionalProperty: _ }), e.error(), u || t.break();
        return;
      }
      if (typeof r == "object" && !(0, ml.alwaysValidSchema)(a, r)) {
        const m = t.name("valid");
        c.removeAdditional === "failing" ? (g(_, m, !1), t.if((0, On.not)(m), () => {
          e.reset(), v(_);
        })) : (g(_, m), u || t.if((0, On.not)(m), () => t.break()));
      }
    }
    function g(_, m, w) {
      const $ = {
        keyword: "additionalProperties",
        dataProp: _,
        dataPropType: ml.Type.Str
      };
      w === !1 && Object.assign($, {
        compositeRule: !0,
        createErrors: !1,
        allErrors: !1
      }), e.subschema($, m);
    }
  }
};
fd.default = b9;
var u0 = {};
Object.defineProperty(u0, "__esModule", { value: !0 });
const _9 = jn, r$ = xt, Jh = Pt, n$ = fd, w9 = {
  keyword: "properties",
  type: "object",
  schemaType: "object",
  code(e) {
    const { gen: t, schema: r, parentSchema: n, data: i, it: s } = e;
    s.opts.removeAdditional === "all" && n.additionalProperties === void 0 && n$.default.code(new _9.KeywordCxt(s, n$.default, "additionalProperties"));
    const a = (0, r$.allSchemaProperties)(r);
    for (const p of a)
      s.definedProperties.add(p);
    s.opts.unevaluated && a.length && s.props !== !0 && (s.props = Jh.mergeEvaluated.props(t, (0, Jh.toHash)(a), s.props));
    const u = a.filter((p) => !(0, Jh.alwaysValidSchema)(s, r[p]));
    if (u.length === 0)
      return;
    const c = t.name("valid");
    for (const p of u)
      l(p) ? d(p) : (t.if((0, r$.propertyInData)(t, i, p, s.opts.ownProperties)), d(p), s.allErrors || t.else().var(c, !0), t.endIf()), e.it.definedProperties.add(p), e.ok(c);
    function l(p) {
      return s.opts.useDefaults && !s.compositeRule && r[p].default !== void 0;
    }
    function d(p) {
      e.subschema({
        keyword: "properties",
        schemaProp: p,
        dataProp: p
      }, c);
    }
  }
};
u0.default = w9;
var c0 = {};
Object.defineProperty(c0, "__esModule", { value: !0 });
const i$ = xt, yl = ht, s$ = Pt, a$ = Pt, $9 = {
  keyword: "patternProperties",
  type: "object",
  schemaType: "object",
  code(e) {
    const { gen: t, schema: r, data: n, parentSchema: i, it: s } = e, { opts: a } = s, u = (0, i$.allSchemaProperties)(r), c = u.filter((g) => (0, s$.alwaysValidSchema)(s, r[g]));
    if (u.length === 0 || c.length === u.length && (!s.opts.unevaluated || s.props === !0))
      return;
    const l = a.strictSchema && !a.allowMatchingProperties && i.properties, d = t.name("valid");
    s.props !== !0 && !(s.props instanceof yl.Name) && (s.props = (0, a$.evaluatedPropsToName)(t, s.props));
    const { props: p } = s;
    h();
    function h() {
      for (const g of u)
        l && v(g), s.allErrors ? y(g) : (t.var(d, !0), y(g), t.if(d));
    }
    function v(g) {
      for (const _ in l)
        new RegExp(g).test(_) && (0, s$.checkStrictMode)(s, `property ${_} matches pattern ${g} (use allowMatchingProperties)`);
    }
    function y(g) {
      t.forIn("key", n, (_) => {
        t.if((0, yl._)`${(0, i$.usePattern)(e, g)}.test(${_})`, () => {
          const m = c.includes(g);
          m || e.subschema({
            keyword: "patternProperties",
            schemaProp: g,
            dataProp: _,
            dataPropType: a$.Type.Str
          }, d), s.opts.unevaluated && p !== !0 ? t.assign((0, yl._)`${p}[${_}]`, !0) : !m && !s.allErrors && t.if((0, yl.not)(d), () => t.break());
        });
      });
    }
  }
};
c0.default = $9;
var l0 = {};
Object.defineProperty(l0, "__esModule", { value: !0 });
const E9 = Pt, x9 = {
  keyword: "not",
  schemaType: ["object", "boolean"],
  trackErrors: !0,
  code(e) {
    const { gen: t, schema: r, it: n } = e;
    if ((0, E9.alwaysValidSchema)(n, r)) {
      e.fail();
      return;
    }
    const i = t.name("valid");
    e.subschema({
      keyword: "not",
      compositeRule: !0,
      createErrors: !1,
      allErrors: !1
    }, i), e.failResult(i, () => e.reset(), () => e.error());
  },
  error: { message: "must NOT be valid" }
};
l0.default = x9;
var f0 = {};
Object.defineProperty(f0, "__esModule", { value: !0 });
const O9 = xt, P9 = {
  keyword: "anyOf",
  schemaType: "array",
  trackErrors: !0,
  code: O9.validateUnion,
  error: { message: "must match a schema in anyOf" }
};
f0.default = P9;
var d0 = {};
Object.defineProperty(d0, "__esModule", { value: !0 });
const Dl = ht, S9 = Pt, A9 = {
  message: "must match exactly one schema in oneOf",
  params: ({ params: e }) => (0, Dl._)`{passingSchemas: ${e.passing}}`
}, C9 = {
  keyword: "oneOf",
  schemaType: "array",
  trackErrors: !0,
  error: A9,
  code(e) {
    const { gen: t, schema: r, parentSchema: n, it: i } = e;
    if (!Array.isArray(r))
      throw new Error("ajv implementation error");
    if (i.opts.discriminator && n.discriminator)
      return;
    const s = r, a = t.let("valid", !1), u = t.let("passing", null), c = t.name("_valid");
    e.setParams({ passing: u }), t.block(l), e.result(a, () => e.reset(), () => e.error(!0));
    function l() {
      s.forEach((d, p) => {
        let h;
        (0, S9.alwaysValidSchema)(i, d) ? t.var(c, !0) : h = e.subschema({
          keyword: "oneOf",
          schemaProp: p,
          compositeRule: !0
        }, c), p > 0 && t.if((0, Dl._)`${c} && ${a}`).assign(a, !1).assign(u, (0, Dl._)`[${u}, ${p}]`).else(), t.if(c, () => {
          t.assign(a, !0), t.assign(u, p), h && e.mergeEvaluated(h, Dl.Name);
        });
      });
    }
  }
};
d0.default = C9;
var p0 = {};
Object.defineProperty(p0, "__esModule", { value: !0 });
const R9 = Pt, T9 = {
  keyword: "allOf",
  schemaType: "array",
  code(e) {
    const { gen: t, schema: r, it: n } = e;
    if (!Array.isArray(r))
      throw new Error("ajv implementation error");
    const i = t.name("valid");
    r.forEach((s, a) => {
      if ((0, R9.alwaysValidSchema)(n, s))
        return;
      const u = e.subschema({ keyword: "allOf", schemaProp: a }, i);
      e.ok(i), e.mergeEvaluated(u);
    });
  }
};
p0.default = T9;
var h0 = {};
Object.defineProperty(h0, "__esModule", { value: !0 });
const bf = ht, DP = Pt, I9 = {
  message: ({ params: e }) => (0, bf.str)`must match "${e.ifClause}" schema`,
  params: ({ params: e }) => (0, bf._)`{failingKeyword: ${e.ifClause}}`
}, j9 = {
  keyword: "if",
  schemaType: ["object", "boolean"],
  trackErrors: !0,
  error: I9,
  code(e) {
    const { gen: t, parentSchema: r, it: n } = e;
    r.then === void 0 && r.else === void 0 && (0, DP.checkStrictMode)(n, '"if" without "then" and "else" is ignored');
    const i = o$(n, "then"), s = o$(n, "else");
    if (!i && !s)
      return;
    const a = t.let("valid", !0), u = t.name("_valid");
    if (c(), e.reset(), i && s) {
      const d = t.let("ifClause");
      e.setParams({ ifClause: d }), t.if(u, l("then", d), l("else", d));
    } else
      i ? t.if(u, l("then")) : t.if((0, bf.not)(u), l("else"));
    e.pass(a, () => e.error(!0));
    function c() {
      const d = e.subschema({
        keyword: "if",
        compositeRule: !0,
        createErrors: !1,
        allErrors: !1
      }, u);
      e.mergeEvaluated(d);
    }
    function l(d, p) {
      return () => {
        const h = e.subschema({ keyword: d }, u);
        t.assign(a, u), e.mergeValidEvaluated(h, a), p ? t.assign(p, (0, bf._)`${d}`) : e.setParams({ ifClause: d });
      };
    }
  }
};
function o$(e, t) {
  const r = e.schema[t];
  return r !== void 0 && !(0, DP.alwaysValidSchema)(e, r);
}
h0.default = j9;
var m0 = {};
Object.defineProperty(m0, "__esModule", { value: !0 });
const k9 = Pt, M9 = {
  keyword: ["then", "else"],
  schemaType: ["object", "boolean"],
  code({ keyword: e, parentSchema: t, it: r }) {
    t.if === void 0 && (0, k9.checkStrictMode)(r, `"${e}" without "if" is ignored`);
  }
};
m0.default = M9;
Object.defineProperty(cd, "__esModule", { value: !0 });
const N9 = mo, D9 = i0, L9 = yo, q9 = s0, F9 = a0, U9 = ld, B9 = o0, V9 = fd, Z9 = u0, z9 = c0, W9 = l0, H9 = f0, G9 = d0, K9 = p0, Y9 = h0, J9 = m0;
function X9(e = !1) {
  const t = [
    // any
    W9.default,
    H9.default,
    G9.default,
    K9.default,
    Y9.default,
    J9.default,
    // object
    B9.default,
    V9.default,
    U9.default,
    Z9.default,
    z9.default
  ];
  return e ? t.push(D9.default, q9.default) : t.push(N9.default, L9.default), t.push(F9.default), t;
}
cd.default = X9;
var y0 = {}, go = {};
Object.defineProperty(go, "__esModule", { value: !0 });
go.dynamicAnchor = void 0;
const Xh = ht, Q9 = nn, u$ = Nr, e7 = ii, t7 = {
  keyword: "$dynamicAnchor",
  schemaType: "string",
  code: (e) => LP(e, e.schema)
};
function LP(e, t) {
  const { gen: r, it: n } = e;
  n.schemaEnv.root.dynamicAnchors[t] = !0;
  const i = (0, Xh._)`${Q9.default.dynamicAnchors}${(0, Xh.getProperty)(t)}`, s = n.errSchemaPath === "#" ? n.validateName : r7(e);
  r.if((0, Xh._)`!${i}`, () => r.assign(i, s));
}
go.dynamicAnchor = LP;
function r7(e) {
  const { schemaEnv: t, schema: r, self: n } = e.it, { root: i, baseId: s, localRefs: a, meta: u } = t.root, { schemaId: c } = n.opts, l = new u$.SchemaEnv({ schema: r, schemaId: c, root: i, baseId: s, localRefs: a, meta: u });
  return u$.compileSchema.call(n, l), (0, e7.getValidate)(e, l);
}
go.default = t7;
var vo = {};
Object.defineProperty(vo, "__esModule", { value: !0 });
vo.dynamicRef = void 0;
const c$ = ht, n7 = nn, l$ = ii, i7 = {
  keyword: "$dynamicRef",
  schemaType: "string",
  code: (e) => qP(e, e.schema)
};
function qP(e, t) {
  const { gen: r, keyword: n, it: i } = e;
  if (t[0] !== "#")
    throw new Error(`"${n}" only supports hash fragment reference`);
  const s = t.slice(1);
  if (i.allErrors)
    a();
  else {
    const c = r.let("valid", !1);
    a(c), e.ok(c);
  }
  function a(c) {
    if (i.schemaEnv.root.dynamicAnchors[s]) {
      const l = r.let("_v", (0, c$._)`${n7.default.dynamicAnchors}${(0, c$.getProperty)(s)}`);
      r.if(l, u(l, c), u(i.validateName, c));
    } else
      u(i.validateName, c)();
  }
  function u(c, l) {
    return l ? () => r.block(() => {
      (0, l$.callRef)(e, c), r.let(l, !0);
    }) : () => (0, l$.callRef)(e, c);
  }
}
vo.dynamicRef = qP;
vo.default = i7;
var g0 = {};
Object.defineProperty(g0, "__esModule", { value: !0 });
const s7 = go, a7 = Pt, o7 = {
  keyword: "$recursiveAnchor",
  schemaType: "boolean",
  code(e) {
    e.schema ? (0, s7.dynamicAnchor)(e, "") : (0, a7.checkStrictMode)(e.it, "$recursiveAnchor: false is ignored");
  }
};
g0.default = o7;
var v0 = {};
Object.defineProperty(v0, "__esModule", { value: !0 });
const u7 = vo, c7 = {
  keyword: "$recursiveRef",
  schemaType: "string",
  code: (e) => (0, u7.dynamicRef)(e, e.schema)
};
v0.default = c7;
Object.defineProperty(y0, "__esModule", { value: !0 });
const l7 = go, f7 = vo, d7 = g0, p7 = v0, h7 = [l7.default, f7.default, d7.default, p7.default];
y0.default = h7;
var b0 = {}, _0 = {};
Object.defineProperty(_0, "__esModule", { value: !0 });
const f$ = ld, m7 = {
  keyword: "dependentRequired",
  type: "object",
  schemaType: "object",
  error: f$.error,
  code: (e) => (0, f$.validatePropertyDeps)(e)
};
_0.default = m7;
var w0 = {};
Object.defineProperty(w0, "__esModule", { value: !0 });
const y7 = ld, g7 = {
  keyword: "dependentSchemas",
  type: "object",
  schemaType: "object",
  code: (e) => (0, y7.validateSchemaDeps)(e)
};
w0.default = g7;
var $0 = {};
Object.defineProperty($0, "__esModule", { value: !0 });
const v7 = Pt, b7 = {
  keyword: ["maxContains", "minContains"],
  type: "array",
  schemaType: "number",
  code({ keyword: e, parentSchema: t, it: r }) {
    t.contains === void 0 && (0, v7.checkStrictMode)(r, `"${e}" without "contains" is ignored`);
  }
};
$0.default = b7;
Object.defineProperty(b0, "__esModule", { value: !0 });
const _7 = _0, w7 = w0, $7 = $0, E7 = [_7.default, w7.default, $7.default];
b0.default = E7;
var E0 = {}, x0 = {};
Object.defineProperty(x0, "__esModule", { value: !0 });
const es = ht, d$ = Pt, x7 = nn, O7 = {
  message: "must NOT have unevaluated properties",
  params: ({ params: e }) => (0, es._)`{unevaluatedProperty: ${e.unevaluatedProperty}}`
}, P7 = {
  keyword: "unevaluatedProperties",
  type: "object",
  schemaType: ["boolean", "object"],
  trackErrors: !0,
  error: O7,
  code(e) {
    const { gen: t, schema: r, data: n, errsCount: i, it: s } = e;
    if (!i)
      throw new Error("ajv implementation error");
    const { allErrors: a, props: u } = s;
    u instanceof es.Name ? t.if((0, es._)`${u} !== true`, () => t.forIn("key", n, (p) => t.if(l(u, p), () => c(p)))) : u !== !0 && t.forIn("key", n, (p) => u === void 0 ? c(p) : t.if(d(u, p), () => c(p))), s.props = !0, e.ok((0, es._)`${i} === ${x7.default.errors}`);
    function c(p) {
      if (r === !1) {
        e.setParams({ unevaluatedProperty: p }), e.error(), a || t.break();
        return;
      }
      if (!(0, d$.alwaysValidSchema)(s, r)) {
        const h = t.name("valid");
        e.subschema({
          keyword: "unevaluatedProperties",
          dataProp: p,
          dataPropType: d$.Type.Str
        }, h), a || t.if((0, es.not)(h), () => t.break());
      }
    }
    function l(p, h) {
      return (0, es._)`!${p} || !${p}[${h}]`;
    }
    function d(p, h) {
      const v = [];
      for (const y in p)
        p[y] === !0 && v.push((0, es._)`${h} !== ${y}`);
      return (0, es.and)(...v);
    }
  }
};
x0.default = P7;
var O0 = {};
Object.defineProperty(O0, "__esModule", { value: !0 });
const Us = ht, p$ = Pt, S7 = {
  message: ({ params: { len: e } }) => (0, Us.str)`must NOT have more than ${e} items`,
  params: ({ params: { len: e } }) => (0, Us._)`{limit: ${e}}`
}, A7 = {
  keyword: "unevaluatedItems",
  type: "array",
  schemaType: ["boolean", "object"],
  error: S7,
  code(e) {
    const { gen: t, schema: r, data: n, it: i } = e, s = i.items || 0;
    if (s === !0)
      return;
    const a = t.const("len", (0, Us._)`${n}.length`);
    if (r === !1)
      e.setParams({ len: s }), e.fail((0, Us._)`${a} > ${s}`);
    else if (typeof r == "object" && !(0, p$.alwaysValidSchema)(i, r)) {
      const c = t.var("valid", (0, Us._)`${a} <= ${s}`);
      t.if((0, Us.not)(c), () => u(c, s)), e.ok(c);
    }
    i.items = !0;
    function u(c, l) {
      t.forRange("i", l, a, (d) => {
        e.subschema({ keyword: "unevaluatedItems", dataProp: d, dataPropType: p$.Type.Num }, c), i.allErrors || t.if((0, Us.not)(c), () => t.break());
      });
    }
  }
};
O0.default = A7;
Object.defineProperty(E0, "__esModule", { value: !0 });
const C7 = x0, R7 = O0, T7 = [C7.default, R7.default];
E0.default = T7;
var dd = {}, P0 = {};
Object.defineProperty(P0, "__esModule", { value: !0 });
const rr = ht, I7 = {
  message: ({ schemaCode: e }) => (0, rr.str)`must match format "${e}"`,
  params: ({ schemaCode: e }) => (0, rr._)`{format: ${e}}`
}, j7 = {
  keyword: "format",
  type: ["number", "string"],
  schemaType: "string",
  $data: !0,
  error: I7,
  code(e, t) {
    const { gen: r, data: n, $data: i, schema: s, schemaCode: a, it: u } = e, { opts: c, errSchemaPath: l, schemaEnv: d, self: p } = u;
    if (!c.validateFormats)
      return;
    i ? h() : v();
    function h() {
      const y = r.scopeValue("formats", {
        ref: p.formats,
        code: c.code.formats
      }), g = r.const("fDef", (0, rr._)`${y}[${a}]`), _ = r.let("fType"), m = r.let("format");
      r.if((0, rr._)`typeof ${g} == "object" && !(${g} instanceof RegExp)`, () => r.assign(_, (0, rr._)`${g}.type || "string"`).assign(m, (0, rr._)`${g}.validate`), () => r.assign(_, (0, rr._)`"string"`).assign(m, g)), e.fail$data((0, rr.or)(w(), $()));
      function w() {
        return c.strictSchema === !1 ? rr.nil : (0, rr._)`${a} && !${m}`;
      }
      function $() {
        const E = d.$async ? (0, rr._)`(${g}.async ? await ${m}(${n}) : ${m}(${n}))` : (0, rr._)`${m}(${n})`, A = (0, rr._)`(typeof ${m} == "function" ? ${E} : ${m}.test(${n}))`;
        return (0, rr._)`${m} && ${m} !== true && ${_} === ${t} && !${A}`;
      }
    }
    function v() {
      const y = p.formats[s];
      if (!y) {
        w();
        return;
      }
      if (y === !0)
        return;
      const [g, _, m] = $(y);
      g === t && e.pass(E());
      function w() {
        if (c.strictSchema === !1) {
          p.logger.warn(A());
          return;
        }
        throw new Error(A());
        function A() {
          return `unknown format "${s}" ignored in schema at path "${l}"`;
        }
      }
      function $(A) {
        const R = A instanceof RegExp ? (0, rr.regexpCode)(A) : c.code.formats ? (0, rr._)`${c.code.formats}${(0, rr.getProperty)(s)}` : void 0, I = r.scopeValue("formats", { key: s, ref: A, code: R });
        return typeof A == "object" && !(A instanceof RegExp) ? [A.type || "string", A.validate, (0, rr._)`${I}.validate`] : ["string", A, I];
      }
      function E() {
        if (typeof y == "object" && !(y instanceof RegExp) && y.async) {
          if (!d.$async)
            throw new Error("async format in sync schema");
          return (0, rr._)`await ${m}(${n})`;
        }
        return typeof _ == "function" ? (0, rr._)`${m}(${n})` : (0, rr._)`${m}.test(${n})`;
      }
    }
  }
};
P0.default = j7;
Object.defineProperty(dd, "__esModule", { value: !0 });
const k7 = P0, M7 = [k7.default];
dd.default = M7;
var oo = {};
Object.defineProperty(oo, "__esModule", { value: !0 });
oo.contentVocabulary = oo.metadataVocabulary = void 0;
oo.metadataVocabulary = [
  "title",
  "description",
  "default",
  "deprecated",
  "readOnly",
  "writeOnly",
  "examples"
];
oo.contentVocabulary = [
  "contentMediaType",
  "contentEncoding",
  "contentSchema"
];
Object.defineProperty(Xg, "__esModule", { value: !0 });
const N7 = Qg, D7 = t0, L7 = cd, q7 = y0, F7 = b0, U7 = E0, B7 = dd, h$ = oo, V7 = [
  q7.default,
  N7.default,
  D7.default,
  (0, L7.default)(!0),
  B7.default,
  h$.metadataVocabulary,
  h$.contentVocabulary,
  F7.default,
  U7.default
];
Xg.default = V7;
var pd = {}, FP = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DiscrError = void 0, function(t) {
    t.Tag = "tag", t.Mapping = "mapping";
  }(e.DiscrError || (e.DiscrError = {}));
})(FP);
Object.defineProperty(pd, "__esModule", { value: !0 });
const qa = ht, Uy = FP, m$ = Nr, Z7 = Pt, z7 = {
  message: ({ params: { discrError: e, tagName: t } }) => e === Uy.DiscrError.Tag ? `tag "${t}" must be string` : `value of tag "${t}" must be in oneOf`,
  params: ({ params: { discrError: e, tag: t, tagName: r } }) => (0, qa._)`{error: ${e}, tag: ${r}, tagValue: ${t}}`
}, W7 = {
  keyword: "discriminator",
  type: "object",
  schemaType: "object",
  error: z7,
  code(e) {
    const { gen: t, data: r, schema: n, parentSchema: i, it: s } = e, { oneOf: a } = i;
    if (!s.opts.discriminator)
      throw new Error("discriminator: requires discriminator option");
    const u = n.propertyName;
    if (typeof u != "string")
      throw new Error("discriminator: requires propertyName");
    if (n.mapping)
      throw new Error("discriminator: mapping is not supported");
    if (!a)
      throw new Error("discriminator: requires oneOf keyword");
    const c = t.let("valid", !1), l = t.const("tag", (0, qa._)`${r}${(0, qa.getProperty)(u)}`);
    t.if((0, qa._)`typeof ${l} == "string"`, () => d(), () => e.error(!1, { discrError: Uy.DiscrError.Tag, tag: l, tagName: u })), e.ok(c);
    function d() {
      const v = h();
      t.if(!1);
      for (const y in v)
        t.elseIf((0, qa._)`${l} === ${y}`), t.assign(c, p(v[y]));
      t.else(), e.error(!1, { discrError: Uy.DiscrError.Mapping, tag: l, tagName: u }), t.endIf();
    }
    function p(v) {
      const y = t.name("valid"), g = e.subschema({ keyword: "oneOf", schemaProp: v }, y);
      return e.mergeEvaluated(g, qa.Name), y;
    }
    function h() {
      var v;
      const y = {}, g = m(i);
      let _ = !0;
      for (let E = 0; E < a.length; E++) {
        let A = a[E];
        A != null && A.$ref && !(0, Z7.schemaHasRulesButRef)(A, s.self.RULES) && (A = m$.resolveRef.call(s.self, s.schemaEnv.root, s.baseId, A == null ? void 0 : A.$ref), A instanceof m$.SchemaEnv && (A = A.schema));
        const R = (v = A == null ? void 0 : A.properties) === null || v === void 0 ? void 0 : v[u];
        if (typeof R != "object")
          throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${u}"`);
        _ = _ && (g || m(A)), w(R, E);
      }
      if (!_)
        throw new Error(`discriminator: "${u}" must be required`);
      return y;
      function m({ required: E }) {
        return Array.isArray(E) && E.includes(u);
      }
      function w(E, A) {
        if (E.const)
          $(E.const, A);
        else if (E.enum)
          for (const R of E.enum)
            $(R, A);
        else
          throw new Error(`discriminator: "properties/${u}" must have "const" or "enum"`);
      }
      function $(E, A) {
        if (typeof E != "string" || E in y)
          throw new Error(`discriminator: "${u}" values must be unique strings`);
        y[E] = A;
      }
    }
  }
};
pd.default = W7;
var S0 = {};
const H7 = "https://json-schema.org/draft/2020-12/schema", G7 = "https://json-schema.org/draft/2020-12/schema", K7 = {
  "https://json-schema.org/draft/2020-12/vocab/core": !0,
  "https://json-schema.org/draft/2020-12/vocab/applicator": !0,
  "https://json-schema.org/draft/2020-12/vocab/unevaluated": !0,
  "https://json-schema.org/draft/2020-12/vocab/validation": !0,
  "https://json-schema.org/draft/2020-12/vocab/meta-data": !0,
  "https://json-schema.org/draft/2020-12/vocab/format-annotation": !0,
  "https://json-schema.org/draft/2020-12/vocab/content": !0
}, Y7 = "meta", J7 = "Core and Validation specifications meta-schema", X7 = [
  {
    $ref: "meta/core"
  },
  {
    $ref: "meta/applicator"
  },
  {
    $ref: "meta/unevaluated"
  },
  {
    $ref: "meta/validation"
  },
  {
    $ref: "meta/meta-data"
  },
  {
    $ref: "meta/format-annotation"
  },
  {
    $ref: "meta/content"
  }
], Q7 = [
  "object",
  "boolean"
], eV = "This meta-schema also defines keywords that have appeared in previous drafts in order to prevent incompatible extensions as they remain in common use.", tV = {
  definitions: {
    $comment: '"definitions" has been replaced by "$defs".',
    type: "object",
    additionalProperties: {
      $dynamicRef: "#meta"
    },
    deprecated: !0,
    default: {}
  },
  dependencies: {
    $comment: '"dependencies" has been split and replaced by "dependentSchemas" and "dependentRequired" in order to serve their differing semantics.',
    type: "object",
    additionalProperties: {
      anyOf: [
        {
          $dynamicRef: "#meta"
        },
        {
          $ref: "meta/validation#/$defs/stringArray"
        }
      ]
    },
    deprecated: !0,
    default: {}
  },
  $recursiveAnchor: {
    $comment: '"$recursiveAnchor" has been replaced by "$dynamicAnchor".',
    $ref: "meta/core#/$defs/anchorString",
    deprecated: !0
  },
  $recursiveRef: {
    $comment: '"$recursiveRef" has been replaced by "$dynamicRef".',
    $ref: "meta/core#/$defs/uriReferenceString",
    deprecated: !0
  }
}, rV = {
  $schema: H7,
  $id: G7,
  $vocabulary: K7,
  $dynamicAnchor: Y7,
  title: J7,
  allOf: X7,
  type: Q7,
  $comment: eV,
  properties: tV
}, nV = "https://json-schema.org/draft/2020-12/schema", iV = "https://json-schema.org/draft/2020-12/meta/applicator", sV = {
  "https://json-schema.org/draft/2020-12/vocab/applicator": !0
}, aV = "meta", oV = "Applicator vocabulary meta-schema", uV = [
  "object",
  "boolean"
], cV = {
  prefixItems: {
    $ref: "#/$defs/schemaArray"
  },
  items: {
    $dynamicRef: "#meta"
  },
  contains: {
    $dynamicRef: "#meta"
  },
  additionalProperties: {
    $dynamicRef: "#meta"
  },
  properties: {
    type: "object",
    additionalProperties: {
      $dynamicRef: "#meta"
    },
    default: {}
  },
  patternProperties: {
    type: "object",
    additionalProperties: {
      $dynamicRef: "#meta"
    },
    propertyNames: {
      format: "regex"
    },
    default: {}
  },
  dependentSchemas: {
    type: "object",
    additionalProperties: {
      $dynamicRef: "#meta"
    },
    default: {}
  },
  propertyNames: {
    $dynamicRef: "#meta"
  },
  if: {
    $dynamicRef: "#meta"
  },
  then: {
    $dynamicRef: "#meta"
  },
  else: {
    $dynamicRef: "#meta"
  },
  allOf: {
    $ref: "#/$defs/schemaArray"
  },
  anyOf: {
    $ref: "#/$defs/schemaArray"
  },
  oneOf: {
    $ref: "#/$defs/schemaArray"
  },
  not: {
    $dynamicRef: "#meta"
  }
}, lV = {
  schemaArray: {
    type: "array",
    minItems: 1,
    items: {
      $dynamicRef: "#meta"
    }
  }
}, fV = {
  $schema: nV,
  $id: iV,
  $vocabulary: sV,
  $dynamicAnchor: aV,
  title: oV,
  type: uV,
  properties: cV,
  $defs: lV
}, dV = "https://json-schema.org/draft/2020-12/schema", pV = "https://json-schema.org/draft/2020-12/meta/unevaluated", hV = {
  "https://json-schema.org/draft/2020-12/vocab/unevaluated": !0
}, mV = "meta", yV = "Unevaluated applicator vocabulary meta-schema", gV = [
  "object",
  "boolean"
], vV = {
  unevaluatedItems: {
    $dynamicRef: "#meta"
  },
  unevaluatedProperties: {
    $dynamicRef: "#meta"
  }
}, bV = {
  $schema: dV,
  $id: pV,
  $vocabulary: hV,
  $dynamicAnchor: mV,
  title: yV,
  type: gV,
  properties: vV
}, _V = "https://json-schema.org/draft/2020-12/schema", wV = "https://json-schema.org/draft/2020-12/meta/content", $V = {
  "https://json-schema.org/draft/2020-12/vocab/content": !0
}, EV = "meta", xV = "Content vocabulary meta-schema", OV = [
  "object",
  "boolean"
], PV = {
  contentEncoding: {
    type: "string"
  },
  contentMediaType: {
    type: "string"
  },
  contentSchema: {
    $dynamicRef: "#meta"
  }
}, SV = {
  $schema: _V,
  $id: wV,
  $vocabulary: $V,
  $dynamicAnchor: EV,
  title: xV,
  type: OV,
  properties: PV
}, AV = "https://json-schema.org/draft/2020-12/schema", CV = "https://json-schema.org/draft/2020-12/meta/core", RV = {
  "https://json-schema.org/draft/2020-12/vocab/core": !0
}, TV = "meta", IV = "Core vocabulary meta-schema", jV = [
  "object",
  "boolean"
], kV = {
  $id: {
    $ref: "#/$defs/uriReferenceString",
    $comment: "Non-empty fragments not allowed.",
    pattern: "^[^#]*#?$"
  },
  $schema: {
    $ref: "#/$defs/uriString"
  },
  $ref: {
    $ref: "#/$defs/uriReferenceString"
  },
  $anchor: {
    $ref: "#/$defs/anchorString"
  },
  $dynamicRef: {
    $ref: "#/$defs/uriReferenceString"
  },
  $dynamicAnchor: {
    $ref: "#/$defs/anchorString"
  },
  $vocabulary: {
    type: "object",
    propertyNames: {
      $ref: "#/$defs/uriString"
    },
    additionalProperties: {
      type: "boolean"
    }
  },
  $comment: {
    type: "string"
  },
  $defs: {
    type: "object",
    additionalProperties: {
      $dynamicRef: "#meta"
    }
  }
}, MV = {
  anchorString: {
    type: "string",
    pattern: "^[A-Za-z_][-A-Za-z0-9._]*$"
  },
  uriString: {
    type: "string",
    format: "uri"
  },
  uriReferenceString: {
    type: "string",
    format: "uri-reference"
  }
}, NV = {
  $schema: AV,
  $id: CV,
  $vocabulary: RV,
  $dynamicAnchor: TV,
  title: IV,
  type: jV,
  properties: kV,
  $defs: MV
}, DV = "https://json-schema.org/draft/2020-12/schema", LV = "https://json-schema.org/draft/2020-12/meta/format-annotation", qV = {
  "https://json-schema.org/draft/2020-12/vocab/format-annotation": !0
}, FV = "meta", UV = "Format vocabulary meta-schema for annotation results", BV = [
  "object",
  "boolean"
], VV = {
  format: {
    type: "string"
  }
}, ZV = {
  $schema: DV,
  $id: LV,
  $vocabulary: qV,
  $dynamicAnchor: FV,
  title: UV,
  type: BV,
  properties: VV
}, zV = "https://json-schema.org/draft/2020-12/schema", WV = "https://json-schema.org/draft/2020-12/meta/meta-data", HV = {
  "https://json-schema.org/draft/2020-12/vocab/meta-data": !0
}, GV = "meta", KV = "Meta-data vocabulary meta-schema", YV = [
  "object",
  "boolean"
], JV = {
  title: {
    type: "string"
  },
  description: {
    type: "string"
  },
  default: !0,
  deprecated: {
    type: "boolean",
    default: !1
  },
  readOnly: {
    type: "boolean",
    default: !1
  },
  writeOnly: {
    type: "boolean",
    default: !1
  },
  examples: {
    type: "array",
    items: !0
  }
}, XV = {
  $schema: zV,
  $id: WV,
  $vocabulary: HV,
  $dynamicAnchor: GV,
  title: KV,
  type: YV,
  properties: JV
}, QV = "https://json-schema.org/draft/2020-12/schema", eZ = "https://json-schema.org/draft/2020-12/meta/validation", tZ = {
  "https://json-schema.org/draft/2020-12/vocab/validation": !0
}, rZ = "meta", nZ = "Validation vocabulary meta-schema", iZ = [
  "object",
  "boolean"
], sZ = {
  type: {
    anyOf: [
      {
        $ref: "#/$defs/simpleTypes"
      },
      {
        type: "array",
        items: {
          $ref: "#/$defs/simpleTypes"
        },
        minItems: 1,
        uniqueItems: !0
      }
    ]
  },
  const: !0,
  enum: {
    type: "array",
    items: !0
  },
  multipleOf: {
    type: "number",
    exclusiveMinimum: 0
  },
  maximum: {
    type: "number"
  },
  exclusiveMaximum: {
    type: "number"
  },
  minimum: {
    type: "number"
  },
  exclusiveMinimum: {
    type: "number"
  },
  maxLength: {
    $ref: "#/$defs/nonNegativeInteger"
  },
  minLength: {
    $ref: "#/$defs/nonNegativeIntegerDefault0"
  },
  pattern: {
    type: "string",
    format: "regex"
  },
  maxItems: {
    $ref: "#/$defs/nonNegativeInteger"
  },
  minItems: {
    $ref: "#/$defs/nonNegativeIntegerDefault0"
  },
  uniqueItems: {
    type: "boolean",
    default: !1
  },
  maxContains: {
    $ref: "#/$defs/nonNegativeInteger"
  },
  minContains: {
    $ref: "#/$defs/nonNegativeInteger",
    default: 1
  },
  maxProperties: {
    $ref: "#/$defs/nonNegativeInteger"
  },
  minProperties: {
    $ref: "#/$defs/nonNegativeIntegerDefault0"
  },
  required: {
    $ref: "#/$defs/stringArray"
  },
  dependentRequired: {
    type: "object",
    additionalProperties: {
      $ref: "#/$defs/stringArray"
    }
  }
}, aZ = {
  nonNegativeInteger: {
    type: "integer",
    minimum: 0
  },
  nonNegativeIntegerDefault0: {
    $ref: "#/$defs/nonNegativeInteger",
    default: 0
  },
  simpleTypes: {
    enum: [
      "array",
      "boolean",
      "integer",
      "null",
      "number",
      "object",
      "string"
    ]
  },
  stringArray: {
    type: "array",
    items: {
      type: "string"
    },
    uniqueItems: !0,
    default: []
  }
}, oZ = {
  $schema: QV,
  $id: eZ,
  $vocabulary: tZ,
  $dynamicAnchor: rZ,
  title: nZ,
  type: iZ,
  properties: sZ,
  $defs: aZ
};
Object.defineProperty(S0, "__esModule", { value: !0 });
const uZ = rV, cZ = fV, lZ = bV, fZ = SV, dZ = NV, pZ = ZV, hZ = XV, mZ = oZ, yZ = ["/properties"];
function gZ(e) {
  return [
    uZ,
    cZ,
    lZ,
    fZ,
    dZ,
    t(this, pZ),
    hZ,
    t(this, mZ)
  ].forEach((r) => this.addMetaSchema(r, void 0, !1)), this;
  function t(r, n) {
    return e ? r.$dataMetaSchema(n, yZ) : n;
  }
}
S0.default = gZ;
(function(e, t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.MissingRefError = t.ValidationError = t.CodeGen = t.Name = t.nil = t.stringify = t.str = t._ = t.KeywordCxt = void 0;
  const r = Ja, n = Xg, i = pd, s = S0, a = "https://json-schema.org/draft/2020-12/schema";
  class u extends r.default {
    constructor(v = {}) {
      super({
        ...v,
        dynamicRef: !0,
        next: !0,
        unevaluated: !0
      });
    }
    _addVocabularies() {
      super._addVocabularies(), n.default.forEach((v) => this.addVocabulary(v)), this.opts.discriminator && this.addKeyword(i.default);
    }
    _addDefaultMetaSchema() {
      super._addDefaultMetaSchema();
      const { $data: v, meta: y } = this.opts;
      y && (s.default.call(this, v), this.refs["http://json-schema.org/schema"] = a);
    }
    defaultMeta() {
      return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(a) ? a : void 0);
    }
  }
  e.exports = t = u, Object.defineProperty(t, "__esModule", { value: !0 }), t.default = u;
  var c = jn;
  Object.defineProperty(t, "KeywordCxt", { enumerable: !0, get: function() {
    return c.KeywordCxt;
  } });
  var l = ht;
  Object.defineProperty(t, "_", { enumerable: !0, get: function() {
    return l._;
  } }), Object.defineProperty(t, "str", { enumerable: !0, get: function() {
    return l.str;
  } }), Object.defineProperty(t, "stringify", { enumerable: !0, get: function() {
    return l.stringify;
  } }), Object.defineProperty(t, "nil", { enumerable: !0, get: function() {
    return l.nil;
  } }), Object.defineProperty(t, "Name", { enumerable: !0, get: function() {
    return l.Name;
  } }), Object.defineProperty(t, "CodeGen", { enumerable: !0, get: function() {
    return l.CodeGen;
  } });
  var d = ic;
  Object.defineProperty(t, "ValidationError", { enumerable: !0, get: function() {
    return d.default;
  } });
  var p = sc;
  Object.defineProperty(t, "MissingRefError", { enumerable: !0, get: function() {
    return p.default;
  } });
})(My, My.exports);
var vZ = My.exports, By = { exports: {} }, A0 = {}, C0 = {};
Object.defineProperty(C0, "__esModule", { value: !0 });
const bZ = ii, _Z = [
  "$schema",
  "id",
  "$defs",
  { keyword: "$comment" },
  "definitions",
  bZ.default
];
C0.default = _Z;
var R0 = {}, T0 = {};
Object.defineProperty(T0, "__esModule", { value: !0 });
const Vy = Ja, wZ = ht, Qi = wZ.operators, Zy = {
  maximum: {
    exclusive: "exclusiveMaximum",
    ops: [
      { okStr: "<=", ok: Qi.LTE, fail: Qi.GT },
      { okStr: "<", ok: Qi.LT, fail: Qi.GTE }
    ]
  },
  minimum: {
    exclusive: "exclusiveMinimum",
    ops: [
      { okStr: ">=", ok: Qi.GTE, fail: Qi.LT },
      { okStr: ">", ok: Qi.GT, fail: Qi.LTE }
    ]
  }
}, $Z = {
  message: (e) => Vy.str`must be ${zy(e).okStr} ${e.schemaCode}`,
  params: (e) => Vy._`{comparison: ${zy(e).okStr}, limit: ${e.schemaCode}}`
}, EZ = {
  keyword: Object.keys(Zy),
  type: "number",
  schemaType: "number",
  $data: !0,
  error: $Z,
  code(e) {
    const { data: t, schemaCode: r } = e;
    e.fail$data(Vy._`${t} ${zy(e).fail} ${r} || isNaN(${t})`);
  }
};
function zy(e) {
  var t;
  const r = e.keyword, n = !((t = e.parentSchema) === null || t === void 0) && t[Zy[r].exclusive] ? 1 : 0;
  return Zy[r].ops[n];
}
T0.default = EZ;
var I0 = {};
Object.defineProperty(I0, "__esModule", { value: !0 });
const y$ = {
  exclusiveMaximum: "maximum",
  exclusiveMinimum: "minimum"
}, xZ = {
  keyword: Object.keys(y$),
  type: "number",
  schemaType: "boolean",
  code({ keyword: e, parentSchema: t }) {
    const r = y$[e];
    if (t[r] === void 0)
      throw new Error(`${e} can only be used with ${r}`);
  }
};
I0.default = xZ;
Object.defineProperty(R0, "__esModule", { value: !0 });
const OZ = T0, PZ = I0, SZ = ed, AZ = td, CZ = rd, RZ = nd, TZ = id, IZ = sd, jZ = ad, kZ = od, MZ = ud, NZ = [
  // number
  OZ.default,
  PZ.default,
  SZ.default,
  // string
  AZ.default,
  CZ.default,
  // object
  RZ.default,
  TZ.default,
  // array
  IZ.default,
  jZ.default,
  // any
  { keyword: "type", schemaType: ["string", "array"] },
  { keyword: "nullable", schemaType: "boolean" },
  kZ.default,
  MZ.default
];
R0.default = NZ;
Object.defineProperty(A0, "__esModule", { value: !0 });
const DZ = C0, LZ = R0, qZ = cd, FZ = dd, UZ = ["title", "description", "default"], BZ = [
  DZ.default,
  LZ.default,
  qZ.default(),
  FZ.default,
  UZ
];
A0.default = BZ;
const VZ = "http://json-schema.org/draft-04/schema#", ZZ = "http://json-schema.org/draft-04/schema#", zZ = "Core schema meta-schema", WZ = {
  schemaArray: {
    type: "array",
    minItems: 1,
    items: {
      $ref: "#"
    }
  },
  positiveInteger: {
    type: "integer",
    minimum: 0
  },
  positiveIntegerDefault0: {
    allOf: [
      {
        $ref: "#/definitions/positiveInteger"
      },
      {
        default: 0
      }
    ]
  },
  simpleTypes: {
    enum: [
      "array",
      "boolean",
      "integer",
      "null",
      "number",
      "object",
      "string"
    ]
  },
  stringArray: {
    type: "array",
    items: {
      type: "string"
    },
    minItems: 1,
    uniqueItems: !0
  }
}, HZ = "object", GZ = {
  id: {
    type: "string",
    format: "uri"
  },
  $schema: {
    type: "string",
    format: "uri"
  },
  title: {
    type: "string"
  },
  description: {
    type: "string"
  },
  default: {},
  multipleOf: {
    type: "number",
    minimum: 0,
    exclusiveMinimum: !0
  },
  maximum: {
    type: "number"
  },
  exclusiveMaximum: {
    type: "boolean",
    default: !1
  },
  minimum: {
    type: "number"
  },
  exclusiveMinimum: {
    type: "boolean",
    default: !1
  },
  maxLength: {
    $ref: "#/definitions/positiveInteger"
  },
  minLength: {
    $ref: "#/definitions/positiveIntegerDefault0"
  },
  pattern: {
    type: "string",
    format: "regex"
  },
  additionalItems: {
    anyOf: [
      {
        type: "boolean"
      },
      {
        $ref: "#"
      }
    ],
    default: {}
  },
  items: {
    anyOf: [
      {
        $ref: "#"
      },
      {
        $ref: "#/definitions/schemaArray"
      }
    ],
    default: {}
  },
  maxItems: {
    $ref: "#/definitions/positiveInteger"
  },
  minItems: {
    $ref: "#/definitions/positiveIntegerDefault0"
  },
  uniqueItems: {
    type: "boolean",
    default: !1
  },
  maxProperties: {
    $ref: "#/definitions/positiveInteger"
  },
  minProperties: {
    $ref: "#/definitions/positiveIntegerDefault0"
  },
  required: {
    $ref: "#/definitions/stringArray"
  },
  additionalProperties: {
    anyOf: [
      {
        type: "boolean"
      },
      {
        $ref: "#"
      }
    ],
    default: {}
  },
  definitions: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    default: {}
  },
  properties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    default: {}
  },
  patternProperties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    default: {}
  },
  dependencies: {
    type: "object",
    additionalProperties: {
      anyOf: [
        {
          $ref: "#"
        },
        {
          $ref: "#/definitions/stringArray"
        }
      ]
    }
  },
  enum: {
    type: "array",
    minItems: 1,
    uniqueItems: !0
  },
  type: {
    anyOf: [
      {
        $ref: "#/definitions/simpleTypes"
      },
      {
        type: "array",
        items: {
          $ref: "#/definitions/simpleTypes"
        },
        minItems: 1,
        uniqueItems: !0
      }
    ]
  },
  allOf: {
    $ref: "#/definitions/schemaArray"
  },
  anyOf: {
    $ref: "#/definitions/schemaArray"
  },
  oneOf: {
    $ref: "#/definitions/schemaArray"
  },
  not: {
    $ref: "#"
  }
}, KZ = {
  exclusiveMaximum: [
    "maximum"
  ],
  exclusiveMinimum: [
    "minimum"
  ]
}, YZ = {
  id: VZ,
  $schema: ZZ,
  description: zZ,
  definitions: WZ,
  type: HZ,
  properties: GZ,
  dependencies: KZ,
  default: {}
};
(function(e, t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.CodeGen = t.Name = t.nil = t.stringify = t.str = t._ = t.KeywordCxt = void 0;
  const r = Ja, n = A0, i = pd, s = YZ, a = ["/properties"], u = "http://json-schema.org/draft-04/schema";
  class c extends r.default {
    constructor(h = {}) {
      super({
        ...h,
        schemaId: "id"
      });
    }
    _addVocabularies() {
      super._addVocabularies(), n.default.forEach((h) => this.addVocabulary(h)), this.opts.discriminator && this.addKeyword(i.default);
    }
    _addDefaultMetaSchema() {
      if (super._addDefaultMetaSchema(), !this.opts.meta)
        return;
      const h = this.opts.$data ? this.$dataMetaSchema(s, a) : s;
      this.addMetaSchema(h, u, !1), this.refs["http://json-schema.org/schema"] = u;
    }
    defaultMeta() {
      return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(u) ? u : void 0);
    }
  }
  e.exports = t = c, Object.defineProperty(t, "__esModule", { value: !0 }), t.default = c;
  var l = Ja;
  Object.defineProperty(t, "KeywordCxt", { enumerable: !0, get: function() {
    return l.KeywordCxt;
  } });
  var d = Ja;
  Object.defineProperty(t, "_", { enumerable: !0, get: function() {
    return d._;
  } }), Object.defineProperty(t, "str", { enumerable: !0, get: function() {
    return d.str;
  } }), Object.defineProperty(t, "stringify", { enumerable: !0, get: function() {
    return d.stringify;
  } }), Object.defineProperty(t, "nil", { enumerable: !0, get: function() {
    return d.nil;
  } }), Object.defineProperty(t, "Name", { enumerable: !0, get: function() {
    return d.Name;
  } }), Object.defineProperty(t, "CodeGen", { enumerable: !0, get: function() {
    return d.CodeGen;
  } });
})(By, By.exports);
var JZ = By.exports;
const { openapi: Qh } = c8, { ono: XZ } = Nn, QZ = SF, ez = vZ, tz = JZ, { getSpecificationName: rz } = ui, nz = 20, iz = 5e6;
var UP = sz;
function sz(e, t) {
  let r, n;
  if (e.swagger)
    n = Qh.v2, r = em();
  else if (e.openapi.startsWith("3.1")) {
    n = Qh.v31;
    const s = n.$defs.schema;
    delete s.$dynamicAnchor, n.$defs.components.properties.schemas.additionalProperties = s, n.$defs.header.dependentSchemas.schema.properties.schema = s, n.$defs["media-type"].properties.schema = s, n.$defs.parameter.properties.schema = s, r = em(!1);
  } else
    n = Qh.v3, r = em();
  if (!r.validate(n, e)) {
    const s = r.errors;
    let a = 0, u = az(s);
    if (u.length >= nz)
      try {
        JSON.stringify(e).length >= iz && (a = u.length - 20, u = u.slice(0, 20));
      } catch {
      }
    let c = `${rz(e)} schema validation failed.
`;
    throw c += `
`, c += QZ(n, e, u, {
      colorize: t.validate.colorizeErrors,
      indent: 2
    }), a && (c += `

`, c += `Plus an additional ${a} errors. Please resolve the above and re-run validation to see more.`), XZ.syntax(s, { details: s }, c);
  }
}
function em(e = !0) {
  const t = {
    allErrors: !0,
    strict: !1,
    validateFormats: !1
  };
  return e ? new tz(t) : new ez(t);
}
function az(e) {
  const t = /* @__PURE__ */ new Map();
  return e.forEach((r) => {
    if (["must have required property '$ref'", "must match exactly one schema in oneOf"].includes(r.message))
      return;
    if (t.size) {
      if (t.has(r.instancePath))
        return;
    } else {
      t.set(r.instancePath, r);
      return;
    }
    let n = !0;
    t.forEach((i) => {
      i.instancePath.includes(r.instancePath) && (n = !1);
    }), n && t.set(r.instancePath, r);
  }), t.size ? [...t.values()] : e;
}
var BP = [
  "get",
  "put",
  "post",
  "delete",
  "options",
  "head",
  "patch"
];
const oz = BP, { ono: Si } = Nn, uz = ui;
var cz = lz;
function lz(e) {
  const t = [];
  Object.keys(e.paths || {}).forEach((r) => {
    const n = e.paths[r], i = `/paths${r}`;
    n && r.indexOf("/") === 0 && fz(e, n, i, t);
  }), e.openapi.startsWith("3.0") && e.components && Object.keys(e.components).forEach((r) => {
    Object.keys(e.components[r]).forEach((n) => {
      const i = `/components/${r}/${n}`;
      if (!/^[a-zA-Z0-9.\-_]+$/.test(n))
        throw Si.syntax(
          `Validation failed. ${i} has an invalid name. Component names should match against: /^[a-zA-Z0-9.-_]+$/`
        );
    });
  });
}
function fz(e, t, r, n) {
  [...oz, "trace"].forEach((i) => {
    const s = t[i], a = `${r}/${i}`;
    if (s) {
      const u = s.operationId;
      if (u)
        if (n.indexOf(u) === -1)
          n.push(u);
        else
          throw Si.syntax(`Validation failed. Duplicate operation id '${u}'`);
      dz(e, t, r, s, a), Object.keys(s.responses || {}).forEach((c) => {
        const l = s.responses[c], d = `${a}/responses/${c}`;
        mz(c, l || {}, d);
      });
    }
  });
}
function dz(e, t, r, n, i) {
  const s = t.parameters || [], a = n.parameters || [];
  try {
    g$(s);
  } catch (c) {
    throw Si.syntax(c, `Validation failed. ${r} has duplicate parameters`);
  }
  try {
    g$(a);
  } catch (c) {
    throw Si.syntax(c, `Validation failed. ${i} has duplicate parameters`);
  }
  const u = s.reduce((c, l) => (c.some((p) => p.in === l.in && p.name === l.name) || c.push(l), c), a.slice());
  pz(u, r, i), hz(u, e, n, i);
}
function pz(e, t, r) {
  const n = [...new Set(t.match(uz.swaggerParamRegExp) || [])];
  if (e.filter((i) => i.in === "path").forEach((i) => {
    if (i.required !== !0)
      throw Si.syntax(
        `Validation failed. Path parameters cannot be optional. Set required=true for the "${i.name}" parameter at ${r}`
      );
    const s = n.indexOf(`{${i.name}}`);
    if (s === -1)
      throw Si.syntax(
        `Validation failed. ${r} has a path parameter named "${i.name}", but there is no corresponding {${i.name}} in the path string`
      );
    n.splice(s, 1);
  }), n.length > 0)
    throw Si.syntax(`Validation failed. ${r} is missing path parameter(s) for ${n}`);
}
function hz(e, t, r, n) {
  e.forEach((i) => {
    if (!i.schema && i.content)
      return;
    const s = `${n}/parameters/${i.name}`;
    Ll(i.schema, s);
  });
}
function g$(e) {
  for (let t = 0; t < e.length - 1; t++) {
    const r = e[t];
    for (let n = t + 1; n < e.length; n++) {
      const i = e[n];
      if (r.name === i.name && r.in === i.in)
        throw Si.syntax(`Validation failed. Found multiple ${r.in} parameters named "${r.name}"`);
    }
  }
}
function mz(e, t, r) {
  Object.keys(t.headers || {}).forEach((n) => {
    const i = t.headers[n], s = `${r}/headers/${n}`;
    i.schema ? Ll(i.schema, s) : i.content && Object.keys(i.content).forEach((a) => {
      i.content[a].schema && Ll(i.content[a].schema || {}, `${s}/content/${a}/schema`);
    });
  }), t.content && Object.keys(t.content).forEach((n) => {
    t.content[n].schema && Ll(t.content[n].schema || {}, `${r}/content/${n}/schema`);
  });
}
function Ll(e, t) {
  if (e.type === "array" && !e.items)
    throw Si.syntax(`Validation failed. ${t} is an array, so it must include an "items" schema`);
}
const yz = BP, { ono: br } = Nn, gz = ui, Wy = ["array", "boolean", "integer", "number", "string"], VP = ["array", "boolean", "integer", "number", "string", "object", "null", void 0];
var vz = bz;
function bz(e) {
  const t = [];
  Object.keys(e.paths || {}).forEach((r) => {
    const n = e.paths[r], i = `/paths${r}`;
    n && r.indexOf("/") === 0 && _z(e, n, i, t);
  }), Object.keys(e.definitions || {}).forEach((r) => {
    const n = e.definitions[r], i = `/definitions/${r}`;
    if (!/^[a-zA-Z0-9.\-_]+$/.test(r))
      throw br.syntax(
        `Validation failed. ${i} has an invalid name. Definition names should match against: /^[a-zA-Z0-9.-_]+$/`
      );
    ZP(n, i);
  });
}
function _z(e, t, r, n) {
  yz.forEach((i) => {
    const s = t[i], a = `${r}/${i}`;
    if (s) {
      const u = s.operationId;
      if (u)
        if (n.indexOf(u) === -1)
          n.push(u);
        else
          throw br.syntax(`Validation failed. Duplicate operation id '${u}'`);
      wz(e, t, r, s, a), Object.keys(s.responses || {}).forEach((c) => {
        const l = s.responses[c], d = `${a}/responses/${c}`;
        Oz(c, l || {}, d);
      });
    }
  });
}
function wz(e, t, r, n, i) {
  const s = t.parameters || [], a = n.parameters || [];
  try {
    v$(s);
  } catch (c) {
    throw br.syntax(c, `Validation failed. ${r} has duplicate parameters`);
  }
  try {
    v$(a);
  } catch (c) {
    throw br.syntax(c, `Validation failed. ${i} has duplicate parameters`);
  }
  const u = s.reduce((c, l) => (c.some((p) => p.in === l.in && p.name === l.name) || c.push(l), c), a.slice());
  $z(u, i), Ez(u, r, i), xz(u, e, n, i);
}
function $z(e, t) {
  const r = e.filter((i) => i.in === "body"), n = e.filter((i) => i.in === "formData");
  if (r.length > 1)
    throw br.syntax(
      `Validation failed. ${t} has ${r.length} body parameters. Only one is allowed.`
    );
  if (r.length > 0 && n.length > 0)
    throw br.syntax(
      `Validation failed. ${t} has body parameters and formData parameters. Only one or the other is allowed.`
    );
}
function Ez(e, t, r) {
  const n = t.match(gz.swaggerParamRegExp) || [];
  for (let i = 0; i < n.length; i++)
    for (let s = i + 1; s < n.length; s++)
      if (n[i] === n[s])
        throw br.syntax(`Validation failed. ${r} has multiple path placeholders named ${n[i]}`);
  if (e.filter((i) => i.in === "path").forEach((i) => {
    if (i.required !== !0)
      throw br.syntax(
        `Validation failed. Path parameters cannot be optional. Set required=true for the "${i.name}" parameter at ${r}`
      );
    const s = n.indexOf(`{${i.name}}`);
    if (s === -1)
      throw br.syntax(
        `Validation failed. ${r} has a path parameter named "${i.name}", but there is no corresponding {${i.name}} in the path string`
      );
    n.splice(s, 1);
  }), n.length > 0)
    throw br.syntax(`Validation failed. ${r} is missing path parameter(s) for ${n}`);
}
function xz(e, t, r, n) {
  e.forEach((i) => {
    const s = `${n}/parameters/${i.name}`;
    let a, u;
    switch (i.in) {
      case "body":
        a = i.schema, u = VP;
        break;
      case "formData":
        a = i, u = Wy.concat("file");
        break;
      default:
        a = i, u = Wy;
    }
    if (Hy(a, s, u), ZP(a, s), a.type === "file") {
      const c = /multipart\/(.*\+)?form-data/, l = /application\/(.*\+)?x-www-form-urlencoded/;
      if (!(r.consumes || t.consumes || []).some((h) => c.test(h) || l.test(h)))
        throw br.syntax(
          `Validation failed. ${n} has a file parameter, so it must consume multipart/form-data or application/x-www-form-urlencoded`
        );
    }
  });
}
function v$(e) {
  for (let t = 0; t < e.length - 1; t++) {
    const r = e[t];
    for (let n = t + 1; n < e.length; n++) {
      const i = e[n];
      if (r.name === i.name && r.in === i.in)
        throw br.syntax(`Validation failed. Found multiple ${r.in} parameters named "${r.name}"`);
    }
  }
}
function Oz(e, t, r) {
  if (e !== "default" && (e < 100 || e > 599))
    throw br.syntax(`Validation failed. ${r} has an invalid response code (${e})`);
  if (Object.keys(t.headers || {}).forEach((n) => {
    const i = t.headers[n], s = `${r}/headers/${n}`;
    Hy(i, s, Wy);
  }), t.schema) {
    const n = VP.concat("file");
    if (n.indexOf(t.schema.type) === -1)
      throw br.syntax(
        `Validation failed. ${r} has an invalid response schema type (${t.schema.type})`
      );
    Hy(t.schema, `${r}/schema`, n);
  }
}
function Hy(e, t, r) {
  if (r.indexOf(e.type) === -1)
    throw br.syntax(`Validation failed. ${t} has an invalid type (${e.type})`);
  if (e.type === "array" && !e.items)
    throw br.syntax(`Validation failed. ${t} is an array, so it must include an "items" schema`);
}
function ZP(e, t) {
  function r(n, i) {
    n.properties && Object.keys(n.properties).forEach((s) => {
      n.properties.hasOwnProperty(s) && (i[s] = n.properties[s]);
    }), n.allOf && n.allOf.forEach((s) => {
      r(s, i);
    });
  }
  if (e.required && Array.isArray(e.required)) {
    const n = {};
    r(e, n), e.required.forEach((i) => {
      if (!n[i])
        throw br.syntax(
          `Validation failed. Property '${i}' listed as required but does not exist in '${t}'`
        );
    });
  }
}
const Pz = cz, Sz = vz;
var zP = function(t) {
  return t.openapi ? Pz(t) : Sz(t);
};
const Gy = LO, Az = ui, Cz = UP, Rz = zP;
var Tz = hd;
function hd(e) {
  Gy.call(this, hd.defaults), Gy.apply(this, arguments);
}
hd.defaults = {
  /**
   * Determines how the API definition will be validated.
   *
   * You can add additional validators of your own, replace an existing one with
   * your own implemenation, or disable any validator by setting it to false.
   */
  validate: {
    colorizeErrors: !1,
    schema: Cz,
    spec: Rz
  }
};
Az.inherits(hd, Gy);
const { ono: Pn } = Nn, aa = _q, Iz = Ax, WP = qO, _f = rx, HP = Tz, GP = ui, jz = UP, kz = zP;
function Mi() {
  aa.apply(this, arguments);
}
GP.inherits(Mi, aa);
Mi.parse = aa.parse;
Mi.resolve = aa.resolve;
Mi.bundle = aa.bundle;
Mi.dereference = aa.dereference;
Object.defineProperty(Mi.prototype, "api", {
  configurable: !0,
  enumerable: !0,
  get() {
    return this.schema;
  }
});
Mi.prototype.parse = async function(e, t, r, n) {
  const i = WP(arguments);
  i.options = new HP(i.options);
  try {
    const s = await aa.prototype.parse.call(this, i.path, i.schema, i.options);
    if (s.swagger) {
      if (s.swagger === void 0 || s.info === void 0 || s.paths === void 0)
        throw Pn.syntax(`${i.path || "Supplied schema"} is not a valid Swagger API definition.`);
      if (typeof s.swagger == "number")
        throw Pn.syntax('Swagger version number must be a string (e.g. "2.0") not a number.');
      if (typeof s.info.version == "number")
        throw Pn.syntax('API version number must be a string (e.g. "1.0.0") not a number.');
      if (s.swagger !== "2.0")
        throw Pn.syntax(`Unrecognized Swagger version: ${s.swagger}. Expected 2.0`);
    } else {
      const a = ["3.0.0", "3.0.1", "3.0.2", "3.0.3", "3.1.0"];
      if (s.openapi === void 0 || s.info === void 0)
        throw Pn.syntax(`${i.path || "Supplied schema"} is not a valid OpenAPI definition.`);
      if (s.paths === void 0)
        if (s.openapi === "3.1.0") {
          if (s.webhooks === void 0)
            throw Pn.syntax(`${i.path || "Supplied schema"} is not a valid OpenAPI definition.`);
        } else
          throw Pn.syntax(`${i.path || "Supplied schema"} is not a valid OpenAPI definition.`);
      else {
        if (typeof s.openapi == "number")
          throw Pn.syntax('OpenAPI version number must be a string (e.g. "3.0.0") not a number.');
        if (typeof s.info.version == "number")
          throw Pn.syntax('API version number must be a string (e.g. "1.0.0") not a number.');
        if (a.indexOf(s.openapi) === -1)
          throw Pn.syntax(
            `Unsupported OpenAPI version: ${s.openapi}. Swagger Parser only supports versions ${a.join(", ")}`
          );
      }
      GP.fixOasRelativeServers(s, i.path);
    }
    return _f(i.callback, Promise.resolve(s));
  } catch (s) {
    return _f(i.callback, Promise.reject(s));
  }
};
Mi.validate = function(e, t, r, n) {
  const i = this, s = new i();
  return s.validate.apply(s, arguments);
};
Mi.prototype.validate = async function(e, t, r, n) {
  const i = this, s = WP(arguments);
  s.options = new HP(s.options);
  const a = s.options.dereference.circular;
  s.options.validate.schema && (s.options.dereference.circular = "ignore");
  try {
    if (await this.dereference(s.path, s.schema, s.options), s.options.dereference.circular = a, s.options.validate.schema && (jz(i.api, s.options), i.$refs.circular)) {
      if (a === !0)
        Iz(i, s.options);
      else if (a === !1)
        throw Pn.reference("The API contains circular references");
    }
    return s.options.validate.spec && kz(i.api), _f(s.callback, Promise.resolve(i.schema));
  } catch (u) {
    return _f(s.callback, Promise.reject(u));
  }
};
var Ky = { exports: {} }, tm, b$;
function Mz() {
  if (b$)
    return tm;
  b$ = 1;
  var e = 1e3, t = e * 60, r = t * 60, n = r * 24, i = n * 7, s = n * 365.25;
  tm = function(d, p) {
    p = p || {};
    var h = typeof d;
    if (h === "string" && d.length > 0)
      return a(d);
    if (h === "number" && isFinite(d))
      return p.long ? c(d) : u(d);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(d)
    );
  };
  function a(d) {
    if (d = String(d), !(d.length > 100)) {
      var p = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        d
      );
      if (p) {
        var h = parseFloat(p[1]), v = (p[2] || "ms").toLowerCase();
        switch (v) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return h * s;
          case "weeks":
          case "week":
          case "w":
            return h * i;
          case "days":
          case "day":
          case "d":
            return h * n;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return h * r;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return h * t;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return h * e;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return h;
          default:
            return;
        }
      }
    }
  }
  function u(d) {
    var p = Math.abs(d);
    return p >= n ? Math.round(d / n) + "d" : p >= r ? Math.round(d / r) + "h" : p >= t ? Math.round(d / t) + "m" : p >= e ? Math.round(d / e) + "s" : d + "ms";
  }
  function c(d) {
    var p = Math.abs(d);
    return p >= n ? l(d, p, n, "day") : p >= r ? l(d, p, r, "hour") : p >= t ? l(d, p, t, "minute") : p >= e ? l(d, p, e, "second") : d + " ms";
  }
  function l(d, p, h, v) {
    var y = p >= h * 1.5;
    return Math.round(d / h) + " " + v + (y ? "s" : "");
  }
  return tm;
}
function Nz(e) {
  r.debug = r, r.default = r, r.coerce = c, r.disable = s, r.enable = i, r.enabled = a, r.humanize = Mz(), r.destroy = l, Object.keys(e).forEach((d) => {
    r[d] = e[d];
  }), r.names = [], r.skips = [], r.formatters = {};
  function t(d) {
    let p = 0;
    for (let h = 0; h < d.length; h++)
      p = (p << 5) - p + d.charCodeAt(h), p |= 0;
    return r.colors[Math.abs(p) % r.colors.length];
  }
  r.selectColor = t;
  function r(d) {
    let p, h = null, v, y;
    function g(..._) {
      if (!g.enabled)
        return;
      const m = g, w = Number(/* @__PURE__ */ new Date()), $ = w - (p || w);
      m.diff = $, m.prev = p, m.curr = w, p = w, _[0] = r.coerce(_[0]), typeof _[0] != "string" && _.unshift("%O");
      let E = 0;
      _[0] = _[0].replace(/%([a-zA-Z%])/g, (R, I) => {
        if (R === "%%")
          return "%";
        E++;
        const D = r.formatters[I];
        if (typeof D == "function") {
          const J = _[E];
          R = D.call(m, J), _.splice(E, 1), E--;
        }
        return R;
      }), r.formatArgs.call(m, _), (m.log || r.log).apply(m, _);
    }
    return g.namespace = d, g.useColors = r.useColors(), g.color = r.selectColor(d), g.extend = n, g.destroy = r.destroy, Object.defineProperty(g, "enabled", {
      enumerable: !0,
      configurable: !1,
      get: () => h !== null ? h : (v !== r.namespaces && (v = r.namespaces, y = r.enabled(d)), y),
      set: (_) => {
        h = _;
      }
    }), typeof r.init == "function" && r.init(g), g;
  }
  function n(d, p) {
    const h = r(this.namespace + (typeof p > "u" ? ":" : p) + d);
    return h.log = this.log, h;
  }
  function i(d) {
    r.save(d), r.namespaces = d, r.names = [], r.skips = [];
    let p;
    const h = (typeof d == "string" ? d : "").split(/[\s,]+/), v = h.length;
    for (p = 0; p < v; p++)
      h[p] && (d = h[p].replace(/\*/g, ".*?"), d[0] === "-" ? r.skips.push(new RegExp("^" + d.slice(1) + "$")) : r.names.push(new RegExp("^" + d + "$")));
  }
  function s() {
    const d = [
      ...r.names.map(u),
      ...r.skips.map(u).map((p) => "-" + p)
    ].join(",");
    return r.enable(""), d;
  }
  function a(d) {
    if (d[d.length - 1] === "*")
      return !0;
    let p, h;
    for (p = 0, h = r.skips.length; p < h; p++)
      if (r.skips[p].test(d))
        return !1;
    for (p = 0, h = r.names.length; p < h; p++)
      if (r.names[p].test(d))
        return !0;
    return !1;
  }
  function u(d) {
    return d.toString().substring(2, d.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  function c(d) {
    return d instanceof Error ? d.stack || d.message : d;
  }
  function l() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  return r.enable(r.load()), r;
}
var Dz = Nz;
(function(e, t) {
  t.formatArgs = n, t.save = i, t.load = s, t.useColors = r, t.storage = a(), t.destroy = (() => {
    let c = !1;
    return () => {
      c || (c = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
    };
  })(), t.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function r() {
    return typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? !0 : typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? !1 : typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function n(c) {
    if (c[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + c[0] + (this.useColors ? "%c " : " ") + "+" + e.exports.humanize(this.diff), !this.useColors)
      return;
    const l = "color: " + this.color;
    c.splice(1, 0, l, "color: inherit");
    let d = 0, p = 0;
    c[0].replace(/%[a-zA-Z%]/g, (h) => {
      h !== "%%" && (d++, h === "%c" && (p = d));
    }), c.splice(p, 0, l);
  }
  t.log = console.debug || console.log || (() => {
  });
  function i(c) {
    try {
      c ? t.storage.setItem("debug", c) : t.storage.removeItem("debug");
    } catch {
    }
  }
  function s() {
    let c;
    try {
      c = t.storage.getItem("debug");
    } catch {
    }
    return !c && typeof Me.process < "u" && "env" in Me.process && (c = Me.process.env.DEBUG), c;
  }
  function a() {
    try {
      return localStorage;
    } catch {
    }
  }
  e.exports = Dz(t);
  const { formatters: u } = e.exports;
  u.j = function(c) {
    try {
      return JSON.stringify(c);
    } catch (l) {
      return "[UnexpectedJSONParseError]: " + l.message;
    }
  };
})(Ky, Ky.exports);
var Lz = Ky.exports;
function _$({ schema: e }) {
  return RE.generateSchema(e);
}
function md(e) {
  return Lz.debug(e);
}
function qz() {
  var e, t, r, n;
  return ((t = (e = Me.process) == null ? void 0 : e.env) == null ? void 0 : t.DEBUG) || !((n = (r = import.meta) == null ? void 0 : r.env) != null && n.PROD);
}
function ql(e) {
  return yn.isBuffer(e) ? e.byteLength : new Blob([typeof e == "object" ? JSON.stringify(e) : e]).size || 0;
}
function Fz(e) {
  return typeof e != "string" ? !1 : !isNaN(e) && !isNaN(parseFloat(e));
}
function Uz(e) {
  return typeof e != "string" ? e : Fz(e) ? e.indexOf(".") !== -1 ? parseFloat(e) : parseInt(e) : e;
}
const yd = ({ ms: e, fn: t }) => new Promise((r, n) => {
  const i = setTimeout(() => {
    n({ error: "timeout" });
  }, e);
  t.then((s) => {
    clearTimeout(i), r(s);
  }, n);
}), Yy = md("security"), KP = new Lf(), Bz = 1e3 * 1e3;
async function Vz({ ip: e, request_id: t }) {
  const r = qf();
  return await KP.set(r, { ip: e, request_id: t }, Bz), r;
}
async function Zz({
  challenge: e,
  ip: t,
  request_id: r
}) {
  const n = await KP.get(e);
  return n ? n.ip !== t || n.request_id !== r ? (Yy(`challenge ${e} does not match ip ${t} or request_id ${r}`), !1) : !0 : (Yy(`challenge ${e} not found`), !1);
}
function uo({ str: e }) {
  return T3(yn.isBuffer(e) ? e : yn.from(e, "hex"));
}
function zz({
  message: e,
  signature: t,
  public_key: r
}) {
  const n = rn({ input: uo({ str: e }) });
  return J3(t, n, r);
}
async function Wz(e) {
  if (e && typeof e == "object" && "auth" in e && "params" in e) {
    const t = e.auth;
    if (!await Zz({ challenge: e.auth.n || "", ip: e.ip, request_id: e.request_id }))
      return !1;
    Yy(`verifying signature for ${e.request_id}`);
    const r = uo({
      str: JSON.stringify({ offer: e.offer, params: e.params || {}, nonce: e.auth.n, request_id: e.id })
    });
    return zz({ message: rn({ input: r }), signature: t.s, public_key: t.pk });
  } else
    return { error: "Missing auth or params" };
}
async function YP() {
  const e = X3.randomPrivateKey(), t = dE(e);
  return { private_key: yn.toString(e, "hex"), public_key: yn.toString(t, "hex") };
}
async function wf(e, t) {
  const r = yn.isBuffer(e) ? yn.from(e) : e, n = rn({ input: uo({ str: r }) });
  return (await Y3(n, rn({ input: t }))).toCompactRawBytes();
}
async function Hz({ private_key: e }) {
  return rn({ input: await dE(e) });
}
function rn({ input: e, add0x: t = !1 }) {
  const r = yn.toString(e, "hex");
  return t ? "0x" + r : r;
}
function $f({ input: e }) {
  return yn.from(e.replace(/^0x/, ""), "hex");
}
async function QH() {
  const e = await YP();
  return {
    ...e,
    user_id: e.public_key
  };
}
var JP = { exports: {} };
(function(e) {
  var t = Object.prototype.hasOwnProperty, r = "~";
  function n() {
  }
  Object.create && (n.prototype = /* @__PURE__ */ Object.create(null), new n().__proto__ || (r = !1));
  function i(c, l, d) {
    this.fn = c, this.context = l, this.once = d || !1;
  }
  function s(c, l, d, p, h) {
    if (typeof d != "function")
      throw new TypeError("The listener must be a function");
    var v = new i(d, p || c, h), y = r ? r + l : l;
    return c._events[y] ? c._events[y].fn ? c._events[y] = [c._events[y], v] : c._events[y].push(v) : (c._events[y] = v, c._eventsCount++), c;
  }
  function a(c, l) {
    --c._eventsCount === 0 ? c._events = new n() : delete c._events[l];
  }
  function u() {
    this._events = new n(), this._eventsCount = 0;
  }
  u.prototype.eventNames = function() {
    var l = [], d, p;
    if (this._eventsCount === 0)
      return l;
    for (p in d = this._events)
      t.call(d, p) && l.push(r ? p.slice(1) : p);
    return Object.getOwnPropertySymbols ? l.concat(Object.getOwnPropertySymbols(d)) : l;
  }, u.prototype.listeners = function(l) {
    var d = r ? r + l : l, p = this._events[d];
    if (!p)
      return [];
    if (p.fn)
      return [p.fn];
    for (var h = 0, v = p.length, y = new Array(v); h < v; h++)
      y[h] = p[h].fn;
    return y;
  }, u.prototype.listenerCount = function(l) {
    var d = r ? r + l : l, p = this._events[d];
    return p ? p.fn ? 1 : p.length : 0;
  }, u.prototype.emit = function(l, d, p, h, v, y) {
    var g = r ? r + l : l;
    if (!this._events[g])
      return !1;
    var _ = this._events[g], m = arguments.length, w, $;
    if (_.fn) {
      switch (_.once && this.removeListener(l, _.fn, void 0, !0), m) {
        case 1:
          return _.fn.call(_.context), !0;
        case 2:
          return _.fn.call(_.context, d), !0;
        case 3:
          return _.fn.call(_.context, d, p), !0;
        case 4:
          return _.fn.call(_.context, d, p, h), !0;
        case 5:
          return _.fn.call(_.context, d, p, h, v), !0;
        case 6:
          return _.fn.call(_.context, d, p, h, v, y), !0;
      }
      for ($ = 1, w = new Array(m - 1); $ < m; $++)
        w[$ - 1] = arguments[$];
      _.fn.apply(_.context, w);
    } else {
      var E = _.length, A;
      for ($ = 0; $ < E; $++)
        switch (_[$].once && this.removeListener(l, _[$].fn, void 0, !0), m) {
          case 1:
            _[$].fn.call(_[$].context);
            break;
          case 2:
            _[$].fn.call(_[$].context, d);
            break;
          case 3:
            _[$].fn.call(_[$].context, d, p);
            break;
          case 4:
            _[$].fn.call(_[$].context, d, p, h);
            break;
          default:
            if (!w)
              for (A = 1, w = new Array(m - 1); A < m; A++)
                w[A - 1] = arguments[A];
            _[$].fn.apply(_[$].context, w);
        }
    }
    return !0;
  }, u.prototype.on = function(l, d, p) {
    return s(this, l, d, p, !1);
  }, u.prototype.once = function(l, d, p) {
    return s(this, l, d, p, !0);
  }, u.prototype.removeListener = function(l, d, p, h) {
    var v = r ? r + l : l;
    if (!this._events[v])
      return this;
    if (!d)
      return a(this, v), this;
    var y = this._events[v];
    if (y.fn)
      y.fn === d && (!h || y.once) && (!p || y.context === p) && a(this, v);
    else {
      for (var g = 0, _ = [], m = y.length; g < m; g++)
        (y[g].fn !== d || h && !y[g].once || p && y[g].context !== p) && _.push(y[g]);
      _.length ? this._events[v] = _.length === 1 ? _[0] : _ : a(this, v);
    }
    return this;
  }, u.prototype.removeAllListeners = function(l) {
    var d;
    return l ? (d = r ? r + l : l, this._events[d] && a(this, d)) : (this._events = new n(), this._eventsCount = 0), this;
  }, u.prototype.off = u.prototype.removeListener, u.prototype.addListener = u.prototype.on, u.prefixed = r, u.EventEmitter = u, e.exports = u;
})(JP);
var Gz = JP.exports;
const Kz = /* @__PURE__ */ ea(Gz), wi = new Kz();
async function XP({ request_id: e, data: t, onData: r, onDone: n, onError: i }) {
  if ("error" in t)
    return i && i(t);
  if (t.request_id && t.status === "ready") {
    e = t.request_id;
    return;
  } else {
    if (t.request_id === e && t.status === "data")
      return r && r(t);
    if (t.request_id === e && t.status === "complete")
      return n && n(t);
    if (t.request_id === e)
      return i && i({ error: `Unknown type of response: ${JSON.stringify(t)}`, code: 500 });
  }
}
async function Yz({
  request_id: e,
  onData: t,
  onDone: r,
  onError: n
}) {
  const i = {
    write: async (s) => {
      const { offer: a } = s.input;
      wi.emit(`${a.call.module_id}:/${a.call.method_id}:post`, s);
    },
    close: async () => !0
  };
  return wi.on(e, async (s) => {
    XP({ request_id: e, data: s, onData: t, onDone: r, onError: n });
  }), i;
}
async function Jz({ API: e }) {
  wi.on("registerModule", async ({ module: t }) => {
    const { code: r } = await e.registerModule({ module: t });
    return r !== 200 ? { error: "Failed to register module", code: r } : { code: r };
  }), wi.on("registerProtocol", async ({ protocol: t }) => ({ code: 200 }));
  for (const t of e.getModules())
    for (const r in t.schema.paths) {
      const n = t.schema.paths[r];
      for (const i in n)
        wi.on(
          `${t.id}:${r}:${i}`,
          async ({
            input: s,
            globals: a,
            abort: u
          }) => {
            if (u)
              return e.abort({ request_id: s.id });
            const c = await e.execute({
              input: s,
              globals: a,
              // ...channel,
              onData: (l) => {
                wi.emit(`${s.id}`, { request_id: s.id, data: l, status: "data" });
              },
              onDone: (l) => {
                wi.emit(`${s.id}`, { request_id: s.id, status: "complete", data: l });
              },
              onError: (l) => {
                wi.emit(`${s.id}`, { request_id: s.id, error: l, status: "error" });
              }
            });
            return c && "error" in c ? wi.emit(`${s.id}`, { request_id: s.id, error: c == null ? void 0 : c.error, status: "error" }) : c;
          }
        );
    }
}
var QP = function() {
  throw new Error(
    "ws does not work in the browser. Browser clients must use the native WebSocket object"
  );
};
const Xz = /* @__PURE__ */ ea(QP), rm = /* @__PURE__ */ new Map();
async function Qz({
  request_id: e,
  host: t,
  onData: r,
  onDone: n,
  onError: i
}) {
  const s = async () => {
    const c = rm.get(t);
    if (!c || (c == null ? void 0 : c.readyState) !== 1) {
      const l = new Xz(`ws://${t}:8080`);
      return rm.set(t, l), new Promise((d) => {
        l.onopen = () => {
          d(l);
        };
      });
    }
    return c;
  }, a = {
    write: async (c) => {
      (await s()).send(JSON.stringify(c));
    },
    close: async () => {
      const c = await s();
      return c && (c.close(), rm.delete(t)), !0;
    }
  }, u = await s();
  return u.onmessage = (c) => {
    try {
      if (yn.isBuffer(c == null ? void 0 : c.data))
        return { error: "buffer not supported yet " };
      const l = typeof c.data == "object" ? c.data : JSON.parse(c.data);
      XP({ request_id: e, data: l, onData: r, onDone: n, onError: i });
    } catch (l) {
      return { error: l };
    }
  }, a;
}
async function eW({
  API: e,
  ws: t,
  input: r,
  globals: n,
  abort: i
}) {
  if (i)
    return e.abort({ request_id: r.id });
  const s = await e.execute({
    input: r,
    globals: n,
    // ...channel,
    onData: (a) => {
      t.send(JSON.stringify({ request_id: r.id, data: a, status: "data" }));
    },
    onDone: (a) => {
      t.send(JSON.stringify({ request_id: r.id, status: "complete", data: a }));
    },
    onError: (a) => {
      t.send(JSON.stringify({ request_id: r.id, error: a, status: "error" }));
    }
  });
  return s && "error" in s ? t.send(JSON.stringify({ request_id: r.id, error: s == null ? void 0 : s.error, status: "error" })) : s;
}
async function tW({
  API: e,
  host: t = "127.0.0.1",
  port: r = 8080
}) {
  new QP.WebSocketServer({ host: t, port: r }).on("connection", function(s) {
    s.on("error", console.error), s.on("message", function(u) {
      const c = yn.isBuffer(u) ? yn.toString(u) : typeof u == "string" ? u : "{}";
      let l = JSON.parse(c);
      eW({ ...l, ws: s, API: e });
    });
  });
}
var oc = {}, j0 = {};
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
(function(e) {
  e.binary = /^(?:[01]{8})+$/, e.boolean = /^(?:true|false)$/, e.byte = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/, e.date = /^(\d{4})-(\d{2})-(\d{2})$/, e.dateTime = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(Z|([+-]\d{2}:?\d{2}))$/i, e.integer = /^-?\d+$/, e.number = /^-?\d+(?:\.\d+)?$/, e["date-time"] = e.dateTime;
})(j0);
const rW = /* @__PURE__ */ If(I5);
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
const nW = Ku;
let iW = nW.inspect.custom || "inspect";
var qn = qr;
function qr(e) {
  if (!(this instanceof qr))
    return new qr(e);
  this.header = e, this.children = {
    at: {},
    nest: [],
    message: []
  };
}
qr.prototype.at = function(e) {
  const t = this.children.at;
  return t[e] || (t[e] = new qr("")), t[e];
};
qr.prototype.clearCache = function() {
  return this;
};
qr.prototype[iW] = function() {
  return this.hasException ? "[ EnforcerException: " + gu(this, null, "  ") + " ]" : "[ EnforcerException ]";
};
qr.prototype.nest = function(e) {
  const t = new qr(e);
  return this.children.nest.push(t), t;
};
qr.prototype.merge = function(e) {
  const t = this.children, r = e.children, n = t.at;
  return Object.keys(r.at).forEach((i) => {
    n[i] ? n[i].merge(r.at[i]) : n[i] = r.at[i];
  }), r.nest.forEach((i) => {
    t.nest.push(i);
  }), r.message.forEach((i) => {
    t.message.push(i);
  }), this;
};
qr.prototype.message = function(e) {
  return this.children.message.push(e), this;
};
qr.prototype.push = function(e) {
  const t = typeof e;
  if (t === "string" && e.length)
    this.children.message.push(e);
  else if (t === "object" && e instanceof qr)
    this.children.nest.push(e);
  else
    throw Error("Can only push string or EnforcerException instance");
  return this;
};
qr.prototype.toString = function() {
  return gu(this, null, "");
};
Object.defineProperties(qr.prototype, {
  count: {
    get: function() {
      const e = this.children;
      return e.message.length + e.nest.reduce((t, r) => t + r.count, 0) + Object.keys(e.at).reduce((t, r) => t + e.at[r].count, 0);
    }
  },
  hasException: {
    get: function() {
      const e = this.children;
      if (e.message.length)
        return !0;
      {
        const t = e.nest, r = t.length;
        for (let s = 0; s < r; s++)
          if (t[s].hasException)
            return !0;
        const n = Object.keys(e.at), i = n.length;
        for (let s = 0; s < i; s++)
          if (e.at[n[s]].hasException)
            return !0;
      }
      return !1;
    }
  }
});
function gu(e, t, r) {
  if (!e.hasException)
    return "";
  const n = r + "  ", i = e.children;
  let s = "";
  e.header && (s += (t ? r : "") + e.header);
  const a = i.at, u = Object.keys(a).filter((l) => a[l].hasException), c = u.length === 1;
  return u.forEach((l) => {
    const d = i.at[l];
    e.header || !c || i.nest.length > 0 || i.message.length > 0 ? s += `
` + n + "at: " + l + gu(d, e, n) : s += " > " + l + gu(d, e, r);
  }), i.nest.forEach((l) => {
    l.hasException && (s += `
` + gu(l, e, n));
  }), i.message.forEach((l) => {
    s += `
` + n + l;
  }), s;
}
const eS = rW, w$ = j0, $$ = qn, E$ = /^([\s\S]+?)\/(?:([\s\S]+?)\+)?([\s\S]+?)$/, tS = ",,,,,,,,,,.................................:;!?", sW = tS.length, rS = "lorem ipsum dolor sit amet consectetur adipiscing elit suspendisse sollicitudin felis pretium laoreet tortor facilisis a integer eu metus velit praesent varius sed erat quis ornare nunc porttitor nulla at ultrices nam ac vestibulum metus maecenas malesuada lectus leo blandit a congue gravida phasellus consectetur libero et tincidunt diam pellentesque lacus neque eros sed porta nunc id lobortis eget ligula mollis nulla nunc maximus gravida felis finibus est ullamcorper pellentesque ex in turpis pharetra dictum in fermentum arcu mauris odio molestie iaculis accumsan nec convallis nec nunc vestibulum nisl curabitur tristique non porttitor vivamus dui ipsum orci eget vulputate lacus interdum suscipit massa elementum sodales at interdum fames ante primis in faucibus duis mi pulvinar accumsan donec odio enim sed dignissim turpis quisque vitae turpis ut nibh tincidunt aliquam magna semper aliquam feugiat sapien justo egestas condimentum metus tincidunt odio volutpat vehicula pulvinar arcu diam bibendum sem leo sodales eleifend vehicula fusce faucibus quam lorem rhoncus amet hendrerit rhoncus augue mattis commodo lobortis urna consequat hendrerit enim risus placerat eros euismod ligula tellus tempus condimentum ac lectus erat ultrices mi lacus nisi scelerisque vehicula cursus cras enim elit aenean aliquam tempor ullamcorper est proin aliquet orci et augue posuere viverra massa augue purus orci purus neque ut elit pretium molestie vel tellus ex consequat tristique urna fringilla dignissim ex lectus imperdiet lobortis potenti efficitur feugiat facilisi placerat posuere bibendum velit volutpat dapibus donec".split(" "), aW = rS.length;
var Qt = {
  arrayRemoveItem: oW,
  copy: (e) => Jy(/* @__PURE__ */ new Map(), e),
  determineSchemaFromSchemas: Fl,
  edgeSlashes: uW,
  findMediaMatch: cW,
  freeze: Ul,
  getDateFromValidDateString: lW,
  getDefinitionType: dW,
  greatestCommonDenominator: nS,
  isDate: Xy,
  isNumber: Bl,
  isInteger: pW,
  isPlainObject: uc,
  isObject: Ef,
  isObjectStringMap: hW,
  leastCommonMultiple: mW,
  leastOf: yW,
  lowerCaseObjectProperties: gW,
  mapObject: vW,
  merge: Qy,
  methods: bW,
  mostOf: _W,
  parseCookieString: wW,
  parseQueryString: $W,
  randomNumber: iS,
  randomOneOf: EW,
  randomText: xW,
  reject: OW,
  rxStringToRx: SW,
  same: eg,
  schemaObjectHasSkipCode: tg,
  smart: _i,
  toPlainObject: function(e, t) {
    const r = /* @__PURE__ */ new Map();
    if (t || (t = {}), typeof t != "object")
      throw Error('Parameter "options" must be an object');
    if (t.hasOwnProperty("allowInheritedProperties") || (t.allowInheritedProperties = !1), t.hasOwnProperty("preserve") || (t.preserve = []), !Array.isArray(t.preserve))
      throw Error('Option "preserve" must be an array');
    t.preserve = new Set(t.preserve), t.preserve.add(Date);
    const n = rg(e, t, r);
    if (!n.set)
      throw Error("Unable to convert value to plain object");
    return n.value;
  },
  toQueryString: AW,
  ucFirst: sS,
  validateExamples: CW,
  validateMaxMin: RW
};
function oW(e, t) {
  const r = e.indexOf(t);
  return r !== -1 && e.splice(r, 1), e;
}
function Jy(e, t) {
  if (t instanceof Date)
    return /* @__PURE__ */ new Date(+t);
  if (t instanceof Me.Buffer)
    return t.slice(0);
  if (Array.isArray(t)) {
    let r = e.get(t);
    return r || (r = [], e.set(t, r), t.forEach((n) => r.push(Jy(e, n))), r);
  } else if (uc(t)) {
    let r = e.get(t);
    return r || (r = {}, e.set(t, r), Object.keys(t).forEach((n) => r[n] = Jy(e, t[n])), r);
  } else
    return t;
}
function Or() {
  throw Error("Date object cannot be modified");
}
function Fl(e, t) {
  const r = typeof t, n = e.length;
  for (let i = 0; i < n; i++) {
    const s = e[i];
    if (s.type === "array" && Array.isArray(t) || s.type === "boolean" && r === "boolean" || s.type === "integer" && r === "number" && /^\d+$/.test(String(t)) || s.type === "number" && r === "number" || s.type === "string" && r === "string" || s.type === "object" && r === "object" && t !== null || t === null && (s.nullable || s["x-nullable"]))
      return s;
    if (s.anyOf) {
      const a = Fl(a.anyOf, t);
      if (a !== null)
        return a;
    } else if (s.oneOf) {
      const a = Fl(a.oneOf, t);
      if (a !== null)
        return a;
    } else if (s.allOf) {
      const a = s.allOf.length;
      for (let u = 0; u < a; u++) {
        const c = c.allOf[u];
        if (c.type !== void 0)
          return c;
        if (c.anyOf || c.oneOf)
          return Fl(c.anyOf ?? c.oneOf, t);
      }
    }
  }
  return null;
}
function uW(e, t, r) {
  return e = e.replace(/^\//, "").replace(/\/$/, ""), e.length === 0 && (t || r) ? "/" : (t && (e = "/" + e), r && (e += "/"), e);
}
function cW(e, t) {
  const r = e.split(/, */).map((a, u) => {
    const c = a.split(";"), l = E$.exec(c[0]), d = /q=(\d(?:\.\d)?)/.exec(c[1]);
    if (l)
      return {
        extension: l[2] || "*",
        index: u,
        quality: +(d && d[1] || 1),
        subType: l[3],
        type: l[1]
      };
  }).filter((a) => !!a), n = [];
  r.forEach((a) => {
    t.forEach((u, c) => {
      const l = E$.exec(u);
      if (l) {
        const d = l[1], p = l[3], h = l[2] || "*";
        (a.type === d || a.type === "*" || d === "*") && (a.subType === p || a.subType === "*" || p === "*") && (a.extension === h || a.extension === "*" || h === "*") && n.push({
          index: a.index,
          order: c,
          quality: a.quality,
          score: (a.type === d ? 1 : 0) + (a.subType === p ? 1 : 0) + (a.extension === h ? 1 : 0),
          value: u
        });
      }
    });
  }), n.sort((a, u) => a.quality < u.quality ? 1 : a.quality > u.quality ? -1 : a.score < u.score ? 1 : a.score > u.score ? -1 : a.index < u.index ? 1 : a.index > u.index || a.order < u.order ? -1 : 1);
  const i = {}, s = [];
  return n.forEach((a) => {
    const u = a.value;
    i[u] || (i[u] = a, s.push(a.value));
  }), s;
}
function Ul(e) {
  return !e || typeof e != "object" || e instanceof Me.Buffer || (e instanceof Date && (e.setDate = Or, e.setFullYear = Or, e.setHours = Or, e.setMilliseconds = Or, e.setMinutes = Or, e.setMonth = Or, e.setSeconds = Or, e.setTime = Or, e.setUTCDate = Or, e.setUTCFullYear = Or, e.setUTCHours = Or, e.setUTCMilliseconds = Or, e.setUTCMinutes = Or, e.setUTCMonth = Or, e.setUTCSeconds = Or, e.setYear = Or), Object.freeze(e)), e;
}
function lW(e, t) {
  const r = new Date(t), n = r.toISOString(), i = e === "date" ? w$.date.exec(n.substring(0, 10)) : w$["date-time"].exec(n), s = +i[1], a = +i[2] - 1, u = +i[3], c = +i[4] || 0, l = +i[5] || 0, d = +i[6] || 0, h = +fW(i[7]) || 0;
  return r.getUTCFullYear() === s && r.getUTCMonth() === a && r.getUTCDate() === u && r.getUTCHours() === c && r.getUTCMinutes() === l && r.getUTCSeconds() === d && r.getUTCMilliseconds() === h ? r : null;
}
function fW(e) {
  if (e === void 0)
    return;
  var t = e;
  const r = 3 - e.length;
  return r > 0 ? t = e + "0".repeat(r) : r < 0 && (t = e.substr(0, 3)), t;
}
function dW(e) {
  if (Array.isArray(e))
    return "array";
  if (uc(e))
    return "object";
  if (e === null)
    return "null";
  const t = typeof e;
  return t === "object" ? "decoratedObject" : t;
}
function nS(e, t) {
  for (e = Math.abs(e), t = Math.abs(t); t; ) {
    const r = t;
    t = e % t, e = r;
  }
  return e;
}
function Xy(e) {
  return e && !isNaN(e) && e instanceof Date;
}
function Bl(e) {
  return typeof e == "number" && !isNaN(e);
}
function pW(e) {
  return !isNaN(e) && typeof e == "number" && e === Math.round(e);
}
function Ef(e) {
  return e && typeof e == "object" && Object.prototype.toString.call(e) === "[object Object]";
}
function uc(e) {
  if (!Ef(e))
    return !1;
  const t = e.constructor;
  if (typeof t != "function")
    return !1;
  const r = t.prototype;
  return Ef(r) ? r.hasOwnProperty("isPrototypeOf") : !1;
}
function hW(e) {
  if (!uc(e))
    return !1;
  const t = Object.keys(e), r = t.length;
  for (let n = 0; n < r; n++)
    if (typeof t[n] != "string" || typeof e[t[n]] != "string")
      return !1;
  return !0;
}
function mW(e, t) {
  return typeof e != "number" || typeof t != "number" ? !1 : !e || !t ? 0 : Math.abs(e * t / nS(e, t));
}
function yW(e) {
  const t = e.length;
  let r = e[0];
  for (let n = 1; n < t; n++)
    e[n] < r && (r = e[n]);
  return r;
}
function gW(e) {
  const t = {};
  return Object.keys(e).forEach((r) => {
    t[r.toLowerCase()] = e[r];
  }), t;
}
function vW(e, t) {
  const r = {};
  return Object.keys(e).forEach((n) => {
    r[n] = t(e[n], n);
  }), r;
}
function Qy(e, t, r = "") {
  if (uc(e)) {
    if (!Ef(t))
      throw Error(r + ": Unable to merge non-object into plain object.");
    return Object.keys(t).forEach((n) => {
      e[n] = e.hasOwnProperty(n) ? Qy(e[n], t[n], r + "> " + n) : t[n];
    }), e;
  } else if (Array.isArray(e)) {
    if (!Array.isArray(t))
      throw Error(r + ": Unable to merge non-array into array");
    const n = e.length, i = n > t.length ? n : t.length;
    for (let s = 0; s < i; s++)
      s >= n ? e[s] = t[s] : e[s] = Qy(e[s], t[s], "> " + s);
    return e;
  } else
    return t;
}
function bW() {
  return ["get", "put", "post", "delete", "options", "head", "patch", "trace"];
}
function _W(e) {
  const t = e.length;
  let r = e[0];
  for (let n = 1; n < t; n++)
    e[n] > r && (r = e[n]);
  return r;
}
function wW(e) {
  const t = {};
  return e.split(/; */).forEach((r) => {
    const [n, i] = r.split("=");
    t[n] || (t[n] = []), t[n].push(i || "");
  }), t;
}
function $W(e, t) {
  const r = eS.parse(e, t);
  return Object.keys(r).forEach((n) => {
    const i = r[n];
    Array.isArray(i) || (r[n] = [i]);
  }), Object.assign({}, r);
}
function iS({ min: e, max: t, multipleOf: r, exclusiveMin: n = !1, exclusiveMax: i = !1, decimalPlaces: s = 0, spread: a = 1e3 } = {}) {
  const u = Bl(e), c = Bl(t);
  if (t < e)
    throw Error("Maximum value must be greater than or equal to minimum value");
  if (Bl(r) && r > 0) {
    const l = e % r;
    return l !== 0 && (e += r - l), t -= t % r, t === e ? t : (Math.round(Math.random() * (t - e) / r) + e) * r;
  } else {
    const l = u && c ? t - e : a;
    let d = Math.random() * l;
    return u && (d += e), d = PW(d, s), u && (d < e && (d = e), d === e && n && (d += Math.pow(10, -1 * s))), c && (d > t && (d = t), d === t && i && (d -= Math.pow(10, -1 * s))), u && (d < e || d === e && n) || c && (d > t || d === t && i) ? void 0 : d;
  }
}
function EW(e) {
  const t = Math.floor(Math.random() * e.length);
  return e[t];
}
function xW({ minLength: e = 1, maxLength: t = 250 } = {}) {
  const r = iS({ min: e, max: t }) + 1;
  let n = "", i = 1, s = !0;
  for (; n.length < r; ) {
    const a = Math.floor(Math.random() * aW);
    let u = rS[a];
    if (s && (u = sS(u)), s = !1, n += u, Math.random() >= i) {
      i = 1;
      const c = Math.floor(Math.random() * sW), l = tS[c];
      /[.!?]/.test(l) && (s = !0), n += l;
    } else
      i *= 0.9;
    n += " ";
  }
  return n = n.trim(), n = n.replace(/[,.:;!?]$/, ""), t > 5 ? (n.length >= t && (n = n.substr(0, t - 1)), n += ".") : n.length > t && (n = n.substr(0, t)), n;
}
function OW(e) {
  return Promise.reject(Error(typeof e == "string" ? e : e.toString()));
}
function PW(e, t = 0) {
  const r = Math.pow(10, t);
  return Math.round(e * r) / r;
}
function SW(e) {
  if (typeof e == "string") {
    const r = /^\/([\s\S]+?)\/(\w*)?$/.exec(e);
    return r ? RegExp(r[1], r[2] || "") : RegExp(e);
  } else {
    if (e instanceof RegExp)
      return e;
    throw Error("Cannot convert value to RegExp instance");
  }
}
function eg(e, t) {
  if (e === t)
    return !0;
  const r = typeof e;
  if (r !== typeof t)
    return !1;
  if (Array.isArray(e)) {
    if (!Array.isArray(t))
      return !1;
    const n = e.length;
    if (n !== t.length)
      return !1;
    for (let i = 0; i < n; i++)
      if (!eg(e[i], t[i]))
        return !1;
    return !0;
  } else {
    if (Me.Buffer.isBuffer(e))
      return Me.Buffer.isBuffer(t) && e.toString() === t.toString();
    if (Xy(e))
      return Xy(t) && +t == +e;
    if (e && r === "object") {
      if (!t)
        return !1;
      const n = Object.keys(e), i = n.length;
      if (i !== Object.keys(t).length)
        return !1;
      for (let s = 0; s < i; s++) {
        const a = n[s];
        if (!eg(e[a], t[a]))
          return !1;
      }
      return !0;
    } else
      return !1;
  }
}
function tg(e, t) {
  return (typeof e == "object" && e !== null ? e["x-enforcer-exception-skip-codes"] ?? "" : "").split(/ +/).map((i) => i.trim()).includes(t);
}
function _i(e) {
  const t = typeof e;
  if (t === "string")
    return '"' + e.replace(/"/g, '\\"') + '"';
  if (e instanceof Date)
    return isNaN(e) ? "invalid date object" : e.toISOString();
  if (Array.isArray(e)) {
    let r = "[" + String(e) + "]";
    const n = r.length;
    if (n > 15) {
      const i = n - 15, s = Math.floor(i / 2), a = i - s, u = Math.ceil(n / 2);
      r = r.substr(0, u - a) + "..." + r.substr(u + s);
    }
    return r;
  }
  if (e && t === "object") {
    const r = e.constructor ? e.constructor.name : "";
    return "[object" + (r ? " " + r : "") + "]";
  }
  return String(e);
}
function rg(e, t, r) {
  if (e && e.constructor && t.preserve.has(e.constructor))
    return { set: !0, value: e };
  if (Array.isArray(e)) {
    if (r.has(e))
      return r.get(e);
    const n = { set: !0, value: [] };
    return r.set(e, n), e.forEach((i) => {
      const s = rg(i, t, r);
      s.set && n.value.push(s.value);
    }), n;
  } else if (e && typeof e == "object") {
    if (r.has(e))
      return r.get(e);
    const n = { set: !0, value: {} };
    r.set(e, n);
    for (let i in e)
      if (t.allowInheritedProperties || e.hasOwnProperty(i)) {
        const s = rg(e[i], t, r);
        s.set && (n.value[i] = s.value);
      }
    return n;
  } else
    return e instanceof Object ? { set: !1 } : { set: !0, value: e };
}
function AW(e) {
  return eS.stringify(e);
}
function sS(e) {
  return e[0].toUpperCase() + e.substr(1);
}
function CW(e, t, r, n) {
  const i = n.exceptionSkipCodes, s = n.exceptionEscalateCodes;
  if (e.hasOwnProperty("schema")) {
    if (e.hasOwnProperty("example")) {
      let a, u;
      if ([a, u] = e.schema.deserialize(e.example), u || (u = e.schema.validate(a)), u && !i.WSCH006 && !tg(e, "WSCH006")) {
        const c = new $$("Example not valid. [WSCH006]");
        c.push(u), (s.WSCH006 ? t : r).at("example").push(c);
      }
      Object.defineProperty(e, "example", {
        configurable: !0,
        enumerable: !0,
        value: Ul(a)
      });
    }
    if (e.hasOwnProperty("examples")) {
      const a = e.enforcerData.major;
      Object.keys(e.examples).forEach((u) => {
        let c, l;
        const d = a === 2 ? e.examples[u] : e.examples[u].value;
        if ([c, l] = e.schema.deserialize(d), l || (l = e.schema.validate(c)), l && !i.WSCH006 && !tg(e, "WSCH006")) {
          const p = new $$("Example not valid. [WSCH006]");
          p.push(l), (s.WSCH006 ? t : r).at("examples").at(u).push(p);
        }
        a === 2 ? Object.defineProperty(e.examples, u, {
          configurable: !0,
          enumerable: !0,
          value: Ul(c)
        }) : Object.defineProperty(e.examples[u], "value", {
          configurable: !0,
          enumerable: !0,
          value: Ul(c)
        });
      });
    }
  }
}
function RW(e, t, r, n, i, s, a, u, c) {
  if (t.hasOwnProperty(n)) {
    if (s && t.exclusiveMaximum && a >= u) {
      let l = t.serialize(t[n]).value || t[n], d = t.serialize(a).value || a;
      e.message("Expected " + r + " to be less than " + _i(l) + ". Received: " + _i(d));
    } else if (a > u) {
      let l = t.serialize(t[n]).value || t[n], d = t.serialize(a).value || a;
      e.message("Expected " + r + " to be less than or equal to " + _i(l) + ". Received: " + _i(d));
    }
  }
  if (t.hasOwnProperty(i)) {
    if (s && t.exclusiveMinimum && a <= c) {
      let l = t.serialize(t[i]).value || t[i], d = t.serialize(a).value || a;
      e.message("Expected " + r + " to be greater than " + _i(l) + ". Received: " + _i(d));
    } else if (a < c) {
      let l = t.serialize(t[i]).value || t[i], d = t.serialize(a).value || a;
      e.message("Expected " + r + " to be greater than or equal to " + _i(l) + ". Received: " + _i(d));
    }
  }
}
const cs = j0, hr = Qt, TW = "00000000";
oc.binary = {
  constructors: [Me.Buffer],
  deserialize: function({ exception: e, value: t }) {
    if (t instanceof Me.Buffer)
      return t;
    if (typeof t != "string" || !cs.binary.test(t))
      e.message("Expected a binary octet string");
    else {
      const r = t.length, n = [];
      for (let i = 0; i < r; i += 8)
        n.push(parseInt(t.substr(i, 8), 2));
      return Me.Buffer.from(n, "binary");
    }
  },
  random: aS(8),
  serialize: function({ exception: e, value: t }) {
    if (t instanceof Me.Buffer) {
      let r = "";
      for (let n = 0; n < t.length; n++) {
        const i = t[n].toString(2);
        r += TW.substr(i.length) + i;
      }
      return r;
    } else
      e.message("Expected a Buffer instance. Received: " + hr.smart(t));
  },
  validate: function({ exception: e, schema: t, value: r }) {
    Me.Buffer.isBuffer(r) ? hr.validateMaxMin(e, t, "binary length", "maxLength", "minLength", !0, r.length * 8, t.maxLength, t.minLength) : e.message("Expected value to be a buffer. Received: " + hr.smart(r));
  },
  validator: function(e) {
    const { exception: t } = e;
    this.hasOwnProperty("maxLength") && this.maxLength % 8 !== 0 && t.at("maxLength").message("Binary format requires maxLength to be a multiple of 8"), this.hasOwnProperty("minLength") && this.minLength % 8 !== 0 && t.at("minLength").message("Binary format requires minLength to be a multiple of 8");
  }
};
oc.byte = {
  constructors: [Me.Buffer],
  deserialize: function({ exception: e, value: t }) {
    if (t instanceof Me.Buffer)
      return t;
    if (typeof t == "string")
      if (t = t.replace(/(\s)/gm, ""), !cs.byte.test(t) || t.length % 4 !== 0)
        e.message("Expected a base64 string");
      else
        return Me.Buffer.from(t, "base64");
    else
      e.message("Expected a base64 string");
  },
  random: aS(4),
  serialize: function({ exception: e, value: t }) {
    if (t instanceof Me.Buffer)
      return t.toString("base64");
    e.message("Expected a Buffer instance. Received: " + hr.smart(t));
  },
  validate: function({ exception: e, schema: t, value: r }) {
    Me.Buffer.isBuffer(r) ? hr.validateMaxMin(e, t, "byte length", "maxLength", "minLength", !0, r.length, t.maxLength, t.minLength) : e.message("Expected value to be a buffer. Received: " + hr.smart(r));
  },
  validator: function(e) {
    const { exception: t } = e;
    this.hasOwnProperty("maxLength") && this.maxLength % 4 !== 0 && t.at("maxLength").message("Byte format requires maxLength to be a multiple of 4"), this.hasOwnProperty("minLength") && this.minLength % 4 !== 0 && t.at("minLength").message("Byte format requires minLength to be a multiple of 4");
  }
};
oc.date = {
  constructors: [Date],
  deserialize: function({ exception: e, value: t }) {
    if (t instanceof Date)
      return t;
    if (typeof t != "string" || !cs.date.test(t))
      e.message("Expected a date string of the format YYYY-MM-DD");
    else {
      const r = hr.getDateFromValidDateString("date", t);
      if (!r)
        e.message("Value is not a valid date");
      else
        return r;
    }
  },
  isNumeric: !0,
  random: oS,
  serialize: function({ exception: e, value: t }) {
    const r = t;
    if (typeof t === "string" && (cs.date.test(t) || cs.dateTime.test(t)) && (t = new Date(t)), hr.isDate(t))
      return t.toISOString().substr(0, 10);
    e.message("Expected a valid Date instance or date formatted string. Received: " + hr.smart(r));
  },
  validate: function({ exception: e, schema: t, value: r }) {
    hr.isDate(r) ? hr.validateMaxMin(e, t, t.format, "maximum", "minimum", !1, r, t.maximum, t.minimum) : e.message("Expected a valid date object. Received: " + hr.smart(r));
  },
  validator: function(e) {
    const { exception: t } = e;
    this.hasOwnProperty("maxLength") && this.maxLength !== 10 && t.at("maxLength").message("Date format requires maxLength to equal 10"), this.hasOwnProperty("minLength") && this.minLength % 4 !== 0 && t.at("minLength").message("Date format requires minLength to equal 10");
  }
};
oc.dateTime = {
  constructors: [Date],
  deserialize: function({ exception: e, value: t }) {
    if (t instanceof Date)
      return t;
    if (typeof t != "string" || !cs.dateTime.test(t))
      e.message("Expected a date-time string of the format YYYY-MM-DDThh:mm:ss.sssZ");
    else {
      const r = hr.getDateFromValidDateString("date-time", t);
      if (!r)
        e.message("Expected a date-time string of the format YYYY-MM-DDThh:mm:ss.sssZ");
      else
        return r;
    }
  },
  isNumeric: !0,
  random: oS,
  serialize: function({ exception: e, value: t }) {
    const r = t;
    if (typeof t === "string" && (cs.date.test(t) || cs.dateTime.test(t)) && (t = new Date(t)), hr.isDate(t))
      return t.toISOString();
    e.message("Expected a valid Date instance or an ISO date formatted string. Received: " + hr.smart(r));
  },
  validate: function({ exception: e, schema: t, value: r }) {
    hr.isDate(r) ? hr.validateMaxMin(e, t, t.format, "maximum", "minimum", !1, r, t.maximum, t.minimum) : e.message("Expected a valid date object. Received: " + hr.smart(r));
  },
  validator: function(e) {
    const { exception: t } = e;
    this.hasOwnProperty("maxLength") && this.maxLength !== 10 && t.at("maxLength").message("Date-time format requires maxLength to equal 24"), this.hasOwnProperty("minLength") && this.minLength % 4 !== 0 && t.at("minLength").message("Date-time format requires minLength to equal 24");
  }
};
function aS(e) {
  return function({ schema: t }, { randomNumber: r }) {
    const n = t.hasOwnProperty("minLength"), i = t.hasOwnProperty("maxLength"), s = {};
    n && i ? (s.min = t.minLength / e, s.max = t.maxLength / e) : n ? (s.min = +t.minLength / e, s.max = s.min + 25) : i ? (s.max = +t.maximum / e, s.min = s.max - 25) : (s.min = 1, s.max = 25);
    const a = r(s), u = [];
    for (let c = 0; c < a; c++)
      u.push(Math.floor(Math.random() * 256));
    return Me.Buffer.from(u);
  };
}
function oS({ schema: e }, { randomNumber: t }) {
  const n = e.hasOwnProperty("minimum"), i = e.hasOwnProperty("maximum"), s = {
    exclusiveMinimum: e.exclusiveMinimum,
    exclusiveMaximum: e.exclusiveMaximum
  };
  n && i ? (s.min = +e.minimum, s.max = +e.maximum) : n ? (s.min = +e.minimum, s.max = s.min + 157248e6) : i ? (s.max = +e.maximum, s.min = s.max - 157248e6) : (s.min = Date.now() - 78624e6, s.max = Date.now() + 78624e6);
  const a = t(s);
  if (a !== void 0)
    return new Date(a);
}
function zn(e) {
  if (typeof e != "string")
    throw new TypeError("Path must be a string. Received " + JSON.stringify(e));
}
function x$(e, t) {
  for (var r = "", n = 0, i = -1, s = 0, a, u = 0; u <= e.length; ++u) {
    if (u < e.length)
      a = e.charCodeAt(u);
    else {
      if (a === 47)
        break;
      a = 47;
    }
    if (a === 47) {
      if (!(i === u - 1 || s === 1))
        if (i !== u - 1 && s === 2) {
          if (r.length < 2 || n !== 2 || r.charCodeAt(r.length - 1) !== 46 || r.charCodeAt(r.length - 2) !== 46) {
            if (r.length > 2) {
              var c = r.lastIndexOf("/");
              if (c !== r.length - 1) {
                c === -1 ? (r = "", n = 0) : (r = r.slice(0, c), n = r.length - 1 - r.lastIndexOf("/")), i = u, s = 0;
                continue;
              }
            } else if (r.length === 2 || r.length === 1) {
              r = "", n = 0, i = u, s = 0;
              continue;
            }
          }
          t && (r.length > 0 ? r += "/.." : r = "..", n = 2);
        } else
          r.length > 0 ? r += "/" + e.slice(i + 1, u) : r = e.slice(i + 1, u), n = u - i - 1;
      i = u, s = 0;
    } else
      a === 46 && s !== -1 ? ++s : s = -1;
  }
  return r;
}
function IW(e, t) {
  var r = t.dir || t.root, n = t.base || (t.name || "") + (t.ext || "");
  return r ? r === t.root ? r + n : r + e + n : n;
}
var Qa = {
  // path.resolve([from ...], to)
  resolve: function() {
    for (var t = "", r = !1, n, i = arguments.length - 1; i >= -1 && !r; i--) {
      var s;
      i >= 0 ? s = arguments[i] : (n === void 0 && (n = Me.process.cwd()), s = n), zn(s), s.length !== 0 && (t = s + "/" + t, r = s.charCodeAt(0) === 47);
    }
    return t = x$(t, !r), r ? t.length > 0 ? "/" + t : "/" : t.length > 0 ? t : ".";
  },
  normalize: function(t) {
    if (zn(t), t.length === 0)
      return ".";
    var r = t.charCodeAt(0) === 47, n = t.charCodeAt(t.length - 1) === 47;
    return t = x$(t, !r), t.length === 0 && !r && (t = "."), t.length > 0 && n && (t += "/"), r ? "/" + t : t;
  },
  isAbsolute: function(t) {
    return zn(t), t.length > 0 && t.charCodeAt(0) === 47;
  },
  join: function() {
    if (arguments.length === 0)
      return ".";
    for (var t, r = 0; r < arguments.length; ++r) {
      var n = arguments[r];
      zn(n), n.length > 0 && (t === void 0 ? t = n : t += "/" + n);
    }
    return t === void 0 ? "." : Qa.normalize(t);
  },
  relative: function(t, r) {
    if (zn(t), zn(r), t === r || (t = Qa.resolve(t), r = Qa.resolve(r), t === r))
      return "";
    for (var n = 1; n < t.length && t.charCodeAt(n) === 47; ++n)
      ;
    for (var i = t.length, s = i - n, a = 1; a < r.length && r.charCodeAt(a) === 47; ++a)
      ;
    for (var u = r.length, c = u - a, l = s < c ? s : c, d = -1, p = 0; p <= l; ++p) {
      if (p === l) {
        if (c > l) {
          if (r.charCodeAt(a + p) === 47)
            return r.slice(a + p + 1);
          if (p === 0)
            return r.slice(a + p);
        } else
          s > l && (t.charCodeAt(n + p) === 47 ? d = p : p === 0 && (d = 0));
        break;
      }
      var h = t.charCodeAt(n + p), v = r.charCodeAt(a + p);
      if (h !== v)
        break;
      h === 47 && (d = p);
    }
    var y = "";
    for (p = n + d + 1; p <= i; ++p)
      (p === i || t.charCodeAt(p) === 47) && (y.length === 0 ? y += ".." : y += "/..");
    return y.length > 0 ? y + r.slice(a + d) : (a += d, r.charCodeAt(a) === 47 && ++a, r.slice(a));
  },
  _makeLong: function(t) {
    return t;
  },
  dirname: function(t) {
    if (zn(t), t.length === 0)
      return ".";
    for (var r = t.charCodeAt(0), n = r === 47, i = -1, s = !0, a = t.length - 1; a >= 1; --a)
      if (r = t.charCodeAt(a), r === 47) {
        if (!s) {
          i = a;
          break;
        }
      } else
        s = !1;
    return i === -1 ? n ? "/" : "." : n && i === 1 ? "//" : t.slice(0, i);
  },
  basename: function(t, r) {
    if (r !== void 0 && typeof r != "string")
      throw new TypeError('"ext" argument must be a string');
    zn(t);
    var n = 0, i = -1, s = !0, a;
    if (r !== void 0 && r.length > 0 && r.length <= t.length) {
      if (r.length === t.length && r === t)
        return "";
      var u = r.length - 1, c = -1;
      for (a = t.length - 1; a >= 0; --a) {
        var l = t.charCodeAt(a);
        if (l === 47) {
          if (!s) {
            n = a + 1;
            break;
          }
        } else
          c === -1 && (s = !1, c = a + 1), u >= 0 && (l === r.charCodeAt(u) ? --u === -1 && (i = a) : (u = -1, i = c));
      }
      return n === i ? i = c : i === -1 && (i = t.length), t.slice(n, i);
    } else {
      for (a = t.length - 1; a >= 0; --a)
        if (t.charCodeAt(a) === 47) {
          if (!s) {
            n = a + 1;
            break;
          }
        } else
          i === -1 && (s = !1, i = a + 1);
      return i === -1 ? "" : t.slice(n, i);
    }
  },
  extname: function(t) {
    zn(t);
    for (var r = -1, n = 0, i = -1, s = !0, a = 0, u = t.length - 1; u >= 0; --u) {
      var c = t.charCodeAt(u);
      if (c === 47) {
        if (!s) {
          n = u + 1;
          break;
        }
        continue;
      }
      i === -1 && (s = !1, i = u + 1), c === 46 ? r === -1 ? r = u : a !== 1 && (a = 1) : r !== -1 && (a = -1);
    }
    return r === -1 || i === -1 || // We saw a non-dot character immediately before the dot
    a === 0 || // The (right-most) trimmed path component is exactly '..'
    a === 1 && r === i - 1 && r === n + 1 ? "" : t.slice(r, i);
  },
  format: function(t) {
    if (t === null || typeof t != "object")
      throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof t);
    return IW("/", t);
  },
  parse: function(t) {
    zn(t);
    var r = { root: "", dir: "", base: "", ext: "", name: "" };
    if (t.length === 0)
      return r;
    var n = t.charCodeAt(0), i = n === 47, s;
    i ? (r.root = "/", s = 1) : s = 0;
    for (var a = -1, u = 0, c = -1, l = !0, d = t.length - 1, p = 0; d >= s; --d) {
      if (n = t.charCodeAt(d), n === 47) {
        if (!l) {
          u = d + 1;
          break;
        }
        continue;
      }
      c === -1 && (l = !1, c = d + 1), n === 46 ? a === -1 ? a = d : p !== 1 && (p = 1) : a !== -1 && (p = -1);
    }
    return a === -1 || c === -1 || // We saw a non-dot character immediately before the dot
    p === 0 || // The (right-most) trimmed path component is exactly '..'
    p === 1 && a === c - 1 && a === u + 1 ? c !== -1 && (u === 0 && i ? r.base = r.name = t.slice(1, c) : r.base = r.name = t.slice(u, c)) : (u === 0 && i ? (r.name = t.slice(1, a), r.base = t.slice(1, c)) : (r.name = t.slice(u, a), r.base = t.slice(u, c)), r.ext = t.slice(a, c)), u > 0 ? r.dir = t.slice(0, u - 1) : i && (r.dir = "/"), r;
  },
  sep: "/",
  delimiter: ":",
  win32: null,
  posix: null
};
Qa.posix = Qa;
var jW = Qa;
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
const kW = ["value", "error", "warning"];
var bs = Uu;
function Uu(e, t, r) {
  if (!(this instanceof Uu))
    return new Uu(e, t, r);
  (!t || !t.hasException) && (t = void 0), (!r || !r.hasException) && (r = void 0), t && (e = void 0), this.error = t, this.value = e, this.warning = r, this.__iterableIndex = -1;
}
Uu.prototype[Symbol.iterator] = function() {
  return this;
};
Uu.prototype.next = function() {
  return this.__iterableIndex++, this.__iterableIndex > 2 && (this.__iterableIndex = 0), {
    done: !1,
    value: this[kW[this.__iterableIndex]]
  };
};
const k0 = qn, MW = _O, Bu = jW, xf = bs, uS = Iu, cS = Qt, O$ = _r, NW = NO, DW = Wf, ng = /^https?:\/\//i, LW = /\.ya?ml$/i, qW = /\.json$/i;
var lS = bo;
const cc = /* @__PURE__ */ new WeakMap();
function bo(e) {
  this.$refs = {}, cc.set(this, {
    bundled: null,
    dereferenced: null,
    // will hold dereference() returned EnforcerResult
    loads: {},
    // a map of loaded resources
    refs: this.$refs,
    sourceMap: { "": [] },
    // a map of source paths to nodes within the source
    source: e
  });
}
bo.prototype.bundle = async function() {
  const e = cc.get(this);
  if (e.bundled) {
    const { value: s, error: a, warning: u } = e.bundled;
    return new xf(s, a, u);
  }
  const t = new k0("Unable to bundle definition for one or more reasons"), [r, n] = await this.dereference(), i = cS.copy(r);
  if (n)
    t.push(n);
  else {
    const s = ig(i, null, "", "#", []), a = Array.from(s.keys()).map((l) => {
      const d = s.get(l);
      return { node: l, refs: d };
    }).filter((l) => l.refs.length > 1), c = UW(i) === 2 ? ["definitions", "parameters", "responses", "securityDefinitions", "security", "tags", "externalDocs"] : ["components/schemas", "components/responses", "components/parameters", "components/examples", "components/requestBodies", "components/headers", "components/securitySchemes", "components/links", "components/callbacks", "components", "security", "servers", "tags", "externalDocs"];
    a.forEach((l) => {
      const d = l.refs;
      d.sort((p, h) => {
        const v = p.path, y = h.path;
        let g = c.findIndex((m) => v.startsWith("#/" + m)), _ = c.findIndex((m) => y.startsWith("#/" + m));
        return g === -1 && (g = Number.MAX_SAFE_INTEGER), _ === -1 && (_ = Number.MAX_SAFE_INTEGER), g < _ ? -1 : g > _ ? 1 : v.split("/").length < y.split("/").length ? -1 : 1;
      }), l.ref = d[0];
    }), a.sort((l, d) => l.ref.pathLength > d.ref.pathLength ? -1 : 1), a.forEach((l) => {
      const d = l.refs, p = d.length;
      for (let h = 1; h < p; h++) {
        const v = d[h];
        v.parent[v.key] = { $ref: l.ref.path };
      }
    });
  }
  return e.bundled = new xf(i, t), e.bundled;
};
bo.prototype.dereference = async function() {
  const e = cc.get(this);
  if (e.dereferenced) {
    const { value: s, error: a, warning: u } = e.dereferenced;
    return new xf(s, a, u);
  }
  const t = new k0("Unable to dereference definition for one or more reasons"), { source: r } = e, n = Me.process.cwd();
  let i;
  if (typeof r == "string") {
    const s = await dS(n, r, t, e);
    i = await za(Bu.dirname(s.path), s.path, s.value, s.value, e, /* @__PURE__ */ new Map(), [], t.at(s.path)), e.refs[s.path] = i;
  } else {
    const s = cS.copy(r);
    i = await za(n, "", s, s, e, /* @__PURE__ */ new Map(), [], t.at("root object")), e.refs[""] = i;
  }
  return e.dereferenced = new xf(i, t), e.dereferenced;
};
bo.prototype.getSourceNode = function(e) {
  const t = this.getSourcePath(e);
  return this.$refs[t];
};
bo.prototype.getSourcePath = function(e) {
  const t = cc.get(this);
  fS(t);
  const r = t.sourceMap, n = Object.keys(r), i = n.length;
  for (let s = 0; s < i; s++) {
    const a = n[s];
    if (r[a].includes(e))
      return a;
  }
};
bo.prototype.resolvePath = function(e, t) {
  const r = cc.get(this);
  fS(r);
  const n = new k0("Could not resolve path from node"), [i, s] = t.split("#");
  let a;
  if (!i)
    a = Of(e, s, n);
  else {
    const u = this.getSourcePath(e);
    if (!u)
      n.message("Unable to resolve source path for provided node.");
    else {
      const c = Bu.dirname(u), l = ng.test(c) ? uS.resolve(c, i) : Bu.resolve(c, i);
      this.$refs.hasOwnProperty(l) ? a = Of(this.$refs[l], s, n) : n.message("Unable to resolve paths that were not already resolved during dereference.");
    }
  }
  if (n.hasException)
    throw Error(n.toString());
  return a;
};
function FW() {
  const e = {};
  return e.promise = new Promise((t, r) => {
    e.resolve = t, e.reject = r;
  }), e;
}
function fS(e) {
  if (!e.dereferenced)
    throw Error("You must first call the dereference function before looking up node source.");
  if (e.dereferenced.error)
    throw Error("Cannot get source for a node when dereference has failed.");
}
function ig(e, t, r, n, i, s = /* @__PURE__ */ new Map()) {
  if (e && typeof e == "object") {
    if (i.includes(e))
      return;
    i = i.slice(), i.push(e);
    const a = {
      key: r,
      parent: t,
      path: n,
      pathLength: i.length
    }, u = s.get(e);
    if (u)
      return u.push(a), s;
    s.set(e, [a]), Array.isArray(e) ? e.forEach((c, l) => {
      ig(c, e, l, n + "/" + l, i, s);
    }) : Object.keys(e).forEach((c) => {
      ig(e[c], e, c, n + "/" + c.replace(/~/g, "~0").replace(/\//g, "~1"), i, s);
    });
  }
  return s;
}
function UW(e) {
  if (e) {
    if (e.swagger)
      return 2;
    if (e.openapi) {
      const t = e.openapi.split(".")[0];
      if (/^\d$/.test(t))
        return +t;
    }
  }
}
async function za(e, t, r, n, i, s, a, u) {
  if (Array.isArray(n)) {
    if (s.has(n))
      return s.get(n);
    s.set(n, n), i.sourceMap[t].push(n);
    const l = n.map(async (d, p) => {
      n[p] = await za(e, t, r, d, i, s, a, u.at(String(p)));
    });
    return await Promise.all(l), n;
  } else if (n && typeof n == "object")
    if (n.hasOwnProperty("$ref") && typeof n.$ref == "string") {
      if (a.includes(n)) {
        u.message("Unresolvable infinite loop");
        return;
      }
      const [, l] = n.$ref.split("#");
      let d = e, p = t, h = r, v;
      if (n.$ref.startsWith("#/"))
        v = Of(r, l, u);
      else {
        const y = await dS(e, n.$ref, u, i), g = u.at(y.path);
        p = y.path, d = Bu.dirname(p), h = await za(d, p, y.value, y.value, i, s, a, g), i.refs[y.path] = h, v = h ? Of(h, l, g) : void 0;
      }
      return v = await za(d, p, h, v, i, s, a.concat([n]), u), v;
    } else {
      const c = s.get(n);
      if (c)
        return c;
      s.set(n, n), i.sourceMap[t].push(n);
      const l = Object.keys(n).map(async (d) => {
        n[d] = await za(e, t, r, n[d], i, s, a, u.at(d));
      });
      return await Promise.all(l), n;
    }
  else
    return n;
}
async function dS(e, t, r, n) {
  const { loads: i, sourceMap: s } = n, { loadPath: a, loadMethod: u } = ZW(e, t);
  if (i[a])
    return i[a];
  const c = FW();
  i[a] = c.promise;
  const l = await u(a, r.at(a));
  return s[a] = [], c.resolve({
    path: a,
    value: l
  }), c.promise;
}
function BW(e, t) {
  return new Promise((r, n) => {
    const s = (e.startsWith("https") ? NW : DW).request(e, {}, (a) => {
      if (a.statusCode < 200 || a.statusCode >= 300)
        t.message("Request failed with status code " + a.statusCode), r();
      else {
        const u = a.headers["content-type"];
        let c;
        /^application\/json/.test(u) && (c = "json"), /^(?:text|application)\/(?:x-)?yaml/.test(u) && (c = "yaml");
        let l = "";
        a.setEncoding("utf8"), a.on("data", (d) => {
          l += d;
        }), a.on("end", () => {
          const d = pS(l, c, t.nest("Unable to parse resource: " + e));
          r(d.value);
        }), a.on("error", (d) => {
          t.message("Unexpected error: " + d.message), r();
        });
      }
    });
    s.on("error", n), s.end();
  });
}
function VW(e, t) {
  return new Promise((r) => {
    MW.readFile(e, "utf8", (n, i) => {
      if (n && (n.code === "ENOENT" || n.code === "ENOTDIR"))
        t.message("Unable to find referenced file: " + e), r();
      else if (n)
        t.message('Unable to read file "' + e + '": ' + n.toString()), r();
      else {
        let s;
        qW.test(e) && (s = "json"), LW.test(e) && (s = "yaml");
        const a = pS(i, s, t.nest("Unable to parse file: " + e));
        r(a.value);
      }
    });
  });
}
function pS(e, t, r) {
  let n;
  if (t === "json")
    try {
      n = JSON.parse(e);
    } catch (i) {
      r.message(i.toString());
    }
  else if (t === "yaml")
    try {
      n = O$.load(e);
    } catch (i) {
      r.message(i.toString());
    }
  else
    try {
      n = JSON.parse(e), t = "json";
    } catch {
      try {
        n = O$.load(e), t = "yaml";
      } catch {
        r.message("Not valid JSON or YAML");
      }
    }
  return {
    type: t,
    value: n
  };
}
function ZW(e, t) {
  const [r] = t.split("#");
  return ng.test(e) || ng.test(t) ? {
    loadPath: uS.resolve(e, r),
    loadMethod: BW
  } : {
    loadPath: Bu.resolve(e, r),
    loadMethod: VW
  };
}
function Of(e, t, r) {
  if (!t)
    return e;
  if (!t.startsWith("/")) {
    r.message("References must start with #/");
    return;
  }
  const n = t.substring(1).split("/");
  let i = e;
  for (; n.length; ) {
    const s = n.shift().replace(/~1/g, "/").replace(/~0/g, "~");
    if (s !== "#")
      if (i && typeof i == "object" && s in i)
        i = i[s];
      else {
        r.message("Cannot resolve reference: #" + t);
        return;
      }
  }
  return i;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var sr = Vu;
function Vu(e, t) {
  if (!(this instanceof Vu))
    return new Vu(e, t);
  this.config = t, this.value = e;
}
Vu.isEnforcerRef = function(e) {
  return typeof e == "object" && e instanceof Vu;
};
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
const Vl = sr, rs = Qt, zW = /^x-.+/;
var WW = Pf;
function au(e, t, r) {
  const n = e.definition[t], i = !e.production, s = rs.getDefinitionType(n);
  let a;
  return s === "array" ? a = [] : s === "object" ? a = {} : a = n, {
    context: e.context,
    definition: n,
    definitionType: s,
    defToInstanceMap: e.defToInstanceMap,
    exception: i ? e.exception.at(t) : e.exception,
    key: t,
    major: e.major,
    map: e.map,
    minor: e.minor,
    options: e.options,
    parent: e,
    patch: e.patch,
    plugins: e.plugins,
    production: e.production,
    refParser: e.refParser,
    result: a,
    root: e.root,
    staticData: null,
    usedDefault: !1,
    validator: r,
    warn: i ? e.warn.at(t) : e.warn
  };
}
function Pf(e, t, r) {
  const { definitionType: n, exception: i, production: s, result: a } = e, u = r.exceptionSkipCodes;
  let c = e.definition;
  try {
    const l = kr(e.validator, e), d = l.freeForm;
    if (!hS(n, e))
      return;
    if (c && typeof c == "object") {
      const h = HW(e);
      if (h)
        return h.value;
      Qo(e, a);
    }
    if (s)
      n === "array" ? (c.forEach((h, v) => {
        const y = au(e, v, l.items);
        a.push(eu(y, t, r));
      }), Object.freeze(a)) : n === "object" ? (Object.keys(c).forEach((v) => {
        let y;
        typeof l != "object" ? y = l : l.properties && l.properties.hasOwnProperty(v) ? y = l.properties[v] : l.additionalProperties && (y = l.additionalProperties);
        const g = au(e, v, y);
        Object.defineProperty(a, v, {
          configurable: !0,
          enumerable: !0,
          value: eu(g, t, r)
        });
      }), P$(l, e).forEach(({ data: v }) => {
        const y = v.key;
        if (!a.hasOwnProperty(y)) {
          const g = v.validator, _ = Vl.isEnforcerRef(g) ? g.config || {} : g;
          if ((_.hasOwnProperty("allowed") ? kr(_.allowed, v) : !0) && _.hasOwnProperty("default")) {
            const w = kr(_.default, v);
            Object.defineProperty(a, y, {
              configurable: !0,
              enumerable: !0,
              value: w
            });
          }
        }
      })) : (e.result = c, Qo(e, c));
    else {
      if (l.enum) {
        const h = kr(l.enum, e);
        h.includes(c) || (h.length === 1 ? i.message("Value must be " + rs.smart(h[0]) + ". Received: " + rs.smart(c)) : i.message("Value must be one of: " + h.join(", ") + ". Received: " + rs.smart(c)));
      }
      if (n === "array" && !d)
        c.forEach((h, v) => {
          const y = au(e, v, l.items);
          a.push(eu(y, t, r));
        }), Object.freeze(a);
      else if (n === "object" && !d) {
        const h = [], v = [], y = [];
        l === !0 ? Object.keys(c).forEach((g) => {
          Object.defineProperty(a, g, {
            configurable: !0,
            enumerable: !0,
            value: c[g]
          });
        }) : l === !1 ? v.push.apply(v, Object.keys(c)) : l.additionalProperties ? Object.keys(c).forEach((g) => {
          const _ = au(e, g, l.additionalProperties), m = Vl.isEnforcerRef(_.validator) ? _.validator.config || {} : _.validator, w = m.hasOwnProperty("allowed") ? kr(m.allowed, _) : !0;
          let $ = !1;
          if (_.definition !== void 0 && (w ? (!m.ignored || !kr(m.ignored, _)) && (Object.defineProperty(a, g, {
            configurable: !0,
            enumerable: !0,
            value: eu(_, t, r)
          }), $ = !0) : v.push(g)), $ && m.errors && m !== _.validator) {
            const E = Object.assign({}, _);
            E.definition = a[g], kr(m.errors, E);
          }
        }) : (Object.keys(c).forEach((_) => {
          zW.test(_) ? Object.defineProperty(a, _, {
            configurable: !0,
            enumerable: !0,
            value: c[_]
          }) : y.push(_);
        }), P$(l, e).forEach((_) => {
          const m = _.data, w = m.key, $ = m.validator, E = Vl.isEnforcerRef($) ? $.config || {} : $, A = E.hasOwnProperty("allowed") ? kr(E.allowed, m) : !0;
          if (rs.arrayRemoveItem(y, w), m.definition === void 0 && A && E.hasOwnProperty("default")) {
            const R = kr(E.default, m);
            R !== void 0 && (m.definition = R, m.usedDefault = !0, m.parent.definition[w] = m.definition, m.definitionType = rs.getDefinitionType(m.definition));
          }
          m.definition !== void 0 ? A ? (!E.ignored || !kr(E.ignored, m)) && Object.defineProperty(a, w, {
            configurable: !0,
            enumerable: !0,
            value: eu(m, t, r)
          }) : v.push(w) : A && E.required && kr(E.required, m) && h.push(w);
        })), v.push.apply(v, y), v.length && !u.EDEV001 && !rs.schemaObjectHasSkipCode(c, "EDEV001") && (v.sort(), i.message("Propert" + (v.length === 1 ? "y" : "ies") + " not allowed: " + v.join(", ") + " [EDEV001]")), h.length && (h.sort(), i.message("Missing required propert" + (h.length === 1 ? "y" : "ies") + ": " + h.join(", ")));
      } else if (d)
        e.result = c, Qo(e, c);
      else
        switch (n) {
          case "boolean":
          case "null":
          case "number":
          case "string":
            e.result = c, Qo(e, c);
            break;
          default:
            i.message("Unknown data type provided");
            break;
        }
    }
    let p = e.definition;
    if (l.deserialize) {
      const h = Object.assign({}, e);
      p = l.deserialize(h), e.result = p, Qo(e, c);
    }
    if (!s && l.errors) {
      const h = Object.assign({}, e);
      h.definition = p, kr(l.errors, h);
    }
  } catch (l) {
    i.message("Unexpected error encountered: " + l.stack);
  }
  return e.result;
}
Pf.isValidatorState = function(e) {
  return e instanceof mS;
};
function Xo(e) {
  return e === "array" ? "an array" : e === "object" ? "a plain object" : "a " + e;
}
function kr(e, t) {
  if (typeof e == "function")
    try {
      return e(t);
    } catch (r) {
      t.exception.message("Unexpected error encountered: " + r.stack);
    }
  else
    return e;
}
function P$(e, t) {
  const r = Object.keys(e.properties || {}).map((n) => {
    const i = e.properties[n];
    return {
      data: au(t, n, i),
      weight: i.weight || 0
    };
  });
  return r.sort((n, i) => n.weight < i.weight ? -1 : n.weight > i.weight ? 1 : n.data.key < i.data.key ? -1 : 1), r;
}
function HW(e) {
  const { definition: t, map: r, validator: n } = e, i = r.get(t);
  if (!i)
    return;
  let s = i.find((a) => a.validator === n);
  return s ? s.value : void 0;
}
function Qo(e, t) {
  const { definition: r, map: n, validator: i } = e;
  let s = n.get(r);
  s || (s = [], n.set(r, s));
  const a = s.find((u) => u.validator === i);
  a ? a.value = t : s.push({ validator: i, value: t });
}
function eu(e, t, r) {
  const n = kr(e.validator, e);
  if (e.validator = n, Vl.isEnforcerRef(n)) {
    const i = e.validator.config;
    if (e.definitionType === "boolean")
      return e.validator = e.validator.config, Pf(e, t, r);
    if (!i || hS(e.definitionType, Object.assign({}, e, { validator: i })))
      return new e.context[n.value](new mS(e), t, r);
  } else
    return e.validator ? Pf(e, t, r) : e.result;
}
function hS(e, t) {
  const { definition: r, exception: n } = t, i = kr(t.validator, t);
  if (!t.production && i.type && r !== void 0) {
    let s = kr(i.type, t);
    if (Array.isArray(s) || (s = [s]), s = s.map((c) => c === "integer" ? "number" : c), s.includes("any") || s.includes(e))
      return !0;
    const a = s.length;
    let u;
    if (a === 1)
      u = Xo(s[0]);
    else if (a === 2)
      u = Xo(s[0]) + " or " + Xo(s[1]);
    else {
      const c = s.pop();
      u = s.map((l) => Xo(l)).join(", ") + ", or " + Xo(c);
    }
    return n.message("Value must be " + u + ". Received: " + rs.smart(r)), !1;
  } else
    return !0;
}
function mS(e) {
  Object.assign(this, e);
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var GW = KW;
const nm = WW, S$ = qn, A$ = bs, gl = Qt, C$ = { post: !0, put: !0, options: !0, head: !0, patch: !0 };
function KW(e, t, r) {
  return r || (r = yE("./enforcers/" + t)), YW(e, t, r);
}
function YW(e, t, r) {
  const n = [], i = /* @__PURE__ */ new WeakMap(), s = new Function(
    "build",
    `const F = function ${t} (definition, refParser, options) {
            if (!(this instanceof F)) return new F(definition, refParser, options)
            return build(this, definition, refParser, options)
        }
        return F`
  )(u);
  s.prototype = Object.assign({}, r.prototype || {}), s.constructor = s, Object.defineProperty(s, "enforcerDefinition", {
    value: r
  }), Object.defineProperty(s.prototype, "enforcerData", {
    get: function() {
      return i.get(this);
    }
  }), s.prototype.toObject = function() {
    return c(this, /* @__PURE__ */ new Map());
  }, s.extend = function(l) {
    if (typeof l != "function")
      throw Error("Invalid input. Callback must be a function. Received: " + l);
    n.push(l);
  };
  const a = {};
  if (r.statics) {
    const l = r.statics(a);
    Object.keys(l).forEach((d) => {
      s[d] = l[d];
    });
  }
  function u(l, d, p, h = {}) {
    const v = !nm.isValidatorState(d);
    h || (h = {}), v && (h = Object.assign({}, h)), h.requestBodyAllowedMethods = h.hasOwnProperty("requestBodyAllowedMethods") ? Object.assign({}, C$, h.requestBodyAllowedMethods) : C$, h.disablePathNormalization = h.hasOwnProperty("disablePathNormalization") ? !!h.disablePathNormalization : !1, h.apiSuggestions = h.hasOwnProperty("apiSuggestions") ? !!h.apiSuggestions : !0, h.production = !!h.production, h.exceptionSkipCodes = h.hasOwnProperty("exceptionSkipCodes") ? Array.isArray(h.exceptionSkipCodes) ? h.exceptionSkipCodes.reduce((m, w) => (m[w] = !0, m), {}) : h.exceptionSkipCodes : {}, h.exceptionEscalateCodes = h.hasOwnProperty("exceptionEscalateCodes") ? Array.isArray(h.exceptionEscalateCodes) ? h.exceptionEscalateCodes.reduce((m, w) => (m[w] = !0, m), {}) : h.exceptionEscalateCodes : {};
    let y;
    if (v) {
      const m = /^(\d+)(?:\.(\d+))(?:\.(\d+))?$/.exec(e.version);
      p || (d = gl.copy(d)), y = {
        context: e,
        definition: d,
        defToInstanceMap: /* @__PURE__ */ new WeakMap(),
        definitionType: gl.getDefinitionType(d),
        exception: S$("One or more errors exist in the " + t + " definition"),
        key: void 0,
        map: /* @__PURE__ */ new Map(),
        major: +m[1],
        minor: +m[2],
        parent: null,
        patch: +(m[3] || 0),
        plugins: [],
        production: h.production,
        refParser: p,
        result: l,
        staticData: a,
        validator: r.validator,
        warn: S$("One or more warnings exist in the " + t + " definition"),
        options: h
      }, y.root = y;
    } else
      y = d, y.staticData = a, y.validator = r.validator, y.result = l;
    const g = y.map.get(y.definition), _ = g ? g.find((m) => m.validator === y.validator) : void 0;
    if (_)
      y.result = l = _.value, nm(y, p, h);
    else {
      if (i.set(l, y), y.definition && typeof y.definition == "object" && y.defToInstanceMap.set(y.definition, l), gl.isPlainObject(y.definition) ? nm(y, p, h) : y.exception.message("Value must be a plain object"), y.exception.hasException && v)
        return new A$(void 0, y.exception, y.warn);
      r.init && r.init.call(l, y);
      const m = y.plugins;
      n.forEach((w) => m.push(function() {
        w.call(l, {
          enforcers: e,
          exception: y.exception,
          key: y.key,
          major: y.major,
          minor: y.minor,
          parent: y.parent && y.parent.result || null,
          patch: y.patch,
          root: y.root.result,
          warn: y.warn
        });
      }));
    }
    if (v)
      for (; y.plugins.length; )
        y.plugins.shift()();
    return v ? new A$(l, y.exception, y.warn) : l;
  }
  function c(l, d) {
    if (Array.isArray(l)) {
      const p = d.get(l);
      if (p)
        return p;
      const h = [];
      return d.set(l, h), l.forEach((v) => {
        h.push(c(v, d));
      }), h;
    } else if (gl.isPlainObject(l)) {
      const p = d.get(l);
      if (p)
        return p;
      const h = {};
      return d.set(l, h), Object.keys(l).forEach((v) => {
        h[v] = c(l[v], d);
      }), h;
    } else
      return l;
  }
  return s;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var im, R$;
function T$() {
  return R$ || (R$ = 1, im = {
    init: function(e) {
    },
    prototype: {},
    validator: function() {
      return {
        type: "object",
        properties: {
          name: {
            type: "string"
          },
          url: {
            type: "string"
          },
          email: {
            type: "string"
          }
        }
      };
    }
  }), im;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var sm, I$;
function j$() {
  return I$ || (I$ = 1, sm = {
    init: function(e) {
    },
    prototype: {},
    validator: function(e) {
      return {
        type: "object",
        properties: {
          description: "string",
          url: {
            type: "string",
            required: !0
          }
        }
      };
    }
  }), sm;
}
var vl = {};
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var k$;
function yS() {
  if (k$)
    return vl;
  k$ = 1;
  const e = sr, t = [
    "default",
    "enum",
    "exclusiveMaximum",
    "exclusiveMinimum",
    "format",
    "items",
    "maximum",
    "maxItems",
    "maxLength",
    "minimum",
    "minItems",
    "minLength",
    "multipleOf",
    "pattern",
    "type",
    "uniqueItems"
  ];
  vl.extractSchemaDefinition = r, vl.validator = (n) => {
    const { major: i } = n, s = {
      type: "object"
    };
    return i === 2 ? (s.properties = {}, Object.assign(s.properties, {
      type: {
        weight: -15,
        required: !0,
        enum: ["array", "boolean", "integer", "number", "string"]
      },
      collectionFormat: {
        allowed: ({ parent: a }) => a.definition.type === "array",
        enum: ["csv", "ssv", "tsv", "pipes"],
        default: "csv"
      },
      default: { allowed: !0 },
      description: {
        type: "string"
      },
      enum: {
        allowed: !0,
        type: "array",
        items: { freeForm: !0 }
      },
      exclusiveMaximum: { allowed: !0 },
      exclusiveMinimum: { allowed: !0 },
      format: { allowed: !0 },
      items: {
        type: "object",
        allowed: ({ parent: a }) => a.definition.type === "array",
        required: ({ parent: a }) => a.definition.type === "array",
        properties: s.properties,
        errors: s.errors
      },
      maximum: { allowed: !0 },
      maxItems: { allowed: !0 },
      maxLength: { allowed: !0 },
      minimum: { allowed: !0 },
      minItems: { allowed: !0 },
      minLength: { allowed: !0 },
      multipleOf: { allowed: !0 },
      pattern: { allowed: !0 },
      uniqueItems: { allowed: !0 }
    }), s.errors = () => {
    }) : i === 3 && (s.properties = {
      content: {
        type: "object",
        additionalProperties: e("MediaType"),
        errors: ({ exception: a, definition: u }) => {
          const c = Object.keys(u);
          c.length !== 1 && a.message("Value must have exactly one key. Received: " + c.join(", "));
        }
      },
      deprecated: {
        type: "boolean"
      },
      description: {
        type: "string"
      },
      example: { allowed: !0, freeForm: !0 },
      examples: {
        type: "object",
        additionalProperties: e("Example")
      },
      schema: e("Schema")
    }, s.errors = ({ exception: a, major: u, definition: c }) => {
      c.hasOwnProperty("content") && c.hasOwnProperty("schema") ? a.message('Cannot have both "content" and "schema" properties') : !c.hasOwnProperty("content") && !c.hasOwnProperty("schema") && a.message('Missing required property "content" or "schema"'), c.hasOwnProperty("example") && c.hasOwnProperty("examples") && a.message('Cannot have both "example" and "examples" properties');
    }), s;
  };
  function r(n, i) {
    return t.forEach((s) => {
      if (i.hasOwnProperty(s)) {
        const a = i[s];
        switch (s) {
          case "items":
            n[s] = r({}, a);
            break;
          default:
            n[s] = a;
            break;
        }
      }
    }), n;
  }
  return vl;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var am, M$;
function N$() {
  if (M$)
    return am;
  M$ = 1;
  const e = yS(), t = qn, r = bs, n = Qt;
  am = {
    init: function(a) {
      const { context: u, exception: c, major: l, warn: d, options: p } = a;
      if (l === 2) {
        const h = e.extractSchemaDefinition({}, this), [v, y, g] = u.Schema(h);
        v && (this.schema = v), y && c.merge(y), g && d.merge(g);
      }
      n.validateExamples(this, c, d, p);
    },
    prototype: {
      stringify: function(a) {
        const { major: u } = this.enforcerData, c = this.schema, l = t("Unable to stringify value");
        if (u === 2)
          return new r(s(this, this, l, a), l);
        if (u === 3) {
          const d = c && c.type;
          let p;
          if (d === "array")
            p = a.map((h, v) => i(this, c.items, l.at(v), h)).join(",");
          else if (d === "object") {
            const h = [];
            Object.keys(a).forEach((v) => {
              const y = c.properties.hasOwnProperty(v) ? c.properties[v] : c.additionalProperties;
              let g = a[v];
              y !== !0 ? g = i(this, y, l.at(v), g) : typeof g != "string" && l.message("Unable to stringify value: " + n.smart(g)), typeof g == "string" && (this.explode ? h.push(v + "=" + g) : h.push(v, g));
            }), p = h.join(",");
          } else
            p = i(this, c, l, a);
          return new r(p, l);
        }
      }
    },
    validator: function(a) {
      const { major: u } = a, c = e.validator(a);
      return Object.assign(c.properties, {
        explode: {
          type: "boolean",
          default: !1
        },
        required: {
          type: "boolean",
          default: !1
        },
        style: {
          weight: -5,
          allowed: u === 3,
          type: "string",
          default: "simple",
          enum: ["simple"]
        }
      }), c;
    }
  };
  function i(a, u, c, l) {
    if (l === void 0) {
      if (a.allowEmptyValue)
        return "";
      c.message("Empty value not allowed");
    } else if (l === null) {
      if (u.nullable)
        return "null";
      c.message("Null value not allowed");
    } else if (u.type === "boolean") {
      if (l === !0)
        return "true";
      if (l === !1)
        return "false";
      c.message("Expected true or false. Received: " + n.smart(l));
    } else if (u.type === "integer" || u.type === "number") {
      if (typeof l == "number" && !isNaN(l))
        return String(l);
      const d = u.type === "integer" ? "an integer" : "a number";
      c.message("Expected " + d + ". Received: " + n.smart(l));
    } else {
      if (u.type === "string")
        return l;
      c.message("Unable to stringify value: " + n.smart(l));
    }
  }
  function s(a, u, c, l) {
    if (u.type === "array") {
      const d = l.map((p, h) => u.items ? s(a, u.items, c.at(h), p) : p);
      switch (u.collectionFormat) {
        case "csv":
          return d.join(",");
        case "pipes":
          return d.join("|");
        case "ssv":
          return d.join(" ");
        case "tsv":
          return d.join("	");
      }
    } else
      return i(a, u, c, l);
  }
  return am;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var om, D$;
function L$() {
  if (D$)
    return om;
  D$ = 1;
  const e = sr;
  return om = {
    init: function(t) {
    },
    prototype: {},
    validator: function() {
      return {
        type: "object",
        properties: {
          title: {
            required: !0,
            type: "string"
          },
          description: {
            type: "string"
          },
          termsOfService: {
            type: "string"
          },
          contact: e("Contact"),
          license: e("License"),
          version: {
            required: !0,
            type: "string"
          }
        }
      };
    }
  }, om;
}
var um = { exports: {} };
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var q$;
function F$() {
  return q$ || (q$ = 1, function(e) {
    e.exports = {
      init: function(t) {
      },
      prototype: {},
      validator: function(t) {
        return {
          type: "object",
          properties: {
            name: {
              required: !0,
              type: "string"
            },
            url: {
              type: "string"
            }
          },
          errors: function(r) {
            e.exports, r.validator;
          }
        };
      }
    };
  }(um)), um.exports;
}
var cm = { exports: {} };
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var lm, U$;
function _s() {
  if (U$)
    return lm;
  U$ = 1;
  const { isPlainObject: e } = Qt;
  lm = i;
  const t = !0, r = !0, n = !0;
  function i(a, u = {}) {
    if (!(this instanceof i))
      return new i(a, u);
    if (typeof a == "object" && a instanceof i && (u = {
      populate: u.populate === void 0 ? a.populate : u.populate,
      serialize: u.serialize === void 0 ? a.serialize : u.serialize,
      validate: u.validate === void 0 ? a.validate : u.validate
    }, a = a.value), !u || typeof u != "object")
      throw Error("Invalid enforcer value configuration");
    const { populate: c, serialize: l, validate: d } = u;
    this.populate = c, this.serialize = l, this.validate = d, this.value = a;
  }
  i.prototype.attributes = function() {
    return {
      populate: this.populate === void 0 ? t : this.populate,
      serialize: this.serialize === void 0 ? r : this.serialize,
      validate: this.validate === void 0 ? n : this.validate,
      value: this.value
    };
  }, i.inherit = function(a, u) {
    return typeof a == "object" && a instanceof i ? (a.populate === void 0 && u.populate !== void 0 && (a.populate = u.populate), a.serialize === void 0 && u.serialize !== void 0 && (a.serialize = u.serialize), a.validate === void 0 && u.validate !== void 0 && (a.validate = u.validate), a) : new i(a, u);
  }, i.extract = s, i.getAttributes = function(a) {
    return typeof a == "object" && a instanceof i ? a.attributes() : {
      populate: t,
      serialize: r,
      validate: n,
      value: a
    };
  };
  function s(a) {
    if (Array.isArray(a))
      return a.map((u) => s(u));
    if (e(a)) {
      const u = {};
      return Object.keys(a).forEach((c) => {
        u[c] = s(a[c]);
      }), u;
    } else
      return typeof a == "object" && a instanceof i ? a.value : a;
  }
  return lm;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var B$;
function Sf() {
  return B$ || (B$ = 1, function(e) {
    const t = sr, r = qn, n = bs, i = Qt, s = _s(), a = ["body", "headers", "method", "path", "query"], u = /^\d+$/, c = /^\d+(?:\.\d+)?$/;
    e.exports = {
      init: function(y) {
        const { major: g, parent: _, plugins: m, root: w } = y;
        m.push(() => {
          this.parameters || (this.parameters = []), this.parametersMap = {}, _ && _.result && _.result.parameters && l(this.parametersMap, _.result.parameters), l(this.parametersMap, this.parameters), this.allParameters = [], Object.keys(this.parametersMap).forEach(($) => {
            const E = this.parametersMap[$];
            Object.keys(E).forEach((A) => {
              this.allParameters.push(E[A]);
            });
          }), g === 2 && !this.produces && w.result.produces && (this.produces = w.result.produces);
        });
      },
      prototype: {
        /**
         * The the possible response mime types for the response code and accepts string.
         * @param {string, number} code
         * @param {string} accepts The allowed media type string. Example: text/html, application/xhtml+xml, application/xml;q=0.9, text/*;q=0.8
         * @returns {EnforcerResult<string[]>}
         */
        getResponseContentTypeMatches: function(y, g) {
          const _ = new r("Unable to determine acceptable response content types"), m = this.responses[y] || this.responses.default;
          let w;
          return m ? this.produces ? (w = i.findMediaMatch(g, this.produces), w.length || (_.message("Operation does not produce acceptable type"), _.code = "NO_MATCH")) : m.content ? (w = i.findMediaMatch(g, Object.keys(m.content)), w.length || (_.message("Operation does not produce acceptable type"), _.code = "NO_MATCH")) : (_.message("Response mime types not defined"), _.code = "NO_TYPES_SPECIFIED") : (_.message("Invalid response code"), _.code = "NO_CODE"), new n(w, _);
        },
        /**
         * Take the input parameters and deserialize and validate them.
         * @param {object} request
         * @param {string|object} [request.body] The request body
         * @param {Object<string,string>} [request.headers={}] The request headers
         * @param {object} [request.path={}] The path and query string
         * @param {string} [request.query=''] The request query string.
         * @param {object} [options]
         * @param {boolean,string[]} [options.allowOtherQueryParameters=false] Allow query parameter data that is not specified in the OAS document
         * @param {boolean} [options.pathParametersProcessed=false] Set to true if the path parameters have already been parsed, deserialized, and validated
         */
        request: function(y, g) {
          if (g || (g = {}), g && typeof g != "object")
            throw Error("Invalid options. Expected an object. Received: " + g);
          if (g = Object.assign({}, g), g.hasOwnProperty("allowOtherQueryParameters") || (g.allowOtherQueryParameters = !1), g.allowOtherQueryParameters) {
            if (Array.isArray(g.allowOtherQueryParameters))
              g.allowOtherQueryParameters.length === 0 ? g.allowOtherQueryParameters = !1 : g.allowOtherQueryParameters.forEach((I) => {
                if (typeof I != "string")
                  throw Error("Invalid option allowOtherQueryParameters. The value must be a boolean or an array of strings.");
              });
            else if (typeof g.allowOtherQueryParameters != "boolean")
              throw Error("Invalid option allowOtherQueryParameters. The value must be a boolean or an array of strings.");
          }
          if (!y || typeof y != "object")
            throw Error("Invalid request. Expected a non-null object. Received: " + y);
          if (y = this.toRequestObject(y), y.hasOwnProperty("headers") || (y.headers = {}), y.hasOwnProperty("path") || (y.path = {}), y.hasOwnProperty("query") || (y.query = ""), !i.isObjectStringMap(y.headers))
            throw Error("Invalid request headers. Expected an object with string keys and string values");
          if (!g.pathParametersProcessed && !i.isObjectStringMap(y.path))
            throw Error("Invalid request path. Expected an object with string keys and string values");
          if (typeof y.query != "string")
            throw Error("Invalid request query. Expected a string");
          const _ = {
            header: i.lowerCaseObjectProperties(y.headers),
            path: y.path,
            query: i.parseQueryString(decodeURI(y.query))
          };
          y.body !== void 0 && (_.body = y.body);
          const m = _.header.cookie || "", w = y.query;
          _.cookie = m ? i.parseCookieString(m) : {}, delete _.header.cookie;
          const $ = r("Request has one or more errors");
          $.statusCode = 400;
          const E = this.parametersMap, A = {
            cookie: {},
            headers: {},
            path: y.path,
            query: {}
          };
          if (E.formData && (!y.body || typeof y.body != "object"))
            throw Error('Parameters in "formData" require that the provided body be a non-null object');
          if (g.pathParametersProcessed) {
            const I = [];
            if (Object.keys(y.path).forEach((D) => {
              E.path.hasOwnProperty(D) || I.push(D);
            }), I.length) {
              const D = "Received unexpected parameter" + (I.length === 1 ? "" : "s") + ": " + I.join(", ");
              $.nest("In path parameters").message(D);
            }
          }
          const R = ["cookie", "header", "query"];
          if (g.pathParametersProcessed || R.push("path"), E.formData && R.push("formData"), R.forEach((I) => {
            const D = I === "formData", J = D ? $.nest("In body") : $.nest("In " + I + " parameters"), ae = D ? "body" : I, ye = _[ae] || {}, xe = [], je = [], re = (() => {
              if (I === "cookie" || I === "header")
                return [];
              const fe = Object.keys(ye);
              if (I === "query") {
                const le = g.allowOtherQueryParameters;
                return Array.isArray(le) ? fe.filter(($e) => !le.includes($e)) : le ? [] : fe;
              }
              return fe;
            })();
            if (E[I]) {
              const fe = {};
              Object.keys(E[I]).forEach((le) => {
                const $e = E[I][le], Ae = $e.schema && $e.schema.type;
                if (ye.hasOwnProperty(le)) {
                  i.arrayRemoveItem(re, le);
                  const _e = I === "query" ? $e.parse(w, ye) : I === "cookie" ? $e.parse(m, ye) : $e.parse(ye[le]);
                  p(J.at(le), $e.schema, _e, "", (ie) => fe[le] = ie);
                } else if ($e.in === "query" && $e.style === "form" && $e.explode && Ae === "object") {
                  const _e = $e.parse(w, ye);
                  if (_e.error) {
                    const ie = new r("In " + I + ' parameter "' + le + '"');
                    ie.message(_e.error), je.push(ie);
                  } else
                    p(J.at(le), $e.schema, _e, "", (ie) => {
                      Object.keys(ie).forEach((K) => i.arrayRemoveItem(re, K)), fe[le] = ie;
                    });
                } else if ($e.in === "query" && $e.style === "deepObject" && Ae === "object") {
                  const _e = $e.parse(w, ye);
                  if (_e.error) {
                    const ie = new r("In " + I + ' parameter "' + le + '"');
                    ie.push(_e.error), je.push(ie);
                  } else
                    p(J.at(le), $e.schema, _e, "", (ie) => {
                      Object.keys(ie).forEach((K) => i.arrayRemoveItem(re, le + "[" + K + "]")), fe[le] = ie;
                    });
                } else
                  $e.required && xe.push(le);
                !fe.hasOwnProperty(le) && $e.schema.hasOwnProperty("default") && (fe[le] = i.copy($e.schema.default));
              }), A[ae === "header" ? "headers" : ae] = s.extract(fe);
            }
            if (re.length) {
              const fe = "Received unexpected parameter" + (re.length === 1 ? "" : "s") + ": " + re.join(", ");
              if (je.length) {
                const le = J.nest(fe).nest("Possible causes");
                je.forEach(($e) => le.push($e));
              } else
                J.message(fe);
            }
            xe.length && J.message("Missing required parameter" + (xe.length > 1 ? "s" : "") + ": " + xe.join(", "));
          }), _.hasOwnProperty("body")) {
            let I = _.body;
            if (E.body) {
              const D = d(E);
              I = v(I, D.schema), p($.nest("In body"), D.schema, { value: I }, "write", (J) => {
                A.body = s.extract(J);
              });
            } else if (this.requestBody) {
              const { content: D, contentType: J, matches: ae } = h(this, _), ye = ae.length;
              if (ye) {
                const xe = new r("In body");
                let je = !1;
                for (let re = 0; re < ye; re++) {
                  const fe = ae[re], le = D[fe];
                  if (le.schema && (I = v(I, le.schema), p(xe.nest("For Content-Type " + fe), le.schema, { value: I }, "write", ($e) => {
                    A.body = s.extract($e), je = !0;
                  })), J === fe || je)
                    break;
                }
                je || $.push(xe);
              } else
                $.message("Content-Type not accepted"), $.statusCode = 415;
            } else
              E.formData || $.message("Body is not allowed");
          } else if (E.body && d(E).required)
            $.message("Missing required parameter: body");
          else if (this.requestBody && this.requestBody.required)
            $.message("Missing required request body");
          else {
            let I;
            if (E.body)
              I = d(E).schema;
            else if (this.requestBody) {
              const { content: D, matches: J } = h(this, _), ae = J.length;
              for (let ye = 0; ye < ae; ye++) {
                const xe = J[ye], je = D[xe].schema;
                if (je && je.hasOwnProperty("default")) {
                  I = je;
                  break;
                }
              }
            }
            I && I.hasOwnProperty("default") && (A.body = i.copy(I.default));
          }
          return new n(A, $);
        },
        response: function(y, g, _ = {}) {
          const m = new r("Response invalid"), w = new r("Response has one or more warnings"), $ = g !== void 0, E = (() => {
            const ae = String(y)[0];
            return this.responses[y] || this.responses[ae + "XX"] || this.responses.default;
          })(), A = { headers: {} }, R = this.enforcerData.major, I = this.enforcerData.options.exceptionSkipCodes, D = this.enforcerData.options.exceptionEscalateCodes;
          if (!i.isPlainObject(_) && i.isObject(_) && (_ = Object.create({}, _)), !i.isObject(_))
            throw Error("Invalid headers input parameter. Must be a plain object");
          if (_ = i.lowerCaseObjectProperties(_), E) {
            if ($) {
              if (R === 2) {
                const ae = E.schema;
                if (!ae)
                  A.body = g;
                else if (ae.type === "file")
                  A.schema = ae, A.body = g;
                else {
                  g = ae.formalize(g);
                  let ye = ae.validate(g, { readWriteMode: "read" });
                  ye || ([g, ye] = ae.serialize(g)), ye ? m.at("body").merge(ye) : (A.schema = ae, A.body = g);
                }
              } else if (R === 3) {
                const ae = E.content;
                if (!ae)
                  A.body = g;
                else {
                  const ye = Object.keys(ae);
                  let xe;
                  if (_.hasOwnProperty("content-type")) {
                    const re = _["content-type"].split(";")[0].trim();
                    ae.hasOwnProperty(re) ? xe = re : I.WOPE001 || (D.WOPE001 ? m : w).message("Content type specified is not defined as a possible mime-type: " + re + ". [WOPE001]");
                  } else
                    ye.length === 1 ? xe = ye[0] : m.message("Unable to determine content type to use. Please specify this value in the header object");
                  const je = xe && ae[xe] && ae[xe].schema;
                  if (je) {
                    g = je.formalize(g);
                    let re = je.validate(g, { readWriteMode: "read" });
                    re || ([g, re] = je.serialize(g)), re ? m.at("body").merge(re) : (A.schema = je, A.body = g);
                  } else
                    A.body = g;
                }
              }
            }
            const J = Object.keys(_);
            E.headers && Object.keys(E.headers).forEach((ae) => {
              const ye = ae.toLowerCase(), xe = E.headers[ae], je = xe.schema;
              let re;
              if (_.hasOwnProperty(ye) ? re = _[ye] : je.hasOwnProperty("default") && (re = i.copy(je.default)), re !== void 0) {
                i.arrayRemoveItem(J, ye), re = je.formalize(re);
                let fe = je.validate(re);
                fe || ([re, fe] = je.serialize(re)), fe || ([re, fe] = xe.stringify(re)), fe ? m.at("headers").at(ae).merge(fe) : A.headers[ae] = re;
              } else
                xe.required && m.at("headers").at(ae).message("Missing required header: " + ae);
            }), J.forEach((ae) => {
              typeof _[ae] != "string" && !I.WOPE002 && (D.WOPE002 ? m : w).at("headers").at(ae).message("Value has no schema and is not a string. [WOPE002]");
            });
          } else
            m.message("Invalid response code: " + y);
          return A.hasOwnProperty("body") && (A.body = s.extract(A.body)), A.headers && Object.keys(A.headers).forEach((J) => {
            A.headers[J] = s.extract(A.headers[J]);
          }), new n(A, m, w);
        },
        toRequestObject: function(y) {
          const g = {};
          return a.forEach((_) => {
            _ in y && (g[_] = y[_]);
          }), g;
        }
      },
      validator: function({ major: y, definition: g }) {
        return {
          type: "object",
          properties: {
            callbacks: {
              allowed: y === 3,
              type: "object",
              additionalProperties: t("Callback")
            },
            consumes: {
              allowed: y === 2,
              type: "array",
              items: {
                type: "string"
              }
            },
            deprecated: {
              type: "boolean",
              default: !1
            },
            description: {
              type: "string"
            },
            externalDocs: t("ExternalDocumentation"),
            operationId: {
              type: "string",
              errors: (_) => {
                const { exception: m, root: w, definition: $ } = _;
                w.__operationIdMap || (w.__operationIdMap = {}), w.__operationIdMap[$] ? m.message("The operationId must be unique") : w.__operationIdMap[$] = _;
              }
            },
            parameters: {
              type: "array",
              items: t("Parameter"),
              errors: e.exports.parametersValidation
            },
            produces: {
              allowed: y === 2,
              type: "array",
              items: {
                type: "string"
              }
            },
            requestBody: t("RequestBody", {
              // for easy unit testing default key to post if there is no parent key
              allowed: ({ options: _, parent: m }) => y === 3 && !!_.requestBodyAllowedMethods[m.key || "post"]
            }),
            responses: t("Responses", { required: !0 }),
            schemes: {
              allowed: y === 2,
              type: "array",
              items: {
                type: "string",
                enum: ["http", "https", "ws", "wss"]
              }
            },
            security: {
              type: "array",
              items: t("SecurityRequirement")
            },
            servers: {
              allowed: y === 3,
              type: "array",
              items: t("Server")
            },
            summary: {
              type: "string",
              errors: ({ definition: _, warn: m, options: w, parent: $ }) => {
                _.length >= 120 && !w.exceptionSkipCodes.WOPE003 && !i.schemaObjectHasSkipCode(g, "WOPE003") && (w.exceptionEscalateCodes.WOPE003 ? exception : m).message("Value should be less than 120 characters. [WOPE003]");
              }
            },
            tags: {
              type: "array",
              items: {
                type: "string"
              }
            }
          }
        };
      },
      parametersValidation: ({ exception: y, parent: g, root: _, definition: m }) => {
        const w = m.length, $ = [];
        let E = 0, A = !1, R = !1, I = !1;
        for (let D = 0; D < w; D++) {
          const J = m[D];
          J.in === "body" && (E++, A = !0), J.in === "formData" && (R = !0, J.type === "file" && (I = !0));
          for (let ae = 0; ae < w; ae++) {
            const ye = m[ae];
            if (J !== ye && J.name === ye.name && J.in === ye.in) {
              const xe = J.name + " in " + J.in;
              $.includes(xe) || $.push(xe);
            }
          }
        }
        if (E > 1 && y.message("Only one body parameter allowed"), A && R && y.message('Cannot have parameters in "body" and "formData" simultaneously'), $.length && y.message("Parameter name must be unique per location. Duplicates found: " + $.join(", ")), I) {
          const D = g.validator === e.exports.validator && g.definition.consumes || _.definition.consumes, J = Array.isArray(D) ? D.length : 0;
          let ae = !1;
          for (let ye = 0; ye < J; ye++) {
            const xe = D[ye];
            if (xe === "multipart/form-data" || xe === "application/x-www-form-urlencoded") {
              ae = !0;
              break;
            }
          }
          ae || y.message('Parameters of type "file" require the consumes property to be set to either "multipart/form-data" or "application/x-www-form-urlencoded"');
        }
      }
    };
    function l(y, g) {
      g && g.forEach((_) => {
        const m = _.in, w = m === "header" ? _.name.toLowerCase() : _.name;
        y.hasOwnProperty(m) || (y[m] = {}), y[m][w] = _;
      });
    }
    function d(y) {
      const g = Object.keys(y.body)[0];
      return y.body[g];
    }
    function p(y, g, _, m, w) {
      _.error || (_ = g.deserialize(_.value)), _.error || (_.error = g.validate(_.value, { readWriteMode: m })), _.error ? y && y.push(_.error) : w(_.value);
    }
    function h(y, g) {
      const _ = g.header.hasOwnProperty("content-type") ? g.header["content-type"].split(";")[0].trim() : "*/*", m = y.requestBody.content, w = Object.keys(m), $ = i.findMediaMatch(_, w);
      return {
        content: m,
        contentType: _,
        matches: $
      };
    }
    function v(y, g) {
      return typeof y == "string" && (g.type === "boolean" ? (y === "true" && (y = !0), (!y || y === "false") && (y = !1)) : g.type === "integer" ? u.test(y) && (y = parseInt(y)) : g.type === "number" && c.test(y) && (y = parseFloat(y))), y;
    }
  }(cm)), cm.exports;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var fm, V$;
function Z$() {
  if (V$)
    return fm;
  V$ = 1;
  const e = yS(), t = sr, r = qn, n = bs, i = Qt, s = _s(), a = /^false/i, u = /^true$/i, c = /^\./;
  fm = {
    init: function(g) {
      const { context: _, definition: m, exception: w, major: $, warn: E, options: A } = g;
      if (m.in === "header" && m.name !== m.name.toLowerCase() && !A.exceptionSkipCodes.WPAR001 && !i.schemaObjectHasSkipCode(m, "WPAR001") && (A.exceptionEscalateCodes.WPAR001 ? w : E).message("Header names are case insensitive and their lower case equivalent will be used. [WPAR001]"), !this.hasOwnProperty("required") && this.in !== "path" && (this.required = !1), $ === 2 && m.in !== "body") {
        const R = e.extractSchemaDefinition({}, this);
        R.type === "file" && (R.type = "string");
        const [I, D, J] = new _.Schema(R);
        I && (this.schema = I), D && w.merge(D), J && E.merge(J);
      } else if ($ === 3 && m.content) {
        const R = Object.keys(m.content)[0];
        m.content[R].schema && (this.schema = m.content[R].schema);
      }
      $ === 3 && this.schema && i.validateExamples(this, w, E, A);
    },
    prototype: {
      /**
       * Parse input. Does not validate.
       * @param {string} value
       * @param {object} [query={}]
       * @returns {EnforcerResult}
       */
      parse: function(g, _) {
        const { major: m } = this.enforcerData, w = this.schema, $ = w && w.type, E = r("Unable to parse value");
        if ((this.in === "path" || this.in === "query") && (g = decodeURIComponent(g)), m === 2)
          if (this.collectionFormat === "multi") {
            _ || (_ = i.parseQueryString(g));
            const A = _[this.name];
            if (A) {
              const R = [];
              return A.forEach((I, D) => {
                !I && !this.allowEmptyValue ? E.at(D).message("Empty value not allowed") : this.items ? R.push(y(this, this.items, E.at(D), I)) : R.push(I);
              }), new n(R, E);
            } else
              return new n(null, E);
          } else if (_ && _.hasOwnProperty(this.name)) {
            const A = _[this.name];
            return A.length ? new n(y(this, this, E, A[A.length - 1]), E) : new n(y(this, this, E, void 0), E);
          } else
            return new n(y(this, this, E, g), E);
        else if (m === 3) {
          const A = this.explode, R = this.style;
          let I;
          if (_ || (this.in === "query" ? _ = i.parseQueryString(g) : this.in === "cookie" && (_ = i.parseCookieString(g))), R === "deepObject") {
            const D = RegExp("(?:^|&)" + this.name + "\\[([^\\]]+)\\](?:=([^&]*))?", "g"), J = {};
            let ae, ye = !1;
            for (; ae = D.exec(g); )
              ye = !0, J[ae[1]] = ae[2];
            ye && (I = J);
          } else if (R === "form") {
            if (A && $ === "object") {
              const D = p("&", "=", "&" + g);
              D && (I = {}, Object.keys(D).forEach((J) => {
                (w.additionalProperties || w.properties && w.properties.hasOwnProperty(J)) && (I[J] = D[J]);
              }));
            } else if (_.hasOwnProperty(this.name)) {
              const D = _[this.name];
              if ($ === "array")
                A ? I = D : D.length > 0 && (I = D[D.length - 1].split(","));
              else if ($ === "object") {
                const J = h(",", D[D.length - 1]);
                J && (I = J);
              } else
                D.length > 0 && (I = D[D.length - 1]);
            }
          } else if (R === "label")
            c.test(g) && ($ === "array" ? I = g.substr(1).split(A ? "." : ",") : $ === "object" ? I = A ? p(".", "=", g) : h(",", g.substr(1)) : I = g.substr(1));
          else if (R === "matrix") {
            const D = this.name, J = RegExp("^;" + D + "(?:=|$)");
            if ($ === "array")
              if (A) {
                const ae = l(";", "=", D, g.substr(1));
                ae && (I = ae);
              } else
                I = g.substr(D.length + 2).split(",");
            else if ($ === "object") {
              if (A || J.test(g)) {
                const ae = A ? p(";", "=", g) : h(",", g.substr(D.length + 2));
                ae && (I = ae);
              }
            } else
              J.test(g) && (I = g.substr(D.length + 2));
          } else if (R === "pipeDelimited") {
            const D = _[this.name];
            D.length > 0 && (I = A ? D : d($, "|", D[D.length - 1]));
          } else if (R === "simple")
            $ === "array" ? I = g.split(",") : $ === "object" ? I = A ? p(",", "=", "," + g) : h(",", g) : I = g;
          else if (R === "spaceDelimited") {
            const D = _[this.name];
            D.length > 0 && (I = A ? D : d($, " ", D[D.length - 1]));
          }
          return I !== void 0 ? $ === "array" ? I = I.map((D, J) => v(this, w.items, E.at(J), D)) : $ === "object" ? Object.keys(I).forEach((D) => {
            w.properties && w.properties[D] ? I[D] = v(this, w.properties[D], E.at(D), I[D]) : typeof w.additionalProperties == "object" && (I[D] = v(this, w.additionalProperties, E.at(D), I[D]));
          }) : I = v(this, w, E, I) : E.message("The value is not formatted properly"), new n(I, E);
        }
      }
    },
    validator: function(g) {
      const { major: _, options: m, definition: w } = g, $ = e.validator(g), E = m.exceptionSkipCodes, A = g.options.exceptionEscalateCodes;
      return {
        type: "object",
        properties: Object.assign({}, $.properties, {
          allowEmptyValue: {
            allowed: ({ parent: R }) => ["query", "formData"].includes(R.definition.in),
            type: "boolean",
            default: !1,
            errors: ({ exception: R, warn: I, major: D, usedDefault: J }) => {
              D === 3 && !J && !E.WPAR002 && !i.schemaObjectHasSkipCode(w, "WPAR002") && (A.WPAR002 ? R : I).message('Per OAS 3.0.2: "Use of this property is NOT RECOMMENDED, as it is likely to be removed in a later revision." [WPAR002]');
            }
          },
          allowReserved: {
            allowed: ({ parent: R }) => _ === 3 && R.definition.in === "query",
            type: "boolean",
            default: !1
          },
          collectionFormat: {
            allowed: ({ major: R, parent: I }) => R === 2 && I.definition.type === "array",
            enum: ({ parent: R }) => ["query", "formData"].includes(R.definition.in) ? ["csv", "ssv", "tsv", "pipes", "multi"] : ["csv", "ssv", "tsv", "pipes"],
            default: "csv"
          },
          explode: {
            type: "boolean",
            allowed: _ === 3,
            default: ({ parent: R }) => R.result.style === "form",
            errors: ({ exception: R, parent: I }) => {
              const D = I.definition.schema && I.definition.schema.type;
              I.definition.in === "cookie" && I.definition.explode && (D === "array" || D === "object") && R.message("Cookies do not support exploded values for non-primitive schemas");
            }
          },
          format: {
            weight: -9,
            allowed: ({ major: R, parent: I }) => R === 2 && ["file", "integer", "number", "string"].includes(I.definition.type),
            type: "string",
            errors: ({ exception: R, parent: I, warn: D }) => {
              const J = I.definition.format;
              if (J) {
                const ae = [];
                switch (I.definition.type) {
                  case "file":
                    ae.push("binary", "byte");
                    break;
                  case "integer":
                    ae.push("int32", "int64");
                    break;
                  case "number":
                    ae.push("float", "double");
                    break;
                  case "string":
                    ae.push("binary", "byte", "date", "date-time", "password");
                    break;
                }
                !ae.includes(J) && !E.WPAR003 && !i.schemaObjectHasSkipCode(w, "WPAR003") && (A.WPAR003 ? R : D).message("Non standard format used: " + J + ". [WPAR003]");
              }
            }
          },
          in: {
            weight: -20,
            required: !0,
            type: "string",
            enum: ({ major: R }) => R === 2 ? ["body", "formData", "header", "query", "path"] : ["cookie", "header", "path", "query"]
          },
          name: {
            required: !0,
            type: "string"
          },
          required: {
            required: ({ parent: R }) => R.definition.in === "path",
            type: "boolean",
            // default: ({parent}) => parent.definition.in === 'path',
            // default: false,
            enum: ({ parent: R }) => R.definition.in === "path" ? [!0] : [!0, !1]
          },
          schema: t("Schema", {
            allowed: ({ parent: R }) => _ === 3 || R.definition.in === "body"
          }),
          style: {
            weight: -19,
            allowed: _ === 3,
            type: "string",
            default: ({ parent: R }) => {
              switch (R.definition.in) {
                case "cookie":
                  return "form";
                case "header":
                  return "simple";
                case "path":
                  return "simple";
                case "query":
                  return "form";
              }
            },
            enum: ({ parent: R }) => {
              switch (R.definition.in) {
                case "cookie":
                  return ["form"];
                case "header":
                  return ["simple"];
                case "path":
                  return ["simple", "label", "matrix"];
                case "query":
                  return ["form", "spaceDelimited", "pipeDelimited", "deepObject"];
              }
            },
            errors: ({ exception: R, parent: I }) => {
              const D = I.definition.style, J = I.definition.schema && I.definition.schema.type;
              if (!J || !D)
                return !1;
              I.definition.in === "query" && D !== "form" && !(D === "spaceDelimited" && J === "array") && !(D === "pipeDelimited" && J === "array") && !(D === "deepObject" && J === "object") && R.message('Style "' + D + '" is incompatible with schema type: ' + J);
            }
          },
          type: {
            weight: -10,
            allowed: ({ major: R, parent: I }) => R === 2 && I.definition.in !== "body",
            required: !0,
            enum: ({ parent: R }) => R.definition.in === "formData" ? ["array", "boolean", "file", "integer", "number", "string"] : ["array", "boolean", "integer", "number", "string"]
          }
        }),
        errors: _ === 3 ? $.errors : (R) => {
          const { exception: I, definition: D } = R;
          D.hasOwnProperty("default") && D.required && I.message('Cannot have a "default" and set "required" to true'), $.errors(R);
        }
      };
    }
  };
  function l(g, _, m, w) {
    const $ = w.split(g), E = $.length, A = [];
    for (let R = 0; R < E; R++) {
      const I = $[R].split(_);
      if (I[0] === m)
        A.push(I[1]);
      else
        return !1;
    }
    return A;
  }
  function d(g, _, m) {
    if (g === "array")
      return m.split(_);
    if (g === "object")
      return h(_, m);
  }
  function p(g, _, m) {
    const $ = RegExp("s([^v]+)v([^s]+)?".replace(/v/g, _).replace(/s/g, g), "g"), E = {};
    let A, R = 0;
    for (; A = $.exec(m); )
      E[A[1]] = A[2] || "", R = A.index + A[0].length;
    if (R === m.length)
      return E;
  }
  function h(g, _) {
    const m = {}, w = _.split(g), $ = w.length;
    if ($ % 2 === 0) {
      for (let E = 1; E < $; E += 2)
        m[w[E - 1]] = w[E];
      return m;
    }
  }
  function v(g, _, m, w) {
    if (w) {
      if (_.type === "boolean") {
        if (u.test(w))
          return !0;
        if (a.test(w))
          return !1;
        m.message('Expected "true" or "false". Received: ' + w);
      } else if (_.type === "integer") {
        const $ = +w;
        if (!isNaN($))
          return $;
        m.message("Expected an integer. Received: " + w);
      } else if (_.type === "number") {
        const $ = +w;
        if (!isNaN($))
          return $;
        m.message("Expected a number. Received: " + w);
      } else if (_.type === "string")
        return w;
    } else {
      if (g.allowEmptyValue)
        return new s(w, { serialize: !1, validate: !1 });
      m.message("Empty value not allowed");
    }
    return w;
  }
  function y(g, _, m, w) {
    if (_.type === "array") {
      let $;
      switch (_.collectionFormat) {
        case "csv":
          $ = w.split(",");
          break;
        case "pipes":
          $ = w.split("|");
          break;
        case "ssv":
          $ = w.split(" ");
          break;
        case "tsv":
          $ = w.split("	");
          break;
      }
      return $.map((E, A) => _.items ? y(g, _.items, m.at(A), E) : E);
    } else
      return v(g, _, m, w);
  }
  return fm;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var dm, z$;
function W$() {
  if (z$)
    return dm;
  z$ = 1;
  const e = sr, t = Qt, r = t.methods();
  return dm = {
    init: function() {
      this.methods = r.filter((n) => !!this[n]);
    },
    prototype: {},
    validator: function({ major: n, options: i, definition: s }) {
      const a = Sf(), u = i.exceptionSkipCodes, c = i.exceptionEscalateCodes;
      return {
        type: "object",
        properties: {
          delete: e("Operation"),
          description: {
            type: "string"
          },
          get: e("Operation"),
          head: e("Operation"),
          options: e("Operation"),
          parameters: {
            weight: -1,
            type: "array",
            items: e("Parameter"),
            errors: a.parametersValidation
          },
          patch: e("Operation"),
          post: e("Operation"),
          put: e("Operation"),
          trace: e("Operation", { allowed: n === 3 }),
          servers: {
            allowed: n === 3,
            type: "array",
            items: e("Server")
          },
          summary: {
            type: "string"
          }
        },
        errors: ({ exception: l, definition: d, warn: p }) => {
          const h = r.length;
          let v = !1;
          for (let y = 0; y < h; y++)
            if (d.hasOwnProperty(r[y])) {
              v = !0;
              break;
            }
          !v && !u.WPAT001 && !t.schemaObjectHasSkipCode(s, "WPAT001") && (c.WPAT001 ? l : p).message("No methods defined. [WPAT001]");
        }
      };
    }
  }, dm;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var pm, H$;
function G$() {
  if (H$)
    return pm;
  H$ = 1;
  const e = sr, t = Qt, r = /{([^}]+)}/, n = t.methods();
  pm = {
    init: function(s) {
      const { exception: a, result: u, plugins: c } = s, l = {};
      s.options.disablePathNormalization || Object.keys(u).forEach((p) => {
        const h = t.edgeSlashes(p, !0, !1);
        h !== p && (u[h] = u[p], delete u[p]);
      }), c.push(() => {
        const d = N0().config;
        Object.keys(u).forEach((_, m) => {
          const w = u[_], $ = _.split("/").length - 1, E = [], A = new RegExp(r, "g");
          let R;
          for (; R = A.exec(_); )
            E.push(R[1]);
          const I = a.at(_).nest("Path parameter definitions inconsistent");
          w.methods.forEach((fe) => {
            const le = I.at(fe), $e = Object.keys(w[fe].parametersMap.path || {}), Ae = $e.length, _e = [];
            for (let V = 0; V < Ae; V++) {
              const z = $e[V];
              E.includes(z) || _e.push(z);
            }
            _e.length && le.message("Path missing defined parameters: " + _e.join(", "));
            const ie = E.length, K = [];
            for (let V = 0; V < ie; V++) {
              const z = E[V];
              $e.includes(z) || K.push(z);
            }
            K.length && le.message("Definition missing path parameters: " + K.join(", "));
          });
          const D = /{([^}]+)}/g;
          let J, ae = "", ye = 0, xe = "";
          for (; R = D.exec(_); )
            J = _.substring(ye, R.index), xe += "0".repeat(J.split("/").length) + "1", ae += i(J) + "([\\s\\S]+?)", ye = R.index + R[0].length;
          J = _.substr(ye), J && (xe += "0".repeat(J.split("/").length) + "0", ae += i(J));
          const je = d.useCaseSensitivePaths ? new RegExp("^" + ae + "$") : new RegExp("^" + ae + "$", "i"), re = (fe) => {
            const le = je.exec(fe);
            if (!le)
              return;
            const $e = {};
            return E.forEach((Ae, _e) => $e[Ae] = le[_e + 1]), {
              params: $e,
              path: w,
              pathKey: _
            };
          };
          re.weight = xe + m, l[$] || (l[$] = []), l[$].push(re);
        });
        const p = Symbol("path parameter"), h = [];
        Object.keys(u).forEach((_, m) => {
          const w = /{([^}]+)}/g, $ = [];
          let E, A = 0;
          for (; E = w.exec(_); ) {
            const I = _.substring(A, E.index);
            $.push(I), $.push(p), A = E.index + E[0].length;
          }
          const R = _.substring(A);
          $.push(R), n.filter((I) => u[_].hasOwnProperty(I)).forEach((I) => {
            h.push({
              key: _,
              method: I,
              signature: d.useCaseSensitivePaths ? [I].concat($) : [I].concat($.map((D) => typeof D == "string" ? D.toLowerCase() : D))
            });
          });
        });
        const v = [], y = [];
        h.forEach((_) => {
          const m = h.filter((w) => {
            const $ = w.signature.length;
            if (_ === w || _.signature.length !== $ || y.includes(w.key))
              return !1;
            for (let E = 0; E < $; E++)
              if (w.signature[E] !== _.signature[E])
                return !1;
            return !0;
          });
          m.length > 0 && (m.unshift(_), m.forEach((w) => y.push(w.key)), v.push(m));
        });
        const g = a.nest("Equivalent paths are not allowed");
        v.forEach((_) => {
          const m = g.nest("Equivalent paths:");
          _.forEach((w) => m.push(w.method.toUpperCase() + " " + w.key));
        }), Object.keys(l).forEach((_) => {
          l[_].sort((m, w) => m.weight < w.weight ? -1 : 1);
        }), this.enforcerData.pathParsers = l;
      });
    },
    prototype: {
      /**
       * Find the Path object for the provided path.
       * @param {string} pathString
       * @returns {{ params: object, path: Path }|undefined}
       */
      findMatch: function(s) {
        return this.findMatches(s)[0];
      },
      findMatches: function(s) {
        const { pathParsers: a } = this.enforcerData, u = [];
        s = s.split("?")[0];
        const c = s.split("/").length - 1, l = a[c];
        if (!l)
          return u;
        const d = l.length;
        for (let p = 0; p < d; p++) {
          const h = l[p], v = h(s);
          v && u.push(v);
        }
        return u;
      }
    },
    validator: function(s) {
      const a = s.options.disablePathNormalization, u = s.options.exceptionSkipCodes, c = s.options.exceptionEscalateCodes, l = s.definition;
      return {
        required: !0,
        type: "object",
        additionalProperties: e("PathItem"),
        errors: ({ exception: d, definition: p, warn: h }) => {
          const v = d.nest("These paths are defined more than once exist due to path normalization:"), y = Object.keys(p), g = {}, _ = [], m = [];
          if (y.forEach((w) => {
            if ((w[0] !== "/" || w[1] === "/") && d.at(w).message("Path must begin with a single forward slash"), !a) {
              const $ = t.edgeSlashes(w, !0, !1);
              g[$] && v.message(w + " --> " + $), $ !== w && !u.WPAS001 && !t.schemaObjectHasSkipCode(l, "WPAS001") && (c.WPAS001 ? d : h).at(w).message("Path normalized from " + w + " to " + $ + ". [WPAS001]"), g[w] = $;
            }
            w !== "/" && (w[w.length - 1] === "/" ? _.push(w) : m.push(w));
          }), !y.length && !u.WPAS002 && !t.schemaObjectHasSkipCode(l, "WPAS002") && (c.WPAS002 ? d : h).message("No paths defined. [WPAS002]"), _.length > 0 && m.length > 0) {
            const w = (c.WPAS003 ? d : h).nest("Some defined paths end with slashes while some do not. This inconsistency may confuse users of your API."), $ = w.nest("Paths without trailing slashes:"), E = w.nest("Paths with trailing slashes:");
            m.forEach((A) => {
              !u.WPAS003 && !t.schemaObjectHasSkipCode(l, "WPAS003") && $.message(A + " [WPAS003]");
            }), _.forEach((A) => {
              !u.WPAS003 && !t.schemaObjectHasSkipCode(l, "WPAS003") && E.message(A + " [WPAS003]");
            });
          }
        }
      };
    }
  };
  function i(s) {
    return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  }
  return pm;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var hm, K$;
function Y$() {
  return K$ || (K$ = 1, hm = {
    init: function(e) {
    },
    prototype: {},
    validator: function(e) {
      return {
        type: "object",
        properties: {
          $ref: {
            type: "string"
          }
        }
      };
    }
  }), hm;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var mm, J$;
function X$() {
  if (J$)
    return mm;
  J$ = 1;
  const e = sr, t = Qt, r = /^content-type$/i, n = /^[a-zA-Z0-9.\-_]+$/;
  return mm = {
    init: function(i) {
      const { exception: s, warn: a, options: u } = i;
      t.validateExamples(this, s, a, u);
    },
    prototype: {},
    validator: function({ major: i }) {
      return {
        type: "object",
        properties: {
          description: {
            type: "string",
            required: !0
          },
          content: {
            allowed: i === 3,
            type: "object",
            additionalProperties: e("MediaType")
          },
          examples: {
            allowed: i === 2,
            type: "object",
            additionalProperties: {
              freeForm: !0
            }
          },
          headers: {
            type: "object",
            additionalProperties: e("Header", {
              ignored: ({ key: s }) => r.test(s)
            })
          },
          links: {
            allowed: i === 3,
            type: "object",
            additionalProperties: e("Link", {
              errors: ({ exception: s, key: a }) => {
                n.test(a) || s.message("Invalid key used for link value");
              }
            })
          },
          schema: i === 2 ? e("Schema") : { allowed: !1 }
        }
      };
    }
  }, mm;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var ym, Q$;
function e2() {
  if (Q$)
    return ym;
  Q$ = 1;
  const e = sr, t = Qt, r = /^[1-5]\d{2}$/, n = /^location$/i, i = /^[1-5]X{2}$/;
  return ym = {
    init: function(s) {
    },
    prototype: {},
    validator: function(s) {
      const { major: a, options: u, definition: c } = s, l = u.exceptionSkipCodes, d = u.exceptionEscalateCodes;
      return {
        type: "object",
        additionalProperties: e("Response", {
          allowed: ({ key: p }) => p === "default" || r.test(p) || a === 3 && i.test(p),
          errors: ({ exception: p, key: h, parent: v, warn: y, definition: g, major: _, options: m }) => {
            if (m.apiSuggestions && r.test(h) && v && v.parent && v.parent.key)
              if (v.parent.key.toLowerCase() === "post" && h === "201") {
                const $ = g.headers ? Object.keys(g.headers).filter((E) => n.test(E))[0] : null;
                (!$ || !g.headers[$]) && !l.WRES001 && !t.schemaObjectHasSkipCode(c, "WRES001") && (d.WRES001 ? p : y).message("A 201 response for a POST request should return a location header (https://tools.ietf.org/html/rfc7231#section-4.3.3) and this is not documented in your OpenAPI document. [WRES001]");
              } else
                h === "204" && (_ === 2 && g.schema && !l.WRES002 && !t.schemaObjectHasSkipCode(c, "WRES002") ? (d.WRES002 ? p : y).message("A 204 response must not contain a body (https://tools.ietf.org/html/rfc7231#section-6.3.5) but this response has a defined schema. [WRES002]") : _ === 3 && g.content && !l.WRES003 && !t.schemaObjectHasSkipCode(c, "WRES003") && (d.WRES003 ? p : y).message("A 204 response must not contain a body (https://tools.ietf.org/html/rfc7231#section-6.3.5) but this response has a defined content. [WRES003]"));
          }
        }),
        errors: ({ exception: p, definition: h }) => {
          Object.keys(h).length === 0 && !p.hasException && p.message("Response object cannot be empty");
        }
      };
    }
  }, ym;
}
var gm = { exports: {} }, vm = {}, t2;
function M0() {
  return t2 || (t2 = 1, function(e) {
    e.after = function(t, r, n, i) {
      return e.runHooks(t, r, n, i).value;
    }, e.runHooks = function(t, r, n, i, s = !1) {
      if (t.enforcerData && t.enforcerData.staticData && t.enforcerData.staticData.hooks) {
        const a = t.enforcerData.staticData.hooks[r], u = a !== void 0 ? a.length : 0;
        let c = n, l = !1;
        if (s && u > 0 && (l = i.hasException), !l)
          for (let d = 0; d < u; d++) {
            const p = a[d](n, t, i);
            if (p && typeof p == "object") {
              if (p.done === !0)
                return p;
              if ("value" in p && (c = p.value), p.hasException || i.hasException) {
                l = !0;
                break;
              }
            }
          }
        return {
          done: l === !0,
          // if it has an exception then it is also done
          hasException: l,
          value: c
        };
      } else
        return {
          done: !1,
          hasException: !1,
          value: n
        };
    };
  }(vm)), vm;
}
var bm = {}, r2;
function gS() {
  if (r2)
    return bm;
  r2 = 1;
  const e = qn, t = Qt, r = _s();
  return bm.anyOneOf = function(n, i, s, a, u, c, l) {
    i instanceof r && (i = i.value);
    const d = n.anyOf ? "anyOf" : "oneOf", p = [], h = [];
    if (n[d].forEach((v) => {
      const y = new e(""), g = new Map(a);
      if (c) {
        const m = v.validate(i);
        if (m) {
          p.push(m);
          return;
        }
      }
      const _ = u(y, g, v, t.copy(i), l);
      if (y.hasException)
        p.push(y);
      else {
        let m = 1;
        if (v.type === "object") {
          const w = v.properties || {}, $ = Object.keys(_), E = $.length;
          for (let A = 0; A < E; A++) {
            const R = $[A];
            if (w.hasOwnProperty(R))
              m++;
            else if (v.additionalProperties === !1) {
              m = 0;
              break;
            }
          }
        }
        m > 0 && !c && v.validate(_) && (m = 0), m > 0 && h.push({ score: m, result: t.copy(_) });
      }
    }), h.length > 1) {
      h.sort((g, _) => g.score > _.score ? -1 : 1);
      const v = h[0].score, y = h.filter((g) => g.score === v);
      if (y.length > 1) {
        const g = c ? "Unable to determine serialization schema because too many schemas match. Use of a discriminator or making your schemas more specific would help this problem." : "Unable to determine deserialization schema because too many schemas match. Use of a discriminator or making your schemas more specific would help this problem.";
        s.message(g);
      } else
        return t.merge(i, y[0].result);
    } else if (h.length === 0)
      if (p.length > 0) {
        const v = s.nest("No matching schemas");
        p.forEach((y) => v.push(y));
      } else
        s.message("No matching schemas");
    else
      return t.merge(i, h[0].result);
  }, bm;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var _m, n2;
function JW() {
  if (n2)
    return _m;
  n2 = 1;
  const e = M0(), t = gS(), r = Qt, n = _s(), i = /^\s*true\s*$/i, s = /^\s*false\s*$/i, a = /^\s*\d+\s*$/, u = /^\s*(?:\d+(?:\.\d+)?)|(?:\.\d+)\s*$/;
  _m = c;
  function c(l, d, p, h, v) {
    let { serialize: y, value: g } = n.getAttributes(h);
    if (!y)
      return h;
    const _ = p.type, m = typeof g;
    if (g && m === "object") {
      let $ = d.get(p);
      if ($ && $.includes(g))
        return g;
      d.set(p, [g]);
    }
    const w = e.runHooks(p, "beforeDeserialize", g, l);
    if (g = w.value, w.done)
      return g;
    if (g === null && (p.nullable || p["x-nullable"]))
      return e.after(p, "afterDeserialize", g, l);
    if (p.allOf) {
      const $ = l.at("allOf");
      if (p.allOf[0].type === "object") {
        const E = {};
        return p.allOf.forEach((A, R) => {
          const I = c($.at(R), d, A, h, v);
          Object.assign(E, I);
        }), e.after(p, "afterDeserialize", Object.assign(g, E), l);
      } else
        return c($.at("0"), d, p.allOf[0], h, v);
    } else if (p.anyOf || p.oneOf) {
      let $;
      if (p.discriminator) {
        const { name: E, key: A, schema: R } = p.discriminate(g, !0);
        R ? $ = Object.assign(g, c(l, d, R, h, v)) : l.message('Discriminator property "' + A + '" as "' + E + '" did not map to a schema');
      } else
        $ = t.anyOneOf(
          p,
          h,
          l,
          d,
          c,
          !1,
          v
        );
      return e.after(p, "afterDeserialize", $, l);
    } else if (_ === "array") {
      if (Array.isArray(g))
        return p.items && g.forEach(($, E) => {
          g[E] = c(l.at(E), d, p.items, n.inherit($, { serialize: y }), v);
        }), e.after(p, "afterDeserialize", g, l);
      l.message("Expected an array. Received: " + r.smart(g));
    } else if (_ === "object")
      if (r.isObject(g)) {
        const $ = p.additionalProperties, E = p.properties || {};
        if (Object.keys(g).forEach((A) => {
          E.hasOwnProperty(A) ? g[A] = c(l.at(A), d, E[A], n.inherit(g[A], { serialize: y }), v) : $ && (g[A] = c(l.at(A), d, $, n.inherit(g[A], { serialize: y }), v));
        }), p.discriminator) {
          const { name: A, key: R, schema: I } = p.discriminate(g, !0);
          I ? Object.assign(g, c(l, d, I, h, v)) : l.message('Discriminator property "' + R + '" as "' + A + '" did not map to a schema');
        }
        return e.after(p, "afterDeserialize", g, l);
      } else
        l.message("Expected an object. Received: " + r.smart(g));
    else if (p !== !0) {
      const $ = p.enforcerData.staticData.dataTypes, E = $[p.type] && $[p.type][p.format] || null;
      if (_ === "boolean")
        if (E && E.deserialize) {
          const A = E.deserialize({
            exception: l,
            schema: p,
            value: g
          });
          return e.after(p, "afterDeserialize", A, l);
        } else if (m !== "boolean") {
          if (!v.strict) {
            if (m === "string") {
              if (i.test(g))
                return !0;
              if (s.test(g))
                return !1;
            } else if (m === "number")
              return e.after(p, "afterDeserialize", !!g, l);
          }
          l.message("Expected a boolean. Received: " + r.smart(g));
        } else
          return e.after(p, "afterDeserialize", g, l);
      else if (_ === "integer")
        if (E && E.deserialize) {
          const A = E.deserialize({
            exception: l,
            schema: p,
            value: g
          });
          return e.after(p, "afterDeserialize", A, l);
        } else if (m !== "number" || !r.isInteger(g)) {
          if (!v.strict && m === "string" && a.test(g))
            return e.after(p, "afterDeserialize", +g, l);
          l.message("Expected an integer. Received: " + r.smart(g));
        } else
          return e.after(p, "afterDeserialize", g, l);
      else if (_ === "number")
        if (E && E.deserialize) {
          const A = E.deserialize({
            exception: l,
            schema: p,
            value: g
          });
          return e.after(p, "afterDeserialize", A, l);
        } else if (m !== "number") {
          if (!v.strict && m === "string" && u.test(g))
            return e.after(p, "afterDeserialize", +g, l);
          l.message("Expected a number. Received: " + r.smart(g));
        } else
          return e.after(p, "afterDeserialize", g, l);
      else if (_ === "string") {
        if (E && E.deserialize) {
          const A = E.deserialize({
            exception: l,
            schema: p,
            value: g
          });
          return e.after(p, "afterDeserialize", A, l);
        }
        if (m !== "string")
          l.message("Expected a string. Received: " + r.smart(g));
        else
          return e.after(p, "afterDeserialize", g, l);
      }
    } else
      return e.after(p, "afterDeserialize", g, l);
  }
  return _m;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var wm, i2;
function XW() {
  if (i2)
    return wm;
  i2 = 1;
  const e = Qt, t = _s();
  wm = r;
  function r(i, s, a, u, c, l, d, p) {
    const { populate: h, value: v } = t.getAttributes(l[d]), y = u.type;
    if (!h) {
      l[d] = v;
      return;
    }
    if (!(u.hasOwnProperty("x-condition") && !c[u["x-condition"]]))
      if (u.allOf)
        u.allOf.forEach((g) => {
          r(i, s, a, g, c, l, d, p);
        });
      else if (u.anyOf || u.oneOf) {
        const g = u.anyOf ? "anyOf" : "oneOf";
        if (!u.discriminator)
          i.message("Unable to populate " + g + " without a discriminator");
        else {
          const { name: _, key: m, schema: w } = u.discriminate(v, !0);
          w ? r(i, s, a, w, c, l, d, p) : i.message('Discriminator property "' + m + '" as "' + _ + '" did not map to a schema');
        }
      } else if (u.not)
        i.message('Cannot populate "not" schemas');
      else if (y === "array")
        if (v !== void 0 && !Array.isArray(v))
          i.message("Provided value must be an array. Received: " + e.smart(v));
        else {
          const g = n(i, u, c, l, d, p);
          u.items && Array.isArray(g) && (a < 0 ? s.message("Reached maximum depth") : g.forEach((_, m) => {
            r(i.at(m), s.at(m), a - 1, u.items, c, g, m, p);
          }));
        }
      else if (y === "object")
        if (v !== void 0 && (!v || typeof v != "object"))
          i.message("Provided value must be an object. Received: " + e.smart(v));
        else if (a < 0)
          s.message("Reached maximum depth");
        else {
          const g = n(i, u, c, l, d, p), _ = g || {}, m = u.additionalProperties;
          if (m) {
            const $ = u.properties || {};
            Object.keys(_).forEach((E) => {
              $.hasOwnProperty(E) || r(i.at(E), s.at(E), a - 1, m, c, _, E, p);
            });
          }
          const w = u.properties;
          w && Object.keys(w).forEach(($) => {
            r(i.at($), s.at($), a - 1, w[$], c, _, $, p);
          }), (g || Object.keys(_).length) && (l[d] = _);
        }
      else
        n(i, u, c, l, d, p);
  }
  function n(i, s, a, u, c, l) {
    if (!(s.hasOwnProperty("x-condition") && !a[s["x-condition"]])) {
      if (u[c] === void 0) {
        const d = s.type;
        if (l.variables && s.hasOwnProperty("x-variable") && a.hasOwnProperty(s["x-variable"])) {
          const p = a[s["x-variable"]];
          p !== void 0 && (u[c] = p);
        } else if (l.templates && d === "string" && s.hasOwnProperty("x-template"))
          u[c] = l.injector(s["x-template"], a);
        else if (l.defaults && s.hasOwnProperty("x-default")) {
          const p = s["x-default"];
          p !== void 0 && (u[c] = l.templateDefaults && typeof p == "string" ? l.injector(p, a) : p);
        } else if (l.defaults && s.hasOwnProperty("default")) {
          const p = s.default;
          p !== void 0 && (u[c] = l.templateDefaults && typeof p == "string" ? l.injector(p, a) : p);
        }
      }
      return u[c];
    }
  }
  return wm;
}
var bl = { exports: {} }, $m = {}, Em, s2;
function gd() {
  return s2 || (s2 = 1, Em = {
    ROOT: 0,
    GROUP: 1,
    POSITION: 2,
    SET: 3,
    RANGE: 4,
    REPETITION: 5,
    REFERENCE: 6,
    CHAR: 7
  }), Em;
}
var bi = {}, a2;
function vS() {
  if (a2)
    return bi;
  a2 = 1;
  const e = gd(), t = () => [{ type: e.RANGE, from: 48, to: 57 }], r = () => [
    { type: e.CHAR, value: 95 },
    { type: e.RANGE, from: 97, to: 122 },
    { type: e.RANGE, from: 65, to: 90 }
  ].concat(t()), n = () => [
    { type: e.CHAR, value: 9 },
    { type: e.CHAR, value: 10 },
    { type: e.CHAR, value: 11 },
    { type: e.CHAR, value: 12 },
    { type: e.CHAR, value: 13 },
    { type: e.CHAR, value: 32 },
    { type: e.CHAR, value: 160 },
    { type: e.CHAR, value: 5760 },
    { type: e.RANGE, from: 8192, to: 8202 },
    { type: e.CHAR, value: 8232 },
    { type: e.CHAR, value: 8233 },
    { type: e.CHAR, value: 8239 },
    { type: e.CHAR, value: 8287 },
    { type: e.CHAR, value: 12288 },
    { type: e.CHAR, value: 65279 }
  ], i = () => [
    { type: e.CHAR, value: 10 },
    { type: e.CHAR, value: 13 },
    { type: e.CHAR, value: 8232 },
    { type: e.CHAR, value: 8233 }
  ];
  return bi.words = () => ({ type: e.SET, set: r(), not: !1 }), bi.notWords = () => ({ type: e.SET, set: r(), not: !0 }), bi.ints = () => ({ type: e.SET, set: t(), not: !1 }), bi.notInts = () => ({ type: e.SET, set: t(), not: !0 }), bi.whitespace = () => ({ type: e.SET, set: n(), not: !1 }), bi.notWhitespace = () => ({ type: e.SET, set: n(), not: !0 }), bi.anyChar = () => ({ type: e.SET, set: i(), not: !0 }), bi;
}
var o2;
function QW() {
  return o2 || (o2 = 1, function(e) {
    const t = gd(), r = vS(), n = "@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^ ?", i = { 0: 0, t: 9, n: 10, v: 11, f: 12, r: 13 };
    e.strToChars = function(s) {
      var a = /(\[\\b\])|(\\)?\\(?:u([A-F0-9]{4})|x([A-F0-9]{2})|(0?[0-7]{2})|c([@A-Z[\\\]^?])|([0tnvfr]))/g;
      return s = s.replace(a, function(u, c, l, d, p, h, v, y) {
        if (l)
          return u;
        var g = c ? 8 : d ? parseInt(d, 16) : p ? parseInt(p, 16) : h ? parseInt(h, 8) : v ? n.indexOf(v) : i[y], _ = String.fromCharCode(g);
        return /[[\]{}^$.|?*+()]/.test(_) && (_ = "\\" + _), _;
      }), s;
    }, e.tokenizeClass = (s, a) => {
      for (var u = [], c = /\\(?:(w)|(d)|(s)|(W)|(D)|(S))|((?:(?:\\)(.)|([^\]\\]))-(?:\\)?([^\]]))|(\])|(?:\\)?([^])/g, l, d; (l = c.exec(s)) != null; )
        if (l[1])
          u.push(r.words());
        else if (l[2])
          u.push(r.ints());
        else if (l[3])
          u.push(r.whitespace());
        else if (l[4])
          u.push(r.notWords());
        else if (l[5])
          u.push(r.notInts());
        else if (l[6])
          u.push(r.notWhitespace());
        else if (l[7])
          u.push({
            type: t.RANGE,
            from: (l[8] || l[9]).charCodeAt(0),
            to: l[10].charCodeAt(0)
          });
        else if (d = l[12])
          u.push({
            type: t.CHAR,
            value: d.charCodeAt(0)
          });
        else
          return [u, c.lastIndex];
      e.error(a, "Unterminated character class");
    }, e.error = (s, a) => {
      throw new SyntaxError("Invalid regular expression: /" + s + "/: " + a);
    };
  }($m)), $m;
}
var ka = {}, u2;
function eH() {
  if (u2)
    return ka;
  u2 = 1;
  const e = gd();
  return ka.wordBoundary = () => ({ type: e.POSITION, value: "b" }), ka.nonWordBoundary = () => ({ type: e.POSITION, value: "B" }), ka.begin = () => ({ type: e.POSITION, value: "^" }), ka.end = () => ({ type: e.POSITION, value: "$" }), ka;
}
var c2;
function tH() {
  if (c2)
    return bl.exports;
  c2 = 1;
  const e = QW(), t = gd(), r = vS(), n = eH();
  return bl.exports = (i) => {
    var s = 0, a, u, c = { type: t.ROOT, stack: [] }, l = c, d = c.stack, p = [], h = (A) => {
      e.error(i, `Nothing to repeat at column ${A - 1}`);
    }, v = e.strToChars(i);
    for (a = v.length; s < a; )
      switch (u = v[s++], u) {
        case "\\":
          switch (u = v[s++], u) {
            case "b":
              d.push(n.wordBoundary());
              break;
            case "B":
              d.push(n.nonWordBoundary());
              break;
            case "w":
              d.push(r.words());
              break;
            case "W":
              d.push(r.notWords());
              break;
            case "d":
              d.push(r.ints());
              break;
            case "D":
              d.push(r.notInts());
              break;
            case "s":
              d.push(r.whitespace());
              break;
            case "S":
              d.push(r.notWhitespace());
              break;
            default:
              /\d/.test(u) ? d.push({ type: t.REFERENCE, value: parseInt(u, 10) }) : d.push({ type: t.CHAR, value: u.charCodeAt(0) });
          }
          break;
        case "^":
          d.push(n.begin());
          break;
        case "$":
          d.push(n.end());
          break;
        case "[":
          var y;
          v[s] === "^" ? (y = !0, s++) : y = !1;
          var g = e.tokenizeClass(v.slice(s), i);
          s += g[1], d.push({
            type: t.SET,
            set: g[0],
            not: y
          });
          break;
        case ".":
          d.push(r.anyChar());
          break;
        case "(":
          var _ = {
            type: t.GROUP,
            stack: [],
            remember: !0
          };
          u = v[s], u === "?" && (u = v[s + 1], s += 2, u === "=" ? _.followedBy = !0 : u === "!" ? _.notFollowedBy = !0 : u !== ":" && e.error(
            i,
            `Invalid group, character '${u}' after '?' at column ${s - 1}`
          ), _.remember = !1), d.push(_), p.push(l), l = _, d = _.stack;
          break;
        case ")":
          p.length === 0 && e.error(i, `Unmatched ) at column ${s - 1}`), l = p.pop(), d = l.options ? l.options[l.options.length - 1] : l.stack;
          break;
        case "|":
          l.options || (l.options = [l.stack], delete l.stack);
          var m = [];
          l.options.push(m), d = m;
          break;
        case "{":
          var w = /^(\d+)(,(\d+)?)?\}/.exec(v.slice(s)), $, E;
          w !== null ? (d.length === 0 && h(s), $ = parseInt(w[1], 10), E = w[2] ? w[3] ? parseInt(w[3], 10) : 1 / 0 : $, s += w[0].length, d.push({
            type: t.REPETITION,
            min: $,
            max: E,
            value: d.pop()
          })) : d.push({
            type: t.CHAR,
            value: 123
          });
          break;
        case "?":
          d.length === 0 && h(s), d.push({
            type: t.REPETITION,
            min: 0,
            max: 1,
            value: d.pop()
          });
          break;
        case "+":
          d.length === 0 && h(s), d.push({
            type: t.REPETITION,
            min: 1,
            max: 1 / 0,
            value: d.pop()
          });
          break;
        case "*":
          d.length === 0 && h(s), d.push({
            type: t.REPETITION,
            min: 0,
            max: 1 / 0,
            value: d.pop()
          });
          break;
        default:
          d.push({
            type: t.CHAR,
            value: u.charCodeAt(0)
          });
      }
    return p.length !== 0 && e.error(i, "Unterminated group"), c;
  }, bl.exports.types = t, bl.exports;
}
var xm, l2;
function rH() {
  if (l2)
    return xm;
  l2 = 1;
  class e {
    constructor(n, i) {
      this.low = n, this.high = i, this.length = 1 + i - n;
    }
    overlaps(n) {
      return !(this.high < n.low || this.low > n.high);
    }
    touches(n) {
      return !(this.high + 1 < n.low || this.low - 1 > n.high);
    }
    // Returns inclusive combination of SubRanges as a SubRange.
    add(n) {
      return new e(
        Math.min(this.low, n.low),
        Math.max(this.high, n.high)
      );
    }
    // Returns subtraction of SubRanges as an array of SubRanges.
    // (There's a case where subtraction divides it in 2)
    subtract(n) {
      return n.low <= this.low && n.high >= this.high ? [] : n.low > this.low && n.high < this.high ? [
        new e(this.low, n.low - 1),
        new e(n.high + 1, this.high)
      ] : n.low <= this.low ? [new e(n.high + 1, this.high)] : [new e(this.low, n.low - 1)];
    }
    toString() {
      return this.low == this.high ? this.low.toString() : this.low + "-" + this.high;
    }
  }
  class t {
    constructor(n, i) {
      this.ranges = [], this.length = 0, n != null && this.add(n, i);
    }
    _update_length() {
      this.length = this.ranges.reduce((n, i) => n + i.length, 0);
    }
    add(n, i) {
      var s = (a) => {
        for (var u = 0; u < this.ranges.length && !a.touches(this.ranges[u]); )
          u++;
        for (var c = this.ranges.slice(0, u); u < this.ranges.length && a.touches(this.ranges[u]); )
          a = a.add(this.ranges[u]), u++;
        c.push(a), this.ranges = c.concat(this.ranges.slice(u)), this._update_length();
      };
      return n instanceof t ? n.ranges.forEach(s) : (i == null && (i = n), s(new e(n, i))), this;
    }
    subtract(n, i) {
      var s = (a) => {
        for (var u = 0; u < this.ranges.length && !a.overlaps(this.ranges[u]); )
          u++;
        for (var c = this.ranges.slice(0, u); u < this.ranges.length && a.overlaps(this.ranges[u]); )
          c = c.concat(this.ranges[u].subtract(a)), u++;
        this.ranges = c.concat(this.ranges.slice(u)), this._update_length();
      };
      return n instanceof t ? n.ranges.forEach(s) : (i == null && (i = n), s(new e(n, i))), this;
    }
    intersect(n, i) {
      var s = [], a = (u) => {
        for (var c = 0; c < this.ranges.length && !u.overlaps(this.ranges[c]); )
          c++;
        for (; c < this.ranges.length && u.overlaps(this.ranges[c]); ) {
          var l = Math.max(this.ranges[c].low, u.low), d = Math.min(this.ranges[c].high, u.high);
          s.push(new e(l, d)), c++;
        }
      };
      return n instanceof t ? n.ranges.forEach(a) : (i == null && (i = n), a(new e(n, i))), this.ranges = s, this._update_length(), this;
    }
    index(n) {
      for (var i = 0; i < this.ranges.length && this.ranges[i].length <= n; )
        n -= this.ranges[i].length, i++;
      return this.ranges[i].low + n;
    }
    toString() {
      return "[ " + this.ranges.join(", ") + " ]";
    }
    clone() {
      return new t(this);
    }
    numbers() {
      return this.ranges.reduce((n, i) => {
        for (var s = i.low; s <= i.high; )
          n.push(s), s++;
        return n;
      }, []);
    }
    subranges() {
      return this.ranges.map((n) => ({
        low: n.low,
        high: n.high,
        length: 1 + n.high - n.low
      }));
    }
  }
  return xm = t, xm;
}
var Om, f2;
function nH() {
  if (f2)
    return Om;
  f2 = 1;
  const e = tH(), t = rH(), r = e.types;
  return Om = class ou {
    /**
     * @constructor
     * @param {RegExp|String} regexp
     * @param {String} m
     */
    constructor(i, s) {
      if (this._setDefaults(i), i instanceof RegExp)
        this.ignoreCase = i.ignoreCase, this.multiline = i.multiline, i = i.source;
      else if (typeof i == "string")
        this.ignoreCase = s && s.indexOf("i") !== -1, this.multiline = s && s.indexOf("m") !== -1;
      else
        throw new Error("Expected a regexp or string");
      this.tokens = e(i);
    }
    /**
     * Checks if some custom properties have been set for this regexp.
     *
     * @param {RandExp} randexp
     * @param {RegExp} regexp
     */
    _setDefaults(i) {
      this.max = i.max != null ? i.max : ou.prototype.max != null ? ou.prototype.max : 100, this.defaultRange = i.defaultRange ? i.defaultRange : this.defaultRange.clone(), i.randInt && (this.randInt = i.randInt);
    }
    /**
     * Generates the random string.
     *
     * @return {String}
     */
    gen() {
      return this._gen(this.tokens, []);
    }
    /**
     * Generate random string modeled after given tokens.
     *
     * @param {Object} token
     * @param {Array.<String>} groups
     * @return {String}
     */
    _gen(i, s) {
      var a, u, c, l, d;
      switch (i.type) {
        case r.ROOT:
        case r.GROUP:
          if (i.followedBy || i.notFollowedBy)
            return "";
          for (i.remember && i.groupNumber === void 0 && (i.groupNumber = s.push(null) - 1), a = i.options ? this._randSelect(i.options) : i.stack, u = "", l = 0, d = a.length; l < d; l++)
            u += this._gen(a[l], s);
          return i.remember && (s[i.groupNumber] = u), u;
        case r.POSITION:
          return "";
        case r.SET:
          var p = this._expand(i);
          return p.length ? String.fromCharCode(this._randSelect(p)) : "";
        case r.REPETITION:
          for (c = this.randInt(
            i.min,
            i.max === 1 / 0 ? i.min + this.max : i.max
          ), u = "", l = 0; l < c; l++)
            u += this._gen(i.value, s);
          return u;
        case r.REFERENCE:
          return s[i.value - 1] || "";
        case r.CHAR:
          var h = this.ignoreCase && this._randBool() ? this._toOtherCase(i.value) : i.value;
          return String.fromCharCode(h);
      }
    }
    /**
     * If code is alphabetic, converts to other case.
     * If not alphabetic, returns back code.
     *
     * @param {Number} code
     * @return {Number}
     */
    _toOtherCase(i) {
      return i + (97 <= i && i <= 122 ? -32 : 65 <= i && i <= 90 ? 32 : 0);
    }
    /**
     * Randomly returns a true or false value.
     *
     * @return {Boolean}
     */
    _randBool() {
      return !this.randInt(0, 1);
    }
    /**
     * Randomly selects and returns a value from the array.
     *
     * @param {Array.<Object>} arr
     * @return {Object}
     */
    _randSelect(i) {
      return i instanceof t ? i.index(this.randInt(0, i.length - 1)) : i[this.randInt(0, i.length - 1)];
    }
    /**
     * expands a token to a DiscontinuousRange of characters which has a
     * length and an index function (for random selecting)
     *
     * @param {Object} token
     * @return {DiscontinuousRange}
     */
    _expand(i) {
      if (i.type === e.types.CHAR)
        return new t(i.value);
      if (i.type === e.types.RANGE)
        return new t(i.from, i.to);
      {
        let s = new t();
        for (let a = 0; a < i.set.length; a++) {
          let u = this._expand(i.set[a]);
          if (s.add(u), this.ignoreCase)
            for (let c = 0; c < u.length; c++) {
              let l = u.index(c), d = this._toOtherCase(l);
              l !== d && s.add(d);
            }
        }
        return i.not ? this.defaultRange.clone().subtract(s) : this.defaultRange.clone().intersect(s);
      }
    }
    /**
     * Randomly generates and returns a number between a and b (inclusive).
     *
     * @param {Number} a
     * @param {Number} b
     * @return {Number}
     */
    randInt(i, s) {
      return i + Math.floor(Math.random() * (1 + s - i));
    }
    /**
     * Default range of characters to generate from.
     */
    get defaultRange() {
      return this._range = this._range || new t(32, 126);
    }
    set defaultRange(i) {
      this._range = i;
    }
    /**
     *
     * Enables use of randexp with a shorter call.
     *
     * @param {RegExp|String| regexp}
     * @param {String} m
     * @return {String}
     */
    static randexp(i, s) {
      var a;
      return typeof i == "string" && (i = new RegExp(i, s)), i._randexp === void 0 ? (a = new ou(i, s), i._randexp = a) : (a = i._randexp, a._setDefaults(i)), a.gen();
    }
    /**
     * Enables sugary /regexp/.gen syntax.
     */
    static sugar() {
      RegExp.prototype.gen = function() {
        return ou.randexp(this);
      };
    }
  }, Om;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var Pm, d2;
function iH() {
  if (d2)
    return Pm;
  d2 = 1;
  const e = nH(), t = Qt, { copy: r, randomOneOf: n, randomNumber: i, randomText: s } = t;
  Pm = a;
  function a(c, l, d, p, h, v, y, g) {
    const _ = p.type, m = h[v];
    if (m && typeof m == "object") {
      if (d.get(m))
        return;
      d.set(m, !0);
    }
    if (!(g > y.maxDepth)) {
      if (p.hasOwnProperty("default") && Math.random() < y.defaultPossibility)
        h[v] = t.copy(p.default);
      else if (p.enum)
        h[v] = r(n(p.enum));
      else if (p.allOf) {
        const [w, $] = p.allOfMerged;
        $ ? l.nest("Cannot generate random value for schema with allOf").push($) : a(c, l, d, w, h, v, y, g);
      } else if (p.anyOf || p.oneOf) {
        const w = p.anyOf ? "anyOf" : "oneOf";
        if (p.discriminator) {
          const { name: $, key: E, schema: A } = p.discriminate(m, !0);
          if (A)
            a(c, l, d, A, h, v, y, g);
          else if ($ === void 0) {
            const R = n(p[w]);
            a(c, l, d, R, h, v, y, g);
          } else
            c.message('Discriminator property "' + E + '" as "' + $ + '" did not map to a schema');
        } else {
          const $ = n(p[w]);
          a(c, l, d, $, h, v, y, g);
        }
      } else if (p.not)
        l.message("Cannot generate random value for schema with not");
      else if (_ === "array") {
        const w = p.hasOwnProperty("minItems") ? p.minItems : 0;
        let $ = p.hasOwnProperty("maxItems") ? p.maxItems : w + y.arrayVariation - Math.round(0.5 * g);
        $ < w && ($ = w);
        const E = i({ min: w, max: $ });
        if (g > 0 && h.hasOwnProperty(v) && !Array.isArray(h[v]))
          c.message("Provided value is not an array");
        else {
          const A = Array.isArray(m) ? m : [];
          for (let R = 0; R < E; R++) {
            let I = !0, D = y.uniqueItemRetry;
            for (; I && D; ) {
              const J = {};
              a(c.at(R), l.at(R), d, p.items, J, "value", y, g + 1);
              const ae = J.value;
              I = p.uniqueItems && A.findIndex((ye) => t.same(ye, ae)) !== -1, I ? I && !D && l.message("Cannot generate example due to too narrowly scoped schema constraints") : A[R] = ae;
            }
          }
          h[v] = A;
        }
      } else if (_ === "object")
        if (g > 0 && h.hasOwnProperty(v) && !t.isObject(h[v]))
          c.message("Provided value is not a plain object");
        else {
          const w = p.properties ? Object.keys(p.properties) : [], $ = h[v] || {};
          let E = 0;
          p.required && p.required.forEach((I) => {
            const D = w.indexOf(I);
            D !== -1 && w.splice(D, 1);
            let J = p.properties && p.properties[I];
            J || (J = p.additionalProperties), J === !0 && (J = u(p)), a(c.at(I), l.at(I), d, J, $, I, y, g + 1), E++;
          });
          let A = w.length;
          const R = p.hasOwnProperty("maxProperties") ? p.maxProperties : Number.MAX_SAFE_INTEGER;
          for (; A && E < R; ) {
            if (Math.random() < y.definedPropertyPossibility) {
              const I = Math.floor(Math.random() * A), D = w[I];
              a(c.at(D), l.at(D), d, p.properties[D], $, D, y, g + 1), E++;
            }
            A--;
          }
          if (p.additionalProperties) {
            const I = p.hasOwnProperty("minProperties") ? p.minProperties : 0;
            let D = E < I || Math.random() < y.additionalPropertiesPossibility, J = 1;
            for (; D && E < R; ) {
              const ae = "additionalProperty" + J++;
              if (!$.hasOwnProperty(ae)) {
                const ye = p.additionalProperties === !0 ? u(p) : p.additionalProperties;
                a(c.at(ae), l.at(ae), d, ye, $, ae, y, g + 1), E++, D = E < I || Math.random() < y.additionalPropertiesPossibility;
              }
            }
          }
          h[v] = $;
        }
      else if (!h.hasOwnProperty(v) || g === 0) {
        const w = p.enforcerData.staticData.dataTypes, $ = w[p.type] && w[p.type][p.format] || null;
        if ($ && $.random)
          h[v] = $.random({ exception: c, schema: p }, { chooseOne: n, randomNumber: i, randomText: s });
        else if (_ === "boolean")
          h[v] = n([!0, !1]);
        else if (_ === "integer" || _ === "number") {
          const E = _ === "integer" ? 0 : i({ min: 1, max: 4 }), A = !!p.exclusiveMinimum, R = !!p.exclusiveMaximum, I = p.hasOwnProperty("multipleOf") ? p.multipleOf : 0, D = p.hasOwnProperty("minimum"), J = p.hasOwnProperty("maximum");
          let ae, ye;
          D && !J ? (ae = p.minimum, ye = ae + y.numberVariation) : !D && J ? (ye = p.maximum, ae = ye - y.numberVariation) : D && J ? (ae = p.minimum, ye = p.maximum) : (ae = -1 * Math.floor(y.numberVariation * 0.25), ye = Math.ceil(y.numberVariation * 0.75)), h[v] = i({ min: ae, max: ye, multipleOf: I, exclusiveMin: A, exclusiveMax: R, decimalPlaces: E });
        } else if (_ === "string")
          if (p.hasOwnProperty("pattern"))
            h[v] = new e(p.pattern).gen();
          else {
            const E = {};
            p.hasOwnProperty("minLength") && (E.minLength = p.minLength), p.hasOwnProperty("maxLength") && (E.maxLength = p.maxLength), h[v] = s(E);
          }
      }
    }
  }
  function u(c) {
    const l = n([
      { type: "boolean" },
      { type: "integer" },
      { type: "number" },
      { type: "string" },
      { type: "string", format: "date" },
      { type: "string", format: "date-time" }
    ]), [d] = new c.enforcerData.context.Schema(l);
    return d;
  }
  return Pm;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var Sm, p2;
function sH() {
  if (p2)
    return Sm;
  p2 = 1;
  const e = M0(), t = gS(), r = Qt, n = _s();
  Sm = i;
  function i(s, a, u, c) {
    let { serialize: l, value: d } = n.getAttributes(c);
    if (!l)
      return c;
    const p = u.type;
    if (d && typeof d == "object") {
      const v = a.get(u);
      if (v && v.includes(d))
        return d;
      a.set(u, [d]);
    }
    const h = e.runHooks(u, "beforeSerialize", d, s);
    if (d = h.value, h.done)
      return d;
    if (d === null && (u.nullable || u["x-nullable"]))
      return e.after(u, "afterSerialize", d, s);
    if (u.allOf) {
      const v = {}, y = s.nest("Unable to serialize allOf");
      return u.allOf.forEach((g, _) => {
        const m = i(y.at(_), a, g, c);
        Object.assign(v, m);
      }), e.after(u, "afterSerialize", Object.assign(d, v), s);
    } else if (u.anyOf || u.oneOf) {
      let v;
      if (u.discriminator) {
        const { name: y, key: g, schema: _ } = u.discriminate(d, !0);
        _ ? v = Object.assign(d, i(s, a, _, c)) : s.message('Discriminator property "' + g + '" as "' + y + '" did not map to a schema');
      } else
        v = t.anyOneOf(u, c, s, a, i, !0);
      return e.after(u, "afterSerialize", v, s);
    } else if (p === "array") {
      if (Array.isArray(d))
        return u.items && d.forEach((v, y) => {
          d[y] = i(s.at(y), a, u.items, n.inherit(v, { serialize: l }));
        }), e.after(u, "afterSerialize", d, s);
      s.message("Expected an array. Received: " + r.smart(d));
    } else if (p === "object")
      if (r.isObject(d)) {
        const v = u.additionalProperties, y = u.properties || {};
        if (Object.keys(d).forEach((g) => {
          y.hasOwnProperty(g) ? d[g] = i(s.at(g), a, y[g], d[g]) : v && (d[g] = i(s.at(g), a, v, d[g]));
        }), u.discriminator) {
          const { name: g, key: _, schema: m } = u.discriminate(d, !0);
          m ? Object.assign(d, i(s, a, m, c)) : s.message('Discriminator property "' + _ + '" as "' + g + '" did not map to a schema');
        }
        return e.after(u, "afterSerialize", d, s);
      } else
        s.message("Expected an object. Received: " + r.smart(c));
    else if (u !== !0) {
      const v = u.enforcerData.staticData.dataTypes, y = v[u.type] && v[u.type][u.format] || {};
      if (y.serialize || (y.serialize = function({ value: g }) {
        return g;
      }), p === "boolean") {
        let g = y.serialize({
          exception: s,
          schema: u,
          value: d
        });
        return typeof g != "boolean" && s.message("Unable to serialize to a boolean. Received: " + r.smart(d)), e.after(u, "afterSerialize", g, s);
      } else if (p === "integer") {
        let g = y.serialize({
          exception: s,
          schema: u,
          value: d
        });
        return (typeof g != "number" || isNaN(g) || g !== Math.round(g)) && s.message("Unable to serialize to an integer. Received: " + r.smart(d)), e.after(u, "afterSerialize", g, s);
      } else if (p === "number") {
        let g = y.serialize({
          exception: s,
          schema: u,
          value: d
        });
        return (typeof g != "number" || isNaN(g)) && s.message("Unable to serialize to a number. Received: " + r.smart(d)), e.after(u, "afterSerialize", g, s);
      } else if (p === "string") {
        let g = y.serialize({
          exception: s,
          schema: u,
          value: d
        });
        return typeof g != "string" && s.message("Unable to serialize to a string. Received: " + r.smart(d)), e.after(u, "afterSerialize", g, s);
      }
    } else
      return e.after(u, "afterSerialize", d, s);
  }
  return Sm;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var Am, h2;
function aH() {
  if (h2)
    return Am;
  h2 = 1;
  const e = M0(), t = qn, r = Qt, n = _s();
  Am = i;
  function i(a, u, c, l, d) {
    let { validate: p, value: h } = n.getAttributes(l);
    if (!p)
      return l;
    const v = c.type;
    if (h && typeof h == "object") {
      let g = u.get(h);
      if (g && g.indexOf(c) !== -1)
        return;
      g || (g = [], u.set(h, g)), g.push(c);
    }
    const y = e.runHooks(c, "beforeValidate", h, a);
    if (h = y.value, y.done)
      return h;
    if (h === null && (c.nullable || c["x-nullable"]))
      return e.after(c, "afterValidate", h, a);
    if (c.allOf) {
      const g = a.nest("Did not validate against all schemas");
      c.allOf.forEach((_, m) => {
        i(g.at(m), u, _, l, d);
      });
    } else if (c.anyOf)
      if (c.discriminator) {
        const g = c.discriminate(h, !0), _ = g.schema, m = g.key;
        if (!_)
          a.message('Discriminator property "' + m + '" as "' + h[m] + '" did not map to a schema');
        else {
          const w = a.at(h[m]);
          i(w, u, _, h, d);
        }
      } else {
        const g = t("Did not validate against at least one schema"), _ = c.anyOf.length;
        let m = !1;
        for (let w = 0; w < _; w++) {
          const $ = g.at(w);
          if (i($, u, c.anyOf[w], h, d), !$.hasException) {
            m = !0;
            break;
          }
        }
        m || a.push(g);
      }
    else if (c.oneOf)
      if (c.discriminator) {
        const { name: g, key: _, schema: m } = c.discriminate(h, !0);
        if (!m)
          a.message('Discriminator property "' + _ + '" as "' + g + '" did not map to a schema');
        else {
          const w = a.at(h[_]);
          i(w, u, m, h, d);
        }
      } else {
        const g = t("Did not validate against exactly one schema"), _ = c.oneOf.length;
        let m = 0;
        for (let w = 0; w < _; w++) {
          const $ = t("Invalid value");
          i($, u, c.oneOf[w], h, d), $.hasException ? g.at(w).push($) : (m++, g.at(w).message("Valid value"));
        }
        m !== 1 && a.push(g);
      }
    else if (c.not) {
      const g = t("");
      i(g, u, c.not, h, d), g.hasException || a.message("Value should not validate against schema");
    } else if (v === "array")
      if (!Array.isArray(h))
        a.message("Expected an array. Received: " + r.smart(h));
      else {
        const g = h.length;
        if (c.hasOwnProperty("maxItems") && c.maxItems < g && a.message("Too many items in the array. Maximum of " + c.maxItems + ". Found " + g + " items"), c.hasOwnProperty("minItems") && c.minItems > g && a.message("Too few items in the array. Minimum of " + c.minItems + ". Found " + g + " items"), c.uniqueItems) {
          const _ = [];
          h.forEach((m, w) => {
            const $ = _.length;
            let E;
            for (let A = 0; A < $; A++)
              if (r.same(m, _[A])) {
                a.message("Array items must be unique. Value is not unique at index " + w), E = !0;
                break;
              }
            E || _.push(m);
          });
        }
        c.items && h.forEach((_, m) => {
          i(a.at(m), u, c.items, _, d);
        });
      }
    else if (v === "object")
      if (!r.isObject(h))
        a.message("Expected a non-null object. Received: " + r.smart(h));
      else {
        const g = c.properties || {}, _ = d.readWriteMode, m = [], w = c.required ? c.required.filter((E) => {
          const A = g[E];
          return !d.readWriteMode || !A || d.readWriteMode === "write" && !A.readOnly || d.readWriteMode === "read" && !A.writeOnly;
        }) : [], $ = Object.keys(h);
        if ($.forEach((E) => {
          const A = w.indexOf(E);
          if (A !== -1 && w.splice(A, 1), g.hasOwnProperty(E)) {
            const R = g[E];
            (_ === "write" && R.readOnly || _ === "read" && R.writeOnly) && m.push(E), i(a.at(E), u, R, h[E], d);
          } else if (c.additionalProperties === !1)
            a.at(E).message("Property not allowed");
          else if (typeof c.additionalProperties == "object") {
            const R = c.additionalProperties;
            (_ === "write" && R.readOnly || _ === "read" && R.writeOnly) && m.push(E), i(a.at(E), u, c.additionalProperties, h[E], d);
          } else
            d.isExample && N0().config.examplesWarnAdditionalProperty === !0 && a.at(E).message("Property is an additional property");
        }), w.length > 0 && a.message("One or more required properties missing: " + w.join(", ")), m.length > 0 && (_ === "write" ? a.message("Cannot write to read only properties: " + m.join(", ")) : _ === "read" && a.message("Cannot read from write only properties: " + m.join(", "))), s(a, c, "object property count", "maxProperties", "minProperties", !1, $.length, c.maxProperties, c.minProperties), c.discriminator) {
          const E = c.discriminate(h, !0), { name: A, key: R } = E;
          E.schema ? i(a, u, E.schema, h, d) : A && a.message('Discriminator property "' + R + '" as "' + A + '" did not map to a schema');
        }
      }
    else {
      const g = c.enforcerData.staticData.dataTypes, _ = g[c.type] && g[c.type][c.format] || { validate: null };
      if (_.validate)
        _.validate({ exception: a, schema: c, value: h });
      else if (v === "boolean")
        typeof h != "boolean" && a.message("Expected a boolean. Received: " + r.smart(h));
      else if (v === "integer")
        isNaN(h) || Math.round(h) !== h || typeof h != "number" ? a.message("Expected an integer. Received: " + r.smart(h)) : (d.maxMin !== !1 && s(a, c, "integer", "maximum", "minimum", !0, h, c.maximum, c.minimum), c.multipleOf && h % c.multipleOf !== 0 && a.message("Expected a multiple of " + c.multipleOf + ". Received: " + r.smart(h)));
      else if (v === "number")
        isNaN(h) || typeof h != "number" ? a.message("Expected a number. Received: " + r.smart(h)) : (d.maxMin !== !1 && s(a, c, "number", "maximum", "minimum", !0, h, c.maximum, c.minimum), c.multipleOf && !Number.isInteger(h / c.multipleOf) && a.message("Expected a multiple of " + c.multipleOf + ". Received: " + r.smart(h)));
      else if (c.type === "string")
        if (typeof h != "string")
          a.message("Expected a string. Received: " + r.smart(h));
        else {
          const m = h.length;
          c.hasOwnProperty("maxLength") && m > c.maxLength && a.message("String too long. " + r.smart(h) + " (" + m + ") above maximum length of " + c.maxLength), c.hasOwnProperty("minLength") && m < c.minLength && a.message("String too short. " + r.smart(h) + " (" + m + ") below minimum length of " + c.minLength), c.hasOwnProperty("pattern") && !c.pattern.test(h) && a.message("String does not match required pattern " + c.pattern + " with value: " + r.smart(h));
        }
    }
    if (c.enum && d.enum !== !1) {
      const g = c.enum.length;
      let _;
      for (let m = 0; m < g; m++)
        if (r.same(h, c.enum[m])) {
          _ = !0;
          break;
        }
      _ || a.message("Value " + r.smart(h) + " did not meet enum requirements");
    }
    e.after(c, "afterValidate", h, a, !0);
  }
  function s(a, u, c, l, d, p, h, v, y) {
    u.hasOwnProperty(l) && (p && u.exclusiveMaximum && h >= v ? a.message("Expected " + c + " to be less than " + r.smart(u.serialize(u[l]).value) + ". Received: " + r.smart(u.serialize(h).value)) : h > v && a.message("Expected " + c + " to be less than or equal to " + r.smart(u.serialize(u[l]).value) + ". Received: " + r.smart(u.serialize(h).value))), u.hasOwnProperty(d) && (p && u.exclusiveMinimum && h <= y ? a.message("Expected " + c + " to be greater than " + r.smart(u.serialize(u[d]).value) + ". Received: " + r.smart(u.serialize(h).value)) : h < y && a.message("Expected " + c + " to be greater than or equal to " + r.smart(u.serialize(u[d]).value) + ". Received: " + r.smart(u.serialize(h).value)));
  }
  return Am;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var m2;
function y2() {
  return m2 || (m2 = 1, function(e) {
    const t = sr, r = qn, n = lS, i = bs, s = JW(), a = XW(), u = iH(), c = sH(), l = aH(), d = Qt, p = _s(), h = d.freeze, v = /^https?:\/\//, y = {
      colon: w(() => /:([_$a-z][_$a-z0-9]*)/ig),
      doubleHandlebar: w(() => /{{([_$a-z][_$a-z0-9]*)}}/ig),
      handlebar: w(() => /{([_$a-z][_$a-z0-9]*)}/ig)
    }, g = [
      { type: "array", properties: ["items", "maxItems", "minItems", "uniqueItems"] },
      { type: "number", properties: ["exclusiveMaximum", "exclusiveMinimum", "maximum", "minimum", "multpleOf"] },
      { type: "object", properties: ["additionProperties", "maxProperties", "minProperties", "properties"] },
      { type: "string", properties: ["maxLength", "minLength", "pattern"] }
    ], _ = {
      /**
       * Take a serialized (ready for HTTP transmission) value and deserialize it.
       * Converts strings of binary, byte, date, and date-time to JavaScript equivalents.
       * @param {*} value
       * @param {object} [options]
       * @param {boolean} [options.strict=true] Whether to be strict on input when deserializing.
       * @returns {EnforcerResult<*>}
       */
      deserialize: function(re, fe) {
        fe || (fe = {}), fe.hasOwnProperty("strict") || (fe.strict = !0);
        const le = r("Unable to deserialize value"), $e = s(le, /* @__PURE__ */ new Map(), this, d.copy(re), fe);
        return new i($e, le);
      },
      /**
       * Get discriminator key and schema.
       * @param {*} value
       * @param {boolean=false} details
       * @returns {Schema|{ key:string, name:string, schema:Schema }}
       */
      discriminate: function(re, fe) {
        const { major: le, root: $e } = this.enforcerData, Ae = this.discriminator, _e = $e.result;
        let ie, K, V;
        if (Ae) {
          if (le === 2)
            ie = Ae, K = Ae && re && re.hasOwnProperty(Ae) ? re[Ae] : void 0, K && (V = _e.definitions && _e.definitions[K]);
          else if (le === 3 && (ie = Ae.propertyName, K = Ae && re && re.hasOwnProperty(Ae.propertyName) ? re[Ae.propertyName] : void 0, K)) {
            const z = Ae.mapping;
            V = z && z.hasOwnProperty(K) ? z[K] : _e.components && _e.components.schemas && _e.components.schemas[K];
          }
          return fe ? { key: ie, name: K, schema: V } : V;
        }
      },
      /**
       * Take a non plain object and convert it into a plain object far enough so that validation and serialization can occur.
       * @param {*} value
       * @returns {*}
       */
      formalize: function(re) {
        return this.enforcerData.context.Schema.formalize(re);
      },
      /**
       * Populate a value from a list of parameters.
       * @param {object} [params]
       * @param {*} [value]
       * @param {object} [options]
       * @param {boolean} [options.copy=false]
       * @param {boolean} [options.conditions=true]
       * @param {boolean} [options.defaults=true]
       * @param {number} [options.depth=100]
       * @param {string} [options.replacement='handlebar']
       * @param {boolean} [options.templateDefaults=true]
       * @param {boolean} [options.templates=true]
       * @param {boolean} [options.variables=true]
       * @returns {EnforcerResult<*>}
       */
      populate: function(re, fe, le = {}) {
        if (re == null && (re = {}), !re || !d.isObject(re))
          throw Error("Invalid params specified. Must be a plain object");
        if (!le || !d.isObject(le))
          throw Error("Invalid options specified. Must be a plain object");
        if (le.hasOwnProperty("copy") || (le.copy = !1), le.hasOwnProperty("conditions") || (le.conditions = !0), le.hasOwnProperty("defaults") || (le.defaults = !0), le.hasOwnProperty("depth") || (le.depth = 100), le.hasOwnProperty("replacement") || (le.replacement = "handlebar"), le.hasOwnProperty("templateDefaults") || (le.templateDefaults = !0), le.hasOwnProperty("templates") || (le.templates = !0), le.hasOwnProperty("variables") || (le.variables = !0), !d.isInteger(le.depth) || le.depth < 0)
          throw Error("Invalid depth specified. Expected a non-negative integer");
        if (!y.hasOwnProperty(le.replacement))
          throw Error("Invalid replacement type specified. Expected one of: " + Object.keys(y).join(", "));
        le.injector = y[le.replacement], re || (re = {}), le.copy && (fe = d.copy(fe));
        const $e = { value: fe }, Ae = r("Unable to populate value"), _e = r("One or more warnings found while populating value");
        return a(Ae, _e, le.depth - 1, this, re, $e, "value", le), new i($e.value, Ae, _e);
      },
      /**
       * Produce a random value for the schema.
       * @param {*} [value] An initial value to add random values to.
       * @param {object} [options]
       * @param {number} [options.additionalPropertiesPossibility=0]
       * @param {number} [options.arrayVariation=4]
       * @param {boolean} [options.copy=false]
       * @param {number} [options.defaultPossibility=.25]
       * @param {number} [options.definedPropertyPossibility=.80]
       * @param {number} [options.maxDepth=10]
       * @param {number} [options.numberVariation=1000]
       * @param {number} [options.uniqueItemRetry=5]
       * @returns {EnforcerResult<*>}
       */
      random: function(re, fe = {}) {
        if (!fe || !d.isObject(fe))
          throw Error("Invalid options specified. Must be a plain object");
        if (fe.hasOwnProperty("additionalPropertiesPossibility") || (fe.additionalPropertiesPossibility = 0), fe.hasOwnProperty("arrayVariation") || (fe.arrayVariation = 4), fe.hasOwnProperty("copy") || (fe.copy = !1), fe.hasOwnProperty("defaultPossibility") || (fe.defaultPossibility = 0.25), fe.hasOwnProperty("definedPropertyPossibility") || (fe.definedPropertyPossibility = 0.8), fe.hasOwnProperty("maxDepth") || (fe.maxDepth = 10), fe.hasOwnProperty("numberVariation") || (fe.numberVariation = 1e3), fe.hasOwnProperty("uniqueItemRetry") || (fe.uniqueItemRetry = 5), fe.additionalPropertiesPossibility < 0 || fe.additionalPropertiesPossibility > 1)
          throw Error('The option "additionalPropertiesPossibility" must be between 0 and 1 inclusive');
        if (fe.defaultPossibility < 0 || fe.defaultPossibility > 1)
          throw Error('The option "defaultPossibility" must be between 0 and 1 inclusive');
        if (fe.definedPropertyPossibility < 0 || fe.definedPropertyPossibility > 1)
          throw Error('The option "definedPropertyPossibility" must be between 0 and 1 inclusive');
        const le = r("Unable to generate random value"), $e = r("One or more warnings found while generating random value"), Ae = { root: fe.copy ? d.copy(re) : re };
        return u(le, $e, /* @__PURE__ */ new Map(), this, Ae, "root", fe, 0), new i(Ae.root, le, $e);
      },
      /**
       * Take a deserialized (not ready for HTTP transmission) value and serialize it.
       * Converts Buffer and Date objects into string equivalent.
       * @param value
       * @returns {EnforcerResult<*>}
       */
      serialize: function(re) {
        const fe = r("Unable to serialize value"), le = c(fe, /* @__PURE__ */ new Map(), this, d.copy(re));
        return new i(le, fe);
      },
      /**
       * Check to see if the value is valid for this schema.
       * @param {*} value
       * @param {object} [options]
       * @param {string} [options.readWriteMode] Can be undefined, "read", or "write"
       * @returns {EnforcerException|undefined}
       */
      validate: function(re, fe) {
        const le = r("Invalid value");
        if (fe || (fe = {}), l(le, /* @__PURE__ */ new Map(), this, re, fe), le.hasException)
          return le;
      }
    };
    e.exports = {
      init: function(re) {
        const { exception: fe, major: le, plugins: $e, refParser: Ae, staticData: _e, warn: ie, options: K, definition: V } = re, z = K.exceptionSkipCodes, C = K.exceptionEscalateCodes, q = _e.dataTypes, N = q && q[this.type] && q[this.type][this.format] || null;
        if (N && N.validator && N.validator.call(this, re), this.allOf) {
          const F = new r("Unable to merge allOf schemas"), T = new r("One or more warnings produced while merging allOf schemas"), Z = R(F, T, this.allOf.map((k) => k.toObject()), q, le, z, C), Y = {
            exception: F,
            warning: T
          };
          if (!F.hasException) {
            const k = new r("Unable to serialize merged schemas"), U = xe(Z, k, q);
            if (k.hasException)
              F.push(k);
            else {
              const [pe, we] = new re.context.Schema(U);
              we ? (we.title = "One or more error exist when all schemas are considered", F.push(we)) : Y.value = pe;
            }
          }
          Object.defineProperty(this, "allOfMerged", {
            get: () => new i(Y.value, Y.exception, Y.warning)
          });
        }
        if (this.required && this.required.length > 0 && this.additionalProperties !== !1) {
          const F = this.required.slice(0);
          if (Object.keys(this.properties || {}).forEach((T) => {
            const Z = F.indexOf(T);
            Z !== -1 && F.splice(Z, 1);
          }), F.length > 0 && !z.WSCH007 && !d.schemaObjectHasSkipCode(V, "WSCH007")) {
            const T = C.WSCH007 ? fe : ie;
            F.length === 1 ? T.message("Required property not specified as a property but allowed via additionalProperties: " + F[0] + " [WSCH007]") : T.message("Required properties not specified as a property but allowed via additionalProperties: " + F.join(", ") + " [WSCH007]");
          }
        }
        $e.push(() => {
          const F = this.discriminator;
          if (le === 3 && Ae && F && F.mapping) {
            const T = Ae instanceof n, Z = re.definition, Y = this.enforcerData.defToInstanceMap;
            Object.keys(F.mapping).forEach((k) => {
              const U = F.mapping[k];
              let pe;
              if (T) {
                const we = v.test(U) || U.indexOf("/") !== -1 ? U : "#/components/schemas/" + U, He = Ae.getSourceNode(Z);
                pe = Ae.resolvePath(He, we);
              } else {
                const we = v.test(U) || U.indexOf("/") !== -1 ? U : "#/components/schemas/" + U;
                pe = Ae.$refs.get(we);
              }
              je(F.mapping, k, Y.get(pe));
            });
          }
          if (this.hasOwnProperty("enum")) {
            const T = fe.at("enum"), Z = this.enum.map((Y, k) => $(this, T.at(k), Y, {
              enum: !1,
              escalateCodes: C,
              skipCodes: z
            }));
            Object.freeze(Z), je(this, "enum", Z);
          }
          if (this.hasOwnProperty("default")) {
            const T = $(this, fe.at("default"), this.default, {});
            je(this, "default", h(T));
          }
          if (this.hasOwnProperty("example")) {
            const T = new r("Example not valid. [WSCH006]"), Z = $(this, T, this.example, {
              isExample: !0
            });
            T.hasException && !z.WSCH006 && !d.schemaObjectHasSkipCode(V, "WSCH006") && (C.WSCH006 ? fe : ie).at("example").push(T), je(this, "example", h(Z));
          }
        });
      },
      prototype: _,
      statics: function(re) {
        const fe = {}, le = /* @__PURE__ */ new Set(), $e = re.dataTypes = {
          boolean: {},
          integer: {},
          number: {},
          string: {}
        }, Ae = re.hooks = {
          afterDeserialize: [],
          afterSerialize: [],
          afterValidate: [],
          beforeDeserialize: [],
          beforeSerialize: [],
          beforeValidate: []
        };
        return re.dataTypeConstructors = function() {
          return Array.from(le.values());
        }, {
          defineDataTypeFormat: function(_e, ie, K) {
            if (!$e.hasOwnProperty(_e))
              throw Error("Invalid type specified. Must be one of: " + Object.keys($e).join(", "));
            if (!ie || typeof ie != "string")
              throw Error("Invalid format specified. Must be a non-empty string");
            if ($e.hasOwnProperty(ie))
              throw Error('Format "' + ie + '" is already defined');
            if (K !== null) {
              if (typeof K != "object" || typeof K.deserialize != "function" || typeof K.serialize != "function" || typeof K.validate != "function" || K.random && typeof K.random != "function")
                throw Error('Invalid data type definition. Must be an object that defines handlers for "deserialize", "serialize", and "validate" with optional "random" handler.');
              if (K.constructors)
                K.constructors.forEach((V) => {
                  if (typeof V != "function")
                    throw Error("Invalid constructor specified. Expected a function, received: " + V);
                  le.add(V);
                });
              else {
                const V = _e + "-" + ie;
                fe[V] || (fe[V] = !0, console.warn('WARNING: Data type definition missing recommended "constructors" property for type "' + _e + '" and format "' + ie + '".'));
              }
            }
            $e[_e][ie] = Object.assign({}, K, { type: _e, format: ie });
          },
          extractValue: p.extract,
          formalize: function(_e) {
            return _e instanceof this.constructor.Value ? (_e.value = d.toPlainObject(_e.value, {
              preserve: re.dataTypeConstructors()
            }), _e) : d.toPlainObject(_e, {
              preserve: re.dataTypeConstructors()
            });
          },
          hook: function(_e, ie) {
            if (!Ae.hasOwnProperty(_e))
              throw Error("Invalid hook type. Choose one of: " + Object.keys(Ae).join(", "));
            if (typeof ie != "function")
              throw Error("Invalid hook handler. Expected a function. Received: " + d.smart(ie));
            Ae[_e].push(ie);
          },
          unhook: function(_e, ie) {
            const K = Ae[_e] || [], V = K.indexOf(ie);
            V !== -1 && K.splice(V, 1);
          },
          Value: p
        };
      },
      validator: function(re) {
        const { major: fe, options: le, definition: $e } = re, Ae = le.exceptionSkipCodes, _e = le.exceptionEscalateCodes, ie = {
          weight: -8,
          allowed: ({ parent: C }) => ae(C.result),
          type: ({ parent: C }) => ye(C.result),
          deserialize: ({ exception: C, parent: q, result: N }) => {
            const F = s(C, /* @__PURE__ */ new Map(), q.result, N);
            return C.hasException ? N : F;
          },
          errors: ({ exception: C, parent: q, result: N }) => {
            l(C, /* @__PURE__ */ new Map(), q.result, N, { maxMin: !1 });
          }
        }, K = {
          allowed: ({ parent: C }) => C.definition.type === "array",
          type: "number",
          errors: ({ exception: C, result: q }) => {
            (!d.isInteger(q) || q < 0) && C.message("Value must be a non-negative integer");
          }
        }, V = {
          allowed: ({ parent: C }) => C.definition.type === "string" && !ae(C.result),
          type: "number",
          errors: ({ exception: C, result: q }) => {
            (!d.isInteger(q) || q < 0) && C.message("Value must be a non-negative integer");
          }
        }, z = {
          allowed: ({ parent: C }) => C.definition.type === "object",
          type: "number",
          errors: ({ exception: C, result: q }) => {
            (!d.isInteger(q) || q < 0) && C.message("Value must be a non-negative integer");
          }
        };
        return {
          type: "object",
          properties: {
            additionalProperties: t("Schema", {
              allowed: ({ parent: C }) => C.definition.type === "object",
              type: ["boolean", "object"],
              // either boolean or object
              default: !0
            }),
            allOf: {
              type: "array",
              items: t("Schema"),
              errors: ({ exception: C, definition: q }) => {
                const N = {}, F = {};
                q.forEach((Z) => {
                  Z.hasOwnProperty("type") && (N[Z.type] || (N[Z.type] = !0), Z.hasOwnProperty("format") && (Z.format, F[Z.format] = F[Z.format] ? F[Z.format] + 1 : 1));
                });
                const T = Object.keys(F).length;
                q.length === 0 && C.message("Must have at least one item"), Object.keys(N).length > 1 && C.message("All items must be of the same type"), T > 1 && C.message("All items must be of the same format");
              }
            },
            anyOf: {
              allowed: ({ major: C }) => C === 3,
              type: "array",
              items: t("Schema")
            },
            default: {
              freeForm: !0,
              type: ({ parent: C, definition: q }) => {
                const N = C.definition, F = [];
                if (N.type !== void 0)
                  F.push(N.type);
                else if (N.anyOf || N.oneOf) {
                  const T = d.determineSchemaFromSchemas(N.anyOf ?? N.oneOf, q);
                  T === null ? Array.isArray(q) ? F.push("array") : typeof q == "object" ? F.push("object") : F.push(typeof q) : T.type !== void 0 && F.push(T.type);
                } else if (N.allOf) {
                  const T = N.allOf.length;
                  for (let Z = 0; Z < T; Z++) {
                    const Y = N.allOf[Z];
                    if (Y.type !== void 0) {
                      F.push(Y.type);
                      break;
                    }
                  }
                }
                return (N.nullable === !0 || N["x-nullable"] === !0) && F.push("null"), F;
              }
            },
            deprecated: {
              allowed: ({ major: C }) => C === 3,
              type: "boolean",
              default: !1
            },
            description: {
              type: "string"
            },
            discriminator: {
              allowed: ({ parent: C }) => C && C.validator === e.exports.validator && (C.definition.type === "object" || C.definition.anyOf || C.definition.oneOf),
              type: ({ major: C }) => C === 2 ? "string" : "object",
              properties: {
                propertyName: {
                  type: "string",
                  required: !0,
                  errors: ({ definition: C, parent: q }) => {
                    const N = q.parent.definition;
                    N.type === "object" && (!N.required || !N.required.includes(C)) && q.parent.exception.message('Property "' + C + '" must be required because it is used as the discriminator property');
                  }
                },
                mapping: {
                  type: "object",
                  additionalProperties: {
                    type: "string",
                    errors: ({ exception: C, parent: q, refParser: N, result: F }) => {
                      if (N) {
                        let T;
                        if (N instanceof n)
                          try {
                            const Z = v.test(F) || F.indexOf("/") !== -1 ? F : "#/components/schemas/" + F, Y = N.getSourceNode(q.definition);
                            T = N.resolvePath(Y, Z);
                          } catch {
                            C.message("Reference cannot be resolved: " + F);
                          }
                        else
                          try {
                            const Z = v.test(F) || F.indexOf("/") !== -1 ? F : "#/components/schemas/" + F;
                            T = N.$refs.get(Z);
                          } catch {
                            const Y = ". If you are using multiple files to define your OpenAPI document then this may be a limitation of the original dereference function. You can try the custom reference parser (in beta) to see if this resolves the issue.";
                            C.message("Reference cannot be resolved: " + F + Y);
                          }
                        if (T) {
                          const Z = q.parent.parent.definition;
                          Z.anyOf && !Z.anyOf.includes(T) ? C.message("Mapping reference must exist in anyOf: " + F) : Z.oneOf && !Z.oneOf.includes(T) && C.message("Mapping reference must exist in oneOf: " + F);
                        }
                      }
                    }
                  }
                }
              },
              errors: ({ exception: C, major: q, parent: N, definition: F }) => {
                q === 2 ? ((!N.definition.required || !N.definition.required.includes(F)) && C.message('Value "' + F + `" must be found in the parent's required properties list.`), (!N.definition.properties || !N.definition.properties.hasOwnProperty(F)) && C.message('Value "' + F + `" must be found in the parent's properties definition.`)) : q === 3 && F.hasOwnProperty("propertyName") && F.type === "object" && ((!N.definition.required || !N.definition.required.includes(F.propertyName)) && C.message('Value "' + F.propertyName + `" must be found in the parent's required properties list.`), (!N.definition.properties || !N.definition.properties.hasOwnProperty(F.propertyName)) && C.message('Value "' + F.propertyName + `" must be found in the parent's properties definition.`));
              }
            },
            enum: {
              weight: -7,
              type: "array",
              items: {
                allowed: ({ parent: C }) => !!(C && C.parent),
                type: ({ parent: C }) => {
                  const q = C.parent.definition, N = [q.type];
                  return (q.nullable === !0 || q["x-nullable"] === !0) && N.push("null"), N;
                },
                freeForm: !0
              }
            },
            example: {
              allowed: !0,
              freeForm: !0
            },
            exclusiveMaximum: {
              allowed: ({ parent: C }) => ae(C.result),
              type: "boolean",
              errors: ({ exception: C, definition: q, parent: N }) => {
                q && !N.definition.hasOwnProperty("maximum") && C.message("Cannot use exclusiveMaximum without defining a maximum");
              }
            },
            exclusiveMinimum: {
              allowed: ({ parent: C }) => ae(C.result),
              type: "boolean",
              errors: ({ exception: C, definition: q, parent: N }) => {
                q && !N.definition.hasOwnProperty("minimum") && C.message("Cannot use exclusiveMinimum without defining a minimum");
              }
            },
            externalDocs: t("ExternalDocumentation"),
            format: {
              weight: -9,
              allowed: ({ parent: C }) => ["boolean", "integer", "number", "string"].includes(C.definition.type),
              type: "string",
              errors: ({ exception: C, parent: q, warn: N }) => {
                const F = q.definition.format;
                if (F) {
                  const T = q.definition.type, Y = q.staticData.dataTypes[T];
                  !(Y ? Object.keys(Y) : []).includes(F) && !Ae.WSCH001 && !d.schemaObjectHasSkipCode($e, "WSCH001") && (_e.WSCH001 ? C : N).message('Non standard format "' + F + '" used for type "' + T + '". [WSCH001]');
                }
              }
            },
            items: t("Schema", {
              allowed: ({ parent: C }) => C.definition.type === "array",
              required: ({ parent: C }) => C.definition.type === "array"
            }),
            maximum: ie,
            maxItems: K,
            maxLength: V,
            maxProperties: z,
            minimum: ie,
            minItems: K,
            minLength: V,
            minProperties: z,
            multipleOf: {
              allowed: ({ parent: C }) => ["integer", "number"].includes(C.definition.type),
              type: "number"
            },
            not: t("Schema", { allowed: fe === 3 }),
            nullable: {
              allowed: ({ major: C }) => C === 3,
              type: "boolean",
              default: !1
            },
            oneOf: {
              allowed: ({ major: C }) => C === 3,
              type: "array",
              items: t("Schema")
            },
            pattern: {
              allowed: ({ parent: C }) => C.definition.type === "string",
              type: "string",
              deserialize: ({ exception: C, result: q }) => q ? new RegExp(q) : (C.message("Value must be a non-empty string"), /./),
              errors: ({ exception: C, result: q }) => {
                q || C.message("Value must be a non-empty string");
              }
            },
            properties: {
              weight: -5,
              allowed: ({ parent: C }) => C.definition.type === "object",
              type: "object",
              additionalProperties: t("Schema")
            },
            readOnly: {
              allowed: A,
              type: "boolean",
              default: !1,
              errors: ({ major: C, parent: q, definition: N }) => {
                C === 2 && N && q && q.parent && q.parent.parent && q.parent.parent.definition.required && q.parent.parent.definition.required.includes(q.key) && !Ae.WSCH002 && !d.schemaObjectHasSkipCode($e, "WSCH002") && q[_e.WSCH002 ? "exception" : "warn"].message("Property should not be marked as both read only and required. [WSCH002]");
              }
            },
            required: {
              weight: 1,
              allowed: ({ parent: C }) => C.definition.type === "object",
              type: "array",
              items: { type: "string" },
              errors: ({ definition: C, exception: q, parent: N }) => {
                const F = N.definition.additionalProperties, T = N.definition.properties;
                C.forEach((Z) => {
                  (!T || !T[Z]) && !F && q.at(Z).message("Property is listed as required but is not defined in the schema properties and additional properties are not allowed.");
                });
              }
            },
            title: "string",
            type: {
              weight: -10,
              type: "string",
              default: ({ parent: C }) => {
                const q = C.definition;
                if (!(q.hasOwnProperty("allOf") || q.hasOwnProperty("anyOf") || q.hasOwnProperty("not") || q.hasOwnProperty("oneOf"))) {
                  for (let N = g.length; N--; N >= 0) {
                    const F = g[N].type, T = g[N].properties;
                    for (let Z = T.length; Z--; Z >= 0)
                      if (T[Z] in q)
                        return F;
                  }
                  if ("default" in q) {
                    const N = q.default;
                    if (Array.isArray(N))
                      return "array";
                    switch (typeof N) {
                      case "boolean":
                        return "boolean";
                      case "number":
                        return "number";
                      case "object":
                        return "object";
                      case "string":
                        return "string";
                    }
                  }
                  if ("enum" in q) {
                    const N = q.enum[0];
                    if (Array.isArray(N))
                      return "array";
                    switch (typeof N) {
                      case "boolean":
                        return "boolean";
                      case "number":
                        return "number";
                      case "object":
                        return "object";
                      case "string":
                        return "string";
                    }
                  }
                }
              },
              enum: ({ definition: C, exception: q, parent: N }) => {
                const F = e.exports.validator;
                let T = fe === 2, Z = N.parent;
                for (; T && Z; )
                  Z.validator === F && (T = !1), Z = Z.parent;
                return C === "file" && fe === 2 && !T && q.message('Value can only be "file" for non-nested schemas'), T ? ["array", "boolean", "file", "integer", "number", "object", "string"] : ["array", "boolean", "integer", "number", "object", "string"];
              }
            },
            uniqueItems: {
              allowed: ({ parent: C }) => C.definition.type === "array",
              type: "boolean"
            },
            writeOnly: {
              allowed: (C) => C.major === 3 && !!A(C),
              type: "boolean",
              default: !1
            },
            xml: t("Xml")
          },
          errors: (C) => {
            const { exception: q, definition: N, result: F, warn: T } = C;
            if (!N.hasOwnProperty("allOf") && !N.hasOwnProperty("anyOf") && !N.hasOwnProperty("not") && !N.hasOwnProperty("oneOf") && !("type" in N) && !Ae.WSCH005 && !d.schemaObjectHasSkipCode($e, "WSCH005") && (_e.WSCH005 ? q : T).message("Schemas with an indeterminable type cannot serialize, deserialize, or validate values. [WSCH005]"), J(F.minItems, F.maxItems) || q.message('Property "minItems" must be less than or equal to "maxItems"'), J(F.minLength, F.maxLength) || q.message('Property "minLength" must be less than or equal to "maxLength"'), J(F.minProperties, F.maxProperties) || q.message('Property "minProperties" must be less than or equal to "maxProperties"'), F.required && F.hasOwnProperty("maxProperties") && F.required.length > F.maxProperties && q.message('There are more required properties than is allows by "maxProperties" contraint'), !J(F.minimum, F.maximum, F.exclusiveMinimum, F.exclusiveMaximum)) {
              const Y = F.exclusiveMinimum || F.exclusiveMaximum ? "" : "or equal to ";
              q.message('Property "minimum" must be less than ' + Y + '"maximum"');
            }
            F.hasOwnProperty("properties") && Object.keys(F.properties).forEach((Y) => {
              const k = F.properties[Y];
              k.readOnly && k.writeOnly && q.at("properties").at(Y).message("Cannot be marked as both readOnly and writeOnly");
            });
            const Z = [];
            ["allOf", "anyOf", "oneOf", "not"].forEach((Y) => {
              F.hasOwnProperty(Y) && Z.push(Y);
            }), Z.length > 1 && q.message("Cannot have multiple composites: " + Z.join(", "));
          }
        };
      }
    };
    function m(re, fe) {
      const le = "exclusive" + fe[0].toUpperCase() + fe.substring(1), $e = {};
      return $e[le] = !1, re.map((Ae) => Ae.hasOwnProperty(fe) && !Ae.hasOwnProperty(le) ? Object.assign({}, $e, Ae) : Ae);
    }
    function w(re) {
      return function(fe, le) {
        const $e = re();
        let Ae, _e = "", ie = 0;
        for (; Ae = $e.exec(fe); ) {
          const K = Ae[1];
          _e += fe.substring(ie, Ae.index) + (le[K] !== void 0 ? le[K] : Ae[0]), ie = Ae.index + Ae[0].length;
        }
        return _e + fe.substr(ie);
      };
    }
    function $(re, fe, le, $e) {
      let Ae;
      if ([le, Ae] = re.deserialize(le), !Ae) {
        const _e = r("Invalid value");
        l(_e, /* @__PURE__ */ new Map(), re, le, $e), _e.hasException && (Ae = _e);
      }
      return Ae && fe.push(Ae), le;
    }
    function E(re, fe = {}, le = {}) {
      return re.forEach(($e) => {
        $e.hasOwnProperty("format") && (le[$e.format] = !0), $e.hasOwnProperty("type") && (fe[$e.type] = !0), $e.hasOwnProperty("allOf") && E($e.allOf, fe, le);
      }), {
        formats: Object.keys(le),
        types: Object.keys(fe)
      };
    }
    function A({ parent: re }) {
      return re && re.parent && re.parent.key === "properties" && re.parent.parent && re.parent.parent.validator === e.exports.validator;
    }
    function R(re, fe, le, $e, Ae, _e, ie) {
      const { types: K, formats: V } = E(le);
      if (K.length > 1)
        return re.message("All items must be of the same type. Found: " + K.join(", "));
      if (V.length > 1)
        return re.message("All items must be of the same format. Found: " + V.join(", "));
      const z = {};
      le.forEach((Ne) => {
        if (typeof Ne == "object" && Ne !== null) {
          const Le = Ne["x-enforcer-exception-skip-codes"];
          Le !== void 0 && (z["x-enforcer-exception-skip-codes"] === void 0 && (z["x-enforcer-exception-skip-codes"] = ""), z["x-enforcer-exception-skip-codes"] += " " + Le);
        }
      });
      const C = K[0], q = V[0], N = V.length > 0 ? $e[C][V[0]] : null, F = N ? N.isNumeric : !1, T = {};
      C && (T.type = C), q && (T.format = q);
      const Z = Array.from(new Set(le.filter((Ne) => Ne.hasOwnProperty("default")).map((Ne) => Ne.default)));
      Z.length > 1 && !_e.WSCH003 && !d.schemaObjectHasSkipCode(z, "WSCH003") && (ie.WSCH003 ? re : fe).message("Two or more defaults found. Using first default. [WSCH003]"), Z.length > 0 && (T.default = Z[0]);
      let Y = 0;
      const k = re.at("enum"), U = [];
      le.forEach((Ne, Le) => {
        if (Ne.hasOwnProperty("enum"))
          if (Y++, N && N.serialize) {
            const at = Ne.enum.map((mt) => N.serialize({
              exception: k.at(Le),
              schema: Ne,
              value: mt
            }));
            U.push(at);
          } else
            U.push(Ne.enum);
      });
      const pe = {};
      U.forEach((Ne) => {
        Ne.forEach((Le) => {
          pe[Le] ? pe[Le]++ : pe[Le] = 1;
        });
      });
      const He = Object.keys(pe).filter((Ne) => pe[Ne] === Y);
      Y && (He.length === 0 ? re.message("Enum values across schemas have nothing in common") : T.enum = He);
      const Fe = Array.from(new Set(le.filter((Ne) => Ne.hasOwnProperty("example")).map((Ne) => Ne.example)));
      Fe.length > 1 && !_e.WSCH004 && !d.schemaObjectHasSkipCode(z, "WSCH004") && (ie.WSCH004 ? re : fe).message("Two or more examples found. Using first example. [WSCH004]"), Fe.length > 0 && (T.example = Fe[0]);
      const Ge = [], jt = [], Ee = [], Mt = [], St = { hasTrue: !1, hasFalse: !1 };
      if (le.forEach((Ne) => {
        Ne.allOf && Ge.push.apply(Ge, Ne.allOf), Ne.oneOf && Ge.push.apply(jt, Ne.oneOf), Ne.anyOf && Ge.push.apply(Ee, Ne.anyOf), Ne.not && Mt.push(Ne.not), Ne.hasOwnProperty("nullable") && (St[Ne.nullable ? "hasTrue" : "hasFalse"] = !0);
      }), Ge.length && Object.assign(T, R(re.at("allOf"), fe.at("allOf"), Ge, $e, Ae, _e, ie)), jt.length && (T.oneOf = jt), Ee.length && (T.anyOf = Ee), Mt.length === 1 && (T.not = Mt[0]), Mt.length > 1 && (T.not = R(re.at("not"), fe.at("not"), Mt, $e, Ae, _e, ie)), St.hasTrue && St.hasFalse ? re.message("Unable to merge conflicting nullable values") : St.hasTrue ? T.nullable = !0 : St.hasFalse && (T.nullable = !1), I(T, le, "readOnly", D), I(T, le, "writeOnly", D), Ae === 2) {
        const Ne = {};
        le.forEach((at) => {
          at.discriminator && (Ne[at.discriminator] = !0);
        });
        const Le = Object.keys(Ne);
        Le.length === 1 && (T.discriminator = Le[0]), Le.length > 1 && re.message("Unable to merge multiple discriminator values into one");
      } else if (Ae === 3) {
        const Ne = {}, Le = {}, at = [];
        le.forEach((qe) => {
          if (qe.discriminator) {
            const L = qe.discriminator;
            Ne[L.propertyName] = !0, L.mapping && Object.keys(L.mapping).forEach((x) => {
              const S = L.mapping[x];
              Le.hasOwnProperty(x) ? Le[x] !== S && at.push(x) : Le[x] = S;
            });
          }
        });
        const mt = Object.keys(Ne);
        mt.length === 1 && (T.discriminator = mt[0]), mt.length > 1 && re.message("Unable to merge multiple discriminator values into one"), at.length > 0 && re.message("Conflicting discriminator mappings attempt to map different values to same name");
      }
      if (C === "array") {
        const Ne = le.filter((Le) => Le.hasOwnProperty("items")).map((Le) => Le.items);
        T.items = R(re.at("items"), fe.at("items"), Ne, $e, Ae, _e, ie), I(T, le, "maxItems", (Le, at) => ({ value: Le < at ? Le : at })), I(T, le, "minItems", (Le, at) => ({ value: Le > at ? Le : at })), I(T, le, "uniqueItems", D);
      } else if (C === "integer" || C === "number" || F)
        I(T, le, "maximum", (Ne, Le) => ({ value: Ne < Le ? Ne : Le })), I(T, le, "minimum", (Ne, Le) => ({ value: Ne > Le ? Ne : Le })), I(T, le, "multipleOf", (Ne, Le) => ({ value: d.leastCommonMultiple(Ne, Le) })), I(T, m(le, "maximum"), "exclusiveMaximum", (Ne, Le, at, mt, qe) => {
          const L = qe[at].maximum, x = qe[mt].maximum;
          return Ne === !0 && L <= x ? { index: at, value: !0 } : Le === !0 && x <= L ? { index: mt, value: !0 } : L <= x ? { index: at, value: !1 } : { index: mt, value: !1 };
        }), I(T, m(le, "minimum"), "exclusiveMinimum", (Ne, Le, at, mt, qe) => {
          const L = qe[at].minimum, x = qe[mt].minimum;
          return Ne === !0 && L >= x ? { index: at, value: !0 } : Le === !0 && x >= L ? { index: mt, value: !0 } : L >= x ? { index: at, value: !1 } : { index: mt, value: !1 };
        });
      else if (C === "object") {
        const Ne = { true: !1, false: !1 }, Le = le.filter((S) => {
          const G = S.additionalProperties;
          return S.hasOwnProperty("additionalProperties") ? (G === !1 && (Ne.false = !0), G === !0 && (Ne.true = !0), typeof G == "object") : !1;
        }).map((S) => S.additionalProperties);
        Ne.false && (Ne.true || Le.length) ? re.message("Conflict with additionalProperties") : Le.length === 1 ? T.additionalProperties = Le[0] : Le.length > 1 && (T.additionalProperties = R(re.at("additionalProperties"), fe.at("additionalProperties"), Le, $e, Ae, _e, ie));
        const at = re.at("properties"), mt = re.at("properties"), qe = {}, L = {};
        le.forEach((S) => {
          S.hasOwnProperty("properties") && Object.keys(S.properties).forEach((G) => {
            qe[G] || (qe[G] = []), qe[G].push(S.properties[G]);
          }), S.hasOwnProperty("required") && S.required.forEach((G) => {
            L[G] = !0;
          });
        }), Object.keys(qe).forEach((S) => {
          const G = qe[S];
          G.length > 0 && (T.properties || (T.properties = {}), G.length === 1 ? T.properties[S] = G[0] : T.properties[S] = R(at.at(S), mt.at(S), G, $e, Ae, _e, ie));
        });
        const x = Object.keys(L);
        x.length && (T.required = x), I(T, le, "maxProperties", (S, G) => ({ value: S < G ? S : G })), I(T, le, "minProperties", (S, G) => ({ value: S > G ? S : G }));
      } else if (C === "string") {
        const Ne = le.filter((Le) => Le.hasOwnProperty("pattern"));
        Ne.length === 1 ? T.patterns = Ne[0] : Ne.length > 1 && re.message("Unable to merge multiple patterns"), I(T, le, "maxLength", (Le, at) => ({ value: Le < at ? Le : at })), I(T, le, "minLength", (Le, at) => ({ value: Le > at ? Le : at }));
      }
      return T;
    }
    function I(re, fe, le, $e) {
      const Ae = fe.length, _e = [];
      for (let ie = 0; ie < Ae; ie++)
        if (fe[ie].hasOwnProperty(le)) {
          const K = fe[ie][le];
          _e.push({ index: ie, value: K });
        }
      if (_e.length === 1)
        re[le] = _e[0].value;
      else if (_e.length > 1) {
        const ie = _e.length;
        let K = _e[0].value, V = _e[0].index;
        for (let z = 1; z < ie; z++) {
          const C = $e(K, _e[z].value, V, _e[z].index, fe);
          C !== void 0 && (K = C.value, V = C.index);
        }
        re[le] = K;
      }
    }
    function D(re, fe) {
      return { value: re === !0 || fe === !0 };
    }
    function J(re, fe, le, $e) {
      return re === void 0 || fe === void 0 ? !0 : (re = re.valueOf(), fe = fe.valueOf(), re < fe || !le && !$e && re === fe);
    }
    function ae(re) {
      if (["number", "integer"].includes(re.type))
        return !0;
      const fe = re.enforcerData.staticData.dataTypes, le = fe[re.type] && fe[re.type][re.format];
      return !!(le && le.isNumeric);
    }
    function ye(re) {
      const fe = re.enforcerData.staticData.dataTypes, le = fe[re.type] && fe[re.type][re.format];
      if (le && le.isNumeric)
        switch (re.type) {
          case "boolean":
            return "boolean";
          case "string":
            return "string";
          case "integer":
          case "number":
          default:
            return "number";
        }
      else
        return "number";
    }
    function xe(re, fe, le, $e) {
      if (re.pattern && (re.pattern = re.pattern.source), !$e)
        $e = [re];
      else if (!$e.includes(re))
        $e.push(re);
      else
        return re;
      if (re.type === "array" && re.items)
        re.items = xe(re.items, fe.at("items"), le, $e);
      else if (re.type === "object") {
        if (re.additionalProperties && typeof re.additionalProperties == "object" && (re.additionalProperties = xe(re.additionalProperties, fe.at("additionalProperties"), le, $e)), re.properties) {
          const Ae = fe.at("properties");
          Object.keys(re.properties).forEach((_e) => {
            re.properties[_e] = xe(re.properties[_e], Ae.at(_e), le, $e);
          });
        }
      } else {
        const Ae = le.hasOwnProperty(re.type) && le[re.type].hasOwnProperty(re.format) && le[re.type][re.format];
        Ae && Ae.serialize && ["default", "maximum", "minimum", "multipleOf"].forEach((_e) => {
          re.hasOwnProperty(_e) && (re[_e] = Ae.serialize({
            exception: fe.at(_e),
            schema: re,
            value: re[_e]
          }));
        });
      }
      return re;
    }
    function je(re, fe, le) {
      Object.defineProperty(re, fe, {
        configurable: !0,
        enumerable: !0,
        value: le
      });
    }
  }(gm)), gm.exports;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var Cm, g2;
function v2() {
  return g2 || (g2 = 1, Cm = {
    init: function(e) {
    },
    prototype: {},
    validator: function({ major: e, root: t }) {
      return {
        type: "object",
        additionalProperties: {
          type: "array",
          items: {
            type: "string"
          },
          errors: ({ exception: r, parent: n, definition: i }) => {
            t.definition && Object.keys(n.definition).forEach((s) => {
              let a;
              if (e === 2 ? (a = t.definition && t.definition.securityDefinitions && t.definition.securityDefinitions[s], a || r.at(s).message("Security requirement name must be defined at the document root under the securityDefinitions")) : e === 3 && (a = t.definition && t.definition.components && t.definition.components.securitySchemes && t.definition.components.securitySchemes[s], a || r.at(s).message("Security requirement name must be defined at the document root under the components/securitySchemes")), a)
                if (a.type === "oauth2") {
                  let u;
                  e === 2 ? u = a.scopes && Object.keys(a.scopes) || [] : e === 3 && (u = [], Object.keys(a.flows || {}).forEach((c) => {
                    const l = a.flows[c];
                    l.scopes && u.push(...Object.keys(l.scopes));
                  })), i.forEach((c) => {
                    if (!u.includes(c)) {
                      const l = e === 2 ? "securityDefinitions" : "securitySchemes";
                      r.at(s).message("Oauth2 scope not defined in " + l);
                    }
                  });
                } else
                  i.length > 0 && a.type !== "openIdConnect" && r.at(s).message("Security requirement for " + a.type + " value must be an empty array");
            });
          }
        }
      };
    }
  }), Cm;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var Rm, b2;
function _2() {
  if (b2)
    return Rm;
  b2 = 1;
  const e = sr;
  return Rm = {
    init: function(t) {
    },
    prototype: {},
    validator: function({ major: t }) {
      return {
        type: "object",
        properties: {
          authorizationUrl: {
            allowed: ({ parent: r }) => t === 2 && r.definition.type === "oauth2",
            required: ({ parent: r }) => ["implicit", "accessCode"].includes(r.definition.flow),
            type: "string"
          },
          bearerFormat: {
            allowed: ({ parent: r }) => t === 3 && r.definition.type === "http",
            type: "string"
          },
          description: "string",
          flow: {
            allowed: ({ parent: r }) => t === 2 && r.definition.type === "oauth2",
            required: !0,
            type: "string",
            enum: ["implicit", "password", "application", "accessCode"]
          },
          flows: e("OAuthFlows", {
            allowed: ({ parent: r }) => t === 3 && r.definition.type === "oauth2"
          }),
          in: {
            allowed: ({ parent: r }) => r.definition.type === "apiKey",
            required: !0,
            type: "string",
            enum: t === 2 ? ["query", "header"] : ["query", "header", "cookie"]
          },
          name: {
            allowed: ({ parent: r }) => r.definition.type === "apiKey",
            required: !0,
            type: "string"
          },
          openIdConnectUrl: {
            allowed: t === 3,
            required: ({ parent: r }) => r.definition.type === "openIdConnect",
            type: "string"
          },
          scheme: {
            allowed: ({ parent: r }) => t === 3 && r.definition.type === "http",
            required: !0,
            type: "string"
          },
          scopes: {
            allowed: ({ parent: r }) => t === 2 && r.definition.type === "oauth2",
            type: "object",
            required: !0,
            additionalProperties: {
              type: "string"
            }
          },
          tokenUrl: {
            allowed: ({ parent: r }) => t === 2 && r.definition.type === "oauth2",
            required: ({ parent: r }) => ["password", "application", "accessCode"].includes(r.definition.flow)
          },
          type: {
            weight: -10,
            required: !0,
            type: "string",
            enum: t === 2 ? ["basic", "apiKey", "oauth2"] : ["apiKey", "http", "oauth2", "openIdConnect"]
          }
        }
      };
    }
  }, Rm;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var Tm, w2;
function bS() {
  if (w2)
    return Tm;
  w2 = 1;
  const e = sr, t = qn, r = bs, n = Sf(), i = Qt, s = /^((?:https?|wss?):\/\/)?(.+?)(\/.+)?$/, a = /^\d+\.\d+\.\d+$/;
  return Tm = {
    init: function(u) {
    },
    prototype: {
      /**
       * Get path parameters and operation from a method and path.
       * @param {string} method
       * @param {string} path
       * @returns {EnforcerResult<{operation:OperationEnforcer, params:Object}>}
       */
      path: function(u, c) {
        const l = t("Request has one or more errors");
        c = this.enforcerData.options.disablePathNormalization ? c.split("?")[0] : i.edgeSlashes(c.split("?")[0], !0, !1), u = u.toLowerCase();
        const d = this.paths.findMatches(c);
        if (d.length === 0)
          return l.message("Path not found"), l.statusCode = 404, new r(void 0, l);
        const p = d.find((_) => _.path.methods.includes(u));
        if (!p) {
          const _ = /* @__PURE__ */ new Set();
          return d.forEach((m) => {
            m.path.methods.forEach((w) => {
              _.add(w.toUpperCase());
            });
          }), l.message("Method not allowed: " + u.toUpperCase()), l.statusCode = 405, l.pathItem = d[0].path, l.pathItems = d.map((m) => m.path), l.headers = { Allow: Array.from(_).join(", ") }, new r(void 0, l);
        }
        const v = p.path[u], y = v.parametersMap.path, g = p.params;
        if (y) {
          const _ = l.nest("Error in one or more path parameters");
          Object.keys(y).forEach((m) => {
            const w = y[m], $ = y[m].schema;
            let E = w.parse(g[m]);
            E.error || (E = $.deserialize(E.value)), E.error || (E.error = $.validate(E.value)), E.error ? _.at(m).push(E.error) : g[m] = E.value;
          });
        }
        return l.hasException && (l.statusCode = 400, l.operation = v, l.pathKey = p.pathKey), new r({
          operation: v,
          params: g,
          pathKey: p.pathKey
        }, l);
      },
      /**
       * Deserialize and validate a request.
       * @param {object} [request]
       * @param {object|string} [request.body]
       * @param {Object<string,string>} [request.headers={}] The request headers
       * @param {string} [request.method='get']
       * @param {string} [request.path='/']
       * @param {Object<string,string>} [request.query] Will be overwritten if the path includes query string parameters.
       * @param {object} [options]
       * @param {boolean,string[]} [options.allowOtherQueryParameters=false] Allow query parameter data that is not specified in the OAS document
       * @returns {EnforcerResult<{ body:*, cookie:object, headers:object, operation: Operation, path:object, query:object, response:function }>}
       */
      request: function(u, c) {
        if (u = this.toRequestObject(u), !u || typeof u != "object")
          throw Error("Invalid request. Expected a non-null object. Received: " + u);
        if (u.hasOwnProperty("body") && !(typeof u.body == "string" || typeof u.body == "object"))
          throw Error("Invalid body provided");
        if (u.hasOwnProperty("headers") && !i.isObjectStringMap(u.headers))
          throw Error("Invalid request headers. Expected an object with string keys and string values");
        if (u.hasOwnProperty("method") && typeof u.method != "string")
          throw Error("Invalid request method. Expected a string");
        if (!u.hasOwnProperty("path"))
          throw Error("Missing required request path");
        if (typeof u.path != "string")
          throw Error("Invalid request path. Expected a string");
        if (u.hasOwnProperty("query") && !i.isObjectStringMap(u.query))
          throw Error("Invalid request query. Expected an object with string keys and string values");
        if (c || (c = {}), typeof c != "object")
          throw Error("Invalid options. Expected an object. Received: " + c);
        c = Object.assign({}, c), c.hasOwnProperty("allowOtherQueryParameters") || (c.allowOtherQueryParameters = !1), c.pathParametersProcessed = !0;
        const l = u.hasOwnProperty("method") ? u.method.toLowerCase() : "get";
        let [d, p] = u.path.split("?");
        !p && u.hasOwnProperty("query") && (p = i.toQueryString(u.query));
        const h = this.enforcerData.options.disablePathNormalization ? d : i.edgeSlashes(d, !0, !1), [v, y] = this.path(l, h);
        if (y)
          return new r(void 0, y);
        const { operation: g, params: _, pathKey: m } = v, w = {
          headers: u.headers || {},
          path: _,
          query: p || ""
        };
        u.hasOwnProperty("body") && (w.body = u.body);
        const $ = g.request(w, c);
        return $.value ? ($.value.operation = g, $.value.response = (E, A, R = {}) => {
          if (R = i.lowerCaseObjectProperties(R), !R["content-type"] && w.headers.accept) {
            const I = g.getResponseContentTypeMatches(E, w.headers.accept);
            I.length && (R["content-type"] = I[0]);
          }
          return g.response(E, A, R);
        }, $.value.pathKey = m) : ($.error.statusCode = 400, $.error.operation = g, $.error.pathKey = v.pathKey), $;
      },
      toRequestObject: n.prototype.toRequestObject
    },
    validator: function({ major: u }) {
      return {
        type: "object",
        properties: {
          basePath: {
            allowed: u === 2,
            type: "string",
            errors: ({ exception: c, definition: l }) => {
              l[0] !== "/" && c.message("Value must start with a forward slash");
            }
          },
          components: e("Components", { weight: -1, allowed: u === 3 }),
          consumes: {
            allowed: u === 2,
            type: "array",
            items: {
              type: "string"
            }
          },
          definitions: {
            weight: -1,
            allowed: u === 2,
            type: "object",
            additionalProperties: e("Schema")
          },
          host: {
            type: "string",
            allowed: u === 2,
            errors: ({ exception: c, definition: l }) => {
              const d = s.exec(l);
              d && (d[1] && c.message("Value must not include the scheme: " + d[1]), d[3] && c.message("Value must not include sub path: " + d[3]));
            }
          },
          info: e("Info", { required: !0 }),
          openapi: {
            allowed: u === 3,
            required: !0,
            type: "string",
            errors: ({ exception: c, definition: l }) => {
              a.test(l) || c.message("Value must be a semantic version number");
            }
          },
          parameters: {
            allowed: u === 2,
            type: "object",
            additionalProperties: e("Parameter")
          },
          paths: e("Paths", { required: !0 }),
          produces: {
            allowed: u === 2,
            type: "array",
            items: {
              type: "string"
            }
          },
          responses: {
            allowed: u === 2,
            type: "object",
            additionalProperties: e("Response")
          },
          schemes: {
            allowed: u === 2,
            type: "array",
            items: {
              type: "string",
              enum: ["http", "https", "ws", "wss"]
            }
          },
          security: {
            type: "array",
            items: e("SecurityRequirement")
          },
          securityDefinitions: {
            allowed: u === 2,
            type: "object",
            additionalProperties: e("SecurityScheme")
          },
          servers: {
            allowed: u === 3,
            type: "array",
            items: e("Server")
          },
          swagger: {
            allowed: u === 2,
            required: !0,
            type: "string",
            enum: ["2.0"]
          },
          tags: {
            type: "array",
            items: e("Tag")
          },
          externalDocs: e("ExternalDocumentation")
        }
      };
    }
  }, Tm;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var Im, $2;
function oH() {
  return $2 || ($2 = 1, Im = bS()), Im;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var jm, E2;
function x2() {
  if (E2)
    return jm;
  E2 = 1;
  const e = sr;
  return jm = {
    init: function(t) {
    },
    prototype: {},
    validator: function(t) {
      return {
        type: "object",
        properties: {
          name: {
            required: !0,
            type: "string"
          },
          description: "string",
          externalDocs: e("ExternalDocumentation")
        }
      };
    }
  }, jm;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var km, O2;
function P2() {
  return O2 || (O2 = 1, km = {
    init: function(e) {
    },
    prototype: {},
    validator: function() {
      return {
        type: "object",
        properties: {
          name: "string",
          namespace: "string",
          prefix: "string",
          attribute: {
            type: "boolean",
            default: !1
          },
          wrapped: {
            type: "boolean",
            default: !1
          }
        }
      };
    }
  }), km;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var Mm, S2;
function uH() {
  if (S2)
    return Mm;
  S2 = 1;
  const e = sr;
  return Mm = {
    init: function(t) {
    },
    prototype: {},
    validator: function() {
      return {
        type: "object",
        additionalProperties: e("PathItem")
      };
    }
  }, Mm;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var Nm, A2;
function cH() {
  if (A2)
    return Nm;
  A2 = 1;
  const e = sr;
  return Nm = {
    init: function(t) {
    },
    prototype: {},
    validator: function({ major: t }) {
      return {
        allowed: t === 3,
        type: "object",
        properties: {
          callbacks: {
            type: "object",
            additionalProperties: e("Callback")
          },
          examples: {
            type: "object",
            additionalProperties: e("Example")
          },
          headers: {
            type: "object",
            additionalProperties: e("Header")
          },
          links: {
            type: "object",
            additionalProperties: e("Link")
          },
          parameters: {
            type: "object",
            additionalProperties: e("Parameter")
          },
          requestBodies: {
            type: "object",
            additionalProperties: e("RequestBody")
          },
          responses: {
            type: "object",
            additionalProperties: e("Response")
          },
          schemas: {
            type: "object",
            additionalProperties: e("Schema")
          },
          securitySchemes: {
            type: "object",
            additionalProperties: e("SecurityScheme")
          }
        }
      };
    }
  }, Nm;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var Dm, C2;
function lH() {
  if (C2)
    return Dm;
  C2 = 1;
  const e = sr, t = /^([a-z-]+)\/(\*|[a-z-]+)(?:\+([a-z-]+))?/;
  return Dm = {
    init: function(r) {
    },
    prototype: {},
    validator: function(r) {
      return {
        type: "object",
        allowed: ({ exception: n, key: i, parent: s }) => {
          const a = s && s.parent && s.parent.definition && s.parent.definition.schema;
          return a && a.type === "object" && a.properties && a.properties.hasOwnProperty(i) ? !0 : "Encoding property " + i + " not found among schema object properties";
        },
        properties: {
          allowReserved: {
            type: "boolean",
            ignored: ({ parent: n }) => n.parent.parent.key !== "application/x-www-form-urlencoded",
            default: !1
          },
          contentType: {
            type: "string",
            default: ({ parent: n }) => {
              const i = n.key, s = n.parent.parent.definition.schema.properties[i];
              if (s.type === "string" && s.format === "binary")
                return "application/octet-stream";
              if (s.type === "object")
                return "application/json";
              if (s.type === "array") {
                const a = s.items;
                if (a.type === "string" && a.format === "binary")
                  return "application/octet-stream";
                if (a.type === "object" || a.type === "array")
                  return "application/json";
              }
              return "text/plain";
            },
            errors: ({ exception: n, definition: i }) => {
              t.test(i) || n.message("Value is not a valid content-type");
            }
          },
          headers: {
            ignored: ({ parent: n }) => !n.parent.parent.key.startsWith("multipart/"),
            type: "object",
            additionalProperties: e("Header", {
              ignored: ({ key: n }) => n.toLowerCase() === "content-type"
            })
          },
          style: {
            weight: -5,
            type: "string",
            ignored: ({ parent: n }) => n.parent.parent.key !== "application/x-www-form-urlencoded",
            default: "form",
            enum: ["form", "spaceDelimited", "pipeDelimited", "deepObject"],
            errors: ({ exception: n, parent: i, definition: s }) => {
              const a = i.parent.parent.definition.schema.type;
              if (!a || !s)
                return !1;
              i.definition.in === "query" && s !== "form" && !(s === "spaceDelimited" && a === "array") && !(s === "pipeDelimited" && a === "array") && !(s === "deepObject" && a === "object") && n.message('Style "' + s + '" is incompatible with schema type: ' + a);
            }
          },
          explode: {
            type: "boolean",
            ignored: ({ parent: n }) => n.parent.parent.key !== "application/x-www-form-urlencoded",
            default: ({ parent: n }) => n.definition.style === "form"
          }
        }
      };
    }
  }, Dm;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var Lm, R2;
function fH() {
  return R2 || (R2 = 1, Lm = {
    init: function(e) {
    },
    prototype: {},
    validator: function(e) {
      return {
        type: "object",
        properties: {
          summary: { type: "string" },
          description: { type: "string" },
          value: { allowed: !0, freeForm: !0 },
          externalValue: { type: "string" }
        },
        errors: ({ exception: t, definition: r }) => {
          r.hasOwnProperty("value") && r.hasOwnProperty("externalValue") && t.message('Cannot have both "externalValue" and "value" properties');
        }
      };
    }
  }), Lm;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var qm, T2;
function dH() {
  if (T2)
    return qm;
  T2 = 1;
  const e = sr;
  return qm = {
    init: function(t) {
    },
    prototype: {},
    validator: function(t) {
      return {
        type: "object",
        properties: {
          description: {
            type: "string"
          },
          operationRef: {
            type: "string"
          },
          operationId: {
            type: "string"
          },
          parameters: {
            type: "object",
            additionalProperties: !0
          },
          requestBody: {},
          server: e("Server")
        },
        errors: ({ definition: r, exception: n }) => {
          r.hasOwnProperty("operationRef") && r.hasOwnProperty("operationId") && n.message("Must not define both operationId and operationRef");
        }
      };
    }
  }, qm;
}
var Fm = { exports: {} };
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var Um, I2;
function _S() {
  if (I2)
    return Um;
  I2 = 1;
  const e = sr;
  return Um = {
    init: function(t) {
    },
    prototype: {},
    validator: function({ major: t }) {
      return {
        allowed: t === 3,
        type: "object",
        properties: {
          description: {
            type: "string"
          },
          content: {
            type: "object",
            required: !0,
            additionalProperties: e("MediaType")
          },
          required: {
            type: "boolean",
            default: !1
          }
        }
      };
    }
  }, Um;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var j2;
function pH() {
  return j2 || (j2 = 1, function(e) {
    const t = sr, r = _S(), n = Qt, i = /(?:^multipart\/)|(?:^application\/x-www-form-urlencoded$)/;
    e.exports = {
      init: function(s) {
        const { exception: a, warn: u, plugins: c, options: l } = s;
        c.push(() => {
          n.validateExamples(this, a, u, l);
        });
      },
      prototype: {},
      validator: function(s) {
        const a = s.options.exceptionEscalateCodes, u = s.options.exceptionSkipCodes, c = s.definition;
        return {
          type: "object",
          properties: {
            encoding: {
              type: "object",
              allowed: ({ parent: l }) => l.parent.parent.validator === r.validator,
              additionalProperties: t("Encoding"),
              errors: ({ exception: l, parent: d }) => {
                i.test(d.key) || l.message("Mime type must be multipart/* or application/x-www-form-urlencoded. Found: " + d.key);
              }
            },
            example: { allowed: !0, freeForm: !0 },
            examples: {
              type: "object",
              additionalProperties: t("Example")
            },
            schema: t("Schema")
          },
          errors: ({ parent: l, key: d, exception: p, warn: h }) => {
            l && l.key === "content" && !e.exports.rx.mediaType.test(d) && !u.WMED001 && !n.schemaObjectHasSkipCode(c, "WMED001") && (a.WMED001 ? p : h).message("Media type appears invalid. [WMED001]");
          }
        };
      },
      rx: {
        mediaType: /^(?:\*|(application|audio|example|font|image|message|model|multipart|text|video|x-\S+))\/(?:\*|(?:([\w.\-]+)\+)?([\w.\-]+)(?:; *(.+))?)$/
      }
    };
  }(Fm)), Fm.exports;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var Bm, k2;
function hH() {
  return k2 || (k2 = 1, Bm = {
    init: function(e) {
    },
    prototype: {},
    validator: function(e) {
      return {
        type: "object",
        properties: {
          authorizationUrl: {
            allowed: ({ parent: t }) => t && ["implicit", "authorizationCode"].includes(t.key),
            required: !0,
            type: "string"
          },
          refreshUrl: {
            type: "string"
          },
          scopes: {
            required: !0,
            type: "object",
            additionalProperties: {
              type: "string"
            }
          },
          tokenUrl: {
            allowed: ({ parent: t }) => t && ["password", "clientCredentials", "authorizationCode"].includes(t.key),
            required: !0,
            type: "string"
          }
        }
      };
    }
  }), Bm;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var Vm, M2;
function mH() {
  if (M2)
    return Vm;
  M2 = 1;
  const e = sr;
  return Vm = {
    init: function(t) {
    },
    prototype: {},
    validator: function(t) {
      return {
        type: "object",
        properties: {
          authorizationCode: e("OAuthFlow"),
          clientCredentials: e("OAuthFlow"),
          implicit: e("OAuthFlow"),
          password: e("OAuthFlow")
        }
      };
    }
  }, Vm;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var Zm, N2;
function yH() {
  if (N2)
    return Zm;
  N2 = 1;
  const e = sr;
  return Zm = {
    init: function(t) {
    },
    prototype: {},
    validator: function(t) {
      return {
        type: "object",
        properties: {
          description: {
            type: "string"
          },
          url: {
            type: "string",
            required: !0
          },
          variables: e("ServerVariable")
        }
      };
    }
  }, Zm;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var zm, D2;
function gH() {
  return D2 || (D2 = 1, zm = {
    init: function(e) {
    },
    prototype: {},
    validator: function(e) {
      return {
        type: "object",
        additionalProperties: {
          type: "object",
          properties: {
            default: {
              type: "string",
              required: !0
            },
            description: {
              type: "string"
            },
            enum: {
              type: "array",
              items: {
                type: "string"
              }
            }
          }
        }
      };
    }
  }), zm;
}
const vH = "openapi-enforcer", bH = "1.22.3", _H = "Library for validating, parsing, and formatting data against open api schemas.", wH = "index.js", $H = {
  test: "tests"
}, EH = {
  test: "mocha --recursive test",
  coverage: "nyc --reporter=html npm test",
  "coverage:report": "nyc npm test && nyc report --reporter=text-lcov | coveralls",
  "coverage:watch": "chokidar 'test/**/*' 'bin/**/*' -c 'npm run coverage'",
  "docs:build": "markdown-docs build docs-src docs",
  "docs:dev": "markdown-docs dev docs-src",
  prepublishOnly: "npm test"
}, xH = {
  type: "git",
  url: "git+https://github.com/byu-oit/openapi-enforcer.git"
}, OH = "openapi-enforcer.d.ts", PH = [
  "openapi",
  "swagger",
  "validate",
  "response",
  "build",
  "compose",
  "parse",
  "format",
  "deserialize",
  "serialize",
  "request validation",
  "request parsing",
  "response validation",
  "response serializing",
  "utility",
  "utils",
  "plugable"
], SH = "James Speirs", AH = "Apache-2.0", CH = {
  url: "https://github.com/byu-oit/openapi-enforcer/issues"
}, RH = "https://openapi-enforcer.com", TH = {
  chai: "^4.3.4",
  coveralls: "^3.1.1",
  mocha: "^9.1.3",
  nyc: "^15.1.0"
}, IH = {
  "js-yaml": "^4.1.0",
  randexp: "^0.5.3"
}, jH = {
  name: vH,
  version: bH,
  description: _H,
  main: wH,
  directories: $H,
  scripts: EH,
  repository: xH,
  types: OH,
  keywords: PH,
  author: SH,
  license: AH,
  bugs: CH,
  homepage: RH,
  devDependencies: TH,
  dependencies: IH
};
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var Wm, L2;
function N0() {
  if (L2)
    return Wm;
  L2 = 1, Wm = a;
  const e = oc, t = qn, r = lS, n = bs, i = GW, s = Qt;
  async function a(l, d) {
    let p, h = t("One or more warnings exist int he OpenAPI definition");
    d = Object.assign({}, d), d.hasOwnProperty("hideWarnings") || (d.hideWarnings = !1), d.hasOwnProperty("fullResult") || (d.fullResult = !1), d.hasOwnProperty("componentOptions") || (d.componentOptions = {});
    let v;
    l = s.copy(l);
    const y = new r(l), [g, _] = await y.dereference();
    if (l = g, v = _, !v) {
      v = t("One or more errors exist in the OpenAPI definition");
      const m = l.hasOwnProperty("swagger");
      if (!m && !l.hasOwnProperty("openapi"))
        v.message('Missing required "openapi" or "swagger" property');
      else {
        const w = /^(\d+)(?:\.(\d+))(?:\.(\d+))?$/.exec(l.swagger || l.openapi);
        w ? [p, v, h] = (+w[1] === 2 ? a.v2_0.Swagger : a.v3_0.OpenApi)(l, y, d.componentOptions) : v.at(m ? "swagger" : "openapi").message("Invalid value");
      }
    }
    if (d.fullResult)
      return new n(p, v, h);
    if (!d.hideWarnings && h && h.hasException && console.warn(h.toString()), v && v.hasException)
      throw Error(v.toString());
    return p.getBundledDefinition = async function() {
      const m = await y.bundle();
      if (m.error)
        throw Error(m.error);
      return m.value;
    }, p;
  }
  a.config = {
    examplesWarnAdditionalProperty: !0,
    useCaseSensitivePaths: !0,
    useNewRefParser: !1
  }, a.bundle = async function(l) {
    const p = await new r(l).bundle();
    if (a.config.useNewRefParser)
      return p;
    {
      const [h, v] = p;
      if (v)
        throw v;
      return h;
    }
  }, a.dereference = async function(l) {
    const p = await new r(l).dereference();
    if (a.config.useNewRefParser)
      return p;
    {
      const [h, v] = p;
      if (v)
        throw v;
      return h;
    }
  }, a.Enforcer = a, a.Exception = t, a.Result = n, a.toPlainObject = s.toPlainObject;
  const u = a.v2_0 = {};
  Object.defineProperty(u, "version", { value: "2.0" }), Object.assign(u, {
    Contact: i(u, "Contact", T$()),
    ExternalDocumentation: i(u, "ExternalDocumentation", j$()),
    Header: i(u, "Header", N$()),
    Info: i(u, "Info", L$()),
    License: i(u, "License", F$()),
    Operation: i(u, "Operation", Sf()),
    Parameter: i(u, "Parameter", Z$()),
    PathItem: i(u, "PathItem", W$()),
    Paths: i(u, "Paths", G$()),
    Reference: i(u, "Reference", Y$()),
    Response: i(u, "Response", X$()),
    Responses: i(u, "Responses", e2()),
    Schema: i(u, "Schema", y2()),
    SecurityRequirement: i(u, "SecurityRequirement", v2()),
    SecurityScheme: i(u, "SecurityScheme", _2()),
    Swagger: i(u, "Swagger", oH()),
    Tag: i(u, "Tag", x2()),
    Xml: i(u, "Xml", P2())
  });
  const c = a.v3_0 = {};
  return Object.defineProperty(c, "version", { value: "3.0" }), Object.assign(c, {
    Callback: i(c, "Callback", uH()),
    Components: i(c, "Components", cH()),
    Contact: i(c, "Contact", T$()),
    Encoding: i(c, "Encoding", lH()),
    Example: i(c, "Example", fH()),
    ExternalDocumentation: i(c, "ExternalDocumentation", j$()),
    Header: i(c, "Header", N$()),
    Info: i(c, "Info", L$()),
    License: i(c, "License", F$()),
    Link: i(c, "Link", dH()),
    MediaType: i(c, "MediaType", pH()),
    OAuthFlow: i(c, "OAuthFlow", hH()),
    OAuthFlows: i(c, "OAuthFlows", mH()),
    OpenApi: i(c, "OpenApi", bS()),
    Operation: i(c, "Operation", Sf()),
    Parameter: i(c, "Parameter", Z$()),
    PathItem: i(c, "PathItem", W$()),
    Paths: i(c, "Paths", G$()),
    Reference: i(c, "Reference", Y$()),
    RequestBody: i(c, "RequestBody", _S()),
    Response: i(c, "Response", X$()),
    Responses: i(c, "Responses", e2()),
    Schema: i(c, "Schema", y2()),
    SecurityRequirement: i(c, "SecurityRequirement", v2()),
    SecurityScheme: i(c, "SecurityScheme", _2()),
    Server: i(c, "Server", yH()),
    ServerVariable: i(c, "ServerVariable", gH()),
    Tag: i(c, "Tag", x2()),
    Xml: i(c, "Xml", P2())
  }), Object.defineProperty(a, "version", {
    configurable: !1,
    value: jH.version
  }), [a.v2_0.Schema, a.v3_0.Schema].forEach((l) => {
    l.defineDataTypeFormat("integer", "int32", null), l.defineDataTypeFormat("integer", "int64", null), l.defineDataTypeFormat("number", "float", null), l.defineDataTypeFormat("number", "double", null), l.defineDataTypeFormat("string", "binary", e.binary), l.defineDataTypeFormat("string", "byte", e.byte), l.defineDataTypeFormat("string", "date", e.date), l.defineDataTypeFormat("string", "date-time", e.dateTime);
  }), Wm;
}
var kH = N0();
const wS = /* @__PURE__ */ ea(kH);
var Af = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
Af.exports;
(function(e, t) {
  (function() {
    var r, n = "4.17.21", i = 200, s = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", a = "Expected a function", u = "Invalid `variable` option passed into `_.template`", c = "__lodash_hash_undefined__", l = 500, d = "__lodash_placeholder__", p = 1, h = 2, v = 4, y = 1, g = 2, _ = 1, m = 2, w = 4, $ = 8, E = 16, A = 32, R = 64, I = 128, D = 256, J = 512, ae = 30, ye = "...", xe = 800, je = 16, re = 1, fe = 2, le = 3, $e = 1 / 0, Ae = 9007199254740991, _e = 17976931348623157e292, ie = 0 / 0, K = 4294967295, V = K - 1, z = K >>> 1, C = [
      ["ary", I],
      ["bind", _],
      ["bindKey", m],
      ["curry", $],
      ["curryRight", E],
      ["flip", J],
      ["partial", A],
      ["partialRight", R],
      ["rearg", D]
    ], q = "[object Arguments]", N = "[object Array]", F = "[object AsyncFunction]", T = "[object Boolean]", Z = "[object Date]", Y = "[object DOMException]", k = "[object Error]", U = "[object Function]", pe = "[object GeneratorFunction]", we = "[object Map]", He = "[object Number]", Fe = "[object Null]", Ge = "[object Object]", jt = "[object Promise]", Ee = "[object Proxy]", Mt = "[object RegExp]", St = "[object Set]", Ne = "[object String]", Le = "[object Symbol]", at = "[object Undefined]", mt = "[object WeakMap]", qe = "[object WeakSet]", L = "[object ArrayBuffer]", x = "[object DataView]", S = "[object Float32Array]", G = "[object Float64Array]", ce = "[object Int8Array]", me = "[object Int16Array]", Oe = "[object Int32Array]", ut = "[object Uint8Array]", Dt = "[object Uint8ClampedArray]", Tt = "[object Uint16Array]", wt = "[object Uint32Array]", It = /\b__p \+= '';/g, _o = /\b(__p \+=) '' \+/g, wo = /(__e\(.*?\)|\b__t\)) \+\n'';/g, oa = /&(?:amp|lt|gt|quot|#39);/g, ua = /[&<>"']/g, $o = RegExp(oa.source), Fn = RegExp(ua.source), Eo = /<%-([\s\S]+?)%>/g, ca = /<%([\s\S]+?)%>/g, la = /<%=([\s\S]+?)%>/g, ws = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, fa = /^\w*$/, xo = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Ni = /[\\^$.*+?()[\]{}|]/g, Oo = RegExp(Ni.source), Di = /^\s+/, se = /\s/, X = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, ue = /\{\n\/\* \[wrapped with (.+)\] \*/, ve = /,? & /, ge = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, Ye = /[()=,{}\[\]\/\s]/, Xe = /\\(\\)?/g, Et = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, Lt = /\w*$/, Wt = /^[-+]0x[0-9a-f]+$/i, vt = /^0b[01]+$/i, Q = /^\[object .+?Constructor\]$/, O = /^0o[0-7]+$/i, j = /^(?:0|[1-9]\d*)$/, W = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, ne = /($^)/, te = /['\n\r\u2028\u2029\\]/g, Ie = "\\ud800-\\udfff", Se = "\\u0300-\\u036f", Ke = "\\ufe20-\\ufe2f", Ze = "\\u20d0-\\u20ff", ct = Se + Ke + Ze, Ut = "\\u2700-\\u27bf", Ur = "a-z\\xdf-\\xf6\\xf8-\\xff", Gr = "\\xac\\xb1\\xd7\\xf7", bn = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", $s = "\\u2000-\\u206f", lc = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", Po = "A-Z\\xc0-\\xd6\\xd8-\\xde", Es = "\\ufe0e\\ufe0f", xs = Gr + bn + $s + lc, Li = "[']", fc = "[" + Ie + "]", So = "[" + xs + "]", Un = "[" + ct + "]", L0 = "\\d+", xS = "[" + Ut + "]", q0 = "[" + Ur + "]", F0 = "[^" + Ie + xs + L0 + Ut + Ur + Po + "]", vd = "\\ud83c[\\udffb-\\udfff]", OS = "(?:" + Un + "|" + vd + ")", U0 = "[^" + Ie + "]", bd = "(?:\\ud83c[\\udde6-\\uddff]){2}", _d = "[\\ud800-\\udbff][\\udc00-\\udfff]", da = "[" + Po + "]", B0 = "\\u200d", V0 = "(?:" + q0 + "|" + F0 + ")", PS = "(?:" + da + "|" + F0 + ")", Z0 = "(?:" + Li + "(?:d|ll|m|re|s|t|ve))?", z0 = "(?:" + Li + "(?:D|LL|M|RE|S|T|VE))?", W0 = OS + "?", H0 = "[" + Es + "]?", SS = "(?:" + B0 + "(?:" + [U0, bd, _d].join("|") + ")" + H0 + W0 + ")*", AS = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", CS = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", G0 = H0 + W0 + SS, RS = "(?:" + [xS, bd, _d].join("|") + ")" + G0, TS = "(?:" + [U0 + Un + "?", Un, bd, _d, fc].join("|") + ")", IS = RegExp(Li, "g"), jS = RegExp(Un, "g"), wd = RegExp(vd + "(?=" + vd + ")|" + TS + G0, "g"), kS = RegExp([
      da + "?" + q0 + "+" + Z0 + "(?=" + [So, da, "$"].join("|") + ")",
      PS + "+" + z0 + "(?=" + [So, da + V0, "$"].join("|") + ")",
      da + "?" + V0 + "+" + Z0,
      da + "+" + z0,
      CS,
      AS,
      L0,
      RS
    ].join("|"), "g"), MS = RegExp("[" + B0 + Ie + ct + Es + "]"), NS = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, DS = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ], LS = -1, Ht = {};
    Ht[S] = Ht[G] = Ht[ce] = Ht[me] = Ht[Oe] = Ht[ut] = Ht[Dt] = Ht[Tt] = Ht[wt] = !0, Ht[q] = Ht[N] = Ht[L] = Ht[T] = Ht[x] = Ht[Z] = Ht[k] = Ht[U] = Ht[we] = Ht[He] = Ht[Ge] = Ht[Mt] = Ht[St] = Ht[Ne] = Ht[mt] = !1;
    var zt = {};
    zt[q] = zt[N] = zt[L] = zt[x] = zt[T] = zt[Z] = zt[S] = zt[G] = zt[ce] = zt[me] = zt[Oe] = zt[we] = zt[He] = zt[Ge] = zt[Mt] = zt[St] = zt[Ne] = zt[Le] = zt[ut] = zt[Dt] = zt[Tt] = zt[wt] = !0, zt[k] = zt[U] = zt[mt] = !1;
    var qS = {
      // Latin-1 Supplement block.
      : "A",
      : "A",
      : "A",
      : "A",
      : "A",
      : "A",
      : "a",
      : "a",
      : "a",
      : "a",
      : "a",
      : "a",
      : "C",
      : "c",
      : "D",
      : "d",
      : "E",
      : "E",
      : "E",
      : "E",
      : "e",
      : "e",
      : "e",
      : "e",
      : "I",
      : "I",
      : "I",
      : "I",
      : "i",
      : "i",
      : "i",
      : "i",
      : "N",
      : "n",
      : "O",
      : "O",
      : "O",
      : "O",
      : "O",
      : "O",
      : "o",
      : "o",
      : "o",
      : "o",
      : "o",
      : "o",
      : "U",
      : "U",
      : "U",
      : "U",
      : "u",
      : "u",
      : "u",
      : "u",
      : "Y",
      : "y",
      : "y",
      : "Ae",
      : "ae",
      : "Th",
      : "th",
      : "ss",
      // Latin Extended-A block.
      : "A",
      : "A",
      : "A",
      : "a",
      : "a",
      : "a",
      : "C",
      : "C",
      : "C",
      : "C",
      : "c",
      : "c",
      : "c",
      : "c",
      : "D",
      : "D",
      : "d",
      : "d",
      : "E",
      : "E",
      : "E",
      : "E",
      : "E",
      : "e",
      : "e",
      : "e",
      : "e",
      : "e",
      : "G",
      : "G",
      : "G",
      : "G",
      : "g",
      : "g",
      : "g",
      : "g",
      : "H",
      : "H",
      : "h",
      : "h",
      : "I",
      : "I",
      : "I",
      : "I",
      : "I",
      : "i",
      : "i",
      : "i",
      : "i",
      : "i",
      : "J",
      : "j",
      : "K",
      : "k",
      : "k",
      : "L",
      : "L",
      : "L",
      : "L",
      : "L",
      : "l",
      : "l",
      : "l",
      : "l",
      : "l",
      : "N",
      : "N",
      : "N",
      : "N",
      : "n",
      : "n",
      : "n",
      : "n",
      : "O",
      : "O",
      : "O",
      : "o",
      : "o",
      : "o",
      : "R",
      : "R",
      : "R",
      : "r",
      : "r",
      : "r",
      : "S",
      : "S",
      : "S",
      : "S",
      : "s",
      : "s",
      : "s",
      : "s",
      : "T",
      : "T",
      : "T",
      : "t",
      : "t",
      : "t",
      : "U",
      : "U",
      : "U",
      : "U",
      : "U",
      : "U",
      : "u",
      : "u",
      : "u",
      : "u",
      : "u",
      : "u",
      : "W",
      : "w",
      : "Y",
      : "y",
      : "Y",
      : "Z",
      : "Z",
      : "Z",
      : "z",
      : "z",
      : "z",
      : "IJ",
      : "ij",
      : "Oe",
      : "oe",
      : "'n",
      : "s"
    }, FS = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    }, US = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    }, BS = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    }, VS = parseFloat, ZS = parseInt, K0 = typeof rt == "object" && rt && rt.Object === Object && rt, zS = typeof self == "object" && self && self.Object === Object && self, mr = K0 || zS || Function("return this")(), $d = t && !t.nodeType && t, Os = $d && !0 && e && !e.nodeType && e, Y0 = Os && Os.exports === $d, Ed = Y0 && K0.process, sn = function() {
      try {
        var de = Os && Os.require && Os.require("util").types;
        return de || Ed && Ed.binding && Ed.binding("util");
      } catch {
      }
    }(), J0 = sn && sn.isArrayBuffer, X0 = sn && sn.isDate, Q0 = sn && sn.isMap, ev = sn && sn.isRegExp, tv = sn && sn.isSet, rv = sn && sn.isTypedArray;
    function Kr(de, Pe, be) {
      switch (be.length) {
        case 0:
          return de.call(Pe);
        case 1:
          return de.call(Pe, be[0]);
        case 2:
          return de.call(Pe, be[0], be[1]);
        case 3:
          return de.call(Pe, be[0], be[1], be[2]);
      }
      return de.apply(Pe, be);
    }
    function WS(de, Pe, be, ze) {
      for (var ft = -1, Nt = de == null ? 0 : de.length; ++ft < Nt; ) {
        var ur = de[ft];
        Pe(ze, ur, be(ur), de);
      }
      return ze;
    }
    function an(de, Pe) {
      for (var be = -1, ze = de == null ? 0 : de.length; ++be < ze && Pe(de[be], be, de) !== !1; )
        ;
      return de;
    }
    function HS(de, Pe) {
      for (var be = de == null ? 0 : de.length; be-- && Pe(de[be], be, de) !== !1; )
        ;
      return de;
    }
    function nv(de, Pe) {
      for (var be = -1, ze = de == null ? 0 : de.length; ++be < ze; )
        if (!Pe(de[be], be, de))
          return !1;
      return !0;
    }
    function qi(de, Pe) {
      for (var be = -1, ze = de == null ? 0 : de.length, ft = 0, Nt = []; ++be < ze; ) {
        var ur = de[be];
        Pe(ur, be, de) && (Nt[ft++] = ur);
      }
      return Nt;
    }
    function dc(de, Pe) {
      var be = de == null ? 0 : de.length;
      return !!be && pa(de, Pe, 0) > -1;
    }
    function xd(de, Pe, be) {
      for (var ze = -1, ft = de == null ? 0 : de.length; ++ze < ft; )
        if (be(Pe, de[ze]))
          return !0;
      return !1;
    }
    function Kt(de, Pe) {
      for (var be = -1, ze = de == null ? 0 : de.length, ft = Array(ze); ++be < ze; )
        ft[be] = Pe(de[be], be, de);
      return ft;
    }
    function Fi(de, Pe) {
      for (var be = -1, ze = Pe.length, ft = de.length; ++be < ze; )
        de[ft + be] = Pe[be];
      return de;
    }
    function Od(de, Pe, be, ze) {
      var ft = -1, Nt = de == null ? 0 : de.length;
      for (ze && Nt && (be = de[++ft]); ++ft < Nt; )
        be = Pe(be, de[ft], ft, de);
      return be;
    }
    function GS(de, Pe, be, ze) {
      var ft = de == null ? 0 : de.length;
      for (ze && ft && (be = de[--ft]); ft--; )
        be = Pe(be, de[ft], ft, de);
      return be;
    }
    function Pd(de, Pe) {
      for (var be = -1, ze = de == null ? 0 : de.length; ++be < ze; )
        if (Pe(de[be], be, de))
          return !0;
      return !1;
    }
    var KS = Sd("length");
    function YS(de) {
      return de.split("");
    }
    function JS(de) {
      return de.match(ge) || [];
    }
    function iv(de, Pe, be) {
      var ze;
      return be(de, function(ft, Nt, ur) {
        if (Pe(ft, Nt, ur))
          return ze = Nt, !1;
      }), ze;
    }
    function pc(de, Pe, be, ze) {
      for (var ft = de.length, Nt = be + (ze ? 1 : -1); ze ? Nt-- : ++Nt < ft; )
        if (Pe(de[Nt], Nt, de))
          return Nt;
      return -1;
    }
    function pa(de, Pe, be) {
      return Pe === Pe ? cA(de, Pe, be) : pc(de, sv, be);
    }
    function XS(de, Pe, be, ze) {
      for (var ft = be - 1, Nt = de.length; ++ft < Nt; )
        if (ze(de[ft], Pe))
          return ft;
      return -1;
    }
    function sv(de) {
      return de !== de;
    }
    function av(de, Pe) {
      var be = de == null ? 0 : de.length;
      return be ? Cd(de, Pe) / be : ie;
    }
    function Sd(de) {
      return function(Pe) {
        return Pe == null ? r : Pe[de];
      };
    }
    function Ad(de) {
      return function(Pe) {
        return de == null ? r : de[Pe];
      };
    }
    function ov(de, Pe, be, ze, ft) {
      return ft(de, function(Nt, ur, Zt) {
        be = ze ? (ze = !1, Nt) : Pe(be, Nt, ur, Zt);
      }), be;
    }
    function QS(de, Pe) {
      var be = de.length;
      for (de.sort(Pe); be--; )
        de[be] = de[be].value;
      return de;
    }
    function Cd(de, Pe) {
      for (var be, ze = -1, ft = de.length; ++ze < ft; ) {
        var Nt = Pe(de[ze]);
        Nt !== r && (be = be === r ? Nt : be + Nt);
      }
      return be;
    }
    function Rd(de, Pe) {
      for (var be = -1, ze = Array(de); ++be < de; )
        ze[be] = Pe(be);
      return ze;
    }
    function eA(de, Pe) {
      return Kt(Pe, function(be) {
        return [be, de[be]];
      });
    }
    function uv(de) {
      return de && de.slice(0, dv(de) + 1).replace(Di, "");
    }
    function Yr(de) {
      return function(Pe) {
        return de(Pe);
      };
    }
    function Td(de, Pe) {
      return Kt(Pe, function(be) {
        return de[be];
      });
    }
    function Ao(de, Pe) {
      return de.has(Pe);
    }
    function cv(de, Pe) {
      for (var be = -1, ze = de.length; ++be < ze && pa(Pe, de[be], 0) > -1; )
        ;
      return be;
    }
    function lv(de, Pe) {
      for (var be = de.length; be-- && pa(Pe, de[be], 0) > -1; )
        ;
      return be;
    }
    function tA(de, Pe) {
      for (var be = de.length, ze = 0; be--; )
        de[be] === Pe && ++ze;
      return ze;
    }
    var rA = Ad(qS), nA = Ad(FS);
    function iA(de) {
      return "\\" + BS[de];
    }
    function sA(de, Pe) {
      return de == null ? r : de[Pe];
    }
    function ha(de) {
      return MS.test(de);
    }
    function aA(de) {
      return NS.test(de);
    }
    function oA(de) {
      for (var Pe, be = []; !(Pe = de.next()).done; )
        be.push(Pe.value);
      return be;
    }
    function Id(de) {
      var Pe = -1, be = Array(de.size);
      return de.forEach(function(ze, ft) {
        be[++Pe] = [ft, ze];
      }), be;
    }
    function fv(de, Pe) {
      return function(be) {
        return de(Pe(be));
      };
    }
    function Ui(de, Pe) {
      for (var be = -1, ze = de.length, ft = 0, Nt = []; ++be < ze; ) {
        var ur = de[be];
        (ur === Pe || ur === d) && (de[be] = d, Nt[ft++] = be);
      }
      return Nt;
    }
    function hc(de) {
      var Pe = -1, be = Array(de.size);
      return de.forEach(function(ze) {
        be[++Pe] = ze;
      }), be;
    }
    function uA(de) {
      var Pe = -1, be = Array(de.size);
      return de.forEach(function(ze) {
        be[++Pe] = [ze, ze];
      }), be;
    }
    function cA(de, Pe, be) {
      for (var ze = be - 1, ft = de.length; ++ze < ft; )
        if (de[ze] === Pe)
          return ze;
      return -1;
    }
    function lA(de, Pe, be) {
      for (var ze = be + 1; ze--; )
        if (de[ze] === Pe)
          return ze;
      return ze;
    }
    function ma(de) {
      return ha(de) ? dA(de) : KS(de);
    }
    function _n(de) {
      return ha(de) ? pA(de) : YS(de);
    }
    function dv(de) {
      for (var Pe = de.length; Pe-- && se.test(de.charAt(Pe)); )
        ;
      return Pe;
    }
    var fA = Ad(US);
    function dA(de) {
      for (var Pe = wd.lastIndex = 0; wd.test(de); )
        ++Pe;
      return Pe;
    }
    function pA(de) {
      return de.match(wd) || [];
    }
    function hA(de) {
      return de.match(kS) || [];
    }
    var mA = function de(Pe) {
      Pe = Pe == null ? mr : ya.defaults(mr.Object(), Pe, ya.pick(mr, DS));
      var be = Pe.Array, ze = Pe.Date, ft = Pe.Error, Nt = Pe.Function, ur = Pe.Math, Zt = Pe.Object, jd = Pe.RegExp, yA = Pe.String, on = Pe.TypeError, mc = be.prototype, gA = Nt.prototype, ga = Zt.prototype, yc = Pe["__core-js_shared__"], gc = gA.toString, Ft = ga.hasOwnProperty, vA = 0, pv = function() {
        var o = /[^.]+$/.exec(yc && yc.keys && yc.keys.IE_PROTO || "");
        return o ? "Symbol(src)_1." + o : "";
      }(), vc = ga.toString, bA = gc.call(Zt), _A = mr._, wA = jd(
        "^" + gc.call(Ft).replace(Ni, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      ), bc = Y0 ? Pe.Buffer : r, Bi = Pe.Symbol, _c = Pe.Uint8Array, hv = bc ? bc.allocUnsafe : r, wc = fv(Zt.getPrototypeOf, Zt), mv = Zt.create, yv = ga.propertyIsEnumerable, $c = mc.splice, gv = Bi ? Bi.isConcatSpreadable : r, Co = Bi ? Bi.iterator : r, Ps = Bi ? Bi.toStringTag : r, Ec = function() {
        try {
          var o = Ts(Zt, "defineProperty");
          return o({}, "", {}), o;
        } catch {
        }
      }(), $A = Pe.clearTimeout !== mr.clearTimeout && Pe.clearTimeout, EA = ze && ze.now !== mr.Date.now && ze.now, xA = Pe.setTimeout !== mr.setTimeout && Pe.setTimeout, xc = ur.ceil, Oc = ur.floor, kd = Zt.getOwnPropertySymbols, OA = bc ? bc.isBuffer : r, vv = Pe.isFinite, PA = mc.join, SA = fv(Zt.keys, Zt), cr = ur.max, wr = ur.min, AA = ze.now, CA = Pe.parseInt, bv = ur.random, RA = mc.reverse, Md = Ts(Pe, "DataView"), Ro = Ts(Pe, "Map"), Nd = Ts(Pe, "Promise"), va = Ts(Pe, "Set"), To = Ts(Pe, "WeakMap"), Io = Ts(Zt, "create"), Pc = To && new To(), ba = {}, TA = Is(Md), IA = Is(Ro), jA = Is(Nd), kA = Is(va), MA = Is(To), Sc = Bi ? Bi.prototype : r, jo = Sc ? Sc.valueOf : r, _v = Sc ? Sc.toString : r;
      function B(o) {
        if (Xt(o) && !pt(o) && !(o instanceof At)) {
          if (o instanceof un)
            return o;
          if (Ft.call(o, "__wrapped__"))
            return wb(o);
        }
        return new un(o);
      }
      var _a = function() {
        function o() {
        }
        return function(f) {
          if (!Yt(f))
            return {};
          if (mv)
            return mv(f);
          o.prototype = f;
          var b = new o();
          return o.prototype = r, b;
        };
      }();
      function Ac() {
      }
      function un(o, f) {
        this.__wrapped__ = o, this.__actions__ = [], this.__chain__ = !!f, this.__index__ = 0, this.__values__ = r;
      }
      B.templateSettings = {
        /**
         * Used to detect `data` property values to be HTML-escaped.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        escape: Eo,
        /**
         * Used to detect code to be evaluated.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        evaluate: ca,
        /**
         * Used to detect `data` property values to inject.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        interpolate: la,
        /**
         * Used to reference the data object in the template text.
         *
         * @memberOf _.templateSettings
         * @type {string}
         */
        variable: "",
        /**
         * Used to import variables into the compiled template.
         *
         * @memberOf _.templateSettings
         * @type {Object}
         */
        imports: {
          /**
           * A reference to the `lodash` function.
           *
           * @memberOf _.templateSettings.imports
           * @type {Function}
           */
          _: B
        }
      }, B.prototype = Ac.prototype, B.prototype.constructor = B, un.prototype = _a(Ac.prototype), un.prototype.constructor = un;
      function At(o) {
        this.__wrapped__ = o, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = K, this.__views__ = [];
      }
      function NA() {
        var o = new At(this.__wrapped__);
        return o.__actions__ = Br(this.__actions__), o.__dir__ = this.__dir__, o.__filtered__ = this.__filtered__, o.__iteratees__ = Br(this.__iteratees__), o.__takeCount__ = this.__takeCount__, o.__views__ = Br(this.__views__), o;
      }
      function DA() {
        if (this.__filtered__) {
          var o = new At(this);
          o.__dir__ = -1, o.__filtered__ = !0;
        } else
          o = this.clone(), o.__dir__ *= -1;
        return o;
      }
      function LA() {
        var o = this.__wrapped__.value(), f = this.__dir__, b = pt(o), P = f < 0, M = b ? o.length : 0, H = YC(0, M, this.__views__), ee = H.start, oe = H.end, he = oe - ee, Ce = P ? oe : ee - 1, Re = this.__iteratees__, ke = Re.length, Ue = 0, Je = wr(he, this.__takeCount__);
        if (!b || !P && M == he && Je == he)
          return Zv(o, this.__actions__);
        var it = [];
        e:
          for (; he-- && Ue < Je; ) {
            Ce += f;
            for (var bt = -1, st = o[Ce]; ++bt < ke; ) {
              var Ot = Re[bt], Rt = Ot.iteratee, Qr = Ot.type, jr = Rt(st);
              if (Qr == fe)
                st = jr;
              else if (!jr) {
                if (Qr == re)
                  continue e;
                break e;
              }
            }
            it[Ue++] = st;
          }
        return it;
      }
      At.prototype = _a(Ac.prototype), At.prototype.constructor = At;
      function Ss(o) {
        var f = -1, b = o == null ? 0 : o.length;
        for (this.clear(); ++f < b; ) {
          var P = o[f];
          this.set(P[0], P[1]);
        }
      }
      function qA() {
        this.__data__ = Io ? Io(null) : {}, this.size = 0;
      }
      function FA(o) {
        var f = this.has(o) && delete this.__data__[o];
        return this.size -= f ? 1 : 0, f;
      }
      function UA(o) {
        var f = this.__data__;
        if (Io) {
          var b = f[o];
          return b === c ? r : b;
        }
        return Ft.call(f, o) ? f[o] : r;
      }
      function BA(o) {
        var f = this.__data__;
        return Io ? f[o] !== r : Ft.call(f, o);
      }
      function VA(o, f) {
        var b = this.__data__;
        return this.size += this.has(o) ? 0 : 1, b[o] = Io && f === r ? c : f, this;
      }
      Ss.prototype.clear = qA, Ss.prototype.delete = FA, Ss.prototype.get = UA, Ss.prototype.has = BA, Ss.prototype.set = VA;
      function ci(o) {
        var f = -1, b = o == null ? 0 : o.length;
        for (this.clear(); ++f < b; ) {
          var P = o[f];
          this.set(P[0], P[1]);
        }
      }
      function ZA() {
        this.__data__ = [], this.size = 0;
      }
      function zA(o) {
        var f = this.__data__, b = Cc(f, o);
        if (b < 0)
          return !1;
        var P = f.length - 1;
        return b == P ? f.pop() : $c.call(f, b, 1), --this.size, !0;
      }
      function WA(o) {
        var f = this.__data__, b = Cc(f, o);
        return b < 0 ? r : f[b][1];
      }
      function HA(o) {
        return Cc(this.__data__, o) > -1;
      }
      function GA(o, f) {
        var b = this.__data__, P = Cc(b, o);
        return P < 0 ? (++this.size, b.push([o, f])) : b[P][1] = f, this;
      }
      ci.prototype.clear = ZA, ci.prototype.delete = zA, ci.prototype.get = WA, ci.prototype.has = HA, ci.prototype.set = GA;
      function li(o) {
        var f = -1, b = o == null ? 0 : o.length;
        for (this.clear(); ++f < b; ) {
          var P = o[f];
          this.set(P[0], P[1]);
        }
      }
      function KA() {
        this.size = 0, this.__data__ = {
          hash: new Ss(),
          map: new (Ro || ci)(),
          string: new Ss()
        };
      }
      function YA(o) {
        var f = Uc(this, o).delete(o);
        return this.size -= f ? 1 : 0, f;
      }
      function JA(o) {
        return Uc(this, o).get(o);
      }
      function XA(o) {
        return Uc(this, o).has(o);
      }
      function QA(o, f) {
        var b = Uc(this, o), P = b.size;
        return b.set(o, f), this.size += b.size == P ? 0 : 1, this;
      }
      li.prototype.clear = KA, li.prototype.delete = YA, li.prototype.get = JA, li.prototype.has = XA, li.prototype.set = QA;
      function As(o) {
        var f = -1, b = o == null ? 0 : o.length;
        for (this.__data__ = new li(); ++f < b; )
          this.add(o[f]);
      }
      function eC(o) {
        return this.__data__.set(o, c), this;
      }
      function tC(o) {
        return this.__data__.has(o);
      }
      As.prototype.add = As.prototype.push = eC, As.prototype.has = tC;
      function wn(o) {
        var f = this.__data__ = new ci(o);
        this.size = f.size;
      }
      function rC() {
        this.__data__ = new ci(), this.size = 0;
      }
      function nC(o) {
        var f = this.__data__, b = f.delete(o);
        return this.size = f.size, b;
      }
      function iC(o) {
        return this.__data__.get(o);
      }
      function sC(o) {
        return this.__data__.has(o);
      }
      function aC(o, f) {
        var b = this.__data__;
        if (b instanceof ci) {
          var P = b.__data__;
          if (!Ro || P.length < i - 1)
            return P.push([o, f]), this.size = ++b.size, this;
          b = this.__data__ = new li(P);
        }
        return b.set(o, f), this.size = b.size, this;
      }
      wn.prototype.clear = rC, wn.prototype.delete = nC, wn.prototype.get = iC, wn.prototype.has = sC, wn.prototype.set = aC;
      function wv(o, f) {
        var b = pt(o), P = !b && js(o), M = !b && !P && Hi(o), H = !b && !P && !M && xa(o), ee = b || P || M || H, oe = ee ? Rd(o.length, yA) : [], he = oe.length;
        for (var Ce in o)
          (f || Ft.call(o, Ce)) && !(ee && // Safari 9 has enumerable `arguments.length` in strict mode.
          (Ce == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          M && (Ce == "offset" || Ce == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          H && (Ce == "buffer" || Ce == "byteLength" || Ce == "byteOffset") || // Skip index properties.
          hi(Ce, he))) && oe.push(Ce);
        return oe;
      }
      function $v(o) {
        var f = o.length;
        return f ? o[Hd(0, f - 1)] : r;
      }
      function oC(o, f) {
        return Bc(Br(o), Cs(f, 0, o.length));
      }
      function uC(o) {
        return Bc(Br(o));
      }
      function Dd(o, f, b) {
        (b !== r && !$n(o[f], b) || b === r && !(f in o)) && fi(o, f, b);
      }
      function ko(o, f, b) {
        var P = o[f];
        (!(Ft.call(o, f) && $n(P, b)) || b === r && !(f in o)) && fi(o, f, b);
      }
      function Cc(o, f) {
        for (var b = o.length; b--; )
          if ($n(o[b][0], f))
            return b;
        return -1;
      }
      function cC(o, f, b, P) {
        return Vi(o, function(M, H, ee) {
          f(P, M, b(M), ee);
        }), P;
      }
      function Ev(o, f) {
        return o && Vn(f, dr(f), o);
      }
      function lC(o, f) {
        return o && Vn(f, Zr(f), o);
      }
      function fi(o, f, b) {
        f == "__proto__" && Ec ? Ec(o, f, {
          configurable: !0,
          enumerable: !0,
          value: b,
          writable: !0
        }) : o[f] = b;
      }
      function Ld(o, f) {
        for (var b = -1, P = f.length, M = be(P), H = o == null; ++b < P; )
          M[b] = H ? r : vp(o, f[b]);
        return M;
      }
      function Cs(o, f, b) {
        return o === o && (b !== r && (o = o <= b ? o : b), f !== r && (o = o >= f ? o : f)), o;
      }
      function cn(o, f, b, P, M, H) {
        var ee, oe = f & p, he = f & h, Ce = f & v;
        if (b && (ee = M ? b(o, P, M, H) : b(o)), ee !== r)
          return ee;
        if (!Yt(o))
          return o;
        var Re = pt(o);
        if (Re) {
          if (ee = XC(o), !oe)
            return Br(o, ee);
        } else {
          var ke = $r(o), Ue = ke == U || ke == pe;
          if (Hi(o))
            return Hv(o, oe);
          if (ke == Ge || ke == q || Ue && !M) {
            if (ee = he || Ue ? {} : db(o), !oe)
              return he ? UC(o, lC(ee, o)) : FC(o, Ev(ee, o));
          } else {
            if (!zt[ke])
              return M ? o : {};
            ee = QC(o, ke, oe);
          }
        }
        H || (H = new wn());
        var Je = H.get(o);
        if (Je)
          return Je;
        H.set(o, ee), Ub(o) ? o.forEach(function(st) {
          ee.add(cn(st, f, b, st, o, H));
        }) : qb(o) && o.forEach(function(st, Ot) {
          ee.set(Ot, cn(st, f, b, Ot, o, H));
        });
        var it = Ce ? he ? ip : np : he ? Zr : dr, bt = Re ? r : it(o);
        return an(bt || o, function(st, Ot) {
          bt && (Ot = st, st = o[Ot]), ko(ee, Ot, cn(st, f, b, Ot, o, H));
        }), ee;
      }
      function fC(o) {
        var f = dr(o);
        return function(b) {
          return xv(b, o, f);
        };
      }
      function xv(o, f, b) {
        var P = b.length;
        if (o == null)
          return !P;
        for (o = Zt(o); P--; ) {
          var M = b[P], H = f[M], ee = o[M];
          if (ee === r && !(M in o) || !H(ee))
            return !1;
        }
        return !0;
      }
      function Ov(o, f, b) {
        if (typeof o != "function")
          throw new on(a);
        return Uo(function() {
          o.apply(r, b);
        }, f);
      }
      function Mo(o, f, b, P) {
        var M = -1, H = dc, ee = !0, oe = o.length, he = [], Ce = f.length;
        if (!oe)
          return he;
        b && (f = Kt(f, Yr(b))), P ? (H = xd, ee = !1) : f.length >= i && (H = Ao, ee = !1, f = new As(f));
        e:
          for (; ++M < oe; ) {
            var Re = o[M], ke = b == null ? Re : b(Re);
            if (Re = P || Re !== 0 ? Re : 0, ee && ke === ke) {
              for (var Ue = Ce; Ue--; )
                if (f[Ue] === ke)
                  continue e;
              he.push(Re);
            } else
              H(f, ke, P) || he.push(Re);
          }
        return he;
      }
      var Vi = Xv(Bn), Pv = Xv(Fd, !0);
      function dC(o, f) {
        var b = !0;
        return Vi(o, function(P, M, H) {
          return b = !!f(P, M, H), b;
        }), b;
      }
      function Rc(o, f, b) {
        for (var P = -1, M = o.length; ++P < M; ) {
          var H = o[P], ee = f(H);
          if (ee != null && (oe === r ? ee === ee && !Xr(ee) : b(ee, oe)))
            var oe = ee, he = H;
        }
        return he;
      }
      function pC(o, f, b, P) {
        var M = o.length;
        for (b = gt(b), b < 0 && (b = -b > M ? 0 : M + b), P = P === r || P > M ? M : gt(P), P < 0 && (P += M), P = b > P ? 0 : Vb(P); b < P; )
          o[b++] = f;
        return o;
      }
      function Sv(o, f) {
        var b = [];
        return Vi(o, function(P, M, H) {
          f(P, M, H) && b.push(P);
        }), b;
      }
      function yr(o, f, b, P, M) {
        var H = -1, ee = o.length;
        for (b || (b = tR), M || (M = []); ++H < ee; ) {
          var oe = o[H];
          f > 0 && b(oe) ? f > 1 ? yr(oe, f - 1, b, P, M) : Fi(M, oe) : P || (M[M.length] = oe);
        }
        return M;
      }
      var qd = Qv(), Av = Qv(!0);
      function Bn(o, f) {
        return o && qd(o, f, dr);
      }
      function Fd(o, f) {
        return o && Av(o, f, dr);
      }
      function Tc(o, f) {
        return qi(f, function(b) {
          return mi(o[b]);
        });
      }
      function Rs(o, f) {
        f = zi(f, o);
        for (var b = 0, P = f.length; o != null && b < P; )
          o = o[Zn(f[b++])];
        return b && b == P ? o : r;
      }
      function Cv(o, f, b) {
        var P = f(o);
        return pt(o) ? P : Fi(P, b(o));
      }
      function Tr(o) {
        return o == null ? o === r ? at : Fe : Ps && Ps in Zt(o) ? KC(o) : uR(o);
      }
      function Ud(o, f) {
        return o > f;
      }
      function hC(o, f) {
        return o != null && Ft.call(o, f);
      }
      function mC(o, f) {
        return o != null && f in Zt(o);
      }
      function yC(o, f, b) {
        return o >= wr(f, b) && o < cr(f, b);
      }
      function Bd(o, f, b) {
        for (var P = b ? xd : dc, M = o[0].length, H = o.length, ee = H, oe = be(H), he = 1 / 0, Ce = []; ee--; ) {
          var Re = o[ee];
          ee && f && (Re = Kt(Re, Yr(f))), he = wr(Re.length, he), oe[ee] = !b && (f || M >= 120 && Re.length >= 120) ? new As(ee && Re) : r;
        }
        Re = o[0];
        var ke = -1, Ue = oe[0];
        e:
          for (; ++ke < M && Ce.length < he; ) {
            var Je = Re[ke], it = f ? f(Je) : Je;
            if (Je = b || Je !== 0 ? Je : 0, !(Ue ? Ao(Ue, it) : P(Ce, it, b))) {
              for (ee = H; --ee; ) {
                var bt = oe[ee];
                if (!(bt ? Ao(bt, it) : P(o[ee], it, b)))
                  continue e;
              }
              Ue && Ue.push(it), Ce.push(Je);
            }
          }
        return Ce;
      }
      function gC(o, f, b, P) {
        return Bn(o, function(M, H, ee) {
          f(P, b(M), H, ee);
        }), P;
      }
      function No(o, f, b) {
        f = zi(f, o), o = yb(o, f);
        var P = o == null ? o : o[Zn(fn(f))];
        return P == null ? r : Kr(P, o, b);
      }
      function Rv(o) {
        return Xt(o) && Tr(o) == q;
      }
      function vC(o) {
        return Xt(o) && Tr(o) == L;
      }
      function bC(o) {
        return Xt(o) && Tr(o) == Z;
      }
      function Do(o, f, b, P, M) {
        return o === f ? !0 : o == null || f == null || !Xt(o) && !Xt(f) ? o !== o && f !== f : _C(o, f, b, P, Do, M);
      }
      function _C(o, f, b, P, M, H) {
        var ee = pt(o), oe = pt(f), he = ee ? N : $r(o), Ce = oe ? N : $r(f);
        he = he == q ? Ge : he, Ce = Ce == q ? Ge : Ce;
        var Re = he == Ge, ke = Ce == Ge, Ue = he == Ce;
        if (Ue && Hi(o)) {
          if (!Hi(f))
            return !1;
          ee = !0, Re = !1;
        }
        if (Ue && !Re)
          return H || (H = new wn()), ee || xa(o) ? cb(o, f, b, P, M, H) : HC(o, f, he, b, P, M, H);
        if (!(b & y)) {
          var Je = Re && Ft.call(o, "__wrapped__"), it = ke && Ft.call(f, "__wrapped__");
          if (Je || it) {
            var bt = Je ? o.value() : o, st = it ? f.value() : f;
            return H || (H = new wn()), M(bt, st, b, P, H);
          }
        }
        return Ue ? (H || (H = new wn()), GC(o, f, b, P, M, H)) : !1;
      }
      function wC(o) {
        return Xt(o) && $r(o) == we;
      }
      function Vd(o, f, b, P) {
        var M = b.length, H = M, ee = !P;
        if (o == null)
          return !H;
        for (o = Zt(o); M--; ) {
          var oe = b[M];
          if (ee && oe[2] ? oe[1] !== o[oe[0]] : !(oe[0] in o))
            return !1;
        }
        for (; ++M < H; ) {
          oe = b[M];
          var he = oe[0], Ce = o[he], Re = oe[1];
          if (ee && oe[2]) {
            if (Ce === r && !(he in o))
              return !1;
          } else {
            var ke = new wn();
            if (P)
              var Ue = P(Ce, Re, he, o, f, ke);
            if (!(Ue === r ? Do(Re, Ce, y | g, P, ke) : Ue))
              return !1;
          }
        }
        return !0;
      }
      function Tv(o) {
        if (!Yt(o) || nR(o))
          return !1;
        var f = mi(o) ? wA : Q;
        return f.test(Is(o));
      }
      function $C(o) {
        return Xt(o) && Tr(o) == Mt;
      }
      function EC(o) {
        return Xt(o) && $r(o) == St;
      }
      function xC(o) {
        return Xt(o) && Gc(o.length) && !!Ht[Tr(o)];
      }
      function Iv(o) {
        return typeof o == "function" ? o : o == null ? zr : typeof o == "object" ? pt(o) ? Mv(o[0], o[1]) : kv(o) : e1(o);
      }
      function Zd(o) {
        if (!Fo(o))
          return SA(o);
        var f = [];
        for (var b in Zt(o))
          Ft.call(o, b) && b != "constructor" && f.push(b);
        return f;
      }
      function OC(o) {
        if (!Yt(o))
          return oR(o);
        var f = Fo(o), b = [];
        for (var P in o)
          P == "constructor" && (f || !Ft.call(o, P)) || b.push(P);
        return b;
      }
      function zd(o, f) {
        return o < f;
      }
      function jv(o, f) {
        var b = -1, P = Vr(o) ? be(o.length) : [];
        return Vi(o, function(M, H, ee) {
          P[++b] = f(M, H, ee);
        }), P;
      }
      function kv(o) {
        var f = ap(o);
        return f.length == 1 && f[0][2] ? hb(f[0][0], f[0][1]) : function(b) {
          return b === o || Vd(b, o, f);
        };
      }
      function Mv(o, f) {
        return up(o) && pb(f) ? hb(Zn(o), f) : function(b) {
          var P = vp(b, o);
          return P === r && P === f ? bp(b, o) : Do(f, P, y | g);
        };
      }
      function Ic(o, f, b, P, M) {
        o !== f && qd(f, function(H, ee) {
          if (M || (M = new wn()), Yt(H))
            PC(o, f, ee, b, Ic, P, M);
          else {
            var oe = P ? P(lp(o, ee), H, ee + "", o, f, M) : r;
            oe === r && (oe = H), Dd(o, ee, oe);
          }
        }, Zr);
      }
      function PC(o, f, b, P, M, H, ee) {
        var oe = lp(o, b), he = lp(f, b), Ce = ee.get(he);
        if (Ce) {
          Dd(o, b, Ce);
          return;
        }
        var Re = H ? H(oe, he, b + "", o, f, ee) : r, ke = Re === r;
        if (ke) {
          var Ue = pt(he), Je = !Ue && Hi(he), it = !Ue && !Je && xa(he);
          Re = he, Ue || Je || it ? pt(oe) ? Re = oe : er(oe) ? Re = Br(oe) : Je ? (ke = !1, Re = Hv(he, !0)) : it ? (ke = !1, Re = Gv(he, !0)) : Re = [] : Bo(he) || js(he) ? (Re = oe, js(oe) ? Re = Zb(oe) : (!Yt(oe) || mi(oe)) && (Re = db(he))) : ke = !1;
        }
        ke && (ee.set(he, Re), M(Re, he, P, H, ee), ee.delete(he)), Dd(o, b, Re);
      }
      function Nv(o, f) {
        var b = o.length;
        if (b)
          return f += f < 0 ? b : 0, hi(f, b) ? o[f] : r;
      }
      function Dv(o, f, b) {
        f.length ? f = Kt(f, function(H) {
          return pt(H) ? function(ee) {
            return Rs(ee, H.length === 1 ? H[0] : H);
          } : H;
        }) : f = [zr];
        var P = -1;
        f = Kt(f, Yr(nt()));
        var M = jv(o, function(H, ee, oe) {
          var he = Kt(f, function(Ce) {
            return Ce(H);
          });
          return { criteria: he, index: ++P, value: H };
        });
        return QS(M, function(H, ee) {
          return qC(H, ee, b);
        });
      }
      function SC(o, f) {
        return Lv(o, f, function(b, P) {
          return bp(o, P);
        });
      }
      function Lv(o, f, b) {
        for (var P = -1, M = f.length, H = {}; ++P < M; ) {
          var ee = f[P], oe = Rs(o, ee);
          b(oe, ee) && Lo(H, zi(ee, o), oe);
        }
        return H;
      }
      function AC(o) {
        return function(f) {
          return Rs(f, o);
        };
      }
      function Wd(o, f, b, P) {
        var M = P ? XS : pa, H = -1, ee = f.length, oe = o;
        for (o === f && (f = Br(f)), b && (oe = Kt(o, Yr(b))); ++H < ee; )
          for (var he = 0, Ce = f[H], Re = b ? b(Ce) : Ce; (he = M(oe, Re, he, P)) > -1; )
            oe !== o && $c.call(oe, he, 1), $c.call(o, he, 1);
        return o;
      }
      function qv(o, f) {
        for (var b = o ? f.length : 0, P = b - 1; b--; ) {
          var M = f[b];
          if (b == P || M !== H) {
            var H = M;
            hi(M) ? $c.call(o, M, 1) : Yd(o, M);
          }
        }
        return o;
      }
      function Hd(o, f) {
        return o + Oc(bv() * (f - o + 1));
      }
      function CC(o, f, b, P) {
        for (var M = -1, H = cr(xc((f - o) / (b || 1)), 0), ee = be(H); H--; )
          ee[P ? H : ++M] = o, o += b;
        return ee;
      }
      function Gd(o, f) {
        var b = "";
        if (!o || f < 1 || f > Ae)
          return b;
        do
          f % 2 && (b += o), f = Oc(f / 2), f && (o += o);
        while (f);
        return b;
      }
      function $t(o, f) {
        return fp(mb(o, f, zr), o + "");
      }
      function RC(o) {
        return $v(Oa(o));
      }
      function TC(o, f) {
        var b = Oa(o);
        return Bc(b, Cs(f, 0, b.length));
      }
      function Lo(o, f, b, P) {
        if (!Yt(o))
          return o;
        f = zi(f, o);
        for (var M = -1, H = f.length, ee = H - 1, oe = o; oe != null && ++M < H; ) {
          var he = Zn(f[M]), Ce = b;
          if (he === "__proto__" || he === "constructor" || he === "prototype")
            return o;
          if (M != ee) {
            var Re = oe[he];
            Ce = P ? P(Re, he, oe) : r, Ce === r && (Ce = Yt(Re) ? Re : hi(f[M + 1]) ? [] : {});
          }
          ko(oe, he, Ce), oe = oe[he];
        }
        return o;
      }
      var Fv = Pc ? function(o, f) {
        return Pc.set(o, f), o;
      } : zr, IC = Ec ? function(o, f) {
        return Ec(o, "toString", {
          configurable: !0,
          enumerable: !1,
          value: wp(f),
          writable: !0
        });
      } : zr;
      function jC(o) {
        return Bc(Oa(o));
      }
      function ln(o, f, b) {
        var P = -1, M = o.length;
        f < 0 && (f = -f > M ? 0 : M + f), b = b > M ? M : b, b < 0 && (b += M), M = f > b ? 0 : b - f >>> 0, f >>>= 0;
        for (var H = be(M); ++P < M; )
          H[P] = o[P + f];
        return H;
      }
      function kC(o, f) {
        var b;
        return Vi(o, function(P, M, H) {
          return b = f(P, M, H), !b;
        }), !!b;
      }
      function jc(o, f, b) {
        var P = 0, M = o == null ? P : o.length;
        if (typeof f == "number" && f === f && M <= z) {
          for (; P < M; ) {
            var H = P + M >>> 1, ee = o[H];
            ee !== null && !Xr(ee) && (b ? ee <= f : ee < f) ? P = H + 1 : M = H;
          }
          return M;
        }
        return Kd(o, f, zr, b);
      }
      function Kd(o, f, b, P) {
        var M = 0, H = o == null ? 0 : o.length;
        if (H === 0)
          return 0;
        f = b(f);
        for (var ee = f !== f, oe = f === null, he = Xr(f), Ce = f === r; M < H; ) {
          var Re = Oc((M + H) / 2), ke = b(o[Re]), Ue = ke !== r, Je = ke === null, it = ke === ke, bt = Xr(ke);
          if (ee)
            var st = P || it;
          else
            Ce ? st = it && (P || Ue) : oe ? st = it && Ue && (P || !Je) : he ? st = it && Ue && !Je && (P || !bt) : Je || bt ? st = !1 : st = P ? ke <= f : ke < f;
          st ? M = Re + 1 : H = Re;
        }
        return wr(H, V);
      }
      function Uv(o, f) {
        for (var b = -1, P = o.length, M = 0, H = []; ++b < P; ) {
          var ee = o[b], oe = f ? f(ee) : ee;
          if (!b || !$n(oe, he)) {
            var he = oe;
            H[M++] = ee === 0 ? 0 : ee;
          }
        }
        return H;
      }
      function Bv(o) {
        return typeof o == "number" ? o : Xr(o) ? ie : +o;
      }
      function Jr(o) {
        if (typeof o == "string")
          return o;
        if (pt(o))
          return Kt(o, Jr) + "";
        if (Xr(o))
          return _v ? _v.call(o) : "";
        var f = o + "";
        return f == "0" && 1 / o == -$e ? "-0" : f;
      }
      function Zi(o, f, b) {
        var P = -1, M = dc, H = o.length, ee = !0, oe = [], he = oe;
        if (b)
          ee = !1, M = xd;
        else if (H >= i) {
          var Ce = f ? null : zC(o);
          if (Ce)
            return hc(Ce);
          ee = !1, M = Ao, he = new As();
        } else
          he = f ? [] : oe;
        e:
          for (; ++P < H; ) {
            var Re = o[P], ke = f ? f(Re) : Re;
            if (Re = b || Re !== 0 ? Re : 0, ee && ke === ke) {
              for (var Ue = he.length; Ue--; )
                if (he[Ue] === ke)
                  continue e;
              f && he.push(ke), oe.push(Re);
            } else
              M(he, ke, b) || (he !== oe && he.push(ke), oe.push(Re));
          }
        return oe;
      }
      function Yd(o, f) {
        return f = zi(f, o), o = yb(o, f), o == null || delete o[Zn(fn(f))];
      }
      function Vv(o, f, b, P) {
        return Lo(o, f, b(Rs(o, f)), P);
      }
      function kc(o, f, b, P) {
        for (var M = o.length, H = P ? M : -1; (P ? H-- : ++H < M) && f(o[H], H, o); )
          ;
        return b ? ln(o, P ? 0 : H, P ? H + 1 : M) : ln(o, P ? H + 1 : 0, P ? M : H);
      }
      function Zv(o, f) {
        var b = o;
        return b instanceof At && (b = b.value()), Od(f, function(P, M) {
          return M.func.apply(M.thisArg, Fi([P], M.args));
        }, b);
      }
      function Jd(o, f, b) {
        var P = o.length;
        if (P < 2)
          return P ? Zi(o[0]) : [];
        for (var M = -1, H = be(P); ++M < P; )
          for (var ee = o[M], oe = -1; ++oe < P; )
            oe != M && (H[M] = Mo(H[M] || ee, o[oe], f, b));
        return Zi(yr(H, 1), f, b);
      }
      function zv(o, f, b) {
        for (var P = -1, M = o.length, H = f.length, ee = {}; ++P < M; ) {
          var oe = P < H ? f[P] : r;
          b(ee, o[P], oe);
        }
        return ee;
      }
      function Xd(o) {
        return er(o) ? o : [];
      }
      function Qd(o) {
        return typeof o == "function" ? o : zr;
      }
      function zi(o, f) {
        return pt(o) ? o : up(o, f) ? [o] : _b(qt(o));
      }
      var MC = $t;
      function Wi(o, f, b) {
        var P = o.length;
        return b = b === r ? P : b, !f && b >= P ? o : ln(o, f, b);
      }
      var Wv = $A || function(o) {
        return mr.clearTimeout(o);
      };
      function Hv(o, f) {
        if (f)
          return o.slice();
        var b = o.length, P = hv ? hv(b) : new o.constructor(b);
        return o.copy(P), P;
      }
      function ep(o) {
        var f = new o.constructor(o.byteLength);
        return new _c(f).set(new _c(o)), f;
      }
      function NC(o, f) {
        var b = f ? ep(o.buffer) : o.buffer;
        return new o.constructor(b, o.byteOffset, o.byteLength);
      }
      function DC(o) {
        var f = new o.constructor(o.source, Lt.exec(o));
        return f.lastIndex = o.lastIndex, f;
      }
      function LC(o) {
        return jo ? Zt(jo.call(o)) : {};
      }
      function Gv(o, f) {
        var b = f ? ep(o.buffer) : o.buffer;
        return new o.constructor(b, o.byteOffset, o.length);
      }
      function Kv(o, f) {
        if (o !== f) {
          var b = o !== r, P = o === null, M = o === o, H = Xr(o), ee = f !== r, oe = f === null, he = f === f, Ce = Xr(f);
          if (!oe && !Ce && !H && o > f || H && ee && he && !oe && !Ce || P && ee && he || !b && he || !M)
            return 1;
          if (!P && !H && !Ce && o < f || Ce && b && M && !P && !H || oe && b && M || !ee && M || !he)
            return -1;
        }
        return 0;
      }
      function qC(o, f, b) {
        for (var P = -1, M = o.criteria, H = f.criteria, ee = M.length, oe = b.length; ++P < ee; ) {
          var he = Kv(M[P], H[P]);
          if (he) {
            if (P >= oe)
              return he;
            var Ce = b[P];
            return he * (Ce == "desc" ? -1 : 1);
          }
        }
        return o.index - f.index;
      }
      function Yv(o, f, b, P) {
        for (var M = -1, H = o.length, ee = b.length, oe = -1, he = f.length, Ce = cr(H - ee, 0), Re = be(he + Ce), ke = !P; ++oe < he; )
          Re[oe] = f[oe];
        for (; ++M < ee; )
          (ke || M < H) && (Re[b[M]] = o[M]);
        for (; Ce--; )
          Re[oe++] = o[M++];
        return Re;
      }
      function Jv(o, f, b, P) {
        for (var M = -1, H = o.length, ee = -1, oe = b.length, he = -1, Ce = f.length, Re = cr(H - oe, 0), ke = be(Re + Ce), Ue = !P; ++M < Re; )
          ke[M] = o[M];
        for (var Je = M; ++he < Ce; )
          ke[Je + he] = f[he];
        for (; ++ee < oe; )
          (Ue || M < H) && (ke[Je + b[ee]] = o[M++]);
        return ke;
      }
      function Br(o, f) {
        var b = -1, P = o.length;
        for (f || (f = be(P)); ++b < P; )
          f[b] = o[b];
        return f;
      }
      function Vn(o, f, b, P) {
        var M = !b;
        b || (b = {});
        for (var H = -1, ee = f.length; ++H < ee; ) {
          var oe = f[H], he = P ? P(b[oe], o[oe], oe, b, o) : r;
          he === r && (he = o[oe]), M ? fi(b, oe, he) : ko(b, oe, he);
        }
        return b;
      }
      function FC(o, f) {
        return Vn(o, op(o), f);
      }
      function UC(o, f) {
        return Vn(o, lb(o), f);
      }
      function Mc(o, f) {
        return function(b, P) {
          var M = pt(b) ? WS : cC, H = f ? f() : {};
          return M(b, o, nt(P, 2), H);
        };
      }
      function wa(o) {
        return $t(function(f, b) {
          var P = -1, M = b.length, H = M > 1 ? b[M - 1] : r, ee = M > 2 ? b[2] : r;
          for (H = o.length > 3 && typeof H == "function" ? (M--, H) : r, ee && Ir(b[0], b[1], ee) && (H = M < 3 ? r : H, M = 1), f = Zt(f); ++P < M; ) {
            var oe = b[P];
            oe && o(f, oe, P, H);
          }
          return f;
        });
      }
      function Xv(o, f) {
        return function(b, P) {
          if (b == null)
            return b;
          if (!Vr(b))
            return o(b, P);
          for (var M = b.length, H = f ? M : -1, ee = Zt(b); (f ? H-- : ++H < M) && P(ee[H], H, ee) !== !1; )
            ;
          return b;
        };
      }
      function Qv(o) {
        return function(f, b, P) {
          for (var M = -1, H = Zt(f), ee = P(f), oe = ee.length; oe--; ) {
            var he = ee[o ? oe : ++M];
            if (b(H[he], he, H) === !1)
              break;
          }
          return f;
        };
      }
      function BC(o, f, b) {
        var P = f & _, M = qo(o);
        function H() {
          var ee = this && this !== mr && this instanceof H ? M : o;
          return ee.apply(P ? b : this, arguments);
        }
        return H;
      }
      function eb(o) {
        return function(f) {
          f = qt(f);
          var b = ha(f) ? _n(f) : r, P = b ? b[0] : f.charAt(0), M = b ? Wi(b, 1).join("") : f.slice(1);
          return P[o]() + M;
        };
      }
      function $a(o) {
        return function(f) {
          return Od(Xb(Jb(f).replace(IS, "")), o, "");
        };
      }
      function qo(o) {
        return function() {
          var f = arguments;
          switch (f.length) {
            case 0:
              return new o();
            case 1:
              return new o(f[0]);
            case 2:
              return new o(f[0], f[1]);
            case 3:
              return new o(f[0], f[1], f[2]);
            case 4:
              return new o(f[0], f[1], f[2], f[3]);
            case 5:
              return new o(f[0], f[1], f[2], f[3], f[4]);
            case 6:
              return new o(f[0], f[1], f[2], f[3], f[4], f[5]);
            case 7:
              return new o(f[0], f[1], f[2], f[3], f[4], f[5], f[6]);
          }
          var b = _a(o.prototype), P = o.apply(b, f);
          return Yt(P) ? P : b;
        };
      }
      function VC(o, f, b) {
        var P = qo(o);
        function M() {
          for (var H = arguments.length, ee = be(H), oe = H, he = Ea(M); oe--; )
            ee[oe] = arguments[oe];
          var Ce = H < 3 && ee[0] !== he && ee[H - 1] !== he ? [] : Ui(ee, he);
          if (H -= Ce.length, H < b)
            return sb(
              o,
              f,
              Nc,
              M.placeholder,
              r,
              ee,
              Ce,
              r,
              r,
              b - H
            );
          var Re = this && this !== mr && this instanceof M ? P : o;
          return Kr(Re, this, ee);
        }
        return M;
      }
      function tb(o) {
        return function(f, b, P) {
          var M = Zt(f);
          if (!Vr(f)) {
            var H = nt(b, 3);
            f = dr(f), b = function(oe) {
              return H(M[oe], oe, M);
            };
          }
          var ee = o(f, b, P);
          return ee > -1 ? M[H ? f[ee] : ee] : r;
        };
      }
      function rb(o) {
        return pi(function(f) {
          var b = f.length, P = b, M = un.prototype.thru;
          for (o && f.reverse(); P--; ) {
            var H = f[P];
            if (typeof H != "function")
              throw new on(a);
            if (M && !ee && Fc(H) == "wrapper")
              var ee = new un([], !0);
          }
          for (P = ee ? P : b; ++P < b; ) {
            H = f[P];
            var oe = Fc(H), he = oe == "wrapper" ? sp(H) : r;
            he && cp(he[0]) && he[1] == (I | $ | A | D) && !he[4].length && he[9] == 1 ? ee = ee[Fc(he[0])].apply(ee, he[3]) : ee = H.length == 1 && cp(H) ? ee[oe]() : ee.thru(H);
          }
          return function() {
            var Ce = arguments, Re = Ce[0];
            if (ee && Ce.length == 1 && pt(Re))
              return ee.plant(Re).value();
            for (var ke = 0, Ue = b ? f[ke].apply(this, Ce) : Re; ++ke < b; )
              Ue = f[ke].call(this, Ue);
            return Ue;
          };
        });
      }
      function Nc(o, f, b, P, M, H, ee, oe, he, Ce) {
        var Re = f & I, ke = f & _, Ue = f & m, Je = f & ($ | E), it = f & J, bt = Ue ? r : qo(o);
        function st() {
          for (var Ot = arguments.length, Rt = be(Ot), Qr = Ot; Qr--; )
            Rt[Qr] = arguments[Qr];
          if (Je)
            var jr = Ea(st), en = tA(Rt, jr);
          if (P && (Rt = Yv(Rt, P, M, Je)), H && (Rt = Jv(Rt, H, ee, Je)), Ot -= en, Je && Ot < Ce) {
            var tr = Ui(Rt, jr);
            return sb(
              o,
              f,
              Nc,
              st.placeholder,
              b,
              Rt,
              tr,
              oe,
              he,
              Ce - Ot
            );
          }
          var En = ke ? b : this, gi = Ue ? En[o] : o;
          return Ot = Rt.length, oe ? Rt = cR(Rt, oe) : it && Ot > 1 && Rt.reverse(), Re && he < Ot && (Rt.length = he), this && this !== mr && this instanceof st && (gi = bt || qo(gi)), gi.apply(En, Rt);
        }
        return st;
      }
      function nb(o, f) {
        return function(b, P) {
          return gC(b, o, f(P), {});
        };
      }
      function Dc(o, f) {
        return function(b, P) {
          var M;
          if (b === r && P === r)
            return f;
          if (b !== r && (M = b), P !== r) {
            if (M === r)
              return P;
            typeof b == "string" || typeof P == "string" ? (b = Jr(b), P = Jr(P)) : (b = Bv(b), P = Bv(P)), M = o(b, P);
          }
          return M;
        };
      }
      function tp(o) {
        return pi(function(f) {
          return f = Kt(f, Yr(nt())), $t(function(b) {
            var P = this;
            return o(f, function(M) {
              return Kr(M, P, b);
            });
          });
        });
      }
      function Lc(o, f) {
        f = f === r ? " " : Jr(f);
        var b = f.length;
        if (b < 2)
          return b ? Gd(f, o) : f;
        var P = Gd(f, xc(o / ma(f)));
        return ha(f) ? Wi(_n(P), 0, o).join("") : P.slice(0, o);
      }
      function ZC(o, f, b, P) {
        var M = f & _, H = qo(o);
        function ee() {
          for (var oe = -1, he = arguments.length, Ce = -1, Re = P.length, ke = be(Re + he), Ue = this && this !== mr && this instanceof ee ? H : o; ++Ce < Re; )
            ke[Ce] = P[Ce];
          for (; he--; )
            ke[Ce++] = arguments[++oe];
          return Kr(Ue, M ? b : this, ke);
        }
        return ee;
      }
      function ib(o) {
        return function(f, b, P) {
          return P && typeof P != "number" && Ir(f, b, P) && (b = P = r), f = yi(f), b === r ? (b = f, f = 0) : b = yi(b), P = P === r ? f < b ? 1 : -1 : yi(P), CC(f, b, P, o);
        };
      }
      function qc(o) {
        return function(f, b) {
          return typeof f == "string" && typeof b == "string" || (f = dn(f), b = dn(b)), o(f, b);
        };
      }
      function sb(o, f, b, P, M, H, ee, oe, he, Ce) {
        var Re = f & $, ke = Re ? ee : r, Ue = Re ? r : ee, Je = Re ? H : r, it = Re ? r : H;
        f |= Re ? A : R, f &= ~(Re ? R : A), f & w || (f &= ~(_ | m));
        var bt = [
          o,
          f,
          M,
          Je,
          ke,
          it,
          Ue,
          oe,
          he,
          Ce
        ], st = b.apply(r, bt);
        return cp(o) && gb(st, bt), st.placeholder = P, vb(st, o, f);
      }
      function rp(o) {
        var f = ur[o];
        return function(b, P) {
          if (b = dn(b), P = P == null ? 0 : wr(gt(P), 292), P && vv(b)) {
            var M = (qt(b) + "e").split("e"), H = f(M[0] + "e" + (+M[1] + P));
            return M = (qt(H) + "e").split("e"), +(M[0] + "e" + (+M[1] - P));
          }
          return f(b);
        };
      }
      var zC = va && 1 / hc(new va([, -0]))[1] == $e ? function(o) {
        return new va(o);
      } : xp;
      function ab(o) {
        return function(f) {
          var b = $r(f);
          return b == we ? Id(f) : b == St ? uA(f) : eA(f, o(f));
        };
      }
      function di(o, f, b, P, M, H, ee, oe) {
        var he = f & m;
        if (!he && typeof o != "function")
          throw new on(a);
        var Ce = P ? P.length : 0;
        if (Ce || (f &= ~(A | R), P = M = r), ee = ee === r ? ee : cr(gt(ee), 0), oe = oe === r ? oe : gt(oe), Ce -= M ? M.length : 0, f & R) {
          var Re = P, ke = M;
          P = M = r;
        }
        var Ue = he ? r : sp(o), Je = [
          o,
          f,
          b,
          P,
          M,
          Re,
          ke,
          H,
          ee,
          oe
        ];
        if (Ue && aR(Je, Ue), o = Je[0], f = Je[1], b = Je[2], P = Je[3], M = Je[4], oe = Je[9] = Je[9] === r ? he ? 0 : o.length : cr(Je[9] - Ce, 0), !oe && f & ($ | E) && (f &= ~($ | E)), !f || f == _)
          var it = BC(o, f, b);
        else
          f == $ || f == E ? it = VC(o, f, oe) : (f == A || f == (_ | A)) && !M.length ? it = ZC(o, f, b, P) : it = Nc.apply(r, Je);
        var bt = Ue ? Fv : gb;
        return vb(bt(it, Je), o, f);
      }
      function ob(o, f, b, P) {
        return o === r || $n(o, ga[b]) && !Ft.call(P, b) ? f : o;
      }
      function ub(o, f, b, P, M, H) {
        return Yt(o) && Yt(f) && (H.set(f, o), Ic(o, f, r, ub, H), H.delete(f)), o;
      }
      function WC(o) {
        return Bo(o) ? r : o;
      }
      function cb(o, f, b, P, M, H) {
        var ee = b & y, oe = o.length, he = f.length;
        if (oe != he && !(ee && he > oe))
          return !1;
        var Ce = H.get(o), Re = H.get(f);
        if (Ce && Re)
          return Ce == f && Re == o;
        var ke = -1, Ue = !0, Je = b & g ? new As() : r;
        for (H.set(o, f), H.set(f, o); ++ke < oe; ) {
          var it = o[ke], bt = f[ke];
          if (P)
            var st = ee ? P(bt, it, ke, f, o, H) : P(it, bt, ke, o, f, H);
          if (st !== r) {
            if (st)
              continue;
            Ue = !1;
            break;
          }
          if (Je) {
            if (!Pd(f, function(Ot, Rt) {
              if (!Ao(Je, Rt) && (it === Ot || M(it, Ot, b, P, H)))
                return Je.push(Rt);
            })) {
              Ue = !1;
              break;
            }
          } else if (!(it === bt || M(it, bt, b, P, H))) {
            Ue = !1;
            break;
          }
        }
        return H.delete(o), H.delete(f), Ue;
      }
      function HC(o, f, b, P, M, H, ee) {
        switch (b) {
          case x:
            if (o.byteLength != f.byteLength || o.byteOffset != f.byteOffset)
              return !1;
            o = o.buffer, f = f.buffer;
          case L:
            return !(o.byteLength != f.byteLength || !H(new _c(o), new _c(f)));
          case T:
          case Z:
          case He:
            return $n(+o, +f);
          case k:
            return o.name == f.name && o.message == f.message;
          case Mt:
          case Ne:
            return o == f + "";
          case we:
            var oe = Id;
          case St:
            var he = P & y;
            if (oe || (oe = hc), o.size != f.size && !he)
              return !1;
            var Ce = ee.get(o);
            if (Ce)
              return Ce == f;
            P |= g, ee.set(o, f);
            var Re = cb(oe(o), oe(f), P, M, H, ee);
            return ee.delete(o), Re;
          case Le:
            if (jo)
              return jo.call(o) == jo.call(f);
        }
        return !1;
      }
      function GC(o, f, b, P, M, H) {
        var ee = b & y, oe = np(o), he = oe.length, Ce = np(f), Re = Ce.length;
        if (he != Re && !ee)
          return !1;
        for (var ke = he; ke--; ) {
          var Ue = oe[ke];
          if (!(ee ? Ue in f : Ft.call(f, Ue)))
            return !1;
        }
        var Je = H.get(o), it = H.get(f);
        if (Je && it)
          return Je == f && it == o;
        var bt = !0;
        H.set(o, f), H.set(f, o);
        for (var st = ee; ++ke < he; ) {
          Ue = oe[ke];
          var Ot = o[Ue], Rt = f[Ue];
          if (P)
            var Qr = ee ? P(Rt, Ot, Ue, f, o, H) : P(Ot, Rt, Ue, o, f, H);
          if (!(Qr === r ? Ot === Rt || M(Ot, Rt, b, P, H) : Qr)) {
            bt = !1;
            break;
          }
          st || (st = Ue == "constructor");
        }
        if (bt && !st) {
          var jr = o.constructor, en = f.constructor;
          jr != en && "constructor" in o && "constructor" in f && !(typeof jr == "function" && jr instanceof jr && typeof en == "function" && en instanceof en) && (bt = !1);
        }
        return H.delete(o), H.delete(f), bt;
      }
      function pi(o) {
        return fp(mb(o, r, xb), o + "");
      }
      function np(o) {
        return Cv(o, dr, op);
      }
      function ip(o) {
        return Cv(o, Zr, lb);
      }
      var sp = Pc ? function(o) {
        return Pc.get(o);
      } : xp;
      function Fc(o) {
        for (var f = o.name + "", b = ba[f], P = Ft.call(ba, f) ? b.length : 0; P--; ) {
          var M = b[P], H = M.func;
          if (H == null || H == o)
            return M.name;
        }
        return f;
      }
      function Ea(o) {
        var f = Ft.call(B, "placeholder") ? B : o;
        return f.placeholder;
      }
      function nt() {
        var o = B.iteratee || $p;
        return o = o === $p ? Iv : o, arguments.length ? o(arguments[0], arguments[1]) : o;
      }
      function Uc(o, f) {
        var b = o.__data__;
        return rR(f) ? b[typeof f == "string" ? "string" : "hash"] : b.map;
      }
      function ap(o) {
        for (var f = dr(o), b = f.length; b--; ) {
          var P = f[b], M = o[P];
          f[b] = [P, M, pb(M)];
        }
        return f;
      }
      function Ts(o, f) {
        var b = sA(o, f);
        return Tv(b) ? b : r;
      }
      function KC(o) {
        var f = Ft.call(o, Ps), b = o[Ps];
        try {
          o[Ps] = r;
          var P = !0;
        } catch {
        }
        var M = vc.call(o);
        return P && (f ? o[Ps] = b : delete o[Ps]), M;
      }
      var op = kd ? function(o) {
        return o == null ? [] : (o = Zt(o), qi(kd(o), function(f) {
          return yv.call(o, f);
        }));
      } : Op, lb = kd ? function(o) {
        for (var f = []; o; )
          Fi(f, op(o)), o = wc(o);
        return f;
      } : Op, $r = Tr;
      (Md && $r(new Md(new ArrayBuffer(1))) != x || Ro && $r(new Ro()) != we || Nd && $r(Nd.resolve()) != jt || va && $r(new va()) != St || To && $r(new To()) != mt) && ($r = function(o) {
        var f = Tr(o), b = f == Ge ? o.constructor : r, P = b ? Is(b) : "";
        if (P)
          switch (P) {
            case TA:
              return x;
            case IA:
              return we;
            case jA:
              return jt;
            case kA:
              return St;
            case MA:
              return mt;
          }
        return f;
      });
      function YC(o, f, b) {
        for (var P = -1, M = b.length; ++P < M; ) {
          var H = b[P], ee = H.size;
          switch (H.type) {
            case "drop":
              o += ee;
              break;
            case "dropRight":
              f -= ee;
              break;
            case "take":
              f = wr(f, o + ee);
              break;
            case "takeRight":
              o = cr(o, f - ee);
              break;
          }
        }
        return { start: o, end: f };
      }
      function JC(o) {
        var f = o.match(ue);
        return f ? f[1].split(ve) : [];
      }
      function fb(o, f, b) {
        f = zi(f, o);
        for (var P = -1, M = f.length, H = !1; ++P < M; ) {
          var ee = Zn(f[P]);
          if (!(H = o != null && b(o, ee)))
            break;
          o = o[ee];
        }
        return H || ++P != M ? H : (M = o == null ? 0 : o.length, !!M && Gc(M) && hi(ee, M) && (pt(o) || js(o)));
      }
      function XC(o) {
        var f = o.length, b = new o.constructor(f);
        return f && typeof o[0] == "string" && Ft.call(o, "index") && (b.index = o.index, b.input = o.input), b;
      }
      function db(o) {
        return typeof o.constructor == "function" && !Fo(o) ? _a(wc(o)) : {};
      }
      function QC(o, f, b) {
        var P = o.constructor;
        switch (f) {
          case L:
            return ep(o);
          case T:
          case Z:
            return new P(+o);
          case x:
            return NC(o, b);
          case S:
          case G:
          case ce:
          case me:
          case Oe:
          case ut:
          case Dt:
          case Tt:
          case wt:
            return Gv(o, b);
          case we:
            return new P();
          case He:
          case Ne:
            return new P(o);
          case Mt:
            return DC(o);
          case St:
            return new P();
          case Le:
            return LC(o);
        }
      }
      function eR(o, f) {
        var b = f.length;
        if (!b)
          return o;
        var P = b - 1;
        return f[P] = (b > 1 ? "& " : "") + f[P], f = f.join(b > 2 ? ", " : " "), o.replace(X, `{
/* [wrapped with ` + f + `] */
`);
      }
      function tR(o) {
        return pt(o) || js(o) || !!(gv && o && o[gv]);
      }
      function hi(o, f) {
        var b = typeof o;
        return f = f ?? Ae, !!f && (b == "number" || b != "symbol" && j.test(o)) && o > -1 && o % 1 == 0 && o < f;
      }
      function Ir(o, f, b) {
        if (!Yt(b))
          return !1;
        var P = typeof f;
        return (P == "number" ? Vr(b) && hi(f, b.length) : P == "string" && f in b) ? $n(b[f], o) : !1;
      }
      function up(o, f) {
        if (pt(o))
          return !1;
        var b = typeof o;
        return b == "number" || b == "symbol" || b == "boolean" || o == null || Xr(o) ? !0 : fa.test(o) || !ws.test(o) || f != null && o in Zt(f);
      }
      function rR(o) {
        var f = typeof o;
        return f == "string" || f == "number" || f == "symbol" || f == "boolean" ? o !== "__proto__" : o === null;
      }
      function cp(o) {
        var f = Fc(o), b = B[f];
        if (typeof b != "function" || !(f in At.prototype))
          return !1;
        if (o === b)
          return !0;
        var P = sp(b);
        return !!P && o === P[0];
      }
      function nR(o) {
        return !!pv && pv in o;
      }
      var iR = yc ? mi : Pp;
      function Fo(o) {
        var f = o && o.constructor, b = typeof f == "function" && f.prototype || ga;
        return o === b;
      }
      function pb(o) {
        return o === o && !Yt(o);
      }
      function hb(o, f) {
        return function(b) {
          return b == null ? !1 : b[o] === f && (f !== r || o in Zt(b));
        };
      }
      function sR(o) {
        var f = Wc(o, function(P) {
          return b.size === l && b.clear(), P;
        }), b = f.cache;
        return f;
      }
      function aR(o, f) {
        var b = o[1], P = f[1], M = b | P, H = M < (_ | m | I), ee = P == I && b == $ || P == I && b == D && o[7].length <= f[8] || P == (I | D) && f[7].length <= f[8] && b == $;
        if (!(H || ee))
          return o;
        P & _ && (o[2] = f[2], M |= b & _ ? 0 : w);
        var oe = f[3];
        if (oe) {
          var he = o[3];
          o[3] = he ? Yv(he, oe, f[4]) : oe, o[4] = he ? Ui(o[3], d) : f[4];
        }
        return oe = f[5], oe && (he = o[5], o[5] = he ? Jv(he, oe, f[6]) : oe, o[6] = he ? Ui(o[5], d) : f[6]), oe = f[7], oe && (o[7] = oe), P & I && (o[8] = o[8] == null ? f[8] : wr(o[8], f[8])), o[9] == null && (o[9] = f[9]), o[0] = f[0], o[1] = M, o;
      }
      function oR(o) {
        var f = [];
        if (o != null)
          for (var b in Zt(o))
            f.push(b);
        return f;
      }
      function uR(o) {
        return vc.call(o);
      }
      function mb(o, f, b) {
        return f = cr(f === r ? o.length - 1 : f, 0), function() {
          for (var P = arguments, M = -1, H = cr(P.length - f, 0), ee = be(H); ++M < H; )
            ee[M] = P[f + M];
          M = -1;
          for (var oe = be(f + 1); ++M < f; )
            oe[M] = P[M];
          return oe[f] = b(ee), Kr(o, this, oe);
        };
      }
      function yb(o, f) {
        return f.length < 2 ? o : Rs(o, ln(f, 0, -1));
      }
      function cR(o, f) {
        for (var b = o.length, P = wr(f.length, b), M = Br(o); P--; ) {
          var H = f[P];
          o[P] = hi(H, b) ? M[H] : r;
        }
        return o;
      }
      function lp(o, f) {
        if (!(f === "constructor" && typeof o[f] == "function") && f != "__proto__")
          return o[f];
      }
      var gb = bb(Fv), Uo = xA || function(o, f) {
        return mr.setTimeout(o, f);
      }, fp = bb(IC);
      function vb(o, f, b) {
        var P = f + "";
        return fp(o, eR(P, lR(JC(P), b)));
      }
      function bb(o) {
        var f = 0, b = 0;
        return function() {
          var P = AA(), M = je - (P - b);
          if (b = P, M > 0) {
            if (++f >= xe)
              return arguments[0];
          } else
            f = 0;
          return o.apply(r, arguments);
        };
      }
      function Bc(o, f) {
        var b = -1, P = o.length, M = P - 1;
        for (f = f === r ? P : f; ++b < f; ) {
          var H = Hd(b, M), ee = o[H];
          o[H] = o[b], o[b] = ee;
        }
        return o.length = f, o;
      }
      var _b = sR(function(o) {
        var f = [];
        return o.charCodeAt(0) === 46 && f.push(""), o.replace(xo, function(b, P, M, H) {
          f.push(M ? H.replace(Xe, "$1") : P || b);
        }), f;
      });
      function Zn(o) {
        if (typeof o == "string" || Xr(o))
          return o;
        var f = o + "";
        return f == "0" && 1 / o == -$e ? "-0" : f;
      }
      function Is(o) {
        if (o != null) {
          try {
            return gc.call(o);
          } catch {
          }
          try {
            return o + "";
          } catch {
          }
        }
        return "";
      }
      function lR(o, f) {
        return an(C, function(b) {
          var P = "_." + b[0];
          f & b[1] && !dc(o, P) && o.push(P);
        }), o.sort();
      }
      function wb(o) {
        if (o instanceof At)
          return o.clone();
        var f = new un(o.__wrapped__, o.__chain__);
        return f.__actions__ = Br(o.__actions__), f.__index__ = o.__index__, f.__values__ = o.__values__, f;
      }
      function fR(o, f, b) {
        (b ? Ir(o, f, b) : f === r) ? f = 1 : f = cr(gt(f), 0);
        var P = o == null ? 0 : o.length;
        if (!P || f < 1)
          return [];
        for (var M = 0, H = 0, ee = be(xc(P / f)); M < P; )
          ee[H++] = ln(o, M, M += f);
        return ee;
      }
      function dR(o) {
        for (var f = -1, b = o == null ? 0 : o.length, P = 0, M = []; ++f < b; ) {
          var H = o[f];
          H && (M[P++] = H);
        }
        return M;
      }
      function pR() {
        var o = arguments.length;
        if (!o)
          return [];
        for (var f = be(o - 1), b = arguments[0], P = o; P--; )
          f[P - 1] = arguments[P];
        return Fi(pt(b) ? Br(b) : [b], yr(f, 1));
      }
      var hR = $t(function(o, f) {
        return er(o) ? Mo(o, yr(f, 1, er, !0)) : [];
      }), mR = $t(function(o, f) {
        var b = fn(f);
        return er(b) && (b = r), er(o) ? Mo(o, yr(f, 1, er, !0), nt(b, 2)) : [];
      }), yR = $t(function(o, f) {
        var b = fn(f);
        return er(b) && (b = r), er(o) ? Mo(o, yr(f, 1, er, !0), r, b) : [];
      });
      function gR(o, f, b) {
        var P = o == null ? 0 : o.length;
        return P ? (f = b || f === r ? 1 : gt(f), ln(o, f < 0 ? 0 : f, P)) : [];
      }
      function vR(o, f, b) {
        var P = o == null ? 0 : o.length;
        return P ? (f = b || f === r ? 1 : gt(f), f = P - f, ln(o, 0, f < 0 ? 0 : f)) : [];
      }
      function bR(o, f) {
        return o && o.length ? kc(o, nt(f, 3), !0, !0) : [];
      }
      function _R(o, f) {
        return o && o.length ? kc(o, nt(f, 3), !0) : [];
      }
      function wR(o, f, b, P) {
        var M = o == null ? 0 : o.length;
        return M ? (b && typeof b != "number" && Ir(o, f, b) && (b = 0, P = M), pC(o, f, b, P)) : [];
      }
      function $b(o, f, b) {
        var P = o == null ? 0 : o.length;
        if (!P)
          return -1;
        var M = b == null ? 0 : gt(b);
        return M < 0 && (M = cr(P + M, 0)), pc(o, nt(f, 3), M);
      }
      function Eb(o, f, b) {
        var P = o == null ? 0 : o.length;
        if (!P)
          return -1;
        var M = P - 1;
        return b !== r && (M = gt(b), M = b < 0 ? cr(P + M, 0) : wr(M, P - 1)), pc(o, nt(f, 3), M, !0);
      }
      function xb(o) {
        var f = o == null ? 0 : o.length;
        return f ? yr(o, 1) : [];
      }
      function $R(o) {
        var f = o == null ? 0 : o.length;
        return f ? yr(o, $e) : [];
      }
      function ER(o, f) {
        var b = o == null ? 0 : o.length;
        return b ? (f = f === r ? 1 : gt(f), yr(o, f)) : [];
      }
      function xR(o) {
        for (var f = -1, b = o == null ? 0 : o.length, P = {}; ++f < b; ) {
          var M = o[f];
          P[M[0]] = M[1];
        }
        return P;
      }
      function Ob(o) {
        return o && o.length ? o[0] : r;
      }
      function OR(o, f, b) {
        var P = o == null ? 0 : o.length;
        if (!P)
          return -1;
        var M = b == null ? 0 : gt(b);
        return M < 0 && (M = cr(P + M, 0)), pa(o, f, M);
      }
      function PR(o) {
        var f = o == null ? 0 : o.length;
        return f ? ln(o, 0, -1) : [];
      }
      var SR = $t(function(o) {
        var f = Kt(o, Xd);
        return f.length && f[0] === o[0] ? Bd(f) : [];
      }), AR = $t(function(o) {
        var f = fn(o), b = Kt(o, Xd);
        return f === fn(b) ? f = r : b.pop(), b.length && b[0] === o[0] ? Bd(b, nt(f, 2)) : [];
      }), CR = $t(function(o) {
        var f = fn(o), b = Kt(o, Xd);
        return f = typeof f == "function" ? f : r, f && b.pop(), b.length && b[0] === o[0] ? Bd(b, r, f) : [];
      });
      function RR(o, f) {
        return o == null ? "" : PA.call(o, f);
      }
      function fn(o) {
        var f = o == null ? 0 : o.length;
        return f ? o[f - 1] : r;
      }
      function TR(o, f, b) {
        var P = o == null ? 0 : o.length;
        if (!P)
          return -1;
        var M = P;
        return b !== r && (M = gt(b), M = M < 0 ? cr(P + M, 0) : wr(M, P - 1)), f === f ? lA(o, f, M) : pc(o, sv, M, !0);
      }
      function IR(o, f) {
        return o && o.length ? Nv(o, gt(f)) : r;
      }
      var jR = $t(Pb);
      function Pb(o, f) {
        return o && o.length && f && f.length ? Wd(o, f) : o;
      }
      function kR(o, f, b) {
        return o && o.length && f && f.length ? Wd(o, f, nt(b, 2)) : o;
      }
      function MR(o, f, b) {
        return o && o.length && f && f.length ? Wd(o, f, r, b) : o;
      }
      var NR = pi(function(o, f) {
        var b = o == null ? 0 : o.length, P = Ld(o, f);
        return qv(o, Kt(f, function(M) {
          return hi(M, b) ? +M : M;
        }).sort(Kv)), P;
      });
      function DR(o, f) {
        var b = [];
        if (!(o && o.length))
          return b;
        var P = -1, M = [], H = o.length;
        for (f = nt(f, 3); ++P < H; ) {
          var ee = o[P];
          f(ee, P, o) && (b.push(ee), M.push(P));
        }
        return qv(o, M), b;
      }
      function dp(o) {
        return o == null ? o : RA.call(o);
      }
      function LR(o, f, b) {
        var P = o == null ? 0 : o.length;
        return P ? (b && typeof b != "number" && Ir(o, f, b) ? (f = 0, b = P) : (f = f == null ? 0 : gt(f), b = b === r ? P : gt(b)), ln(o, f, b)) : [];
      }
      function qR(o, f) {
        return jc(o, f);
      }
      function FR(o, f, b) {
        return Kd(o, f, nt(b, 2));
      }
      function UR(o, f) {
        var b = o == null ? 0 : o.length;
        if (b) {
          var P = jc(o, f);
          if (P < b && $n(o[P], f))
            return P;
        }
        return -1;
      }
      function BR(o, f) {
        return jc(o, f, !0);
      }
      function VR(o, f, b) {
        return Kd(o, f, nt(b, 2), !0);
      }
      function ZR(o, f) {
        var b = o == null ? 0 : o.length;
        if (b) {
          var P = jc(o, f, !0) - 1;
          if ($n(o[P], f))
            return P;
        }
        return -1;
      }
      function zR(o) {
        return o && o.length ? Uv(o) : [];
      }
      function WR(o, f) {
        return o && o.length ? Uv(o, nt(f, 2)) : [];
      }
      function HR(o) {
        var f = o == null ? 0 : o.length;
        return f ? ln(o, 1, f) : [];
      }
      function GR(o, f, b) {
        return o && o.length ? (f = b || f === r ? 1 : gt(f), ln(o, 0, f < 0 ? 0 : f)) : [];
      }
      function KR(o, f, b) {
        var P = o == null ? 0 : o.length;
        return P ? (f = b || f === r ? 1 : gt(f), f = P - f, ln(o, f < 0 ? 0 : f, P)) : [];
      }
      function YR(o, f) {
        return o && o.length ? kc(o, nt(f, 3), !1, !0) : [];
      }
      function JR(o, f) {
        return o && o.length ? kc(o, nt(f, 3)) : [];
      }
      var XR = $t(function(o) {
        return Zi(yr(o, 1, er, !0));
      }), QR = $t(function(o) {
        var f = fn(o);
        return er(f) && (f = r), Zi(yr(o, 1, er, !0), nt(f, 2));
      }), eT = $t(function(o) {
        var f = fn(o);
        return f = typeof f == "function" ? f : r, Zi(yr(o, 1, er, !0), r, f);
      });
      function tT(o) {
        return o && o.length ? Zi(o) : [];
      }
      function rT(o, f) {
        return o && o.length ? Zi(o, nt(f, 2)) : [];
      }
      function nT(o, f) {
        return f = typeof f == "function" ? f : r, o && o.length ? Zi(o, r, f) : [];
      }
      function pp(o) {
        if (!(o && o.length))
          return [];
        var f = 0;
        return o = qi(o, function(b) {
          if (er(b))
            return f = cr(b.length, f), !0;
        }), Rd(f, function(b) {
          return Kt(o, Sd(b));
        });
      }
      function Sb(o, f) {
        if (!(o && o.length))
          return [];
        var b = pp(o);
        return f == null ? b : Kt(b, function(P) {
          return Kr(f, r, P);
        });
      }
      var iT = $t(function(o, f) {
        return er(o) ? Mo(o, f) : [];
      }), sT = $t(function(o) {
        return Jd(qi(o, er));
      }), aT = $t(function(o) {
        var f = fn(o);
        return er(f) && (f = r), Jd(qi(o, er), nt(f, 2));
      }), oT = $t(function(o) {
        var f = fn(o);
        return f = typeof f == "function" ? f : r, Jd(qi(o, er), r, f);
      }), uT = $t(pp);
      function cT(o, f) {
        return zv(o || [], f || [], ko);
      }
      function lT(o, f) {
        return zv(o || [], f || [], Lo);
      }
      var fT = $t(function(o) {
        var f = o.length, b = f > 1 ? o[f - 1] : r;
        return b = typeof b == "function" ? (o.pop(), b) : r, Sb(o, b);
      });
      function Ab(o) {
        var f = B(o);
        return f.__chain__ = !0, f;
      }
      function dT(o, f) {
        return f(o), o;
      }
      function Vc(o, f) {
        return f(o);
      }
      var pT = pi(function(o) {
        var f = o.length, b = f ? o[0] : 0, P = this.__wrapped__, M = function(H) {
          return Ld(H, o);
        };
        return f > 1 || this.__actions__.length || !(P instanceof At) || !hi(b) ? this.thru(M) : (P = P.slice(b, +b + (f ? 1 : 0)), P.__actions__.push({
          func: Vc,
          args: [M],
          thisArg: r
        }), new un(P, this.__chain__).thru(function(H) {
          return f && !H.length && H.push(r), H;
        }));
      });
      function hT() {
        return Ab(this);
      }
      function mT() {
        return new un(this.value(), this.__chain__);
      }
      function yT() {
        this.__values__ === r && (this.__values__ = Bb(this.value()));
        var o = this.__index__ >= this.__values__.length, f = o ? r : this.__values__[this.__index__++];
        return { done: o, value: f };
      }
      function gT() {
        return this;
      }
      function vT(o) {
        for (var f, b = this; b instanceof Ac; ) {
          var P = wb(b);
          P.__index__ = 0, P.__values__ = r, f ? M.__wrapped__ = P : f = P;
          var M = P;
          b = b.__wrapped__;
        }
        return M.__wrapped__ = o, f;
      }
      function bT() {
        var o = this.__wrapped__;
        if (o instanceof At) {
          var f = o;
          return this.__actions__.length && (f = new At(this)), f = f.reverse(), f.__actions__.push({
            func: Vc,
            args: [dp],
            thisArg: r
          }), new un(f, this.__chain__);
        }
        return this.thru(dp);
      }
      function _T() {
        return Zv(this.__wrapped__, this.__actions__);
      }
      var wT = Mc(function(o, f, b) {
        Ft.call(o, b) ? ++o[b] : fi(o, b, 1);
      });
      function $T(o, f, b) {
        var P = pt(o) ? nv : dC;
        return b && Ir(o, f, b) && (f = r), P(o, nt(f, 3));
      }
      function ET(o, f) {
        var b = pt(o) ? qi : Sv;
        return b(o, nt(f, 3));
      }
      var xT = tb($b), OT = tb(Eb);
      function PT(o, f) {
        return yr(Zc(o, f), 1);
      }
      function ST(o, f) {
        return yr(Zc(o, f), $e);
      }
      function AT(o, f, b) {
        return b = b === r ? 1 : gt(b), yr(Zc(o, f), b);
      }
      function Cb(o, f) {
        var b = pt(o) ? an : Vi;
        return b(o, nt(f, 3));
      }
      function Rb(o, f) {
        var b = pt(o) ? HS : Pv;
        return b(o, nt(f, 3));
      }
      var CT = Mc(function(o, f, b) {
        Ft.call(o, b) ? o[b].push(f) : fi(o, b, [f]);
      });
      function RT(o, f, b, P) {
        o = Vr(o) ? o : Oa(o), b = b && !P ? gt(b) : 0;
        var M = o.length;
        return b < 0 && (b = cr(M + b, 0)), Kc(o) ? b <= M && o.indexOf(f, b) > -1 : !!M && pa(o, f, b) > -1;
      }
      var TT = $t(function(o, f, b) {
        var P = -1, M = typeof f == "function", H = Vr(o) ? be(o.length) : [];
        return Vi(o, function(ee) {
          H[++P] = M ? Kr(f, ee, b) : No(ee, f, b);
        }), H;
      }), IT = Mc(function(o, f, b) {
        fi(o, b, f);
      });
      function Zc(o, f) {
        var b = pt(o) ? Kt : jv;
        return b(o, nt(f, 3));
      }
      function jT(o, f, b, P) {
        return o == null ? [] : (pt(f) || (f = f == null ? [] : [f]), b = P ? r : b, pt(b) || (b = b == null ? [] : [b]), Dv(o, f, b));
      }
      var kT = Mc(function(o, f, b) {
        o[b ? 0 : 1].push(f);
      }, function() {
        return [[], []];
      });
      function MT(o, f, b) {
        var P = pt(o) ? Od : ov, M = arguments.length < 3;
        return P(o, nt(f, 4), b, M, Vi);
      }
      function NT(o, f, b) {
        var P = pt(o) ? GS : ov, M = arguments.length < 3;
        return P(o, nt(f, 4), b, M, Pv);
      }
      function DT(o, f) {
        var b = pt(o) ? qi : Sv;
        return b(o, Hc(nt(f, 3)));
      }
      function LT(o) {
        var f = pt(o) ? $v : RC;
        return f(o);
      }
      function qT(o, f, b) {
        (b ? Ir(o, f, b) : f === r) ? f = 1 : f = gt(f);
        var P = pt(o) ? oC : TC;
        return P(o, f);
      }
      function FT(o) {
        var f = pt(o) ? uC : jC;
        return f(o);
      }
      function UT(o) {
        if (o == null)
          return 0;
        if (Vr(o))
          return Kc(o) ? ma(o) : o.length;
        var f = $r(o);
        return f == we || f == St ? o.size : Zd(o).length;
      }
      function BT(o, f, b) {
        var P = pt(o) ? Pd : kC;
        return b && Ir(o, f, b) && (f = r), P(o, nt(f, 3));
      }
      var VT = $t(function(o, f) {
        if (o == null)
          return [];
        var b = f.length;
        return b > 1 && Ir(o, f[0], f[1]) ? f = [] : b > 2 && Ir(f[0], f[1], f[2]) && (f = [f[0]]), Dv(o, yr(f, 1), []);
      }), zc = EA || function() {
        return mr.Date.now();
      };
      function ZT(o, f) {
        if (typeof f != "function")
          throw new on(a);
        return o = gt(o), function() {
          if (--o < 1)
            return f.apply(this, arguments);
        };
      }
      function Tb(o, f, b) {
        return f = b ? r : f, f = o && f == null ? o.length : f, di(o, I, r, r, r, r, f);
      }
      function Ib(o, f) {
        var b;
        if (typeof f != "function")
          throw new on(a);
        return o = gt(o), function() {
          return --o > 0 && (b = f.apply(this, arguments)), o <= 1 && (f = r), b;
        };
      }
      var hp = $t(function(o, f, b) {
        var P = _;
        if (b.length) {
          var M = Ui(b, Ea(hp));
          P |= A;
        }
        return di(o, P, f, b, M);
      }), jb = $t(function(o, f, b) {
        var P = _ | m;
        if (b.length) {
          var M = Ui(b, Ea(jb));
          P |= A;
        }
        return di(f, P, o, b, M);
      });
      function kb(o, f, b) {
        f = b ? r : f;
        var P = di(o, $, r, r, r, r, r, f);
        return P.placeholder = kb.placeholder, P;
      }
      function Mb(o, f, b) {
        f = b ? r : f;
        var P = di(o, E, r, r, r, r, r, f);
        return P.placeholder = Mb.placeholder, P;
      }
      function Nb(o, f, b) {
        var P, M, H, ee, oe, he, Ce = 0, Re = !1, ke = !1, Ue = !0;
        if (typeof o != "function")
          throw new on(a);
        f = dn(f) || 0, Yt(b) && (Re = !!b.leading, ke = "maxWait" in b, H = ke ? cr(dn(b.maxWait) || 0, f) : H, Ue = "trailing" in b ? !!b.trailing : Ue);
        function Je(tr) {
          var En = P, gi = M;
          return P = M = r, Ce = tr, ee = o.apply(gi, En), ee;
        }
        function it(tr) {
          return Ce = tr, oe = Uo(Ot, f), Re ? Je(tr) : ee;
        }
        function bt(tr) {
          var En = tr - he, gi = tr - Ce, t1 = f - En;
          return ke ? wr(t1, H - gi) : t1;
        }
        function st(tr) {
          var En = tr - he, gi = tr - Ce;
          return he === r || En >= f || En < 0 || ke && gi >= H;
        }
        function Ot() {
          var tr = zc();
          if (st(tr))
            return Rt(tr);
          oe = Uo(Ot, bt(tr));
        }
        function Rt(tr) {
          return oe = r, Ue && P ? Je(tr) : (P = M = r, ee);
        }
        function Qr() {
          oe !== r && Wv(oe), Ce = 0, P = he = M = oe = r;
        }
        function jr() {
          return oe === r ? ee : Rt(zc());
        }
        function en() {
          var tr = zc(), En = st(tr);
          if (P = arguments, M = this, he = tr, En) {
            if (oe === r)
              return it(he);
            if (ke)
              return Wv(oe), oe = Uo(Ot, f), Je(he);
          }
          return oe === r && (oe = Uo(Ot, f)), ee;
        }
        return en.cancel = Qr, en.flush = jr, en;
      }
      var zT = $t(function(o, f) {
        return Ov(o, 1, f);
      }), WT = $t(function(o, f, b) {
        return Ov(o, dn(f) || 0, b);
      });
      function HT(o) {
        return di(o, J);
      }
      function Wc(o, f) {
        if (typeof o != "function" || f != null && typeof f != "function")
          throw new on(a);
        var b = function() {
          var P = arguments, M = f ? f.apply(this, P) : P[0], H = b.cache;
          if (H.has(M))
            return H.get(M);
          var ee = o.apply(this, P);
          return b.cache = H.set(M, ee) || H, ee;
        };
        return b.cache = new (Wc.Cache || li)(), b;
      }
      Wc.Cache = li;
      function Hc(o) {
        if (typeof o != "function")
          throw new on(a);
        return function() {
          var f = arguments;
          switch (f.length) {
            case 0:
              return !o.call(this);
            case 1:
              return !o.call(this, f[0]);
            case 2:
              return !o.call(this, f[0], f[1]);
            case 3:
              return !o.call(this, f[0], f[1], f[2]);
          }
          return !o.apply(this, f);
        };
      }
      function GT(o) {
        return Ib(2, o);
      }
      var KT = MC(function(o, f) {
        f = f.length == 1 && pt(f[0]) ? Kt(f[0], Yr(nt())) : Kt(yr(f, 1), Yr(nt()));
        var b = f.length;
        return $t(function(P) {
          for (var M = -1, H = wr(P.length, b); ++M < H; )
            P[M] = f[M].call(this, P[M]);
          return Kr(o, this, P);
        });
      }), mp = $t(function(o, f) {
        var b = Ui(f, Ea(mp));
        return di(o, A, r, f, b);
      }), Db = $t(function(o, f) {
        var b = Ui(f, Ea(Db));
        return di(o, R, r, f, b);
      }), YT = pi(function(o, f) {
        return di(o, D, r, r, r, f);
      });
      function JT(o, f) {
        if (typeof o != "function")
          throw new on(a);
        return f = f === r ? f : gt(f), $t(o, f);
      }
      function XT(o, f) {
        if (typeof o != "function")
          throw new on(a);
        return f = f == null ? 0 : cr(gt(f), 0), $t(function(b) {
          var P = b[f], M = Wi(b, 0, f);
          return P && Fi(M, P), Kr(o, this, M);
        });
      }
      function QT(o, f, b) {
        var P = !0, M = !0;
        if (typeof o != "function")
          throw new on(a);
        return Yt(b) && (P = "leading" in b ? !!b.leading : P, M = "trailing" in b ? !!b.trailing : M), Nb(o, f, {
          leading: P,
          maxWait: f,
          trailing: M
        });
      }
      function eI(o) {
        return Tb(o, 1);
      }
      function tI(o, f) {
        return mp(Qd(f), o);
      }
      function rI() {
        if (!arguments.length)
          return [];
        var o = arguments[0];
        return pt(o) ? o : [o];
      }
      function nI(o) {
        return cn(o, v);
      }
      function iI(o, f) {
        return f = typeof f == "function" ? f : r, cn(o, v, f);
      }
      function sI(o) {
        return cn(o, p | v);
      }
      function aI(o, f) {
        return f = typeof f == "function" ? f : r, cn(o, p | v, f);
      }
      function oI(o, f) {
        return f == null || xv(o, f, dr(f));
      }
      function $n(o, f) {
        return o === f || o !== o && f !== f;
      }
      var uI = qc(Ud), cI = qc(function(o, f) {
        return o >= f;
      }), js = Rv(function() {
        return arguments;
      }()) ? Rv : function(o) {
        return Xt(o) && Ft.call(o, "callee") && !yv.call(o, "callee");
      }, pt = be.isArray, lI = J0 ? Yr(J0) : vC;
      function Vr(o) {
        return o != null && Gc(o.length) && !mi(o);
      }
      function er(o) {
        return Xt(o) && Vr(o);
      }
      function fI(o) {
        return o === !0 || o === !1 || Xt(o) && Tr(o) == T;
      }
      var Hi = OA || Pp, dI = X0 ? Yr(X0) : bC;
      function pI(o) {
        return Xt(o) && o.nodeType === 1 && !Bo(o);
      }
      function hI(o) {
        if (o == null)
          return !0;
        if (Vr(o) && (pt(o) || typeof o == "string" || typeof o.splice == "function" || Hi(o) || xa(o) || js(o)))
          return !o.length;
        var f = $r(o);
        if (f == we || f == St)
          return !o.size;
        if (Fo(o))
          return !Zd(o).length;
        for (var b in o)
          if (Ft.call(o, b))
            return !1;
        return !0;
      }
      function mI(o, f) {
        return Do(o, f);
      }
      function yI(o, f, b) {
        b = typeof b == "function" ? b : r;
        var P = b ? b(o, f) : r;
        return P === r ? Do(o, f, r, b) : !!P;
      }
      function yp(o) {
        if (!Xt(o))
          return !1;
        var f = Tr(o);
        return f == k || f == Y || typeof o.message == "string" && typeof o.name == "string" && !Bo(o);
      }
      function gI(o) {
        return typeof o == "number" && vv(o);
      }
      function mi(o) {
        if (!Yt(o))
          return !1;
        var f = Tr(o);
        return f == U || f == pe || f == F || f == Ee;
      }
      function Lb(o) {
        return typeof o == "number" && o == gt(o);
      }
      function Gc(o) {
        return typeof o == "number" && o > -1 && o % 1 == 0 && o <= Ae;
      }
      function Yt(o) {
        var f = typeof o;
        return o != null && (f == "object" || f == "function");
      }
      function Xt(o) {
        return o != null && typeof o == "object";
      }
      var qb = Q0 ? Yr(Q0) : wC;
      function vI(o, f) {
        return o === f || Vd(o, f, ap(f));
      }
      function bI(o, f, b) {
        return b = typeof b == "function" ? b : r, Vd(o, f, ap(f), b);
      }
      function _I(o) {
        return Fb(o) && o != +o;
      }
      function wI(o) {
        if (iR(o))
          throw new ft(s);
        return Tv(o);
      }
      function $I(o) {
        return o === null;
      }
      function EI(o) {
        return o == null;
      }
      function Fb(o) {
        return typeof o == "number" || Xt(o) && Tr(o) == He;
      }
      function Bo(o) {
        if (!Xt(o) || Tr(o) != Ge)
          return !1;
        var f = wc(o);
        if (f === null)
          return !0;
        var b = Ft.call(f, "constructor") && f.constructor;
        return typeof b == "function" && b instanceof b && gc.call(b) == bA;
      }
      var gp = ev ? Yr(ev) : $C;
      function xI(o) {
        return Lb(o) && o >= -Ae && o <= Ae;
      }
      var Ub = tv ? Yr(tv) : EC;
      function Kc(o) {
        return typeof o == "string" || !pt(o) && Xt(o) && Tr(o) == Ne;
      }
      function Xr(o) {
        return typeof o == "symbol" || Xt(o) && Tr(o) == Le;
      }
      var xa = rv ? Yr(rv) : xC;
      function OI(o) {
        return o === r;
      }
      function PI(o) {
        return Xt(o) && $r(o) == mt;
      }
      function SI(o) {
        return Xt(o) && Tr(o) == qe;
      }
      var AI = qc(zd), CI = qc(function(o, f) {
        return o <= f;
      });
      function Bb(o) {
        if (!o)
          return [];
        if (Vr(o))
          return Kc(o) ? _n(o) : Br(o);
        if (Co && o[Co])
          return oA(o[Co]());
        var f = $r(o), b = f == we ? Id : f == St ? hc : Oa;
        return b(o);
      }
      function yi(o) {
        if (!o)
          return o === 0 ? o : 0;
        if (o = dn(o), o === $e || o === -$e) {
          var f = o < 0 ? -1 : 1;
          return f * _e;
        }
        return o === o ? o : 0;
      }
      function gt(o) {
        var f = yi(o), b = f % 1;
        return f === f ? b ? f - b : f : 0;
      }
      function Vb(o) {
        return o ? Cs(gt(o), 0, K) : 0;
      }
      function dn(o) {
        if (typeof o == "number")
          return o;
        if (Xr(o))
          return ie;
        if (Yt(o)) {
          var f = typeof o.valueOf == "function" ? o.valueOf() : o;
          o = Yt(f) ? f + "" : f;
        }
        if (typeof o != "string")
          return o === 0 ? o : +o;
        o = uv(o);
        var b = vt.test(o);
        return b || O.test(o) ? ZS(o.slice(2), b ? 2 : 8) : Wt.test(o) ? ie : +o;
      }
      function Zb(o) {
        return Vn(o, Zr(o));
      }
      function RI(o) {
        return o ? Cs(gt(o), -Ae, Ae) : o === 0 ? o : 0;
      }
      function qt(o) {
        return o == null ? "" : Jr(o);
      }
      var TI = wa(function(o, f) {
        if (Fo(f) || Vr(f)) {
          Vn(f, dr(f), o);
          return;
        }
        for (var b in f)
          Ft.call(f, b) && ko(o, b, f[b]);
      }), zb = wa(function(o, f) {
        Vn(f, Zr(f), o);
      }), Yc = wa(function(o, f, b, P) {
        Vn(f, Zr(f), o, P);
      }), II = wa(function(o, f, b, P) {
        Vn(f, dr(f), o, P);
      }), jI = pi(Ld);
      function kI(o, f) {
        var b = _a(o);
        return f == null ? b : Ev(b, f);
      }
      var MI = $t(function(o, f) {
        o = Zt(o);
        var b = -1, P = f.length, M = P > 2 ? f[2] : r;
        for (M && Ir(f[0], f[1], M) && (P = 1); ++b < P; )
          for (var H = f[b], ee = Zr(H), oe = -1, he = ee.length; ++oe < he; ) {
            var Ce = ee[oe], Re = o[Ce];
            (Re === r || $n(Re, ga[Ce]) && !Ft.call(o, Ce)) && (o[Ce] = H[Ce]);
          }
        return o;
      }), NI = $t(function(o) {
        return o.push(r, ub), Kr(Wb, r, o);
      });
      function DI(o, f) {
        return iv(o, nt(f, 3), Bn);
      }
      function LI(o, f) {
        return iv(o, nt(f, 3), Fd);
      }
      function qI(o, f) {
        return o == null ? o : qd(o, nt(f, 3), Zr);
      }
      function FI(o, f) {
        return o == null ? o : Av(o, nt(f, 3), Zr);
      }
      function UI(o, f) {
        return o && Bn(o, nt(f, 3));
      }
      function BI(o, f) {
        return o && Fd(o, nt(f, 3));
      }
      function VI(o) {
        return o == null ? [] : Tc(o, dr(o));
      }
      function ZI(o) {
        return o == null ? [] : Tc(o, Zr(o));
      }
      function vp(o, f, b) {
        var P = o == null ? r : Rs(o, f);
        return P === r ? b : P;
      }
      function zI(o, f) {
        return o != null && fb(o, f, hC);
      }
      function bp(o, f) {
        return o != null && fb(o, f, mC);
      }
      var WI = nb(function(o, f, b) {
        f != null && typeof f.toString != "function" && (f = vc.call(f)), o[f] = b;
      }, wp(zr)), HI = nb(function(o, f, b) {
        f != null && typeof f.toString != "function" && (f = vc.call(f)), Ft.call(o, f) ? o[f].push(b) : o[f] = [b];
      }, nt), GI = $t(No);
      function dr(o) {
        return Vr(o) ? wv(o) : Zd(o);
      }
      function Zr(o) {
        return Vr(o) ? wv(o, !0) : OC(o);
      }
      function KI(o, f) {
        var b = {};
        return f = nt(f, 3), Bn(o, function(P, M, H) {
          fi(b, f(P, M, H), P);
        }), b;
      }
      function YI(o, f) {
        var b = {};
        return f = nt(f, 3), Bn(o, function(P, M, H) {
          fi(b, M, f(P, M, H));
        }), b;
      }
      var JI = wa(function(o, f, b) {
        Ic(o, f, b);
      }), Wb = wa(function(o, f, b, P) {
        Ic(o, f, b, P);
      }), XI = pi(function(o, f) {
        var b = {};
        if (o == null)
          return b;
        var P = !1;
        f = Kt(f, function(H) {
          return H = zi(H, o), P || (P = H.length > 1), H;
        }), Vn(o, ip(o), b), P && (b = cn(b, p | h | v, WC));
        for (var M = f.length; M--; )
          Yd(b, f[M]);
        return b;
      });
      function QI(o, f) {
        return Hb(o, Hc(nt(f)));
      }
      var ej = pi(function(o, f) {
        return o == null ? {} : SC(o, f);
      });
      function Hb(o, f) {
        if (o == null)
          return {};
        var b = Kt(ip(o), function(P) {
          return [P];
        });
        return f = nt(f), Lv(o, b, function(P, M) {
          return f(P, M[0]);
        });
      }
      function tj(o, f, b) {
        f = zi(f, o);
        var P = -1, M = f.length;
        for (M || (M = 1, o = r); ++P < M; ) {
          var H = o == null ? r : o[Zn(f[P])];
          H === r && (P = M, H = b), o = mi(H) ? H.call(o) : H;
        }
        return o;
      }
      function rj(o, f, b) {
        return o == null ? o : Lo(o, f, b);
      }
      function nj(o, f, b, P) {
        return P = typeof P == "function" ? P : r, o == null ? o : Lo(o, f, b, P);
      }
      var Gb = ab(dr), Kb = ab(Zr);
      function ij(o, f, b) {
        var P = pt(o), M = P || Hi(o) || xa(o);
        if (f = nt(f, 4), b == null) {
          var H = o && o.constructor;
          M ? b = P ? new H() : [] : Yt(o) ? b = mi(H) ? _a(wc(o)) : {} : b = {};
        }
        return (M ? an : Bn)(o, function(ee, oe, he) {
          return f(b, ee, oe, he);
        }), b;
      }
      function sj(o, f) {
        return o == null ? !0 : Yd(o, f);
      }
      function aj(o, f, b) {
        return o == null ? o : Vv(o, f, Qd(b));
      }
      function oj(o, f, b, P) {
        return P = typeof P == "function" ? P : r, o == null ? o : Vv(o, f, Qd(b), P);
      }
      function Oa(o) {
        return o == null ? [] : Td(o, dr(o));
      }
      function uj(o) {
        return o == null ? [] : Td(o, Zr(o));
      }
      function cj(o, f, b) {
        return b === r && (b = f, f = r), b !== r && (b = dn(b), b = b === b ? b : 0), f !== r && (f = dn(f), f = f === f ? f : 0), Cs(dn(o), f, b);
      }
      function lj(o, f, b) {
        return f = yi(f), b === r ? (b = f, f = 0) : b = yi(b), o = dn(o), yC(o, f, b);
      }
      function fj(o, f, b) {
        if (b && typeof b != "boolean" && Ir(o, f, b) && (f = b = r), b === r && (typeof f == "boolean" ? (b = f, f = r) : typeof o == "boolean" && (b = o, o = r)), o === r && f === r ? (o = 0, f = 1) : (o = yi(o), f === r ? (f = o, o = 0) : f = yi(f)), o > f) {
          var P = o;
          o = f, f = P;
        }
        if (b || o % 1 || f % 1) {
          var M = bv();
          return wr(o + M * (f - o + VS("1e-" + ((M + "").length - 1))), f);
        }
        return Hd(o, f);
      }
      var dj = $a(function(o, f, b) {
        return f = f.toLowerCase(), o + (b ? Yb(f) : f);
      });
      function Yb(o) {
        return _p(qt(o).toLowerCase());
      }
      function Jb(o) {
        return o = qt(o), o && o.replace(W, rA).replace(jS, "");
      }
      function pj(o, f, b) {
        o = qt(o), f = Jr(f);
        var P = o.length;
        b = b === r ? P : Cs(gt(b), 0, P);
        var M = b;
        return b -= f.length, b >= 0 && o.slice(b, M) == f;
      }
      function hj(o) {
        return o = qt(o), o && Fn.test(o) ? o.replace(ua, nA) : o;
      }
      function mj(o) {
        return o = qt(o), o && Oo.test(o) ? o.replace(Ni, "\\$&") : o;
      }
      var yj = $a(function(o, f, b) {
        return o + (b ? "-" : "") + f.toLowerCase();
      }), gj = $a(function(o, f, b) {
        return o + (b ? " " : "") + f.toLowerCase();
      }), vj = eb("toLowerCase");
      function bj(o, f, b) {
        o = qt(o), f = gt(f);
        var P = f ? ma(o) : 0;
        if (!f || P >= f)
          return o;
        var M = (f - P) / 2;
        return Lc(Oc(M), b) + o + Lc(xc(M), b);
      }
      function _j(o, f, b) {
        o = qt(o), f = gt(f);
        var P = f ? ma(o) : 0;
        return f && P < f ? o + Lc(f - P, b) : o;
      }
      function wj(o, f, b) {
        o = qt(o), f = gt(f);
        var P = f ? ma(o) : 0;
        return f && P < f ? Lc(f - P, b) + o : o;
      }
      function $j(o, f, b) {
        return b || f == null ? f = 0 : f && (f = +f), CA(qt(o).replace(Di, ""), f || 0);
      }
      function Ej(o, f, b) {
        return (b ? Ir(o, f, b) : f === r) ? f = 1 : f = gt(f), Gd(qt(o), f);
      }
      function xj() {
        var o = arguments, f = qt(o[0]);
        return o.length < 3 ? f : f.replace(o[1], o[2]);
      }
      var Oj = $a(function(o, f, b) {
        return o + (b ? "_" : "") + f.toLowerCase();
      });
      function Pj(o, f, b) {
        return b && typeof b != "number" && Ir(o, f, b) && (f = b = r), b = b === r ? K : b >>> 0, b ? (o = qt(o), o && (typeof f == "string" || f != null && !gp(f)) && (f = Jr(f), !f && ha(o)) ? Wi(_n(o), 0, b) : o.split(f, b)) : [];
      }
      var Sj = $a(function(o, f, b) {
        return o + (b ? " " : "") + _p(f);
      });
      function Aj(o, f, b) {
        return o = qt(o), b = b == null ? 0 : Cs(gt(b), 0, o.length), f = Jr(f), o.slice(b, b + f.length) == f;
      }
      function Cj(o, f, b) {
        var P = B.templateSettings;
        b && Ir(o, f, b) && (f = r), o = qt(o), f = Yc({}, f, P, ob);
        var M = Yc({}, f.imports, P.imports, ob), H = dr(M), ee = Td(M, H), oe, he, Ce = 0, Re = f.interpolate || ne, ke = "__p += '", Ue = jd(
          (f.escape || ne).source + "|" + Re.source + "|" + (Re === la ? Et : ne).source + "|" + (f.evaluate || ne).source + "|$",
          "g"
        ), Je = "//# sourceURL=" + (Ft.call(f, "sourceURL") ? (f.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++LS + "]") + `
`;
        o.replace(Ue, function(st, Ot, Rt, Qr, jr, en) {
          return Rt || (Rt = Qr), ke += o.slice(Ce, en).replace(te, iA), Ot && (oe = !0, ke += `' +
__e(` + Ot + `) +
'`), jr && (he = !0, ke += `';
` + jr + `;
__p += '`), Rt && (ke += `' +
((__t = (` + Rt + `)) == null ? '' : __t) +
'`), Ce = en + st.length, st;
        }), ke += `';
`;
        var it = Ft.call(f, "variable") && f.variable;
        if (!it)
          ke = `with (obj) {
` + ke + `
}
`;
        else if (Ye.test(it))
          throw new ft(u);
        ke = (he ? ke.replace(It, "") : ke).replace(_o, "$1").replace(wo, "$1;"), ke = "function(" + (it || "obj") + `) {
` + (it ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (oe ? ", __e = _.escape" : "") + (he ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + ke + `return __p
}`;
        var bt = Qb(function() {
          return Nt(H, Je + "return " + ke).apply(r, ee);
        });
        if (bt.source = ke, yp(bt))
          throw bt;
        return bt;
      }
      function Rj(o) {
        return qt(o).toLowerCase();
      }
      function Tj(o) {
        return qt(o).toUpperCase();
      }
      function Ij(o, f, b) {
        if (o = qt(o), o && (b || f === r))
          return uv(o);
        if (!o || !(f = Jr(f)))
          return o;
        var P = _n(o), M = _n(f), H = cv(P, M), ee = lv(P, M) + 1;
        return Wi(P, H, ee).join("");
      }
      function jj(o, f, b) {
        if (o = qt(o), o && (b || f === r))
          return o.slice(0, dv(o) + 1);
        if (!o || !(f = Jr(f)))
          return o;
        var P = _n(o), M = lv(P, _n(f)) + 1;
        return Wi(P, 0, M).join("");
      }
      function kj(o, f, b) {
        if (o = qt(o), o && (b || f === r))
          return o.replace(Di, "");
        if (!o || !(f = Jr(f)))
          return o;
        var P = _n(o), M = cv(P, _n(f));
        return Wi(P, M).join("");
      }
      function Mj(o, f) {
        var b = ae, P = ye;
        if (Yt(f)) {
          var M = "separator" in f ? f.separator : M;
          b = "length" in f ? gt(f.length) : b, P = "omission" in f ? Jr(f.omission) : P;
        }
        o = qt(o);
        var H = o.length;
        if (ha(o)) {
          var ee = _n(o);
          H = ee.length;
        }
        if (b >= H)
          return o;
        var oe = b - ma(P);
        if (oe < 1)
          return P;
        var he = ee ? Wi(ee, 0, oe).join("") : o.slice(0, oe);
        if (M === r)
          return he + P;
        if (ee && (oe += he.length - oe), gp(M)) {
          if (o.slice(oe).search(M)) {
            var Ce, Re = he;
            for (M.global || (M = jd(M.source, qt(Lt.exec(M)) + "g")), M.lastIndex = 0; Ce = M.exec(Re); )
              var ke = Ce.index;
            he = he.slice(0, ke === r ? oe : ke);
          }
        } else if (o.indexOf(Jr(M), oe) != oe) {
          var Ue = he.lastIndexOf(M);
          Ue > -1 && (he = he.slice(0, Ue));
        }
        return he + P;
      }
      function Nj(o) {
        return o = qt(o), o && $o.test(o) ? o.replace(oa, fA) : o;
      }
      var Dj = $a(function(o, f, b) {
        return o + (b ? " " : "") + f.toUpperCase();
      }), _p = eb("toUpperCase");
      function Xb(o, f, b) {
        return o = qt(o), f = b ? r : f, f === r ? aA(o) ? hA(o) : JS(o) : o.match(f) || [];
      }
      var Qb = $t(function(o, f) {
        try {
          return Kr(o, r, f);
        } catch (b) {
          return yp(b) ? b : new ft(b);
        }
      }), Lj = pi(function(o, f) {
        return an(f, function(b) {
          b = Zn(b), fi(o, b, hp(o[b], o));
        }), o;
      });
      function qj(o) {
        var f = o == null ? 0 : o.length, b = nt();
        return o = f ? Kt(o, function(P) {
          if (typeof P[1] != "function")
            throw new on(a);
          return [b(P[0]), P[1]];
        }) : [], $t(function(P) {
          for (var M = -1; ++M < f; ) {
            var H = o[M];
            if (Kr(H[0], this, P))
              return Kr(H[1], this, P);
          }
        });
      }
      function Fj(o) {
        return fC(cn(o, p));
      }
      function wp(o) {
        return function() {
          return o;
        };
      }
      function Uj(o, f) {
        return o == null || o !== o ? f : o;
      }
      var Bj = rb(), Vj = rb(!0);
      function zr(o) {
        return o;
      }
      function $p(o) {
        return Iv(typeof o == "function" ? o : cn(o, p));
      }
      function Zj(o) {
        return kv(cn(o, p));
      }
      function zj(o, f) {
        return Mv(o, cn(f, p));
      }
      var Wj = $t(function(o, f) {
        return function(b) {
          return No(b, o, f);
        };
      }), Hj = $t(function(o, f) {
        return function(b) {
          return No(o, b, f);
        };
      });
      function Ep(o, f, b) {
        var P = dr(f), M = Tc(f, P);
        b == null && !(Yt(f) && (M.length || !P.length)) && (b = f, f = o, o = this, M = Tc(f, dr(f)));
        var H = !(Yt(b) && "chain" in b) || !!b.chain, ee = mi(o);
        return an(M, function(oe) {
          var he = f[oe];
          o[oe] = he, ee && (o.prototype[oe] = function() {
            var Ce = this.__chain__;
            if (H || Ce) {
              var Re = o(this.__wrapped__), ke = Re.__actions__ = Br(this.__actions__);
              return ke.push({ func: he, args: arguments, thisArg: o }), Re.__chain__ = Ce, Re;
            }
            return he.apply(o, Fi([this.value()], arguments));
          });
        }), o;
      }
      function Gj() {
        return mr._ === this && (mr._ = _A), this;
      }
      function xp() {
      }
      function Kj(o) {
        return o = gt(o), $t(function(f) {
          return Nv(f, o);
        });
      }
      var Yj = tp(Kt), Jj = tp(nv), Xj = tp(Pd);
      function e1(o) {
        return up(o) ? Sd(Zn(o)) : AC(o);
      }
      function Qj(o) {
        return function(f) {
          return o == null ? r : Rs(o, f);
        };
      }
      var ek = ib(), tk = ib(!0);
      function Op() {
        return [];
      }
      function Pp() {
        return !1;
      }
      function rk() {
        return {};
      }
      function nk() {
        return "";
      }
      function ik() {
        return !0;
      }
      function sk(o, f) {
        if (o = gt(o), o < 1 || o > Ae)
          return [];
        var b = K, P = wr(o, K);
        f = nt(f), o -= K;
        for (var M = Rd(P, f); ++b < o; )
          f(b);
        return M;
      }
      function ak(o) {
        return pt(o) ? Kt(o, Zn) : Xr(o) ? [o] : Br(_b(qt(o)));
      }
      function ok(o) {
        var f = ++vA;
        return qt(o) + f;
      }
      var uk = Dc(function(o, f) {
        return o + f;
      }, 0), ck = rp("ceil"), lk = Dc(function(o, f) {
        return o / f;
      }, 1), fk = rp("floor");
      function dk(o) {
        return o && o.length ? Rc(o, zr, Ud) : r;
      }
      function pk(o, f) {
        return o && o.length ? Rc(o, nt(f, 2), Ud) : r;
      }
      function hk(o) {
        return av(o, zr);
      }
      function mk(o, f) {
        return av(o, nt(f, 2));
      }
      function yk(o) {
        return o && o.length ? Rc(o, zr, zd) : r;
      }
      function gk(o, f) {
        return o && o.length ? Rc(o, nt(f, 2), zd) : r;
      }
      var vk = Dc(function(o, f) {
        return o * f;
      }, 1), bk = rp("round"), _k = Dc(function(o, f) {
        return o - f;
      }, 0);
      function wk(o) {
        return o && o.length ? Cd(o, zr) : 0;
      }
      function $k(o, f) {
        return o && o.length ? Cd(o, nt(f, 2)) : 0;
      }
      return B.after = ZT, B.ary = Tb, B.assign = TI, B.assignIn = zb, B.assignInWith = Yc, B.assignWith = II, B.at = jI, B.before = Ib, B.bind = hp, B.bindAll = Lj, B.bindKey = jb, B.castArray = rI, B.chain = Ab, B.chunk = fR, B.compact = dR, B.concat = pR, B.cond = qj, B.conforms = Fj, B.constant = wp, B.countBy = wT, B.create = kI, B.curry = kb, B.curryRight = Mb, B.debounce = Nb, B.defaults = MI, B.defaultsDeep = NI, B.defer = zT, B.delay = WT, B.difference = hR, B.differenceBy = mR, B.differenceWith = yR, B.drop = gR, B.dropRight = vR, B.dropRightWhile = bR, B.dropWhile = _R, B.fill = wR, B.filter = ET, B.flatMap = PT, B.flatMapDeep = ST, B.flatMapDepth = AT, B.flatten = xb, B.flattenDeep = $R, B.flattenDepth = ER, B.flip = HT, B.flow = Bj, B.flowRight = Vj, B.fromPairs = xR, B.functions = VI, B.functionsIn = ZI, B.groupBy = CT, B.initial = PR, B.intersection = SR, B.intersectionBy = AR, B.intersectionWith = CR, B.invert = WI, B.invertBy = HI, B.invokeMap = TT, B.iteratee = $p, B.keyBy = IT, B.keys = dr, B.keysIn = Zr, B.map = Zc, B.mapKeys = KI, B.mapValues = YI, B.matches = Zj, B.matchesProperty = zj, B.memoize = Wc, B.merge = JI, B.mergeWith = Wb, B.method = Wj, B.methodOf = Hj, B.mixin = Ep, B.negate = Hc, B.nthArg = Kj, B.omit = XI, B.omitBy = QI, B.once = GT, B.orderBy = jT, B.over = Yj, B.overArgs = KT, B.overEvery = Jj, B.overSome = Xj, B.partial = mp, B.partialRight = Db, B.partition = kT, B.pick = ej, B.pickBy = Hb, B.property = e1, B.propertyOf = Qj, B.pull = jR, B.pullAll = Pb, B.pullAllBy = kR, B.pullAllWith = MR, B.pullAt = NR, B.range = ek, B.rangeRight = tk, B.rearg = YT, B.reject = DT, B.remove = DR, B.rest = JT, B.reverse = dp, B.sampleSize = qT, B.set = rj, B.setWith = nj, B.shuffle = FT, B.slice = LR, B.sortBy = VT, B.sortedUniq = zR, B.sortedUniqBy = WR, B.split = Pj, B.spread = XT, B.tail = HR, B.take = GR, B.takeRight = KR, B.takeRightWhile = YR, B.takeWhile = JR, B.tap = dT, B.throttle = QT, B.thru = Vc, B.toArray = Bb, B.toPairs = Gb, B.toPairsIn = Kb, B.toPath = ak, B.toPlainObject = Zb, B.transform = ij, B.unary = eI, B.union = XR, B.unionBy = QR, B.unionWith = eT, B.uniq = tT, B.uniqBy = rT, B.uniqWith = nT, B.unset = sj, B.unzip = pp, B.unzipWith = Sb, B.update = aj, B.updateWith = oj, B.values = Oa, B.valuesIn = uj, B.without = iT, B.words = Xb, B.wrap = tI, B.xor = sT, B.xorBy = aT, B.xorWith = oT, B.zip = uT, B.zipObject = cT, B.zipObjectDeep = lT, B.zipWith = fT, B.entries = Gb, B.entriesIn = Kb, B.extend = zb, B.extendWith = Yc, Ep(B, B), B.add = uk, B.attempt = Qb, B.camelCase = dj, B.capitalize = Yb, B.ceil = ck, B.clamp = cj, B.clone = nI, B.cloneDeep = sI, B.cloneDeepWith = aI, B.cloneWith = iI, B.conformsTo = oI, B.deburr = Jb, B.defaultTo = Uj, B.divide = lk, B.endsWith = pj, B.eq = $n, B.escape = hj, B.escapeRegExp = mj, B.every = $T, B.find = xT, B.findIndex = $b, B.findKey = DI, B.findLast = OT, B.findLastIndex = Eb, B.findLastKey = LI, B.floor = fk, B.forEach = Cb, B.forEachRight = Rb, B.forIn = qI, B.forInRight = FI, B.forOwn = UI, B.forOwnRight = BI, B.get = vp, B.gt = uI, B.gte = cI, B.has = zI, B.hasIn = bp, B.head = Ob, B.identity = zr, B.includes = RT, B.indexOf = OR, B.inRange = lj, B.invoke = GI, B.isArguments = js, B.isArray = pt, B.isArrayBuffer = lI, B.isArrayLike = Vr, B.isArrayLikeObject = er, B.isBoolean = fI, B.isBuffer = Hi, B.isDate = dI, B.isElement = pI, B.isEmpty = hI, B.isEqual = mI, B.isEqualWith = yI, B.isError = yp, B.isFinite = gI, B.isFunction = mi, B.isInteger = Lb, B.isLength = Gc, B.isMap = qb, B.isMatch = vI, B.isMatchWith = bI, B.isNaN = _I, B.isNative = wI, B.isNil = EI, B.isNull = $I, B.isNumber = Fb, B.isObject = Yt, B.isObjectLike = Xt, B.isPlainObject = Bo, B.isRegExp = gp, B.isSafeInteger = xI, B.isSet = Ub, B.isString = Kc, B.isSymbol = Xr, B.isTypedArray = xa, B.isUndefined = OI, B.isWeakMap = PI, B.isWeakSet = SI, B.join = RR, B.kebabCase = yj, B.last = fn, B.lastIndexOf = TR, B.lowerCase = gj, B.lowerFirst = vj, B.lt = AI, B.lte = CI, B.max = dk, B.maxBy = pk, B.mean = hk, B.meanBy = mk, B.min = yk, B.minBy = gk, B.stubArray = Op, B.stubFalse = Pp, B.stubObject = rk, B.stubString = nk, B.stubTrue = ik, B.multiply = vk, B.nth = IR, B.noConflict = Gj, B.noop = xp, B.now = zc, B.pad = bj, B.padEnd = _j, B.padStart = wj, B.parseInt = $j, B.random = fj, B.reduce = MT, B.reduceRight = NT, B.repeat = Ej, B.replace = xj, B.result = tj, B.round = bk, B.runInContext = de, B.sample = LT, B.size = UT, B.snakeCase = Oj, B.some = BT, B.sortedIndex = qR, B.sortedIndexBy = FR, B.sortedIndexOf = UR, B.sortedLastIndex = BR, B.sortedLastIndexBy = VR, B.sortedLastIndexOf = ZR, B.startCase = Sj, B.startsWith = Aj, B.subtract = _k, B.sum = wk, B.sumBy = $k, B.template = Cj, B.times = sk, B.toFinite = yi, B.toInteger = gt, B.toLength = Vb, B.toLower = Rj, B.toNumber = dn, B.toSafeInteger = RI, B.toString = qt, B.toUpper = Tj, B.trim = Ij, B.trimEnd = jj, B.trimStart = kj, B.truncate = Mj, B.unescape = Nj, B.uniqueId = ok, B.upperCase = Dj, B.upperFirst = _p, B.each = Cb, B.eachRight = Rb, B.first = Ob, Ep(B, function() {
        var o = {};
        return Bn(B, function(f, b) {
          Ft.call(B.prototype, b) || (o[b] = f);
        }), o;
      }(), { chain: !1 }), B.VERSION = n, an(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(o) {
        B[o].placeholder = B;
      }), an(["drop", "take"], function(o, f) {
        At.prototype[o] = function(b) {
          b = b === r ? 1 : cr(gt(b), 0);
          var P = this.__filtered__ && !f ? new At(this) : this.clone();
          return P.__filtered__ ? P.__takeCount__ = wr(b, P.__takeCount__) : P.__views__.push({
            size: wr(b, K),
            type: o + (P.__dir__ < 0 ? "Right" : "")
          }), P;
        }, At.prototype[o + "Right"] = function(b) {
          return this.reverse()[o](b).reverse();
        };
      }), an(["filter", "map", "takeWhile"], function(o, f) {
        var b = f + 1, P = b == re || b == le;
        At.prototype[o] = function(M) {
          var H = this.clone();
          return H.__iteratees__.push({
            iteratee: nt(M, 3),
            type: b
          }), H.__filtered__ = H.__filtered__ || P, H;
        };
      }), an(["head", "last"], function(o, f) {
        var b = "take" + (f ? "Right" : "");
        At.prototype[o] = function() {
          return this[b](1).value()[0];
        };
      }), an(["initial", "tail"], function(o, f) {
        var b = "drop" + (f ? "" : "Right");
        At.prototype[o] = function() {
          return this.__filtered__ ? new At(this) : this[b](1);
        };
      }), At.prototype.compact = function() {
        return this.filter(zr);
      }, At.prototype.find = function(o) {
        return this.filter(o).head();
      }, At.prototype.findLast = function(o) {
        return this.reverse().find(o);
      }, At.prototype.invokeMap = $t(function(o, f) {
        return typeof o == "function" ? new At(this) : this.map(function(b) {
          return No(b, o, f);
        });
      }), At.prototype.reject = function(o) {
        return this.filter(Hc(nt(o)));
      }, At.prototype.slice = function(o, f) {
        o = gt(o);
        var b = this;
        return b.__filtered__ && (o > 0 || f < 0) ? new At(b) : (o < 0 ? b = b.takeRight(-o) : o && (b = b.drop(o)), f !== r && (f = gt(f), b = f < 0 ? b.dropRight(-f) : b.take(f - o)), b);
      }, At.prototype.takeRightWhile = function(o) {
        return this.reverse().takeWhile(o).reverse();
      }, At.prototype.toArray = function() {
        return this.take(K);
      }, Bn(At.prototype, function(o, f) {
        var b = /^(?:filter|find|map|reject)|While$/.test(f), P = /^(?:head|last)$/.test(f), M = B[P ? "take" + (f == "last" ? "Right" : "") : f], H = P || /^find/.test(f);
        M && (B.prototype[f] = function() {
          var ee = this.__wrapped__, oe = P ? [1] : arguments, he = ee instanceof At, Ce = oe[0], Re = he || pt(ee), ke = function(Ot) {
            var Rt = M.apply(B, Fi([Ot], oe));
            return P && Ue ? Rt[0] : Rt;
          };
          Re && b && typeof Ce == "function" && Ce.length != 1 && (he = Re = !1);
          var Ue = this.__chain__, Je = !!this.__actions__.length, it = H && !Ue, bt = he && !Je;
          if (!H && Re) {
            ee = bt ? ee : new At(this);
            var st = o.apply(ee, oe);
            return st.__actions__.push({ func: Vc, args: [ke], thisArg: r }), new un(st, Ue);
          }
          return it && bt ? o.apply(this, oe) : (st = this.thru(ke), it ? P ? st.value()[0] : st.value() : st);
        });
      }), an(["pop", "push", "shift", "sort", "splice", "unshift"], function(o) {
        var f = mc[o], b = /^(?:push|sort|unshift)$/.test(o) ? "tap" : "thru", P = /^(?:pop|shift)$/.test(o);
        B.prototype[o] = function() {
          var M = arguments;
          if (P && !this.__chain__) {
            var H = this.value();
            return f.apply(pt(H) ? H : [], M);
          }
          return this[b](function(ee) {
            return f.apply(pt(ee) ? ee : [], M);
          });
        };
      }), Bn(At.prototype, function(o, f) {
        var b = B[f];
        if (b) {
          var P = b.name + "";
          Ft.call(ba, P) || (ba[P] = []), ba[P].push({ name: f, func: b });
        }
      }), ba[Nc(r, m).name] = [{
        name: "wrapper",
        func: r
      }], At.prototype.clone = NA, At.prototype.reverse = DA, At.prototype.value = LA, B.prototype.at = pT, B.prototype.chain = hT, B.prototype.commit = mT, B.prototype.next = yT, B.prototype.plant = vT, B.prototype.reverse = bT, B.prototype.toJSON = B.prototype.valueOf = B.prototype.value = _T, B.prototype.first = B.prototype.head, Co && (B.prototype[Co] = gT), B;
    }, ya = mA();
    Os ? ((Os.exports = ya)._ = ya, $d._ = ya) : mr._ = ya;
  }).call(rt);
})(Af, Af.exports);
var MH = Af.exports;
const NH = /* @__PURE__ */ ea(MH), $S = (e) => {
  const t = {};
  return Object.keys(e.schema.paths).map((r) => {
    const n = r.replace("/", "");
    t[n] = async (i) => new Promise((s, a) => {
      e.fns[n].fn({
        ...i,
        onData: i == null ? void 0 : i.onData,
        onDone: s,
        onError: a
      });
    });
  }), t;
}, ES = async ({ id: e, desc: t, version: r }) => {
  const n = {}, i = {}, s = {};
  return {
    addMethod: ({ id: u, fn: c, desc: l, settings: d }) => {
      n[u] = {
        fn: async (h) => c(h),
        settings: d,
        desc: l
      };
      const p = {
        addInput: ({ schema: h }) => {
          if (i[u])
            throw new Error(`Method ${u} already has an input, only one input per method allowed`);
          return i[u] = _$({ schema: h }), p;
        },
        addOutput: ({ schema: h, desc: v, code: y }) => (s[u] || (s[u] = []), s[u].push({ schema: _$({ schema: h }), desc: v, code: y }), p),
        setMultiplier: ({ multiplier: h }) => {
          var v;
          return (v = n[u]) != null && v.settings || (n[u].settings = {}), n[u].settings = { ...n[u].settings, multiplier: h }, p;
        }
      };
      return p;
    },
    run: async () => {
      const u = {};
      Object.keys(n).forEach((v) => {
        var g;
        const y = {
          required: !1,
          content: {}
        };
        u[`/${v}`] = {
          post: {
            summary: n[v].desc,
            operationId: v,
            tags: (g = NH.keys(n[v].settings)) == null ? void 0 : g.map((_) => {
              var w, $;
              const m = ($ = (w = n[v]) == null ? void 0 : w.settings) == null ? void 0 : $[_];
              return `${_}=${m}`;
            }),
            //FNS[fn_id].settings?.free ? ["free=true"] : [],
            requestBody: i[v] ? {
              required: !0,
              content: {
                "application/json": {
                  schema: i[v]
                }
              }
            } : y,
            responses: {}
          }
        }, s[v].forEach((_) => {
          u[`/${v}`].post.responses[_.code] = {
            description: _.desc,
            content: {
              "application/json": {
                schema: _.schema
              }
            }
          };
        });
      });
      const c = {};
      Object.keys(n).forEach((v) => {
        c[v] = {
          fn: n[v].fn,
          desc: n[v].desc,
          settings: n[v].settings
        };
      });
      const l = {
        id: e,
        fns: c,
        schema: {
          openapi: "3.0.0",
          info: {
            title: e,
            description: t,
            version: r || "1.0.0"
          },
          paths: u
        }
      }, [d, p, h] = await wS(l.schema, {
        fullResult: !0
      });
      if (p)
        throw new Error(`Module ${e} verification failed: ${p.message()}`);
      return l;
    }
  };
}, D0 = 1e4, q2 = new Lf({ ttl: 1e4 }), F2 = new Lf({ ttl: 1e4 }), U2 = new Lf({ ttl: 1e4 }), DH = async ({ user_id: e }) => {
  const t = await q2.get(e);
  if (t)
    return t;
  const r = await yd({
    ms: 15e3,
    fn: fetch("https://wallet.promptc0.com/getStatus", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ user_id: e })
    })
  }).then((n) => "json" in n && n.json());
  return !r || "error" in r || typeof r.result === void 0 ? !1 : (await q2.set(e, r.result, D0), r.result);
}, LH = async ({ user_id: e }) => {
  const t = await F2.get(e);
  if (t)
    return t;
  const r = await yd({
    ms: 15e3,
    fn: fetch("https://wallet.promptc0.com/getBalance", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ user_id: e })
    })
  }).then((n) => "json" in n && n.json());
  return !r || "error" in r || typeof r.result === void 0 ? !1 : (await F2.set(e, r.result, D0), r.result);
}, qH = async ({ user_id: e }) => {
  const t = await U2.get(e);
  if (t)
    return t;
  const r = await yd({
    ms: 15e3,
    fn: fetch("https://wallet.promptc0.com/getBalance", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ user_id: e })
    })
  }).then((n) => "json" in n && n.json());
  return !r || "error" in r || typeof r.result === void 0 ? !1 : (await U2.set(e, r.result, D0), r.result);
}, FH = async ({ receipt: e }) => yd({
  ms: 15e3,
  fn: fetch("https://wallet.promptc0.com/charge", {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify({ receipt: e })
  }).then((t) => t.json())
}), _l = md("module:handshake"), sg = async () => {
  const e = await ES({
    id: "wallet",
    desc: "Wallet module",
    version: "1.0.0"
  });
  return e.addMethod({
    id: "getStatus",
    desc: "Get wallet status",
    fn: async ({ onData: t, onError: r, onDone: n, user_id: i }) => {
      const s = await DH({ user_id: i });
      return !s || "error" in s ? r({ error: (s == null ? void 0 : s.error) || "Unknown error", code: 500 }) : (_l(`fetched status ${s} for ${i}`), n({ result: s }), {
        abort: () => {
        }
      });
    }
  }).addInput({
    schema: Te.object({
      user_id: Te.string()
    })
  }).addOutput({
    code: 200,
    desc: "Returns wallet status",
    schema: Te.object({
      result: Te.string()
    })
  }), e.addMethod({
    id: "getBalance",
    desc: "Get wallet balance",
    fn: async ({ onData: t, onError: r, onDone: n, user_id: i }) => {
      const s = await LH({ user_id: i });
      return typeof s === void 0 || typeof s == "object" && "error" in s ? r({ error: (s == null ? void 0 : s.error) || "Unknown error", code: 500 }) : (_l(`fetched balance ${s} for ${i}`), n({ result: s }), {
        abort: () => {
        }
      });
    }
  }).addInput({
    schema: Te.object({
      user_id: Te.string()
    })
  }).addOutput({
    code: 200,
    desc: "Returns wallet balance",
    schema: Te.object({
      result: Te.number()
    })
  }), e.addMethod({
    id: "getSubsidizedBalance",
    desc: "Get wallet's subsidized credits",
    fn: async ({ onData: t, onError: r, onDone: n, user_id: i }) => {
      const s = await qH({ user_id: i });
      return !s || "error" in s ? r({ error: (s == null ? void 0 : s.error) || "Unknown error", code: 500 }) : (_l(`fetched subsidized balance ${s} for ${i}`), n({ result: s }), {
        abort: () => {
        }
      });
    }
  }).addInput({
    schema: Te.object({
      user_id: Te.string()
    })
  }).addOutput({
    code: 200,
    desc: "Returns wallet's subsidized credits",
    schema: Te.object({
      result: Te.number()
    })
  }), e.addMethod({
    id: "charge",
    desc: "Charge wallet",
    fn: async ({ onData: t, onError: r, onDone: n, receipt: i }) => {
      const s = await FH({ receipt: i });
      return s && "error" in s ? r({ error: s.error, code: 500 }) : (_l(`charged wallet ${i.user_id} with ${i.amount}`), n({ result: s.body }), {
        abort: () => {
        }
      });
    }
  }).addInput({
    schema: Te.object({
      receipt: ag
    })
  }).addOutput({
    code: 200,
    desc: "Charge wallet",
    schema: Te.object({
      result: Te.number()
    })
  }), e.run();
};
async function B2({
  input: e,
  globals: t,
  request: r
}) {
  var y;
  const { MODULES: n, PROTOCOLS: i, REQUESTS: s } = t;
  if (s[e.id])
    return;
  e.offer.call.module_id !== "handshake" && (s[e.id] = !0);
  const { call: a } = e.offer, u = a.method_id.replace("/", ""), c = n.find(
    (g) => g.id === a.module_id && g.schema.paths[`/${a.method_id}`] && g.fns[u]
  );
  if (!c)
    return r.onError({ error: `Unknown call ${a.module_id}`, code: 404 });
  if (typeof ((y = c.fns[u]) == null ? void 0 : y.fn) != "function")
    return r.onError({ error: "Function id references are not supported yet", code: 404 });
  const l = {
    openapi: "3.0.0",
    ...c.schema
  };
  l.info.title = c.id;
  const [d, p, h] = await wS(l, {
    fullResult: !0
  });
  if (p)
    return r.onError({ error: p.message(), code: 500 });
  h && console.warn(h.message);
  const v = c.fns[u].fn;
  if (console.log(`Executing ${a.module_id}:${a.method_id} / ${e.id}`), typeof v == "function") {
    let g = 0;
    const _ = async ($) => {
      const E = $ == null ? void 0 : $.data;
      E && (g += ql(E)), r != null && r.onData && r.onData($);
    }, m = async ($) => {
      var R, I;
      const E = {
        id: qf(),
        user_id: e.meta.user_id,
        offer: e.offer,
        details: {
          input: {
            bytes: 0,
            tokens: 0
          },
          output: {
            bytes: 0,
            tokens: 0
          }
        },
        total_bytes: 0,
        total_tokens: 0
      };
      let A = 0;
      if (e != null && e.signed_transaction && ((R = e == null ? void 0 : e.offer) != null && R.multiplier)) {
        let D = g;
        $ != null && $.data && (D = ql($ == null ? void 0 : $.data)), A = ((I = c.fns[u].settings) == null ? void 0 : I.multiplier) || 0;
        const J = ql(e.params || 0);
        E.details = {
          input: {
            bytes: J,
            tokens: J * A
          },
          output: {
            bytes: D,
            tokens: A * D
          }
        }, E.total_tokens = E.details.input.tokens + E.details.output.tokens, E.total_bytes = E.details.input.bytes + E.details.output.bytes;
        const ae = await wf(JSON.stringify(E), $f({ input: t.private_key }));
        E.sig = rn({ input: ae });
        const ye = ag.safeParse(E);
        if (!ye.success)
          return (r == null ? void 0 : r.onError) && r.onError({ error: "invalid receipt", code: 500 });
        $.receipt = ye.data;
        const xe = $S(await sg());
        try {
          const je = await xe.charge({
            receipt: $.receipt
          });
        } catch (je) {
          return (r == null ? void 0 : r.onError) && r.onError(je);
        }
      }
      r != null && r.onDone && r.onDone($);
    }, w = await v({
      stripe: t.stripe,
      ...e.params,
      user_id: e.meta.user_id,
      onData: _,
      onDone: m,
      onError: r.onError
    });
    return typeof w == "object" && "error" in w ? r.onError({ ...w == null ? void 0 : w.error }) : (e.offer.id !== "handshake" && (s[e.id] = w), w);
  } else
    return r.onError({ error: `Unknown function ${e.offer.call.method_id}`, code: 404 });
}
const UH = md("module:handshake"), BH = async () => {
  const e = await ES({
    id: "handshake",
    desc: "Handshake module",
    version: "1.0.0"
  });
  return e.addMethod({
    id: "challenge",
    fn: async ({ onData: t, onError: r, onDone: n, request_id: i, ip: s }) => {
      const a = await Vz({ request_id: i, ip: s || "localhost" });
      return UH(`generated challenge ${a} for ${i}`), n && n({ result: a }), {
        abort: () => {
        }
      };
    },
    desc: "Generate security challenge",
    settings: { free: !0 }
  }).addInput({
    schema: Te.object({
      request_id: Te.string(),
      ip: Te.string()
    })
  }).addOutput({
    code: 200,
    desc: "Returns a random nonce for signing",
    schema: Te.object({
      result: Te.string()
    })
  }), e.run();
}, tu = md("server"), Ma = [], Hm = [], Gm = {}, Km = {};
async function VH({
  modules: e = [],
  private_key: t,
  protocols: r,
  globals: n,
  type: i = "events",
  no_auth: s = !1,
  host: a = "127.0.0.1",
  port: u = 8080
}) {
  if (t || (t = (await YP()).private_key), n)
    for (const l in n)
      tu(`setting global ${l}`), Gm[l] = n[l];
  e = [...e, await BH(), await sg()];
  for (const l of e) {
    if (!i1.safeParse(l).success)
      throw tu(`invalid module ${l.id}`), new Error("Invalid Module");
    Ma.push(l), tu(`loaded module ${l.id}`);
  }
  if (r)
    for (const l of r) {
      if (!ey.safeParse(l).success)
        throw new Error("Invalid Protocol");
      Hm.push(l), tu(`loaded protocol ${l.id}`);
    }
  const c = {
    getModules: () => Ma,
    execute: async function({
      input: l,
      globals: d,
      onData: p,
      onDone: h,
      onError: v
    }) {
      var $, E, A, R;
      tu(`executing ${l.offer.call.module_id}:${l.offer.call.method_id} / ${l.id}`);
      const y = ey.safeParse(l);
      if (!y.success)
        return { error: "Invalid payload", code: 400 };
      if (!s && l.offer.call.module_id === "handshake" && l.offer.call.method_id === "challenge") {
        const I = async (D) => {
          const J = D.result;
          if (!J)
            return v({ error: "Invalid challenge", code: 400 });
          h({ request_id: l.id, status: "challenge", data: { challenge: J } });
        };
        return B2({
          input: { ...y.data, params: { request_id: l.id, ip: (d == null ? void 0 : d.ip) || "localhost" } },
          globals: { MODULES: Ma, PROTOCOLS: Hm, REQUESTS: Km, ...Gm, ...d },
          request: {
            request_id: l.id,
            abort: async () => {
            },
            setAbort: async () => {
            },
            onDone: I,
            onError: v
          },
          onData: p,
          onDone: I,
          onError: v
        });
      }
      if (!s && !await Wz({ ...l, request_id: l.id, ip: (d == null ? void 0 : d.ip) || "localhost" }))
        return { error: "Unauthorized", code: 401 };
      const g = Ma.find((I) => I.id === l.offer.call.module_id), _ = (E = ($ = g == null ? void 0 : g.schema) == null ? void 0 : $.paths[`/${l.offer.call.method_id}`]) == null ? void 0 : E.post;
      if (!_)
        return { error: "Invalid module method", code: 404 };
      const m = Uz(((R = (A = _.tags) == null ? void 0 : A.find((I) => I.startsWith("multiplier="))) == null ? void 0 : R.split("=")[1]) || "0");
      if (m && typeof m == "number") {
        if (!l.signed_transaction)
          return { error: "Missing tx", code: 400 };
        if (!X2.safeParse(l.signed_transaction).success)
          return { error: "Invalid tx", code: 400 };
        const D = await $S(await sg()).getBalance({ user_id: l.meta.user_id }) || 0;
        if ((D == null ? void 0 : D.result) === void 0)
          return { error: "Invalid balance", code: 400 };
        if (await ql(l.params || {}) * m > (D == null ? void 0 : D.result))
          return { error: "Insufficient balance", code: 402 };
      }
      const w = await Ek({
        module_id: l.offer.call.module_id,
        method_id: l.offer.call.method_id,
        request_id: l.id,
        onData: p,
        onDone: h,
        onError: v,
        tx: l.signed_transaction || void 0
      });
      return "error" in w ? { error: w.error, code: 500 } : B2({
        input: { ...y.data, params: (l == null ? void 0 : l.params) || null },
        globals: { MODULES: Ma, PROTOCOLS: Hm, REQUESTS: Km, ...Gm, ...d, private_key: t },
        request: w,
        onData: p,
        onDone: h,
        onError: v
      });
    },
    abort: async function({ request_id: l }) {
      const d = Km[l];
      return d ? typeof d == "object" && d.abort() : { error: "Unknown request", code: 404 };
    },
    registerModule: async function({ module: l }) {
      return i1.safeParse(l).success ? (Ma.push(l), { code: 200 }) : { error: "Invalid Module", code: 400 };
    },
    signOffer: async function(l) {
      if (!t)
        return { error: "No private key", code: 500 };
      const d = uo({ str: JSON.stringify(l) }), p = await wf(d, $f({ input: t }));
      return {
        ...l,
        id: qf(),
        sig: {
          c: rn({ input: d }),
          s: rn({ input: p }),
          pk: await Hz({ private_key: t })
        }
      };
    }
  };
  switch (i) {
    case "events":
      Jz({ API: c });
      break;
    case "websocket":
      tW({ API: c, host: a, port: u });
      break;
  }
  return { ...c, host: a, type: i };
}
async function eG({
  host: e = "localhost",
  type: t = "events",
  server_modules: r = [],
  server_private_key: n
}) {
  let i;
  switch (t) {
    case "websocket":
      i = Qz;
      break;
    case "events":
      i = Yz;
      break;
  }
  const s = {
    request: async ({ user: a, offer: u, params: c, tx: l }) => {
      var E, A, R;
      const d = qf(), p = new Promise((I, D) => {
        const J = setTimeout(
          () => {
            D("timeout");
          },
          qz() ? 1e6 : 1e4
        );
        s.compute({
          onData: () => {
          },
          onDone: (ae) => {
            clearTimeout(J), I(ae.data);
          },
          onError: (ae) => {
            clearTimeout(J), D(ae);
          },
          request: {
            id: d,
            meta: {
              user_id: a.user_id
            },
            params: c,
            offer: {
              id: "handshake",
              call: {
                module_id: "handshake",
                method_id: "challenge"
              },
              sig: {
                n: "",
                c: "",
                s: "",
                pk: a.public_key
              }
            },
            auth: {
              n: "",
              c: "",
              s: "",
              pk: a.public_key
            }
          }
        });
      }), [h] = await Promise.all([p]);
      if (!((E = h == null ? void 0 : h.data) != null && E.challenge))
        return { error: "Invalid challenge", code: 400 };
      const v = uo({
        str: JSON.stringify({ offer: u, params: c || {}, nonce: (A = h == null ? void 0 : h.data) == null ? void 0 : A.challenge, request_id: d })
      });
      rn({ input: v });
      const y = await wf(v, $f({ input: a.private_key })), g = {
        n: (R = h == null ? void 0 : h.data) == null ? void 0 : R.challenge,
        c: rn({ input: v }),
        s: rn({ input: y }),
        pk: a.public_key
      }, _ = uo({
        str: JSON.stringify({ offer: u, params: c || {}, request_id: d, max_spent: (l == null ? void 0 : l.max_spent) || 0 })
      }), m = await wf(_, $f({ input: a.private_key })), w = {
        max_spent: (l == null ? void 0 : l.max_spent) || 0,
        signature: {
          c: rn({ input: _ }),
          s: rn({ input: m }),
          pk: a.public_key
        }
      };
      return {
        id: d,
        meta: {
          user_id: a.user_id
        },
        params: c,
        auth: g,
        signed_transaction: w,
        offer: u
      };
    },
    compute: async ({ request: a, onData: u, onDone: c, onError: l }) => {
      if (!i)
        return { error: "Invalid channel type", code: 400 };
      const { write: d, close: p } = await i({
        request_id: a.id,
        host: e,
        onData: u,
        onDone: c,
        onError: l
      });
      return d({ input: a }), {
        abort: () => {
          d({ input: a, abort: !0 });
        }
      };
    }
  };
  if (e === "localhost") {
    const a = await VH({
      modules: r,
      type: "events",
      private_key: n || void 0
    });
    if ("error" in a)
      throw new Error(JSON.stringify(a.error));
  }
  return { ...s, host: e, type: t };
}
export {
  eG as Client,
  Ek as Request,
  VH as Server,
  _$ as convertZod,
  QH as generateUser,
  ES as moduleGenerator,
  Te as z
};
//# sourceMappingURL=bundle.js.map
