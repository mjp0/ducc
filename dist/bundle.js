async function Bj({
  tx: e,
  onData: t,
  onDone: r,
  onError: i,
  request_id: n,
  method_id: s,
  module_id: a
}) {
  const c = {
    request_id: n,
    tx: e,
    abort: async () => {
    },
    setAbort: async (l) => {
      c.abort = l;
    },
    ...{
      onData: async (l) => {
        t && t(l);
      },
      onDone: async (l) => {
        r && r(l);
      },
      onError: async (l) => {
        i && i(l);
      }
    }
  };
  return c;
}
var It;
(function(e) {
  e.assertEqual = (n) => n;
  function t(n) {
  }
  e.assertIs = t;
  function r(n) {
    throw new Error();
  }
  e.assertNever = r, e.arrayToEnum = (n) => {
    const s = {};
    for (const a of n)
      s[a] = a;
    return s;
  }, e.getValidEnumValues = (n) => {
    const s = e.objectKeys(n).filter((o) => typeof n[n[o]] != "number"), a = {};
    for (const o of s)
      a[o] = n[o];
    return e.objectValues(a);
  }, e.objectValues = (n) => e.objectKeys(n).map(function(s) {
    return n[s];
  }), e.objectKeys = typeof Object.keys == "function" ? (n) => Object.keys(n) : (n) => {
    const s = [];
    for (const a in n)
      Object.prototype.hasOwnProperty.call(n, a) && s.push(a);
    return s;
  }, e.find = (n, s) => {
    for (const a of n)
      if (s(a))
        return a;
  }, e.isInteger = typeof Number.isInteger == "function" ? (n) => Number.isInteger(n) : (n) => typeof n == "number" && isFinite(n) && Math.floor(n) === n;
  function i(n, s = " | ") {
    return n.map((a) => typeof a == "string" ? `'${a}'` : a).join(s);
  }
  e.joinValues = i, e.jsonStringifyReplacer = (n, s) => typeof s == "bigint" ? s.toString() : s;
})(It || (It = {}));
var Fm;
(function(e) {
  e.mergeShapes = (t, r) => ({
    ...t,
    ...r
    // second overwrites first
  });
})(Fm || (Fm = {}));
const ze = It.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), Xi = (e) => {
  switch (typeof e) {
    case "undefined":
      return ze.undefined;
    case "string":
      return ze.string;
    case "number":
      return isNaN(e) ? ze.nan : ze.number;
    case "boolean":
      return ze.boolean;
    case "function":
      return ze.function;
    case "bigint":
      return ze.bigint;
    case "symbol":
      return ze.symbol;
    case "object":
      return Array.isArray(e) ? ze.array : e === null ? ze.null : e.then && typeof e.then == "function" && e.catch && typeof e.catch == "function" ? ze.promise : typeof Map < "u" && e instanceof Map ? ze.map : typeof Set < "u" && e instanceof Set ? ze.set : typeof Date < "u" && e instanceof Date ? ze.date : ze.object;
    default:
      return ze.unknown;
  }
}, Fe = It.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]), Vj = (e) => JSON.stringify(e, null, 2).replace(/"([^"]+)":/g, "$1:");
let An = class extends Error {
  constructor(t) {
    super(), this.issues = [], this.addIssue = (i) => {
      this.issues = [...this.issues, i];
    }, this.addIssues = (i = []) => {
      this.issues = [...this.issues, ...i];
    };
    const r = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, r) : this.__proto__ = r, this.name = "ZodError", this.issues = t;
  }
  get errors() {
    return this.issues;
  }
  format(t) {
    const r = t || function(s) {
      return s.message;
    }, i = { _errors: [] }, n = (s) => {
      for (const a of s.issues)
        if (a.code === "invalid_union")
          a.unionErrors.map(n);
        else if (a.code === "invalid_return_type")
          n(a.returnTypeError);
        else if (a.code === "invalid_arguments")
          n(a.argumentsError);
        else if (a.path.length === 0)
          i._errors.push(r(a));
        else {
          let o = i, c = 0;
          for (; c < a.path.length; ) {
            const l = a.path[c];
            c === a.path.length - 1 ? (o[l] = o[l] || { _errors: [] }, o[l]._errors.push(r(a))) : o[l] = o[l] || { _errors: [] }, o = o[l], c++;
          }
        }
    };
    return n(this), i;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, It.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(t = (r) => r.message) {
    const r = {}, i = [];
    for (const n of this.issues)
      n.path.length > 0 ? (r[n.path[0]] = r[n.path[0]] || [], r[n.path[0]].push(t(n))) : i.push(t(n));
    return { formErrors: i, fieldErrors: r };
  }
  get formErrors() {
    return this.flatten();
  }
};
An.create = (e) => new An(e);
const fu = (e, t) => {
  let r;
  switch (e.code) {
    case Fe.invalid_type:
      e.received === ze.undefined ? r = "Required" : r = `Expected ${e.expected}, received ${e.received}`;
      break;
    case Fe.invalid_literal:
      r = `Invalid literal value, expected ${JSON.stringify(e.expected, It.jsonStringifyReplacer)}`;
      break;
    case Fe.unrecognized_keys:
      r = `Unrecognized key(s) in object: ${It.joinValues(e.keys, ", ")}`;
      break;
    case Fe.invalid_union:
      r = "Invalid input";
      break;
    case Fe.invalid_union_discriminator:
      r = `Invalid discriminator value. Expected ${It.joinValues(e.options)}`;
      break;
    case Fe.invalid_enum_value:
      r = `Invalid enum value. Expected ${It.joinValues(e.options)}, received '${e.received}'`;
      break;
    case Fe.invalid_arguments:
      r = "Invalid function arguments";
      break;
    case Fe.invalid_return_type:
      r = "Invalid function return type";
      break;
    case Fe.invalid_date:
      r = "Invalid date";
      break;
    case Fe.invalid_string:
      typeof e.validation == "object" ? "includes" in e.validation ? (r = `Invalid input: must include "${e.validation.includes}"`, typeof e.validation.position == "number" && (r = `${r} at one or more positions greater than or equal to ${e.validation.position}`)) : "startsWith" in e.validation ? r = `Invalid input: must start with "${e.validation.startsWith}"` : "endsWith" in e.validation ? r = `Invalid input: must end with "${e.validation.endsWith}"` : It.assertNever(e.validation) : e.validation !== "regex" ? r = `Invalid ${e.validation}` : r = "Invalid";
      break;
    case Fe.too_small:
      e.type === "array" ? r = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "more than"} ${e.minimum} element(s)` : e.type === "string" ? r = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "over"} ${e.minimum} character(s)` : e.type === "number" ? r = `Number must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${e.minimum}` : e.type === "date" ? r = `Date must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(e.minimum))}` : r = "Invalid input";
      break;
    case Fe.too_big:
      e.type === "array" ? r = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "less than"} ${e.maximum} element(s)` : e.type === "string" ? r = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "under"} ${e.maximum} character(s)` : e.type === "number" ? r = `Number must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "bigint" ? r = `BigInt must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "date" ? r = `Date must be ${e.exact ? "exactly" : e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(e.maximum))}` : r = "Invalid input";
      break;
    case Fe.custom:
      r = "Invalid input";
      break;
    case Fe.invalid_intersection_types:
      r = "Intersection results could not be merged";
      break;
    case Fe.not_multiple_of:
      r = `Number must be a multiple of ${e.multipleOf}`;
      break;
    case Fe.not_finite:
      r = "Number must be finite";
      break;
    default:
      r = t.defaultError, It.assertNever(e);
  }
  return { message: r };
};
let x2 = fu;
function Zj(e) {
  x2 = e;
}
function Dl() {
  return x2;
}
const Ll = (e) => {
  const { data: t, path: r, errorMaps: i, issueData: n } = e, s = [...r, ...n.path || []], a = {
    ...n,
    path: s
  };
  let o = "";
  const c = i.filter((l) => !!l).slice().reverse();
  for (const l of c)
    o = l(a, { data: t, defaultError: o }).message;
  return {
    ...n,
    path: s,
    message: n.message || o
  };
}, zj = [];
function Ge(e, t) {
  const r = Ll({
    issueData: t,
    data: e.data,
    path: e.path,
    errorMaps: [
      e.common.contextualErrorMap,
      e.schemaErrorMap,
      Dl(),
      fu
      // then global default map
    ].filter((i) => !!i)
  });
  e.common.issues.push(r);
}
class Or {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(t, r) {
    const i = [];
    for (const n of r) {
      if (n.status === "aborted")
        return ft;
      n.status === "dirty" && t.dirty(), i.push(n.value);
    }
    return { status: t.value, value: i };
  }
  static async mergeObjectAsync(t, r) {
    const i = [];
    for (const n of r)
      i.push({
        key: await n.key,
        value: await n.value
      });
    return Or.mergeObjectSync(t, i);
  }
  static mergeObjectSync(t, r) {
    const i = {};
    for (const n of r) {
      const { key: s, value: a } = n;
      if (s.status === "aborted" || a.status === "aborted")
        return ft;
      s.status === "dirty" && t.dirty(), a.status === "dirty" && t.dirty(), s.value !== "__proto__" && (typeof a.value < "u" || n.alwaysSet) && (i[s.value] = a.value);
    }
    return { status: t.value, value: i };
  }
}
const ft = Object.freeze({
  status: "aborted"
}), O2 = (e) => ({ status: "dirty", value: e }), jr = (e) => ({ status: "valid", value: e }), Um = (e) => e.status === "aborted", Bm = (e) => e.status === "dirty", du = (e) => e.status === "valid", ql = (e) => typeof Promise < "u" && e instanceof Promise;
var et;
(function(e) {
  e.errToObj = (t) => typeof t == "string" ? { message: t } : t || {}, e.toString = (t) => typeof t == "string" ? t : t == null ? void 0 : t.message;
})(et || (et = {}));
class Jn {
  constructor(t, r, i, n) {
    this._cachedPath = [], this.parent = t, this.data = r, this._path = i, this._key = n;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
}
const qb = (e, t) => {
  if (du(t))
    return { success: !0, data: t.value };
  if (!e.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      const r = new An(e.common.issues);
      return this._error = r, this._error;
    }
  };
};
function yt(e) {
  if (!e)
    return {};
  const { errorMap: t, invalid_type_error: r, required_error: i, description: n } = e;
  if (t && (r || i))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return t ? { errorMap: t, description: n } : { errorMap: (a, o) => a.code !== "invalid_type" ? { message: o.defaultError } : typeof o.data > "u" ? { message: i ?? o.defaultError } : { message: r ?? o.defaultError }, description: n };
}
class wt {
  constructor(t) {
    this.spa = this.safeParseAsync, this._def = t, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(t) {
    return Xi(t.data);
  }
  _getOrReturnCtx(t, r) {
    return r || {
      common: t.parent.common,
      data: t.data,
      parsedType: Xi(t.data),
      schemaErrorMap: this._def.errorMap,
      path: t.path,
      parent: t.parent
    };
  }
  _processInputParams(t) {
    return {
      status: new Or(),
      ctx: {
        common: t.parent.common,
        data: t.data,
        parsedType: Xi(t.data),
        schemaErrorMap: this._def.errorMap,
        path: t.path,
        parent: t.parent
      }
    };
  }
  _parseSync(t) {
    const r = this._parse(t);
    if (ql(r))
      throw new Error("Synchronous parse encountered promise.");
    return r;
  }
  _parseAsync(t) {
    const r = this._parse(t);
    return Promise.resolve(r);
  }
  parse(t, r) {
    const i = this.safeParse(t, r);
    if (i.success)
      return i.data;
    throw i.error;
  }
  safeParse(t, r) {
    var i;
    const n = {
      common: {
        issues: [],
        async: (i = r == null ? void 0 : r.async) !== null && i !== void 0 ? i : !1,
        contextualErrorMap: r == null ? void 0 : r.errorMap
      },
      path: (r == null ? void 0 : r.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: Xi(t)
    }, s = this._parseSync({ data: t, path: n.path, parent: n });
    return qb(n, s);
  }
  async parseAsync(t, r) {
    const i = await this.safeParseAsync(t, r);
    if (i.success)
      return i.data;
    throw i.error;
  }
  async safeParseAsync(t, r) {
    const i = {
      common: {
        issues: [],
        contextualErrorMap: r == null ? void 0 : r.errorMap,
        async: !0
      },
      path: (r == null ? void 0 : r.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: Xi(t)
    }, n = this._parse({ data: t, path: i.path, parent: i }), s = await (ql(n) ? n : Promise.resolve(n));
    return qb(i, s);
  }
  refine(t, r) {
    const i = (n) => typeof r == "string" || typeof r > "u" ? { message: r } : typeof r == "function" ? r(n) : r;
    return this._refinement((n, s) => {
      const a = t(n), o = () => s.addIssue({
        code: Fe.custom,
        ...i(n)
      });
      return typeof Promise < "u" && a instanceof Promise ? a.then((c) => c ? !0 : (o(), !1)) : a ? !0 : (o(), !1);
    });
  }
  refinement(t, r) {
    return this._refinement((i, n) => t(i) ? !0 : (n.addIssue(typeof r == "function" ? r(i, n) : r), !1));
  }
  _refinement(t) {
    return new Rn({
      schema: this,
      typeName: ot.ZodEffects,
      effect: { type: "refinement", refinement: t }
    });
  }
  superRefine(t) {
    return this._refinement(t);
  }
  optional() {
    return _i.create(this, this._def);
  }
  nullable() {
    return Ws.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return Cn.create(this, this._def);
  }
  promise() {
    return Ka.create(this, this._def);
  }
  or(t) {
    return yu.create([this, t], this._def);
  }
  and(t) {
    return gu.create(this, t, this._def);
  }
  transform(t) {
    return new Rn({
      ...yt(this._def),
      schema: this,
      typeName: ot.ZodEffects,
      effect: { type: "transform", transform: t }
    });
  }
  default(t) {
    const r = typeof t == "function" ? t : () => t;
    return new $u({
      ...yt(this._def),
      innerType: this,
      defaultValue: r,
      typeName: ot.ZodDefault
    });
  }
  brand() {
    return new S2({
      typeName: ot.ZodBranded,
      type: this,
      ...yt(this._def)
    });
  }
  catch(t) {
    const r = typeof t == "function" ? t : () => t;
    return new Vl({
      ...yt(this._def),
      innerType: this,
      catchValue: r,
      typeName: ot.ZodCatch
    });
  }
  describe(t) {
    const r = this.constructor;
    return new r({
      ...this._def,
      description: t
    });
  }
  pipe(t) {
    return Lu.create(this, t);
  }
  readonly() {
    return zl.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const Wj = /^c[^\s-]{8,}$/i, Hj = /^[a-z][a-z0-9]*$/, Gj = /[0-9A-HJKMNP-TV-Z]{26}/, Kj = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, Yj = /^([A-Z0-9_+-]+\.?)*[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, Jj = /^(\p{Extended_Pictographic}|\p{Emoji_Component})+$/u, Xj = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/, Qj = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/, ek = (e) => e.precision ? e.offset ? new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`) : new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}Z$`) : e.precision === 0 ? e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$") : e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");
function tk(e, t) {
  return !!((t === "v4" || !t) && Xj.test(e) || (t === "v6" || !t) && Qj.test(e));
}
class Sn extends wt {
  constructor() {
    super(...arguments), this._regex = (t, r, i) => this.refinement((n) => t.test(n), {
      validation: r,
      code: Fe.invalid_string,
      ...et.errToObj(i)
    }), this.nonempty = (t) => this.min(1, et.errToObj(t)), this.trim = () => new Sn({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    }), this.toLowerCase = () => new Sn({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    }), this.toUpperCase = () => new Sn({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  _parse(t) {
    if (this._def.coerce && (t.data = String(t.data)), this._getType(t) !== ze.string) {
      const s = this._getOrReturnCtx(t);
      return Ge(
        s,
        {
          code: Fe.invalid_type,
          expected: ze.string,
          received: s.parsedType
        }
        //
      ), ft;
    }
    const i = new Or();
    let n;
    for (const s of this._def.checks)
      if (s.kind === "min")
        t.data.length < s.value && (n = this._getOrReturnCtx(t, n), Ge(n, {
          code: Fe.too_small,
          minimum: s.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: s.message
        }), i.dirty());
      else if (s.kind === "max")
        t.data.length > s.value && (n = this._getOrReturnCtx(t, n), Ge(n, {
          code: Fe.too_big,
          maximum: s.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: s.message
        }), i.dirty());
      else if (s.kind === "length") {
        const a = t.data.length > s.value, o = t.data.length < s.value;
        (a || o) && (n = this._getOrReturnCtx(t, n), a ? Ge(n, {
          code: Fe.too_big,
          maximum: s.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: s.message
        }) : o && Ge(n, {
          code: Fe.too_small,
          minimum: s.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: s.message
        }), i.dirty());
      } else if (s.kind === "email")
        Yj.test(t.data) || (n = this._getOrReturnCtx(t, n), Ge(n, {
          validation: "email",
          code: Fe.invalid_string,
          message: s.message
        }), i.dirty());
      else if (s.kind === "emoji")
        Jj.test(t.data) || (n = this._getOrReturnCtx(t, n), Ge(n, {
          validation: "emoji",
          code: Fe.invalid_string,
          message: s.message
        }), i.dirty());
      else if (s.kind === "uuid")
        Kj.test(t.data) || (n = this._getOrReturnCtx(t, n), Ge(n, {
          validation: "uuid",
          code: Fe.invalid_string,
          message: s.message
        }), i.dirty());
      else if (s.kind === "cuid")
        Wj.test(t.data) || (n = this._getOrReturnCtx(t, n), Ge(n, {
          validation: "cuid",
          code: Fe.invalid_string,
          message: s.message
        }), i.dirty());
      else if (s.kind === "cuid2")
        Hj.test(t.data) || (n = this._getOrReturnCtx(t, n), Ge(n, {
          validation: "cuid2",
          code: Fe.invalid_string,
          message: s.message
        }), i.dirty());
      else if (s.kind === "ulid")
        Gj.test(t.data) || (n = this._getOrReturnCtx(t, n), Ge(n, {
          validation: "ulid",
          code: Fe.invalid_string,
          message: s.message
        }), i.dirty());
      else if (s.kind === "url")
        try {
          new URL(t.data);
        } catch {
          n = this._getOrReturnCtx(t, n), Ge(n, {
            validation: "url",
            code: Fe.invalid_string,
            message: s.message
          }), i.dirty();
        }
      else
        s.kind === "regex" ? (s.regex.lastIndex = 0, s.regex.test(t.data) || (n = this._getOrReturnCtx(t, n), Ge(n, {
          validation: "regex",
          code: Fe.invalid_string,
          message: s.message
        }), i.dirty())) : s.kind === "trim" ? t.data = t.data.trim() : s.kind === "includes" ? t.data.includes(s.value, s.position) || (n = this._getOrReturnCtx(t, n), Ge(n, {
          code: Fe.invalid_string,
          validation: { includes: s.value, position: s.position },
          message: s.message
        }), i.dirty()) : s.kind === "toLowerCase" ? t.data = t.data.toLowerCase() : s.kind === "toUpperCase" ? t.data = t.data.toUpperCase() : s.kind === "startsWith" ? t.data.startsWith(s.value) || (n = this._getOrReturnCtx(t, n), Ge(n, {
          code: Fe.invalid_string,
          validation: { startsWith: s.value },
          message: s.message
        }), i.dirty()) : s.kind === "endsWith" ? t.data.endsWith(s.value) || (n = this._getOrReturnCtx(t, n), Ge(n, {
          code: Fe.invalid_string,
          validation: { endsWith: s.value },
          message: s.message
        }), i.dirty()) : s.kind === "datetime" ? ek(s).test(t.data) || (n = this._getOrReturnCtx(t, n), Ge(n, {
          code: Fe.invalid_string,
          validation: "datetime",
          message: s.message
        }), i.dirty()) : s.kind === "ip" ? tk(t.data, s.version) || (n = this._getOrReturnCtx(t, n), Ge(n, {
          validation: "ip",
          code: Fe.invalid_string,
          message: s.message
        }), i.dirty()) : It.assertNever(s);
    return { status: i.value, value: t.data };
  }
  _addCheck(t) {
    return new Sn({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  email(t) {
    return this._addCheck({ kind: "email", ...et.errToObj(t) });
  }
  url(t) {
    return this._addCheck({ kind: "url", ...et.errToObj(t) });
  }
  emoji(t) {
    return this._addCheck({ kind: "emoji", ...et.errToObj(t) });
  }
  uuid(t) {
    return this._addCheck({ kind: "uuid", ...et.errToObj(t) });
  }
  cuid(t) {
    return this._addCheck({ kind: "cuid", ...et.errToObj(t) });
  }
  cuid2(t) {
    return this._addCheck({ kind: "cuid2", ...et.errToObj(t) });
  }
  ulid(t) {
    return this._addCheck({ kind: "ulid", ...et.errToObj(t) });
  }
  ip(t) {
    return this._addCheck({ kind: "ip", ...et.errToObj(t) });
  }
  datetime(t) {
    var r;
    return typeof t == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      message: t
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof (t == null ? void 0 : t.precision) > "u" ? null : t == null ? void 0 : t.precision,
      offset: (r = t == null ? void 0 : t.offset) !== null && r !== void 0 ? r : !1,
      ...et.errToObj(t == null ? void 0 : t.message)
    });
  }
  regex(t, r) {
    return this._addCheck({
      kind: "regex",
      regex: t,
      ...et.errToObj(r)
    });
  }
  includes(t, r) {
    return this._addCheck({
      kind: "includes",
      value: t,
      position: r == null ? void 0 : r.position,
      ...et.errToObj(r == null ? void 0 : r.message)
    });
  }
  startsWith(t, r) {
    return this._addCheck({
      kind: "startsWith",
      value: t,
      ...et.errToObj(r)
    });
  }
  endsWith(t, r) {
    return this._addCheck({
      kind: "endsWith",
      value: t,
      ...et.errToObj(r)
    });
  }
  min(t, r) {
    return this._addCheck({
      kind: "min",
      value: t,
      ...et.errToObj(r)
    });
  }
  max(t, r) {
    return this._addCheck({
      kind: "max",
      value: t,
      ...et.errToObj(r)
    });
  }
  length(t, r) {
    return this._addCheck({
      kind: "length",
      value: t,
      ...et.errToObj(r)
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((t) => t.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((t) => t.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((t) => t.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((t) => t.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((t) => t.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((t) => t.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((t) => t.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((t) => t.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((t) => t.kind === "ip");
  }
  get minLength() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "min" && (t === null || r.value > t) && (t = r.value);
    return t;
  }
  get maxLength() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    return t;
  }
}
Sn.create = (e) => {
  var t;
  return new Sn({
    checks: [],
    typeName: ot.ZodString,
    coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
    ...yt(e)
  });
};
function rk(e, t) {
  const r = (e.toString().split(".")[1] || "").length, i = (t.toString().split(".")[1] || "").length, n = r > i ? r : i, s = parseInt(e.toFixed(n).replace(".", "")), a = parseInt(t.toFixed(n).replace(".", ""));
  return s % a / Math.pow(10, n);
}
class is extends wt {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = Number(t.data)), this._getType(t) !== ze.number) {
      const s = this._getOrReturnCtx(t);
      return Ge(s, {
        code: Fe.invalid_type,
        expected: ze.number,
        received: s.parsedType
      }), ft;
    }
    let i;
    const n = new Or();
    for (const s of this._def.checks)
      s.kind === "int" ? It.isInteger(t.data) || (i = this._getOrReturnCtx(t, i), Ge(i, {
        code: Fe.invalid_type,
        expected: "integer",
        received: "float",
        message: s.message
      }), n.dirty()) : s.kind === "min" ? (s.inclusive ? t.data < s.value : t.data <= s.value) && (i = this._getOrReturnCtx(t, i), Ge(i, {
        code: Fe.too_small,
        minimum: s.value,
        type: "number",
        inclusive: s.inclusive,
        exact: !1,
        message: s.message
      }), n.dirty()) : s.kind === "max" ? (s.inclusive ? t.data > s.value : t.data >= s.value) && (i = this._getOrReturnCtx(t, i), Ge(i, {
        code: Fe.too_big,
        maximum: s.value,
        type: "number",
        inclusive: s.inclusive,
        exact: !1,
        message: s.message
      }), n.dirty()) : s.kind === "multipleOf" ? rk(t.data, s.value) !== 0 && (i = this._getOrReturnCtx(t, i), Ge(i, {
        code: Fe.not_multiple_of,
        multipleOf: s.value,
        message: s.message
      }), n.dirty()) : s.kind === "finite" ? Number.isFinite(t.data) || (i = this._getOrReturnCtx(t, i), Ge(i, {
        code: Fe.not_finite,
        message: s.message
      }), n.dirty()) : It.assertNever(s);
    return { status: n.value, value: t.data };
  }
  gte(t, r) {
    return this.setLimit("min", t, !0, et.toString(r));
  }
  gt(t, r) {
    return this.setLimit("min", t, !1, et.toString(r));
  }
  lte(t, r) {
    return this.setLimit("max", t, !0, et.toString(r));
  }
  lt(t, r) {
    return this.setLimit("max", t, !1, et.toString(r));
  }
  setLimit(t, r, i, n) {
    return new is({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: r,
          inclusive: i,
          message: et.toString(n)
        }
      ]
    });
  }
  _addCheck(t) {
    return new is({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  int(t) {
    return this._addCheck({
      kind: "int",
      message: et.toString(t)
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: et.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: et.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: et.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: et.toString(t)
    });
  }
  multipleOf(t, r) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: et.toString(r)
    });
  }
  finite(t) {
    return this._addCheck({
      kind: "finite",
      message: et.toString(t)
    });
  }
  safe(t) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: et.toString(t)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: et.toString(t)
    });
  }
  get minValue() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "min" && (t === null || r.value > t) && (t = r.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    return t;
  }
  get isInt() {
    return !!this._def.checks.find((t) => t.kind === "int" || t.kind === "multipleOf" && It.isInteger(t.value));
  }
  get isFinite() {
    let t = null, r = null;
    for (const i of this._def.checks) {
      if (i.kind === "finite" || i.kind === "int" || i.kind === "multipleOf")
        return !0;
      i.kind === "min" ? (r === null || i.value > r) && (r = i.value) : i.kind === "max" && (t === null || i.value < t) && (t = i.value);
    }
    return Number.isFinite(r) && Number.isFinite(t);
  }
}
is.create = (e) => new is({
  checks: [],
  typeName: ot.ZodNumber,
  coerce: (e == null ? void 0 : e.coerce) || !1,
  ...yt(e)
});
class ss extends wt {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = BigInt(t.data)), this._getType(t) !== ze.bigint) {
      const s = this._getOrReturnCtx(t);
      return Ge(s, {
        code: Fe.invalid_type,
        expected: ze.bigint,
        received: s.parsedType
      }), ft;
    }
    let i;
    const n = new Or();
    for (const s of this._def.checks)
      s.kind === "min" ? (s.inclusive ? t.data < s.value : t.data <= s.value) && (i = this._getOrReturnCtx(t, i), Ge(i, {
        code: Fe.too_small,
        type: "bigint",
        minimum: s.value,
        inclusive: s.inclusive,
        message: s.message
      }), n.dirty()) : s.kind === "max" ? (s.inclusive ? t.data > s.value : t.data >= s.value) && (i = this._getOrReturnCtx(t, i), Ge(i, {
        code: Fe.too_big,
        type: "bigint",
        maximum: s.value,
        inclusive: s.inclusive,
        message: s.message
      }), n.dirty()) : s.kind === "multipleOf" ? t.data % s.value !== BigInt(0) && (i = this._getOrReturnCtx(t, i), Ge(i, {
        code: Fe.not_multiple_of,
        multipleOf: s.value,
        message: s.message
      }), n.dirty()) : It.assertNever(s);
    return { status: n.value, value: t.data };
  }
  gte(t, r) {
    return this.setLimit("min", t, !0, et.toString(r));
  }
  gt(t, r) {
    return this.setLimit("min", t, !1, et.toString(r));
  }
  lte(t, r) {
    return this.setLimit("max", t, !0, et.toString(r));
  }
  lt(t, r) {
    return this.setLimit("max", t, !1, et.toString(r));
  }
  setLimit(t, r, i, n) {
    return new ss({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: r,
          inclusive: i,
          message: et.toString(n)
        }
      ]
    });
  }
  _addCheck(t) {
    return new ss({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: et.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: et.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: et.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: et.toString(t)
    });
  }
  multipleOf(t, r) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: et.toString(r)
    });
  }
  get minValue() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "min" && (t === null || r.value > t) && (t = r.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    return t;
  }
}
ss.create = (e) => {
  var t;
  return new ss({
    checks: [],
    typeName: ot.ZodBigInt,
    coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
    ...yt(e)
  });
};
class pu extends wt {
  _parse(t) {
    if (this._def.coerce && (t.data = !!t.data), this._getType(t) !== ze.boolean) {
      const i = this._getOrReturnCtx(t);
      return Ge(i, {
        code: Fe.invalid_type,
        expected: ze.boolean,
        received: i.parsedType
      }), ft;
    }
    return jr(t.data);
  }
}
pu.create = (e) => new pu({
  typeName: ot.ZodBoolean,
  coerce: (e == null ? void 0 : e.coerce) || !1,
  ...yt(e)
});
class Zs extends wt {
  _parse(t) {
    if (this._def.coerce && (t.data = new Date(t.data)), this._getType(t) !== ze.date) {
      const s = this._getOrReturnCtx(t);
      return Ge(s, {
        code: Fe.invalid_type,
        expected: ze.date,
        received: s.parsedType
      }), ft;
    }
    if (isNaN(t.data.getTime())) {
      const s = this._getOrReturnCtx(t);
      return Ge(s, {
        code: Fe.invalid_date
      }), ft;
    }
    const i = new Or();
    let n;
    for (const s of this._def.checks)
      s.kind === "min" ? t.data.getTime() < s.value && (n = this._getOrReturnCtx(t, n), Ge(n, {
        code: Fe.too_small,
        message: s.message,
        inclusive: !0,
        exact: !1,
        minimum: s.value,
        type: "date"
      }), i.dirty()) : s.kind === "max" ? t.data.getTime() > s.value && (n = this._getOrReturnCtx(t, n), Ge(n, {
        code: Fe.too_big,
        message: s.message,
        inclusive: !0,
        exact: !1,
        maximum: s.value,
        type: "date"
      }), i.dirty()) : It.assertNever(s);
    return {
      status: i.value,
      value: new Date(t.data.getTime())
    };
  }
  _addCheck(t) {
    return new Zs({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  min(t, r) {
    return this._addCheck({
      kind: "min",
      value: t.getTime(),
      message: et.toString(r)
    });
  }
  max(t, r) {
    return this._addCheck({
      kind: "max",
      value: t.getTime(),
      message: et.toString(r)
    });
  }
  get minDate() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "min" && (t === null || r.value > t) && (t = r.value);
    return t != null ? new Date(t) : null;
  }
  get maxDate() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    return t != null ? new Date(t) : null;
  }
}
Zs.create = (e) => new Zs({
  checks: [],
  coerce: (e == null ? void 0 : e.coerce) || !1,
  typeName: ot.ZodDate,
  ...yt(e)
});
class Fl extends wt {
  _parse(t) {
    if (this._getType(t) !== ze.symbol) {
      const i = this._getOrReturnCtx(t);
      return Ge(i, {
        code: Fe.invalid_type,
        expected: ze.symbol,
        received: i.parsedType
      }), ft;
    }
    return jr(t.data);
  }
}
Fl.create = (e) => new Fl({
  typeName: ot.ZodSymbol,
  ...yt(e)
});
class hu extends wt {
  _parse(t) {
    if (this._getType(t) !== ze.undefined) {
      const i = this._getOrReturnCtx(t);
      return Ge(i, {
        code: Fe.invalid_type,
        expected: ze.undefined,
        received: i.parsedType
      }), ft;
    }
    return jr(t.data);
  }
}
hu.create = (e) => new hu({
  typeName: ot.ZodUndefined,
  ...yt(e)
});
class mu extends wt {
  _parse(t) {
    if (this._getType(t) !== ze.null) {
      const i = this._getOrReturnCtx(t);
      return Ge(i, {
        code: Fe.invalid_type,
        expected: ze.null,
        received: i.parsedType
      }), ft;
    }
    return jr(t.data);
  }
}
mu.create = (e) => new mu({
  typeName: ot.ZodNull,
  ...yt(e)
});
class Ga extends wt {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(t) {
    return jr(t.data);
  }
}
Ga.create = (e) => new Ga({
  typeName: ot.ZodAny,
  ...yt(e)
});
class Fs extends wt {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(t) {
    return jr(t.data);
  }
}
Fs.create = (e) => new Fs({
  typeName: ot.ZodUnknown,
  ...yt(e)
});
class xi extends wt {
  _parse(t) {
    const r = this._getOrReturnCtx(t);
    return Ge(r, {
      code: Fe.invalid_type,
      expected: ze.never,
      received: r.parsedType
    }), ft;
  }
}
xi.create = (e) => new xi({
  typeName: ot.ZodNever,
  ...yt(e)
});
class Ul extends wt {
  _parse(t) {
    if (this._getType(t) !== ze.undefined) {
      const i = this._getOrReturnCtx(t);
      return Ge(i, {
        code: Fe.invalid_type,
        expected: ze.void,
        received: i.parsedType
      }), ft;
    }
    return jr(t.data);
  }
}
Ul.create = (e) => new Ul({
  typeName: ot.ZodVoid,
  ...yt(e)
});
class Cn extends wt {
  _parse(t) {
    const { ctx: r, status: i } = this._processInputParams(t), n = this._def;
    if (r.parsedType !== ze.array)
      return Ge(r, {
        code: Fe.invalid_type,
        expected: ze.array,
        received: r.parsedType
      }), ft;
    if (n.exactLength !== null) {
      const a = r.data.length > n.exactLength.value, o = r.data.length < n.exactLength.value;
      (a || o) && (Ge(r, {
        code: a ? Fe.too_big : Fe.too_small,
        minimum: o ? n.exactLength.value : void 0,
        maximum: a ? n.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: n.exactLength.message
      }), i.dirty());
    }
    if (n.minLength !== null && r.data.length < n.minLength.value && (Ge(r, {
      code: Fe.too_small,
      minimum: n.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: n.minLength.message
    }), i.dirty()), n.maxLength !== null && r.data.length > n.maxLength.value && (Ge(r, {
      code: Fe.too_big,
      maximum: n.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: n.maxLength.message
    }), i.dirty()), r.common.async)
      return Promise.all([...r.data].map((a, o) => n.type._parseAsync(new Jn(r, a, r.path, o)))).then((a) => Or.mergeArray(i, a));
    const s = [...r.data].map((a, o) => n.type._parseSync(new Jn(r, a, r.path, o)));
    return Or.mergeArray(i, s);
  }
  get element() {
    return this._def.type;
  }
  min(t, r) {
    return new Cn({
      ...this._def,
      minLength: { value: t, message: et.toString(r) }
    });
  }
  max(t, r) {
    return new Cn({
      ...this._def,
      maxLength: { value: t, message: et.toString(r) }
    });
  }
  length(t, r) {
    return new Cn({
      ...this._def,
      exactLength: { value: t, message: et.toString(r) }
    });
  }
  nonempty(t) {
    return this.min(1, t);
  }
}
Cn.create = (e, t) => new Cn({
  type: e,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: ot.ZodArray,
  ...yt(t)
});
function Ra(e) {
  if (e instanceof Gt) {
    const t = {};
    for (const r in e.shape) {
      const i = e.shape[r];
      t[r] = _i.create(Ra(i));
    }
    return new Gt({
      ...e._def,
      shape: () => t
    });
  } else
    return e instanceof Cn ? new Cn({
      ...e._def,
      type: Ra(e.element)
    }) : e instanceof _i ? _i.create(Ra(e.unwrap())) : e instanceof Ws ? Ws.create(Ra(e.unwrap())) : e instanceof Xn ? Xn.create(e.items.map((t) => Ra(t))) : e;
}
class Gt extends wt {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const t = this._def.shape(), r = It.objectKeys(t);
    return this._cached = { shape: t, keys: r };
  }
  _parse(t) {
    if (this._getType(t) !== ze.object) {
      const l = this._getOrReturnCtx(t);
      return Ge(l, {
        code: Fe.invalid_type,
        expected: ze.object,
        received: l.parsedType
      }), ft;
    }
    const { status: i, ctx: n } = this._processInputParams(t), { shape: s, keys: a } = this._getCached(), o = [];
    if (!(this._def.catchall instanceof xi && this._def.unknownKeys === "strip"))
      for (const l in n.data)
        a.includes(l) || o.push(l);
    const c = [];
    for (const l of a) {
      const d = s[l], p = n.data[l];
      c.push({
        key: { status: "valid", value: l },
        value: d._parse(new Jn(n, p, n.path, l)),
        alwaysSet: l in n.data
      });
    }
    if (this._def.catchall instanceof xi) {
      const l = this._def.unknownKeys;
      if (l === "passthrough")
        for (const d of o)
          c.push({
            key: { status: "valid", value: d },
            value: { status: "valid", value: n.data[d] }
          });
      else if (l === "strict")
        o.length > 0 && (Ge(n, {
          code: Fe.unrecognized_keys,
          keys: o
        }), i.dirty());
      else if (l !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const l = this._def.catchall;
      for (const d of o) {
        const p = n.data[d];
        c.push({
          key: { status: "valid", value: d },
          value: l._parse(
            new Jn(n, p, n.path, d)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: d in n.data
        });
      }
    }
    return n.common.async ? Promise.resolve().then(async () => {
      const l = [];
      for (const d of c) {
        const p = await d.key;
        l.push({
          key: p,
          value: await d.value,
          alwaysSet: d.alwaysSet
        });
      }
      return l;
    }).then((l) => Or.mergeObjectSync(i, l)) : Or.mergeObjectSync(i, c);
  }
  get shape() {
    return this._def.shape();
  }
  strict(t) {
    return et.errToObj, new Gt({
      ...this._def,
      unknownKeys: "strict",
      ...t !== void 0 ? {
        errorMap: (r, i) => {
          var n, s, a, o;
          const c = (a = (s = (n = this._def).errorMap) === null || s === void 0 ? void 0 : s.call(n, r, i).message) !== null && a !== void 0 ? a : i.defaultError;
          return r.code === "unrecognized_keys" ? {
            message: (o = et.errToObj(t).message) !== null && o !== void 0 ? o : c
          } : {
            message: c
          };
        }
      } : {}
    });
  }
  strip() {
    return new Gt({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new Gt({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(t) {
    return new Gt({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...t
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(t) {
    return new Gt({
      unknownKeys: t._def.unknownKeys,
      catchall: t._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...t._def.shape()
      }),
      typeName: ot.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(t, r) {
    return this.augment({ [t]: r });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(t) {
    return new Gt({
      ...this._def,
      catchall: t
    });
  }
  pick(t) {
    const r = {};
    return It.objectKeys(t).forEach((i) => {
      t[i] && this.shape[i] && (r[i] = this.shape[i]);
    }), new Gt({
      ...this._def,
      shape: () => r
    });
  }
  omit(t) {
    const r = {};
    return It.objectKeys(this.shape).forEach((i) => {
      t[i] || (r[i] = this.shape[i]);
    }), new Gt({
      ...this._def,
      shape: () => r
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return Ra(this);
  }
  partial(t) {
    const r = {};
    return It.objectKeys(this.shape).forEach((i) => {
      const n = this.shape[i];
      t && !t[i] ? r[i] = n : r[i] = n.optional();
    }), new Gt({
      ...this._def,
      shape: () => r
    });
  }
  required(t) {
    const r = {};
    return It.objectKeys(this.shape).forEach((i) => {
      if (t && !t[i])
        r[i] = this.shape[i];
      else {
        let s = this.shape[i];
        for (; s instanceof _i; )
          s = s._def.innerType;
        r[i] = s;
      }
    }), new Gt({
      ...this._def,
      shape: () => r
    });
  }
  keyof() {
    return P2(It.objectKeys(this.shape));
  }
}
Gt.create = (e, t) => new Gt({
  shape: () => e,
  unknownKeys: "strip",
  catchall: xi.create(),
  typeName: ot.ZodObject,
  ...yt(t)
});
Gt.strictCreate = (e, t) => new Gt({
  shape: () => e,
  unknownKeys: "strict",
  catchall: xi.create(),
  typeName: ot.ZodObject,
  ...yt(t)
});
Gt.lazycreate = (e, t) => new Gt({
  shape: e,
  unknownKeys: "strip",
  catchall: xi.create(),
  typeName: ot.ZodObject,
  ...yt(t)
});
class yu extends wt {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t), i = this._def.options;
    function n(s) {
      for (const o of s)
        if (o.result.status === "valid")
          return o.result;
      for (const o of s)
        if (o.result.status === "dirty")
          return r.common.issues.push(...o.ctx.common.issues), o.result;
      const a = s.map((o) => new An(o.ctx.common.issues));
      return Ge(r, {
        code: Fe.invalid_union,
        unionErrors: a
      }), ft;
    }
    if (r.common.async)
      return Promise.all(i.map(async (s) => {
        const a = {
          ...r,
          common: {
            ...r.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await s._parseAsync({
            data: r.data,
            path: r.path,
            parent: a
          }),
          ctx: a
        };
      })).then(n);
    {
      let s;
      const a = [];
      for (const c of i) {
        const l = {
          ...r,
          common: {
            ...r.common,
            issues: []
          },
          parent: null
        }, d = c._parseSync({
          data: r.data,
          path: r.path,
          parent: l
        });
        if (d.status === "valid")
          return d;
        d.status === "dirty" && !s && (s = { result: d, ctx: l }), l.common.issues.length && a.push(l.common.issues);
      }
      if (s)
        return r.common.issues.push(...s.ctx.common.issues), s.result;
      const o = a.map((c) => new An(c));
      return Ge(r, {
        code: Fe.invalid_union,
        unionErrors: o
      }), ft;
    }
  }
  get options() {
    return this._def.options;
  }
}
yu.create = (e, t) => new yu({
  options: e,
  typeName: ot.ZodUnion,
  ...yt(t)
});
const hl = (e) => e instanceof bu ? hl(e.schema) : e instanceof Rn ? hl(e.innerType()) : e instanceof _u ? [e.value] : e instanceof as ? e.options : e instanceof wu ? Object.keys(e.enum) : e instanceof $u ? hl(e._def.innerType) : e instanceof hu ? [void 0] : e instanceof mu ? [null] : null;
class wf extends wt {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t);
    if (r.parsedType !== ze.object)
      return Ge(r, {
        code: Fe.invalid_type,
        expected: ze.object,
        received: r.parsedType
      }), ft;
    const i = this.discriminator, n = r.data[i], s = this.optionsMap.get(n);
    return s ? r.common.async ? s._parseAsync({
      data: r.data,
      path: r.path,
      parent: r
    }) : s._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }) : (Ge(r, {
      code: Fe.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [i]
    }), ft);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(t, r, i) {
    const n = /* @__PURE__ */ new Map();
    for (const s of r) {
      const a = hl(s.shape[t]);
      if (!a)
        throw new Error(`A discriminator value for key \`${t}\` could not be extracted from all schema options`);
      for (const o of a) {
        if (n.has(o))
          throw new Error(`Discriminator property ${String(t)} has duplicate value ${String(o)}`);
        n.set(o, s);
      }
    }
    return new wf({
      typeName: ot.ZodDiscriminatedUnion,
      discriminator: t,
      options: r,
      optionsMap: n,
      ...yt(i)
    });
  }
}
function Vm(e, t) {
  const r = Xi(e), i = Xi(t);
  if (e === t)
    return { valid: !0, data: e };
  if (r === ze.object && i === ze.object) {
    const n = It.objectKeys(t), s = It.objectKeys(e).filter((o) => n.indexOf(o) !== -1), a = { ...e, ...t };
    for (const o of s) {
      const c = Vm(e[o], t[o]);
      if (!c.valid)
        return { valid: !1 };
      a[o] = c.data;
    }
    return { valid: !0, data: a };
  } else if (r === ze.array && i === ze.array) {
    if (e.length !== t.length)
      return { valid: !1 };
    const n = [];
    for (let s = 0; s < e.length; s++) {
      const a = e[s], o = t[s], c = Vm(a, o);
      if (!c.valid)
        return { valid: !1 };
      n.push(c.data);
    }
    return { valid: !0, data: n };
  } else
    return r === ze.date && i === ze.date && +e == +t ? { valid: !0, data: e } : { valid: !1 };
}
class gu extends wt {
  _parse(t) {
    const { status: r, ctx: i } = this._processInputParams(t), n = (s, a) => {
      if (Um(s) || Um(a))
        return ft;
      const o = Vm(s.value, a.value);
      return o.valid ? ((Bm(s) || Bm(a)) && r.dirty(), { status: r.value, value: o.data }) : (Ge(i, {
        code: Fe.invalid_intersection_types
      }), ft);
    };
    return i.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: i.data,
        path: i.path,
        parent: i
      }),
      this._def.right._parseAsync({
        data: i.data,
        path: i.path,
        parent: i
      })
    ]).then(([s, a]) => n(s, a)) : n(this._def.left._parseSync({
      data: i.data,
      path: i.path,
      parent: i
    }), this._def.right._parseSync({
      data: i.data,
      path: i.path,
      parent: i
    }));
  }
}
gu.create = (e, t, r) => new gu({
  left: e,
  right: t,
  typeName: ot.ZodIntersection,
  ...yt(r)
});
class Xn extends wt {
  _parse(t) {
    const { status: r, ctx: i } = this._processInputParams(t);
    if (i.parsedType !== ze.array)
      return Ge(i, {
        code: Fe.invalid_type,
        expected: ze.array,
        received: i.parsedType
      }), ft;
    if (i.data.length < this._def.items.length)
      return Ge(i, {
        code: Fe.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), ft;
    !this._def.rest && i.data.length > this._def.items.length && (Ge(i, {
      code: Fe.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), r.dirty());
    const s = [...i.data].map((a, o) => {
      const c = this._def.items[o] || this._def.rest;
      return c ? c._parse(new Jn(i, a, i.path, o)) : null;
    }).filter((a) => !!a);
    return i.common.async ? Promise.all(s).then((a) => Or.mergeArray(r, a)) : Or.mergeArray(r, s);
  }
  get items() {
    return this._def.items;
  }
  rest(t) {
    return new Xn({
      ...this._def,
      rest: t
    });
  }
}
Xn.create = (e, t) => {
  if (!Array.isArray(e))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new Xn({
    items: e,
    typeName: ot.ZodTuple,
    rest: null,
    ...yt(t)
  });
};
class vu extends wt {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(t) {
    const { status: r, ctx: i } = this._processInputParams(t);
    if (i.parsedType !== ze.object)
      return Ge(i, {
        code: Fe.invalid_type,
        expected: ze.object,
        received: i.parsedType
      }), ft;
    const n = [], s = this._def.keyType, a = this._def.valueType;
    for (const o in i.data)
      n.push({
        key: s._parse(new Jn(i, o, i.path, o)),
        value: a._parse(new Jn(i, i.data[o], i.path, o))
      });
    return i.common.async ? Or.mergeObjectAsync(r, n) : Or.mergeObjectSync(r, n);
  }
  get element() {
    return this._def.valueType;
  }
  static create(t, r, i) {
    return r instanceof wt ? new vu({
      keyType: t,
      valueType: r,
      typeName: ot.ZodRecord,
      ...yt(i)
    }) : new vu({
      keyType: Sn.create(),
      valueType: t,
      typeName: ot.ZodRecord,
      ...yt(r)
    });
  }
}
class Bl extends wt {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(t) {
    const { status: r, ctx: i } = this._processInputParams(t);
    if (i.parsedType !== ze.map)
      return Ge(i, {
        code: Fe.invalid_type,
        expected: ze.map,
        received: i.parsedType
      }), ft;
    const n = this._def.keyType, s = this._def.valueType, a = [...i.data.entries()].map(([o, c], l) => ({
      key: n._parse(new Jn(i, o, i.path, [l, "key"])),
      value: s._parse(new Jn(i, c, i.path, [l, "value"]))
    }));
    if (i.common.async) {
      const o = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const c of a) {
          const l = await c.key, d = await c.value;
          if (l.status === "aborted" || d.status === "aborted")
            return ft;
          (l.status === "dirty" || d.status === "dirty") && r.dirty(), o.set(l.value, d.value);
        }
        return { status: r.value, value: o };
      });
    } else {
      const o = /* @__PURE__ */ new Map();
      for (const c of a) {
        const l = c.key, d = c.value;
        if (l.status === "aborted" || d.status === "aborted")
          return ft;
        (l.status === "dirty" || d.status === "dirty") && r.dirty(), o.set(l.value, d.value);
      }
      return { status: r.value, value: o };
    }
  }
}
Bl.create = (e, t, r) => new Bl({
  valueType: t,
  keyType: e,
  typeName: ot.ZodMap,
  ...yt(r)
});
class zs extends wt {
  _parse(t) {
    const { status: r, ctx: i } = this._processInputParams(t);
    if (i.parsedType !== ze.set)
      return Ge(i, {
        code: Fe.invalid_type,
        expected: ze.set,
        received: i.parsedType
      }), ft;
    const n = this._def;
    n.minSize !== null && i.data.size < n.minSize.value && (Ge(i, {
      code: Fe.too_small,
      minimum: n.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: n.minSize.message
    }), r.dirty()), n.maxSize !== null && i.data.size > n.maxSize.value && (Ge(i, {
      code: Fe.too_big,
      maximum: n.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: n.maxSize.message
    }), r.dirty());
    const s = this._def.valueType;
    function a(c) {
      const l = /* @__PURE__ */ new Set();
      for (const d of c) {
        if (d.status === "aborted")
          return ft;
        d.status === "dirty" && r.dirty(), l.add(d.value);
      }
      return { status: r.value, value: l };
    }
    const o = [...i.data.values()].map((c, l) => s._parse(new Jn(i, c, i.path, l)));
    return i.common.async ? Promise.all(o).then((c) => a(c)) : a(o);
  }
  min(t, r) {
    return new zs({
      ...this._def,
      minSize: { value: t, message: et.toString(r) }
    });
  }
  max(t, r) {
    return new zs({
      ...this._def,
      maxSize: { value: t, message: et.toString(r) }
    });
  }
  size(t, r) {
    return this.min(t, r).max(t, r);
  }
  nonempty(t) {
    return this.min(1, t);
  }
}
zs.create = (e, t) => new zs({
  valueType: e,
  minSize: null,
  maxSize: null,
  typeName: ot.ZodSet,
  ...yt(t)
});
class Fa extends wt {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(t) {
    const { ctx: r } = this._processInputParams(t);
    if (r.parsedType !== ze.function)
      return Ge(r, {
        code: Fe.invalid_type,
        expected: ze.function,
        received: r.parsedType
      }), ft;
    function i(o, c) {
      return Ll({
        data: o,
        path: r.path,
        errorMaps: [
          r.common.contextualErrorMap,
          r.schemaErrorMap,
          Dl(),
          fu
        ].filter((l) => !!l),
        issueData: {
          code: Fe.invalid_arguments,
          argumentsError: c
        }
      });
    }
    function n(o, c) {
      return Ll({
        data: o,
        path: r.path,
        errorMaps: [
          r.common.contextualErrorMap,
          r.schemaErrorMap,
          Dl(),
          fu
        ].filter((l) => !!l),
        issueData: {
          code: Fe.invalid_return_type,
          returnTypeError: c
        }
      });
    }
    const s = { errorMap: r.common.contextualErrorMap }, a = r.data;
    if (this._def.returns instanceof Ka) {
      const o = this;
      return jr(async function(...c) {
        const l = new An([]), d = await o._def.args.parseAsync(c, s).catch((g) => {
          throw l.addIssue(i(c, g)), l;
        }), p = await Reflect.apply(a, this, d);
        return await o._def.returns._def.type.parseAsync(p, s).catch((g) => {
          throw l.addIssue(n(p, g)), l;
        });
      });
    } else {
      const o = this;
      return jr(function(...c) {
        const l = o._def.args.safeParse(c, s);
        if (!l.success)
          throw new An([i(c, l.error)]);
        const d = Reflect.apply(a, this, l.data), p = o._def.returns.safeParse(d, s);
        if (!p.success)
          throw new An([n(d, p.error)]);
        return p.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...t) {
    return new Fa({
      ...this._def,
      args: Xn.create(t).rest(Fs.create())
    });
  }
  returns(t) {
    return new Fa({
      ...this._def,
      returns: t
    });
  }
  implement(t) {
    return this.parse(t);
  }
  strictImplement(t) {
    return this.parse(t);
  }
  static create(t, r, i) {
    return new Fa({
      args: t || Xn.create([]).rest(Fs.create()),
      returns: r || Fs.create(),
      typeName: ot.ZodFunction,
      ...yt(i)
    });
  }
}
class bu extends wt {
  get schema() {
    return this._def.getter();
  }
  _parse(t) {
    const { ctx: r } = this._processInputParams(t);
    return this._def.getter()._parse({ data: r.data, path: r.path, parent: r });
  }
}
bu.create = (e, t) => new bu({
  getter: e,
  typeName: ot.ZodLazy,
  ...yt(t)
});
class _u extends wt {
  _parse(t) {
    if (t.data !== this._def.value) {
      const r = this._getOrReturnCtx(t);
      return Ge(r, {
        received: r.data,
        code: Fe.invalid_literal,
        expected: this._def.value
      }), ft;
    }
    return { status: "valid", value: t.data };
  }
  get value() {
    return this._def.value;
  }
}
_u.create = (e, t) => new _u({
  value: e,
  typeName: ot.ZodLiteral,
  ...yt(t)
});
function P2(e, t) {
  return new as({
    values: e,
    typeName: ot.ZodEnum,
    ...yt(t)
  });
}
class as extends wt {
  _parse(t) {
    if (typeof t.data != "string") {
      const r = this._getOrReturnCtx(t), i = this._def.values;
      return Ge(r, {
        expected: It.joinValues(i),
        received: r.parsedType,
        code: Fe.invalid_type
      }), ft;
    }
    if (this._def.values.indexOf(t.data) === -1) {
      const r = this._getOrReturnCtx(t), i = this._def.values;
      return Ge(r, {
        received: r.data,
        code: Fe.invalid_enum_value,
        options: i
      }), ft;
    }
    return jr(t.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const t = {};
    for (const r of this._def.values)
      t[r] = r;
    return t;
  }
  get Values() {
    const t = {};
    for (const r of this._def.values)
      t[r] = r;
    return t;
  }
  get Enum() {
    const t = {};
    for (const r of this._def.values)
      t[r] = r;
    return t;
  }
  extract(t) {
    return as.create(t);
  }
  exclude(t) {
    return as.create(this.options.filter((r) => !t.includes(r)));
  }
}
as.create = P2;
class wu extends wt {
  _parse(t) {
    const r = It.getValidEnumValues(this._def.values), i = this._getOrReturnCtx(t);
    if (i.parsedType !== ze.string && i.parsedType !== ze.number) {
      const n = It.objectValues(r);
      return Ge(i, {
        expected: It.joinValues(n),
        received: i.parsedType,
        code: Fe.invalid_type
      }), ft;
    }
    if (r.indexOf(t.data) === -1) {
      const n = It.objectValues(r);
      return Ge(i, {
        received: i.data,
        code: Fe.invalid_enum_value,
        options: n
      }), ft;
    }
    return jr(t.data);
  }
  get enum() {
    return this._def.values;
  }
}
wu.create = (e, t) => new wu({
  values: e,
  typeName: ot.ZodNativeEnum,
  ...yt(t)
});
class Ka extends wt {
  unwrap() {
    return this._def.type;
  }
  _parse(t) {
    const { ctx: r } = this._processInputParams(t);
    if (r.parsedType !== ze.promise && r.common.async === !1)
      return Ge(r, {
        code: Fe.invalid_type,
        expected: ze.promise,
        received: r.parsedType
      }), ft;
    const i = r.parsedType === ze.promise ? r.data : Promise.resolve(r.data);
    return jr(i.then((n) => this._def.type.parseAsync(n, {
      path: r.path,
      errorMap: r.common.contextualErrorMap
    })));
  }
}
Ka.create = (e, t) => new Ka({
  type: e,
  typeName: ot.ZodPromise,
  ...yt(t)
});
class Rn extends wt {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ot.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(t) {
    const { status: r, ctx: i } = this._processInputParams(t), n = this._def.effect || null, s = {
      addIssue: (a) => {
        Ge(i, a), a.fatal ? r.abort() : r.dirty();
      },
      get path() {
        return i.path;
      }
    };
    if (s.addIssue = s.addIssue.bind(s), n.type === "preprocess") {
      const a = n.transform(i.data, s);
      return i.common.issues.length ? {
        status: "dirty",
        value: i.data
      } : i.common.async ? Promise.resolve(a).then((o) => this._def.schema._parseAsync({
        data: o,
        path: i.path,
        parent: i
      })) : this._def.schema._parseSync({
        data: a,
        path: i.path,
        parent: i
      });
    }
    if (n.type === "refinement") {
      const a = (o) => {
        const c = n.refinement(o, s);
        if (i.common.async)
          return Promise.resolve(c);
        if (c instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return o;
      };
      if (i.common.async === !1) {
        const o = this._def.schema._parseSync({
          data: i.data,
          path: i.path,
          parent: i
        });
        return o.status === "aborted" ? ft : (o.status === "dirty" && r.dirty(), a(o.value), { status: r.value, value: o.value });
      } else
        return this._def.schema._parseAsync({ data: i.data, path: i.path, parent: i }).then((o) => o.status === "aborted" ? ft : (o.status === "dirty" && r.dirty(), a(o.value).then(() => ({ status: r.value, value: o.value }))));
    }
    if (n.type === "transform")
      if (i.common.async === !1) {
        const a = this._def.schema._parseSync({
          data: i.data,
          path: i.path,
          parent: i
        });
        if (!du(a))
          return a;
        const o = n.transform(a.value, s);
        if (o instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: r.value, value: o };
      } else
        return this._def.schema._parseAsync({ data: i.data, path: i.path, parent: i }).then((a) => du(a) ? Promise.resolve(n.transform(a.value, s)).then((o) => ({ status: r.value, value: o })) : a);
    It.assertNever(n);
  }
}
Rn.create = (e, t, r) => new Rn({
  schema: e,
  typeName: ot.ZodEffects,
  effect: t,
  ...yt(r)
});
Rn.createWithPreprocess = (e, t, r) => new Rn({
  schema: t,
  effect: { type: "preprocess", transform: e },
  typeName: ot.ZodEffects,
  ...yt(r)
});
class _i extends wt {
  _parse(t) {
    return this._getType(t) === ze.undefined ? jr(void 0) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
}
_i.create = (e, t) => new _i({
  innerType: e,
  typeName: ot.ZodOptional,
  ...yt(t)
});
class Ws extends wt {
  _parse(t) {
    return this._getType(t) === ze.null ? jr(null) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
}
Ws.create = (e, t) => new Ws({
  innerType: e,
  typeName: ot.ZodNullable,
  ...yt(t)
});
class $u extends wt {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t);
    let i = r.data;
    return r.parsedType === ze.undefined && (i = this._def.defaultValue()), this._def.innerType._parse({
      data: i,
      path: r.path,
      parent: r
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
$u.create = (e, t) => new $u({
  innerType: e,
  typeName: ot.ZodDefault,
  defaultValue: typeof t.default == "function" ? t.default : () => t.default,
  ...yt(t)
});
class Vl extends wt {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t), i = {
      ...r,
      common: {
        ...r.common,
        issues: []
      }
    }, n = this._def.innerType._parse({
      data: i.data,
      path: i.path,
      parent: {
        ...i
      }
    });
    return ql(n) ? n.then((s) => ({
      status: "valid",
      value: s.status === "valid" ? s.value : this._def.catchValue({
        get error() {
          return new An(i.common.issues);
        },
        input: i.data
      })
    })) : {
      status: "valid",
      value: n.status === "valid" ? n.value : this._def.catchValue({
        get error() {
          return new An(i.common.issues);
        },
        input: i.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
}
Vl.create = (e, t) => new Vl({
  innerType: e,
  typeName: ot.ZodCatch,
  catchValue: typeof t.catch == "function" ? t.catch : () => t.catch,
  ...yt(t)
});
class Zl extends wt {
  _parse(t) {
    if (this._getType(t) !== ze.nan) {
      const i = this._getOrReturnCtx(t);
      return Ge(i, {
        code: Fe.invalid_type,
        expected: ze.nan,
        received: i.parsedType
      }), ft;
    }
    return { status: "valid", value: t.data };
  }
}
Zl.create = (e) => new Zl({
  typeName: ot.ZodNaN,
  ...yt(e)
});
const nk = Symbol("zod_brand");
class S2 extends wt {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t), i = r.data;
    return this._def.type._parse({
      data: i,
      path: r.path,
      parent: r
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class Lu extends wt {
  _parse(t) {
    const { status: r, ctx: i } = this._processInputParams(t);
    if (i.common.async)
      return (async () => {
        const s = await this._def.in._parseAsync({
          data: i.data,
          path: i.path,
          parent: i
        });
        return s.status === "aborted" ? ft : s.status === "dirty" ? (r.dirty(), O2(s.value)) : this._def.out._parseAsync({
          data: s.value,
          path: i.path,
          parent: i
        });
      })();
    {
      const n = this._def.in._parseSync({
        data: i.data,
        path: i.path,
        parent: i
      });
      return n.status === "aborted" ? ft : n.status === "dirty" ? (r.dirty(), {
        status: "dirty",
        value: n.value
      }) : this._def.out._parseSync({
        data: n.value,
        path: i.path,
        parent: i
      });
    }
  }
  static create(t, r) {
    return new Lu({
      in: t,
      out: r,
      typeName: ot.ZodPipeline
    });
  }
}
class zl extends wt {
  _parse(t) {
    const r = this._def.innerType._parse(t);
    return du(r) && (r.value = Object.freeze(r.value)), r;
  }
}
zl.create = (e, t) => new zl({
  innerType: e,
  typeName: ot.ZodReadonly,
  ...yt(t)
});
const A2 = (e, t = {}, r) => e ? Ga.create().superRefine((i, n) => {
  var s, a;
  if (!e(i)) {
    const o = typeof t == "function" ? t(i) : typeof t == "string" ? { message: t } : t, c = (a = (s = o.fatal) !== null && s !== void 0 ? s : r) !== null && a !== void 0 ? a : !0, l = typeof o == "string" ? { message: o } : o;
    n.addIssue({ code: "custom", ...l, fatal: c });
  }
}) : Ga.create(), ik = {
  object: Gt.lazycreate
};
var ot;
(function(e) {
  e.ZodString = "ZodString", e.ZodNumber = "ZodNumber", e.ZodNaN = "ZodNaN", e.ZodBigInt = "ZodBigInt", e.ZodBoolean = "ZodBoolean", e.ZodDate = "ZodDate", e.ZodSymbol = "ZodSymbol", e.ZodUndefined = "ZodUndefined", e.ZodNull = "ZodNull", e.ZodAny = "ZodAny", e.ZodUnknown = "ZodUnknown", e.ZodNever = "ZodNever", e.ZodVoid = "ZodVoid", e.ZodArray = "ZodArray", e.ZodObject = "ZodObject", e.ZodUnion = "ZodUnion", e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", e.ZodIntersection = "ZodIntersection", e.ZodTuple = "ZodTuple", e.ZodRecord = "ZodRecord", e.ZodMap = "ZodMap", e.ZodSet = "ZodSet", e.ZodFunction = "ZodFunction", e.ZodLazy = "ZodLazy", e.ZodLiteral = "ZodLiteral", e.ZodEnum = "ZodEnum", e.ZodEffects = "ZodEffects", e.ZodNativeEnum = "ZodNativeEnum", e.ZodOptional = "ZodOptional", e.ZodNullable = "ZodNullable", e.ZodDefault = "ZodDefault", e.ZodCatch = "ZodCatch", e.ZodPromise = "ZodPromise", e.ZodBranded = "ZodBranded", e.ZodPipeline = "ZodPipeline", e.ZodReadonly = "ZodReadonly";
})(ot || (ot = {}));
const sk = (e, t = {
  message: `Input not instance of ${e.name}`
}) => A2((r) => r instanceof e, t), C2 = Sn.create, R2 = is.create, ak = Zl.create, ok = ss.create, T2 = pu.create, uk = Zs.create, ck = Fl.create, lk = hu.create, fk = mu.create, dk = Ga.create, pk = Fs.create, hk = xi.create, mk = Ul.create, yk = Cn.create, gk = Gt.create, vk = Gt.strictCreate, bk = yu.create, _k = wf.create, wk = gu.create, $k = Xn.create, Ek = vu.create, xk = Bl.create, Ok = zs.create, Pk = Fa.create, Sk = bu.create, Ak = _u.create, Ck = as.create, Rk = wu.create, Tk = Ka.create, Fb = Rn.create, Ik = _i.create, jk = Ws.create, kk = Rn.createWithPreprocess, Mk = Lu.create, Nk = () => C2().optional(), Dk = () => R2().optional(), Lk = () => T2().optional(), qk = {
  string: (e) => Sn.create({ ...e, coerce: !0 }),
  number: (e) => is.create({ ...e, coerce: !0 }),
  boolean: (e) => pu.create({
    ...e,
    coerce: !0
  }),
  bigint: (e) => ss.create({ ...e, coerce: !0 }),
  date: (e) => Zs.create({ ...e, coerce: !0 })
}, Fk = ft;
var ke = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: fu,
  setErrorMap: Zj,
  getErrorMap: Dl,
  makeIssue: Ll,
  EMPTY_PATH: zj,
  addIssueToContext: Ge,
  ParseStatus: Or,
  INVALID: ft,
  DIRTY: O2,
  OK: jr,
  isAborted: Um,
  isDirty: Bm,
  isValid: du,
  isAsync: ql,
  get util() {
    return It;
  },
  get objectUtil() {
    return Fm;
  },
  ZodParsedType: ze,
  getParsedType: Xi,
  ZodType: wt,
  ZodString: Sn,
  ZodNumber: is,
  ZodBigInt: ss,
  ZodBoolean: pu,
  ZodDate: Zs,
  ZodSymbol: Fl,
  ZodUndefined: hu,
  ZodNull: mu,
  ZodAny: Ga,
  ZodUnknown: Fs,
  ZodNever: xi,
  ZodVoid: Ul,
  ZodArray: Cn,
  ZodObject: Gt,
  ZodUnion: yu,
  ZodDiscriminatedUnion: wf,
  ZodIntersection: gu,
  ZodTuple: Xn,
  ZodRecord: vu,
  ZodMap: Bl,
  ZodSet: zs,
  ZodFunction: Fa,
  ZodLazy: bu,
  ZodLiteral: _u,
  ZodEnum: as,
  ZodNativeEnum: wu,
  ZodPromise: Ka,
  ZodEffects: Rn,
  ZodTransformer: Rn,
  ZodOptional: _i,
  ZodNullable: Ws,
  ZodDefault: $u,
  ZodCatch: Vl,
  ZodNaN: Zl,
  BRAND: nk,
  ZodBranded: S2,
  ZodPipeline: Lu,
  ZodReadonly: zl,
  custom: A2,
  Schema: wt,
  ZodSchema: wt,
  late: ik,
  get ZodFirstPartyTypeKind() {
    return ot;
  },
  coerce: qk,
  any: dk,
  array: yk,
  bigint: ok,
  boolean: T2,
  date: uk,
  discriminatedUnion: _k,
  effect: Fb,
  enum: Ck,
  function: Pk,
  instanceof: sk,
  intersection: wk,
  lazy: Sk,
  literal: Ak,
  map: xk,
  nan: ak,
  nativeEnum: Rk,
  never: hk,
  null: fk,
  nullable: jk,
  number: R2,
  object: gk,
  oboolean: Lk,
  onumber: Dk,
  optional: Ik,
  ostring: Nk,
  pipeline: Mk,
  preprocess: kk,
  promise: Tk,
  record: Ek,
  set: Ok,
  strictObject: vk,
  string: C2,
  symbol: ck,
  transformer: Fb,
  tuple: $k,
  undefined: lk,
  union: bk,
  unknown: pk,
  void: mk,
  NEVER: Fk,
  ZodIssueCode: Fe,
  quotelessJson: Vj,
  ZodError: An
});
ke.object({
  user_id: ke.string().nonempty(),
  public_key: ke.string().nonempty(),
  private_key: ke.string().nonempty()
});
ke.object({
  id: ke.string().nonempty(),
  path: ke.string().nonempty().catch("/"),
  method: ke.string().nonempty().catch("post")
});
const $f = ke.object({
  n: ke.string().optional(),
  c: ke.string(),
  s: ke.string(),
  pk: ke.string()
}), Uk = ke.object({
  module_id: ke.string().nonempty(),
  method_id: ke.string().nonempty()
}), I2 = ke.object({
  id: ke.string().nonempty(),
  call: Uk,
  multiplier: ke.number().nonnegative().optional(),
  sig: $f
}), j2 = ke.object({
  max_spent: ke.number().nonnegative(),
  signature: $f
}), Zm = ke.object({
  id: ke.string().nonempty(),
  meta: ke.object({
    user_id: ke.string().nonempty()
  }),
  auth: $f,
  offer: I2,
  params: ke.any().optional(),
  signed_transaction: j2.optional(),
  abort: ke.boolean().optional()
});
Zm.merge(
  ke.object({
    auth: $f
  })
);
const k2 = ke.object({
  input: ke.object({
    tokens: ke.number(),
    bytes: ke.number()
  }),
  output: ke.object({
    tokens: ke.number(),
    bytes: ke.number()
  })
}), Yy = ke.object({
  id: ke.string(),
  user_id: ke.string(),
  details: k2,
  total_bytes: ke.number(),
  total_tokens: ke.number(),
  offer: I2,
  sig: ke.string()
}), Ef = ke.object({
  request_id: ke.string().nonempty(),
  msg: ke.any().optional(),
  code: ke.string().optional(),
  data: ke.any().optional()
});
Ef.merge(
  ke.object({
    status: ke.literal("ready")
  })
);
Ef.merge(
  ke.object({
    status: ke.literal("data")
  })
);
Ef.merge(
  ke.object({
    receipt: Yy,
    costs: k2,
    status: ke.literal("complete")
  })
);
Ef.merge(
  ke.object({
    status: ke.literal("challenge"),
    data: ke.object({
      challenge: ke.string()
    })
  })
);
const Eu = ke.lazy(
  () => ke.object({
    type: ke.string(),
    properties: ke.union([ke.record(Eu), Eu]).optional(),
    required: ke.array(ke.string()).optional()
  })
), Bk = ke.object({
  summary: ke.string(),
  operationId: ke.string(),
  tags: ke.array(ke.string()).optional(),
  requestBody: ke.object({
    required: ke.boolean(),
    content: ke.record(
      ke.object({
        schema: Eu
      })
    ).optional()
  }),
  responses: ke.record(
    ke.object({
      description: ke.string(),
      content: ke.record(
        ke.object({
          schema: Eu
        })
      )
    })
  )
}), Ub = ke.object({
  id: ke.string().nonempty(),
  fns: ke.record(ke.any()),
  // TODO: specify this (tired of trying to make zod work with functions)
  schema: ke.object({
    info: ke.object({
      title: ke.string().optional().describe("filled in by the server"),
      description: ke.string().nonempty(),
      version: ke.string().nonempty()
    }),
    paths: ke.record(ke.record(Bk)),
    components: ke.object({ schemas: ke.record(Eu) }).optional()
  })
});
function ru(e) {
  if (!Number.isSafeInteger(e) || e < 0)
    throw new Error(`Wrong positive integer: ${e}`);
}
function M2(e, ...t) {
  if (!(e instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (t.length > 0 && !t.includes(e.length))
    throw new Error(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
function zm(e, t = !0) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function N2(e, t) {
  M2(e);
  const r = t.outputLen;
  if (e.length < r)
    throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
const Zc = /* @__PURE__ */ BigInt(2 ** 32 - 1), Bb = /* @__PURE__ */ BigInt(32);
function Vb(e, t = !1) {
  return t ? { h: Number(e & Zc), l: Number(e >> Bb & Zc) } : { h: Number(e >> Bb & Zc) | 0, l: Number(e & Zc) | 0 };
}
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Vk = (e) => e instanceof Uint8Array, Zk = (e) => new Uint8Array(e.buffer, e.byteOffset, e.byteLength), Wl = (e) => new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4)), Hl = (e, t) => e << 32 - t | e >>> t, zk = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!zk)
  throw new Error("Non little-endian hardware is not supported");
function Wk(e) {
  if (typeof e != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
  return new Uint8Array(new TextEncoder().encode(e));
}
function Jy(e) {
  if (typeof e == "string" && (e = Wk(e)), !Vk(e))
    throw new Error(`expected Uint8Array, got ${typeof e}`);
  return e;
}
class Hk {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
}
function Gk(e) {
  const t = (i, n) => e(n).update(Jy(i)).digest(), r = e({});
  return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = (i) => e(i), t;
}
class Kk extends Hk {
  constructor(t, r, i = {}, n, s, a) {
    if (super(), this.blockLen = t, this.outputLen = r, this.length = 0, this.pos = 0, this.finished = !1, this.destroyed = !1, ru(t), ru(r), ru(n), r < 0 || r > n)
      throw new Error("outputLen bigger than keyLen");
    if (i.key !== void 0 && (i.key.length < 1 || i.key.length > n))
      throw new Error(`key must be up 1..${n} byte long or undefined`);
    if (i.salt !== void 0 && i.salt.length !== s)
      throw new Error(`salt must be ${s} byte long or undefined`);
    if (i.personalization !== void 0 && i.personalization.length !== a)
      throw new Error(`personalization must be ${a} byte long or undefined`);
    this.buffer32 = Wl(this.buffer = new Uint8Array(t));
  }
  update(t) {
    zm(this);
    const { blockLen: r, buffer: i, buffer32: n } = this;
    t = Jy(t);
    const s = t.length, a = t.byteOffset, o = t.buffer;
    for (let c = 0; c < s; ) {
      this.pos === r && (this.compress(n, 0, !1), this.pos = 0);
      const l = Math.min(r - this.pos, s - c), d = a + c;
      if (l === r && !(d % 4) && c + l < s) {
        const p = new Uint32Array(o, d, Math.floor((s - c) / 4));
        for (let h = 0; c + r < s; h += n.length, c += r)
          this.length += r, this.compress(p, h, !1);
        continue;
      }
      i.set(t.subarray(c, c + l), this.pos), this.pos += l, this.length += l, c += l;
    }
    return this;
  }
  digestInto(t) {
    zm(this), N2(t, this);
    const { pos: r, buffer32: i } = this;
    this.finished = !0, this.buffer.subarray(r).fill(0), this.compress(i, 0, !0);
    const n = Wl(t);
    this.get().forEach((s, a) => n[a] = s);
  }
  digest() {
    const { buffer: t, outputLen: r } = this;
    this.digestInto(t);
    const i = t.slice(0, r);
    return this.destroy(), i;
  }
  _cloneInto(t) {
    const { buffer: r, length: i, finished: n, destroyed: s, outputLen: a, pos: o } = this;
    return t || (t = new this.constructor({ dkLen: a })), t.set(...this.get()), t.length = i, t.finished = n, t.destroyed = s, t.outputLen = a, t.buffer.set(r), t.pos = o, t;
  }
}
const pi = /* @__PURE__ */ new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]);
function Zi(e, t, r, i, n) {
  return e = e + t + n | 0, i = Hl(i ^ e, 16), r = r + i | 0, t = Hl(t ^ r, 12), { a: e, b: t, c: r, d: i };
}
function zi(e, t, r, i, n) {
  return e = e + t + n | 0, i = Hl(i ^ e, 8), r = r + i | 0, t = Hl(t ^ r, 7), { a: e, b: t, c: r, d: i };
}
function Zb(e, t, r, i, n, s, a, o, c, l, d, p, h, g, m, v, _, y, w, $) {
  let E = 0;
  for (let S = 0; S < i; S++)
    ({ a: n, b: c, c: h, d: _ } = Zi(n, c, h, _, r[t + e[E++]])), { a: n, b: c, c: h, d: _ } = zi(n, c, h, _, r[t + e[E++]]), { a: s, b: l, c: g, d: y } = Zi(s, l, g, y, r[t + e[E++]]), { a: s, b: l, c: g, d: y } = zi(s, l, g, y, r[t + e[E++]]), { a, b: d, c: m, d: w } = Zi(a, d, m, w, r[t + e[E++]]), { a, b: d, c: m, d: w } = zi(a, d, m, w, r[t + e[E++]]), { a: o, b: p, c: v, d: $ } = Zi(o, p, v, $, r[t + e[E++]]), { a: o, b: p, c: v, d: $ } = zi(o, p, v, $, r[t + e[E++]]), { a: n, b: l, c: m, d: $ } = Zi(n, l, m, $, r[t + e[E++]]), { a: n, b: l, c: m, d: $ } = zi(n, l, m, $, r[t + e[E++]]), { a: s, b: d, c: v, d: _ } = Zi(s, d, v, _, r[t + e[E++]]), { a: s, b: d, c: v, d: _ } = zi(s, d, v, _, r[t + e[E++]]), { a, b: p, c: h, d: y } = Zi(a, p, h, y, r[t + e[E++]]), { a, b: p, c: h, d: y } = zi(a, p, h, y, r[t + e[E++]]), { a: o, b: c, c: g, d: w } = Zi(o, c, g, w, r[t + e[E++]]), { a: o, b: c, c: g, d: w } = zi(o, c, g, w, r[t + e[E++]]);
  return { v0: n, v1: s, v2: a, v3: o, v4: c, v5: l, v6: d, v7: p, v8: h, v9: g, v10: m, v11: v, v12: _, v13: y, v14: w, v15: $ };
}
const zb = /* @__PURE__ */ (() => {
  const e = Array.from({ length: 16 }, (i, n) => n), t = (i) => [2, 6, 3, 10, 7, 0, 4, 13, 1, 11, 12, 5, 9, 14, 15, 8].map((n) => i[n]), r = [];
  for (let i = 0, n = e; i < 7; i++, n = t(n))
    r.push(...n);
  return Uint8Array.from(r);
})();
class Xy extends Kk {
  constructor(t = {}, r = 0) {
    if (super(64, t.dkLen === void 0 ? 32 : t.dkLen, {}, Number.MAX_SAFE_INTEGER, 0, 0), this.flags = 0, this.chunkPos = 0, this.chunksDone = 0, this.stack = [], this.posOut = 0, this.bufferOut32 = new Uint32Array(16), this.chunkOut = 0, this.enableXOF = !0, this.outputLen = t.dkLen === void 0 ? 32 : t.dkLen, ru(this.outputLen), t.key !== void 0 && t.context !== void 0)
      throw new Error("Blake3: only key or context can be specified at same time");
    if (t.key !== void 0) {
      const i = Jy(t.key).slice();
      if (i.length !== 32)
        throw new Error("Blake3: key should be 32 byte");
      this.IV = Wl(i), this.flags = r | 16;
    } else if (t.context !== void 0) {
      const i = new Xy(
        { dkLen: 32 },
        32
        /* Flags.DERIVE_KEY_CONTEXT */
      ).update(t.context).digest();
      this.IV = Wl(i), this.flags = r | 64;
    } else
      this.IV = pi.slice(), this.flags = r;
    this.state = this.IV.slice(), this.bufferOut = Zk(this.bufferOut32);
  }
  // Unused
  get() {
    return [];
  }
  set() {
  }
  b2Compress(t, r, i, n = 0) {
    const { state: s, pos: a } = this, { h: o, l: c } = Vb(BigInt(t), !0), { v0: l, v1: d, v2: p, v3: h, v4: g, v5: m, v6: v, v7: _, v8: y, v9: w, v10: $, v11: E, v12: S, v13: R, v14: j, v15: L } = Zb(zb, n, i, 7, s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7], pi[0], pi[1], pi[2], pi[3], o, c, a, r);
    s[0] = l ^ y, s[1] = d ^ w, s[2] = p ^ $, s[3] = h ^ E, s[4] = g ^ S, s[5] = m ^ R, s[6] = v ^ j, s[7] = _ ^ L;
  }
  compress(t, r = 0, i = !1) {
    let n = this.flags;
    if (this.chunkPos || (n |= 1), (this.chunkPos === 15 || i) && (n |= 2), i || (this.pos = this.blockLen), this.b2Compress(this.chunksDone, n, t, r), this.chunkPos += 1, this.chunkPos === 16 || i) {
      let s = this.state;
      this.state = this.IV.slice();
      for (let a, o = this.chunksDone + 1; (i || !(o & 1)) && (a = this.stack.pop()); o >>= 1)
        this.buffer32.set(a, 0), this.buffer32.set(s, 8), this.pos = this.blockLen, this.b2Compress(0, this.flags | 4, this.buffer32, 0), s = this.state, this.state = this.IV.slice();
      this.chunksDone++, this.chunkPos = 0, this.stack.push(s);
    }
    this.pos = 0;
  }
  _cloneInto(t) {
    t = super._cloneInto(t);
    const { IV: r, flags: i, state: n, chunkPos: s, posOut: a, chunkOut: o, stack: c, chunksDone: l } = this;
    return t.state.set(n.slice()), t.stack = c.map((d) => Uint32Array.from(d)), t.IV.set(r), t.flags = i, t.chunkPos = s, t.chunksDone = l, t.posOut = a, t.chunkOut = o, t.enableXOF = this.enableXOF, t.bufferOut32.set(this.bufferOut32), t;
  }
  destroy() {
    this.destroyed = !0, this.state.fill(0), this.buffer32.fill(0), this.IV.fill(0), this.bufferOut32.fill(0);
    for (let t of this.stack)
      t.fill(0);
  }
  // Same as b2Compress, but doesn't modify state and returns 16 u32 array (instead of 8)
  b2CompressOut() {
    const { state: t, pos: r, flags: i, buffer32: n, bufferOut32: s } = this, { h: a, l: o } = Vb(BigInt(this.chunkOut++)), { v0: c, v1: l, v2: d, v3: p, v4: h, v5: g, v6: m, v7: v, v8: _, v9: y, v10: w, v11: $, v12: E, v13: S, v14: R, v15: j } = Zb(zb, 0, n, 7, t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], pi[0], pi[1], pi[2], pi[3], o, a, r, i);
    s[0] = c ^ _, s[1] = l ^ y, s[2] = d ^ w, s[3] = p ^ $, s[4] = h ^ E, s[5] = g ^ S, s[6] = m ^ R, s[7] = v ^ j, s[8] = t[0] ^ _, s[9] = t[1] ^ y, s[10] = t[2] ^ w, s[11] = t[3] ^ $, s[12] = t[4] ^ E, s[13] = t[5] ^ S, s[14] = t[6] ^ R, s[15] = t[7] ^ j, this.posOut = 0;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0, this.buffer.fill(0, this.pos);
    let t = this.flags | 8;
    this.stack.length ? (t |= 4, this.compress(this.buffer32, 0, !0), this.chunksDone = 0, this.pos = this.blockLen) : t |= (this.chunkPos ? 0 : 1) | 2, this.flags = t, this.b2CompressOut();
  }
  writeInto(t) {
    zm(this, !1), M2(t), this.finish();
    const { blockLen: r, bufferOut: i } = this;
    for (let n = 0, s = t.length; n < s; ) {
      this.posOut >= r && this.b2CompressOut();
      const a = Math.min(r - this.posOut, s - n);
      t.set(i.subarray(this.posOut, this.posOut + a), n), this.posOut += a, n += a;
    }
    return t;
  }
  xofInto(t) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible after digest call");
    return this.writeInto(t);
  }
  xof(t) {
    return ru(t), this.xofInto(new Uint8Array(t));
  }
  digestInto(t) {
    if (N2(t, this), this.finished)
      throw new Error("digest() was already called");
    return this.enableXOF = !1, this.writeInto(t), this.destroy(), t;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
}
const Yk = /* @__PURE__ */ Gk((e) => new Xy(e));
var tt = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Ks(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function xf(e) {
  if (e.__esModule)
    return e;
  var t = e.default;
  if (typeof t == "function") {
    var r = function i() {
      return this instanceof i ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    r.prototype = t.prototype;
  } else
    r = {};
  return Object.defineProperty(r, "__esModule", { value: !0 }), Object.keys(e).forEach(function(i) {
    var n = Object.getOwnPropertyDescriptor(e, i);
    Object.defineProperty(r, i, n.get ? n : {
      enumerable: !0,
      get: function() {
        return e[i];
      }
    });
  }), r;
}
var Wm = { exports: {} };
function D2(e) {
  return e.length;
}
function Jk(e) {
  const t = e.byteLength;
  let r = "";
  for (let i = 0; i < t; i++)
    r += String.fromCharCode(e[i]);
  return r;
}
function Xk(e, t, r = 0, i = D2(t)) {
  const n = Math.min(i, e.byteLength - r);
  for (let s = 0; s < n; s++)
    e[r + s] = t.charCodeAt(s);
  return n;
}
var Qk = {
  byteLength: D2,
  toString: Jk,
  write: Xk
};
const ka = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", Ds = new Uint8Array(256);
for (let e = 0; e < ka.length; e++)
  Ds[ka.charCodeAt(e)] = e;
Ds[
  /* - */
  45
] = 62;
Ds[
  /* _ */
  95
] = 63;
function L2(e) {
  let t = e.length;
  return e.charCodeAt(t - 1) === 61 && t--, t > 1 && e.charCodeAt(t - 1) === 61 && t--, t * 3 >>> 2;
}
function e3(e) {
  const t = e.byteLength;
  let r = "";
  for (let i = 0; i < t; i += 3)
    r += ka[e[i] >> 2] + ka[(e[i] & 3) << 4 | e[i + 1] >> 4] + ka[(e[i + 1] & 15) << 2 | e[i + 2] >> 6] + ka[e[i + 2] & 63];
  return t % 3 === 2 ? r = r.substring(0, r.length - 1) + "=" : t % 3 === 1 && (r = r.substring(0, r.length - 2) + "=="), r;
}
function t3(e, t, r = 0, i = L2(t)) {
  const n = Math.min(i, e.byteLength - r);
  for (let s = 0, a = 0; a < n; s += 4) {
    const o = Ds[t.charCodeAt(s)], c = Ds[t.charCodeAt(s + 1)], l = Ds[t.charCodeAt(s + 2)], d = Ds[t.charCodeAt(s + 3)];
    e[a++] = o << 2 | c >> 4, e[a++] = (c & 15) << 4 | l >> 2, e[a++] = (l & 3) << 6 | d & 63;
  }
  return n;
}
var r3 = {
  byteLength: L2,
  toString: e3,
  write: t3
};
function q2(e) {
  return e.length >>> 1;
}
function n3(e) {
  const t = e.byteLength;
  e = new DataView(e.buffer, e.byteOffset, t);
  let r = "", i = 0;
  for (let n = t - t % 4; i < n; i += 4)
    r += e.getUint32(i).toString(16).padStart(8, "0");
  for (; i < t; i++)
    r += e.getUint8(i).toString(16).padStart(2, "0");
  return r;
}
function i3(e, t, r = 0, i = q2(t)) {
  const n = Math.min(i, e.byteLength - r);
  for (let s = 0; s < n; s++) {
    const a = Wb(t.charCodeAt(s * 2)), o = Wb(t.charCodeAt(s * 2 + 1));
    if (a === void 0 || o === void 0)
      return e.subarray(0, s);
    e[r + s] = a << 4 | o;
  }
  return n;
}
var s3 = {
  byteLength: q2,
  toString: n3,
  write: i3
};
function Wb(e) {
  if (e >= 48 && e <= 57)
    return e - 48;
  if (e >= 65 && e <= 70)
    return e - 65 + 10;
  if (e >= 97 && e <= 102)
    return e - 97 + 10;
}
function Hm(e) {
  let t = 0;
  for (let r = 0, i = e.length; r < i; r++) {
    const n = e.charCodeAt(r);
    if (n >= 55296 && n <= 56319 && r + 1 < i) {
      const s = e.charCodeAt(r + 1);
      if (s >= 56320 && s <= 57343) {
        t += 4, r++;
        continue;
      }
    }
    n <= 127 ? t += 1 : n <= 2047 ? t += 2 : t += 3;
  }
  return t;
}
let Gm;
if (typeof TextDecoder < "u") {
  const e = new TextDecoder();
  Gm = function(r) {
    return e.decode(r);
  };
} else
  Gm = function(t) {
    const r = t.byteLength;
    let i = "", n = 0;
    for (; n < r; ) {
      let s = t[n];
      if (s <= 127) {
        i += String.fromCharCode(s), n++;
        continue;
      }
      let a = 0, o = 0;
      if (s <= 223 ? (a = 1, o = s & 31) : s <= 239 ? (a = 2, o = s & 15) : s <= 244 && (a = 3, o = s & 7), r - n - a > 0) {
        let c = 0;
        for (; c < a; )
          s = t[n + c + 1], o = o << 6 | s & 63, c += 1;
      } else
        o = 65533, a = r - n;
      i += String.fromCodePoint(o), n += a + 1;
    }
    return i;
  };
let Km;
if (typeof TextEncoder < "u") {
  const e = new TextEncoder();
  Km = function(r, i, n = 0, s = Hm(i)) {
    const a = Math.min(s, r.byteLength - n);
    return e.encodeInto(i, r.subarray(n, n + a)), a;
  };
} else
  Km = function(t, r, i = 0, n = Hm(r)) {
    const s = Math.min(n, t.byteLength - i);
    t = t.subarray(i, i + s);
    let a = 0, o = 0;
    for (; a < r.length; ) {
      const c = r.codePointAt(a);
      if (c <= 127) {
        t[o++] = c, a++;
        continue;
      }
      let l = 0, d = 0;
      for (c <= 2047 ? (l = 6, d = 192) : c <= 65535 ? (l = 12, d = 224) : c <= 2097151 && (l = 18, d = 240), t[o++] = d | c >> l, l -= 6; l >= 0; )
        t[o++] = 128 | c >> l & 63, l -= 6;
      a += c >= 65536 ? 2 : 1;
    }
    return s;
  };
var a3 = {
  byteLength: Hm,
  toString: Gm,
  write: Km
};
function F2(e) {
  return e.length * 2;
}
function o3(e) {
  const t = e.byteLength;
  let r = "";
  for (let i = 0; i < t - 1; i += 2)
    r += String.fromCharCode(e[i] + e[i + 1] * 256);
  return r;
}
function u3(e, t, r = 0, i = F2(t)) {
  const n = Math.min(i, e.byteLength - r);
  let s = n;
  for (let a = 0; a < t.length && !((s -= 2) < 0); ++a) {
    const o = t.charCodeAt(a), c = o >> 8, l = o % 256;
    e[r + a * 2] = l, e[r + a * 2 + 1] = c;
  }
  return n;
}
var c3 = {
  byteLength: F2,
  toString: o3,
  write: u3
};
(function(e, t) {
  const r = Qk, i = r3, n = s3, s = a3, a = c3, o = new Uint8Array(Uint16Array.of(255).buffer)[0] === 255;
  function c(k) {
    switch (k) {
      case "ascii":
        return r;
      case "base64":
        return i;
      case "hex":
        return n;
      case "utf8":
      case "utf-8":
      case void 0:
        return s;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return a;
      default:
        throw new Error(`Unknown encoding: ${k}`);
    }
  }
  function l(k) {
    return k instanceof Uint8Array;
  }
  function d(k) {
    try {
      return c(k), !0;
    } catch {
      return !1;
    }
  }
  function p(k, Z, J) {
    const A = new Uint8Array(k);
    return Z !== void 0 && t.fill(A, Z, 0, A.byteLength, J), A;
  }
  function h(k) {
    return new Uint8Array(k);
  }
  function g(k) {
    return new Uint8Array(k);
  }
  function m(k, Z) {
    return c(Z).byteLength(k);
  }
  function v(k, Z) {
    if (k === Z)
      return 0;
    const J = Math.min(k.byteLength, Z.byteLength);
    k = new DataView(k.buffer, k.byteOffset, k.byteLength), Z = new DataView(Z.buffer, Z.byteOffset, Z.byteLength);
    let A = 0;
    for (let I = J - J % 4; A < I; A += 4) {
      const X = k.getUint32(A, o), oe = Z.getUint32(A, o);
      if (X !== oe)
        break;
    }
    for (; A < J; A++) {
      const I = k.getUint8(A), X = Z.getUint8(A);
      if (I < X)
        return -1;
      if (I > X)
        return 1;
    }
    return k.byteLength > Z.byteLength ? 1 : k.byteLength < Z.byteLength ? -1 : 0;
  }
  function _(k, Z) {
    Z === void 0 && (Z = k.reduce((I, X) => I + X.byteLength, 0));
    const J = new Uint8Array(Z);
    let A = 0;
    for (const I of k) {
      if (A + I.byteLength > J.byteLength) {
        const X = I.subarray(0, J.byteLength - A);
        return J.set(X, A), J;
      }
      J.set(I, A), A += I.byteLength;
    }
    return J;
  }
  function y(k, Z, J = 0, A = 0, I = k.byteLength) {
    if (I > 0 && I < A || I === A || k.byteLength === 0 || Z.byteLength === 0)
      return 0;
    if (J < 0)
      throw new RangeError("targetStart is out of range");
    if (A < 0 || A >= k.byteLength)
      throw new RangeError("sourceStart is out of range");
    if (I < 0)
      throw new RangeError("sourceEnd is out of range");
    J >= Z.byteLength && (J = Z.byteLength), I > k.byteLength && (I = k.byteLength), Z.byteLength - J < I - A && (I = Z.length - J + A);
    const X = I - A;
    return k === Z ? Z.copyWithin(J, A, I) : Z.set(k.subarray(A, I), J), X;
  }
  function w(k, Z) {
    if (k === Z)
      return !0;
    if (k.byteLength !== Z.byteLength)
      return !1;
    const J = k.byteLength;
    k = new DataView(k.buffer, k.byteOffset, k.byteLength), Z = new DataView(Z.buffer, Z.byteOffset, Z.byteLength);
    let A = 0;
    for (let I = J - J % 4; A < I; A += 4)
      if (k.getUint32(A, o) !== Z.getUint32(A, o))
        return !1;
    for (; A < J; A++)
      if (k.getUint8(A) !== Z.getUint8(A))
        return !1;
    return !0;
  }
  function $(k, Z, J, A, I) {
    if (typeof Z == "string" ? typeof J == "string" ? (I = J, J = 0, A = k.byteLength) : typeof A == "string" && (I = A, A = k.byteLength) : typeof Z == "number" ? Z = Z & 255 : typeof Z == "boolean" && (Z = +Z), J < 0 || k.byteLength < J || k.byteLength < A)
      throw new RangeError("Out of range index");
    if (J === void 0 && (J = 0), A === void 0 && (A = k.byteLength), A <= J)
      return k;
    if (Z || (Z = 0), typeof Z == "number")
      for (let X = J; X < A; ++X)
        k[X] = Z;
    else {
      Z = l(Z) ? Z : E(Z, I);
      const X = Z.byteLength;
      for (let oe = 0; oe < A - J; ++oe)
        k[oe + J] = Z[oe % X];
    }
    return k;
  }
  function E(k, Z, J) {
    return typeof k == "string" ? S(k, Z) : Array.isArray(k) ? R(k) : ArrayBuffer.isView(k) ? j(k) : L(k, Z, J);
  }
  function S(k, Z) {
    const J = c(Z), A = new Uint8Array(J.byteLength(k));
    return J.write(A, k, 0, A.byteLength), A;
  }
  function R(k) {
    const Z = new Uint8Array(k.length);
    return Z.set(k), Z;
  }
  function j(k) {
    const Z = new Uint8Array(k.byteLength);
    return Z.set(k), Z;
  }
  function L(k, Z, J) {
    return new Uint8Array(k, Z, J);
  }
  function K(k, Z, J, A) {
    return ye(k, Z, J, A) !== -1;
  }
  function ae(k, Z, J, A, I) {
    if (k.byteLength === 0)
      return -1;
    if (typeof J == "string" ? (A = J, J = 0) : J === void 0 ? J = I ? 0 : k.length - 1 : J < 0 && (J += k.byteLength), J >= k.byteLength) {
      if (I)
        return -1;
      J = k.byteLength - 1;
    } else if (J < 0)
      if (I)
        J = 0;
      else
        return -1;
    if (typeof Z == "string")
      Z = E(Z, A);
    else if (typeof Z == "number")
      return Z = Z & 255, I ? k.indexOf(Z, J) : k.lastIndexOf(Z, J);
    if (Z.byteLength === 0)
      return -1;
    if (I) {
      let X = -1;
      for (let oe = J; oe < k.byteLength; oe++)
        if (k[oe] === Z[X === -1 ? 0 : oe - X]) {
          if (X === -1 && (X = oe), oe - X + 1 === Z.byteLength)
            return X;
        } else
          X !== -1 && (oe -= oe - X), X = -1;
    } else {
      J + Z.byteLength > k.byteLength && (J = k.byteLength - Z.byteLength);
      for (let X = J; X >= 0; X--) {
        let oe = !0;
        for (let Ae = 0; Ae < Z.byteLength; Ae++)
          if (k[X + Ae] !== Z[Ae]) {
            oe = !1;
            break;
          }
        if (oe)
          return X;
      }
    }
    return -1;
  }
  function ye(k, Z, J, A) {
    return ae(
      k,
      Z,
      J,
      A,
      !0
      /* first */
    );
  }
  function xe(k, Z, J, A) {
    return ae(
      k,
      Z,
      J,
      A,
      !1
      /* last */
    );
  }
  function Pe(k, Z, J) {
    const A = k[Z];
    k[Z] = k[J], k[J] = A;
  }
  function te(k) {
    const Z = k.byteLength;
    if (Z % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let J = 0; J < Z; J += 2)
      Pe(k, J, J + 1);
    return k;
  }
  function pe(k) {
    const Z = k.byteLength;
    if (Z % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let J = 0; J < Z; J += 4)
      Pe(k, J, J + 3), Pe(k, J + 1, J + 2);
    return k;
  }
  function de(k) {
    const Z = k.byteLength;
    if (Z % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let J = 0; J < Z; J += 8)
      Pe(k, J, J + 7), Pe(k, J + 1, J + 6), Pe(k, J + 2, J + 5), Pe(k, J + 3, J + 4);
    return k;
  }
  function Ee(k) {
    return k;
  }
  function Re(k, Z, J = 0, A = k.byteLength) {
    const I = k.byteLength;
    return J >= I || A <= J ? "" : (J < 0 && (J = 0), A > I && (A = I), (J !== 0 || A < I) && (k = k.subarray(J, A)), c(Z).toString(k));
  }
  function _e(k, Z, J, A, I) {
    return J === void 0 ? I = "utf8" : A === void 0 && typeof J == "string" ? (I = J, J = void 0) : I === void 0 && typeof A == "string" && (I = A, A = void 0), c(I).write(k, Z, J, A);
  }
  function ie(k, Z, J) {
    return J === void 0 && (J = 0), new DataView(k.buffer, k.byteOffset, k.byteLength).setFloat64(J, Z, !0), J + 8;
  }
  function Y(k, Z, J) {
    return J === void 0 && (J = 0), new DataView(k.buffer, k.byteOffset, k.byteLength).setFloat32(J, Z, !0), J + 4;
  }
  function V(k, Z, J) {
    return J === void 0 && (J = 0), new DataView(k.buffer, k.byteOffset, k.byteLength).setUint32(J, Z, !0), J + 4;
  }
  function z(k, Z, J) {
    return J === void 0 && (J = 0), new DataView(k.buffer, k.byteOffset, k.byteLength).setInt32(J, Z, !0), J + 4;
  }
  function T(k, Z) {
    return Z === void 0 && (Z = 0), new DataView(k.buffer, k.byteOffset, k.byteLength).getFloat64(Z, !0);
  }
  function F(k, Z) {
    return Z === void 0 && (Z = 0), new DataView(k.buffer, k.byteOffset, k.byteLength).getFloat32(Z, !0);
  }
  function D(k, Z) {
    return Z === void 0 && (Z = 0), new DataView(k.buffer, k.byteOffset, k.byteLength).getUint32(Z, !0);
  }
  function U(k, Z) {
    return Z === void 0 && (Z = 0), new DataView(k.buffer, k.byteOffset, k.byteLength).getInt32(Z, !0);
  }
  e.exports = t = {
    isBuffer: l,
    isEncoding: d,
    alloc: p,
    allocUnsafe: h,
    allocUnsafeSlow: g,
    byteLength: m,
    compare: v,
    concat: _,
    copy: y,
    equals: w,
    fill: $,
    from: E,
    includes: K,
    indexOf: ye,
    lastIndexOf: xe,
    swap16: te,
    swap32: pe,
    swap64: de,
    toBuffer: Ee,
    toString: Re,
    write: _e,
    writeDoubleLE: ie,
    writeFloatLE: Y,
    writeUInt32LE: V,
    writeInt32LE: z,
    readDoubleLE: T,
    readFloatLE: F,
    readUInt32LE: D,
    readInt32LE: U
  };
})(Wm, Wm.exports);
var l3 = Wm.exports;
const dn = /* @__PURE__ */ Ks(l3);
/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
const Qy = 2n ** 256n, ts = Qy - 0x1000003d1n, ur = Qy - 0x14551231950b75fc4402da1732fc9bebfn, U2 = 0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798n, B2 = 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8n, V2 = { p: ts, n: ur, a: 0n, b: 7n, Gx: U2, Gy: B2 }, xr = 32, Hb = (e) => Ze(Ze(e * e) * e + V2.b), Ft = (e = "") => {
  throw new Error(e);
}, Of = (e) => typeof e == "bigint", Z2 = (e) => typeof e == "string", vp = (e) => Of(e) && 0n < e && e < ts, xu = (e) => Of(e) && 0n < e && e < ur, z2 = (e, t) => (
  // is Uint8Array (of specific length)
  !(e instanceof Uint8Array) || typeof t == "number" && t > 0 && e.length !== t ? Ft("Uint8Array expected") : e
), Jr = (e) => new Uint8Array(e), Oi = (e, t) => z2(Z2(e) ? qu(e) : Jr(e), t), Ze = (e, t = ts) => {
  let r = e % t;
  return r >= 0n ? r : t + r;
}, Gb = (e) => e instanceof Er ? e : Ft("Point expected");
let Kb;
class Er {
  constructor(t, r, i) {
    this.px = t, this.py = r, this.pz = i;
  }
  //3d=less inversions
  static fromAffine(t) {
    return new Er(t.x, t.y, 1n);
  }
  static fromHex(t) {
    t = Oi(t);
    let r;
    const i = t[0], n = t.subarray(1), s = Gl(n, 0, xr), a = t.length;
    if (a === 33 && [2, 3].includes(i)) {
      vp(s) || Ft("Point hex invalid: x not FE");
      let o = f3(Hb(s));
      const c = (o & 1n) === 1n;
      (i & 1) === 1 !== c && (o = Ze(-o)), r = new Er(s, o, 1n);
    }
    return a === 65 && i === 4 && (r = new Er(s, Gl(n, xr, 2 * xr), 1n)), r ? r.ok() : Ft("Point is not on curve");
  }
  static fromPrivateKey(t) {
    return wi.mul(Kl(t));
  }
  // Create point from a private key.
  get x() {
    return this.aff().x;
  }
  // .x, .y will call expensive toAffine:
  get y() {
    return this.aff().y;
  }
  // should be used with care.
  equals(t) {
    const { px: r, py: i, pz: n } = this, { px: s, py: a, pz: o } = Gb(t), c = Ze(r * o), l = Ze(s * n), d = Ze(i * o), p = Ze(a * n);
    return c === l && d === p;
  }
  negate() {
    return new Er(this.px, Ze(-this.py), this.pz);
  }
  // Flip point over y coord
  double() {
    return this.add(this);
  }
  // Point doubling: P+P, complete formula.
  add(t) {
    const { px: r, py: i, pz: n } = this, { px: s, py: a, pz: o } = Gb(t), { a: c, b: l } = V2;
    let d = 0n, p = 0n, h = 0n;
    const g = Ze(l * 3n);
    let m = Ze(r * s), v = Ze(i * a), _ = Ze(n * o), y = Ze(r + i), w = Ze(s + a);
    y = Ze(y * w), w = Ze(m + v), y = Ze(y - w), w = Ze(r + n);
    let $ = Ze(s + o);
    return w = Ze(w * $), $ = Ze(m + _), w = Ze(w - $), $ = Ze(i + n), d = Ze(a + o), $ = Ze($ * d), d = Ze(v + _), $ = Ze($ - d), h = Ze(c * w), d = Ze(g * _), h = Ze(d + h), d = Ze(v - h), h = Ze(v + h), p = Ze(d * h), v = Ze(m + m), v = Ze(v + m), _ = Ze(c * _), w = Ze(g * w), v = Ze(v + _), _ = Ze(m - _), _ = Ze(c * _), w = Ze(w + _), m = Ze(v * w), p = Ze(p + m), m = Ze($ * w), d = Ze(y * d), d = Ze(d - m), m = Ze(y * v), h = Ze($ * h), h = Ze(h + m), new Er(d, p, h);
  }
  mul(t, r = !0) {
    if (!r && t === 0n)
      return ml;
    if (xu(t) || Ft("invalid scalar"), this.equals(wi))
      return b3(t).p;
    let i = ml, n = wi;
    for (let s = this; t > 0n; s = s.double(), t >>= 1n)
      t & 1n ? i = i.add(s) : r && (n = n.add(s));
    return i;
  }
  mulAddQUns(t, r, i) {
    return this.mul(r, !1).add(t.mul(i, !1)).ok();
  }
  // to private keys. Doesn't use Shamir trick
  toAffine() {
    const { px: t, py: r, pz: i } = this;
    if (this.equals(ml))
      return { x: 0n, y: 0n };
    if (i === 1n)
      return { x: t, y: r };
    const n = Uu(i);
    return Ze(i * n) !== 1n && Ft("invalid inverse"), { x: Ze(t * n), y: Ze(r * n) };
  }
  assertValidity() {
    const { x: t, y: r } = this.aff();
    return (!vp(t) || !vp(r)) && Ft("Point invalid: x or y"), Ze(r * r) === Hb(t) ? (
      // y = x + ax + b, must be equal
      this
    ) : Ft("Point invalid: not on curve");
  }
  multiply(t) {
    return this.mul(t);
  }
  // Aliases to compress code
  aff() {
    return this.toAffine();
  }
  ok() {
    return this.assertValidity();
  }
  toHex(t = !0) {
    const { x: r, y: i } = this.aff();
    return (t ? (i & 1n) === 0n ? "02" : "03" : "04") + nu(r) + (t ? "" : nu(i));
  }
  toRawBytes(t = !0) {
    return qu(this.toHex(t));
  }
}
Er.BASE = new Er(U2, B2, 1n);
Er.ZERO = new Er(0n, 1n, 0n);
const { BASE: wi, ZERO: ml } = Er, W2 = (e, t) => e.toString(16).padStart(t, "0"), eg = (e) => Array.from(e).map((t) => W2(t, 2)).join(""), qu = (e) => {
  const t = e.length;
  (!Z2(e) || t % 2) && Ft("hex invalid 1");
  const r = Jr(t / 2);
  for (let i = 0; i < r.length; i++) {
    const n = i * 2, s = e.slice(n, n + 2), a = Number.parseInt(s, 16);
    (Number.isNaN(a) || a < 0) && Ft("hex invalid 2"), r[i] = a;
  }
  return r;
}, Fu = (e) => BigInt("0x" + (eg(e) || "0")), Gl = (e, t, r) => Fu(e.slice(t, r)), Pf = (e) => Of(e) && e >= 0n && e < Qy ? qu(W2(e, 2 * xr)) : Ft("bigint expected"), nu = (e) => eg(Pf(e)), Ym = (...e) => {
  const t = Jr(e.reduce((i, n) => i + z2(n).length, 0));
  let r = 0;
  return e.forEach((i) => {
    t.set(i, r), r += i.length;
  }), t;
}, Uu = (e, t = ts) => {
  (e === 0n || t <= 0n) && Ft("no inverse n=" + e + " mod=" + t);
  let r = Ze(e, t), i = t, n = 0n, s = 1n;
  for (; r !== 0n; ) {
    const a = i / r, o = i % r, c = n - s * a;
    i = r, r = o, n = s, s = c;
  }
  return i === 1n ? Ze(n, t) : Ft("no inverse");
}, f3 = (e) => {
  let t = 1n;
  for (let r = e, i = (ts + 1n) / 4n; i > 0n; i >>= 1n)
    i & 1n && (t = t * r % ts), r = r * r % ts;
  return Ze(t * t) === e ? t : Ft("sqrt invalid");
}, Kl = (e) => (Of(e) || (e = Fu(Oi(e, xr))), xu(e) ? e : Ft("private key out of range")), tg = (e) => e > ur >> 1n;
function H2(e, t = !0) {
  return Er.fromPrivateKey(e).toRawBytes(t);
}
class Ya {
  constructor(t, r, i) {
    this.r = t, this.s = r, this.recovery = i, this.assertValidity();
  }
  // constructed outside.
  static fromCompact(t) {
    return t = Oi(t, 64), new Ya(Gl(t, 0, xr), Gl(t, xr, 2 * xr));
  }
  assertValidity() {
    return xu(this.r) && xu(this.s) ? this : Ft();
  }
  // 0 < r or s < CURVE.n
  addRecoveryBit(t) {
    return new Ya(this.r, this.s, t);
  }
  hasHighS() {
    return tg(this.s);
  }
  recoverPublicKey(t) {
    const { r, s: i, recovery: n } = this;
    [0, 1, 2, 3].includes(n) || Ft("recovery id invalid");
    const s = rg(Oi(t, 32)), a = n === 2 || n === 3 ? r + ur : r;
    a >= ts && Ft("q.x invalid");
    const o = n & 1 ? "03" : "02", c = Er.fromHex(o + nu(a)), l = Uu(a, ur), d = Ze(-s * l, ur), p = Ze(i * l, ur);
    return wi.mulAddQUns(c, d, p);
  }
  toCompactRawBytes() {
    return qu(this.toCompactHex());
  }
  // Uint8Array 64b compact repr
  toCompactHex() {
    return nu(this.r) + nu(this.s);
  }
  // hex 64b compact repr
}
const G2 = (e) => {
  const t = e.length * 8 - 256, r = Fu(e);
  return t > 0 ? r >> BigInt(t) : r;
}, rg = (e) => Ze(G2(e), ur), Yb = (e) => Pf(e), Jb = () => (
  // We support: 1) browsers 2) node.js 19+ 3) deno, other envs with crypto
  typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0
);
let iu;
const K2 = { lowS: !0 }, d3 = { lowS: !0 };
function p3(e, t, r = K2) {
  ["der", "recovered", "canonical"].some((p) => p in r) && Ft("sign() legacy options not supported");
  let { lowS: i } = r;
  i == null && (i = !0);
  const n = rg(Oi(e)), s = Yb(n), a = Kl(t), o = [Yb(a), s];
  let c = r.extraEntropy;
  if (c) {
    c === !0 && (c = Sf.randomBytes(xr));
    const p = Oi(c);
    p.length !== xr && Ft(), o.push(p);
  }
  const l = n, d = (p) => {
    const h = G2(p);
    if (!xu(h))
      return;
    const g = Uu(h, ur), m = wi.mul(h).aff(), v = Ze(m.x, ur);
    if (v === 0n)
      return;
    const _ = Ze(g * Ze(l + Ze(a * v, ur), ur), ur);
    if (_ === 0n)
      return;
    let y = _, w = (m.x === v ? 0 : 2) | Number(m.y & 1n);
    return i && tg(_) && (y = Ze(-_, ur), w ^= 1), new Ya(v, y, w);
  };
  return { seed: Ym(...o), k2sig: d };
}
function h3(e) {
  let t = Jr(xr), r = Jr(xr), i = 0;
  const n = () => {
    t.fill(1), r.fill(0), i = 0;
  }, s = "drbg: tried 1000 values";
  if (e) {
    const a = (...l) => Sf.hmacSha256Async(r, t, ...l), o = async (l = Jr()) => {
      r = await a(Jr([0]), l), t = await a(), l.length !== 0 && (r = await a(Jr([1]), l), t = await a());
    }, c = async () => (i++ >= 1e3 && Ft(s), t = await a(), t);
    return async (l, d) => {
      n(), await o(l);
      let p;
      for (; !(p = d(await c())); )
        await o();
      return n(), p;
    };
  } else {
    const a = (...l) => {
      const d = iu;
      return d || Ft("etc.hmacSha256Sync not set"), d(r, t, ...l);
    }, o = (l = Jr()) => {
      r = a(Jr([0]), l), t = a(), l.length !== 0 && (r = a(Jr([1]), l), t = a());
    }, c = () => (i++ >= 1e3 && Ft(s), t = a(), t);
    return (l, d) => {
      n(), o(l);
      let p;
      for (; !(p = d(c())); )
        o();
      return n(), p;
    };
  }
}
async function m3(e, t, r = K2) {
  const { seed: i, k2sig: n } = p3(e, t, r);
  return h3(!0)(i, n);
}
function y3(e, t, r, i = d3) {
  let { lowS: n } = i;
  n == null && (n = !0), "strict" in i && Ft("verify() legacy options not supported");
  let s, a, o;
  const c = e && typeof e == "object" && "r" in e;
  !c && Oi(e).length !== 2 * xr && Ft("signature must be 64 bytes");
  try {
    s = c ? new Ya(e.r, e.s).assertValidity() : Ya.fromCompact(e), a = rg(Oi(t, xr)), o = r instanceof Er ? r.ok() : Er.fromHex(r);
  } catch {
    return !1;
  }
  if (!s)
    return !1;
  const { r: l, s: d } = s;
  if (n && tg(d))
    return !1;
  let p;
  try {
    const g = Uu(d, ur), m = Ze(a * g, ur), v = Ze(l * g, ur);
    p = wi.mulAddQUns(o, m, v).aff();
  } catch {
    return !1;
  }
  return p ? Ze(p.x, ur) === l : !1;
}
function Y2(e) {
  e = Oi(e);
  const t = xr + 8;
  (e.length < t || e.length > 1024) && Ft("expected proper params");
  const r = Ze(Fu(e), ur - 1n) + 1n;
  return Pf(r);
}
const Sf = {
  hexToBytes: qu,
  bytesToHex: eg,
  concatBytes: Ym,
  bytesToNumberBE: Fu,
  numberToBytesBE: Pf,
  mod: Ze,
  invert: Uu,
  hmacSha256Async: async (e, ...t) => {
    const r = Jb();
    if (!r)
      return Ft("etc.hmacSha256Async not set");
    const i = r.subtle, n = await i.importKey("raw", e, { name: "HMAC", hash: { name: "SHA-256" } }, !1, ["sign"]);
    return Jr(await i.sign("HMAC", n, Ym(...t)));
  },
  hmacSha256Sync: iu,
  hashToPrivateKey: Y2,
  randomBytes: (e) => {
    const t = Jb();
    return t || Ft("crypto.getRandomValues must be defined"), t.getRandomValues(Jr(e));
  }
}, g3 = {
  normPrivateKeyToScalar: Kl,
  isValidPrivateKey: (e) => {
    try {
      return !!Kl(e);
    } catch {
      return !1;
    }
  },
  randomPrivateKey: () => Y2(Sf.randomBytes(xr + 8)),
  precompute(e = 8, t = wi) {
    return t.multiply(3n), t;
  }
  // no-op
};
Object.defineProperties(Sf, { hmacSha256Sync: {
  configurable: !1,
  get() {
    return iu;
  },
  set(e) {
    iu || (iu = e);
  }
} });
const Is = 8, v3 = () => {
  const e = [], t = 256 / Is + 1;
  let r = wi, i = r;
  for (let n = 0; n < t; n++) {
    i = r, e.push(i);
    for (let s = 1; s < 2 ** (Is - 1); s++)
      i = i.add(r), e.push(i);
    r = i.double();
  }
  return e;
}, b3 = (e) => {
  const t = Kb || (Kb = v3()), r = (d, p) => {
    let h = p.negate();
    return d ? h : p;
  };
  let i = ml, n = wi;
  const s = 1 + 256 / Is, a = 2 ** (Is - 1), o = BigInt(2 ** Is - 1), c = 2 ** Is, l = BigInt(Is);
  for (let d = 0; d < s; d++) {
    const p = d * a;
    let h = Number(e & o);
    e >>= l, h > a && (h -= c, e += 1n);
    const g = p, m = p + Math.abs(h) - 1, v = d % 2 !== 0, _ = h < 0;
    h === 0 ? n = n.add(r(v, t[g])) : i = i.add(r(_, t[m]));
  }
  return { p: i, f: n };
};
var qe = {}, ro = {}, Af = {};
Af.byteLength = $3;
Af.toByteArray = x3;
Af.fromByteArray = S3;
var Wn = [], cn = [], _3 = typeof Uint8Array < "u" ? Uint8Array : Array, bp = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var wa = 0, w3 = bp.length; wa < w3; ++wa)
  Wn[wa] = bp[wa], cn[bp.charCodeAt(wa)] = wa;
cn["-".charCodeAt(0)] = 62;
cn["_".charCodeAt(0)] = 63;
function J2(e) {
  var t = e.length;
  if (t % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var r = e.indexOf("=");
  r === -1 && (r = t);
  var i = r === t ? 0 : 4 - r % 4;
  return [r, i];
}
function $3(e) {
  var t = J2(e), r = t[0], i = t[1];
  return (r + i) * 3 / 4 - i;
}
function E3(e, t, r) {
  return (t + r) * 3 / 4 - r;
}
function x3(e) {
  var t, r = J2(e), i = r[0], n = r[1], s = new _3(E3(e, i, n)), a = 0, o = n > 0 ? i - 4 : i, c;
  for (c = 0; c < o; c += 4)
    t = cn[e.charCodeAt(c)] << 18 | cn[e.charCodeAt(c + 1)] << 12 | cn[e.charCodeAt(c + 2)] << 6 | cn[e.charCodeAt(c + 3)], s[a++] = t >> 16 & 255, s[a++] = t >> 8 & 255, s[a++] = t & 255;
  return n === 2 && (t = cn[e.charCodeAt(c)] << 2 | cn[e.charCodeAt(c + 1)] >> 4, s[a++] = t & 255), n === 1 && (t = cn[e.charCodeAt(c)] << 10 | cn[e.charCodeAt(c + 1)] << 4 | cn[e.charCodeAt(c + 2)] >> 2, s[a++] = t >> 8 & 255, s[a++] = t & 255), s;
}
function O3(e) {
  return Wn[e >> 18 & 63] + Wn[e >> 12 & 63] + Wn[e >> 6 & 63] + Wn[e & 63];
}
function P3(e, t, r) {
  for (var i, n = [], s = t; s < r; s += 3)
    i = (e[s] << 16 & 16711680) + (e[s + 1] << 8 & 65280) + (e[s + 2] & 255), n.push(O3(i));
  return n.join("");
}
function S3(e) {
  for (var t, r = e.length, i = r % 3, n = [], s = 16383, a = 0, o = r - i; a < o; a += s)
    n.push(P3(e, a, a + s > o ? o : a + s));
  return i === 1 ? (t = e[r - 1], n.push(
    Wn[t >> 2] + Wn[t << 4 & 63] + "=="
  )) : i === 2 && (t = (e[r - 2] << 8) + e[r - 1], n.push(
    Wn[t >> 10] + Wn[t >> 4 & 63] + Wn[t << 2 & 63] + "="
  )), n.join("");
}
var ng = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ng.read = function(e, t, r, i, n) {
  var s, a, o = n * 8 - i - 1, c = (1 << o) - 1, l = c >> 1, d = -7, p = r ? n - 1 : 0, h = r ? -1 : 1, g = e[t + p];
  for (p += h, s = g & (1 << -d) - 1, g >>= -d, d += o; d > 0; s = s * 256 + e[t + p], p += h, d -= 8)
    ;
  for (a = s & (1 << -d) - 1, s >>= -d, d += i; d > 0; a = a * 256 + e[t + p], p += h, d -= 8)
    ;
  if (s === 0)
    s = 1 - l;
  else {
    if (s === c)
      return a ? NaN : (g ? -1 : 1) * (1 / 0);
    a = a + Math.pow(2, i), s = s - l;
  }
  return (g ? -1 : 1) * a * Math.pow(2, s - i);
};
ng.write = function(e, t, r, i, n, s) {
  var a, o, c, l = s * 8 - n - 1, d = (1 << l) - 1, p = d >> 1, h = n === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, g = i ? 0 : s - 1, m = i ? 1 : -1, v = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
  for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (o = isNaN(t) ? 1 : 0, a = d) : (a = Math.floor(Math.log(t) / Math.LN2), t * (c = Math.pow(2, -a)) < 1 && (a--, c *= 2), a + p >= 1 ? t += h / c : t += h * Math.pow(2, 1 - p), t * c >= 2 && (a++, c /= 2), a + p >= d ? (o = 0, a = d) : a + p >= 1 ? (o = (t * c - 1) * Math.pow(2, n), a = a + p) : (o = t * Math.pow(2, p - 1) * Math.pow(2, n), a = 0)); n >= 8; e[r + g] = o & 255, g += m, o /= 256, n -= 8)
    ;
  for (a = a << n | o, l += n; l > 0; e[r + g] = a & 255, g += m, a /= 256, l -= 8)
    ;
  e[r + g - m] |= v * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(e) {
  const t = Af, r = ng, i = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  e.Buffer = o, e.SlowBuffer = w, e.INSPECT_MAX_BYTES = 50;
  const n = 2147483647;
  e.kMaxLength = n, o.TYPED_ARRAY_SUPPORT = s(), !o.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function s() {
    try {
      const q = new Uint8Array(1), x = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(x, Uint8Array.prototype), Object.setPrototypeOf(q, x), q.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(o.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (o.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(o.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (o.isBuffer(this))
        return this.byteOffset;
    }
  });
  function a(q) {
    if (q > n)
      throw new RangeError('The value "' + q + '" is invalid for option "size"');
    const x = new Uint8Array(q);
    return Object.setPrototypeOf(x, o.prototype), x;
  }
  function o(q, x, C) {
    if (typeof q == "number") {
      if (typeof x == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return p(q);
    }
    return c(q, x, C);
  }
  o.poolSize = 8192;
  function c(q, x, C) {
    if (typeof q == "string")
      return h(q, x);
    if (ArrayBuffer.isView(q))
      return m(q);
    if (q == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof q
      );
    if (De(q, ArrayBuffer) || q && De(q.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (De(q, SharedArrayBuffer) || q && De(q.buffer, SharedArrayBuffer)))
      return v(q, x, C);
    if (typeof q == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const G = q.valueOf && q.valueOf();
    if (G != null && G !== q)
      return o.from(G, x, C);
    const fe = _(q);
    if (fe)
      return fe;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof q[Symbol.toPrimitive] == "function")
      return o.from(q[Symbol.toPrimitive]("string"), x, C);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof q
    );
  }
  o.from = function(q, x, C) {
    return c(q, x, C);
  }, Object.setPrototypeOf(o.prototype, Uint8Array.prototype), Object.setPrototypeOf(o, Uint8Array);
  function l(q) {
    if (typeof q != "number")
      throw new TypeError('"size" argument must be of type number');
    if (q < 0)
      throw new RangeError('The value "' + q + '" is invalid for option "size"');
  }
  function d(q, x, C) {
    return l(q), q <= 0 ? a(q) : x !== void 0 ? typeof C == "string" ? a(q).fill(x, C) : a(q).fill(x) : a(q);
  }
  o.alloc = function(q, x, C) {
    return d(q, x, C);
  };
  function p(q) {
    return l(q), a(q < 0 ? 0 : y(q) | 0);
  }
  o.allocUnsafe = function(q) {
    return p(q);
  }, o.allocUnsafeSlow = function(q) {
    return p(q);
  };
  function h(q, x) {
    if ((typeof x != "string" || x === "") && (x = "utf8"), !o.isEncoding(x))
      throw new TypeError("Unknown encoding: " + x);
    const C = $(q, x) | 0;
    let G = a(C);
    const fe = G.write(q, x);
    return fe !== C && (G = G.slice(0, fe)), G;
  }
  function g(q) {
    const x = q.length < 0 ? 0 : y(q.length) | 0, C = a(x);
    for (let G = 0; G < x; G += 1)
      C[G] = q[G] & 255;
    return C;
  }
  function m(q) {
    if (De(q, Uint8Array)) {
      const x = new Uint8Array(q);
      return v(x.buffer, x.byteOffset, x.byteLength);
    }
    return g(q);
  }
  function v(q, x, C) {
    if (x < 0 || q.byteLength < x)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (q.byteLength < x + (C || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let G;
    return x === void 0 && C === void 0 ? G = new Uint8Array(q) : C === void 0 ? G = new Uint8Array(q, x) : G = new Uint8Array(q, x, C), Object.setPrototypeOf(G, o.prototype), G;
  }
  function _(q) {
    if (o.isBuffer(q)) {
      const x = y(q.length) | 0, C = a(x);
      return C.length === 0 || q.copy(C, 0, 0, x), C;
    }
    if (q.length !== void 0)
      return typeof q.length != "number" || Le(q.length) ? a(0) : g(q);
    if (q.type === "Buffer" && Array.isArray(q.data))
      return g(q.data);
  }
  function y(q) {
    if (q >= n)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + n.toString(16) + " bytes");
    return q | 0;
  }
  function w(q) {
    return +q != q && (q = 0), o.alloc(+q);
  }
  o.isBuffer = function(x) {
    return x != null && x._isBuffer === !0 && x !== o.prototype;
  }, o.compare = function(x, C) {
    if (De(x, Uint8Array) && (x = o.from(x, x.offset, x.byteLength)), De(C, Uint8Array) && (C = o.from(C, C.offset, C.byteLength)), !o.isBuffer(x) || !o.isBuffer(C))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (x === C)
      return 0;
    let G = x.length, fe = C.length;
    for (let ge = 0, Oe = Math.min(G, fe); ge < Oe; ++ge)
      if (x[ge] !== C[ge]) {
        G = x[ge], fe = C[ge];
        break;
      }
    return G < fe ? -1 : fe < G ? 1 : 0;
  }, o.isEncoding = function(x) {
    switch (String(x).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, o.concat = function(x, C) {
    if (!Array.isArray(x))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (x.length === 0)
      return o.alloc(0);
    let G;
    if (C === void 0)
      for (C = 0, G = 0; G < x.length; ++G)
        C += x[G].length;
    const fe = o.allocUnsafe(C);
    let ge = 0;
    for (G = 0; G < x.length; ++G) {
      let Oe = x[G];
      if (De(Oe, Uint8Array))
        ge + Oe.length > fe.length ? (o.isBuffer(Oe) || (Oe = o.from(Oe)), Oe.copy(fe, ge)) : Uint8Array.prototype.set.call(
          fe,
          Oe,
          ge
        );
      else if (o.isBuffer(Oe))
        Oe.copy(fe, ge);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      ge += Oe.length;
    }
    return fe;
  };
  function $(q, x) {
    if (o.isBuffer(q))
      return q.length;
    if (ArrayBuffer.isView(q) || De(q, ArrayBuffer))
      return q.byteLength;
    if (typeof q != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof q
      );
    const C = q.length, G = arguments.length > 2 && arguments[2] === !0;
    if (!G && C === 0)
      return 0;
    let fe = !1;
    for (; ; )
      switch (x) {
        case "ascii":
        case "latin1":
        case "binary":
          return C;
        case "utf8":
        case "utf-8":
          return Be(q).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return C * 2;
        case "hex":
          return C >>> 1;
        case "base64":
          return ht(q).length;
        default:
          if (fe)
            return G ? -1 : Be(q).length;
          x = ("" + x).toLowerCase(), fe = !0;
      }
  }
  o.byteLength = $;
  function E(q, x, C) {
    let G = !1;
    if ((x === void 0 || x < 0) && (x = 0), x > this.length || ((C === void 0 || C > this.length) && (C = this.length), C <= 0) || (C >>>= 0, x >>>= 0, C <= x))
      return "";
    for (q || (q = "utf8"); ; )
      switch (q) {
        case "hex":
          return _e(this, x, C);
        case "utf8":
        case "utf-8":
          return te(this, x, C);
        case "ascii":
          return Ee(this, x, C);
        case "latin1":
        case "binary":
          return Re(this, x, C);
        case "base64":
          return Pe(this, x, C);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ie(this, x, C);
        default:
          if (G)
            throw new TypeError("Unknown encoding: " + q);
          q = (q + "").toLowerCase(), G = !0;
      }
  }
  o.prototype._isBuffer = !0;
  function S(q, x, C) {
    const G = q[x];
    q[x] = q[C], q[C] = G;
  }
  o.prototype.swap16 = function() {
    const x = this.length;
    if (x % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let C = 0; C < x; C += 2)
      S(this, C, C + 1);
    return this;
  }, o.prototype.swap32 = function() {
    const x = this.length;
    if (x % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let C = 0; C < x; C += 4)
      S(this, C, C + 3), S(this, C + 1, C + 2);
    return this;
  }, o.prototype.swap64 = function() {
    const x = this.length;
    if (x % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let C = 0; C < x; C += 8)
      S(this, C, C + 7), S(this, C + 1, C + 6), S(this, C + 2, C + 5), S(this, C + 3, C + 4);
    return this;
  }, o.prototype.toString = function() {
    const x = this.length;
    return x === 0 ? "" : arguments.length === 0 ? te(this, 0, x) : E.apply(this, arguments);
  }, o.prototype.toLocaleString = o.prototype.toString, o.prototype.equals = function(x) {
    if (!o.isBuffer(x))
      throw new TypeError("Argument must be a Buffer");
    return this === x ? !0 : o.compare(this, x) === 0;
  }, o.prototype.inspect = function() {
    let x = "";
    const C = e.INSPECT_MAX_BYTES;
    return x = this.toString("hex", 0, C).replace(/(.{2})/g, "$1 ").trim(), this.length > C && (x += " ... "), "<Buffer " + x + ">";
  }, i && (o.prototype[i] = o.prototype.inspect), o.prototype.compare = function(x, C, G, fe, ge) {
    if (De(x, Uint8Array) && (x = o.from(x, x.offset, x.byteLength)), !o.isBuffer(x))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof x
      );
    if (C === void 0 && (C = 0), G === void 0 && (G = x ? x.length : 0), fe === void 0 && (fe = 0), ge === void 0 && (ge = this.length), C < 0 || G > x.length || fe < 0 || ge > this.length)
      throw new RangeError("out of range index");
    if (fe >= ge && C >= G)
      return 0;
    if (fe >= ge)
      return -1;
    if (C >= G)
      return 1;
    if (C >>>= 0, G >>>= 0, fe >>>= 0, ge >>>= 0, this === x)
      return 0;
    let Oe = ge - fe, ut = G - C;
    const kt = Math.min(Oe, ut), Rt = this.slice(fe, ge), $t = x.slice(C, G);
    for (let Tt = 0; Tt < kt; ++Tt)
      if (Rt[Tt] !== $t[Tt]) {
        Oe = Rt[Tt], ut = $t[Tt];
        break;
      }
    return Oe < ut ? -1 : ut < Oe ? 1 : 0;
  };
  function R(q, x, C, G, fe) {
    if (q.length === 0)
      return -1;
    if (typeof C == "string" ? (G = C, C = 0) : C > 2147483647 ? C = 2147483647 : C < -2147483648 && (C = -2147483648), C = +C, Le(C) && (C = fe ? 0 : q.length - 1), C < 0 && (C = q.length + C), C >= q.length) {
      if (fe)
        return -1;
      C = q.length - 1;
    } else if (C < 0)
      if (fe)
        C = 0;
      else
        return -1;
    if (typeof x == "string" && (x = o.from(x, G)), o.isBuffer(x))
      return x.length === 0 ? -1 : j(q, x, C, G, fe);
    if (typeof x == "number")
      return x = x & 255, typeof Uint8Array.prototype.indexOf == "function" ? fe ? Uint8Array.prototype.indexOf.call(q, x, C) : Uint8Array.prototype.lastIndexOf.call(q, x, C) : j(q, [x], C, G, fe);
    throw new TypeError("val must be string, number or Buffer");
  }
  function j(q, x, C, G, fe) {
    let ge = 1, Oe = q.length, ut = x.length;
    if (G !== void 0 && (G = String(G).toLowerCase(), G === "ucs2" || G === "ucs-2" || G === "utf16le" || G === "utf-16le")) {
      if (q.length < 2 || x.length < 2)
        return -1;
      ge = 2, Oe /= 2, ut /= 2, C /= 2;
    }
    function kt($t, Tt) {
      return ge === 1 ? $t[Tt] : $t.readUInt16BE(Tt * ge);
    }
    let Rt;
    if (fe) {
      let $t = -1;
      for (Rt = C; Rt < Oe; Rt++)
        if (kt(q, Rt) === kt(x, $t === -1 ? 0 : Rt - $t)) {
          if ($t === -1 && ($t = Rt), Rt - $t + 1 === ut)
            return $t * ge;
        } else
          $t !== -1 && (Rt -= Rt - $t), $t = -1;
    } else
      for (C + ut > Oe && (C = Oe - ut), Rt = C; Rt >= 0; Rt--) {
        let $t = !0;
        for (let Tt = 0; Tt < ut; Tt++)
          if (kt(q, Rt + Tt) !== kt(x, Tt)) {
            $t = !1;
            break;
          }
        if ($t)
          return Rt;
      }
    return -1;
  }
  o.prototype.includes = function(x, C, G) {
    return this.indexOf(x, C, G) !== -1;
  }, o.prototype.indexOf = function(x, C, G) {
    return R(this, x, C, G, !0);
  }, o.prototype.lastIndexOf = function(x, C, G) {
    return R(this, x, C, G, !1);
  };
  function L(q, x, C, G) {
    C = Number(C) || 0;
    const fe = q.length - C;
    G ? (G = Number(G), G > fe && (G = fe)) : G = fe;
    const ge = x.length;
    G > ge / 2 && (G = ge / 2);
    let Oe;
    for (Oe = 0; Oe < G; ++Oe) {
      const ut = parseInt(x.substr(Oe * 2, 2), 16);
      if (Le(ut))
        return Oe;
      q[C + Oe] = ut;
    }
    return Oe;
  }
  function K(q, x, C, G) {
    return nt(Be(x, q.length - C), q, C, G);
  }
  function ae(q, x, C, G) {
    return nt(vt(x), q, C, G);
  }
  function ye(q, x, C, G) {
    return nt(ht(x), q, C, G);
  }
  function xe(q, x, C, G) {
    return nt($e(x, q.length - C), q, C, G);
  }
  o.prototype.write = function(x, C, G, fe) {
    if (C === void 0)
      fe = "utf8", G = this.length, C = 0;
    else if (G === void 0 && typeof C == "string")
      fe = C, G = this.length, C = 0;
    else if (isFinite(C))
      C = C >>> 0, isFinite(G) ? (G = G >>> 0, fe === void 0 && (fe = "utf8")) : (fe = G, G = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const ge = this.length - C;
    if ((G === void 0 || G > ge) && (G = ge), x.length > 0 && (G < 0 || C < 0) || C > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    fe || (fe = "utf8");
    let Oe = !1;
    for (; ; )
      switch (fe) {
        case "hex":
          return L(this, x, C, G);
        case "utf8":
        case "utf-8":
          return K(this, x, C, G);
        case "ascii":
        case "latin1":
        case "binary":
          return ae(this, x, C, G);
        case "base64":
          return ye(this, x, C, G);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return xe(this, x, C, G);
        default:
          if (Oe)
            throw new TypeError("Unknown encoding: " + fe);
          fe = ("" + fe).toLowerCase(), Oe = !0;
      }
  }, o.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function Pe(q, x, C) {
    return x === 0 && C === q.length ? t.fromByteArray(q) : t.fromByteArray(q.slice(x, C));
  }
  function te(q, x, C) {
    C = Math.min(q.length, C);
    const G = [];
    let fe = x;
    for (; fe < C; ) {
      const ge = q[fe];
      let Oe = null, ut = ge > 239 ? 4 : ge > 223 ? 3 : ge > 191 ? 2 : 1;
      if (fe + ut <= C) {
        let kt, Rt, $t, Tt;
        switch (ut) {
          case 1:
            ge < 128 && (Oe = ge);
            break;
          case 2:
            kt = q[fe + 1], (kt & 192) === 128 && (Tt = (ge & 31) << 6 | kt & 63, Tt > 127 && (Oe = Tt));
            break;
          case 3:
            kt = q[fe + 1], Rt = q[fe + 2], (kt & 192) === 128 && (Rt & 192) === 128 && (Tt = (ge & 15) << 12 | (kt & 63) << 6 | Rt & 63, Tt > 2047 && (Tt < 55296 || Tt > 57343) && (Oe = Tt));
            break;
          case 4:
            kt = q[fe + 1], Rt = q[fe + 2], $t = q[fe + 3], (kt & 192) === 128 && (Rt & 192) === 128 && ($t & 192) === 128 && (Tt = (ge & 15) << 18 | (kt & 63) << 12 | (Rt & 63) << 6 | $t & 63, Tt > 65535 && Tt < 1114112 && (Oe = Tt));
        }
      }
      Oe === null ? (Oe = 65533, ut = 1) : Oe > 65535 && (Oe -= 65536, G.push(Oe >>> 10 & 1023 | 55296), Oe = 56320 | Oe & 1023), G.push(Oe), fe += ut;
    }
    return de(G);
  }
  const pe = 4096;
  function de(q) {
    const x = q.length;
    if (x <= pe)
      return String.fromCharCode.apply(String, q);
    let C = "", G = 0;
    for (; G < x; )
      C += String.fromCharCode.apply(
        String,
        q.slice(G, G += pe)
      );
    return C;
  }
  function Ee(q, x, C) {
    let G = "";
    C = Math.min(q.length, C);
    for (let fe = x; fe < C; ++fe)
      G += String.fromCharCode(q[fe] & 127);
    return G;
  }
  function Re(q, x, C) {
    let G = "";
    C = Math.min(q.length, C);
    for (let fe = x; fe < C; ++fe)
      G += String.fromCharCode(q[fe]);
    return G;
  }
  function _e(q, x, C) {
    const G = q.length;
    (!x || x < 0) && (x = 0), (!C || C < 0 || C > G) && (C = G);
    let fe = "";
    for (let ge = x; ge < C; ++ge)
      fe += at[q[ge]];
    return fe;
  }
  function ie(q, x, C) {
    const G = q.slice(x, C);
    let fe = "";
    for (let ge = 0; ge < G.length - 1; ge += 2)
      fe += String.fromCharCode(G[ge] + G[ge + 1] * 256);
    return fe;
  }
  o.prototype.slice = function(x, C) {
    const G = this.length;
    x = ~~x, C = C === void 0 ? G : ~~C, x < 0 ? (x += G, x < 0 && (x = 0)) : x > G && (x = G), C < 0 ? (C += G, C < 0 && (C = 0)) : C > G && (C = G), C < x && (C = x);
    const fe = this.subarray(x, C);
    return Object.setPrototypeOf(fe, o.prototype), fe;
  };
  function Y(q, x, C) {
    if (q % 1 !== 0 || q < 0)
      throw new RangeError("offset is not uint");
    if (q + x > C)
      throw new RangeError("Trying to access beyond buffer length");
  }
  o.prototype.readUintLE = o.prototype.readUIntLE = function(x, C, G) {
    x = x >>> 0, C = C >>> 0, G || Y(x, C, this.length);
    let fe = this[x], ge = 1, Oe = 0;
    for (; ++Oe < C && (ge *= 256); )
      fe += this[x + Oe] * ge;
    return fe;
  }, o.prototype.readUintBE = o.prototype.readUIntBE = function(x, C, G) {
    x = x >>> 0, C = C >>> 0, G || Y(x, C, this.length);
    let fe = this[x + --C], ge = 1;
    for (; C > 0 && (ge *= 256); )
      fe += this[x + --C] * ge;
    return fe;
  }, o.prototype.readUint8 = o.prototype.readUInt8 = function(x, C) {
    return x = x >>> 0, C || Y(x, 1, this.length), this[x];
  }, o.prototype.readUint16LE = o.prototype.readUInt16LE = function(x, C) {
    return x = x >>> 0, C || Y(x, 2, this.length), this[x] | this[x + 1] << 8;
  }, o.prototype.readUint16BE = o.prototype.readUInt16BE = function(x, C) {
    return x = x >>> 0, C || Y(x, 2, this.length), this[x] << 8 | this[x + 1];
  }, o.prototype.readUint32LE = o.prototype.readUInt32LE = function(x, C) {
    return x = x >>> 0, C || Y(x, 4, this.length), (this[x] | this[x + 1] << 8 | this[x + 2] << 16) + this[x + 3] * 16777216;
  }, o.prototype.readUint32BE = o.prototype.readUInt32BE = function(x, C) {
    return x = x >>> 0, C || Y(x, 4, this.length), this[x] * 16777216 + (this[x + 1] << 16 | this[x + 2] << 8 | this[x + 3]);
  }, o.prototype.readBigUInt64LE = mt(function(x) {
    x = x >>> 0, X(x, "offset");
    const C = this[x], G = this[x + 7];
    (C === void 0 || G === void 0) && oe(x, this.length - 8);
    const fe = C + this[++x] * 2 ** 8 + this[++x] * 2 ** 16 + this[++x] * 2 ** 24, ge = this[++x] + this[++x] * 2 ** 8 + this[++x] * 2 ** 16 + G * 2 ** 24;
    return BigInt(fe) + (BigInt(ge) << BigInt(32));
  }), o.prototype.readBigUInt64BE = mt(function(x) {
    x = x >>> 0, X(x, "offset");
    const C = this[x], G = this[x + 7];
    (C === void 0 || G === void 0) && oe(x, this.length - 8);
    const fe = C * 2 ** 24 + this[++x] * 2 ** 16 + this[++x] * 2 ** 8 + this[++x], ge = this[++x] * 2 ** 24 + this[++x] * 2 ** 16 + this[++x] * 2 ** 8 + G;
    return (BigInt(fe) << BigInt(32)) + BigInt(ge);
  }), o.prototype.readIntLE = function(x, C, G) {
    x = x >>> 0, C = C >>> 0, G || Y(x, C, this.length);
    let fe = this[x], ge = 1, Oe = 0;
    for (; ++Oe < C && (ge *= 256); )
      fe += this[x + Oe] * ge;
    return ge *= 128, fe >= ge && (fe -= Math.pow(2, 8 * C)), fe;
  }, o.prototype.readIntBE = function(x, C, G) {
    x = x >>> 0, C = C >>> 0, G || Y(x, C, this.length);
    let fe = C, ge = 1, Oe = this[x + --fe];
    for (; fe > 0 && (ge *= 256); )
      Oe += this[x + --fe] * ge;
    return ge *= 128, Oe >= ge && (Oe -= Math.pow(2, 8 * C)), Oe;
  }, o.prototype.readInt8 = function(x, C) {
    return x = x >>> 0, C || Y(x, 1, this.length), this[x] & 128 ? (255 - this[x] + 1) * -1 : this[x];
  }, o.prototype.readInt16LE = function(x, C) {
    x = x >>> 0, C || Y(x, 2, this.length);
    const G = this[x] | this[x + 1] << 8;
    return G & 32768 ? G | 4294901760 : G;
  }, o.prototype.readInt16BE = function(x, C) {
    x = x >>> 0, C || Y(x, 2, this.length);
    const G = this[x + 1] | this[x] << 8;
    return G & 32768 ? G | 4294901760 : G;
  }, o.prototype.readInt32LE = function(x, C) {
    return x = x >>> 0, C || Y(x, 4, this.length), this[x] | this[x + 1] << 8 | this[x + 2] << 16 | this[x + 3] << 24;
  }, o.prototype.readInt32BE = function(x, C) {
    return x = x >>> 0, C || Y(x, 4, this.length), this[x] << 24 | this[x + 1] << 16 | this[x + 2] << 8 | this[x + 3];
  }, o.prototype.readBigInt64LE = mt(function(x) {
    x = x >>> 0, X(x, "offset");
    const C = this[x], G = this[x + 7];
    (C === void 0 || G === void 0) && oe(x, this.length - 8);
    const fe = this[x + 4] + this[x + 5] * 2 ** 8 + this[x + 6] * 2 ** 16 + (G << 24);
    return (BigInt(fe) << BigInt(32)) + BigInt(C + this[++x] * 2 ** 8 + this[++x] * 2 ** 16 + this[++x] * 2 ** 24);
  }), o.prototype.readBigInt64BE = mt(function(x) {
    x = x >>> 0, X(x, "offset");
    const C = this[x], G = this[x + 7];
    (C === void 0 || G === void 0) && oe(x, this.length - 8);
    const fe = (C << 24) + // Overflow
    this[++x] * 2 ** 16 + this[++x] * 2 ** 8 + this[++x];
    return (BigInt(fe) << BigInt(32)) + BigInt(this[++x] * 2 ** 24 + this[++x] * 2 ** 16 + this[++x] * 2 ** 8 + G);
  }), o.prototype.readFloatLE = function(x, C) {
    return x = x >>> 0, C || Y(x, 4, this.length), r.read(this, x, !0, 23, 4);
  }, o.prototype.readFloatBE = function(x, C) {
    return x = x >>> 0, C || Y(x, 4, this.length), r.read(this, x, !1, 23, 4);
  }, o.prototype.readDoubleLE = function(x, C) {
    return x = x >>> 0, C || Y(x, 8, this.length), r.read(this, x, !0, 52, 8);
  }, o.prototype.readDoubleBE = function(x, C) {
    return x = x >>> 0, C || Y(x, 8, this.length), r.read(this, x, !1, 52, 8);
  };
  function V(q, x, C, G, fe, ge) {
    if (!o.isBuffer(q))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (x > fe || x < ge)
      throw new RangeError('"value" argument is out of bounds');
    if (C + G > q.length)
      throw new RangeError("Index out of range");
  }
  o.prototype.writeUintLE = o.prototype.writeUIntLE = function(x, C, G, fe) {
    if (x = +x, C = C >>> 0, G = G >>> 0, !fe) {
      const ut = Math.pow(2, 8 * G) - 1;
      V(this, x, C, G, ut, 0);
    }
    let ge = 1, Oe = 0;
    for (this[C] = x & 255; ++Oe < G && (ge *= 256); )
      this[C + Oe] = x / ge & 255;
    return C + G;
  }, o.prototype.writeUintBE = o.prototype.writeUIntBE = function(x, C, G, fe) {
    if (x = +x, C = C >>> 0, G = G >>> 0, !fe) {
      const ut = Math.pow(2, 8 * G) - 1;
      V(this, x, C, G, ut, 0);
    }
    let ge = G - 1, Oe = 1;
    for (this[C + ge] = x & 255; --ge >= 0 && (Oe *= 256); )
      this[C + ge] = x / Oe & 255;
    return C + G;
  }, o.prototype.writeUint8 = o.prototype.writeUInt8 = function(x, C, G) {
    return x = +x, C = C >>> 0, G || V(this, x, C, 1, 255, 0), this[C] = x & 255, C + 1;
  }, o.prototype.writeUint16LE = o.prototype.writeUInt16LE = function(x, C, G) {
    return x = +x, C = C >>> 0, G || V(this, x, C, 2, 65535, 0), this[C] = x & 255, this[C + 1] = x >>> 8, C + 2;
  }, o.prototype.writeUint16BE = o.prototype.writeUInt16BE = function(x, C, G) {
    return x = +x, C = C >>> 0, G || V(this, x, C, 2, 65535, 0), this[C] = x >>> 8, this[C + 1] = x & 255, C + 2;
  }, o.prototype.writeUint32LE = o.prototype.writeUInt32LE = function(x, C, G) {
    return x = +x, C = C >>> 0, G || V(this, x, C, 4, 4294967295, 0), this[C + 3] = x >>> 24, this[C + 2] = x >>> 16, this[C + 1] = x >>> 8, this[C] = x & 255, C + 4;
  }, o.prototype.writeUint32BE = o.prototype.writeUInt32BE = function(x, C, G) {
    return x = +x, C = C >>> 0, G || V(this, x, C, 4, 4294967295, 0), this[C] = x >>> 24, this[C + 1] = x >>> 16, this[C + 2] = x >>> 8, this[C + 3] = x & 255, C + 4;
  };
  function z(q, x, C, G, fe) {
    I(x, G, fe, q, C, 7);
    let ge = Number(x & BigInt(4294967295));
    q[C++] = ge, ge = ge >> 8, q[C++] = ge, ge = ge >> 8, q[C++] = ge, ge = ge >> 8, q[C++] = ge;
    let Oe = Number(x >> BigInt(32) & BigInt(4294967295));
    return q[C++] = Oe, Oe = Oe >> 8, q[C++] = Oe, Oe = Oe >> 8, q[C++] = Oe, Oe = Oe >> 8, q[C++] = Oe, C;
  }
  function T(q, x, C, G, fe) {
    I(x, G, fe, q, C, 7);
    let ge = Number(x & BigInt(4294967295));
    q[C + 7] = ge, ge = ge >> 8, q[C + 6] = ge, ge = ge >> 8, q[C + 5] = ge, ge = ge >> 8, q[C + 4] = ge;
    let Oe = Number(x >> BigInt(32) & BigInt(4294967295));
    return q[C + 3] = Oe, Oe = Oe >> 8, q[C + 2] = Oe, Oe = Oe >> 8, q[C + 1] = Oe, Oe = Oe >> 8, q[C] = Oe, C + 8;
  }
  o.prototype.writeBigUInt64LE = mt(function(x, C = 0) {
    return z(this, x, C, BigInt(0), BigInt("0xffffffffffffffff"));
  }), o.prototype.writeBigUInt64BE = mt(function(x, C = 0) {
    return T(this, x, C, BigInt(0), BigInt("0xffffffffffffffff"));
  }), o.prototype.writeIntLE = function(x, C, G, fe) {
    if (x = +x, C = C >>> 0, !fe) {
      const kt = Math.pow(2, 8 * G - 1);
      V(this, x, C, G, kt - 1, -kt);
    }
    let ge = 0, Oe = 1, ut = 0;
    for (this[C] = x & 255; ++ge < G && (Oe *= 256); )
      x < 0 && ut === 0 && this[C + ge - 1] !== 0 && (ut = 1), this[C + ge] = (x / Oe >> 0) - ut & 255;
    return C + G;
  }, o.prototype.writeIntBE = function(x, C, G, fe) {
    if (x = +x, C = C >>> 0, !fe) {
      const kt = Math.pow(2, 8 * G - 1);
      V(this, x, C, G, kt - 1, -kt);
    }
    let ge = G - 1, Oe = 1, ut = 0;
    for (this[C + ge] = x & 255; --ge >= 0 && (Oe *= 256); )
      x < 0 && ut === 0 && this[C + ge + 1] !== 0 && (ut = 1), this[C + ge] = (x / Oe >> 0) - ut & 255;
    return C + G;
  }, o.prototype.writeInt8 = function(x, C, G) {
    return x = +x, C = C >>> 0, G || V(this, x, C, 1, 127, -128), x < 0 && (x = 255 + x + 1), this[C] = x & 255, C + 1;
  }, o.prototype.writeInt16LE = function(x, C, G) {
    return x = +x, C = C >>> 0, G || V(this, x, C, 2, 32767, -32768), this[C] = x & 255, this[C + 1] = x >>> 8, C + 2;
  }, o.prototype.writeInt16BE = function(x, C, G) {
    return x = +x, C = C >>> 0, G || V(this, x, C, 2, 32767, -32768), this[C] = x >>> 8, this[C + 1] = x & 255, C + 2;
  }, o.prototype.writeInt32LE = function(x, C, G) {
    return x = +x, C = C >>> 0, G || V(this, x, C, 4, 2147483647, -2147483648), this[C] = x & 255, this[C + 1] = x >>> 8, this[C + 2] = x >>> 16, this[C + 3] = x >>> 24, C + 4;
  }, o.prototype.writeInt32BE = function(x, C, G) {
    return x = +x, C = C >>> 0, G || V(this, x, C, 4, 2147483647, -2147483648), x < 0 && (x = 4294967295 + x + 1), this[C] = x >>> 24, this[C + 1] = x >>> 16, this[C + 2] = x >>> 8, this[C + 3] = x & 255, C + 4;
  }, o.prototype.writeBigInt64LE = mt(function(x, C = 0) {
    return z(this, x, C, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), o.prototype.writeBigInt64BE = mt(function(x, C = 0) {
    return T(this, x, C, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function F(q, x, C, G, fe, ge) {
    if (C + G > q.length)
      throw new RangeError("Index out of range");
    if (C < 0)
      throw new RangeError("Index out of range");
  }
  function D(q, x, C, G, fe) {
    return x = +x, C = C >>> 0, fe || F(q, x, C, 4), r.write(q, x, C, G, 23, 4), C + 4;
  }
  o.prototype.writeFloatLE = function(x, C, G) {
    return D(this, x, C, !0, G);
  }, o.prototype.writeFloatBE = function(x, C, G) {
    return D(this, x, C, !1, G);
  };
  function U(q, x, C, G, fe) {
    return x = +x, C = C >>> 0, fe || F(q, x, C, 8), r.write(q, x, C, G, 52, 8), C + 8;
  }
  o.prototype.writeDoubleLE = function(x, C, G) {
    return U(this, x, C, !0, G);
  }, o.prototype.writeDoubleBE = function(x, C, G) {
    return U(this, x, C, !1, G);
  }, o.prototype.copy = function(x, C, G, fe) {
    if (!o.isBuffer(x))
      throw new TypeError("argument should be a Buffer");
    if (G || (G = 0), !fe && fe !== 0 && (fe = this.length), C >= x.length && (C = x.length), C || (C = 0), fe > 0 && fe < G && (fe = G), fe === G || x.length === 0 || this.length === 0)
      return 0;
    if (C < 0)
      throw new RangeError("targetStart out of bounds");
    if (G < 0 || G >= this.length)
      throw new RangeError("Index out of range");
    if (fe < 0)
      throw new RangeError("sourceEnd out of bounds");
    fe > this.length && (fe = this.length), x.length - C < fe - G && (fe = x.length - C + G);
    const ge = fe - G;
    return this === x && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(C, G, fe) : Uint8Array.prototype.set.call(
      x,
      this.subarray(G, fe),
      C
    ), ge;
  }, o.prototype.fill = function(x, C, G, fe) {
    if (typeof x == "string") {
      if (typeof C == "string" ? (fe = C, C = 0, G = this.length) : typeof G == "string" && (fe = G, G = this.length), fe !== void 0 && typeof fe != "string")
        throw new TypeError("encoding must be a string");
      if (typeof fe == "string" && !o.isEncoding(fe))
        throw new TypeError("Unknown encoding: " + fe);
      if (x.length === 1) {
        const Oe = x.charCodeAt(0);
        (fe === "utf8" && Oe < 128 || fe === "latin1") && (x = Oe);
      }
    } else
      typeof x == "number" ? x = x & 255 : typeof x == "boolean" && (x = Number(x));
    if (C < 0 || this.length < C || this.length < G)
      throw new RangeError("Out of range index");
    if (G <= C)
      return this;
    C = C >>> 0, G = G === void 0 ? this.length : G >>> 0, x || (x = 0);
    let ge;
    if (typeof x == "number")
      for (ge = C; ge < G; ++ge)
        this[ge] = x;
    else {
      const Oe = o.isBuffer(x) ? x : o.from(x, fe), ut = Oe.length;
      if (ut === 0)
        throw new TypeError('The value "' + x + '" is invalid for argument "value"');
      for (ge = 0; ge < G - C; ++ge)
        this[ge + C] = Oe[ge % ut];
    }
    return this;
  };
  const k = {};
  function Z(q, x, C) {
    k[q] = class extends C {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: x.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${q}]`, this.stack, delete this.name;
      }
      get code() {
        return q;
      }
      set code(fe) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: fe,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${q}]: ${this.message}`;
      }
    };
  }
  Z(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(q) {
      return q ? `${q} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), Z(
    "ERR_INVALID_ARG_TYPE",
    function(q, x) {
      return `The "${q}" argument must be of type number. Received type ${typeof x}`;
    },
    TypeError
  ), Z(
    "ERR_OUT_OF_RANGE",
    function(q, x, C) {
      let G = `The value of "${q}" is out of range.`, fe = C;
      return Number.isInteger(C) && Math.abs(C) > 2 ** 32 ? fe = J(String(C)) : typeof C == "bigint" && (fe = String(C), (C > BigInt(2) ** BigInt(32) || C < -(BigInt(2) ** BigInt(32))) && (fe = J(fe)), fe += "n"), G += ` It must be ${x}. Received ${fe}`, G;
    },
    RangeError
  );
  function J(q) {
    let x = "", C = q.length;
    const G = q[0] === "-" ? 1 : 0;
    for (; C >= G + 4; C -= 3)
      x = `_${q.slice(C - 3, C)}${x}`;
    return `${q.slice(0, C)}${x}`;
  }
  function A(q, x, C) {
    X(x, "offset"), (q[x] === void 0 || q[x + C] === void 0) && oe(x, q.length - (C + 1));
  }
  function I(q, x, C, G, fe, ge) {
    if (q > C || q < x) {
      const Oe = typeof x == "bigint" ? "n" : "";
      let ut;
      throw ge > 3 ? x === 0 || x === BigInt(0) ? ut = `>= 0${Oe} and < 2${Oe} ** ${(ge + 1) * 8}${Oe}` : ut = `>= -(2${Oe} ** ${(ge + 1) * 8 - 1}${Oe}) and < 2 ** ${(ge + 1) * 8 - 1}${Oe}` : ut = `>= ${x}${Oe} and <= ${C}${Oe}`, new k.ERR_OUT_OF_RANGE("value", ut, q);
    }
    A(G, fe, ge);
  }
  function X(q, x) {
    if (typeof q != "number")
      throw new k.ERR_INVALID_ARG_TYPE(x, "number", q);
  }
  function oe(q, x, C) {
    throw Math.floor(q) !== q ? (X(q, C), new k.ERR_OUT_OF_RANGE(C || "offset", "an integer", q)) : x < 0 ? new k.ERR_BUFFER_OUT_OF_BOUNDS() : new k.ERR_OUT_OF_RANGE(
      C || "offset",
      `>= ${C ? 1 : 0} and <= ${x}`,
      q
    );
  }
  const Ae = /[^+/0-9A-Za-z-_]/g;
  function je(q) {
    if (q = q.split("=")[0], q = q.trim().replace(Ae, ""), q.length < 2)
      return "";
    for (; q.length % 4 !== 0; )
      q = q + "=";
    return q;
  }
  function Be(q, x) {
    x = x || 1 / 0;
    let C;
    const G = q.length;
    let fe = null;
    const ge = [];
    for (let Oe = 0; Oe < G; ++Oe) {
      if (C = q.charCodeAt(Oe), C > 55295 && C < 57344) {
        if (!fe) {
          if (C > 56319) {
            (x -= 3) > -1 && ge.push(239, 191, 189);
            continue;
          } else if (Oe + 1 === G) {
            (x -= 3) > -1 && ge.push(239, 191, 189);
            continue;
          }
          fe = C;
          continue;
        }
        if (C < 56320) {
          (x -= 3) > -1 && ge.push(239, 191, 189), fe = C;
          continue;
        }
        C = (fe - 55296 << 10 | C - 56320) + 65536;
      } else
        fe && (x -= 3) > -1 && ge.push(239, 191, 189);
      if (fe = null, C < 128) {
        if ((x -= 1) < 0)
          break;
        ge.push(C);
      } else if (C < 2048) {
        if ((x -= 2) < 0)
          break;
        ge.push(
          C >> 6 | 192,
          C & 63 | 128
        );
      } else if (C < 65536) {
        if ((x -= 3) < 0)
          break;
        ge.push(
          C >> 12 | 224,
          C >> 6 & 63 | 128,
          C & 63 | 128
        );
      } else if (C < 1114112) {
        if ((x -= 4) < 0)
          break;
        ge.push(
          C >> 18 | 240,
          C >> 12 & 63 | 128,
          C >> 6 & 63 | 128,
          C & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return ge;
  }
  function vt(q) {
    const x = [];
    for (let C = 0; C < q.length; ++C)
      x.push(q.charCodeAt(C) & 255);
    return x;
  }
  function $e(q, x) {
    let C, G, fe;
    const ge = [];
    for (let Oe = 0; Oe < q.length && !((x -= 2) < 0); ++Oe)
      C = q.charCodeAt(Oe), G = C >> 8, fe = C % 256, ge.push(fe), ge.push(G);
    return ge;
  }
  function ht(q) {
    return t.toByteArray(je(q));
  }
  function nt(q, x, C, G) {
    let fe;
    for (fe = 0; fe < G && !(fe + C >= x.length || fe >= q.length); ++fe)
      x[fe + C] = q[fe];
    return fe;
  }
  function De(q, x) {
    return q instanceof x || q != null && q.constructor != null && q.constructor.name != null && q.constructor.name === x.name;
  }
  function Le(q) {
    return q !== q;
  }
  const at = function() {
    const q = "0123456789abcdef", x = new Array(256);
    for (let C = 0; C < 16; ++C) {
      const G = C * 16;
      for (let fe = 0; fe < 16; ++fe)
        x[G + fe] = q[C] + q[fe];
    }
    return x;
  }();
  function mt(q) {
    return typeof BigInt > "u" ? Ue : q;
  }
  function Ue() {
    throw new Error("BigInt not supported");
  }
})(ro);
var X2 = { exports: {} }, tr = X2.exports = {}, Vn, Zn;
function Jm() {
  throw new Error("setTimeout has not been defined");
}
function Xm() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? Vn = setTimeout : Vn = Jm;
  } catch {
    Vn = Jm;
  }
  try {
    typeof clearTimeout == "function" ? Zn = clearTimeout : Zn = Xm;
  } catch {
    Zn = Xm;
  }
})();
function Q2(e) {
  if (Vn === setTimeout)
    return setTimeout(e, 0);
  if ((Vn === Jm || !Vn) && setTimeout)
    return Vn = setTimeout, setTimeout(e, 0);
  try {
    return Vn(e, 0);
  } catch {
    try {
      return Vn.call(null, e, 0);
    } catch {
      return Vn.call(this, e, 0);
    }
  }
}
function A3(e) {
  if (Zn === clearTimeout)
    return clearTimeout(e);
  if ((Zn === Xm || !Zn) && clearTimeout)
    return Zn = clearTimeout, clearTimeout(e);
  try {
    return Zn(e);
  } catch {
    try {
      return Zn.call(null, e);
    } catch {
      return Zn.call(this, e);
    }
  }
}
var bi = [], Ua = !1, Ls, yl = -1;
function C3() {
  !Ua || !Ls || (Ua = !1, Ls.length ? bi = Ls.concat(bi) : yl = -1, bi.length && eE());
}
function eE() {
  if (!Ua) {
    var e = Q2(C3);
    Ua = !0;
    for (var t = bi.length; t; ) {
      for (Ls = bi, bi = []; ++yl < t; )
        Ls && Ls[yl].run();
      yl = -1, t = bi.length;
    }
    Ls = null, Ua = !1, A3(e);
  }
}
tr.nextTick = function(e) {
  var t = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var r = 1; r < arguments.length; r++)
      t[r - 1] = arguments[r];
  bi.push(new tE(e, t)), bi.length === 1 && !Ua && Q2(eE);
};
function tE(e, t) {
  this.fun = e, this.array = t;
}
tE.prototype.run = function() {
  this.fun.apply(null, this.array);
};
tr.title = "browser";
tr.browser = !0;
tr.env = {};
tr.argv = [];
tr.version = "";
tr.versions = {};
function Ai() {
}
tr.on = Ai;
tr.addListener = Ai;
tr.once = Ai;
tr.off = Ai;
tr.removeListener = Ai;
tr.removeAllListeners = Ai;
tr.emit = Ai;
tr.prependListener = Ai;
tr.prependOnceListener = Ai;
tr.listeners = function(e) {
  return [];
};
tr.binding = function(e) {
  throw new Error("process.binding is not supported");
};
tr.cwd = function() {
  return "/";
};
tr.chdir = function(e) {
  throw new Error("process.chdir is not supported");
};
tr.umask = function() {
  return 0;
};
var R3 = X2.exports;
(function(e) {
  Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
  const t = ro, r = R3, i = (a) => a && a.__esModule ? a : { default: a }, n = i(r), s = globalThis || void 0 || self;
  Object.defineProperty(e, "Buffer", { enumerable: !0, get: () => t.Buffer }), Object.defineProperty(e, "process", { enumerable: !0, get: () => n.default }), e.global = s;
})(qe);
var no = {}, rE = {}, nE = function() {
  if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
    return !1;
  if (typeof Symbol.iterator == "symbol")
    return !0;
  var t = {}, r = Symbol("test"), i = Object(r);
  if (typeof r == "string" || Object.prototype.toString.call(r) !== "[object Symbol]" || Object.prototype.toString.call(i) !== "[object Symbol]")
    return !1;
  var n = 42;
  t[r] = n;
  for (r in t)
    return !1;
  if (typeof Object.keys == "function" && Object.keys(t).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(t).length !== 0)
    return !1;
  var s = Object.getOwnPropertySymbols(t);
  if (s.length !== 1 || s[0] !== r || !Object.prototype.propertyIsEnumerable.call(t, r))
    return !1;
  if (typeof Object.getOwnPropertyDescriptor == "function") {
    var a = Object.getOwnPropertyDescriptor(t, r);
    if (a.value !== n || a.enumerable !== !0)
      return !1;
  }
  return !0;
}, T3 = nE, ig = function() {
  return T3() && !!Symbol.toStringTag;
}, Xb = typeof Symbol < "u" && Symbol, I3 = nE, j3 = function() {
  return typeof Xb != "function" || typeof Symbol != "function" || typeof Xb("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : I3();
}, Qb = {
  foo: {}
}, k3 = Object, M3 = function() {
  return { __proto__: Qb }.foo === Qb.foo && !({ __proto__: null } instanceof k3);
}, N3 = "Function.prototype.bind called on incompatible ", _p = Array.prototype.slice, D3 = Object.prototype.toString, L3 = "[object Function]", q3 = function(t) {
  var r = this;
  if (typeof r != "function" || D3.call(r) !== L3)
    throw new TypeError(N3 + r);
  for (var i = _p.call(arguments, 1), n, s = function() {
    if (this instanceof n) {
      var d = r.apply(
        this,
        i.concat(_p.call(arguments))
      );
      return Object(d) === d ? d : this;
    } else
      return r.apply(
        t,
        i.concat(_p.call(arguments))
      );
  }, a = Math.max(0, r.length - i.length), o = [], c = 0; c < a; c++)
    o.push("$" + c);
  if (n = Function("binder", "return function (" + o.join(",") + "){ return binder.apply(this,arguments); }")(s), r.prototype) {
    var l = function() {
    };
    l.prototype = r.prototype, n.prototype = new l(), l.prototype = null;
  }
  return n;
}, F3 = q3, sg = Function.prototype.bind || F3, U3 = sg, B3 = U3.call(Function.call, Object.prototype.hasOwnProperty), At, Ja = SyntaxError, iE = Function, Ba = TypeError, wp = function(e) {
  try {
    return iE('"use strict"; return (' + e + ").constructor;")();
  } catch {
  }
}, Us = Object.getOwnPropertyDescriptor;
if (Us)
  try {
    Us({}, "");
  } catch {
    Us = null;
  }
var $p = function() {
  throw new Ba();
}, V3 = Us ? function() {
  try {
    return arguments.callee, $p;
  } catch {
    try {
      return Us(arguments, "callee").get;
    } catch {
      return $p;
    }
  }
}() : $p, $a = j3(), Z3 = M3(), lr = Object.getPrototypeOf || (Z3 ? function(e) {
  return e.__proto__;
} : null), Ta = {}, z3 = typeof Uint8Array > "u" || !lr ? At : lr(Uint8Array), Bs = {
  "%AggregateError%": typeof AggregateError > "u" ? At : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer > "u" ? At : ArrayBuffer,
  "%ArrayIteratorPrototype%": $a && lr ? lr([][Symbol.iterator]()) : At,
  "%AsyncFromSyncIteratorPrototype%": At,
  "%AsyncFunction%": Ta,
  "%AsyncGenerator%": Ta,
  "%AsyncGeneratorFunction%": Ta,
  "%AsyncIteratorPrototype%": Ta,
  "%Atomics%": typeof Atomics > "u" ? At : Atomics,
  "%BigInt%": typeof BigInt > "u" ? At : BigInt,
  "%BigInt64Array%": typeof BigInt64Array > "u" ? At : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array > "u" ? At : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView > "u" ? At : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": Error,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": EvalError,
  "%Float32Array%": typeof Float32Array > "u" ? At : Float32Array,
  "%Float64Array%": typeof Float64Array > "u" ? At : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? At : FinalizationRegistry,
  "%Function%": iE,
  "%GeneratorFunction%": Ta,
  "%Int8Array%": typeof Int8Array > "u" ? At : Int8Array,
  "%Int16Array%": typeof Int16Array > "u" ? At : Int16Array,
  "%Int32Array%": typeof Int32Array > "u" ? At : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": $a && lr ? lr(lr([][Symbol.iterator]())) : At,
  "%JSON%": typeof JSON == "object" ? JSON : At,
  "%Map%": typeof Map > "u" ? At : Map,
  "%MapIteratorPrototype%": typeof Map > "u" || !$a || !lr ? At : lr((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise > "u" ? At : Promise,
  "%Proxy%": typeof Proxy > "u" ? At : Proxy,
  "%RangeError%": RangeError,
  "%ReferenceError%": ReferenceError,
  "%Reflect%": typeof Reflect > "u" ? At : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set > "u" ? At : Set,
  "%SetIteratorPrototype%": typeof Set > "u" || !$a || !lr ? At : lr((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? At : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": $a && lr ? lr(""[Symbol.iterator]()) : At,
  "%Symbol%": $a ? Symbol : At,
  "%SyntaxError%": Ja,
  "%ThrowTypeError%": V3,
  "%TypedArray%": z3,
  "%TypeError%": Ba,
  "%Uint8Array%": typeof Uint8Array > "u" ? At : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? At : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array > "u" ? At : Uint16Array,
  "%Uint32Array%": typeof Uint32Array > "u" ? At : Uint32Array,
  "%URIError%": URIError,
  "%WeakMap%": typeof WeakMap > "u" ? At : WeakMap,
  "%WeakRef%": typeof WeakRef > "u" ? At : WeakRef,
  "%WeakSet%": typeof WeakSet > "u" ? At : WeakSet
};
if (lr)
  try {
    null.error;
  } catch (e) {
    var W3 = lr(lr(e));
    Bs["%Error.prototype%"] = W3;
  }
var H3 = function e(t) {
  var r;
  if (t === "%AsyncFunction%")
    r = wp("async function () {}");
  else if (t === "%GeneratorFunction%")
    r = wp("function* () {}");
  else if (t === "%AsyncGeneratorFunction%")
    r = wp("async function* () {}");
  else if (t === "%AsyncGenerator%") {
    var i = e("%AsyncGeneratorFunction%");
    i && (r = i.prototype);
  } else if (t === "%AsyncIteratorPrototype%") {
    var n = e("%AsyncGenerator%");
    n && lr && (r = lr(n.prototype));
  }
  return Bs[t] = r, r;
}, e1 = {
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
}, Bu = sg, Yl = B3, G3 = Bu.call(Function.call, Array.prototype.concat), K3 = Bu.call(Function.apply, Array.prototype.splice), t1 = Bu.call(Function.call, String.prototype.replace), Jl = Bu.call(Function.call, String.prototype.slice), Y3 = Bu.call(Function.call, RegExp.prototype.exec), J3 = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, X3 = /\\(\\)?/g, Q3 = function(t) {
  var r = Jl(t, 0, 1), i = Jl(t, -1);
  if (r === "%" && i !== "%")
    throw new Ja("invalid intrinsic syntax, expected closing `%`");
  if (i === "%" && r !== "%")
    throw new Ja("invalid intrinsic syntax, expected opening `%`");
  var n = [];
  return t1(t, J3, function(s, a, o, c) {
    n[n.length] = o ? t1(c, X3, "$1") : a || s;
  }), n;
}, eM = function(t, r) {
  var i = t, n;
  if (Yl(e1, i) && (n = e1[i], i = "%" + n[0] + "%"), Yl(Bs, i)) {
    var s = Bs[i];
    if (s === Ta && (s = H3(i)), typeof s > "u" && !r)
      throw new Ba("intrinsic " + t + " exists, but is not available. Please file an issue!");
    return {
      alias: n,
      name: i,
      value: s
    };
  }
  throw new Ja("intrinsic " + t + " does not exist!");
}, ag = function(t, r) {
  if (typeof t != "string" || t.length === 0)
    throw new Ba("intrinsic name must be a non-empty string");
  if (arguments.length > 1 && typeof r != "boolean")
    throw new Ba('"allowMissing" argument must be a boolean');
  if (Y3(/^%?[^%]*%?$/, t) === null)
    throw new Ja("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  var i = Q3(t), n = i.length > 0 ? i[0] : "", s = eM("%" + n + "%", r), a = s.name, o = s.value, c = !1, l = s.alias;
  l && (n = l[0], K3(i, G3([0, 1], l)));
  for (var d = 1, p = !0; d < i.length; d += 1) {
    var h = i[d], g = Jl(h, 0, 1), m = Jl(h, -1);
    if ((g === '"' || g === "'" || g === "`" || m === '"' || m === "'" || m === "`") && g !== m)
      throw new Ja("property names with quotes must have matching quotes");
    if ((h === "constructor" || !p) && (c = !0), n += "." + h, a = "%" + n + "%", Yl(Bs, a))
      o = Bs[a];
    else if (o != null) {
      if (!(h in o)) {
        if (!r)
          throw new Ba("base intrinsic for " + t + " exists, but the property is not available.");
        return;
      }
      if (Us && d + 1 >= i.length) {
        var v = Us(o, h);
        p = !!v, p && "get" in v && !("originalValue" in v.get) ? o = v.get : o = o[h];
      } else
        p = Yl(o, h), o = o[h];
      p && !c && (Bs[a] = o);
    }
  }
  return o;
}, sE = { exports: {} };
(function(e) {
  var t = sg, r = ag, i = r("%Function.prototype.apply%"), n = r("%Function.prototype.call%"), s = r("%Reflect.apply%", !0) || t.call(n, i), a = r("%Object.getOwnPropertyDescriptor%", !0), o = r("%Object.defineProperty%", !0), c = r("%Math.max%");
  if (o)
    try {
      o({}, "a", { value: 1 });
    } catch {
      o = null;
    }
  e.exports = function(p) {
    var h = s(t, n, arguments);
    if (a && o) {
      var g = a(h, "length");
      g.configurable && o(
        h,
        "length",
        { value: 1 + c(0, p.length - (arguments.length - 1)) }
      );
    }
    return h;
  };
  var l = function() {
    return s(t, i, arguments);
  };
  o ? o(e.exports, "apply", { value: l }) : e.exports.apply = l;
})(sE);
var aE = sE.exports, oE = ag, uE = aE, tM = uE(oE("String.prototype.indexOf")), cE = function(t, r) {
  var i = oE(t, !!r);
  return typeof i == "function" && tM(t, ".prototype.") > -1 ? uE(i) : i;
}, rM = ig(), nM = cE, Qm = nM("Object.prototype.toString"), Cf = function(t) {
  return rM && t && typeof t == "object" && Symbol.toStringTag in t ? !1 : Qm(t) === "[object Arguments]";
}, lE = function(t) {
  return Cf(t) ? !0 : t !== null && typeof t == "object" && typeof t.length == "number" && t.length >= 0 && Qm(t) !== "[object Array]" && Qm(t.callee) === "[object Function]";
}, iM = function() {
  return Cf(arguments);
}();
Cf.isLegacyArguments = lE;
var sM = iM ? Cf : lE, aM = Object.prototype.toString, oM = Function.prototype.toString, uM = /^\s*(?:function)?\*/, fE = ig(), Ep = Object.getPrototypeOf, cM = function() {
  if (!fE)
    return !1;
  try {
    return Function("return function*() {}")();
  } catch {
  }
}, xp, lM = function(t) {
  if (typeof t != "function")
    return !1;
  if (uM.test(oM.call(t)))
    return !0;
  if (!fE) {
    var r = aM.call(t);
    return r === "[object GeneratorFunction]";
  }
  if (!Ep)
    return !1;
  if (typeof xp > "u") {
    var i = cM();
    xp = i ? Ep(i) : !1;
  }
  return Ep(t) === xp;
}, dE = Function.prototype.toString, Ma = typeof Reflect == "object" && Reflect !== null && Reflect.apply, ey, gl;
if (typeof Ma == "function" && typeof Object.defineProperty == "function")
  try {
    ey = Object.defineProperty({}, "length", {
      get: function() {
        throw gl;
      }
    }), gl = {}, Ma(function() {
      throw 42;
    }, null, ey);
  } catch (e) {
    e !== gl && (Ma = null);
  }
else
  Ma = null;
var fM = /^\s*class\b/, ty = function(t) {
  try {
    var r = dE.call(t);
    return fM.test(r);
  } catch {
    return !1;
  }
}, Op = function(t) {
  try {
    return ty(t) ? !1 : (dE.call(t), !0);
  } catch {
    return !1;
  }
}, vl = Object.prototype.toString, dM = "[object Object]", pM = "[object Function]", hM = "[object GeneratorFunction]", mM = "[object HTMLAllCollection]", yM = "[object HTML document.all class]", gM = "[object HTMLCollection]", vM = typeof Symbol == "function" && !!Symbol.toStringTag, bM = !(0 in [,]), ry = function() {
  return !1;
};
if (typeof document == "object") {
  var _M = document.all;
  vl.call(_M) === vl.call(document.all) && (ry = function(t) {
    if ((bM || !t) && (typeof t > "u" || typeof t == "object"))
      try {
        var r = vl.call(t);
        return (r === mM || r === yM || r === gM || r === dM) && t("") == null;
      } catch {
      }
    return !1;
  });
}
var wM = Ma ? function(t) {
  if (ry(t))
    return !0;
  if (!t || typeof t != "function" && typeof t != "object")
    return !1;
  try {
    Ma(t, null, ey);
  } catch (r) {
    if (r !== gl)
      return !1;
  }
  return !ty(t) && Op(t);
} : function(t) {
  if (ry(t))
    return !0;
  if (!t || typeof t != "function" && typeof t != "object")
    return !1;
  if (vM)
    return Op(t);
  if (ty(t))
    return !1;
  var r = vl.call(t);
  return r !== pM && r !== hM && !/^\[object HTML/.test(r) ? !1 : Op(t);
}, $M = wM, EM = Object.prototype.toString, pE = Object.prototype.hasOwnProperty, xM = function(t, r, i) {
  for (var n = 0, s = t.length; n < s; n++)
    pE.call(t, n) && (i == null ? r(t[n], n, t) : r.call(i, t[n], n, t));
}, OM = function(t, r, i) {
  for (var n = 0, s = t.length; n < s; n++)
    i == null ? r(t.charAt(n), n, t) : r.call(i, t.charAt(n), n, t);
}, PM = function(t, r, i) {
  for (var n in t)
    pE.call(t, n) && (i == null ? r(t[n], n, t) : r.call(i, t[n], n, t));
}, SM = function(t, r, i) {
  if (!$M(r))
    throw new TypeError("iterator must be a function");
  var n;
  arguments.length >= 3 && (n = i), EM.call(t) === "[object Array]" ? xM(t, r, n) : typeof t == "string" ? OM(t, r, n) : PM(t, r, n);
}, AM = SM, Pp = [
  "BigInt64Array",
  "BigUint64Array",
  "Float32Array",
  "Float64Array",
  "Int16Array",
  "Int32Array",
  "Int8Array",
  "Uint16Array",
  "Uint32Array",
  "Uint8Array",
  "Uint8ClampedArray"
], CM = typeof globalThis > "u" ? tt : globalThis, RM = function() {
  for (var t = [], r = 0; r < Pp.length; r++)
    typeof CM[Pp[r]] == "function" && (t[t.length] = Pp[r]);
  return t;
}, TM = ag, bl = TM("%Object.getOwnPropertyDescriptor%", !0);
if (bl)
  try {
    bl([], "length");
  } catch {
    bl = null;
  }
var IM = bl, Xl = AM, jM = RM, r1 = aE, og = cE, _l = IM, kM = og("Object.prototype.toString"), hE = ig(), n1 = typeof globalThis > "u" ? tt : globalThis, ny = jM(), ug = og("String.prototype.slice"), Sp = Object.getPrototypeOf, MM = og("Array.prototype.indexOf", !0) || function(t, r) {
  for (var i = 0; i < t.length; i += 1)
    if (t[i] === r)
      return i;
  return -1;
}, Ql = { __proto__: null };
hE && _l && Sp ? Xl(ny, function(e) {
  var t = new n1[e]();
  if (Symbol.toStringTag in t) {
    var r = Sp(t), i = _l(r, Symbol.toStringTag);
    if (!i) {
      var n = Sp(r);
      i = _l(n, Symbol.toStringTag);
    }
    Ql["$" + e] = r1(i.get);
  }
}) : Xl(ny, function(e) {
  var t = new n1[e]();
  Ql["$" + e] = r1(t.slice);
});
var NM = function(t) {
  var r = !1;
  return Xl(Ql, function(i, n) {
    if (!r)
      try {
        "$" + i(t) === n && (r = ug(n, 1));
      } catch {
      }
  }), r;
}, DM = function(t) {
  var r = !1;
  return Xl(Ql, function(i, n) {
    if (!r)
      try {
        i(t), r = ug(n, 1);
      } catch {
      }
  }), r;
}, mE = function(t) {
  if (!t || typeof t != "object")
    return !1;
  if (!hE) {
    var r = ug(kM(t), 8, -1);
    return MM(ny, r) > -1 ? r : r !== "Object" ? !1 : DM(t);
  }
  return _l ? NM(t) : null;
}, LM = mE, qM = function(t) {
  return !!LM(t);
};
(function(e) {
  var t = sM, r = lM, i = mE, n = qM;
  function s($e) {
    return $e.call.bind($e);
  }
  var a = typeof BigInt < "u", o = typeof Symbol < "u", c = s(Object.prototype.toString), l = s(Number.prototype.valueOf), d = s(String.prototype.valueOf), p = s(Boolean.prototype.valueOf);
  if (a)
    var h = s(BigInt.prototype.valueOf);
  if (o)
    var g = s(Symbol.prototype.valueOf);
  function m($e, ht) {
    if (typeof $e != "object")
      return !1;
    try {
      return ht($e), !0;
    } catch {
      return !1;
    }
  }
  e.isArgumentsObject = t, e.isGeneratorFunction = r, e.isTypedArray = n;
  function v($e) {
    return typeof Promise < "u" && $e instanceof Promise || $e !== null && typeof $e == "object" && typeof $e.then == "function" && typeof $e.catch == "function";
  }
  e.isPromise = v;
  function _($e) {
    return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView($e) : n($e) || z($e);
  }
  e.isArrayBufferView = _;
  function y($e) {
    return i($e) === "Uint8Array";
  }
  e.isUint8Array = y;
  function w($e) {
    return i($e) === "Uint8ClampedArray";
  }
  e.isUint8ClampedArray = w;
  function $($e) {
    return i($e) === "Uint16Array";
  }
  e.isUint16Array = $;
  function E($e) {
    return i($e) === "Uint32Array";
  }
  e.isUint32Array = E;
  function S($e) {
    return i($e) === "Int8Array";
  }
  e.isInt8Array = S;
  function R($e) {
    return i($e) === "Int16Array";
  }
  e.isInt16Array = R;
  function j($e) {
    return i($e) === "Int32Array";
  }
  e.isInt32Array = j;
  function L($e) {
    return i($e) === "Float32Array";
  }
  e.isFloat32Array = L;
  function K($e) {
    return i($e) === "Float64Array";
  }
  e.isFloat64Array = K;
  function ae($e) {
    return i($e) === "BigInt64Array";
  }
  e.isBigInt64Array = ae;
  function ye($e) {
    return i($e) === "BigUint64Array";
  }
  e.isBigUint64Array = ye;
  function xe($e) {
    return c($e) === "[object Map]";
  }
  xe.working = typeof Map < "u" && xe(/* @__PURE__ */ new Map());
  function Pe($e) {
    return typeof Map > "u" ? !1 : xe.working ? xe($e) : $e instanceof Map;
  }
  e.isMap = Pe;
  function te($e) {
    return c($e) === "[object Set]";
  }
  te.working = typeof Set < "u" && te(/* @__PURE__ */ new Set());
  function pe($e) {
    return typeof Set > "u" ? !1 : te.working ? te($e) : $e instanceof Set;
  }
  e.isSet = pe;
  function de($e) {
    return c($e) === "[object WeakMap]";
  }
  de.working = typeof WeakMap < "u" && de(/* @__PURE__ */ new WeakMap());
  function Ee($e) {
    return typeof WeakMap > "u" ? !1 : de.working ? de($e) : $e instanceof WeakMap;
  }
  e.isWeakMap = Ee;
  function Re($e) {
    return c($e) === "[object WeakSet]";
  }
  Re.working = typeof WeakSet < "u" && Re(/* @__PURE__ */ new WeakSet());
  function _e($e) {
    return Re($e);
  }
  e.isWeakSet = _e;
  function ie($e) {
    return c($e) === "[object ArrayBuffer]";
  }
  ie.working = typeof ArrayBuffer < "u" && ie(new ArrayBuffer());
  function Y($e) {
    return typeof ArrayBuffer > "u" ? !1 : ie.working ? ie($e) : $e instanceof ArrayBuffer;
  }
  e.isArrayBuffer = Y;
  function V($e) {
    return c($e) === "[object DataView]";
  }
  V.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && V(new DataView(new ArrayBuffer(1), 0, 1));
  function z($e) {
    return typeof DataView > "u" ? !1 : V.working ? V($e) : $e instanceof DataView;
  }
  e.isDataView = z;
  var T = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
  function F($e) {
    return c($e) === "[object SharedArrayBuffer]";
  }
  function D($e) {
    return typeof T > "u" ? !1 : (typeof F.working > "u" && (F.working = F(new T())), F.working ? F($e) : $e instanceof T);
  }
  e.isSharedArrayBuffer = D;
  function U($e) {
    return c($e) === "[object AsyncFunction]";
  }
  e.isAsyncFunction = U;
  function k($e) {
    return c($e) === "[object Map Iterator]";
  }
  e.isMapIterator = k;
  function Z($e) {
    return c($e) === "[object Set Iterator]";
  }
  e.isSetIterator = Z;
  function J($e) {
    return c($e) === "[object Generator]";
  }
  e.isGeneratorObject = J;
  function A($e) {
    return c($e) === "[object WebAssembly.Module]";
  }
  e.isWebAssemblyCompiledModule = A;
  function I($e) {
    return m($e, l);
  }
  e.isNumberObject = I;
  function X($e) {
    return m($e, d);
  }
  e.isStringObject = X;
  function oe($e) {
    return m($e, p);
  }
  e.isBooleanObject = oe;
  function Ae($e) {
    return a && m($e, h);
  }
  e.isBigIntObject = Ae;
  function je($e) {
    return o && m($e, g);
  }
  e.isSymbolObject = je;
  function Be($e) {
    return I($e) || X($e) || oe($e) || Ae($e) || je($e);
  }
  e.isBoxedPrimitive = Be;
  function vt($e) {
    return typeof Uint8Array < "u" && (Y($e) || D($e));
  }
  e.isAnyArrayBuffer = vt, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function($e) {
    Object.defineProperty(e, $e, {
      enumerable: !1,
      value: function() {
        throw new Error($e + " is not supported in userland");
      }
    });
  });
})(rE);
var FM = function(t) {
  return t && typeof t == "object" && typeof t.copy == "function" && typeof t.fill == "function" && typeof t.readUInt8 == "function";
}, iy = { exports: {} };
typeof Object.create == "function" ? iy.exports = function(t, r) {
  r && (t.super_ = r, t.prototype = Object.create(r.prototype, {
    constructor: {
      value: t,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }));
} : iy.exports = function(t, r) {
  if (r) {
    t.super_ = r;
    var i = function() {
    };
    i.prototype = r.prototype, t.prototype = new i(), t.prototype.constructor = t;
  }
};
var ls = iy.exports;
(function(e) {
  var t = Object.getOwnPropertyDescriptors || function(z) {
    for (var T = Object.keys(z), F = {}, D = 0; D < T.length; D++)
      F[T[D]] = Object.getOwnPropertyDescriptor(z, T[D]);
    return F;
  }, r = /%[sdj%]/g;
  e.format = function(V) {
    if (!S(V)) {
      for (var z = [], T = 0; T < arguments.length; T++)
        z.push(a(arguments[T]));
      return z.join(" ");
    }
    for (var T = 1, F = arguments, D = F.length, U = String(V).replace(r, function(Z) {
      if (Z === "%%")
        return "%";
      if (T >= D)
        return Z;
      switch (Z) {
        case "%s":
          return String(F[T++]);
        case "%d":
          return Number(F[T++]);
        case "%j":
          try {
            return JSON.stringify(F[T++]);
          } catch {
            return "[Circular]";
          }
        default:
          return Z;
      }
    }), k = F[T]; T < D; k = F[++T])
      w(k) || !K(k) ? U += " " + k : U += " " + a(k);
    return U;
  }, e.deprecate = function(V, z) {
    if (typeof qe.process < "u" && qe.process.noDeprecation === !0)
      return V;
    if (typeof qe.process > "u")
      return function() {
        return e.deprecate(V, z).apply(this, arguments);
      };
    var T = !1;
    function F() {
      if (!T) {
        if (qe.process.throwDeprecation)
          throw new Error(z);
        qe.process.traceDeprecation ? console.trace(z) : console.error(z), T = !0;
      }
      return V.apply(this, arguments);
    }
    return F;
  };
  var i = {}, n = /^$/;
  if (qe.process.env.NODE_DEBUG) {
    var s = qe.process.env.NODE_DEBUG;
    s = s.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), n = new RegExp("^" + s + "$", "i");
  }
  e.debuglog = function(V) {
    if (V = V.toUpperCase(), !i[V])
      if (n.test(V)) {
        var z = qe.process.pid;
        i[V] = function() {
          var T = e.format.apply(e, arguments);
          console.error("%s %d: %s", V, z, T);
        };
      } else
        i[V] = function() {
        };
    return i[V];
  };
  function a(V, z) {
    var T = {
      seen: [],
      stylize: c
    };
    return arguments.length >= 3 && (T.depth = arguments[2]), arguments.length >= 4 && (T.colors = arguments[3]), y(z) ? T.showHidden = z : z && e._extend(T, z), j(T.showHidden) && (T.showHidden = !1), j(T.depth) && (T.depth = 2), j(T.colors) && (T.colors = !1), j(T.customInspect) && (T.customInspect = !0), T.colors && (T.stylize = o), d(T, V, T.depth);
  }
  e.inspect = a, a.colors = {
    bold: [1, 22],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    white: [37, 39],
    grey: [90, 39],
    black: [30, 39],
    blue: [34, 39],
    cyan: [36, 39],
    green: [32, 39],
    magenta: [35, 39],
    red: [31, 39],
    yellow: [33, 39]
  }, a.styles = {
    special: "cyan",
    number: "yellow",
    boolean: "yellow",
    undefined: "grey",
    null: "bold",
    string: "green",
    date: "magenta",
    // "name": intentionally not styling
    regexp: "red"
  };
  function o(V, z) {
    var T = a.styles[z];
    return T ? "\x1B[" + a.colors[T][0] + "m" + V + "\x1B[" + a.colors[T][1] + "m" : V;
  }
  function c(V, z) {
    return V;
  }
  function l(V) {
    var z = {};
    return V.forEach(function(T, F) {
      z[T] = !0;
    }), z;
  }
  function d(V, z, T) {
    if (V.customInspect && z && xe(z.inspect) && // Filter out the util module, it's inspect function is special
    z.inspect !== e.inspect && // Also filter out any prototype objects using the circular check.
    !(z.constructor && z.constructor.prototype === z)) {
      var F = z.inspect(T, V);
      return S(F) || (F = d(V, F, T)), F;
    }
    var D = p(V, z);
    if (D)
      return D;
    var U = Object.keys(z), k = l(U);
    if (V.showHidden && (U = Object.getOwnPropertyNames(z)), ye(z) && (U.indexOf("message") >= 0 || U.indexOf("description") >= 0))
      return h(z);
    if (U.length === 0) {
      if (xe(z)) {
        var Z = z.name ? ": " + z.name : "";
        return V.stylize("[Function" + Z + "]", "special");
      }
      if (L(z))
        return V.stylize(RegExp.prototype.toString.call(z), "regexp");
      if (ae(z))
        return V.stylize(Date.prototype.toString.call(z), "date");
      if (ye(z))
        return h(z);
    }
    var J = "", A = !1, I = ["{", "}"];
    if (_(z) && (A = !0, I = ["[", "]"]), xe(z)) {
      var X = z.name ? ": " + z.name : "";
      J = " [Function" + X + "]";
    }
    if (L(z) && (J = " " + RegExp.prototype.toString.call(z)), ae(z) && (J = " " + Date.prototype.toUTCString.call(z)), ye(z) && (J = " " + h(z)), U.length === 0 && (!A || z.length == 0))
      return I[0] + J + I[1];
    if (T < 0)
      return L(z) ? V.stylize(RegExp.prototype.toString.call(z), "regexp") : V.stylize("[Object]", "special");
    V.seen.push(z);
    var oe;
    return A ? oe = g(V, z, T, k, U) : oe = U.map(function(Ae) {
      return m(V, z, T, k, Ae, A);
    }), V.seen.pop(), v(oe, J, I);
  }
  function p(V, z) {
    if (j(z))
      return V.stylize("undefined", "undefined");
    if (S(z)) {
      var T = "'" + JSON.stringify(z).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return V.stylize(T, "string");
    }
    if (E(z))
      return V.stylize("" + z, "number");
    if (y(z))
      return V.stylize("" + z, "boolean");
    if (w(z))
      return V.stylize("null", "null");
  }
  function h(V) {
    return "[" + Error.prototype.toString.call(V) + "]";
  }
  function g(V, z, T, F, D) {
    for (var U = [], k = 0, Z = z.length; k < Z; ++k)
      Re(z, String(k)) ? U.push(m(
        V,
        z,
        T,
        F,
        String(k),
        !0
      )) : U.push("");
    return D.forEach(function(J) {
      J.match(/^\d+$/) || U.push(m(
        V,
        z,
        T,
        F,
        J,
        !0
      ));
    }), U;
  }
  function m(V, z, T, F, D, U) {
    var k, Z, J;
    if (J = Object.getOwnPropertyDescriptor(z, D) || { value: z[D] }, J.get ? J.set ? Z = V.stylize("[Getter/Setter]", "special") : Z = V.stylize("[Getter]", "special") : J.set && (Z = V.stylize("[Setter]", "special")), Re(F, D) || (k = "[" + D + "]"), Z || (V.seen.indexOf(J.value) < 0 ? (w(T) ? Z = d(V, J.value, null) : Z = d(V, J.value, T - 1), Z.indexOf(`
`) > -1 && (U ? Z = Z.split(`
`).map(function(A) {
      return "  " + A;
    }).join(`
`).slice(2) : Z = `
` + Z.split(`
`).map(function(A) {
      return "   " + A;
    }).join(`
`))) : Z = V.stylize("[Circular]", "special")), j(k)) {
      if (U && D.match(/^\d+$/))
        return Z;
      k = JSON.stringify("" + D), k.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (k = k.slice(1, -1), k = V.stylize(k, "name")) : (k = k.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), k = V.stylize(k, "string"));
    }
    return k + ": " + Z;
  }
  function v(V, z, T) {
    var F = V.reduce(function(D, U) {
      return U.indexOf(`
`) >= 0, D + U.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    return F > 60 ? T[0] + (z === "" ? "" : z + `
 `) + " " + V.join(`,
  `) + " " + T[1] : T[0] + z + " " + V.join(", ") + " " + T[1];
  }
  e.types = rE;
  function _(V) {
    return Array.isArray(V);
  }
  e.isArray = _;
  function y(V) {
    return typeof V == "boolean";
  }
  e.isBoolean = y;
  function w(V) {
    return V === null;
  }
  e.isNull = w;
  function $(V) {
    return V == null;
  }
  e.isNullOrUndefined = $;
  function E(V) {
    return typeof V == "number";
  }
  e.isNumber = E;
  function S(V) {
    return typeof V == "string";
  }
  e.isString = S;
  function R(V) {
    return typeof V == "symbol";
  }
  e.isSymbol = R;
  function j(V) {
    return V === void 0;
  }
  e.isUndefined = j;
  function L(V) {
    return K(V) && te(V) === "[object RegExp]";
  }
  e.isRegExp = L, e.types.isRegExp = L;
  function K(V) {
    return typeof V == "object" && V !== null;
  }
  e.isObject = K;
  function ae(V) {
    return K(V) && te(V) === "[object Date]";
  }
  e.isDate = ae, e.types.isDate = ae;
  function ye(V) {
    return K(V) && (te(V) === "[object Error]" || V instanceof Error);
  }
  e.isError = ye, e.types.isNativeError = ye;
  function xe(V) {
    return typeof V == "function";
  }
  e.isFunction = xe;
  function Pe(V) {
    return V === null || typeof V == "boolean" || typeof V == "number" || typeof V == "string" || typeof V == "symbol" || // ES6 symbol
    typeof V > "u";
  }
  e.isPrimitive = Pe, e.isBuffer = FM;
  function te(V) {
    return Object.prototype.toString.call(V);
  }
  function pe(V) {
    return V < 10 ? "0" + V.toString(10) : V.toString(10);
  }
  var de = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ];
  function Ee() {
    var V = /* @__PURE__ */ new Date(), z = [
      pe(V.getHours()),
      pe(V.getMinutes()),
      pe(V.getSeconds())
    ].join(":");
    return [V.getDate(), de[V.getMonth()], z].join(" ");
  }
  e.log = function() {
    console.log("%s - %s", Ee(), e.format.apply(e, arguments));
  }, e.inherits = ls, e._extend = function(V, z) {
    if (!z || !K(z))
      return V;
    for (var T = Object.keys(z), F = T.length; F--; )
      V[T[F]] = z[T[F]];
    return V;
  };
  function Re(V, z) {
    return Object.prototype.hasOwnProperty.call(V, z);
  }
  var _e = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
  e.promisify = function(z) {
    if (typeof z != "function")
      throw new TypeError('The "original" argument must be of type Function');
    if (_e && z[_e]) {
      var T = z[_e];
      if (typeof T != "function")
        throw new TypeError('The "util.promisify.custom" argument must be of type Function');
      return Object.defineProperty(T, _e, {
        value: T,
        enumerable: !1,
        writable: !1,
        configurable: !0
      }), T;
    }
    function T() {
      for (var F, D, U = new Promise(function(J, A) {
        F = J, D = A;
      }), k = [], Z = 0; Z < arguments.length; Z++)
        k.push(arguments[Z]);
      k.push(function(J, A) {
        J ? D(J) : F(A);
      });
      try {
        z.apply(this, k);
      } catch (J) {
        D(J);
      }
      return U;
    }
    return Object.setPrototypeOf(T, Object.getPrototypeOf(z)), _e && Object.defineProperty(T, _e, {
      value: T,
      enumerable: !1,
      writable: !1,
      configurable: !0
    }), Object.defineProperties(
      T,
      t(z)
    );
  }, e.promisify.custom = _e;
  function ie(V, z) {
    if (!V) {
      var T = new Error("Promise was rejected with a falsy value");
      T.reason = V, V = T;
    }
    return z(V);
  }
  function Y(V) {
    if (typeof V != "function")
      throw new TypeError('The "original" argument must be of type Function');
    function z() {
      for (var T = [], F = 0; F < arguments.length; F++)
        T.push(arguments[F]);
      var D = T.pop();
      if (typeof D != "function")
        throw new TypeError("The last argument must be of type Function");
      var U = this, k = function() {
        return D.apply(U, arguments);
      };
      V.apply(this, T).then(
        function(Z) {
          qe.process.nextTick(k.bind(null, null, Z));
        },
        function(Z) {
          qe.process.nextTick(ie.bind(null, Z, k));
        }
      );
    }
    return Object.setPrototypeOf(z, Object.getPrototypeOf(V)), Object.defineProperties(
      z,
      t(V)
    ), z;
  }
  e.callbackify = Y;
})(no);
var cg = { exports: {} }, Va = typeof Reflect == "object" ? Reflect : null, i1 = Va && typeof Va.apply == "function" ? Va.apply : function(t, r, i) {
  return Function.prototype.apply.call(t, r, i);
}, wl;
Va && typeof Va.ownKeys == "function" ? wl = Va.ownKeys : Object.getOwnPropertySymbols ? wl = function(t) {
  return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t));
} : wl = function(t) {
  return Object.getOwnPropertyNames(t);
};
function UM(e) {
  console && console.warn && console.warn(e);
}
var yE = Number.isNaN || function(t) {
  return t !== t;
};
function Ut() {
  Ut.init.call(this);
}
cg.exports = Ut;
cg.exports.once = zM;
Ut.EventEmitter = Ut;
Ut.prototype._events = void 0;
Ut.prototype._eventsCount = 0;
Ut.prototype._maxListeners = void 0;
var s1 = 10;
function Rf(e) {
  if (typeof e != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e);
}
Object.defineProperty(Ut, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return s1;
  },
  set: function(e) {
    if (typeof e != "number" || e < 0 || yE(e))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e + ".");
    s1 = e;
  }
});
Ut.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
Ut.prototype.setMaxListeners = function(t) {
  if (typeof t != "number" || t < 0 || yE(t))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
  return this._maxListeners = t, this;
};
function gE(e) {
  return e._maxListeners === void 0 ? Ut.defaultMaxListeners : e._maxListeners;
}
Ut.prototype.getMaxListeners = function() {
  return gE(this);
};
Ut.prototype.emit = function(t) {
  for (var r = [], i = 1; i < arguments.length; i++)
    r.push(arguments[i]);
  var n = t === "error", s = this._events;
  if (s !== void 0)
    n = n && s.error === void 0;
  else if (!n)
    return !1;
  if (n) {
    var a;
    if (r.length > 0 && (a = r[0]), a instanceof Error)
      throw a;
    var o = new Error("Unhandled error." + (a ? " (" + a.message + ")" : ""));
    throw o.context = a, o;
  }
  var c = s[t];
  if (c === void 0)
    return !1;
  if (typeof c == "function")
    i1(c, this, r);
  else
    for (var l = c.length, d = $E(c, l), i = 0; i < l; ++i)
      i1(d[i], this, r);
  return !0;
};
function vE(e, t, r, i) {
  var n, s, a;
  if (Rf(r), s = e._events, s === void 0 ? (s = e._events = /* @__PURE__ */ Object.create(null), e._eventsCount = 0) : (s.newListener !== void 0 && (e.emit(
    "newListener",
    t,
    r.listener ? r.listener : r
  ), s = e._events), a = s[t]), a === void 0)
    a = s[t] = r, ++e._eventsCount;
  else if (typeof a == "function" ? a = s[t] = i ? [r, a] : [a, r] : i ? a.unshift(r) : a.push(r), n = gE(e), n > 0 && a.length > n && !a.warned) {
    a.warned = !0;
    var o = new Error("Possible EventEmitter memory leak detected. " + a.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    o.name = "MaxListenersExceededWarning", o.emitter = e, o.type = t, o.count = a.length, UM(o);
  }
  return e;
}
Ut.prototype.addListener = function(t, r) {
  return vE(this, t, r, !1);
};
Ut.prototype.on = Ut.prototype.addListener;
Ut.prototype.prependListener = function(t, r) {
  return vE(this, t, r, !0);
};
function BM() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function bE(e, t, r) {
  var i = { fired: !1, wrapFn: void 0, target: e, type: t, listener: r }, n = BM.bind(i);
  return n.listener = r, i.wrapFn = n, n;
}
Ut.prototype.once = function(t, r) {
  return Rf(r), this.on(t, bE(this, t, r)), this;
};
Ut.prototype.prependOnceListener = function(t, r) {
  return Rf(r), this.prependListener(t, bE(this, t, r)), this;
};
Ut.prototype.removeListener = function(t, r) {
  var i, n, s, a, o;
  if (Rf(r), n = this._events, n === void 0)
    return this;
  if (i = n[t], i === void 0)
    return this;
  if (i === r || i.listener === r)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete n[t], n.removeListener && this.emit("removeListener", t, i.listener || r));
  else if (typeof i != "function") {
    for (s = -1, a = i.length - 1; a >= 0; a--)
      if (i[a] === r || i[a].listener === r) {
        o = i[a].listener, s = a;
        break;
      }
    if (s < 0)
      return this;
    s === 0 ? i.shift() : VM(i, s), i.length === 1 && (n[t] = i[0]), n.removeListener !== void 0 && this.emit("removeListener", t, o || r);
  }
  return this;
};
Ut.prototype.off = Ut.prototype.removeListener;
Ut.prototype.removeAllListeners = function(t) {
  var r, i, n;
  if (i = this._events, i === void 0)
    return this;
  if (i.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : i[t] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete i[t]), this;
  if (arguments.length === 0) {
    var s = Object.keys(i), a;
    for (n = 0; n < s.length; ++n)
      a = s[n], a !== "removeListener" && this.removeAllListeners(a);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (r = i[t], typeof r == "function")
    this.removeListener(t, r);
  else if (r !== void 0)
    for (n = r.length - 1; n >= 0; n--)
      this.removeListener(t, r[n]);
  return this;
};
function _E(e, t, r) {
  var i = e._events;
  if (i === void 0)
    return [];
  var n = i[t];
  return n === void 0 ? [] : typeof n == "function" ? r ? [n.listener || n] : [n] : r ? ZM(n) : $E(n, n.length);
}
Ut.prototype.listeners = function(t) {
  return _E(this, t, !0);
};
Ut.prototype.rawListeners = function(t) {
  return _E(this, t, !1);
};
Ut.listenerCount = function(e, t) {
  return typeof e.listenerCount == "function" ? e.listenerCount(t) : wE.call(e, t);
};
Ut.prototype.listenerCount = wE;
function wE(e) {
  var t = this._events;
  if (t !== void 0) {
    var r = t[e];
    if (typeof r == "function")
      return 1;
    if (r !== void 0)
      return r.length;
  }
  return 0;
}
Ut.prototype.eventNames = function() {
  return this._eventsCount > 0 ? wl(this._events) : [];
};
function $E(e, t) {
  for (var r = new Array(t), i = 0; i < t; ++i)
    r[i] = e[i];
  return r;
}
function VM(e, t) {
  for (; t + 1 < e.length; t++)
    e[t] = e[t + 1];
  e.pop();
}
function ZM(e) {
  for (var t = new Array(e.length), r = 0; r < t.length; ++r)
    t[r] = e[r].listener || e[r];
  return t;
}
function zM(e, t) {
  return new Promise(function(r, i) {
    function n(a) {
      e.removeListener(t, s), i(a);
    }
    function s() {
      typeof e.removeListener == "function" && e.removeListener("error", n), r([].slice.call(arguments));
    }
    EE(e, t, s, { once: !0 }), t !== "error" && WM(e, n, { once: !0 });
  });
}
function WM(e, t, r) {
  typeof e.on == "function" && EE(e, "error", t, r);
}
function EE(e, t, r, i) {
  if (typeof e.on == "function")
    i.once ? e.once(t, r) : e.on(t, r);
  else if (typeof e.addEventListener == "function")
    e.addEventListener(t, function n(s) {
      i.once && e.removeEventListener(t, n), r(s);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e);
}
var lg = cg.exports, HM = no, GM = lg;
function fs(e) {
  e = e || {}, this._store = {}, this._size = 0, this._ttl = Number(e.ttl), this._capacity = 1 / 0, this.setCapacity(e.capacity);
}
HM.inherits(fs, GM.EventEmitter);
fs.prototype.put = function(e, t, r) {
  if (!(e === void 0 || t === void 0)) {
    if (!this._store[e] && this.size() >= this._capacity) {
      this.emit("drop", e, t, r);
      return;
    }
    r = r === void 0 ? this._ttl : Number(r), this.del(e), this._store[e] = {
      val: t,
      expire: xE() + r,
      timeout: setTimeout((function() {
        this.del(e);
      }).bind(this), r)
    }, this._store[e].timeout.unref(), this._size += 1, this.emit("put", e, t, r);
  }
};
fs.prototype.get = function(e) {
  var t = this._store[e];
  return t ? t.expire && t.expire > xE() ? this.emit("hit", e, t.val) : (this.del(e), this.emit("miss", e), t = void 0) : this.emit("miss", e), t && t.val;
};
fs.prototype.del = function(e) {
  if (this._store[e]) {
    var t = this._store[e].val;
    return clearTimeout(this._store[e].timeout), delete this._store[e], this._size -= 1, this.emit("del", e, t), t;
  }
};
fs.prototype.clear = function() {
  Object.keys(this._store).forEach((function(e) {
    this.del(e);
  }).bind(this));
};
fs.prototype.size = function(e) {
  return e ? Object.keys(this._store).reduce((function(t, r) {
    return t + (this.get(r) !== void 0 ? 1 : 0);
  }).bind(this), 0) : this._size;
};
fs.prototype.setCapacity = function(e) {
  typeof e == "number" && e >= 0 && (this._capacity = e);
};
function xE() {
  return Date.now();
}
var KM = fs;
const Vu = /* @__PURE__ */ Ks(KM);
let Tf = (e = 21) => crypto.getRandomValues(new Uint8Array(e)).reduce((t, r) => (r &= 63, r < 36 ? t += r.toString(36) : r < 62 ? t += (r - 26).toString(36).toUpperCase() : r > 62 ? t += "-" : t += "_", t), "");
var OE = {}, Hs = {}, fg = {};
Object.defineProperty(fg, "__esModule", { value: !0 });
const a1 = (e) => {
  if (typeof e == "object" && e !== null) {
    if (typeof Object.getPrototypeOf == "function") {
      const t = Object.getPrototypeOf(e);
      return t === Object.prototype || t === null;
    }
    return Object.prototype.toString.call(e) === "[object Object]";
  }
  return !1;
}, Hn = (...e) => e.reduce((t, r) => {
  if (Array.isArray(r))
    throw new TypeError("Arguments provided to ts-deepmerge must be objects, not arrays.");
  return Object.keys(r).forEach((i) => {
    ["__proto__", "constructor", "prototype"].includes(i) || (Array.isArray(t[i]) && Array.isArray(r[i]) ? t[i] = Hn.options.mergeArrays ? Hn.options.uniqueArrayItems ? Array.from(new Set(t[i].concat(r[i]))) : [...t[i], ...r[i]] : r[i] : a1(t[i]) && a1(r[i]) ? t[i] = Hn(t[i], r[i]) : t[i] = r[i] === void 0 ? Hn.options.allowUndefinedOverrides ? r[i] : t[i] : r[i]);
  }), t;
}, {}), sy = {
  allowUndefinedOverrides: !0,
  mergeArrays: !0,
  uniqueArrayItems: !0
};
Hn.options = sy;
Hn.withOptions = (e, ...t) => {
  Hn.options = Object.assign(Object.assign({}, sy), e);
  const r = Hn(...t);
  return Hn.options = sy, r;
};
fg.default = Hn;
var PE = {}, ay = {}, Gn = {}, If = {}, Zu = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.getParsedType = e.ZodParsedType = e.objectUtil = e.util = void 0;
  var t;
  (function(i) {
    i.assertEqual = (o) => o;
    function n(o) {
    }
    i.assertIs = n;
    function s(o) {
      throw new Error();
    }
    i.assertNever = s, i.arrayToEnum = (o) => {
      const c = {};
      for (const l of o)
        c[l] = l;
      return c;
    }, i.getValidEnumValues = (o) => {
      const c = i.objectKeys(o).filter((d) => typeof o[o[d]] != "number"), l = {};
      for (const d of c)
        l[d] = o[d];
      return i.objectValues(l);
    }, i.objectValues = (o) => i.objectKeys(o).map(function(c) {
      return o[c];
    }), i.objectKeys = typeof Object.keys == "function" ? (o) => Object.keys(o) : (o) => {
      const c = [];
      for (const l in o)
        Object.prototype.hasOwnProperty.call(o, l) && c.push(l);
      return c;
    }, i.find = (o, c) => {
      for (const l of o)
        if (c(l))
          return l;
    }, i.isInteger = typeof Number.isInteger == "function" ? (o) => Number.isInteger(o) : (o) => typeof o == "number" && isFinite(o) && Math.floor(o) === o;
    function a(o, c = " | ") {
      return o.map((l) => typeof l == "string" ? `'${l}'` : l).join(c);
    }
    i.joinValues = a, i.jsonStringifyReplacer = (o, c) => typeof c == "bigint" ? c.toString() : c;
  })(t = e.util || (e.util = {})), function(i) {
    i.mergeShapes = (n, s) => ({
      ...n,
      ...s
    });
  }(e.objectUtil || (e.objectUtil = {})), e.ZodParsedType = t.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set"
  ]);
  const r = (i) => {
    switch (typeof i) {
      case "undefined":
        return e.ZodParsedType.undefined;
      case "string":
        return e.ZodParsedType.string;
      case "number":
        return isNaN(i) ? e.ZodParsedType.nan : e.ZodParsedType.number;
      case "boolean":
        return e.ZodParsedType.boolean;
      case "function":
        return e.ZodParsedType.function;
      case "bigint":
        return e.ZodParsedType.bigint;
      case "symbol":
        return e.ZodParsedType.symbol;
      case "object":
        return Array.isArray(i) ? e.ZodParsedType.array : i === null ? e.ZodParsedType.null : i.then && typeof i.then == "function" && i.catch && typeof i.catch == "function" ? e.ZodParsedType.promise : typeof Map < "u" && i instanceof Map ? e.ZodParsedType.map : typeof Set < "u" && i instanceof Set ? e.ZodParsedType.set : typeof Date < "u" && i instanceof Date ? e.ZodParsedType.date : e.ZodParsedType.object;
      default:
        return e.ZodParsedType.unknown;
    }
  };
  e.getParsedType = r;
})(Zu);
var Kn = {};
Object.defineProperty(Kn, "__esModule", { value: !0 });
Kn.ZodError = Kn.quotelessJson = Kn.ZodIssueCode = void 0;
const SE = Zu;
Kn.ZodIssueCode = SE.util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
const YM = (e) => JSON.stringify(e, null, 2).replace(/"([^"]+)":/g, "$1:");
Kn.quotelessJson = YM;
class oy extends Error {
  constructor(t) {
    super(), this.issues = [], this.addIssue = (i) => {
      this.issues = [...this.issues, i];
    }, this.addIssues = (i = []) => {
      this.issues = [...this.issues, ...i];
    };
    const r = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, r) : this.__proto__ = r, this.name = "ZodError", this.issues = t;
  }
  get errors() {
    return this.issues;
  }
  format(t) {
    const r = t || function(s) {
      return s.message;
    }, i = { _errors: [] }, n = (s) => {
      for (const a of s.issues)
        if (a.code === "invalid_union")
          a.unionErrors.map(n);
        else if (a.code === "invalid_return_type")
          n(a.returnTypeError);
        else if (a.code === "invalid_arguments")
          n(a.argumentsError);
        else if (a.path.length === 0)
          i._errors.push(r(a));
        else {
          let o = i, c = 0;
          for (; c < a.path.length; ) {
            const l = a.path[c];
            c === a.path.length - 1 ? (o[l] = o[l] || { _errors: [] }, o[l]._errors.push(r(a))) : o[l] = o[l] || { _errors: [] }, o = o[l], c++;
          }
        }
    };
    return n(this), i;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, SE.util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(t = (r) => r.message) {
    const r = {}, i = [];
    for (const n of this.issues)
      n.path.length > 0 ? (r[n.path[0]] = r[n.path[0]] || [], r[n.path[0]].push(t(n))) : i.push(t(n));
    return { formErrors: i, fieldErrors: r };
  }
  get formErrors() {
    return this.flatten();
  }
}
Kn.ZodError = oy;
oy.create = (e) => new oy(e);
Object.defineProperty(If, "__esModule", { value: !0 });
const Cs = Zu, _r = Kn, JM = (e, t) => {
  let r;
  switch (e.code) {
    case _r.ZodIssueCode.invalid_type:
      e.received === Cs.ZodParsedType.undefined ? r = "Required" : r = `Expected ${e.expected}, received ${e.received}`;
      break;
    case _r.ZodIssueCode.invalid_literal:
      r = `Invalid literal value, expected ${JSON.stringify(e.expected, Cs.util.jsonStringifyReplacer)}`;
      break;
    case _r.ZodIssueCode.unrecognized_keys:
      r = `Unrecognized key(s) in object: ${Cs.util.joinValues(e.keys, ", ")}`;
      break;
    case _r.ZodIssueCode.invalid_union:
      r = "Invalid input";
      break;
    case _r.ZodIssueCode.invalid_union_discriminator:
      r = `Invalid discriminator value. Expected ${Cs.util.joinValues(e.options)}`;
      break;
    case _r.ZodIssueCode.invalid_enum_value:
      r = `Invalid enum value. Expected ${Cs.util.joinValues(e.options)}, received '${e.received}'`;
      break;
    case _r.ZodIssueCode.invalid_arguments:
      r = "Invalid function arguments";
      break;
    case _r.ZodIssueCode.invalid_return_type:
      r = "Invalid function return type";
      break;
    case _r.ZodIssueCode.invalid_date:
      r = "Invalid date";
      break;
    case _r.ZodIssueCode.invalid_string:
      typeof e.validation == "object" ? "includes" in e.validation ? (r = `Invalid input: must include "${e.validation.includes}"`, typeof e.validation.position == "number" && (r = `${r} at one or more positions greater than or equal to ${e.validation.position}`)) : "startsWith" in e.validation ? r = `Invalid input: must start with "${e.validation.startsWith}"` : "endsWith" in e.validation ? r = `Invalid input: must end with "${e.validation.endsWith}"` : Cs.util.assertNever(e.validation) : e.validation !== "regex" ? r = `Invalid ${e.validation}` : r = "Invalid";
      break;
    case _r.ZodIssueCode.too_small:
      e.type === "array" ? r = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "more than"} ${e.minimum} element(s)` : e.type === "string" ? r = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "over"} ${e.minimum} character(s)` : e.type === "number" ? r = `Number must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${e.minimum}` : e.type === "date" ? r = `Date must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(e.minimum))}` : r = "Invalid input";
      break;
    case _r.ZodIssueCode.too_big:
      e.type === "array" ? r = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "less than"} ${e.maximum} element(s)` : e.type === "string" ? r = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "under"} ${e.maximum} character(s)` : e.type === "number" ? r = `Number must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "bigint" ? r = `BigInt must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "date" ? r = `Date must be ${e.exact ? "exactly" : e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(e.maximum))}` : r = "Invalid input";
      break;
    case _r.ZodIssueCode.custom:
      r = "Invalid input";
      break;
    case _r.ZodIssueCode.invalid_intersection_types:
      r = "Intersection results could not be merged";
      break;
    case _r.ZodIssueCode.not_multiple_of:
      r = `Number must be a multiple of ${e.multipleOf}`;
      break;
    case _r.ZodIssueCode.not_finite:
      r = "Number must be finite";
      break;
    default:
      r = t.defaultError, Cs.util.assertNever(e);
  }
  return { message: r };
};
If.default = JM;
var XM = tt && tt.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Gn, "__esModule", { value: !0 });
Gn.getErrorMap = Gn.setErrorMap = Gn.defaultErrorMap = void 0;
const AE = XM(If);
Gn.defaultErrorMap = AE.default;
let CE = AE.default;
function QM(e) {
  CE = e;
}
Gn.setErrorMap = QM;
function eN() {
  return CE;
}
Gn.getErrorMap = eN;
var dg = {};
(function(e) {
  var t = tt && tt.__importDefault || function(g) {
    return g && g.__esModule ? g : { default: g };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.isAsync = e.isValid = e.isDirty = e.isAborted = e.OK = e.DIRTY = e.INVALID = e.ParseStatus = e.addIssueToContext = e.EMPTY_PATH = e.makeIssue = void 0;
  const r = Gn, i = t(If), n = (g) => {
    const { data: m, path: v, errorMaps: _, issueData: y } = g, w = [...v, ...y.path || []], $ = {
      ...y,
      path: w
    };
    let E = "";
    const S = _.filter((R) => !!R).slice().reverse();
    for (const R of S)
      E = R($, { data: m, defaultError: E }).message;
    return {
      ...y,
      path: w,
      message: y.message || E
    };
  };
  e.makeIssue = n, e.EMPTY_PATH = [];
  function s(g, m) {
    const v = (0, e.makeIssue)({
      issueData: m,
      data: g.data,
      path: g.path,
      errorMaps: [
        g.common.contextualErrorMap,
        g.schemaErrorMap,
        (0, r.getErrorMap)(),
        i.default
      ].filter((_) => !!_)
    });
    g.common.issues.push(v);
  }
  e.addIssueToContext = s;
  class a {
    constructor() {
      this.value = "valid";
    }
    dirty() {
      this.value === "valid" && (this.value = "dirty");
    }
    abort() {
      this.value !== "aborted" && (this.value = "aborted");
    }
    static mergeArray(m, v) {
      const _ = [];
      for (const y of v) {
        if (y.status === "aborted")
          return e.INVALID;
        y.status === "dirty" && m.dirty(), _.push(y.value);
      }
      return { status: m.value, value: _ };
    }
    static async mergeObjectAsync(m, v) {
      const _ = [];
      for (const y of v)
        _.push({
          key: await y.key,
          value: await y.value
        });
      return a.mergeObjectSync(m, _);
    }
    static mergeObjectSync(m, v) {
      const _ = {};
      for (const y of v) {
        const { key: w, value: $ } = y;
        if (w.status === "aborted" || $.status === "aborted")
          return e.INVALID;
        w.status === "dirty" && m.dirty(), $.status === "dirty" && m.dirty(), w.value !== "__proto__" && (typeof $.value < "u" || y.alwaysSet) && (_[w.value] = $.value);
      }
      return { status: m.value, value: _ };
    }
  }
  e.ParseStatus = a, e.INVALID = Object.freeze({
    status: "aborted"
  });
  const o = (g) => ({ status: "dirty", value: g });
  e.DIRTY = o;
  const c = (g) => ({ status: "valid", value: g });
  e.OK = c;
  const l = (g) => g.status === "aborted";
  e.isAborted = l;
  const d = (g) => g.status === "dirty";
  e.isDirty = d;
  const p = (g) => g.status === "valid";
  e.isValid = p;
  const h = (g) => typeof Promise < "u" && g instanceof Promise;
  e.isAsync = h;
})(dg);
var RE = {};
Object.defineProperty(RE, "__esModule", { value: !0 });
var TE = {}, IE = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.errorUtil = void 0, function(t) {
    t.errToObj = (r) => typeof r == "string" ? { message: r } : r || {}, t.toString = (r) => typeof r == "string" ? r : r == null ? void 0 : r.message;
  }(e.errorUtil || (e.errorUtil = {}));
})(IE);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.date = e.boolean = e.bigint = e.array = e.any = e.coerce = e.ZodFirstPartyTypeKind = e.late = e.ZodSchema = e.Schema = e.custom = e.ZodReadonly = e.ZodPipeline = e.ZodBranded = e.BRAND = e.ZodNaN = e.ZodCatch = e.ZodDefault = e.ZodNullable = e.ZodOptional = e.ZodTransformer = e.ZodEffects = e.ZodPromise = e.ZodNativeEnum = e.ZodEnum = e.ZodLiteral = e.ZodLazy = e.ZodFunction = e.ZodSet = e.ZodMap = e.ZodRecord = e.ZodTuple = e.ZodIntersection = e.ZodDiscriminatedUnion = e.ZodUnion = e.ZodObject = e.ZodArray = e.ZodVoid = e.ZodNever = e.ZodUnknown = e.ZodAny = e.ZodNull = e.ZodUndefined = e.ZodSymbol = e.ZodDate = e.ZodBoolean = e.ZodBigInt = e.ZodNumber = e.ZodString = e.ZodType = void 0, e.NEVER = e.void = e.unknown = e.union = e.undefined = e.tuple = e.transformer = e.symbol = e.string = e.strictObject = e.set = e.record = e.promise = e.preprocess = e.pipeline = e.ostring = e.optional = e.onumber = e.oboolean = e.object = e.number = e.nullable = e.null = e.never = e.nativeEnum = e.nan = e.map = e.literal = e.lazy = e.intersection = e.instanceof = e.function = e.enum = e.effect = e.discriminatedUnion = void 0;
  const t = Gn, r = IE, i = dg, n = Zu, s = Kn;
  class a {
    constructor(O, M, W, se) {
      this._cachedPath = [], this.parent = O, this.data = M, this._path = W, this._key = se;
    }
    get path() {
      return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
    }
  }
  const o = (ee, O) => {
    if ((0, i.isValid)(O))
      return { success: !0, data: O.value };
    if (!ee.common.issues.length)
      throw new Error("Validation failed but no issues detected.");
    return {
      success: !1,
      get error() {
        if (this._error)
          return this._error;
        const M = new s.ZodError(ee.common.issues);
        return this._error = M, this._error;
      }
    };
  };
  function c(ee) {
    if (!ee)
      return {};
    const { errorMap: O, invalid_type_error: M, required_error: W, description: se } = ee;
    if (O && (M || W))
      throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    return O ? { errorMap: O, description: se } : { errorMap: (Me, Ce) => Me.code !== "invalid_type" ? { message: Ce.defaultError } : typeof Ce.data > "u" ? { message: W ?? Ce.defaultError } : { message: M ?? Ce.defaultError }, description: se };
  }
  class l {
    constructor(O) {
      this.spa = this.safeParseAsync, this._def = O, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
    }
    get description() {
      return this._def.description;
    }
    _getType(O) {
      return (0, n.getParsedType)(O.data);
    }
    _getOrReturnCtx(O, M) {
      return M || {
        common: O.parent.common,
        data: O.data,
        parsedType: (0, n.getParsedType)(O.data),
        schemaErrorMap: this._def.errorMap,
        path: O.path,
        parent: O.parent
      };
    }
    _processInputParams(O) {
      return {
        status: new i.ParseStatus(),
        ctx: {
          common: O.parent.common,
          data: O.data,
          parsedType: (0, n.getParsedType)(O.data),
          schemaErrorMap: this._def.errorMap,
          path: O.path,
          parent: O.parent
        }
      };
    }
    _parseSync(O) {
      const M = this._parse(O);
      if ((0, i.isAsync)(M))
        throw new Error("Synchronous parse encountered promise.");
      return M;
    }
    _parseAsync(O) {
      const M = this._parse(O);
      return Promise.resolve(M);
    }
    parse(O, M) {
      const W = this.safeParse(O, M);
      if (W.success)
        return W.data;
      throw W.error;
    }
    safeParse(O, M) {
      var W;
      const se = {
        common: {
          issues: [],
          async: (W = M == null ? void 0 : M.async) !== null && W !== void 0 ? W : !1,
          contextualErrorMap: M == null ? void 0 : M.errorMap
        },
        path: (M == null ? void 0 : M.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: O,
        parsedType: (0, n.getParsedType)(O)
      }, ne = this._parseSync({ data: O, path: se.path, parent: se });
      return o(se, ne);
    }
    async parseAsync(O, M) {
      const W = await this.safeParseAsync(O, M);
      if (W.success)
        return W.data;
      throw W.error;
    }
    async safeParseAsync(O, M) {
      const W = {
        common: {
          issues: [],
          contextualErrorMap: M == null ? void 0 : M.errorMap,
          async: !0
        },
        path: (M == null ? void 0 : M.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: O,
        parsedType: (0, n.getParsedType)(O)
      }, se = this._parse({ data: O, path: W.path, parent: W }), ne = await ((0, i.isAsync)(se) ? se : Promise.resolve(se));
      return o(W, ne);
    }
    refine(O, M) {
      const W = (se) => typeof M == "string" || typeof M > "u" ? { message: M } : typeof M == "function" ? M(se) : M;
      return this._refinement((se, ne) => {
        const Me = O(se), Ce = () => ne.addIssue({
          code: s.ZodIssueCode.custom,
          ...W(se)
        });
        return typeof Promise < "u" && Me instanceof Promise ? Me.then((Ke) => Ke ? !0 : (Ce(), !1)) : Me ? !0 : (Ce(), !1);
      });
    }
    refinement(O, M) {
      return this._refinement((W, se) => O(W) ? !0 : (se.addIssue(typeof M == "function" ? M(W, se) : M), !1));
    }
    _refinement(O) {
      return new je({
        schema: this,
        typeName: Ue.ZodEffects,
        effect: { type: "refinement", refinement: O }
      });
    }
    superRefine(O) {
      return this._refinement(O);
    }
    optional() {
      return Be.create(this, this._def);
    }
    nullable() {
      return vt.create(this, this._def);
    }
    nullish() {
      return this.nullable().optional();
    }
    array() {
      return Ee.create(this, this._def);
    }
    promise() {
      return Ae.create(this, this._def);
    }
    or(O) {
      return ie.create([this, O], this._def);
    }
    and(O) {
      return T.create(this, O, this._def);
    }
    transform(O) {
      return new je({
        ...c(this._def),
        schema: this,
        typeName: Ue.ZodEffects,
        effect: { type: "transform", transform: O }
      });
    }
    default(O) {
      const M = typeof O == "function" ? O : () => O;
      return new $e({
        ...c(this._def),
        innerType: this,
        defaultValue: M,
        typeName: Ue.ZodDefault
      });
    }
    brand() {
      return new De({
        typeName: Ue.ZodBranded,
        type: this,
        ...c(this._def)
      });
    }
    catch(O) {
      const M = typeof O == "function" ? O : () => O;
      return new ht({
        ...c(this._def),
        innerType: this,
        catchValue: M,
        typeName: Ue.ZodCatch
      });
    }
    describe(O) {
      const M = this.constructor;
      return new M({
        ...this._def,
        description: O
      });
    }
    pipe(O) {
      return Le.create(this, O);
    }
    readonly() {
      return at.create(this);
    }
    isOptional() {
      return this.safeParse(void 0).success;
    }
    isNullable() {
      return this.safeParse(null).success;
    }
  }
  e.ZodType = l, e.Schema = l, e.ZodSchema = l;
  const d = /^c[^\s-]{8,}$/i, p = /^[a-z][a-z0-9]*$/, h = /[0-9A-HJKMNP-TV-Z]{26}/, g = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, m = /^([A-Z0-9_+-]+\.?)*[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, v = /^(\p{Extended_Pictographic}|\p{Emoji_Component})+$/u, _ = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/, y = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/, w = (ee) => ee.precision ? ee.offset ? new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${ee.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`) : new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${ee.precision}}Z$`) : ee.precision === 0 ? ee.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$") : ee.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");
  function $(ee, O) {
    return !!((O === "v4" || !O) && _.test(ee) || (O === "v6" || !O) && y.test(ee));
  }
  class E extends l {
    constructor() {
      super(...arguments), this._regex = (O, M, W) => this.refinement((se) => O.test(se), {
        validation: M,
        code: s.ZodIssueCode.invalid_string,
        ...r.errorUtil.errToObj(W)
      }), this.nonempty = (O) => this.min(1, r.errorUtil.errToObj(O)), this.trim = () => new E({
        ...this._def,
        checks: [...this._def.checks, { kind: "trim" }]
      }), this.toLowerCase = () => new E({
        ...this._def,
        checks: [...this._def.checks, { kind: "toLowerCase" }]
      }), this.toUpperCase = () => new E({
        ...this._def,
        checks: [...this._def.checks, { kind: "toUpperCase" }]
      });
    }
    _parse(O) {
      if (this._def.coerce && (O.data = String(O.data)), this._getType(O) !== n.ZodParsedType.string) {
        const ne = this._getOrReturnCtx(O);
        return (0, i.addIssueToContext)(ne, {
          code: s.ZodIssueCode.invalid_type,
          expected: n.ZodParsedType.string,
          received: ne.parsedType
        }), i.INVALID;
      }
      const W = new i.ParseStatus();
      let se;
      for (const ne of this._def.checks)
        if (ne.kind === "min")
          O.data.length < ne.value && (se = this._getOrReturnCtx(O, se), (0, i.addIssueToContext)(se, {
            code: s.ZodIssueCode.too_small,
            minimum: ne.value,
            type: "string",
            inclusive: !0,
            exact: !1,
            message: ne.message
          }), W.dirty());
        else if (ne.kind === "max")
          O.data.length > ne.value && (se = this._getOrReturnCtx(O, se), (0, i.addIssueToContext)(se, {
            code: s.ZodIssueCode.too_big,
            maximum: ne.value,
            type: "string",
            inclusive: !0,
            exact: !1,
            message: ne.message
          }), W.dirty());
        else if (ne.kind === "length") {
          const Me = O.data.length > ne.value, Ce = O.data.length < ne.value;
          (Me || Ce) && (se = this._getOrReturnCtx(O, se), Me ? (0, i.addIssueToContext)(se, {
            code: s.ZodIssueCode.too_big,
            maximum: ne.value,
            type: "string",
            inclusive: !0,
            exact: !0,
            message: ne.message
          }) : Ce && (0, i.addIssueToContext)(se, {
            code: s.ZodIssueCode.too_small,
            minimum: ne.value,
            type: "string",
            inclusive: !0,
            exact: !0,
            message: ne.message
          }), W.dirty());
        } else if (ne.kind === "email")
          m.test(O.data) || (se = this._getOrReturnCtx(O, se), (0, i.addIssueToContext)(se, {
            validation: "email",
            code: s.ZodIssueCode.invalid_string,
            message: ne.message
          }), W.dirty());
        else if (ne.kind === "emoji")
          v.test(O.data) || (se = this._getOrReturnCtx(O, se), (0, i.addIssueToContext)(se, {
            validation: "emoji",
            code: s.ZodIssueCode.invalid_string,
            message: ne.message
          }), W.dirty());
        else if (ne.kind === "uuid")
          g.test(O.data) || (se = this._getOrReturnCtx(O, se), (0, i.addIssueToContext)(se, {
            validation: "uuid",
            code: s.ZodIssueCode.invalid_string,
            message: ne.message
          }), W.dirty());
        else if (ne.kind === "cuid")
          d.test(O.data) || (se = this._getOrReturnCtx(O, se), (0, i.addIssueToContext)(se, {
            validation: "cuid",
            code: s.ZodIssueCode.invalid_string,
            message: ne.message
          }), W.dirty());
        else if (ne.kind === "cuid2")
          p.test(O.data) || (se = this._getOrReturnCtx(O, se), (0, i.addIssueToContext)(se, {
            validation: "cuid2",
            code: s.ZodIssueCode.invalid_string,
            message: ne.message
          }), W.dirty());
        else if (ne.kind === "ulid")
          h.test(O.data) || (se = this._getOrReturnCtx(O, se), (0, i.addIssueToContext)(se, {
            validation: "ulid",
            code: s.ZodIssueCode.invalid_string,
            message: ne.message
          }), W.dirty());
        else if (ne.kind === "url")
          try {
            new URL(O.data);
          } catch {
            se = this._getOrReturnCtx(O, se), (0, i.addIssueToContext)(se, {
              validation: "url",
              code: s.ZodIssueCode.invalid_string,
              message: ne.message
            }), W.dirty();
          }
        else
          ne.kind === "regex" ? (ne.regex.lastIndex = 0, ne.regex.test(O.data) || (se = this._getOrReturnCtx(O, se), (0, i.addIssueToContext)(se, {
            validation: "regex",
            code: s.ZodIssueCode.invalid_string,
            message: ne.message
          }), W.dirty())) : ne.kind === "trim" ? O.data = O.data.trim() : ne.kind === "includes" ? O.data.includes(ne.value, ne.position) || (se = this._getOrReturnCtx(O, se), (0, i.addIssueToContext)(se, {
            code: s.ZodIssueCode.invalid_string,
            validation: { includes: ne.value, position: ne.position },
            message: ne.message
          }), W.dirty()) : ne.kind === "toLowerCase" ? O.data = O.data.toLowerCase() : ne.kind === "toUpperCase" ? O.data = O.data.toUpperCase() : ne.kind === "startsWith" ? O.data.startsWith(ne.value) || (se = this._getOrReturnCtx(O, se), (0, i.addIssueToContext)(se, {
            code: s.ZodIssueCode.invalid_string,
            validation: { startsWith: ne.value },
            message: ne.message
          }), W.dirty()) : ne.kind === "endsWith" ? O.data.endsWith(ne.value) || (se = this._getOrReturnCtx(O, se), (0, i.addIssueToContext)(se, {
            code: s.ZodIssueCode.invalid_string,
            validation: { endsWith: ne.value },
            message: ne.message
          }), W.dirty()) : ne.kind === "datetime" ? w(ne).test(O.data) || (se = this._getOrReturnCtx(O, se), (0, i.addIssueToContext)(se, {
            code: s.ZodIssueCode.invalid_string,
            validation: "datetime",
            message: ne.message
          }), W.dirty()) : ne.kind === "ip" ? $(O.data, ne.version) || (se = this._getOrReturnCtx(O, se), (0, i.addIssueToContext)(se, {
            validation: "ip",
            code: s.ZodIssueCode.invalid_string,
            message: ne.message
          }), W.dirty()) : n.util.assertNever(ne);
      return { status: W.value, value: O.data };
    }
    _addCheck(O) {
      return new E({
        ...this._def,
        checks: [...this._def.checks, O]
      });
    }
    email(O) {
      return this._addCheck({ kind: "email", ...r.errorUtil.errToObj(O) });
    }
    url(O) {
      return this._addCheck({ kind: "url", ...r.errorUtil.errToObj(O) });
    }
    emoji(O) {
      return this._addCheck({ kind: "emoji", ...r.errorUtil.errToObj(O) });
    }
    uuid(O) {
      return this._addCheck({ kind: "uuid", ...r.errorUtil.errToObj(O) });
    }
    cuid(O) {
      return this._addCheck({ kind: "cuid", ...r.errorUtil.errToObj(O) });
    }
    cuid2(O) {
      return this._addCheck({ kind: "cuid2", ...r.errorUtil.errToObj(O) });
    }
    ulid(O) {
      return this._addCheck({ kind: "ulid", ...r.errorUtil.errToObj(O) });
    }
    ip(O) {
      return this._addCheck({ kind: "ip", ...r.errorUtil.errToObj(O) });
    }
    datetime(O) {
      var M;
      return typeof O == "string" ? this._addCheck({
        kind: "datetime",
        precision: null,
        offset: !1,
        message: O
      }) : this._addCheck({
        kind: "datetime",
        precision: typeof (O == null ? void 0 : O.precision) > "u" ? null : O == null ? void 0 : O.precision,
        offset: (M = O == null ? void 0 : O.offset) !== null && M !== void 0 ? M : !1,
        ...r.errorUtil.errToObj(O == null ? void 0 : O.message)
      });
    }
    regex(O, M) {
      return this._addCheck({
        kind: "regex",
        regex: O,
        ...r.errorUtil.errToObj(M)
      });
    }
    includes(O, M) {
      return this._addCheck({
        kind: "includes",
        value: O,
        position: M == null ? void 0 : M.position,
        ...r.errorUtil.errToObj(M == null ? void 0 : M.message)
      });
    }
    startsWith(O, M) {
      return this._addCheck({
        kind: "startsWith",
        value: O,
        ...r.errorUtil.errToObj(M)
      });
    }
    endsWith(O, M) {
      return this._addCheck({
        kind: "endsWith",
        value: O,
        ...r.errorUtil.errToObj(M)
      });
    }
    min(O, M) {
      return this._addCheck({
        kind: "min",
        value: O,
        ...r.errorUtil.errToObj(M)
      });
    }
    max(O, M) {
      return this._addCheck({
        kind: "max",
        value: O,
        ...r.errorUtil.errToObj(M)
      });
    }
    length(O, M) {
      return this._addCheck({
        kind: "length",
        value: O,
        ...r.errorUtil.errToObj(M)
      });
    }
    get isDatetime() {
      return !!this._def.checks.find((O) => O.kind === "datetime");
    }
    get isEmail() {
      return !!this._def.checks.find((O) => O.kind === "email");
    }
    get isURL() {
      return !!this._def.checks.find((O) => O.kind === "url");
    }
    get isEmoji() {
      return !!this._def.checks.find((O) => O.kind === "emoji");
    }
    get isUUID() {
      return !!this._def.checks.find((O) => O.kind === "uuid");
    }
    get isCUID() {
      return !!this._def.checks.find((O) => O.kind === "cuid");
    }
    get isCUID2() {
      return !!this._def.checks.find((O) => O.kind === "cuid2");
    }
    get isULID() {
      return !!this._def.checks.find((O) => O.kind === "ulid");
    }
    get isIP() {
      return !!this._def.checks.find((O) => O.kind === "ip");
    }
    get minLength() {
      let O = null;
      for (const M of this._def.checks)
        M.kind === "min" && (O === null || M.value > O) && (O = M.value);
      return O;
    }
    get maxLength() {
      let O = null;
      for (const M of this._def.checks)
        M.kind === "max" && (O === null || M.value < O) && (O = M.value);
      return O;
    }
  }
  e.ZodString = E, E.create = (ee) => {
    var O;
    return new E({
      checks: [],
      typeName: Ue.ZodString,
      coerce: (O = ee == null ? void 0 : ee.coerce) !== null && O !== void 0 ? O : !1,
      ...c(ee)
    });
  };
  function S(ee, O) {
    const M = (ee.toString().split(".")[1] || "").length, W = (O.toString().split(".")[1] || "").length, se = M > W ? M : W, ne = parseInt(ee.toFixed(se).replace(".", "")), Me = parseInt(O.toFixed(se).replace(".", ""));
    return ne % Me / Math.pow(10, se);
  }
  class R extends l {
    constructor() {
      super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
    }
    _parse(O) {
      if (this._def.coerce && (O.data = Number(O.data)), this._getType(O) !== n.ZodParsedType.number) {
        const ne = this._getOrReturnCtx(O);
        return (0, i.addIssueToContext)(ne, {
          code: s.ZodIssueCode.invalid_type,
          expected: n.ZodParsedType.number,
          received: ne.parsedType
        }), i.INVALID;
      }
      let W;
      const se = new i.ParseStatus();
      for (const ne of this._def.checks)
        ne.kind === "int" ? n.util.isInteger(O.data) || (W = this._getOrReturnCtx(O, W), (0, i.addIssueToContext)(W, {
          code: s.ZodIssueCode.invalid_type,
          expected: "integer",
          received: "float",
          message: ne.message
        }), se.dirty()) : ne.kind === "min" ? (ne.inclusive ? O.data < ne.value : O.data <= ne.value) && (W = this._getOrReturnCtx(O, W), (0, i.addIssueToContext)(W, {
          code: s.ZodIssueCode.too_small,
          minimum: ne.value,
          type: "number",
          inclusive: ne.inclusive,
          exact: !1,
          message: ne.message
        }), se.dirty()) : ne.kind === "max" ? (ne.inclusive ? O.data > ne.value : O.data >= ne.value) && (W = this._getOrReturnCtx(O, W), (0, i.addIssueToContext)(W, {
          code: s.ZodIssueCode.too_big,
          maximum: ne.value,
          type: "number",
          inclusive: ne.inclusive,
          exact: !1,
          message: ne.message
        }), se.dirty()) : ne.kind === "multipleOf" ? S(O.data, ne.value) !== 0 && (W = this._getOrReturnCtx(O, W), (0, i.addIssueToContext)(W, {
          code: s.ZodIssueCode.not_multiple_of,
          multipleOf: ne.value,
          message: ne.message
        }), se.dirty()) : ne.kind === "finite" ? Number.isFinite(O.data) || (W = this._getOrReturnCtx(O, W), (0, i.addIssueToContext)(W, {
          code: s.ZodIssueCode.not_finite,
          message: ne.message
        }), se.dirty()) : n.util.assertNever(ne);
      return { status: se.value, value: O.data };
    }
    gte(O, M) {
      return this.setLimit("min", O, !0, r.errorUtil.toString(M));
    }
    gt(O, M) {
      return this.setLimit("min", O, !1, r.errorUtil.toString(M));
    }
    lte(O, M) {
      return this.setLimit("max", O, !0, r.errorUtil.toString(M));
    }
    lt(O, M) {
      return this.setLimit("max", O, !1, r.errorUtil.toString(M));
    }
    setLimit(O, M, W, se) {
      return new R({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind: O,
            value: M,
            inclusive: W,
            message: r.errorUtil.toString(se)
          }
        ]
      });
    }
    _addCheck(O) {
      return new R({
        ...this._def,
        checks: [...this._def.checks, O]
      });
    }
    int(O) {
      return this._addCheck({
        kind: "int",
        message: r.errorUtil.toString(O)
      });
    }
    positive(O) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: !1,
        message: r.errorUtil.toString(O)
      });
    }
    negative(O) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: !1,
        message: r.errorUtil.toString(O)
      });
    }
    nonpositive(O) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: !0,
        message: r.errorUtil.toString(O)
      });
    }
    nonnegative(O) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: !0,
        message: r.errorUtil.toString(O)
      });
    }
    multipleOf(O, M) {
      return this._addCheck({
        kind: "multipleOf",
        value: O,
        message: r.errorUtil.toString(M)
      });
    }
    finite(O) {
      return this._addCheck({
        kind: "finite",
        message: r.errorUtil.toString(O)
      });
    }
    safe(O) {
      return this._addCheck({
        kind: "min",
        inclusive: !0,
        value: Number.MIN_SAFE_INTEGER,
        message: r.errorUtil.toString(O)
      })._addCheck({
        kind: "max",
        inclusive: !0,
        value: Number.MAX_SAFE_INTEGER,
        message: r.errorUtil.toString(O)
      });
    }
    get minValue() {
      let O = null;
      for (const M of this._def.checks)
        M.kind === "min" && (O === null || M.value > O) && (O = M.value);
      return O;
    }
    get maxValue() {
      let O = null;
      for (const M of this._def.checks)
        M.kind === "max" && (O === null || M.value < O) && (O = M.value);
      return O;
    }
    get isInt() {
      return !!this._def.checks.find((O) => O.kind === "int" || O.kind === "multipleOf" && n.util.isInteger(O.value));
    }
    get isFinite() {
      let O = null, M = null;
      for (const W of this._def.checks) {
        if (W.kind === "finite" || W.kind === "int" || W.kind === "multipleOf")
          return !0;
        W.kind === "min" ? (M === null || W.value > M) && (M = W.value) : W.kind === "max" && (O === null || W.value < O) && (O = W.value);
      }
      return Number.isFinite(M) && Number.isFinite(O);
    }
  }
  e.ZodNumber = R, R.create = (ee) => new R({
    checks: [],
    typeName: Ue.ZodNumber,
    coerce: (ee == null ? void 0 : ee.coerce) || !1,
    ...c(ee)
  });
  class j extends l {
    constructor() {
      super(...arguments), this.min = this.gte, this.max = this.lte;
    }
    _parse(O) {
      if (this._def.coerce && (O.data = BigInt(O.data)), this._getType(O) !== n.ZodParsedType.bigint) {
        const ne = this._getOrReturnCtx(O);
        return (0, i.addIssueToContext)(ne, {
          code: s.ZodIssueCode.invalid_type,
          expected: n.ZodParsedType.bigint,
          received: ne.parsedType
        }), i.INVALID;
      }
      let W;
      const se = new i.ParseStatus();
      for (const ne of this._def.checks)
        ne.kind === "min" ? (ne.inclusive ? O.data < ne.value : O.data <= ne.value) && (W = this._getOrReturnCtx(O, W), (0, i.addIssueToContext)(W, {
          code: s.ZodIssueCode.too_small,
          type: "bigint",
          minimum: ne.value,
          inclusive: ne.inclusive,
          message: ne.message
        }), se.dirty()) : ne.kind === "max" ? (ne.inclusive ? O.data > ne.value : O.data >= ne.value) && (W = this._getOrReturnCtx(O, W), (0, i.addIssueToContext)(W, {
          code: s.ZodIssueCode.too_big,
          type: "bigint",
          maximum: ne.value,
          inclusive: ne.inclusive,
          message: ne.message
        }), se.dirty()) : ne.kind === "multipleOf" ? O.data % ne.value !== BigInt(0) && (W = this._getOrReturnCtx(O, W), (0, i.addIssueToContext)(W, {
          code: s.ZodIssueCode.not_multiple_of,
          multipleOf: ne.value,
          message: ne.message
        }), se.dirty()) : n.util.assertNever(ne);
      return { status: se.value, value: O.data };
    }
    gte(O, M) {
      return this.setLimit("min", O, !0, r.errorUtil.toString(M));
    }
    gt(O, M) {
      return this.setLimit("min", O, !1, r.errorUtil.toString(M));
    }
    lte(O, M) {
      return this.setLimit("max", O, !0, r.errorUtil.toString(M));
    }
    lt(O, M) {
      return this.setLimit("max", O, !1, r.errorUtil.toString(M));
    }
    setLimit(O, M, W, se) {
      return new j({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind: O,
            value: M,
            inclusive: W,
            message: r.errorUtil.toString(se)
          }
        ]
      });
    }
    _addCheck(O) {
      return new j({
        ...this._def,
        checks: [...this._def.checks, O]
      });
    }
    positive(O) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: !1,
        message: r.errorUtil.toString(O)
      });
    }
    negative(O) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: !1,
        message: r.errorUtil.toString(O)
      });
    }
    nonpositive(O) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: !0,
        message: r.errorUtil.toString(O)
      });
    }
    nonnegative(O) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: !0,
        message: r.errorUtil.toString(O)
      });
    }
    multipleOf(O, M) {
      return this._addCheck({
        kind: "multipleOf",
        value: O,
        message: r.errorUtil.toString(M)
      });
    }
    get minValue() {
      let O = null;
      for (const M of this._def.checks)
        M.kind === "min" && (O === null || M.value > O) && (O = M.value);
      return O;
    }
    get maxValue() {
      let O = null;
      for (const M of this._def.checks)
        M.kind === "max" && (O === null || M.value < O) && (O = M.value);
      return O;
    }
  }
  e.ZodBigInt = j, j.create = (ee) => {
    var O;
    return new j({
      checks: [],
      typeName: Ue.ZodBigInt,
      coerce: (O = ee == null ? void 0 : ee.coerce) !== null && O !== void 0 ? O : !1,
      ...c(ee)
    });
  };
  class L extends l {
    _parse(O) {
      if (this._def.coerce && (O.data = !!O.data), this._getType(O) !== n.ZodParsedType.boolean) {
        const W = this._getOrReturnCtx(O);
        return (0, i.addIssueToContext)(W, {
          code: s.ZodIssueCode.invalid_type,
          expected: n.ZodParsedType.boolean,
          received: W.parsedType
        }), i.INVALID;
      }
      return (0, i.OK)(O.data);
    }
  }
  e.ZodBoolean = L, L.create = (ee) => new L({
    typeName: Ue.ZodBoolean,
    coerce: (ee == null ? void 0 : ee.coerce) || !1,
    ...c(ee)
  });
  class K extends l {
    _parse(O) {
      if (this._def.coerce && (O.data = new Date(O.data)), this._getType(O) !== n.ZodParsedType.date) {
        const ne = this._getOrReturnCtx(O);
        return (0, i.addIssueToContext)(ne, {
          code: s.ZodIssueCode.invalid_type,
          expected: n.ZodParsedType.date,
          received: ne.parsedType
        }), i.INVALID;
      }
      if (isNaN(O.data.getTime())) {
        const ne = this._getOrReturnCtx(O);
        return (0, i.addIssueToContext)(ne, {
          code: s.ZodIssueCode.invalid_date
        }), i.INVALID;
      }
      const W = new i.ParseStatus();
      let se;
      for (const ne of this._def.checks)
        ne.kind === "min" ? O.data.getTime() < ne.value && (se = this._getOrReturnCtx(O, se), (0, i.addIssueToContext)(se, {
          code: s.ZodIssueCode.too_small,
          message: ne.message,
          inclusive: !0,
          exact: !1,
          minimum: ne.value,
          type: "date"
        }), W.dirty()) : ne.kind === "max" ? O.data.getTime() > ne.value && (se = this._getOrReturnCtx(O, se), (0, i.addIssueToContext)(se, {
          code: s.ZodIssueCode.too_big,
          message: ne.message,
          inclusive: !0,
          exact: !1,
          maximum: ne.value,
          type: "date"
        }), W.dirty()) : n.util.assertNever(ne);
      return {
        status: W.value,
        value: new Date(O.data.getTime())
      };
    }
    _addCheck(O) {
      return new K({
        ...this._def,
        checks: [...this._def.checks, O]
      });
    }
    min(O, M) {
      return this._addCheck({
        kind: "min",
        value: O.getTime(),
        message: r.errorUtil.toString(M)
      });
    }
    max(O, M) {
      return this._addCheck({
        kind: "max",
        value: O.getTime(),
        message: r.errorUtil.toString(M)
      });
    }
    get minDate() {
      let O = null;
      for (const M of this._def.checks)
        M.kind === "min" && (O === null || M.value > O) && (O = M.value);
      return O != null ? new Date(O) : null;
    }
    get maxDate() {
      let O = null;
      for (const M of this._def.checks)
        M.kind === "max" && (O === null || M.value < O) && (O = M.value);
      return O != null ? new Date(O) : null;
    }
  }
  e.ZodDate = K, K.create = (ee) => new K({
    checks: [],
    coerce: (ee == null ? void 0 : ee.coerce) || !1,
    typeName: Ue.ZodDate,
    ...c(ee)
  });
  class ae extends l {
    _parse(O) {
      if (this._getType(O) !== n.ZodParsedType.symbol) {
        const W = this._getOrReturnCtx(O);
        return (0, i.addIssueToContext)(W, {
          code: s.ZodIssueCode.invalid_type,
          expected: n.ZodParsedType.symbol,
          received: W.parsedType
        }), i.INVALID;
      }
      return (0, i.OK)(O.data);
    }
  }
  e.ZodSymbol = ae, ae.create = (ee) => new ae({
    typeName: Ue.ZodSymbol,
    ...c(ee)
  });
  class ye extends l {
    _parse(O) {
      if (this._getType(O) !== n.ZodParsedType.undefined) {
        const W = this._getOrReturnCtx(O);
        return (0, i.addIssueToContext)(W, {
          code: s.ZodIssueCode.invalid_type,
          expected: n.ZodParsedType.undefined,
          received: W.parsedType
        }), i.INVALID;
      }
      return (0, i.OK)(O.data);
    }
  }
  e.ZodUndefined = ye, ye.create = (ee) => new ye({
    typeName: Ue.ZodUndefined,
    ...c(ee)
  });
  class xe extends l {
    _parse(O) {
      if (this._getType(O) !== n.ZodParsedType.null) {
        const W = this._getOrReturnCtx(O);
        return (0, i.addIssueToContext)(W, {
          code: s.ZodIssueCode.invalid_type,
          expected: n.ZodParsedType.null,
          received: W.parsedType
        }), i.INVALID;
      }
      return (0, i.OK)(O.data);
    }
  }
  e.ZodNull = xe, xe.create = (ee) => new xe({
    typeName: Ue.ZodNull,
    ...c(ee)
  });
  class Pe extends l {
    constructor() {
      super(...arguments), this._any = !0;
    }
    _parse(O) {
      return (0, i.OK)(O.data);
    }
  }
  e.ZodAny = Pe, Pe.create = (ee) => new Pe({
    typeName: Ue.ZodAny,
    ...c(ee)
  });
  class te extends l {
    constructor() {
      super(...arguments), this._unknown = !0;
    }
    _parse(O) {
      return (0, i.OK)(O.data);
    }
  }
  e.ZodUnknown = te, te.create = (ee) => new te({
    typeName: Ue.ZodUnknown,
    ...c(ee)
  });
  class pe extends l {
    _parse(O) {
      const M = this._getOrReturnCtx(O);
      return (0, i.addIssueToContext)(M, {
        code: s.ZodIssueCode.invalid_type,
        expected: n.ZodParsedType.never,
        received: M.parsedType
      }), i.INVALID;
    }
  }
  e.ZodNever = pe, pe.create = (ee) => new pe({
    typeName: Ue.ZodNever,
    ...c(ee)
  });
  class de extends l {
    _parse(O) {
      if (this._getType(O) !== n.ZodParsedType.undefined) {
        const W = this._getOrReturnCtx(O);
        return (0, i.addIssueToContext)(W, {
          code: s.ZodIssueCode.invalid_type,
          expected: n.ZodParsedType.void,
          received: W.parsedType
        }), i.INVALID;
      }
      return (0, i.OK)(O.data);
    }
  }
  e.ZodVoid = de, de.create = (ee) => new de({
    typeName: Ue.ZodVoid,
    ...c(ee)
  });
  class Ee extends l {
    _parse(O) {
      const { ctx: M, status: W } = this._processInputParams(O), se = this._def;
      if (M.parsedType !== n.ZodParsedType.array)
        return (0, i.addIssueToContext)(M, {
          code: s.ZodIssueCode.invalid_type,
          expected: n.ZodParsedType.array,
          received: M.parsedType
        }), i.INVALID;
      if (se.exactLength !== null) {
        const Me = M.data.length > se.exactLength.value, Ce = M.data.length < se.exactLength.value;
        (Me || Ce) && ((0, i.addIssueToContext)(M, {
          code: Me ? s.ZodIssueCode.too_big : s.ZodIssueCode.too_small,
          minimum: Ce ? se.exactLength.value : void 0,
          maximum: Me ? se.exactLength.value : void 0,
          type: "array",
          inclusive: !0,
          exact: !0,
          message: se.exactLength.message
        }), W.dirty());
      }
      if (se.minLength !== null && M.data.length < se.minLength.value && ((0, i.addIssueToContext)(M, {
        code: s.ZodIssueCode.too_small,
        minimum: se.minLength.value,
        type: "array",
        inclusive: !0,
        exact: !1,
        message: se.minLength.message
      }), W.dirty()), se.maxLength !== null && M.data.length > se.maxLength.value && ((0, i.addIssueToContext)(M, {
        code: s.ZodIssueCode.too_big,
        maximum: se.maxLength.value,
        type: "array",
        inclusive: !0,
        exact: !1,
        message: se.maxLength.message
      }), W.dirty()), M.common.async)
        return Promise.all([...M.data].map((Me, Ce) => se.type._parseAsync(new a(M, Me, M.path, Ce)))).then((Me) => i.ParseStatus.mergeArray(W, Me));
      const ne = [...M.data].map((Me, Ce) => se.type._parseSync(new a(M, Me, M.path, Ce)));
      return i.ParseStatus.mergeArray(W, ne);
    }
    get element() {
      return this._def.type;
    }
    min(O, M) {
      return new Ee({
        ...this._def,
        minLength: { value: O, message: r.errorUtil.toString(M) }
      });
    }
    max(O, M) {
      return new Ee({
        ...this._def,
        maxLength: { value: O, message: r.errorUtil.toString(M) }
      });
    }
    length(O, M) {
      return new Ee({
        ...this._def,
        exactLength: { value: O, message: r.errorUtil.toString(M) }
      });
    }
    nonempty(O) {
      return this.min(1, O);
    }
  }
  e.ZodArray = Ee, Ee.create = (ee, O) => new Ee({
    type: ee,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: Ue.ZodArray,
    ...c(O)
  });
  function Re(ee) {
    if (ee instanceof _e) {
      const O = {};
      for (const M in ee.shape) {
        const W = ee.shape[M];
        O[M] = Be.create(Re(W));
      }
      return new _e({
        ...ee._def,
        shape: () => O
      });
    } else
      return ee instanceof Ee ? new Ee({
        ...ee._def,
        type: Re(ee.element)
      }) : ee instanceof Be ? Be.create(Re(ee.unwrap())) : ee instanceof vt ? vt.create(Re(ee.unwrap())) : ee instanceof F ? F.create(ee.items.map((O) => Re(O))) : ee;
  }
  class _e extends l {
    constructor() {
      super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
    }
    _getCached() {
      if (this._cached !== null)
        return this._cached;
      const O = this._def.shape(), M = n.util.objectKeys(O);
      return this._cached = { shape: O, keys: M };
    }
    _parse(O) {
      if (this._getType(O) !== n.ZodParsedType.object) {
        const We = this._getOrReturnCtx(O);
        return (0, i.addIssueToContext)(We, {
          code: s.ZodIssueCode.invalid_type,
          expected: n.ZodParsedType.object,
          received: We.parsedType
        }), i.INVALID;
      }
      const { status: W, ctx: se } = this._processInputParams(O), { shape: ne, keys: Me } = this._getCached(), Ce = [];
      if (!(this._def.catchall instanceof pe && this._def.unknownKeys === "strip"))
        for (const We in se.data)
          Me.includes(We) || Ce.push(We);
      const Ke = [];
      for (const We of Me) {
        const ct = ne[We], qt = se.data[We];
        Ke.push({
          key: { status: "valid", value: We },
          value: ct._parse(new a(se, qt, se.path, We)),
          alwaysSet: We in se.data
        });
      }
      if (this._def.catchall instanceof pe) {
        const We = this._def.unknownKeys;
        if (We === "passthrough")
          for (const ct of Ce)
            Ke.push({
              key: { status: "valid", value: ct },
              value: { status: "valid", value: se.data[ct] }
            });
        else if (We === "strict")
          Ce.length > 0 && ((0, i.addIssueToContext)(se, {
            code: s.ZodIssueCode.unrecognized_keys,
            keys: Ce
          }), W.dirty());
        else if (We !== "strip")
          throw new Error("Internal ZodObject error: invalid unknownKeys value.");
      } else {
        const We = this._def.catchall;
        for (const ct of Ce) {
          const qt = se.data[ct];
          Ke.push({
            key: { status: "valid", value: ct },
            value: We._parse(new a(se, qt, se.path, ct)),
            alwaysSet: ct in se.data
          });
        }
      }
      return se.common.async ? Promise.resolve().then(async () => {
        const We = [];
        for (const ct of Ke) {
          const qt = await ct.key;
          We.push({
            key: qt,
            value: await ct.value,
            alwaysSet: ct.alwaysSet
          });
        }
        return We;
      }).then((We) => i.ParseStatus.mergeObjectSync(W, We)) : i.ParseStatus.mergeObjectSync(W, Ke);
    }
    get shape() {
      return this._def.shape();
    }
    strict(O) {
      return r.errorUtil.errToObj, new _e({
        ...this._def,
        unknownKeys: "strict",
        ...O !== void 0 ? {
          errorMap: (M, W) => {
            var se, ne, Me, Ce;
            const Ke = (Me = (ne = (se = this._def).errorMap) === null || ne === void 0 ? void 0 : ne.call(se, M, W).message) !== null && Me !== void 0 ? Me : W.defaultError;
            return M.code === "unrecognized_keys" ? {
              message: (Ce = r.errorUtil.errToObj(O).message) !== null && Ce !== void 0 ? Ce : Ke
            } : {
              message: Ke
            };
          }
        } : {}
      });
    }
    strip() {
      return new _e({
        ...this._def,
        unknownKeys: "strip"
      });
    }
    passthrough() {
      return new _e({
        ...this._def,
        unknownKeys: "passthrough"
      });
    }
    extend(O) {
      return new _e({
        ...this._def,
        shape: () => ({
          ...this._def.shape(),
          ...O
        })
      });
    }
    merge(O) {
      return new _e({
        unknownKeys: O._def.unknownKeys,
        catchall: O._def.catchall,
        shape: () => ({
          ...this._def.shape(),
          ...O._def.shape()
        }),
        typeName: Ue.ZodObject
      });
    }
    setKey(O, M) {
      return this.augment({ [O]: M });
    }
    catchall(O) {
      return new _e({
        ...this._def,
        catchall: O
      });
    }
    pick(O) {
      const M = {};
      return n.util.objectKeys(O).forEach((W) => {
        O[W] && this.shape[W] && (M[W] = this.shape[W]);
      }), new _e({
        ...this._def,
        shape: () => M
      });
    }
    omit(O) {
      const M = {};
      return n.util.objectKeys(this.shape).forEach((W) => {
        O[W] || (M[W] = this.shape[W]);
      }), new _e({
        ...this._def,
        shape: () => M
      });
    }
    deepPartial() {
      return Re(this);
    }
    partial(O) {
      const M = {};
      return n.util.objectKeys(this.shape).forEach((W) => {
        const se = this.shape[W];
        O && !O[W] ? M[W] = se : M[W] = se.optional();
      }), new _e({
        ...this._def,
        shape: () => M
      });
    }
    required(O) {
      const M = {};
      return n.util.objectKeys(this.shape).forEach((W) => {
        if (O && !O[W])
          M[W] = this.shape[W];
        else {
          let ne = this.shape[W];
          for (; ne instanceof Be; )
            ne = ne._def.innerType;
          M[W] = ne;
        }
      }), new _e({
        ...this._def,
        shape: () => M
      });
    }
    keyof() {
      return I(n.util.objectKeys(this.shape));
    }
  }
  e.ZodObject = _e, _e.create = (ee, O) => new _e({
    shape: () => ee,
    unknownKeys: "strip",
    catchall: pe.create(),
    typeName: Ue.ZodObject,
    ...c(O)
  }), _e.strictCreate = (ee, O) => new _e({
    shape: () => ee,
    unknownKeys: "strict",
    catchall: pe.create(),
    typeName: Ue.ZodObject,
    ...c(O)
  }), _e.lazycreate = (ee, O) => new _e({
    shape: ee,
    unknownKeys: "strip",
    catchall: pe.create(),
    typeName: Ue.ZodObject,
    ...c(O)
  });
  class ie extends l {
    _parse(O) {
      const { ctx: M } = this._processInputParams(O), W = this._def.options;
      function se(ne) {
        for (const Ce of ne)
          if (Ce.result.status === "valid")
            return Ce.result;
        for (const Ce of ne)
          if (Ce.result.status === "dirty")
            return M.common.issues.push(...Ce.ctx.common.issues), Ce.result;
        const Me = ne.map((Ce) => new s.ZodError(Ce.ctx.common.issues));
        return (0, i.addIssueToContext)(M, {
          code: s.ZodIssueCode.invalid_union,
          unionErrors: Me
        }), i.INVALID;
      }
      if (M.common.async)
        return Promise.all(W.map(async (ne) => {
          const Me = {
            ...M,
            common: {
              ...M.common,
              issues: []
            },
            parent: null
          };
          return {
            result: await ne._parseAsync({
              data: M.data,
              path: M.path,
              parent: Me
            }),
            ctx: Me
          };
        })).then(se);
      {
        let ne;
        const Me = [];
        for (const Ke of W) {
          const We = {
            ...M,
            common: {
              ...M.common,
              issues: []
            },
            parent: null
          }, ct = Ke._parseSync({
            data: M.data,
            path: M.path,
            parent: We
          });
          if (ct.status === "valid")
            return ct;
          ct.status === "dirty" && !ne && (ne = { result: ct, ctx: We }), We.common.issues.length && Me.push(We.common.issues);
        }
        if (ne)
          return M.common.issues.push(...ne.ctx.common.issues), ne.result;
        const Ce = Me.map((Ke) => new s.ZodError(Ke));
        return (0, i.addIssueToContext)(M, {
          code: s.ZodIssueCode.invalid_union,
          unionErrors: Ce
        }), i.INVALID;
      }
    }
    get options() {
      return this._def.options;
    }
  }
  e.ZodUnion = ie, ie.create = (ee, O) => new ie({
    options: ee,
    typeName: Ue.ZodUnion,
    ...c(O)
  });
  const Y = (ee) => ee instanceof J ? Y(ee.schema) : ee instanceof je ? Y(ee.innerType()) : ee instanceof A ? [ee.value] : ee instanceof X ? ee.options : ee instanceof oe ? Object.keys(ee.enum) : ee instanceof $e ? Y(ee._def.innerType) : ee instanceof ye ? [void 0] : ee instanceof xe ? [null] : null;
  class V extends l {
    _parse(O) {
      const { ctx: M } = this._processInputParams(O);
      if (M.parsedType !== n.ZodParsedType.object)
        return (0, i.addIssueToContext)(M, {
          code: s.ZodIssueCode.invalid_type,
          expected: n.ZodParsedType.object,
          received: M.parsedType
        }), i.INVALID;
      const W = this.discriminator, se = M.data[W], ne = this.optionsMap.get(se);
      return ne ? M.common.async ? ne._parseAsync({
        data: M.data,
        path: M.path,
        parent: M
      }) : ne._parseSync({
        data: M.data,
        path: M.path,
        parent: M
      }) : ((0, i.addIssueToContext)(M, {
        code: s.ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [W]
      }), i.INVALID);
    }
    get discriminator() {
      return this._def.discriminator;
    }
    get options() {
      return this._def.options;
    }
    get optionsMap() {
      return this._def.optionsMap;
    }
    static create(O, M, W) {
      const se = /* @__PURE__ */ new Map();
      for (const ne of M) {
        const Me = Y(ne.shape[O]);
        if (!Me)
          throw new Error(`A discriminator value for key \`${O}\` could not be extracted from all schema options`);
        for (const Ce of Me) {
          if (se.has(Ce))
            throw new Error(`Discriminator property ${String(O)} has duplicate value ${String(Ce)}`);
          se.set(Ce, ne);
        }
      }
      return new V({
        typeName: Ue.ZodDiscriminatedUnion,
        discriminator: O,
        options: M,
        optionsMap: se,
        ...c(W)
      });
    }
  }
  e.ZodDiscriminatedUnion = V;
  function z(ee, O) {
    const M = (0, n.getParsedType)(ee), W = (0, n.getParsedType)(O);
    if (ee === O)
      return { valid: !0, data: ee };
    if (M === n.ZodParsedType.object && W === n.ZodParsedType.object) {
      const se = n.util.objectKeys(O), ne = n.util.objectKeys(ee).filter((Ce) => se.indexOf(Ce) !== -1), Me = { ...ee, ...O };
      for (const Ce of ne) {
        const Ke = z(ee[Ce], O[Ce]);
        if (!Ke.valid)
          return { valid: !1 };
        Me[Ce] = Ke.data;
      }
      return { valid: !0, data: Me };
    } else if (M === n.ZodParsedType.array && W === n.ZodParsedType.array) {
      if (ee.length !== O.length)
        return { valid: !1 };
      const se = [];
      for (let ne = 0; ne < ee.length; ne++) {
        const Me = ee[ne], Ce = O[ne], Ke = z(Me, Ce);
        if (!Ke.valid)
          return { valid: !1 };
        se.push(Ke.data);
      }
      return { valid: !0, data: se };
    } else
      return M === n.ZodParsedType.date && W === n.ZodParsedType.date && +ee == +O ? { valid: !0, data: ee } : { valid: !1 };
  }
  class T extends l {
    _parse(O) {
      const { status: M, ctx: W } = this._processInputParams(O), se = (ne, Me) => {
        if ((0, i.isAborted)(ne) || (0, i.isAborted)(Me))
          return i.INVALID;
        const Ce = z(ne.value, Me.value);
        return Ce.valid ? (((0, i.isDirty)(ne) || (0, i.isDirty)(Me)) && M.dirty(), { status: M.value, value: Ce.data }) : ((0, i.addIssueToContext)(W, {
          code: s.ZodIssueCode.invalid_intersection_types
        }), i.INVALID);
      };
      return W.common.async ? Promise.all([
        this._def.left._parseAsync({
          data: W.data,
          path: W.path,
          parent: W
        }),
        this._def.right._parseAsync({
          data: W.data,
          path: W.path,
          parent: W
        })
      ]).then(([ne, Me]) => se(ne, Me)) : se(this._def.left._parseSync({
        data: W.data,
        path: W.path,
        parent: W
      }), this._def.right._parseSync({
        data: W.data,
        path: W.path,
        parent: W
      }));
    }
  }
  e.ZodIntersection = T, T.create = (ee, O, M) => new T({
    left: ee,
    right: O,
    typeName: Ue.ZodIntersection,
    ...c(M)
  });
  class F extends l {
    _parse(O) {
      const { status: M, ctx: W } = this._processInputParams(O);
      if (W.parsedType !== n.ZodParsedType.array)
        return (0, i.addIssueToContext)(W, {
          code: s.ZodIssueCode.invalid_type,
          expected: n.ZodParsedType.array,
          received: W.parsedType
        }), i.INVALID;
      if (W.data.length < this._def.items.length)
        return (0, i.addIssueToContext)(W, {
          code: s.ZodIssueCode.too_small,
          minimum: this._def.items.length,
          inclusive: !0,
          exact: !1,
          type: "array"
        }), i.INVALID;
      !this._def.rest && W.data.length > this._def.items.length && ((0, i.addIssueToContext)(W, {
        code: s.ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), M.dirty());
      const ne = [...W.data].map((Me, Ce) => {
        const Ke = this._def.items[Ce] || this._def.rest;
        return Ke ? Ke._parse(new a(W, Me, W.path, Ce)) : null;
      }).filter((Me) => !!Me);
      return W.common.async ? Promise.all(ne).then((Me) => i.ParseStatus.mergeArray(M, Me)) : i.ParseStatus.mergeArray(M, ne);
    }
    get items() {
      return this._def.items;
    }
    rest(O) {
      return new F({
        ...this._def,
        rest: O
      });
    }
  }
  e.ZodTuple = F, F.create = (ee, O) => {
    if (!Array.isArray(ee))
      throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    return new F({
      items: ee,
      typeName: Ue.ZodTuple,
      rest: null,
      ...c(O)
    });
  };
  class D extends l {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(O) {
      const { status: M, ctx: W } = this._processInputParams(O);
      if (W.parsedType !== n.ZodParsedType.object)
        return (0, i.addIssueToContext)(W, {
          code: s.ZodIssueCode.invalid_type,
          expected: n.ZodParsedType.object,
          received: W.parsedType
        }), i.INVALID;
      const se = [], ne = this._def.keyType, Me = this._def.valueType;
      for (const Ce in W.data)
        se.push({
          key: ne._parse(new a(W, Ce, W.path, Ce)),
          value: Me._parse(new a(W, W.data[Ce], W.path, Ce))
        });
      return W.common.async ? i.ParseStatus.mergeObjectAsync(M, se) : i.ParseStatus.mergeObjectSync(M, se);
    }
    get element() {
      return this._def.valueType;
    }
    static create(O, M, W) {
      return M instanceof l ? new D({
        keyType: O,
        valueType: M,
        typeName: Ue.ZodRecord,
        ...c(W)
      }) : new D({
        keyType: E.create(),
        valueType: O,
        typeName: Ue.ZodRecord,
        ...c(M)
      });
    }
  }
  e.ZodRecord = D;
  class U extends l {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(O) {
      const { status: M, ctx: W } = this._processInputParams(O);
      if (W.parsedType !== n.ZodParsedType.map)
        return (0, i.addIssueToContext)(W, {
          code: s.ZodIssueCode.invalid_type,
          expected: n.ZodParsedType.map,
          received: W.parsedType
        }), i.INVALID;
      const se = this._def.keyType, ne = this._def.valueType, Me = [...W.data.entries()].map(([Ce, Ke], We) => ({
        key: se._parse(new a(W, Ce, W.path, [We, "key"])),
        value: ne._parse(new a(W, Ke, W.path, [We, "value"]))
      }));
      if (W.common.async) {
        const Ce = /* @__PURE__ */ new Map();
        return Promise.resolve().then(async () => {
          for (const Ke of Me) {
            const We = await Ke.key, ct = await Ke.value;
            if (We.status === "aborted" || ct.status === "aborted")
              return i.INVALID;
            (We.status === "dirty" || ct.status === "dirty") && M.dirty(), Ce.set(We.value, ct.value);
          }
          return { status: M.value, value: Ce };
        });
      } else {
        const Ce = /* @__PURE__ */ new Map();
        for (const Ke of Me) {
          const We = Ke.key, ct = Ke.value;
          if (We.status === "aborted" || ct.status === "aborted")
            return i.INVALID;
          (We.status === "dirty" || ct.status === "dirty") && M.dirty(), Ce.set(We.value, ct.value);
        }
        return { status: M.value, value: Ce };
      }
    }
  }
  e.ZodMap = U, U.create = (ee, O, M) => new U({
    valueType: O,
    keyType: ee,
    typeName: Ue.ZodMap,
    ...c(M)
  });
  class k extends l {
    _parse(O) {
      const { status: M, ctx: W } = this._processInputParams(O);
      if (W.parsedType !== n.ZodParsedType.set)
        return (0, i.addIssueToContext)(W, {
          code: s.ZodIssueCode.invalid_type,
          expected: n.ZodParsedType.set,
          received: W.parsedType
        }), i.INVALID;
      const se = this._def;
      se.minSize !== null && W.data.size < se.minSize.value && ((0, i.addIssueToContext)(W, {
        code: s.ZodIssueCode.too_small,
        minimum: se.minSize.value,
        type: "set",
        inclusive: !0,
        exact: !1,
        message: se.minSize.message
      }), M.dirty()), se.maxSize !== null && W.data.size > se.maxSize.value && ((0, i.addIssueToContext)(W, {
        code: s.ZodIssueCode.too_big,
        maximum: se.maxSize.value,
        type: "set",
        inclusive: !0,
        exact: !1,
        message: se.maxSize.message
      }), M.dirty());
      const ne = this._def.valueType;
      function Me(Ke) {
        const We = /* @__PURE__ */ new Set();
        for (const ct of Ke) {
          if (ct.status === "aborted")
            return i.INVALID;
          ct.status === "dirty" && M.dirty(), We.add(ct.value);
        }
        return { status: M.value, value: We };
      }
      const Ce = [...W.data.values()].map((Ke, We) => ne._parse(new a(W, Ke, W.path, We)));
      return W.common.async ? Promise.all(Ce).then((Ke) => Me(Ke)) : Me(Ce);
    }
    min(O, M) {
      return new k({
        ...this._def,
        minSize: { value: O, message: r.errorUtil.toString(M) }
      });
    }
    max(O, M) {
      return new k({
        ...this._def,
        maxSize: { value: O, message: r.errorUtil.toString(M) }
      });
    }
    size(O, M) {
      return this.min(O, M).max(O, M);
    }
    nonempty(O) {
      return this.min(1, O);
    }
  }
  e.ZodSet = k, k.create = (ee, O) => new k({
    valueType: ee,
    minSize: null,
    maxSize: null,
    typeName: Ue.ZodSet,
    ...c(O)
  });
  class Z extends l {
    constructor() {
      super(...arguments), this.validate = this.implement;
    }
    _parse(O) {
      const { ctx: M } = this._processInputParams(O);
      if (M.parsedType !== n.ZodParsedType.function)
        return (0, i.addIssueToContext)(M, {
          code: s.ZodIssueCode.invalid_type,
          expected: n.ZodParsedType.function,
          received: M.parsedType
        }), i.INVALID;
      function W(Ce, Ke) {
        return (0, i.makeIssue)({
          data: Ce,
          path: M.path,
          errorMaps: [
            M.common.contextualErrorMap,
            M.schemaErrorMap,
            (0, t.getErrorMap)(),
            t.defaultErrorMap
          ].filter((We) => !!We),
          issueData: {
            code: s.ZodIssueCode.invalid_arguments,
            argumentsError: Ke
          }
        });
      }
      function se(Ce, Ke) {
        return (0, i.makeIssue)({
          data: Ce,
          path: M.path,
          errorMaps: [
            M.common.contextualErrorMap,
            M.schemaErrorMap,
            (0, t.getErrorMap)(),
            t.defaultErrorMap
          ].filter((We) => !!We),
          issueData: {
            code: s.ZodIssueCode.invalid_return_type,
            returnTypeError: Ke
          }
        });
      }
      const ne = { errorMap: M.common.contextualErrorMap }, Me = M.data;
      if (this._def.returns instanceof Ae) {
        const Ce = this;
        return (0, i.OK)(async function(...Ke) {
          const We = new s.ZodError([]), ct = await Ce._def.args.parseAsync(Ke, ne).catch((Zr) => {
            throw We.addIssue(W(Ke, Zr)), We;
          }), qt = await Reflect.apply(Me, this, ct);
          return await Ce._def.returns._def.type.parseAsync(qt, ne).catch((Zr) => {
            throw We.addIssue(se(qt, Zr)), We;
          });
        });
      } else {
        const Ce = this;
        return (0, i.OK)(function(...Ke) {
          const We = Ce._def.args.safeParse(Ke, ne);
          if (!We.success)
            throw new s.ZodError([W(Ke, We.error)]);
          const ct = Reflect.apply(Me, this, We.data), qt = Ce._def.returns.safeParse(ct, ne);
          if (!qt.success)
            throw new s.ZodError([se(ct, qt.error)]);
          return qt.data;
        });
      }
    }
    parameters() {
      return this._def.args;
    }
    returnType() {
      return this._def.returns;
    }
    args(...O) {
      return new Z({
        ...this._def,
        args: F.create(O).rest(te.create())
      });
    }
    returns(O) {
      return new Z({
        ...this._def,
        returns: O
      });
    }
    implement(O) {
      return this.parse(O);
    }
    strictImplement(O) {
      return this.parse(O);
    }
    static create(O, M, W) {
      return new Z({
        args: O || F.create([]).rest(te.create()),
        returns: M || te.create(),
        typeName: Ue.ZodFunction,
        ...c(W)
      });
    }
  }
  e.ZodFunction = Z;
  class J extends l {
    get schema() {
      return this._def.getter();
    }
    _parse(O) {
      const { ctx: M } = this._processInputParams(O);
      return this._def.getter()._parse({ data: M.data, path: M.path, parent: M });
    }
  }
  e.ZodLazy = J, J.create = (ee, O) => new J({
    getter: ee,
    typeName: Ue.ZodLazy,
    ...c(O)
  });
  class A extends l {
    _parse(O) {
      if (O.data !== this._def.value) {
        const M = this._getOrReturnCtx(O);
        return (0, i.addIssueToContext)(M, {
          received: M.data,
          code: s.ZodIssueCode.invalid_literal,
          expected: this._def.value
        }), i.INVALID;
      }
      return { status: "valid", value: O.data };
    }
    get value() {
      return this._def.value;
    }
  }
  e.ZodLiteral = A, A.create = (ee, O) => new A({
    value: ee,
    typeName: Ue.ZodLiteral,
    ...c(O)
  });
  function I(ee, O) {
    return new X({
      values: ee,
      typeName: Ue.ZodEnum,
      ...c(O)
    });
  }
  class X extends l {
    _parse(O) {
      if (typeof O.data != "string") {
        const M = this._getOrReturnCtx(O), W = this._def.values;
        return (0, i.addIssueToContext)(M, {
          expected: n.util.joinValues(W),
          received: M.parsedType,
          code: s.ZodIssueCode.invalid_type
        }), i.INVALID;
      }
      if (this._def.values.indexOf(O.data) === -1) {
        const M = this._getOrReturnCtx(O), W = this._def.values;
        return (0, i.addIssueToContext)(M, {
          received: M.data,
          code: s.ZodIssueCode.invalid_enum_value,
          options: W
        }), i.INVALID;
      }
      return (0, i.OK)(O.data);
    }
    get options() {
      return this._def.values;
    }
    get enum() {
      const O = {};
      for (const M of this._def.values)
        O[M] = M;
      return O;
    }
    get Values() {
      const O = {};
      for (const M of this._def.values)
        O[M] = M;
      return O;
    }
    get Enum() {
      const O = {};
      for (const M of this._def.values)
        O[M] = M;
      return O;
    }
    extract(O) {
      return X.create(O);
    }
    exclude(O) {
      return X.create(this.options.filter((M) => !O.includes(M)));
    }
  }
  e.ZodEnum = X, X.create = I;
  class oe extends l {
    _parse(O) {
      const M = n.util.getValidEnumValues(this._def.values), W = this._getOrReturnCtx(O);
      if (W.parsedType !== n.ZodParsedType.string && W.parsedType !== n.ZodParsedType.number) {
        const se = n.util.objectValues(M);
        return (0, i.addIssueToContext)(W, {
          expected: n.util.joinValues(se),
          received: W.parsedType,
          code: s.ZodIssueCode.invalid_type
        }), i.INVALID;
      }
      if (M.indexOf(O.data) === -1) {
        const se = n.util.objectValues(M);
        return (0, i.addIssueToContext)(W, {
          received: W.data,
          code: s.ZodIssueCode.invalid_enum_value,
          options: se
        }), i.INVALID;
      }
      return (0, i.OK)(O.data);
    }
    get enum() {
      return this._def.values;
    }
  }
  e.ZodNativeEnum = oe, oe.create = (ee, O) => new oe({
    values: ee,
    typeName: Ue.ZodNativeEnum,
    ...c(O)
  });
  class Ae extends l {
    unwrap() {
      return this._def.type;
    }
    _parse(O) {
      const { ctx: M } = this._processInputParams(O);
      if (M.parsedType !== n.ZodParsedType.promise && M.common.async === !1)
        return (0, i.addIssueToContext)(M, {
          code: s.ZodIssueCode.invalid_type,
          expected: n.ZodParsedType.promise,
          received: M.parsedType
        }), i.INVALID;
      const W = M.parsedType === n.ZodParsedType.promise ? M.data : Promise.resolve(M.data);
      return (0, i.OK)(W.then((se) => this._def.type.parseAsync(se, {
        path: M.path,
        errorMap: M.common.contextualErrorMap
      })));
    }
  }
  e.ZodPromise = Ae, Ae.create = (ee, O) => new Ae({
    type: ee,
    typeName: Ue.ZodPromise,
    ...c(O)
  });
  class je extends l {
    innerType() {
      return this._def.schema;
    }
    sourceType() {
      return this._def.schema._def.typeName === Ue.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(O) {
      const { status: M, ctx: W } = this._processInputParams(O), se = this._def.effect || null, ne = {
        addIssue: (Me) => {
          (0, i.addIssueToContext)(W, Me), Me.fatal ? M.abort() : M.dirty();
        },
        get path() {
          return W.path;
        }
      };
      if (ne.addIssue = ne.addIssue.bind(ne), se.type === "preprocess") {
        const Me = se.transform(W.data, ne);
        return W.common.issues.length ? {
          status: "dirty",
          value: W.data
        } : W.common.async ? Promise.resolve(Me).then((Ce) => this._def.schema._parseAsync({
          data: Ce,
          path: W.path,
          parent: W
        })) : this._def.schema._parseSync({
          data: Me,
          path: W.path,
          parent: W
        });
      }
      if (se.type === "refinement") {
        const Me = (Ce) => {
          const Ke = se.refinement(Ce, ne);
          if (W.common.async)
            return Promise.resolve(Ke);
          if (Ke instanceof Promise)
            throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
          return Ce;
        };
        if (W.common.async === !1) {
          const Ce = this._def.schema._parseSync({
            data: W.data,
            path: W.path,
            parent: W
          });
          return Ce.status === "aborted" ? i.INVALID : (Ce.status === "dirty" && M.dirty(), Me(Ce.value), { status: M.value, value: Ce.value });
        } else
          return this._def.schema._parseAsync({ data: W.data, path: W.path, parent: W }).then((Ce) => Ce.status === "aborted" ? i.INVALID : (Ce.status === "dirty" && M.dirty(), Me(Ce.value).then(() => ({ status: M.value, value: Ce.value }))));
      }
      if (se.type === "transform")
        if (W.common.async === !1) {
          const Me = this._def.schema._parseSync({
            data: W.data,
            path: W.path,
            parent: W
          });
          if (!(0, i.isValid)(Me))
            return Me;
          const Ce = se.transform(Me.value, ne);
          if (Ce instanceof Promise)
            throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
          return { status: M.value, value: Ce };
        } else
          return this._def.schema._parseAsync({ data: W.data, path: W.path, parent: W }).then((Me) => (0, i.isValid)(Me) ? Promise.resolve(se.transform(Me.value, ne)).then((Ce) => ({ status: M.value, value: Ce })) : Me);
      n.util.assertNever(se);
    }
  }
  e.ZodEffects = je, e.ZodTransformer = je, je.create = (ee, O, M) => new je({
    schema: ee,
    typeName: Ue.ZodEffects,
    effect: O,
    ...c(M)
  }), je.createWithPreprocess = (ee, O, M) => new je({
    schema: O,
    effect: { type: "preprocess", transform: ee },
    typeName: Ue.ZodEffects,
    ...c(M)
  });
  class Be extends l {
    _parse(O) {
      return this._getType(O) === n.ZodParsedType.undefined ? (0, i.OK)(void 0) : this._def.innerType._parse(O);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  e.ZodOptional = Be, Be.create = (ee, O) => new Be({
    innerType: ee,
    typeName: Ue.ZodOptional,
    ...c(O)
  });
  class vt extends l {
    _parse(O) {
      return this._getType(O) === n.ZodParsedType.null ? (0, i.OK)(null) : this._def.innerType._parse(O);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  e.ZodNullable = vt, vt.create = (ee, O) => new vt({
    innerType: ee,
    typeName: Ue.ZodNullable,
    ...c(O)
  });
  class $e extends l {
    _parse(O) {
      const { ctx: M } = this._processInputParams(O);
      let W = M.data;
      return M.parsedType === n.ZodParsedType.undefined && (W = this._def.defaultValue()), this._def.innerType._parse({
        data: W,
        path: M.path,
        parent: M
      });
    }
    removeDefault() {
      return this._def.innerType;
    }
  }
  e.ZodDefault = $e, $e.create = (ee, O) => new $e({
    innerType: ee,
    typeName: Ue.ZodDefault,
    defaultValue: typeof O.default == "function" ? O.default : () => O.default,
    ...c(O)
  });
  class ht extends l {
    _parse(O) {
      const { ctx: M } = this._processInputParams(O), W = {
        ...M,
        common: {
          ...M.common,
          issues: []
        }
      }, se = this._def.innerType._parse({
        data: W.data,
        path: W.path,
        parent: {
          ...W
        }
      });
      return (0, i.isAsync)(se) ? se.then((ne) => ({
        status: "valid",
        value: ne.status === "valid" ? ne.value : this._def.catchValue({
          get error() {
            return new s.ZodError(W.common.issues);
          },
          input: W.data
        })
      })) : {
        status: "valid",
        value: se.status === "valid" ? se.value : this._def.catchValue({
          get error() {
            return new s.ZodError(W.common.issues);
          },
          input: W.data
        })
      };
    }
    removeCatch() {
      return this._def.innerType;
    }
  }
  e.ZodCatch = ht, ht.create = (ee, O) => new ht({
    innerType: ee,
    typeName: Ue.ZodCatch,
    catchValue: typeof O.catch == "function" ? O.catch : () => O.catch,
    ...c(O)
  });
  class nt extends l {
    _parse(O) {
      if (this._getType(O) !== n.ZodParsedType.nan) {
        const W = this._getOrReturnCtx(O);
        return (0, i.addIssueToContext)(W, {
          code: s.ZodIssueCode.invalid_type,
          expected: n.ZodParsedType.nan,
          received: W.parsedType
        }), i.INVALID;
      }
      return { status: "valid", value: O.data };
    }
  }
  e.ZodNaN = nt, nt.create = (ee) => new nt({
    typeName: Ue.ZodNaN,
    ...c(ee)
  }), e.BRAND = Symbol("zod_brand");
  class De extends l {
    _parse(O) {
      const { ctx: M } = this._processInputParams(O), W = M.data;
      return this._def.type._parse({
        data: W,
        path: M.path,
        parent: M
      });
    }
    unwrap() {
      return this._def.type;
    }
  }
  e.ZodBranded = De;
  class Le extends l {
    _parse(O) {
      const { status: M, ctx: W } = this._processInputParams(O);
      if (W.common.async)
        return (async () => {
          const ne = await this._def.in._parseAsync({
            data: W.data,
            path: W.path,
            parent: W
          });
          return ne.status === "aborted" ? i.INVALID : ne.status === "dirty" ? (M.dirty(), (0, i.DIRTY)(ne.value)) : this._def.out._parseAsync({
            data: ne.value,
            path: W.path,
            parent: W
          });
        })();
      {
        const se = this._def.in._parseSync({
          data: W.data,
          path: W.path,
          parent: W
        });
        return se.status === "aborted" ? i.INVALID : se.status === "dirty" ? (M.dirty(), {
          status: "dirty",
          value: se.value
        }) : this._def.out._parseSync({
          data: se.value,
          path: W.path,
          parent: W
        });
      }
    }
    static create(O, M) {
      return new Le({
        in: O,
        out: M,
        typeName: Ue.ZodPipeline
      });
    }
  }
  e.ZodPipeline = Le;
  class at extends l {
    _parse(O) {
      const M = this._def.innerType._parse(O);
      return (0, i.isValid)(M) && (M.value = Object.freeze(M.value)), M;
    }
  }
  e.ZodReadonly = at, at.create = (ee, O) => new at({
    innerType: ee,
    typeName: Ue.ZodReadonly,
    ...c(O)
  });
  const mt = (ee, O = {}, M) => ee ? Pe.create().superRefine((W, se) => {
    var ne, Me;
    if (!ee(W)) {
      const Ce = typeof O == "function" ? O(W) : typeof O == "string" ? { message: O } : O, Ke = (Me = (ne = Ce.fatal) !== null && ne !== void 0 ? ne : M) !== null && Me !== void 0 ? Me : !0, We = typeof Ce == "string" ? { message: Ce } : Ce;
      se.addIssue({ code: "custom", ...We, fatal: Ke });
    }
  }) : Pe.create();
  e.custom = mt, e.late = {
    object: _e.lazycreate
  };
  var Ue;
  (function(ee) {
    ee.ZodString = "ZodString", ee.ZodNumber = "ZodNumber", ee.ZodNaN = "ZodNaN", ee.ZodBigInt = "ZodBigInt", ee.ZodBoolean = "ZodBoolean", ee.ZodDate = "ZodDate", ee.ZodSymbol = "ZodSymbol", ee.ZodUndefined = "ZodUndefined", ee.ZodNull = "ZodNull", ee.ZodAny = "ZodAny", ee.ZodUnknown = "ZodUnknown", ee.ZodNever = "ZodNever", ee.ZodVoid = "ZodVoid", ee.ZodArray = "ZodArray", ee.ZodObject = "ZodObject", ee.ZodUnion = "ZodUnion", ee.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", ee.ZodIntersection = "ZodIntersection", ee.ZodTuple = "ZodTuple", ee.ZodRecord = "ZodRecord", ee.ZodMap = "ZodMap", ee.ZodSet = "ZodSet", ee.ZodFunction = "ZodFunction", ee.ZodLazy = "ZodLazy", ee.ZodLiteral = "ZodLiteral", ee.ZodEnum = "ZodEnum", ee.ZodEffects = "ZodEffects", ee.ZodNativeEnum = "ZodNativeEnum", ee.ZodOptional = "ZodOptional", ee.ZodNullable = "ZodNullable", ee.ZodDefault = "ZodDefault", ee.ZodCatch = "ZodCatch", ee.ZodPromise = "ZodPromise", ee.ZodBranded = "ZodBranded", ee.ZodPipeline = "ZodPipeline", ee.ZodReadonly = "ZodReadonly";
  })(Ue = e.ZodFirstPartyTypeKind || (e.ZodFirstPartyTypeKind = {}));
  const q = (ee, O = {
    message: `Input not instance of ${ee.name}`
  }) => (0, e.custom)((M) => M instanceof ee, O);
  e.instanceof = q;
  const x = E.create;
  e.string = x;
  const C = R.create;
  e.number = C;
  const G = nt.create;
  e.nan = G;
  const fe = j.create;
  e.bigint = fe;
  const ge = L.create;
  e.boolean = ge;
  const Oe = K.create;
  e.date = Oe;
  const ut = ae.create;
  e.symbol = ut;
  const kt = ye.create;
  e.undefined = kt;
  const Rt = xe.create;
  e.null = Rt;
  const $t = Pe.create;
  e.any = $t;
  const Tt = te.create;
  e.unknown = Tt;
  const ho = pe.create;
  e.never = ho;
  const mo = de.create;
  e.void = mo;
  const ra = Ee.create;
  e.array = ra;
  const na = _e.create;
  e.object = na;
  const yo = _e.strictCreate;
  e.strictObject = yo;
  const Dn = ie.create;
  e.union = Dn;
  const go = V.create;
  e.discriminatedUnion = go;
  const ia = T.create;
  e.intersection = ia;
  const sa = F.create;
  e.tuple = sa;
  const ys = D.create;
  e.record = ys;
  const aa = U.create;
  e.map = aa;
  const vo = k.create;
  e.set = vo;
  const Ii = Z.create;
  e.function = Ii;
  const bo = J.create;
  e.lazy = bo;
  const ji = A.create;
  e.literal = ji;
  const ue = X.create;
  e.enum = ue;
  const Q = oe.create;
  e.nativeEnum = Q;
  const le = Ae.create;
  e.promise = le;
  const be = je.create;
  e.effect = be, e.transformer = be;
  const ve = Be.create;
  e.optional = ve;
  const Ye = vt.create;
  e.nullable = Ye;
  const Xe = je.createWithPreprocess;
  e.preprocess = Xe;
  const xt = Le.create;
  e.pipeline = xt;
  const Mt = () => x().optional();
  e.ostring = Mt;
  const Zt = () => C().optional();
  e.onumber = Zt;
  const bt = () => ge().optional();
  e.oboolean = bt, e.coerce = {
    string: (ee) => E.create({ ...ee, coerce: !0 }),
    number: (ee) => R.create({ ...ee, coerce: !0 }),
    boolean: (ee) => L.create({
      ...ee,
      coerce: !0
    }),
    bigint: (ee) => j.create({ ...ee, coerce: !0 }),
    date: (ee) => K.create({ ...ee, coerce: !0 })
  }, e.NEVER = i.INVALID;
})(TE);
(function(e) {
  var t = tt && tt.__createBinding || (Object.create ? function(i, n, s, a) {
    a === void 0 && (a = s), Object.defineProperty(i, a, { enumerable: !0, get: function() {
      return n[s];
    } });
  } : function(i, n, s, a) {
    a === void 0 && (a = s), i[a] = n[s];
  }), r = tt && tt.__exportStar || function(i, n) {
    for (var s in i)
      s !== "default" && !Object.prototype.hasOwnProperty.call(n, s) && t(n, i, s);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), r(Gn, e), r(dg, e), r(RE, e), r(Zu, e), r(TE, e), r(Kn, e);
})(ay);
(function(e) {
  var t = tt && tt.__createBinding || (Object.create ? function(a, o, c, l) {
    l === void 0 && (l = c), Object.defineProperty(a, l, { enumerable: !0, get: function() {
      return o[c];
    } });
  } : function(a, o, c, l) {
    l === void 0 && (l = c), a[l] = o[c];
  }), r = tt && tt.__setModuleDefault || (Object.create ? function(a, o) {
    Object.defineProperty(a, "default", { enumerable: !0, value: o });
  } : function(a, o) {
    a.default = o;
  }), i = tt && tt.__importStar || function(a) {
    if (a && a.__esModule)
      return a;
    var o = {};
    if (a != null)
      for (var c in a)
        c !== "default" && Object.prototype.hasOwnProperty.call(a, c) && t(o, a, c);
    return r(o, a), o;
  }, n = tt && tt.__exportStar || function(a, o) {
    for (var c in a)
      c !== "default" && !Object.prototype.hasOwnProperty.call(o, c) && t(o, a, c);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.z = void 0;
  const s = i(ay);
  e.z = s, n(ay, e), e.default = s;
})(PE);
Object.defineProperty(Hs, "__esModule", { value: !0 });
Hs.generateSchema = Hs.extendApi = void 0;
const er = fg, $l = PE;
function tN(e, t = {}) {
  return e.metaOpenApi = Object.assign(e.metaOpenApi || {}, t), e;
}
Hs.extendApi = tN;
function rN({ zodRef: e, useOutput: t, hideDefinitions: r }) {
  return Object.keys(e.shape).filter((n) => (r == null ? void 0 : r.includes(n)) === !1).reduce((n, s) => Object.assign(Object.assign({}, n), { [s]: kr(e.shape[s], t) }), {});
}
function o1({ zodRef: e, schemas: t, useOutput: r }) {
  const i = kr(e._def.schema, r);
  let n = "undefined";
  if (r && e._def.effect) {
    const s = e._def.effect.type === "transform" ? e._def.effect : null;
    if (s && "transform" in s)
      try {
        n = typeof s.transform(
          ["integer", "number"].includes(`${i.type}`) ? 0 : i.type === "string" ? "" : i.type === "boolean" ? !1 : i.type === "object" ? {} : i.type === "null" ? null : i.type === "array" ? [] : void 0,
          { addIssue: () => {
          }, path: [] }
          // TODO: Discover if context is necessary here
        );
      } catch {
      }
  }
  return (0, er.default)(Object.assign(Object.assign(Object.assign({}, e.description ? { description: e.description } : {}), i), ["number", "string", "boolean", "null"].includes(n) ? {
    type: n
  } : {}), ...t);
}
function nN({ zodRef: e, schemas: t }) {
  const r = {
    type: "string"
  }, { checks: i = [] } = e._def;
  return i.forEach((n) => {
    switch (n.kind) {
      case "email":
        r.format = "email";
        break;
      case "uuid":
        r.format = "uuid";
        break;
      case "cuid":
        r.format = "cuid";
        break;
      case "url":
        r.format = "uri";
        break;
      case "datetime":
        r.format = "date-time";
        break;
      case "length":
        r.minLength = n.value, r.maxLength = n.value;
        break;
      case "max":
        r.maxLength = n.value;
        break;
      case "min":
        r.minLength = n.value;
        break;
      case "regex":
        r.pattern = n.regex.source;
        break;
    }
  }), (0, er.default)(r, e.description ? { description: e.description } : {}, ...t);
}
function iN({ zodRef: e, schemas: t }) {
  const r = {
    type: "number"
  }, { checks: i = [] } = e._def;
  return i.forEach((n) => {
    switch (n.kind) {
      case "max":
        r.maximum = n.value, n.inclusive || (r.exclusiveMaximum = n.value);
        break;
      case "min":
        r.minimum = n.value, n.inclusive || (r.exclusiveMinimum = n.value);
        break;
      case "int":
        r.type = "integer";
        break;
      case "multipleOf":
        r.multipleOf = n.value;
    }
  }), (0, er.default)(r, e.description ? { description: e.description } : {}, ...t);
}
function sN(e) {
  const t = [];
  for (const r of e)
    Array.isArray(r.hideDefinitions) && t.push(...r.hideDefinitions);
  return t;
}
function aN({ zodRef: e, schemas: t, useOutput: r, hideDefinitions: i }) {
  var n;
  let s;
  e._def.catchall instanceof $l.z.ZodNever || ((n = e._def.catchall) === null || n === void 0 ? void 0 : n._def.typeName) === "ZodNever" ? e._def.unknownKeys === "passthrough" ? s = !0 : e._def.unknownKeys === "strict" && (s = !1) : s = kr(e._def.catchall, r), s = s != null ? { additionalProperties: s } : {};
  const a = Object.keys(e.shape).filter((c) => {
    const l = e.shape[c];
    return !(l.isOptional() || l instanceof $l.z.ZodDefault || l._def.typeName === "ZodDefault") && !(l instanceof $l.z.ZodNever || l._def.typeName === "ZodDefault");
  }), o = a.length > 0 ? { required: a } : {};
  return (0, er.default)(Object.assign(Object.assign(Object.assign({ type: "object", properties: rN({
    zodRef: e,
    schemas: t,
    useOutput: r,
    hideDefinitions: sN(t)
  }) }, o), s), i), e.description ? { description: e.description, hideDefinitions: i } : {}, ...t);
}
function oN({ zodRef: e, schemas: t, useOutput: r }) {
  return (0, er.default)({
    type: "object",
    additionalProperties: e._def.valueType instanceof $l.z.ZodUnknown ? {} : kr(e._def.valueType, r)
  }, e.description ? { description: e.description } : {}, ...t);
}
function uN({ zodRef: e, schemas: t }) {
  return (0, er.default)({ type: "integer", format: "int64" }, e.description ? { description: e.description } : {}, ...t);
}
function cN({ zodRef: e, schemas: t }) {
  return (0, er.default)({ type: "boolean" }, e.description ? { description: e.description } : {}, ...t);
}
function lN({ zodRef: e, schemas: t }) {
  return (0, er.default)({ type: "string", format: "date-time" }, e.description ? { description: e.description } : {}, ...t);
}
function fN({ zodRef: e, schemas: t }) {
  return (0, er.default)({
    type: "string",
    format: "null",
    nullable: !0
  }, e.description ? { description: e.description } : {}, ...t);
}
function u1({ schemas: e, zodRef: t, useOutput: r }) {
  return (0, er.default)(kr(t.unwrap(), r), t.description ? { description: t.description } : {}, ...e);
}
function dN({ schemas: e, zodRef: t, useOutput: r }) {
  return (0, er.default)(Object.assign({ default: t._def.defaultValue() }, kr(t._def.innerType, r)), t.description ? { description: t.description } : {}, ...e);
}
function pN({ schemas: e, zodRef: t, useOutput: r }) {
  const i = {};
  return t._def.exactLength != null && (i.minItems = t._def.exactLength.value, i.maxItems = t._def.exactLength.value), t._def.minLength != null && (i.minItems = t._def.minLength.value), t._def.maxLength != null && (i.maxItems = t._def.maxLength.value), (0, er.default)(Object.assign({ type: "array", items: kr(t.element, r) }, i), t.description ? { description: t.description } : {}, ...e);
}
function hN({ schemas: e, zodRef: t }) {
  return (0, er.default)({
    type: typeof t._def.value,
    enum: [t._def.value]
  }, t.description ? { description: t.description } : {}, ...e);
}
function c1({ schemas: e, zodRef: t }) {
  return (0, er.default)({
    type: typeof Object.values(t._def.values)[0],
    enum: Object.values(t._def.values)
  }, t.description ? { description: t.description } : {}, ...e);
}
function mN({ schemas: e, zodRef: t, useOutput: r }) {
  return (0, er.default)({
    allOf: [
      kr(t._def.left, r),
      kr(t._def.right, r)
    ]
  }, t.description ? { description: t.description } : {}, ...e);
}
function yN({ schemas: e, zodRef: t, useOutput: r }) {
  const i = t._def.options;
  if (i.reduce((n, s) => n && s._def.typeName === "ZodLiteral", !0)) {
    const n = i, s = n.reduce((a, o) => !a || a === typeof o._def.value ? typeof o._def.value : null, null);
    if (s)
      return (0, er.default)({
        type: s,
        enum: n.map((a) => a._def.value)
      }, t.description ? { description: t.description } : {}, ...e);
  }
  return (0, er.default)({
    oneOf: i.map((n) => kr(n, r))
  }, t.description ? { description: t.description } : {}, ...e);
}
function gN({ schemas: e, zodRef: t, useOutput: r }) {
  return (0, er.default)({
    discriminator: {
      propertyName: t._def.discriminator
    },
    oneOf: Array.from(t._def.options.values()).map((i) => kr(i, r))
  }, t.description ? { description: t.description } : {}, ...e);
}
function vN({ zodRef: e, schemas: t }) {
  return (0, er.default)({ readOnly: !0 }, e.description ? { description: e.description } : {}, ...t);
}
function bN({ schemas: e, zodRef: t }) {
  return (0, er.default)(kr(t._def.type), ...e);
}
function xn({ zodRef: e, schemas: t }) {
  return (0, er.default)(e.description ? { description: e.description } : {}, ...t);
}
function _N({ zodRef: e, useOutput: t }) {
  return kr(t ? e._def.out : e._def.in, t);
}
const l1 = {
  ZodObject: aN,
  ZodRecord: oN,
  ZodString: nN,
  ZodNumber: iN,
  ZodBigInt: uN,
  ZodBoolean: cN,
  ZodDate: lN,
  ZodNull: fN,
  ZodOptional: u1,
  ZodNullable: u1,
  ZodDefault: dN,
  ZodArray: pN,
  ZodLiteral: hN,
  ZodEnum: c1,
  ZodNativeEnum: c1,
  ZodTransformer: o1,
  ZodEffects: o1,
  ZodIntersection: mN,
  ZodUnion: yN,
  ZodDiscriminatedUnion: gN,
  ZodNever: vN,
  ZodBranded: bN,
  // TODO Transform the rest to schemas
  ZodUndefined: xn,
  // TODO: `prefixItems` is allowed in OpenAPI 3.1 which can be used to create tuples
  ZodTuple: xn,
  ZodMap: xn,
  ZodFunction: xn,
  ZodLazy: xn,
  ZodPromise: xn,
  ZodAny: xn,
  ZodUnknown: xn,
  ZodVoid: xn,
  ZodPipeline: _N
};
function kr(e, t) {
  const { metaOpenApi: r = {} } = e, i = [
    e.isNullable && e.isNullable() ? { nullable: !0 } : {},
    ...Array.isArray(r) ? r : [r]
  ];
  try {
    const n = e._def.typeName;
    return n in l1 ? l1[n]({
      zodRef: e,
      schemas: i,
      useOutput: t
    }) : xn({ zodRef: e, schemas: i });
  } catch (n) {
    return console.error(n), xn({ zodRef: e, schemas: i });
  }
}
Hs.generateSchema = kr;
var jf = {};
Object.defineProperty(jf, "__esModule", { value: !0 });
jf.extendZodWithOpenApi = void 0;
const wN = Hs;
function $N(e, t = !1) {
  !t && typeof e.ZodSchema.prototype.openapi < "u" || (e.ZodSchema.prototype.openapi = function(r) {
    return (0, wN.extendApi)(this, r);
  });
}
jf.extendZodWithOpenApi = $N;
(function(e) {
  var t = tt && tt.__createBinding || (Object.create ? function(i, n, s, a) {
    a === void 0 && (a = s);
    var o = Object.getOwnPropertyDescriptor(n, s);
    (!o || ("get" in o ? !n.__esModule : o.writable || o.configurable)) && (o = { enumerable: !0, get: function() {
      return n[s];
    } }), Object.defineProperty(i, a, o);
  } : function(i, n, s, a) {
    a === void 0 && (a = s), i[a] = n[s];
  }), r = tt && tt.__exportStar || function(i, n) {
    for (var s in i)
      s !== "default" && !Object.prototype.hasOwnProperty.call(n, s) && t(n, i, s);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), r(Hs, e), r(jf, e);
})(OE);
const EN = !1, xN = /\r?\n/, ON = /\bono[ @]/;
function PN(e) {
  return !!(e && e.configurable && typeof e.get == "function");
}
function SN(e) {
  return !!// If there is no stack property, then it's writable, since assigning it will create it
  (!e || e.writable || typeof e.set == "function");
}
function jE(e, t) {
  let r = kE(e.stack), i = t ? t.stack : void 0;
  return r && i ? r + `

` + i : r || i;
}
function AN(e, t, r) {
  r ? Object.defineProperty(t, "stack", {
    get: () => {
      let i = e.get.apply(t);
      return jE({ stack: i }, r);
    },
    enumerable: !1,
    configurable: !0
  }) : CN(t, e);
}
function kE(e) {
  if (e) {
    let t = e.split(xN), r;
    for (let i = 0; i < t.length; i++) {
      let n = t[i];
      if (ON.test(n))
        r === void 0 && (r = i);
      else if (r !== void 0) {
        t.splice(r, i - r);
        break;
      }
    }
    if (t.length > 0)
      return t.join(`
`);
  }
  return e;
}
function CN(e, t) {
  Object.defineProperty(e, "stack", {
    get: () => kE(t.get.apply(e)),
    enumerable: !1,
    configurable: !0
  });
}
const RN = ["function", "symbol", "undefined"], TN = ["constructor", "prototype", "__proto__"], IN = Object.getPrototypeOf({});
function ME() {
  let e = {}, t = this;
  for (let r of NE(t))
    if (typeof r == "string") {
      let i = t[r], n = typeof i;
      RN.includes(n) || (e[r] = i);
    }
  return e;
}
function NE(e, t = []) {
  let r = [];
  for (; e && e !== IN; )
    r = r.concat(Object.getOwnPropertyNames(e), Object.getOwnPropertySymbols(e)), e = Object.getPrototypeOf(e);
  let i = new Set(r);
  for (let n of t.concat(TN))
    i.delete(n);
  return i;
}
const jN = ["name", "message", "stack"];
function El(e, t, r) {
  let i = e;
  return kN(i, t), t && typeof t == "object" && MN(i, t), i.toJSON = ME, r && typeof r == "object" && Object.assign(i, r), i;
}
function kN(e, t) {
  let r = Object.getOwnPropertyDescriptor(e, "stack");
  PN(r) ? AN(r, e, t) : SN(r) && (e.stack = jE(e, t));
}
function MN(e, t) {
  let r = NE(t, jN), i = e, n = t;
  for (let s of r)
    if (i[s] === void 0)
      try {
        i[s] = n[s];
      } catch {
      }
}
function NN(e) {
  return e = e || {}, {
    concatMessages: e.concatMessages === void 0 ? !0 : !!e.concatMessages,
    format: e.format === void 0 ? EN : typeof e.format == "function" ? e.format : !1
  };
}
function DN(e, t) {
  let r, i, n, s = "";
  return typeof e[0] == "string" ? n = e : typeof e[1] == "string" ? (e[0] instanceof Error ? r = e[0] : i = e[0], n = e.slice(1)) : (r = e[0], i = e[1], n = e.slice(2)), n.length > 0 && (t.format ? s = t.format.apply(void 0, n) : s = n.join(" ")), t.concatMessages && r && r.message && (s += (s ? ` 
` : "") + r.message), { originalError: r, props: i, message: s };
}
const ds = pg;
function pg(e, t) {
  t = NN(t);
  function r(...i) {
    let { originalError: n, props: s, message: a } = DN(i, t), o = new e(a);
    return El(o, n, s);
  }
  return r[Symbol.species] = e, r;
}
pg.toJSON = function(t) {
  return ME.call(t);
};
pg.extend = function(t, r, i) {
  return i || r instanceof Error ? El(t, r, i) : r ? El(t, void 0, r) : El(t);
};
const f1 = ei;
ei.error = new ds(Error);
ei.eval = new ds(EvalError);
ei.range = new ds(RangeError);
ei.reference = new ds(ReferenceError);
ei.syntax = new ds(SyntaxError);
ei.type = new ds(TypeError);
ei.uri = new ds(URIError);
const LN = ei;
function ei(...e) {
  let t = e[0];
  if (typeof t == "object" && typeof t.name == "string") {
    for (let r of Object.values(LN))
      if (typeof r == "function" && r.name === "ono") {
        let i = r[Symbol.species];
        if (i && i !== Error && (t instanceof i || t.name === i.name))
          return r.apply(void 0, e);
      }
  }
  return ei.error.apply(void 0, e);
}
typeof module == "object" && typeof module.exports == "object" && (module.exports = Object.assign(module.exports.default, module.exports));
const qN = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Ono: ds,
  default: f1,
  ono: f1
}, Symbol.toStringTag, { value: "Module" })), In = /* @__PURE__ */ xf(qN);
var ti = { exports: {} };
function FN() {
  return typeof qe.process == "object" && typeof qe.process.nextTick == "function" ? qe.process.nextTick : typeof setImmediate == "function" ? setImmediate : function(t) {
    setTimeout(t, 0);
  };
}
var UN = FN(), d1 = UN, DE = function(t, r) {
  if (t) {
    r.then(function(i) {
      d1(function() {
        t(null, i);
      });
    }, function(i) {
      d1(function() {
        t(i);
      });
    });
    return;
  } else
    return r;
}, ir = {}, uy = { exports: {} }, ef = { exports: {} };
/*! https://mths.be/punycode v1.4.1 by @mathias */
ef.exports;
(function(e, t) {
  (function(r) {
    var i = t && !t.nodeType && t, n = e && !e.nodeType && e, s = typeof tt == "object" && tt;
    (s.global === s || s.window === s || s.self === s) && (r = s);
    var a, o = 2147483647, c = 36, l = 1, d = 26, p = 38, h = 700, g = 72, m = 128, v = "-", _ = /^xn--/, y = /[^\x20-\x7E]/, w = /[\x2E\u3002\uFF0E\uFF61]/g, $ = {
      overflow: "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    }, E = c - l, S = Math.floor, R = String.fromCharCode, j;
    function L(ie) {
      throw new RangeError($[ie]);
    }
    function K(ie, Y) {
      for (var V = ie.length, z = []; V--; )
        z[V] = Y(ie[V]);
      return z;
    }
    function ae(ie, Y) {
      var V = ie.split("@"), z = "";
      V.length > 1 && (z = V[0] + "@", ie = V[1]), ie = ie.replace(w, ".");
      var T = ie.split("."), F = K(T, Y).join(".");
      return z + F;
    }
    function ye(ie) {
      for (var Y = [], V = 0, z = ie.length, T, F; V < z; )
        T = ie.charCodeAt(V++), T >= 55296 && T <= 56319 && V < z ? (F = ie.charCodeAt(V++), (F & 64512) == 56320 ? Y.push(((T & 1023) << 10) + (F & 1023) + 65536) : (Y.push(T), V--)) : Y.push(T);
      return Y;
    }
    function xe(ie) {
      return K(ie, function(Y) {
        var V = "";
        return Y > 65535 && (Y -= 65536, V += R(Y >>> 10 & 1023 | 55296), Y = 56320 | Y & 1023), V += R(Y), V;
      }).join("");
    }
    function Pe(ie) {
      return ie - 48 < 10 ? ie - 22 : ie - 65 < 26 ? ie - 65 : ie - 97 < 26 ? ie - 97 : c;
    }
    function te(ie, Y) {
      return ie + 22 + 75 * (ie < 26) - ((Y != 0) << 5);
    }
    function pe(ie, Y, V) {
      var z = 0;
      for (ie = V ? S(ie / h) : ie >> 1, ie += S(ie / Y); ie > E * d >> 1; z += c)
        ie = S(ie / E);
      return S(z + (E + 1) * ie / (ie + p));
    }
    function de(ie) {
      var Y = [], V = ie.length, z, T = 0, F = m, D = g, U, k, Z, J, A, I, X, oe, Ae;
      for (U = ie.lastIndexOf(v), U < 0 && (U = 0), k = 0; k < U; ++k)
        ie.charCodeAt(k) >= 128 && L("not-basic"), Y.push(ie.charCodeAt(k));
      for (Z = U > 0 ? U + 1 : 0; Z < V; ) {
        for (J = T, A = 1, I = c; Z >= V && L("invalid-input"), X = Pe(ie.charCodeAt(Z++)), (X >= c || X > S((o - T) / A)) && L("overflow"), T += X * A, oe = I <= D ? l : I >= D + d ? d : I - D, !(X < oe); I += c)
          Ae = c - oe, A > S(o / Ae) && L("overflow"), A *= Ae;
        z = Y.length + 1, D = pe(T - J, z, J == 0), S(T / z) > o - F && L("overflow"), F += S(T / z), T %= z, Y.splice(T++, 0, F);
      }
      return xe(Y);
    }
    function Ee(ie) {
      var Y, V, z, T, F, D, U, k, Z, J, A, I = [], X, oe, Ae, je;
      for (ie = ye(ie), X = ie.length, Y = m, V = 0, F = g, D = 0; D < X; ++D)
        A = ie[D], A < 128 && I.push(R(A));
      for (z = T = I.length, T && I.push(v); z < X; ) {
        for (U = o, D = 0; D < X; ++D)
          A = ie[D], A >= Y && A < U && (U = A);
        for (oe = z + 1, U - Y > S((o - V) / oe) && L("overflow"), V += (U - Y) * oe, Y = U, D = 0; D < X; ++D)
          if (A = ie[D], A < Y && ++V > o && L("overflow"), A == Y) {
            for (k = V, Z = c; J = Z <= F ? l : Z >= F + d ? d : Z - F, !(k < J); Z += c)
              je = k - J, Ae = c - J, I.push(
                R(te(J + je % Ae, 0))
              ), k = S(je / Ae);
            I.push(R(te(k, 0))), F = pe(V, oe, z == T), V = 0, ++z;
          }
        ++V, ++Y;
      }
      return I.join("");
    }
    function Re(ie) {
      return ae(ie, function(Y) {
        return _.test(Y) ? de(Y.slice(4).toLowerCase()) : Y;
      });
    }
    function _e(ie) {
      return ae(ie, function(Y) {
        return y.test(Y) ? "xn--" + Ee(Y) : Y;
      });
    }
    if (a = {
      /**
       * A string representing the current Punycode.js version number.
       * @memberOf punycode
       * @type String
       */
      version: "1.4.1",
      /**
       * An object of methods to convert from JavaScript's internal character
       * representation (UCS-2) to Unicode code points, and back.
       * @see <https://mathiasbynens.be/notes/javascript-encoding>
       * @memberOf punycode
       * @type Object
       */
      ucs2: {
        decode: ye,
        encode: xe
      },
      decode: de,
      encode: Ee,
      toASCII: _e,
      toUnicode: Re
    }, i && n)
      if (e.exports == i)
        n.exports = a;
      else
        for (j in a)
          a.hasOwnProperty(j) && (i[j] = a[j]);
    else
      r.punycode = a;
  })(tt);
})(ef, ef.exports);
var BN = ef.exports;
const VN = /* @__PURE__ */ Ks(BN);
function ZN(e, t) {
  return Object.prototype.hasOwnProperty.call(e, t);
}
var zN = function(e, t, r, i) {
  t = t || "&", r = r || "=";
  var n = {};
  if (typeof e != "string" || e.length === 0)
    return n;
  var s = /\+/g;
  e = e.split(t);
  var a = 1e3;
  i && typeof i.maxKeys == "number" && (a = i.maxKeys);
  var o = e.length;
  a > 0 && o > a && (o = a);
  for (var c = 0; c < o; ++c) {
    var l = e[c].replace(s, "%20"), d = l.indexOf(r), p, h, g, m;
    d >= 0 ? (p = l.substr(0, d), h = l.substr(d + 1)) : (p = l, h = ""), g = decodeURIComponent(p), m = decodeURIComponent(h), ZN(n, g) ? WN(n[g]) ? n[g].push(m) : n[g] = [n[g], m] : n[g] = m;
  }
  return n;
}, WN = Array.isArray || function(e) {
  return Object.prototype.toString.call(e) === "[object Array]";
}, Do = function(e) {
  switch (typeof e) {
    case "string":
      return e;
    case "boolean":
      return e ? "true" : "false";
    case "number":
      return isFinite(e) ? e : "";
    default:
      return "";
  }
}, HN = function(e, t, r, i) {
  return t = t || "&", r = r || "=", e === null && (e = void 0), typeof e == "object" ? p1(KN(e), function(n) {
    var s = encodeURIComponent(Do(n)) + r;
    return GN(e[n]) ? p1(e[n], function(a) {
      return s + encodeURIComponent(Do(a));
    }).join(t) : s + encodeURIComponent(Do(e[n]));
  }).join(t) : i ? encodeURIComponent(Do(i)) + r + encodeURIComponent(Do(e)) : "";
}, GN = Array.isArray || function(e) {
  return Object.prototype.toString.call(e) === "[object Array]";
};
function p1(e, t) {
  if (e.map)
    return e.map(t);
  for (var r = [], i = 0; i < e.length; i++)
    r.push(t(e[i], i));
  return r;
}
var KN = Object.keys || function(e) {
  var t = [];
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.push(r);
  return t;
}, hg, mg, LE = mg = zN, qE = hg = HN;
function FE(e) {
  return encodeURIComponent(e);
}
function UE(e) {
  return decodeURIComponent(e);
}
var BE = {
  decode: LE,
  encode: qE,
  parse: mg,
  stringify: hg,
  escape: FE,
  unescape: UE
};
const YN = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: LE,
  default: BE,
  encode: qE,
  escape: FE,
  get parse() {
    return mg;
  },
  get stringify() {
    return hg;
  },
  unescape: UE
}, Symbol.toStringTag, { value: "Module" }));
var JN = {
  isString: function(e) {
    return typeof e == "string";
  },
  isObject: function(e) {
    return typeof e == "object" && e !== null;
  },
  isNull: function(e) {
    return e === null;
  },
  isNullOrUndefined: function(e) {
    return e == null;
  }
}, XN = VN, zn = JN, QN = zu, e5 = d5, VE = p5, t5 = f5, r5 = fn;
function fn() {
  this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
}
var n5 = /^([a-z0-9.+-]+:)/i, i5 = /:[0-9]*$/, s5 = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, a5 = ["<", ">", '"', "`", " ", "\r", `
`, "	"], o5 = ["{", "}", "|", "\\", "^", "`"].concat(a5), cy = ["'"].concat(o5), h1 = ["%", "/", "?", ";", "#"].concat(cy), m1 = ["/", "?", "#"], u5 = 255, y1 = /^[+a-z0-9A-Z_-]{0,63}$/, c5 = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, l5 = {
  javascript: !0,
  "javascript:": !0
}, ly = {
  javascript: !0,
  "javascript:": !0
}, Za = {
  http: !0,
  https: !0,
  ftp: !0,
  gopher: !0,
  file: !0,
  "http:": !0,
  "https:": !0,
  "ftp:": !0,
  "gopher:": !0,
  "file:": !0
}, fy = BE;
function zu(e, t, r) {
  if (e && zn.isObject(e) && e instanceof fn)
    return e;
  var i = new fn();
  return i.parse(e, t, r), i;
}
fn.prototype.parse = function(e, t, r) {
  if (!zn.isString(e))
    throw new TypeError("Parameter 'url' must be a string, not " + typeof e);
  var i = e.indexOf("?"), n = i !== -1 && i < e.indexOf("#") ? "?" : "#", s = e.split(n), a = /\\/g;
  s[0] = s[0].replace(a, "/"), e = s.join(n);
  var o = e;
  if (o = o.trim(), !r && e.split("#").length === 1) {
    var c = s5.exec(o);
    if (c)
      return this.path = o, this.href = o, this.pathname = c[1], c[2] ? (this.search = c[2], t ? this.query = fy.parse(this.search.substr(1)) : this.query = this.search.substr(1)) : t && (this.search = "", this.query = {}), this;
  }
  var l = n5.exec(o);
  if (l) {
    l = l[0];
    var d = l.toLowerCase();
    this.protocol = d, o = o.substr(l.length);
  }
  if (r || l || o.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var p = o.substr(0, 2) === "//";
    p && !(l && ly[l]) && (o = o.substr(2), this.slashes = !0);
  }
  if (!ly[l] && (p || l && !Za[l])) {
    for (var h = -1, g = 0; g < m1.length; g++) {
      var m = o.indexOf(m1[g]);
      m !== -1 && (h === -1 || m < h) && (h = m);
    }
    var v, _;
    h === -1 ? _ = o.lastIndexOf("@") : _ = o.lastIndexOf("@", h), _ !== -1 && (v = o.slice(0, _), o = o.slice(_ + 1), this.auth = decodeURIComponent(v)), h = -1;
    for (var g = 0; g < h1.length; g++) {
      var m = o.indexOf(h1[g]);
      m !== -1 && (h === -1 || m < h) && (h = m);
    }
    h === -1 && (h = o.length), this.host = o.slice(0, h), o = o.slice(h), this.parseHost(), this.hostname = this.hostname || "";
    var y = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!y)
      for (var w = this.hostname.split(/\./), g = 0, $ = w.length; g < $; g++) {
        var E = w[g];
        if (E && !E.match(y1)) {
          for (var S = "", R = 0, j = E.length; R < j; R++)
            E.charCodeAt(R) > 127 ? S += "x" : S += E[R];
          if (!S.match(y1)) {
            var L = w.slice(0, g), K = w.slice(g + 1), ae = E.match(c5);
            ae && (L.push(ae[1]), K.unshift(ae[2])), K.length && (o = "/" + K.join(".") + o), this.hostname = L.join(".");
            break;
          }
        }
      }
    this.hostname.length > u5 ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), y || (this.hostname = XN.toASCII(this.hostname));
    var ye = this.port ? ":" + this.port : "", xe = this.hostname || "";
    this.host = xe + ye, this.href += this.host, y && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), o[0] !== "/" && (o = "/" + o));
  }
  if (!l5[d])
    for (var g = 0, $ = cy.length; g < $; g++) {
      var Pe = cy[g];
      if (o.indexOf(Pe) !== -1) {
        var te = encodeURIComponent(Pe);
        te === Pe && (te = escape(Pe)), o = o.split(Pe).join(te);
      }
    }
  var pe = o.indexOf("#");
  pe !== -1 && (this.hash = o.substr(pe), o = o.slice(0, pe));
  var de = o.indexOf("?");
  if (de !== -1 ? (this.search = o.substr(de), this.query = o.substr(de + 1), t && (this.query = fy.parse(this.query)), o = o.slice(0, de)) : t && (this.search = "", this.query = {}), o && (this.pathname = o), Za[d] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
    var ye = this.pathname || "", Ee = this.search || "";
    this.path = ye + Ee;
  }
  return this.href = this.format(), this;
};
function f5(e) {
  return zn.isString(e) && (e = zu(e)), e instanceof fn ? e.format() : fn.prototype.format.call(e);
}
fn.prototype.format = function() {
  var e = this.auth || "";
  e && (e = encodeURIComponent(e), e = e.replace(/%3A/i, ":"), e += "@");
  var t = this.protocol || "", r = this.pathname || "", i = this.hash || "", n = !1, s = "";
  this.host ? n = e + this.host : this.hostname && (n = e + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"), this.port && (n += ":" + this.port)), this.query && zn.isObject(this.query) && Object.keys(this.query).length && (s = fy.stringify(this.query));
  var a = this.search || s && "?" + s || "";
  return t && t.substr(-1) !== ":" && (t += ":"), this.slashes || (!t || Za[t]) && n !== !1 ? (n = "//" + (n || ""), r && r.charAt(0) !== "/" && (r = "/" + r)) : n || (n = ""), i && i.charAt(0) !== "#" && (i = "#" + i), a && a.charAt(0) !== "?" && (a = "?" + a), r = r.replace(/[?#]/g, function(o) {
    return encodeURIComponent(o);
  }), a = a.replace("#", "%23"), t + n + r + a + i;
};
function d5(e, t) {
  return zu(e, !1, !0).resolve(t);
}
fn.prototype.resolve = function(e) {
  return this.resolveObject(zu(e, !1, !0)).format();
};
function p5(e, t) {
  return e ? zu(e, !1, !0).resolveObject(t) : t;
}
fn.prototype.resolveObject = function(e) {
  if (zn.isString(e)) {
    var t = new fn();
    t.parse(e, !1, !0), e = t;
  }
  for (var r = new fn(), i = Object.keys(this), n = 0; n < i.length; n++) {
    var s = i[n];
    r[s] = this[s];
  }
  if (r.hash = e.hash, e.href === "")
    return r.href = r.format(), r;
  if (e.slashes && !e.protocol) {
    for (var a = Object.keys(e), o = 0; o < a.length; o++) {
      var c = a[o];
      c !== "protocol" && (r[c] = e[c]);
    }
    return Za[r.protocol] && r.hostname && !r.pathname && (r.path = r.pathname = "/"), r.href = r.format(), r;
  }
  if (e.protocol && e.protocol !== r.protocol) {
    if (!Za[e.protocol]) {
      for (var l = Object.keys(e), d = 0; d < l.length; d++) {
        var p = l[d];
        r[p] = e[p];
      }
      return r.href = r.format(), r;
    }
    if (r.protocol = e.protocol, !e.host && !ly[e.protocol]) {
      for (var $ = (e.pathname || "").split("/"); $.length && !(e.host = $.shift()); )
        ;
      e.host || (e.host = ""), e.hostname || (e.hostname = ""), $[0] !== "" && $.unshift(""), $.length < 2 && $.unshift(""), r.pathname = $.join("/");
    } else
      r.pathname = e.pathname;
    if (r.search = e.search, r.query = e.query, r.host = e.host || "", r.auth = e.auth, r.hostname = e.hostname || e.host, r.port = e.port, r.pathname || r.search) {
      var h = r.pathname || "", g = r.search || "";
      r.path = h + g;
    }
    return r.slashes = r.slashes || e.slashes, r.href = r.format(), r;
  }
  var m = r.pathname && r.pathname.charAt(0) === "/", v = e.host || e.pathname && e.pathname.charAt(0) === "/", _ = v || m || r.host && e.pathname, y = _, w = r.pathname && r.pathname.split("/") || [], $ = e.pathname && e.pathname.split("/") || [], E = r.protocol && !Za[r.protocol];
  if (E && (r.hostname = "", r.port = null, r.host && (w[0] === "" ? w[0] = r.host : w.unshift(r.host)), r.host = "", e.protocol && (e.hostname = null, e.port = null, e.host && ($[0] === "" ? $[0] = e.host : $.unshift(e.host)), e.host = null), _ = _ && ($[0] === "" || w[0] === "")), v)
    r.host = e.host || e.host === "" ? e.host : r.host, r.hostname = e.hostname || e.hostname === "" ? e.hostname : r.hostname, r.search = e.search, r.query = e.query, w = $;
  else if ($.length)
    w || (w = []), w.pop(), w = w.concat($), r.search = e.search, r.query = e.query;
  else if (!zn.isNullOrUndefined(e.search)) {
    if (E) {
      r.hostname = r.host = w.shift();
      var S = r.host && r.host.indexOf("@") > 0 ? r.host.split("@") : !1;
      S && (r.auth = S.shift(), r.host = r.hostname = S.shift());
    }
    return r.search = e.search, r.query = e.query, (!zn.isNull(r.pathname) || !zn.isNull(r.search)) && (r.path = (r.pathname ? r.pathname : "") + (r.search ? r.search : "")), r.href = r.format(), r;
  }
  if (!w.length)
    return r.pathname = null, r.search ? r.path = "/" + r.search : r.path = null, r.href = r.format(), r;
  for (var R = w.slice(-1)[0], j = (r.host || e.host || w.length > 1) && (R === "." || R === "..") || R === "", L = 0, K = w.length; K >= 0; K--)
    R = w[K], R === "." ? w.splice(K, 1) : R === ".." ? (w.splice(K, 1), L++) : L && (w.splice(K, 1), L--);
  if (!_ && !y)
    for (; L--; L)
      w.unshift("..");
  _ && w[0] !== "" && (!w[0] || w[0].charAt(0) !== "/") && w.unshift(""), j && w.join("/").substr(-1) !== "/" && w.push("");
  var ae = w[0] === "" || w[0] && w[0].charAt(0) === "/";
  if (E) {
    r.hostname = r.host = ae ? "" : w.length ? w.shift() : "";
    var S = r.host && r.host.indexOf("@") > 0 ? r.host.split("@") : !1;
    S && (r.auth = S.shift(), r.host = r.hostname = S.shift());
  }
  return _ = _ || r.host && w.length, _ && !ae && w.unshift(""), w.length ? r.pathname = w.join("/") : (r.pathname = null, r.path = null), (!zn.isNull(r.pathname) || !zn.isNull(r.search)) && (r.path = (r.pathname ? r.pathname : "") + (r.search ? r.search : "")), r.auth = e.auth || r.auth, r.slashes = r.slashes || e.slashes, r.href = r.format(), r;
};
fn.prototype.parseHost = function() {
  var e = this.host, t = i5.exec(e);
  t && (t = t[0], t !== ":" && (this.port = t.substr(1)), e = e.substr(0, e.length - t.length)), e && (this.hostname = e);
};
function h5(e, t) {
  for (var r = 0, i = e.length - 1; i >= 0; i--) {
    var n = e[i];
    n === "." ? e.splice(i, 1) : n === ".." ? (e.splice(i, 1), r++) : r && (e.splice(i, 1), r--);
  }
  if (t)
    for (; r--; r)
      e.unshift("..");
  return e;
}
function m5() {
  for (var e = "", t = !1, r = arguments.length - 1; r >= -1 && !t; r--) {
    var i = r >= 0 ? arguments[r] : "/";
    if (typeof i != "string")
      throw new TypeError("Arguments to path.resolve must be strings");
    if (!i)
      continue;
    e = i + "/" + e, t = i.charAt(0) === "/";
  }
  return e = h5(y5(e.split("/"), function(n) {
    return !!n;
  }), !t).join("/"), (t ? "/" : "") + e || ".";
}
function y5(e, t) {
  if (e.filter)
    return e.filter(t);
  for (var r = [], i = 0; i < e.length; i++)
    t(e[i], i, e) && r.push(e[i]);
  return r;
}
var ZE = function(e) {
  function t() {
    var i = this || self;
    return delete e.prototype.__magic__, i;
  }
  if (typeof globalThis == "object")
    return globalThis;
  if (this)
    return t();
  e.defineProperty(e.prototype, "__magic__", {
    configurable: !0,
    get: t
  });
  var r = __magic__;
  return r;
}(Object), g5 = (
  /** @type {formatImport}*/
  t5
), zE = (
  /** @type {parseImport}*/
  QN
), WE = (
  /** @type {resolveImport}*/
  e5
), HE = (
  /** @type {UrlImport}*/
  r5
), os = ZE.URL, GE = ZE.URLSearchParams, v5 = /%/g, b5 = /\\/g, _5 = /\n/g, w5 = /\r/g, $5 = /\t/g, E5 = 47;
function x5(e) {
  var t = (
    /** @type {URL|null} */
    e ?? null
  );
  return !!(t !== null && (t != null && t.href) && (t != null && t.origin));
}
function O5(e) {
  if (e.hostname !== "")
    throw new TypeError('File URL host must be "localhost" or empty on browser');
  for (var t = e.pathname, r = 0; r < t.length; r++)
    if (t[r] === "%") {
      var i = t.codePointAt(r + 2) | 32;
      if (t[r + 1] === "2" && i === 102)
        throw new TypeError("File URL path must not include encoded / characters");
    }
  return decodeURIComponent(t);
}
function P5(e) {
  return e.includes("%") && (e = e.replace(v5, "%25")), e.includes("\\") && (e = e.replace(b5, "%5C")), e.includes(`
`) && (e = e.replace(_5, "%0A")), e.includes("\r") && (e = e.replace(w5, "%0D")), e.includes("	") && (e = e.replace($5, "%09")), e;
}
var KE = (
  /**
   * @type {domainToASCII}
   */
  function(t) {
    if (typeof t > "u")
      throw new TypeError('The "domain" argument must be specified');
    return new os("http://" + t).hostname;
  }
), YE = (
  /**
   * @type {domainToUnicode}
   */
  function(t) {
    if (typeof t > "u")
      throw new TypeError('The "domain" argument must be specified');
    return new os("http://" + t).hostname;
  }
), JE = (
  /**
   * @type {(url: string) => URL}
   */
  function(t) {
    var r = new os("file://"), i = m5(t), n = t.charCodeAt(t.length - 1);
    return n === E5 && i[i.length - 1] !== "/" && (i += "/"), r.pathname = P5(i), r;
  }
), XE = (
  /**
   * @type {fileURLToPath & ((path: string | URL) => string)}
   */
  function(t) {
    if (!x5(t) && typeof t != "string")
      throw new TypeError('The "path" argument must be of type string or an instance of URL. Received type ' + typeof t + " (" + t + ")");
    var r = new os(t);
    if (r.protocol !== "file:")
      throw new TypeError("The URL must be of scheme file");
    return O5(r);
  }
), QE = (
  /**
   * @type {(
   *   ((urlObject: URL, options?: URLFormatOptions) => string) &
   *   ((urlObject: UrlObject | string, options?: never) => string)
   * )}
   */
  function(t, r) {
    var i, n, s;
    if (r === void 0 && (r = {}), !(t instanceof os))
      return g5(t);
    if (typeof r != "object" || r === null)
      throw new TypeError('The "options" argument must be of type object.');
    var a = (i = r.auth) != null ? i : !0, o = (n = r.fragment) != null ? n : !0, c = (s = r.search) != null ? s : !0, l = new os(t.toString());
    return a || (l.username = "", l.password = ""), o || (l.hash = ""), c || (l.search = ""), l.toString();
  }
), S5 = {
  format: QE,
  parse: zE,
  resolve: WE,
  resolveObject: VE,
  Url: HE,
  URL: os,
  URLSearchParams: GE,
  domainToASCII: KE,
  domainToUnicode: YE,
  pathToFileURL: JE,
  fileURLToPath: XE
};
const A5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  URL: os,
  URLSearchParams: GE,
  Url: HE,
  default: S5,
  domainToASCII: KE,
  domainToUnicode: YE,
  fileURLToPath: XE,
  format: QE,
  parse: zE,
  pathToFileURL: JE,
  resolve: WE,
  resolveObject: VE
}, Symbol.toStringTag, { value: "Module" })), Ou = /* @__PURE__ */ xf(A5);
(function(e, t) {
  const r = /^win/.test(qe.process.platform), i = /\//g, n = /^(\w{2,}):\/\//i, s = e.exports, a = /~1/g, o = /~0/g, c = [
    /\?/g,
    "%3F",
    /#/g,
    "%23"
  ], l = [
    /%23/g,
    "#",
    /%24/g,
    "$",
    /%26/g,
    "&",
    /%2C/g,
    ",",
    /%40/g,
    "@"
  ];
  t.parse = Ou.parse, t.resolve = Ou.resolve, t.cwd = function() {
    if (qe.process.browser)
      return location.href;
    const p = qe.process.cwd(), h = p.slice(-1);
    return h === "/" || h === "\\" ? p : `${p}/`;
  }, t.getProtocol = function(p) {
    const h = n.exec(p);
    if (h)
      return h[1].toLowerCase();
  }, t.getExtension = function(p) {
    const h = p.lastIndexOf(".");
    return h >= 0 ? s.stripQuery(p.substr(h).toLowerCase()) : "";
  }, t.stripQuery = function(p) {
    const h = p.indexOf("?");
    return h >= 0 && (p = p.substr(0, h)), p;
  }, t.getHash = function(p) {
    const h = p.indexOf("#");
    return h >= 0 ? p.substr(h) : "#";
  }, t.stripHash = function(p) {
    const h = p.indexOf("#");
    return h >= 0 ? p.substr(0, h) : p;
  }, t.isHttp = function(p) {
    const h = s.getProtocol(p);
    return h === "http" || h === "https" ? !0 : h === void 0 ? qe.process.browser : !1;
  }, t.isFileSystemPath = function(p) {
    if (qe.process.browser)
      return !1;
    const h = s.getProtocol(p);
    return h === void 0 || h === "file";
  }, t.fromFileSystemPath = function(p) {
    r && (p = p.replace(/\\/g, "/")), p = encodeURI(p);
    for (let h = 0; h < c.length; h += 2)
      p = p.replace(c[h], c[h + 1]);
    return p;
  }, t.toFileSystemPath = function(p, h) {
    p = decodeURI(p);
    for (let m = 0; m < l.length; m += 2)
      p = p.replace(l[m], l[m + 1]);
    let g = p.substr(0, 7).toLowerCase() === "file://";
    return g && (p = p[7] === "/" ? p.substr(8) : p.substr(7), r && p[1] === "/" && (p = `${p[0]}:${p.substr(1)}`), h ? p = `file:///${p}` : (g = !1, p = r ? p : `/${p}`)), r && !g && (p = p.replace(i, "\\"), p.substr(1, 2) === ":\\" && (p = p[0].toUpperCase() + p.substr(1))), p;
  }, t.safePointerToPath = function(p) {
    return p.length <= 1 || p[0] !== "#" || p[1] !== "/" ? [] : p.slice(2).split("/").map((h) => decodeURIComponent(h).replace(a, "/").replace(o, "~"));
  };
})(uy, uy.exports);
var pn = uy.exports;
const { Ono: ex } = In, { stripHash: tx, toFileSystemPath: C5 } = pn;
function ps(e) {
  Object.defineProperty(e.prototype, "name", {
    value: e.name,
    enumerable: !0
  });
}
const Ci = class extends Error {
  constructor(t, r) {
    super(), this.code = "EUNKNOWN", this.message = t, this.source = r, this.path = null, ex.extend(this);
  }
  get footprint() {
    return `${this.path}+${this.source}+${this.code}+${this.message}`;
  }
};
ir.JSONParserError = Ci;
ps(Ci);
const yg = class rx extends Error {
  constructor(t) {
    super(), this.files = t, this.message = `${this.errors.length} error${this.errors.length > 1 ? "s" : ""} occurred while reading '${C5(t.$refs._root$Ref.path)}'`, ex.extend(this);
  }
  static getParserErrors(t) {
    const r = [];
    for (const i of Object.values(t.$refs._$refs))
      i.errors && r.push(...i.errors);
    return r;
  }
  get errors() {
    return rx.getParserErrors(this.files);
  }
};
ir.JSONParserErrorGroup = yg;
ps(yg);
const nx = class extends Ci {
  constructor(t, r) {
    super(`Error parsing ${r}: ${t}`, r), this.code = "EPARSER";
  }
};
ir.ParserError = nx;
ps(nx);
const ix = class extends Ci {
  constructor(t) {
    super(`Could not find parser for "${t}"`, t), this.code = "EUNMATCHEDPARSER";
  }
};
ir.UnmatchedParserError = ix;
ps(ix);
const sx = class extends Ci {
  constructor(t, r) {
    super(t.message || `Error reading file "${r}"`, r), this.code = "ERESOLVER", "code" in t && (this.ioErrorCode = String(t.code));
  }
};
ir.ResolverError = sx;
ps(sx);
const ax = class extends Ci {
  constructor(t) {
    super(`Could not find resolver for "${t}"`, t), this.code = "EUNMATCHEDRESOLVER";
  }
};
ir.UnmatchedResolverError = ax;
ps(ax);
const ox = class extends Ci {
  constructor(t, r) {
    super(`Token "${t}" does not exist.`, tx(r)), this.code = "EMISSINGPOINTER";
  }
};
ir.MissingPointerError = ox;
ps(ox);
const ux = class extends Ci {
  constructor(t, r) {
    super(`Invalid $ref pointer "${t}". Pointers must begin with "#/"`, tx(r)), this.code = "EINVALIDPOINTER";
  }
};
ir.InvalidPointerError = ux;
ps(ux);
ir.isHandledError = function(e) {
  return e instanceof Ci || e instanceof yg;
};
ir.normalizeError = function(e) {
  return e.path === null && (e.path = []), e;
};
var Ap, g1;
function kf() {
  if (g1)
    return Ap;
  g1 = 1;
  const e = Wu(), { JSONParserError: t, InvalidPointerError: r, MissingPointerError: i, isHandledError: n } = ir, s = pn, a = /\//g, o = /~/g, c = /~1/g, l = /~0/g;
  Ap = d;
  function d(m, v, _) {
    this.$ref = m, this.path = v, this.originalPath = _ || v, this.value = void 0, this.circular = !1, this.indirections = 0;
  }
  d.prototype.resolve = function(m, v, _) {
    const y = d.parse(this.path, this.originalPath);
    this.value = g(m);
    for (let w = 0; w < y.length; w++) {
      if (p(this, v) && (this.path = d.join(this.path, y.slice(w))), typeof this.value == "object" && this.value !== null && "$ref" in this.value)
        return this;
      const $ = y[w];
      if (this.value[$] === void 0 || this.value[$] === null)
        throw this.value = null, new i($, this.originalPath);
      this.value = this.value[$];
    }
    return (!this.value || this.value.$ref && s.resolve(this.path, this.value.$ref) !== _) && p(this, v), this;
  }, d.prototype.set = function(m, v, _) {
    const y = d.parse(this.path);
    let w;
    if (y.length === 0)
      return this.value = v, v;
    this.value = g(m);
    for (let $ = 0; $ < y.length - 1; $++)
      p(this, _), w = y[$], this.value && this.value[w] !== void 0 ? this.value = this.value[w] : this.value = h(this, w, {});
    return p(this, _), w = y[y.length - 1], h(this, w, v), m;
  }, d.parse = function(m, v) {
    let _ = s.getHash(m).substr(1);
    if (!_)
      return [];
    _ = _.split("/");
    for (let y = 0; y < _.length; y++)
      _[y] = decodeURIComponent(_[y].replace(c, "/").replace(l, "~"));
    if (_[0] !== "")
      throw new r(_, v === void 0 ? m : v);
    return _.slice(1);
  }, d.join = function(m, v) {
    m.indexOf("#") === -1 && (m += "#"), v = Array.isArray(v) ? v : [v];
    for (let _ = 0; _ < v.length; _++) {
      const y = v[_];
      m += `/${encodeURIComponent(y.replace(o, "~0").replace(a, "~1"))}`;
    }
    return m;
  };
  function p(m, v) {
    if (e.isAllowed$Ref(m.value, v)) {
      const _ = s.resolve(m.path, m.value.$ref);
      if (_ === m.path)
        m.circular = !0;
      else {
        const y = m.$ref.$refs._resolve(_, m.path, v);
        return y === null ? !1 : (m.indirections += y.indirections + 1, e.isExtended$Ref(m.value) ? (m.value = e.dereference(m.value, y.value), !1) : (m.$ref = y.$ref, m.path = y.path, m.value = y.value, !0));
      }
    }
  }
  function h(m, v, _) {
    if (m.value && typeof m.value == "object")
      v === "-" && Array.isArray(m.value) ? m.value.push(_) : m.value[v] = _;
    else
      throw new t(
        `Error assigning $ref pointer "${m.path}". 
Cannot set "${v}" of a non-object.`
      );
    return _;
  }
  function g(m) {
    if (n(m))
      throw m;
    return m;
  }
  return Ap;
}
var Cp, v1;
function Wu() {
  if (v1)
    return Cp;
  v1 = 1, Cp = o;
  const e = kf(), { InvalidPointerError: t, isHandledError: r, normalizeError: i } = ir, { safePointerToPath: n, stripHash: s, getHash: a } = pn;
  function o() {
    this.path = void 0, this.value = void 0, this.$refs = void 0, this.pathType = void 0, this.errors = void 0;
  }
  return o.prototype.addError = function(c) {
    this.errors === void 0 && (this.errors = []);
    const l = this.errors.map(({ footprint: d }) => d);
    Array.isArray(c.errors) ? this.errors.push(...c.errors.map(i).filter(({ footprint: d }) => !l.includes(d))) : l.includes(c.footprint) || this.errors.push(i(c));
  }, o.prototype.exists = function(c, l) {
    try {
      return this.resolve(c, l), !0;
    } catch {
      return !1;
    }
  }, o.prototype.get = function(c, l) {
    return this.resolve(c, l).value;
  }, o.prototype.resolve = function(c, l, d, p) {
    const h = new e(this, c, d);
    try {
      return h.resolve(this.value, l, p);
    } catch (g) {
      if (!l || !l.continueOnError || !r(g))
        throw g;
      return g.path === null && (g.path = n(a(p))), g instanceof t && (g.source = s(p)), this.addError(g), null;
    }
  }, o.prototype.set = function(c, l) {
    const d = new e(this, c);
    this.value = d.set(this.value, l);
  }, o.is$Ref = function(c) {
    return c && typeof c == "object" && typeof c.$ref == "string" && c.$ref.length > 0;
  }, o.isExternal$Ref = function(c) {
    return o.is$Ref(c) && c.$ref[0] !== "#";
  }, o.isAllowed$Ref = function(c, l) {
    if (o.is$Ref(c)) {
      if (c.$ref.substr(0, 2) === "#/" || c.$ref === "#")
        return !0;
      if (c.$ref[0] !== "#" && (!l || l.resolve.external))
        return !0;
    }
  }, o.isExtended$Ref = function(c) {
    return o.is$Ref(c) && Object.keys(c).length > 1;
  }, o.dereference = function(c, l) {
    if (l && typeof l == "object" && o.isExtended$Ref(c)) {
      const d = {};
      for (const p of Object.keys(c))
        p !== "$ref" && (d[p] = c[p]);
      for (const p of Object.keys(l))
        p in d || (d[p] = l[p]);
      return d;
    }
    return l;
  }, Cp;
}
const tf = Wu(), Pu = kf(), Rp = pn;
var R5 = function(t, r) {
  const i = [];
  gg(t, "schema", `${t.$refs._root$Ref.path}#`, "#", 0, i, t.$refs, r), T5(i);
};
function gg(e, t, r, i, n, s, a, o) {
  const c = t === null ? e : e[t];
  if (c && typeof c == "object" && !ArrayBuffer.isView(c))
    if (tf.isAllowed$Ref(c))
      b1(e, t, r, i, n, s, a, o);
    else {
      const l = Object.keys(c).sort((d, p) => d === "definitions" ? -1 : p === "definitions" ? 1 : d.length - p.length);
      for (const d of l) {
        const p = Pu.join(r, d), h = Pu.join(i, d), g = c[d];
        tf.isAllowed$Ref(g) ? b1(c, d, r, h, n, s, a, o) : gg(c, d, p, h, n, s, a, o);
      }
    }
}
function b1(e, t, r, i, n, s, a, o) {
  const c = t === null ? e : e[t], l = Rp.resolve(r, c.$ref), d = a._resolve(l, i, o);
  if (d === null)
    return;
  const p = Pu.parse(i).length, h = Rp.stripHash(d.path), g = Rp.getHash(d.path), m = h !== a._root$Ref.path, v = tf.isExtended$Ref(c);
  n += d.indirections;
  const _ = I5(s, e, t);
  if (_)
    if (p < _.depth || n < _.indirections)
      j5(s, _);
    else
      return;
  s.push({
    $ref: c,
    // The JSON Reference (e.g. {$ref: string})
    parent: e,
    // The object that contains this $ref pointer
    key: t,
    // The key in `parent` that is the $ref pointer
    pathFromRoot: i,
    // The path to the $ref pointer, from the JSON Schema root
    depth: p,
    // How far from the JSON Schema root is this $ref pointer?
    file: h,
    // The file that the $ref pointer resolves to
    hash: g,
    // The hash within `file` that the $ref pointer resolves to
    value: d.value,
    // The resolved value of the $ref pointer
    circular: d.circular,
    // Is this $ref pointer DIRECTLY circular? (i.e. it references itself)
    extended: v,
    // Does this $ref extend its resolved value? (i.e. it has extra properties, in addition to "$ref")
    external: m,
    // Does this $ref pointer point to a file other than the main JSON Schema file?
    indirections: n
    // The number of indirect references that were traversed to resolve the value
  }), _ || gg(d.value, null, d.path, i, n + 1, s, a, o);
}
function T5(e) {
  e.sort((n, s) => {
    if (n.file !== s.file)
      return n.file < s.file ? -1 : 1;
    if (n.hash !== s.hash)
      return n.hash < s.hash ? -1 : 1;
    if (n.circular !== s.circular)
      return n.circular ? -1 : 1;
    if (n.extended !== s.extended)
      return n.extended ? 1 : -1;
    if (n.indirections !== s.indirections)
      return n.indirections - s.indirections;
    if (n.depth !== s.depth)
      return n.depth - s.depth;
    const a = n.pathFromRoot.lastIndexOf("/definitions"), o = s.pathFromRoot.lastIndexOf("/definitions");
    return a !== o ? o - a : n.pathFromRoot.length - s.pathFromRoot.length;
  });
  let t, r, i;
  for (const n of e)
    n.external ? n.file === t && n.hash === r ? n.$ref.$ref = i : n.file === t && n.hash.indexOf(`${r}/`) === 0 ? n.$ref.$ref = Pu.join(i, Pu.parse(n.hash.replace(r, "#"))) : (t = n.file, r = n.hash, i = n.pathFromRoot, n.parent[n.key] = tf.dereference(n.$ref, n.value), n.$ref = n.parent[n.key], n.circular && (n.$ref.$ref = n.pathFromRoot)) : n.$ref.$ref = n.hash;
}
function I5(e, t, r) {
  for (let i = 0; i < e.length; i++) {
    const n = e[i];
    if (n.parent === t && n.key === r)
      return n;
  }
}
function j5(e, t) {
  const r = e.indexOf(t);
  e.splice(r, 1);
}
const { ono: k5 } = In, _1 = kf(), dy = Wu(), M5 = pn;
var cx = function(t, r) {
  const i = vg(
    t.schema,
    t.$refs._root$Ref.path,
    "#",
    /* @__PURE__ */ new Set(),
    /* @__PURE__ */ new Set(),
    /* @__PURE__ */ new Map(),
    t.$refs,
    r
  );
  t.$refs.circular = i.circular, t.schema = i.value;
};
function vg(e, t, r, i, n, s, a, o) {
  let c;
  const l = {
    value: e,
    circular: !1
  };
  if ((o.dereference.circular === "ignore" || !n.has(e)) && e && typeof e == "object" && !ArrayBuffer.isView(e)) {
    if (i.add(e), n.add(e), dy.isAllowed$Ref(e, o))
      c = w1(
        e,
        t,
        r,
        i,
        n,
        s,
        a,
        o
      ), l.circular = c.circular, l.value = c.value, e.description && (l.value.description = e.description), e.summary && (l.value.summary = e.summary);
    else
      for (const d of Object.keys(e)) {
        const p = _1.join(t, d), h = _1.join(r, d), g = e[d];
        let m = !1;
        dy.isAllowed$Ref(g, o) ? (c = w1(
          g,
          p,
          h,
          i,
          n,
          s,
          a,
          o
        ), m = c.circular, e[d] !== c.value && (e[d] = c.value, g.description && (e[d].description = g.description), g.summary && (e[d].summary = g.summary))) : i.has(g) ? m = lx(p, a, o) : (c = vg(
          g,
          p,
          h,
          i,
          n,
          s,
          a,
          o
        ), m = c.circular, e[d] !== c.value && (e[d] = c.value)), l.circular = l.circular || m;
      }
    i.delete(e);
  }
  return l;
}
function w1(e, t, r, i, n, s, a, o) {
  const c = M5.resolve(t, e.$ref), l = s.get(c);
  if (l) {
    const v = Object.keys(e);
    if (v.length > 1) {
      const _ = {};
      for (const y of v)
        y !== "$ref" && !(y in l.value) && (_[y] = e[y]);
      return {
        circular: l.circular,
        value: { ...l.value, ..._ }
      };
    }
    return l;
  }
  const d = a._resolve(c, t, o);
  if (d === null)
    return {
      circular: !1,
      value: null
    };
  const p = d.circular;
  let h = p || i.has(d.value);
  h && lx(t, a, o);
  let g = dy.dereference(e, d.value);
  if (!h) {
    const v = vg(
      g,
      d.path,
      r,
      i,
      n,
      s,
      a,
      o
    );
    h = v.circular, g = v.value;
  }
  h && !p && o.dereference.circular === "ignore" && (g = e), p && (g.$ref = r);
  const m = {
    circular: h,
    value: g
  };
  return Object.keys(e).length === 1 && s.set(c, m), m;
}
function lx(e, t, r) {
  if (t.circular = !0, t.circularRefs.push(e), !r.dereference.circular)
    throw k5.reference(`Circular $ref pointer found at ${e}`);
  return !0;
}
const N5 = /\.(jpeg|jpg|gif|png|bmp|ico)$/i;
var D5 = {
  /**
   * The order that this parser will run, in relation to other parsers.
   *
   * @type {number}
   */
  order: 400,
  /**
   * Whether to allow "empty" files (zero bytes).
   *
   * @type {boolean}
   */
  allowEmpty: !0,
  /**
   * Determines whether this parser can parse a given file reference.
   * Parsers that return true will be tried, in order, until one successfully parses the file.
   * Parsers that return false will be skipped, UNLESS all parsers returned false, in which case
   * every parser will be tried.
   *
   * @param {object} file           - An object containing information about the referenced file
   * @param {string} file.url       - The full URL of the referenced file
   * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
   * @returns {boolean}
   */
  canParse(e) {
    return qe.Buffer.isBuffer(e.data) && N5.test(e.url);
  },
  /**
   * Parses the given data as a Buffer (byte array).
   *
   * @param {object} file           - An object containing information about the referenced file
   * @param {string} file.url       - The full URL of the referenced file
   * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
   * @returns {Buffer}
   */
  parse(e) {
    return qe.Buffer.isBuffer(e.data) ? e.data : qe.Buffer.from(e.data);
  }
};
const { ParserError: L5 } = ir;
var q5 = {
  /**
   * The order that this parser will run, in relation to other parsers.
   *
   * @type {number}
   */
  order: 100,
  /**
   * Whether to allow "empty" files. This includes zero-byte files, as well as empty JSON objects.
   *
   * @type {boolean}
   */
  allowEmpty: !0,
  /**
   * Determines whether this parser can parse a given file reference.
   * Parsers that match will be tried, in order, until one successfully parses the file.
   * Parsers that don't match will be skipped, UNLESS none of the parsers match, in which case
   * every parser will be tried.
   *
   * @type {RegExp|string|string[]|function}
   */
  canParse: ".json",
  /**
   * Parses the given file as JSON
   *
   * @param {object} file           - An object containing information about the referenced file
   * @param {string} file.url       - The full URL of the referenced file
   * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
   * @returns {Promise}
   */
  // eslint-disable-next-line require-await
  async parse(e) {
    let t = e.data;
    if (qe.Buffer.isBuffer(t) && (t = t.toString()), typeof t == "string") {
      if (t.trim().length === 0)
        return;
      try {
        return JSON.parse(t);
      } catch (r) {
        throw new L5(r.message, e.url);
      }
    }
    return t;
  }
};
const { ParserError: F5 } = ir, U5 = /\.(txt|htm|html|md|xml|js|min|map|css|scss|less|svg)$/i;
var B5 = {
  /**
   * The order that this parser will run, in relation to other parsers.
   *
   * @type {number}
   */
  order: 300,
  /**
   * Whether to allow "empty" files (zero bytes).
   *
   * @type {boolean}
   */
  allowEmpty: !0,
  /**
   * The encoding that the text is expected to be in.
   *
   * @type {string}
   */
  encoding: "utf8",
  /**
   * Determines whether this parser can parse a given file reference.
   * Parsers that return true will be tried, in order, until one successfully parses the file.
   * Parsers that return false will be skipped, UNLESS all parsers returned false, in which case
   * every parser will be tried.
   *
   * @param {object} file           - An object containing information about the referenced file
   * @param {string} file.url       - The full URL of the referenced file
   * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
   * @returns {boolean}
   */
  canParse(e) {
    return (typeof e.data == "string" || qe.Buffer.isBuffer(e.data)) && U5.test(e.url);
  },
  /**
   * Parses the given file as text
   *
   * @param {object} file           - An object containing information about the referenced file
   * @param {string} file.url       - The full URL of the referenced file
   * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
   * @returns {string}
   */
  parse(e) {
    if (typeof e.data == "string")
      return e.data;
    if (qe.Buffer.isBuffer(e.data))
      return e.data.toString(this.encoding);
    throw new F5("data is not text", e.url);
  }
}, gr = {}, bg = {}, jn = {};
function fx(e) {
  return typeof e > "u" || e === null;
}
function V5(e) {
  return typeof e == "object" && e !== null;
}
function Z5(e) {
  return Array.isArray(e) ? e : fx(e) ? [] : [e];
}
function z5(e, t) {
  var r, i, n, s;
  if (t)
    for (s = Object.keys(t), r = 0, i = s.length; r < i; r += 1)
      n = s[r], e[n] = t[n];
  return e;
}
function W5(e, t) {
  var r = "", i;
  for (i = 0; i < t; i += 1)
    r += e;
  return r;
}
function H5(e) {
  return e === 0 && Number.NEGATIVE_INFINITY === 1 / e;
}
jn.isNothing = fx;
jn.isObject = V5;
jn.toArray = Z5;
jn.repeat = W5;
jn.isNegativeZero = H5;
jn.extend = z5;
function dx(e, t) {
  var r = "", i = e.reason || "(unknown reason)";
  return e.mark ? (e.mark.name && (r += 'in "' + e.mark.name + '" '), r += "(" + (e.mark.line + 1) + ":" + (e.mark.column + 1) + ")", !t && e.mark.snippet && (r += `

` + e.mark.snippet), i + " " + r) : i;
}
function Su(e, t) {
  Error.call(this), this.name = "YAMLException", this.reason = e, this.mark = t, this.message = dx(this, !1), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack || "";
}
Su.prototype = Object.create(Error.prototype);
Su.prototype.constructor = Su;
Su.prototype.toString = function(t) {
  return this.name + ": " + dx(this, t);
};
var Hu = Su, Yo = jn;
function Tp(e, t, r, i, n) {
  var s = "", a = "", o = Math.floor(n / 2) - 1;
  return i - t > o && (s = " ... ", t = i - o + s.length), r - i > o && (a = " ...", r = i + o - a.length), {
    str: s + e.slice(t, r).replace(/\t/g, "") + a,
    pos: i - t + s.length
    // relative position
  };
}
function Ip(e, t) {
  return Yo.repeat(" ", t - e.length) + e;
}
function G5(e, t) {
  if (t = Object.create(t || null), !e.buffer)
    return null;
  t.maxLength || (t.maxLength = 79), typeof t.indent != "number" && (t.indent = 1), typeof t.linesBefore != "number" && (t.linesBefore = 3), typeof t.linesAfter != "number" && (t.linesAfter = 2);
  for (var r = /\r?\n|\r|\0/g, i = [0], n = [], s, a = -1; s = r.exec(e.buffer); )
    n.push(s.index), i.push(s.index + s[0].length), e.position <= s.index && a < 0 && (a = i.length - 2);
  a < 0 && (a = i.length - 1);
  var o = "", c, l, d = Math.min(e.line + t.linesAfter, n.length).toString().length, p = t.maxLength - (t.indent + d + 3);
  for (c = 1; c <= t.linesBefore && !(a - c < 0); c++)
    l = Tp(
      e.buffer,
      i[a - c],
      n[a - c],
      e.position - (i[a] - i[a - c]),
      p
    ), o = Yo.repeat(" ", t.indent) + Ip((e.line - c + 1).toString(), d) + " | " + l.str + `
` + o;
  for (l = Tp(e.buffer, i[a], n[a], e.position, p), o += Yo.repeat(" ", t.indent) + Ip((e.line + 1).toString(), d) + " | " + l.str + `
`, o += Yo.repeat("-", t.indent + d + 3 + l.pos) + `^
`, c = 1; c <= t.linesAfter && !(a + c >= n.length); c++)
    l = Tp(
      e.buffer,
      i[a + c],
      n[a + c],
      e.position - (i[a] - i[a + c]),
      p
    ), o += Yo.repeat(" ", t.indent) + Ip((e.line + c + 1).toString(), d) + " | " + l.str + `
`;
  return o.replace(/\n$/, "");
}
var K5 = G5, $1 = Hu, Y5 = [
  "kind",
  "multi",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "representName",
  "defaultStyle",
  "styleAliases"
], J5 = [
  "scalar",
  "sequence",
  "mapping"
];
function X5(e) {
  var t = {};
  return e !== null && Object.keys(e).forEach(function(r) {
    e[r].forEach(function(i) {
      t[String(i)] = r;
    });
  }), t;
}
function Q5(e, t) {
  if (t = t || {}, Object.keys(t).forEach(function(r) {
    if (Y5.indexOf(r) === -1)
      throw new $1('Unknown option "' + r + '" is met in definition of "' + e + '" YAML type.');
  }), this.options = t, this.tag = e, this.kind = t.kind || null, this.resolve = t.resolve || function() {
    return !0;
  }, this.construct = t.construct || function(r) {
    return r;
  }, this.instanceOf = t.instanceOf || null, this.predicate = t.predicate || null, this.represent = t.represent || null, this.representName = t.representName || null, this.defaultStyle = t.defaultStyle || null, this.multi = t.multi || !1, this.styleAliases = X5(t.styleAliases || null), J5.indexOf(this.kind) === -1)
    throw new $1('Unknown kind "' + this.kind + '" is specified for "' + e + '" YAML type.');
}
var Nr = Q5, Lo = Hu, jp = Nr;
function E1(e, t) {
  var r = [];
  return e[t].forEach(function(i) {
    var n = r.length;
    r.forEach(function(s, a) {
      s.tag === i.tag && s.kind === i.kind && s.multi === i.multi && (n = a);
    }), r[n] = i;
  }), r;
}
function eD() {
  var e = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, t, r;
  function i(n) {
    n.multi ? (e.multi[n.kind].push(n), e.multi.fallback.push(n)) : e[n.kind][n.tag] = e.fallback[n.tag] = n;
  }
  for (t = 0, r = arguments.length; t < r; t += 1)
    arguments[t].forEach(i);
  return e;
}
function py(e) {
  return this.extend(e);
}
py.prototype.extend = function(t) {
  var r = [], i = [];
  if (t instanceof jp)
    i.push(t);
  else if (Array.isArray(t))
    i = i.concat(t);
  else if (t && (Array.isArray(t.implicit) || Array.isArray(t.explicit)))
    t.implicit && (r = r.concat(t.implicit)), t.explicit && (i = i.concat(t.explicit));
  else
    throw new Lo("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  r.forEach(function(s) {
    if (!(s instanceof jp))
      throw new Lo("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    if (s.loadKind && s.loadKind !== "scalar")
      throw new Lo("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    if (s.multi)
      throw new Lo("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
  }), i.forEach(function(s) {
    if (!(s instanceof jp))
      throw new Lo("Specified list of YAML types (or a single Type object) contains a non-Type object.");
  });
  var n = Object.create(py.prototype);
  return n.implicit = (this.implicit || []).concat(r), n.explicit = (this.explicit || []).concat(i), n.compiledImplicit = E1(n, "implicit"), n.compiledExplicit = E1(n, "explicit"), n.compiledTypeMap = eD(n.compiledImplicit, n.compiledExplicit), n;
};
var px = py, tD = Nr, hx = new tD("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: function(e) {
    return e !== null ? e : "";
  }
}), rD = Nr, mx = new rD("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: function(e) {
    return e !== null ? e : [];
  }
}), nD = Nr, yx = new nD("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: function(e) {
    return e !== null ? e : {};
  }
}), iD = px, gx = new iD({
  explicit: [
    hx,
    mx,
    yx
  ]
}), sD = Nr;
function aD(e) {
  if (e === null)
    return !0;
  var t = e.length;
  return t === 1 && e === "~" || t === 4 && (e === "null" || e === "Null" || e === "NULL");
}
function oD() {
  return null;
}
function uD(e) {
  return e === null;
}
var vx = new sD("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: aD,
  construct: oD,
  predicate: uD,
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    },
    empty: function() {
      return "";
    }
  },
  defaultStyle: "lowercase"
}), cD = Nr;
function lD(e) {
  if (e === null)
    return !1;
  var t = e.length;
  return t === 4 && (e === "true" || e === "True" || e === "TRUE") || t === 5 && (e === "false" || e === "False" || e === "FALSE");
}
function fD(e) {
  return e === "true" || e === "True" || e === "TRUE";
}
function dD(e) {
  return Object.prototype.toString.call(e) === "[object Boolean]";
}
var bx = new cD("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: lD,
  construct: fD,
  predicate: dD,
  represent: {
    lowercase: function(e) {
      return e ? "true" : "false";
    },
    uppercase: function(e) {
      return e ? "TRUE" : "FALSE";
    },
    camelcase: function(e) {
      return e ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
}), pD = jn, hD = Nr;
function mD(e) {
  return 48 <= e && e <= 57 || 65 <= e && e <= 70 || 97 <= e && e <= 102;
}
function yD(e) {
  return 48 <= e && e <= 55;
}
function gD(e) {
  return 48 <= e && e <= 57;
}
function vD(e) {
  if (e === null)
    return !1;
  var t = e.length, r = 0, i = !1, n;
  if (!t)
    return !1;
  if (n = e[r], (n === "-" || n === "+") && (n = e[++r]), n === "0") {
    if (r + 1 === t)
      return !0;
    if (n = e[++r], n === "b") {
      for (r++; r < t; r++)
        if (n = e[r], n !== "_") {
          if (n !== "0" && n !== "1")
            return !1;
          i = !0;
        }
      return i && n !== "_";
    }
    if (n === "x") {
      for (r++; r < t; r++)
        if (n = e[r], n !== "_") {
          if (!mD(e.charCodeAt(r)))
            return !1;
          i = !0;
        }
      return i && n !== "_";
    }
    if (n === "o") {
      for (r++; r < t; r++)
        if (n = e[r], n !== "_") {
          if (!yD(e.charCodeAt(r)))
            return !1;
          i = !0;
        }
      return i && n !== "_";
    }
  }
  if (n === "_")
    return !1;
  for (; r < t; r++)
    if (n = e[r], n !== "_") {
      if (!gD(e.charCodeAt(r)))
        return !1;
      i = !0;
    }
  return !(!i || n === "_");
}
function bD(e) {
  var t = e, r = 1, i;
  if (t.indexOf("_") !== -1 && (t = t.replace(/_/g, "")), i = t[0], (i === "-" || i === "+") && (i === "-" && (r = -1), t = t.slice(1), i = t[0]), t === "0")
    return 0;
  if (i === "0") {
    if (t[1] === "b")
      return r * parseInt(t.slice(2), 2);
    if (t[1] === "x")
      return r * parseInt(t.slice(2), 16);
    if (t[1] === "o")
      return r * parseInt(t.slice(2), 8);
  }
  return r * parseInt(t, 10);
}
function _D(e) {
  return Object.prototype.toString.call(e) === "[object Number]" && e % 1 === 0 && !pD.isNegativeZero(e);
}
var _x = new hD("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: vD,
  construct: bD,
  predicate: _D,
  represent: {
    binary: function(e) {
      return e >= 0 ? "0b" + e.toString(2) : "-0b" + e.toString(2).slice(1);
    },
    octal: function(e) {
      return e >= 0 ? "0o" + e.toString(8) : "-0o" + e.toString(8).slice(1);
    },
    decimal: function(e) {
      return e.toString(10);
    },
    /* eslint-disable max-len */
    hexadecimal: function(e) {
      return e >= 0 ? "0x" + e.toString(16).toUpperCase() : "-0x" + e.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
}), wx = jn, wD = Nr, $D = new RegExp(
  // 2.5e4, 2.5 and integers
  "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function ED(e) {
  return !(e === null || !$D.test(e) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  e[e.length - 1] === "_");
}
function xD(e) {
  var t, r;
  return t = e.replace(/_/g, "").toLowerCase(), r = t[0] === "-" ? -1 : 1, "+-".indexOf(t[0]) >= 0 && (t = t.slice(1)), t === ".inf" ? r === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY : t === ".nan" ? NaN : r * parseFloat(t, 10);
}
var OD = /^[-+]?[0-9]+e/;
function PD(e, t) {
  var r;
  if (isNaN(e))
    switch (t) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  else if (Number.POSITIVE_INFINITY === e)
    switch (t) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  else if (Number.NEGATIVE_INFINITY === e)
    switch (t) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  else if (wx.isNegativeZero(e))
    return "-0.0";
  return r = e.toString(10), OD.test(r) ? r.replace("e", ".e") : r;
}
function SD(e) {
  return Object.prototype.toString.call(e) === "[object Number]" && (e % 1 !== 0 || wx.isNegativeZero(e));
}
var $x = new wD("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: ED,
  construct: xD,
  predicate: SD,
  represent: PD,
  defaultStyle: "lowercase"
}), Ex = gx.extend({
  implicit: [
    vx,
    bx,
    _x,
    $x
  ]
}), xx = Ex, AD = Nr, Ox = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
), Px = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
);
function CD(e) {
  return e === null ? !1 : Ox.exec(e) !== null || Px.exec(e) !== null;
}
function RD(e) {
  var t, r, i, n, s, a, o, c = 0, l = null, d, p, h;
  if (t = Ox.exec(e), t === null && (t = Px.exec(e)), t === null)
    throw new Error("Date resolve error");
  if (r = +t[1], i = +t[2] - 1, n = +t[3], !t[4])
    return new Date(Date.UTC(r, i, n));
  if (s = +t[4], a = +t[5], o = +t[6], t[7]) {
    for (c = t[7].slice(0, 3); c.length < 3; )
      c += "0";
    c = +c;
  }
  return t[9] && (d = +t[10], p = +(t[11] || 0), l = (d * 60 + p) * 6e4, t[9] === "-" && (l = -l)), h = new Date(Date.UTC(r, i, n, s, a, o, c)), l && h.setTime(h.getTime() - l), h;
}
function TD(e) {
  return e.toISOString();
}
var Sx = new AD("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: CD,
  construct: RD,
  instanceOf: Date,
  represent: TD
}), ID = Nr;
function jD(e) {
  return e === "<<" || e === null;
}
var Ax = new ID("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: jD
}), kD = Nr, _g = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`;
function MD(e) {
  if (e === null)
    return !1;
  var t, r, i = 0, n = e.length, s = _g;
  for (r = 0; r < n; r++)
    if (t = s.indexOf(e.charAt(r)), !(t > 64)) {
      if (t < 0)
        return !1;
      i += 6;
    }
  return i % 8 === 0;
}
function ND(e) {
  var t, r, i = e.replace(/[\r\n=]/g, ""), n = i.length, s = _g, a = 0, o = [];
  for (t = 0; t < n; t++)
    t % 4 === 0 && t && (o.push(a >> 16 & 255), o.push(a >> 8 & 255), o.push(a & 255)), a = a << 6 | s.indexOf(i.charAt(t));
  return r = n % 4 * 6, r === 0 ? (o.push(a >> 16 & 255), o.push(a >> 8 & 255), o.push(a & 255)) : r === 18 ? (o.push(a >> 10 & 255), o.push(a >> 2 & 255)) : r === 12 && o.push(a >> 4 & 255), new Uint8Array(o);
}
function DD(e) {
  var t = "", r = 0, i, n, s = e.length, a = _g;
  for (i = 0; i < s; i++)
    i % 3 === 0 && i && (t += a[r >> 18 & 63], t += a[r >> 12 & 63], t += a[r >> 6 & 63], t += a[r & 63]), r = (r << 8) + e[i];
  return n = s % 3, n === 0 ? (t += a[r >> 18 & 63], t += a[r >> 12 & 63], t += a[r >> 6 & 63], t += a[r & 63]) : n === 2 ? (t += a[r >> 10 & 63], t += a[r >> 4 & 63], t += a[r << 2 & 63], t += a[64]) : n === 1 && (t += a[r >> 2 & 63], t += a[r << 4 & 63], t += a[64], t += a[64]), t;
}
function LD(e) {
  return Object.prototype.toString.call(e) === "[object Uint8Array]";
}
var Cx = new kD("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: MD,
  construct: ND,
  predicate: LD,
  represent: DD
}), qD = Nr, FD = Object.prototype.hasOwnProperty, UD = Object.prototype.toString;
function BD(e) {
  if (e === null)
    return !0;
  var t = [], r, i, n, s, a, o = e;
  for (r = 0, i = o.length; r < i; r += 1) {
    if (n = o[r], a = !1, UD.call(n) !== "[object Object]")
      return !1;
    for (s in n)
      if (FD.call(n, s))
        if (!a)
          a = !0;
        else
          return !1;
    if (!a)
      return !1;
    if (t.indexOf(s) === -1)
      t.push(s);
    else
      return !1;
  }
  return !0;
}
function VD(e) {
  return e !== null ? e : [];
}
var Rx = new qD("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: BD,
  construct: VD
}), ZD = Nr, zD = Object.prototype.toString;
function WD(e) {
  if (e === null)
    return !0;
  var t, r, i, n, s, a = e;
  for (s = new Array(a.length), t = 0, r = a.length; t < r; t += 1) {
    if (i = a[t], zD.call(i) !== "[object Object]" || (n = Object.keys(i), n.length !== 1))
      return !1;
    s[t] = [n[0], i[n[0]]];
  }
  return !0;
}
function HD(e) {
  if (e === null)
    return [];
  var t, r, i, n, s, a = e;
  for (s = new Array(a.length), t = 0, r = a.length; t < r; t += 1)
    i = a[t], n = Object.keys(i), s[t] = [n[0], i[n[0]]];
  return s;
}
var Tx = new ZD("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: WD,
  construct: HD
}), GD = Nr, KD = Object.prototype.hasOwnProperty;
function YD(e) {
  if (e === null)
    return !0;
  var t, r = e;
  for (t in r)
    if (KD.call(r, t) && r[t] !== null)
      return !1;
  return !0;
}
function JD(e) {
  return e !== null ? e : {};
}
var Ix = new GD("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: YD,
  construct: JD
}), wg = xx.extend({
  implicit: [
    Sx,
    Ax
  ],
  explicit: [
    Cx,
    Rx,
    Tx,
    Ix
  ]
}), js = jn, jx = Hu, XD = K5, QD = wg, us = Object.prototype.hasOwnProperty, rf = 1, kx = 2, Mx = 3, nf = 4, kp = 1, eL = 2, x1 = 3, tL = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, rL = /[\x85\u2028\u2029]/, nL = /[,\[\]\{\}]/, Nx = /^(?:!|!!|![a-z\-]+!)$/i, Dx = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function O1(e) {
  return Object.prototype.toString.call(e);
}
function Yn(e) {
  return e === 10 || e === 13;
}
function Vs(e) {
  return e === 9 || e === 32;
}
function Vr(e) {
  return e === 9 || e === 32 || e === 10 || e === 13;
}
function Na(e) {
  return e === 44 || e === 91 || e === 93 || e === 123 || e === 125;
}
function iL(e) {
  var t;
  return 48 <= e && e <= 57 ? e - 48 : (t = e | 32, 97 <= t && t <= 102 ? t - 97 + 10 : -1);
}
function sL(e) {
  return e === 120 ? 2 : e === 117 ? 4 : e === 85 ? 8 : 0;
}
function aL(e) {
  return 48 <= e && e <= 57 ? e - 48 : -1;
}
function P1(e) {
  return e === 48 ? "\0" : e === 97 ? "\x07" : e === 98 ? "\b" : e === 116 || e === 9 ? "	" : e === 110 ? `
` : e === 118 ? "\v" : e === 102 ? "\f" : e === 114 ? "\r" : e === 101 ? "\x1B" : e === 32 ? " " : e === 34 ? '"' : e === 47 ? "/" : e === 92 ? "\\" : e === 78 ? "" : e === 95 ? "" : e === 76 ? "\u2028" : e === 80 ? "\u2029" : "";
}
function oL(e) {
  return e <= 65535 ? String.fromCharCode(e) : String.fromCharCode(
    (e - 65536 >> 10) + 55296,
    (e - 65536 & 1023) + 56320
  );
}
var Lx = new Array(256), qx = new Array(256);
for (var Ea = 0; Ea < 256; Ea++)
  Lx[Ea] = P1(Ea) ? 1 : 0, qx[Ea] = P1(Ea);
function uL(e, t) {
  this.input = e, this.filename = t.filename || null, this.schema = t.schema || QD, this.onWarning = t.onWarning || null, this.legacy = t.legacy || !1, this.json = t.json || !1, this.listener = t.listener || null, this.implicitTypes = this.schema.compiledImplicit, this.typeMap = this.schema.compiledTypeMap, this.length = e.length, this.position = 0, this.line = 0, this.lineStart = 0, this.lineIndent = 0, this.firstTabInLine = -1, this.documents = [];
}
function Fx(e, t) {
  var r = {
    name: e.filename,
    buffer: e.input.slice(0, -1),
    // omit trailing \0
    position: e.position,
    line: e.line,
    column: e.position - e.lineStart
  };
  return r.snippet = XD(r), new jx(t, r);
}
function Qe(e, t) {
  throw Fx(e, t);
}
function sf(e, t) {
  e.onWarning && e.onWarning.call(null, Fx(e, t));
}
var S1 = {
  YAML: function(t, r, i) {
    var n, s, a;
    t.version !== null && Qe(t, "duplication of %YAML directive"), i.length !== 1 && Qe(t, "YAML directive accepts exactly one argument"), n = /^([0-9]+)\.([0-9]+)$/.exec(i[0]), n === null && Qe(t, "ill-formed argument of the YAML directive"), s = parseInt(n[1], 10), a = parseInt(n[2], 10), s !== 1 && Qe(t, "unacceptable YAML version of the document"), t.version = i[0], t.checkLineBreaks = a < 2, a !== 1 && a !== 2 && sf(t, "unsupported YAML version of the document");
  },
  TAG: function(t, r, i) {
    var n, s;
    i.length !== 2 && Qe(t, "TAG directive accepts exactly two arguments"), n = i[0], s = i[1], Nx.test(n) || Qe(t, "ill-formed tag handle (first argument) of the TAG directive"), us.call(t.tagMap, n) && Qe(t, 'there is a previously declared suffix for "' + n + '" tag handle'), Dx.test(s) || Qe(t, "ill-formed tag prefix (second argument) of the TAG directive");
    try {
      s = decodeURIComponent(s);
    } catch {
      Qe(t, "tag prefix is malformed: " + s);
    }
    t.tagMap[n] = s;
  }
};
function rs(e, t, r, i) {
  var n, s, a, o;
  if (t < r) {
    if (o = e.input.slice(t, r), i)
      for (n = 0, s = o.length; n < s; n += 1)
        a = o.charCodeAt(n), a === 9 || 32 <= a && a <= 1114111 || Qe(e, "expected valid JSON character");
    else
      tL.test(o) && Qe(e, "the stream contains non-printable characters");
    e.result += o;
  }
}
function A1(e, t, r, i) {
  var n, s, a, o;
  for (js.isObject(r) || Qe(e, "cannot merge mappings; the provided source object is unacceptable"), n = Object.keys(r), a = 0, o = n.length; a < o; a += 1)
    s = n[a], us.call(t, s) || (t[s] = r[s], i[s] = !0);
}
function Da(e, t, r, i, n, s, a, o, c) {
  var l, d;
  if (Array.isArray(n))
    for (n = Array.prototype.slice.call(n), l = 0, d = n.length; l < d; l += 1)
      Array.isArray(n[l]) && Qe(e, "nested arrays are not supported inside keys"), typeof n == "object" && O1(n[l]) === "[object Object]" && (n[l] = "[object Object]");
  if (typeof n == "object" && O1(n) === "[object Object]" && (n = "[object Object]"), n = String(n), t === null && (t = {}), i === "tag:yaml.org,2002:merge")
    if (Array.isArray(s))
      for (l = 0, d = s.length; l < d; l += 1)
        A1(e, t, s[l], r);
    else
      A1(e, t, s, r);
  else
    !e.json && !us.call(r, n) && us.call(t, n) && (e.line = a || e.line, e.lineStart = o || e.lineStart, e.position = c || e.position, Qe(e, "duplicated mapping key")), n === "__proto__" ? Object.defineProperty(t, n, {
      configurable: !0,
      enumerable: !0,
      writable: !0,
      value: s
    }) : t[n] = s, delete r[n];
  return t;
}
function $g(e) {
  var t;
  t = e.input.charCodeAt(e.position), t === 10 ? e.position++ : t === 13 ? (e.position++, e.input.charCodeAt(e.position) === 10 && e.position++) : Qe(e, "a line break is expected"), e.line += 1, e.lineStart = e.position, e.firstTabInLine = -1;
}
function nr(e, t, r) {
  for (var i = 0, n = e.input.charCodeAt(e.position); n !== 0; ) {
    for (; Vs(n); )
      n === 9 && e.firstTabInLine === -1 && (e.firstTabInLine = e.position), n = e.input.charCodeAt(++e.position);
    if (t && n === 35)
      do
        n = e.input.charCodeAt(++e.position);
      while (n !== 10 && n !== 13 && n !== 0);
    if (Yn(n))
      for ($g(e), n = e.input.charCodeAt(e.position), i++, e.lineIndent = 0; n === 32; )
        e.lineIndent++, n = e.input.charCodeAt(++e.position);
    else
      break;
  }
  return r !== -1 && i !== 0 && e.lineIndent < r && sf(e, "deficient indentation"), i;
}
function Mf(e) {
  var t = e.position, r;
  return r = e.input.charCodeAt(t), !!((r === 45 || r === 46) && r === e.input.charCodeAt(t + 1) && r === e.input.charCodeAt(t + 2) && (t += 3, r = e.input.charCodeAt(t), r === 0 || Vr(r)));
}
function Eg(e, t) {
  t === 1 ? e.result += " " : t > 1 && (e.result += js.repeat(`
`, t - 1));
}
function cL(e, t, r) {
  var i, n, s, a, o, c, l, d, p = e.kind, h = e.result, g;
  if (g = e.input.charCodeAt(e.position), Vr(g) || Na(g) || g === 35 || g === 38 || g === 42 || g === 33 || g === 124 || g === 62 || g === 39 || g === 34 || g === 37 || g === 64 || g === 96 || (g === 63 || g === 45) && (n = e.input.charCodeAt(e.position + 1), Vr(n) || r && Na(n)))
    return !1;
  for (e.kind = "scalar", e.result = "", s = a = e.position, o = !1; g !== 0; ) {
    if (g === 58) {
      if (n = e.input.charCodeAt(e.position + 1), Vr(n) || r && Na(n))
        break;
    } else if (g === 35) {
      if (i = e.input.charCodeAt(e.position - 1), Vr(i))
        break;
    } else {
      if (e.position === e.lineStart && Mf(e) || r && Na(g))
        break;
      if (Yn(g))
        if (c = e.line, l = e.lineStart, d = e.lineIndent, nr(e, !1, -1), e.lineIndent >= t) {
          o = !0, g = e.input.charCodeAt(e.position);
          continue;
        } else {
          e.position = a, e.line = c, e.lineStart = l, e.lineIndent = d;
          break;
        }
    }
    o && (rs(e, s, a, !1), Eg(e, e.line - c), s = a = e.position, o = !1), Vs(g) || (a = e.position + 1), g = e.input.charCodeAt(++e.position);
  }
  return rs(e, s, a, !1), e.result ? !0 : (e.kind = p, e.result = h, !1);
}
function lL(e, t) {
  var r, i, n;
  if (r = e.input.charCodeAt(e.position), r !== 39)
    return !1;
  for (e.kind = "scalar", e.result = "", e.position++, i = n = e.position; (r = e.input.charCodeAt(e.position)) !== 0; )
    if (r === 39)
      if (rs(e, i, e.position, !0), r = e.input.charCodeAt(++e.position), r === 39)
        i = e.position, e.position++, n = e.position;
      else
        return !0;
    else
      Yn(r) ? (rs(e, i, n, !0), Eg(e, nr(e, !1, t)), i = n = e.position) : e.position === e.lineStart && Mf(e) ? Qe(e, "unexpected end of the document within a single quoted scalar") : (e.position++, n = e.position);
  Qe(e, "unexpected end of the stream within a single quoted scalar");
}
function fL(e, t) {
  var r, i, n, s, a, o;
  if (o = e.input.charCodeAt(e.position), o !== 34)
    return !1;
  for (e.kind = "scalar", e.result = "", e.position++, r = i = e.position; (o = e.input.charCodeAt(e.position)) !== 0; ) {
    if (o === 34)
      return rs(e, r, e.position, !0), e.position++, !0;
    if (o === 92) {
      if (rs(e, r, e.position, !0), o = e.input.charCodeAt(++e.position), Yn(o))
        nr(e, !1, t);
      else if (o < 256 && Lx[o])
        e.result += qx[o], e.position++;
      else if ((a = sL(o)) > 0) {
        for (n = a, s = 0; n > 0; n--)
          o = e.input.charCodeAt(++e.position), (a = iL(o)) >= 0 ? s = (s << 4) + a : Qe(e, "expected hexadecimal character");
        e.result += oL(s), e.position++;
      } else
        Qe(e, "unknown escape sequence");
      r = i = e.position;
    } else
      Yn(o) ? (rs(e, r, i, !0), Eg(e, nr(e, !1, t)), r = i = e.position) : e.position === e.lineStart && Mf(e) ? Qe(e, "unexpected end of the document within a double quoted scalar") : (e.position++, i = e.position);
  }
  Qe(e, "unexpected end of the stream within a double quoted scalar");
}
function dL(e, t) {
  var r = !0, i, n, s, a = e.tag, o, c = e.anchor, l, d, p, h, g, m = /* @__PURE__ */ Object.create(null), v, _, y, w;
  if (w = e.input.charCodeAt(e.position), w === 91)
    d = 93, g = !1, o = [];
  else if (w === 123)
    d = 125, g = !0, o = {};
  else
    return !1;
  for (e.anchor !== null && (e.anchorMap[e.anchor] = o), w = e.input.charCodeAt(++e.position); w !== 0; ) {
    if (nr(e, !0, t), w = e.input.charCodeAt(e.position), w === d)
      return e.position++, e.tag = a, e.anchor = c, e.kind = g ? "mapping" : "sequence", e.result = o, !0;
    r ? w === 44 && Qe(e, "expected the node content, but found ','") : Qe(e, "missed comma between flow collection entries"), _ = v = y = null, p = h = !1, w === 63 && (l = e.input.charCodeAt(e.position + 1), Vr(l) && (p = h = !0, e.position++, nr(e, !0, t))), i = e.line, n = e.lineStart, s = e.position, Xa(e, t, rf, !1, !0), _ = e.tag, v = e.result, nr(e, !0, t), w = e.input.charCodeAt(e.position), (h || e.line === i) && w === 58 && (p = !0, w = e.input.charCodeAt(++e.position), nr(e, !0, t), Xa(e, t, rf, !1, !0), y = e.result), g ? Da(e, o, m, _, v, y, i, n, s) : p ? o.push(Da(e, null, m, _, v, y, i, n, s)) : o.push(v), nr(e, !0, t), w = e.input.charCodeAt(e.position), w === 44 ? (r = !0, w = e.input.charCodeAt(++e.position)) : r = !1;
  }
  Qe(e, "unexpected end of the stream within a flow collection");
}
function pL(e, t) {
  var r, i, n = kp, s = !1, a = !1, o = t, c = 0, l = !1, d, p;
  if (p = e.input.charCodeAt(e.position), p === 124)
    i = !1;
  else if (p === 62)
    i = !0;
  else
    return !1;
  for (e.kind = "scalar", e.result = ""; p !== 0; )
    if (p = e.input.charCodeAt(++e.position), p === 43 || p === 45)
      kp === n ? n = p === 43 ? x1 : eL : Qe(e, "repeat of a chomping mode identifier");
    else if ((d = aL(p)) >= 0)
      d === 0 ? Qe(e, "bad explicit indentation width of a block scalar; it cannot be less than one") : a ? Qe(e, "repeat of an indentation width identifier") : (o = t + d - 1, a = !0);
    else
      break;
  if (Vs(p)) {
    do
      p = e.input.charCodeAt(++e.position);
    while (Vs(p));
    if (p === 35)
      do
        p = e.input.charCodeAt(++e.position);
      while (!Yn(p) && p !== 0);
  }
  for (; p !== 0; ) {
    for ($g(e), e.lineIndent = 0, p = e.input.charCodeAt(e.position); (!a || e.lineIndent < o) && p === 32; )
      e.lineIndent++, p = e.input.charCodeAt(++e.position);
    if (!a && e.lineIndent > o && (o = e.lineIndent), Yn(p)) {
      c++;
      continue;
    }
    if (e.lineIndent < o) {
      n === x1 ? e.result += js.repeat(`
`, s ? 1 + c : c) : n === kp && s && (e.result += `
`);
      break;
    }
    for (i ? Vs(p) ? (l = !0, e.result += js.repeat(`
`, s ? 1 + c : c)) : l ? (l = !1, e.result += js.repeat(`
`, c + 1)) : c === 0 ? s && (e.result += " ") : e.result += js.repeat(`
`, c) : e.result += js.repeat(`
`, s ? 1 + c : c), s = !0, a = !0, c = 0, r = e.position; !Yn(p) && p !== 0; )
      p = e.input.charCodeAt(++e.position);
    rs(e, r, e.position, !1);
  }
  return !0;
}
function C1(e, t) {
  var r, i = e.tag, n = e.anchor, s = [], a, o = !1, c;
  if (e.firstTabInLine !== -1)
    return !1;
  for (e.anchor !== null && (e.anchorMap[e.anchor] = s), c = e.input.charCodeAt(e.position); c !== 0 && (e.firstTabInLine !== -1 && (e.position = e.firstTabInLine, Qe(e, "tab characters must not be used in indentation")), !(c !== 45 || (a = e.input.charCodeAt(e.position + 1), !Vr(a)))); ) {
    if (o = !0, e.position++, nr(e, !0, -1) && e.lineIndent <= t) {
      s.push(null), c = e.input.charCodeAt(e.position);
      continue;
    }
    if (r = e.line, Xa(e, t, Mx, !1, !0), s.push(e.result), nr(e, !0, -1), c = e.input.charCodeAt(e.position), (e.line === r || e.lineIndent > t) && c !== 0)
      Qe(e, "bad indentation of a sequence entry");
    else if (e.lineIndent < t)
      break;
  }
  return o ? (e.tag = i, e.anchor = n, e.kind = "sequence", e.result = s, !0) : !1;
}
function hL(e, t, r) {
  var i, n, s, a, o, c, l = e.tag, d = e.anchor, p = {}, h = /* @__PURE__ */ Object.create(null), g = null, m = null, v = null, _ = !1, y = !1, w;
  if (e.firstTabInLine !== -1)
    return !1;
  for (e.anchor !== null && (e.anchorMap[e.anchor] = p), w = e.input.charCodeAt(e.position); w !== 0; ) {
    if (!_ && e.firstTabInLine !== -1 && (e.position = e.firstTabInLine, Qe(e, "tab characters must not be used in indentation")), i = e.input.charCodeAt(e.position + 1), s = e.line, (w === 63 || w === 58) && Vr(i))
      w === 63 ? (_ && (Da(e, p, h, g, m, null, a, o, c), g = m = v = null), y = !0, _ = !0, n = !0) : _ ? (_ = !1, n = !0) : Qe(e, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"), e.position += 1, w = i;
    else {
      if (a = e.line, o = e.lineStart, c = e.position, !Xa(e, r, kx, !1, !0))
        break;
      if (e.line === s) {
        for (w = e.input.charCodeAt(e.position); Vs(w); )
          w = e.input.charCodeAt(++e.position);
        if (w === 58)
          w = e.input.charCodeAt(++e.position), Vr(w) || Qe(e, "a whitespace character is expected after the key-value separator within a block mapping"), _ && (Da(e, p, h, g, m, null, a, o, c), g = m = v = null), y = !0, _ = !1, n = !1, g = e.tag, m = e.result;
        else if (y)
          Qe(e, "can not read an implicit mapping pair; a colon is missed");
        else
          return e.tag = l, e.anchor = d, !0;
      } else if (y)
        Qe(e, "can not read a block mapping entry; a multiline key may not be an implicit key");
      else
        return e.tag = l, e.anchor = d, !0;
    }
    if ((e.line === s || e.lineIndent > t) && (_ && (a = e.line, o = e.lineStart, c = e.position), Xa(e, t, nf, !0, n) && (_ ? m = e.result : v = e.result), _ || (Da(e, p, h, g, m, v, a, o, c), g = m = v = null), nr(e, !0, -1), w = e.input.charCodeAt(e.position)), (e.line === s || e.lineIndent > t) && w !== 0)
      Qe(e, "bad indentation of a mapping entry");
    else if (e.lineIndent < t)
      break;
  }
  return _ && Da(e, p, h, g, m, null, a, o, c), y && (e.tag = l, e.anchor = d, e.kind = "mapping", e.result = p), y;
}
function mL(e) {
  var t, r = !1, i = !1, n, s, a;
  if (a = e.input.charCodeAt(e.position), a !== 33)
    return !1;
  if (e.tag !== null && Qe(e, "duplication of a tag property"), a = e.input.charCodeAt(++e.position), a === 60 ? (r = !0, a = e.input.charCodeAt(++e.position)) : a === 33 ? (i = !0, n = "!!", a = e.input.charCodeAt(++e.position)) : n = "!", t = e.position, r) {
    do
      a = e.input.charCodeAt(++e.position);
    while (a !== 0 && a !== 62);
    e.position < e.length ? (s = e.input.slice(t, e.position), a = e.input.charCodeAt(++e.position)) : Qe(e, "unexpected end of the stream within a verbatim tag");
  } else {
    for (; a !== 0 && !Vr(a); )
      a === 33 && (i ? Qe(e, "tag suffix cannot contain exclamation marks") : (n = e.input.slice(t - 1, e.position + 1), Nx.test(n) || Qe(e, "named tag handle cannot contain such characters"), i = !0, t = e.position + 1)), a = e.input.charCodeAt(++e.position);
    s = e.input.slice(t, e.position), nL.test(s) && Qe(e, "tag suffix cannot contain flow indicator characters");
  }
  s && !Dx.test(s) && Qe(e, "tag name cannot contain such characters: " + s);
  try {
    s = decodeURIComponent(s);
  } catch {
    Qe(e, "tag name is malformed: " + s);
  }
  return r ? e.tag = s : us.call(e.tagMap, n) ? e.tag = e.tagMap[n] + s : n === "!" ? e.tag = "!" + s : n === "!!" ? e.tag = "tag:yaml.org,2002:" + s : Qe(e, 'undeclared tag handle "' + n + '"'), !0;
}
function yL(e) {
  var t, r;
  if (r = e.input.charCodeAt(e.position), r !== 38)
    return !1;
  for (e.anchor !== null && Qe(e, "duplication of an anchor property"), r = e.input.charCodeAt(++e.position), t = e.position; r !== 0 && !Vr(r) && !Na(r); )
    r = e.input.charCodeAt(++e.position);
  return e.position === t && Qe(e, "name of an anchor node must contain at least one character"), e.anchor = e.input.slice(t, e.position), !0;
}
function gL(e) {
  var t, r, i;
  if (i = e.input.charCodeAt(e.position), i !== 42)
    return !1;
  for (i = e.input.charCodeAt(++e.position), t = e.position; i !== 0 && !Vr(i) && !Na(i); )
    i = e.input.charCodeAt(++e.position);
  return e.position === t && Qe(e, "name of an alias node must contain at least one character"), r = e.input.slice(t, e.position), us.call(e.anchorMap, r) || Qe(e, 'unidentified alias "' + r + '"'), e.result = e.anchorMap[r], nr(e, !0, -1), !0;
}
function Xa(e, t, r, i, n) {
  var s, a, o, c = 1, l = !1, d = !1, p, h, g, m, v, _;
  if (e.listener !== null && e.listener("open", e), e.tag = null, e.anchor = null, e.kind = null, e.result = null, s = a = o = nf === r || Mx === r, i && nr(e, !0, -1) && (l = !0, e.lineIndent > t ? c = 1 : e.lineIndent === t ? c = 0 : e.lineIndent < t && (c = -1)), c === 1)
    for (; mL(e) || yL(e); )
      nr(e, !0, -1) ? (l = !0, o = s, e.lineIndent > t ? c = 1 : e.lineIndent === t ? c = 0 : e.lineIndent < t && (c = -1)) : o = !1;
  if (o && (o = l || n), (c === 1 || nf === r) && (rf === r || kx === r ? v = t : v = t + 1, _ = e.position - e.lineStart, c === 1 ? o && (C1(e, _) || hL(e, _, v)) || dL(e, v) ? d = !0 : (a && pL(e, v) || lL(e, v) || fL(e, v) ? d = !0 : gL(e) ? (d = !0, (e.tag !== null || e.anchor !== null) && Qe(e, "alias node should not have any properties")) : cL(e, v, rf === r) && (d = !0, e.tag === null && (e.tag = "?")), e.anchor !== null && (e.anchorMap[e.anchor] = e.result)) : c === 0 && (d = o && C1(e, _))), e.tag === null)
    e.anchor !== null && (e.anchorMap[e.anchor] = e.result);
  else if (e.tag === "?") {
    for (e.result !== null && e.kind !== "scalar" && Qe(e, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + e.kind + '"'), p = 0, h = e.implicitTypes.length; p < h; p += 1)
      if (m = e.implicitTypes[p], m.resolve(e.result)) {
        e.result = m.construct(e.result), e.tag = m.tag, e.anchor !== null && (e.anchorMap[e.anchor] = e.result);
        break;
      }
  } else if (e.tag !== "!") {
    if (us.call(e.typeMap[e.kind || "fallback"], e.tag))
      m = e.typeMap[e.kind || "fallback"][e.tag];
    else
      for (m = null, g = e.typeMap.multi[e.kind || "fallback"], p = 0, h = g.length; p < h; p += 1)
        if (e.tag.slice(0, g[p].tag.length) === g[p].tag) {
          m = g[p];
          break;
        }
    m || Qe(e, "unknown tag !<" + e.tag + ">"), e.result !== null && m.kind !== e.kind && Qe(e, "unacceptable node kind for !<" + e.tag + '> tag; it should be "' + m.kind + '", not "' + e.kind + '"'), m.resolve(e.result, e.tag) ? (e.result = m.construct(e.result, e.tag), e.anchor !== null && (e.anchorMap[e.anchor] = e.result)) : Qe(e, "cannot resolve a node with !<" + e.tag + "> explicit tag");
  }
  return e.listener !== null && e.listener("close", e), e.tag !== null || e.anchor !== null || d;
}
function vL(e) {
  var t = e.position, r, i, n, s = !1, a;
  for (e.version = null, e.checkLineBreaks = e.legacy, e.tagMap = /* @__PURE__ */ Object.create(null), e.anchorMap = /* @__PURE__ */ Object.create(null); (a = e.input.charCodeAt(e.position)) !== 0 && (nr(e, !0, -1), a = e.input.charCodeAt(e.position), !(e.lineIndent > 0 || a !== 37)); ) {
    for (s = !0, a = e.input.charCodeAt(++e.position), r = e.position; a !== 0 && !Vr(a); )
      a = e.input.charCodeAt(++e.position);
    for (i = e.input.slice(r, e.position), n = [], i.length < 1 && Qe(e, "directive name must not be less than one character in length"); a !== 0; ) {
      for (; Vs(a); )
        a = e.input.charCodeAt(++e.position);
      if (a === 35) {
        do
          a = e.input.charCodeAt(++e.position);
        while (a !== 0 && !Yn(a));
        break;
      }
      if (Yn(a))
        break;
      for (r = e.position; a !== 0 && !Vr(a); )
        a = e.input.charCodeAt(++e.position);
      n.push(e.input.slice(r, e.position));
    }
    a !== 0 && $g(e), us.call(S1, i) ? S1[i](e, i, n) : sf(e, 'unknown document directive "' + i + '"');
  }
  if (nr(e, !0, -1), e.lineIndent === 0 && e.input.charCodeAt(e.position) === 45 && e.input.charCodeAt(e.position + 1) === 45 && e.input.charCodeAt(e.position + 2) === 45 ? (e.position += 3, nr(e, !0, -1)) : s && Qe(e, "directives end mark is expected"), Xa(e, e.lineIndent - 1, nf, !1, !0), nr(e, !0, -1), e.checkLineBreaks && rL.test(e.input.slice(t, e.position)) && sf(e, "non-ASCII line breaks are interpreted as content"), e.documents.push(e.result), e.position === e.lineStart && Mf(e)) {
    e.input.charCodeAt(e.position) === 46 && (e.position += 3, nr(e, !0, -1));
    return;
  }
  if (e.position < e.length - 1)
    Qe(e, "end of the stream or a document separator is expected");
  else
    return;
}
function Ux(e, t) {
  e = String(e), t = t || {}, e.length !== 0 && (e.charCodeAt(e.length - 1) !== 10 && e.charCodeAt(e.length - 1) !== 13 && (e += `
`), e.charCodeAt(0) === 65279 && (e = e.slice(1)));
  var r = new uL(e, t), i = e.indexOf("\0");
  for (i !== -1 && (r.position = i, Qe(r, "null byte is not allowed in input")), r.input += "\0"; r.input.charCodeAt(r.position) === 32; )
    r.lineIndent += 1, r.position += 1;
  for (; r.position < r.length - 1; )
    vL(r);
  return r.documents;
}
function bL(e, t, r) {
  t !== null && typeof t == "object" && typeof r > "u" && (r = t, t = null);
  var i = Ux(e, r);
  if (typeof t != "function")
    return i;
  for (var n = 0, s = i.length; n < s; n += 1)
    t(i[n]);
}
function _L(e, t) {
  var r = Ux(e, t);
  if (r.length !== 0) {
    if (r.length === 1)
      return r[0];
    throw new jx("expected a single document in the stream, but found more");
  }
}
bg.loadAll = bL;
bg.load = _L;
var Bx = {}, Nf = jn, Gu = Hu, wL = wg, Vx = Object.prototype.toString, Zx = Object.prototype.hasOwnProperty, xg = 65279, $L = 9, Au = 10, EL = 13, xL = 32, OL = 33, PL = 34, hy = 35, SL = 37, AL = 38, CL = 39, RL = 42, zx = 44, TL = 45, af = 58, IL = 61, jL = 62, kL = 63, ML = 64, Wx = 91, Hx = 93, NL = 96, Gx = 123, DL = 124, Kx = 125, Sr = {};
Sr[0] = "\\0";
Sr[7] = "\\a";
Sr[8] = "\\b";
Sr[9] = "\\t";
Sr[10] = "\\n";
Sr[11] = "\\v";
Sr[12] = "\\f";
Sr[13] = "\\r";
Sr[27] = "\\e";
Sr[34] = '\\"';
Sr[92] = "\\\\";
Sr[133] = "\\N";
Sr[160] = "\\_";
Sr[8232] = "\\L";
Sr[8233] = "\\P";
var LL = [
  "y",
  "Y",
  "yes",
  "Yes",
  "YES",
  "on",
  "On",
  "ON",
  "n",
  "N",
  "no",
  "No",
  "NO",
  "off",
  "Off",
  "OFF"
], qL = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function FL(e, t) {
  var r, i, n, s, a, o, c;
  if (t === null)
    return {};
  for (r = {}, i = Object.keys(t), n = 0, s = i.length; n < s; n += 1)
    a = i[n], o = String(t[a]), a.slice(0, 2) === "!!" && (a = "tag:yaml.org,2002:" + a.slice(2)), c = e.compiledTypeMap.fallback[a], c && Zx.call(c.styleAliases, o) && (o = c.styleAliases[o]), r[a] = o;
  return r;
}
function UL(e) {
  var t, r, i;
  if (t = e.toString(16).toUpperCase(), e <= 255)
    r = "x", i = 2;
  else if (e <= 65535)
    r = "u", i = 4;
  else if (e <= 4294967295)
    r = "U", i = 8;
  else
    throw new Gu("code point within a string may not be greater than 0xFFFFFFFF");
  return "\\" + r + Nf.repeat("0", i - t.length) + t;
}
var BL = 1, Cu = 2;
function VL(e) {
  this.schema = e.schema || wL, this.indent = Math.max(1, e.indent || 2), this.noArrayIndent = e.noArrayIndent || !1, this.skipInvalid = e.skipInvalid || !1, this.flowLevel = Nf.isNothing(e.flowLevel) ? -1 : e.flowLevel, this.styleMap = FL(this.schema, e.styles || null), this.sortKeys = e.sortKeys || !1, this.lineWidth = e.lineWidth || 80, this.noRefs = e.noRefs || !1, this.noCompatMode = e.noCompatMode || !1, this.condenseFlow = e.condenseFlow || !1, this.quotingType = e.quotingType === '"' ? Cu : BL, this.forceQuotes = e.forceQuotes || !1, this.replacer = typeof e.replacer == "function" ? e.replacer : null, this.implicitTypes = this.schema.compiledImplicit, this.explicitTypes = this.schema.compiledExplicit, this.tag = null, this.result = "", this.duplicates = [], this.usedDuplicates = null;
}
function R1(e, t) {
  for (var r = Nf.repeat(" ", t), i = 0, n = -1, s = "", a, o = e.length; i < o; )
    n = e.indexOf(`
`, i), n === -1 ? (a = e.slice(i), i = o) : (a = e.slice(i, n + 1), i = n + 1), a.length && a !== `
` && (s += r), s += a;
  return s;
}
function my(e, t) {
  return `
` + Nf.repeat(" ", e.indent * t);
}
function ZL(e, t) {
  var r, i, n;
  for (r = 0, i = e.implicitTypes.length; r < i; r += 1)
    if (n = e.implicitTypes[r], n.resolve(t))
      return !0;
  return !1;
}
function of(e) {
  return e === xL || e === $L;
}
function Ru(e) {
  return 32 <= e && e <= 126 || 161 <= e && e <= 55295 && e !== 8232 && e !== 8233 || 57344 <= e && e <= 65533 && e !== xg || 65536 <= e && e <= 1114111;
}
function T1(e) {
  return Ru(e) && e !== xg && e !== EL && e !== Au;
}
function I1(e, t, r) {
  var i = T1(e), n = i && !of(e);
  return (
    // ns-plain-safe
    (r ? (
      // c = flow-in
      i
    ) : i && e !== zx && e !== Wx && e !== Hx && e !== Gx && e !== Kx) && e !== hy && !(t === af && !n) || T1(t) && !of(t) && e === hy || t === af && n
  );
}
function zL(e) {
  return Ru(e) && e !== xg && !of(e) && e !== TL && e !== kL && e !== af && e !== zx && e !== Wx && e !== Hx && e !== Gx && e !== Kx && e !== hy && e !== AL && e !== RL && e !== OL && e !== DL && e !== IL && e !== jL && e !== CL && e !== PL && e !== SL && e !== ML && e !== NL;
}
function WL(e) {
  return !of(e) && e !== af;
}
function Jo(e, t) {
  var r = e.charCodeAt(t), i;
  return r >= 55296 && r <= 56319 && t + 1 < e.length && (i = e.charCodeAt(t + 1), i >= 56320 && i <= 57343) ? (r - 55296) * 1024 + i - 56320 + 65536 : r;
}
function Yx(e) {
  var t = /^\n* /;
  return t.test(e);
}
var Jx = 1, yy = 2, Xx = 3, Qx = 4, Ia = 5;
function HL(e, t, r, i, n, s, a, o) {
  var c, l = 0, d = null, p = !1, h = !1, g = i !== -1, m = -1, v = zL(Jo(e, 0)) && WL(Jo(e, e.length - 1));
  if (t || a)
    for (c = 0; c < e.length; l >= 65536 ? c += 2 : c++) {
      if (l = Jo(e, c), !Ru(l))
        return Ia;
      v = v && I1(l, d, o), d = l;
    }
  else {
    for (c = 0; c < e.length; l >= 65536 ? c += 2 : c++) {
      if (l = Jo(e, c), l === Au)
        p = !0, g && (h = h || // Foldable line = too long, and not more-indented.
        c - m - 1 > i && e[m + 1] !== " ", m = c);
      else if (!Ru(l))
        return Ia;
      v = v && I1(l, d, o), d = l;
    }
    h = h || g && c - m - 1 > i && e[m + 1] !== " ";
  }
  return !p && !h ? v && !a && !n(e) ? Jx : s === Cu ? Ia : yy : r > 9 && Yx(e) ? Ia : a ? s === Cu ? Ia : yy : h ? Qx : Xx;
}
function GL(e, t, r, i, n) {
  e.dump = function() {
    if (t.length === 0)
      return e.quotingType === Cu ? '""' : "''";
    if (!e.noCompatMode && (LL.indexOf(t) !== -1 || qL.test(t)))
      return e.quotingType === Cu ? '"' + t + '"' : "'" + t + "'";
    var s = e.indent * Math.max(1, r), a = e.lineWidth === -1 ? -1 : Math.max(Math.min(e.lineWidth, 40), e.lineWidth - s), o = i || e.flowLevel > -1 && r >= e.flowLevel;
    function c(l) {
      return ZL(e, l);
    }
    switch (HL(
      t,
      o,
      e.indent,
      a,
      c,
      e.quotingType,
      e.forceQuotes && !i,
      n
    )) {
      case Jx:
        return t;
      case yy:
        return "'" + t.replace(/'/g, "''") + "'";
      case Xx:
        return "|" + j1(t, e.indent) + k1(R1(t, s));
      case Qx:
        return ">" + j1(t, e.indent) + k1(R1(KL(t, a), s));
      case Ia:
        return '"' + YL(t) + '"';
      default:
        throw new Gu("impossible error: invalid scalar style");
    }
  }();
}
function j1(e, t) {
  var r = Yx(e) ? String(t) : "", i = e[e.length - 1] === `
`, n = i && (e[e.length - 2] === `
` || e === `
`), s = n ? "+" : i ? "" : "-";
  return r + s + `
`;
}
function k1(e) {
  return e[e.length - 1] === `
` ? e.slice(0, -1) : e;
}
function KL(e, t) {
  for (var r = /(\n+)([^\n]*)/g, i = function() {
    var l = e.indexOf(`
`);
    return l = l !== -1 ? l : e.length, r.lastIndex = l, M1(e.slice(0, l), t);
  }(), n = e[0] === `
` || e[0] === " ", s, a; a = r.exec(e); ) {
    var o = a[1], c = a[2];
    s = c[0] === " ", i += o + (!n && !s && c !== "" ? `
` : "") + M1(c, t), n = s;
  }
  return i;
}
function M1(e, t) {
  if (e === "" || e[0] === " ")
    return e;
  for (var r = / [^ ]/g, i, n = 0, s, a = 0, o = 0, c = ""; i = r.exec(e); )
    o = i.index, o - n > t && (s = a > n ? a : o, c += `
` + e.slice(n, s), n = s + 1), a = o;
  return c += `
`, e.length - n > t && a > n ? c += e.slice(n, a) + `
` + e.slice(a + 1) : c += e.slice(n), c.slice(1);
}
function YL(e) {
  for (var t = "", r = 0, i, n = 0; n < e.length; r >= 65536 ? n += 2 : n++)
    r = Jo(e, n), i = Sr[r], !i && Ru(r) ? (t += e[n], r >= 65536 && (t += e[n + 1])) : t += i || UL(r);
  return t;
}
function JL(e, t, r) {
  var i = "", n = e.tag, s, a, o;
  for (s = 0, a = r.length; s < a; s += 1)
    o = r[s], e.replacer && (o = e.replacer.call(r, String(s), o)), (Pi(e, t, o, !1, !1) || typeof o > "u" && Pi(e, t, null, !1, !1)) && (i !== "" && (i += "," + (e.condenseFlow ? "" : " ")), i += e.dump);
  e.tag = n, e.dump = "[" + i + "]";
}
function N1(e, t, r, i) {
  var n = "", s = e.tag, a, o, c;
  for (a = 0, o = r.length; a < o; a += 1)
    c = r[a], e.replacer && (c = e.replacer.call(r, String(a), c)), (Pi(e, t + 1, c, !0, !0, !1, !0) || typeof c > "u" && Pi(e, t + 1, null, !0, !0, !1, !0)) && ((!i || n !== "") && (n += my(e, t)), e.dump && Au === e.dump.charCodeAt(0) ? n += "-" : n += "- ", n += e.dump);
  e.tag = s, e.dump = n || "[]";
}
function XL(e, t, r) {
  var i = "", n = e.tag, s = Object.keys(r), a, o, c, l, d;
  for (a = 0, o = s.length; a < o; a += 1)
    d = "", i !== "" && (d += ", "), e.condenseFlow && (d += '"'), c = s[a], l = r[c], e.replacer && (l = e.replacer.call(r, c, l)), Pi(e, t, c, !1, !1) && (e.dump.length > 1024 && (d += "? "), d += e.dump + (e.condenseFlow ? '"' : "") + ":" + (e.condenseFlow ? "" : " "), Pi(e, t, l, !1, !1) && (d += e.dump, i += d));
  e.tag = n, e.dump = "{" + i + "}";
}
function QL(e, t, r, i) {
  var n = "", s = e.tag, a = Object.keys(r), o, c, l, d, p, h;
  if (e.sortKeys === !0)
    a.sort();
  else if (typeof e.sortKeys == "function")
    a.sort(e.sortKeys);
  else if (e.sortKeys)
    throw new Gu("sortKeys must be a boolean or a function");
  for (o = 0, c = a.length; o < c; o += 1)
    h = "", (!i || n !== "") && (h += my(e, t)), l = a[o], d = r[l], e.replacer && (d = e.replacer.call(r, l, d)), Pi(e, t + 1, l, !0, !0, !0) && (p = e.tag !== null && e.tag !== "?" || e.dump && e.dump.length > 1024, p && (e.dump && Au === e.dump.charCodeAt(0) ? h += "?" : h += "? "), h += e.dump, p && (h += my(e, t)), Pi(e, t + 1, d, !0, p) && (e.dump && Au === e.dump.charCodeAt(0) ? h += ":" : h += ": ", h += e.dump, n += h));
  e.tag = s, e.dump = n || "{}";
}
function D1(e, t, r) {
  var i, n, s, a, o, c;
  for (n = r ? e.explicitTypes : e.implicitTypes, s = 0, a = n.length; s < a; s += 1)
    if (o = n[s], (o.instanceOf || o.predicate) && (!o.instanceOf || typeof t == "object" && t instanceof o.instanceOf) && (!o.predicate || o.predicate(t))) {
      if (r ? o.multi && o.representName ? e.tag = o.representName(t) : e.tag = o.tag : e.tag = "?", o.represent) {
        if (c = e.styleMap[o.tag] || o.defaultStyle, Vx.call(o.represent) === "[object Function]")
          i = o.represent(t, c);
        else if (Zx.call(o.represent, c))
          i = o.represent[c](t, c);
        else
          throw new Gu("!<" + o.tag + '> tag resolver accepts not "' + c + '" style');
        e.dump = i;
      }
      return !0;
    }
  return !1;
}
function Pi(e, t, r, i, n, s, a) {
  e.tag = null, e.dump = r, D1(e, r, !1) || D1(e, r, !0);
  var o = Vx.call(e.dump), c = i, l;
  i && (i = e.flowLevel < 0 || e.flowLevel > t);
  var d = o === "[object Object]" || o === "[object Array]", p, h;
  if (d && (p = e.duplicates.indexOf(r), h = p !== -1), (e.tag !== null && e.tag !== "?" || h || e.indent !== 2 && t > 0) && (n = !1), h && e.usedDuplicates[p])
    e.dump = "*ref_" + p;
  else {
    if (d && h && !e.usedDuplicates[p] && (e.usedDuplicates[p] = !0), o === "[object Object]")
      i && Object.keys(e.dump).length !== 0 ? (QL(e, t, e.dump, n), h && (e.dump = "&ref_" + p + e.dump)) : (XL(e, t, e.dump), h && (e.dump = "&ref_" + p + " " + e.dump));
    else if (o === "[object Array]")
      i && e.dump.length !== 0 ? (e.noArrayIndent && !a && t > 0 ? N1(e, t - 1, e.dump, n) : N1(e, t, e.dump, n), h && (e.dump = "&ref_" + p + e.dump)) : (JL(e, t, e.dump), h && (e.dump = "&ref_" + p + " " + e.dump));
    else if (o === "[object String]")
      e.tag !== "?" && GL(e, e.dump, t, s, c);
    else {
      if (o === "[object Undefined]")
        return !1;
      if (e.skipInvalid)
        return !1;
      throw new Gu("unacceptable kind of an object to dump " + o);
    }
    e.tag !== null && e.tag !== "?" && (l = encodeURI(
      e.tag[0] === "!" ? e.tag.slice(1) : e.tag
    ).replace(/!/g, "%21"), e.tag[0] === "!" ? l = "!" + l : l.slice(0, 18) === "tag:yaml.org,2002:" ? l = "!!" + l.slice(18) : l = "!<" + l + ">", e.dump = l + " " + e.dump);
  }
  return !0;
}
function e6(e, t) {
  var r = [], i = [], n, s;
  for (gy(e, r, i), n = 0, s = i.length; n < s; n += 1)
    t.duplicates.push(r[i[n]]);
  t.usedDuplicates = new Array(s);
}
function gy(e, t, r) {
  var i, n, s;
  if (e !== null && typeof e == "object")
    if (n = t.indexOf(e), n !== -1)
      r.indexOf(n) === -1 && r.push(n);
    else if (t.push(e), Array.isArray(e))
      for (n = 0, s = e.length; n < s; n += 1)
        gy(e[n], t, r);
    else
      for (i = Object.keys(e), n = 0, s = i.length; n < s; n += 1)
        gy(e[i[n]], t, r);
}
function t6(e, t) {
  t = t || {};
  var r = new VL(t);
  r.noRefs || e6(e, r);
  var i = e;
  return r.replacer && (i = r.replacer.call({ "": i }, "", i)), Pi(r, 0, i, !0, !0) ? r.dump + `
` : "";
}
Bx.dump = t6;
var eO = bg, r6 = Bx;
function Og(e, t) {
  return function() {
    throw new Error("Function yaml." + e + " is removed in js-yaml 4. Use yaml." + t + " instead, which is now safe by default.");
  };
}
gr.Type = Nr;
gr.Schema = px;
gr.FAILSAFE_SCHEMA = gx;
gr.JSON_SCHEMA = Ex;
gr.CORE_SCHEMA = xx;
gr.DEFAULT_SCHEMA = wg;
gr.load = eO.load;
gr.loadAll = eO.loadAll;
gr.dump = r6.dump;
gr.YAMLException = Hu;
gr.types = {
  binary: Cx,
  float: $x,
  map: yx,
  null: vx,
  pairs: Tx,
  set: Ix,
  timestamp: Sx,
  bool: bx,
  int: _x,
  merge: Ax,
  omap: Rx,
  seq: mx,
  str: hx
};
gr.safeLoad = Og("safeLoad", "load");
gr.safeLoadAll = Og("safeLoadAll", "loadAll");
gr.safeDump = Og("safeDump", "dump");
const n6 = gr, { JSON_SCHEMA: i6 } = gr, { ParserError: s6 } = ir;
var a6 = {
  /**
   * The order that this parser will run, in relation to other parsers.
   *
   * @type {number}
   */
  order: 200,
  /**
   * Whether to allow "empty" files. This includes zero-byte files, as well as empty JSON objects.
   *
   * @type {boolean}
   */
  allowEmpty: !0,
  /**
   * Determines whether this parser can parse a given file reference.
   * Parsers that match will be tried, in order, until one successfully parses the file.
   * Parsers that don't match will be skipped, UNLESS none of the parsers match, in which case
   * every parser will be tried.
   *
   * @type {RegExp|string[]|function}
   */
  canParse: [".yaml", ".yml", ".json"],
  // JSON is valid YAML
  /**
   * Parses the given file as YAML
   *
   * @param {object} file           - An object containing information about the referenced file
   * @param {string} file.url       - The full URL of the referenced file
   * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
   * @returns {Promise}
   */
  // eslint-disable-next-line require-await
  async parse(e) {
    let t = e.data;
    if (qe.Buffer.isBuffer(t) && (t = t.toString()), typeof t == "string")
      try {
        return n6.load(t, { schema: i6 });
      } catch (r) {
        throw new s6(r.message, e.url);
      }
    return t;
  }
}, o6 = null;
const u6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: o6
}, Symbol.toStringTag, { value: "Module" })), tO = /* @__PURE__ */ xf(u6), c6 = tO, { ono: Mp } = In, { ResolverError: Np } = ir, L1 = pn;
var l6 = {
  /**
   * The order that this resolver will run, in relation to other resolvers.
   *
   * @type {number}
   */
  order: 100,
  /**
   * Determines whether this resolver can read a given file reference.
   * Resolvers that return true will be tried, in order, until one successfully resolves the file.
   * Resolvers that return false will not be given a chance to resolve the file.
   *
   * @param {object} file           - An object containing information about the referenced file
   * @param {string} file.url       - The full URL of the referenced file
   * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
   * @returns {boolean}
   */
  canRead(e) {
    return L1.isFileSystemPath(e.url);
  },
  /**
   * Reads the given file and returns its raw contents as a Buffer.
   *
   * @param {object} file           - An object containing information about the referenced file
   * @param {string} file.url       - The full URL of the referenced file
   * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
   * @returns {Promise<Buffer>}
   */
  read(e) {
    return new Promise((t, r) => {
      let i;
      try {
        i = L1.toFileSystemPath(e.url);
      } catch (n) {
        r(new Np(Mp.uri(n, `Malformed URI: ${e.url}`), e.url));
      }
      try {
        c6.readFile(i, (n, s) => {
          n ? r(new Np(Mp(n, `Error opening file "${i}"`), i)) : t(s);
        });
      } catch (n) {
        r(new Np(Mp(n, `Error opening file "${i}"`), i));
      }
    });
  }
}, Df = {}, rO = { exports: {} }, Pg = {};
(function(e) {
  e.fetch = n(tt.fetch) && n(tt.ReadableStream), e.writableStream = n(tt.WritableStream), e.abortController = n(tt.AbortController);
  var t;
  function r() {
    if (t !== void 0)
      return t;
    if (tt.XMLHttpRequest) {
      t = new tt.XMLHttpRequest();
      try {
        t.open("GET", tt.XDomainRequest ? "/" : "https://example.com");
      } catch {
        t = null;
      }
    } else
      t = null;
    return t;
  }
  function i(s) {
    var a = r();
    if (!a)
      return !1;
    try {
      return a.responseType = s, a.responseType === s;
    } catch {
    }
    return !1;
  }
  e.arraybuffer = e.fetch || i("arraybuffer"), e.msstream = !e.fetch && i("ms-stream"), e.mozchunkedarraybuffer = !e.fetch && i("moz-chunked-arraybuffer"), e.overrideMimeType = e.fetch || (r() ? n(r().overrideMimeType) : !1);
  function n(s) {
    return typeof s == "function";
  }
  t = null;
})(Pg);
var Lf = {}, vy = { exports: {} }, nO = lg.EventEmitter, Dp, q1;
function f6() {
  if (q1)
    return Dp;
  q1 = 1;
  function e(m, v) {
    var _ = Object.keys(m);
    if (Object.getOwnPropertySymbols) {
      var y = Object.getOwnPropertySymbols(m);
      v && (y = y.filter(function(w) {
        return Object.getOwnPropertyDescriptor(m, w).enumerable;
      })), _.push.apply(_, y);
    }
    return _;
  }
  function t(m) {
    for (var v = 1; v < arguments.length; v++) {
      var _ = arguments[v] != null ? arguments[v] : {};
      v % 2 ? e(Object(_), !0).forEach(function(y) {
        r(m, y, _[y]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(m, Object.getOwnPropertyDescriptors(_)) : e(Object(_)).forEach(function(y) {
        Object.defineProperty(m, y, Object.getOwnPropertyDescriptor(_, y));
      });
    }
    return m;
  }
  function r(m, v, _) {
    return v = a(v), v in m ? Object.defineProperty(m, v, { value: _, enumerable: !0, configurable: !0, writable: !0 }) : m[v] = _, m;
  }
  function i(m, v) {
    if (!(m instanceof v))
      throw new TypeError("Cannot call a class as a function");
  }
  function n(m, v) {
    for (var _ = 0; _ < v.length; _++) {
      var y = v[_];
      y.enumerable = y.enumerable || !1, y.configurable = !0, "value" in y && (y.writable = !0), Object.defineProperty(m, a(y.key), y);
    }
  }
  function s(m, v, _) {
    return v && n(m.prototype, v), _ && n(m, _), Object.defineProperty(m, "prototype", { writable: !1 }), m;
  }
  function a(m) {
    var v = o(m, "string");
    return typeof v == "symbol" ? v : String(v);
  }
  function o(m, v) {
    if (typeof m != "object" || m === null)
      return m;
    var _ = m[Symbol.toPrimitive];
    if (_ !== void 0) {
      var y = _.call(m, v || "default");
      if (typeof y != "object")
        return y;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (v === "string" ? String : Number)(m);
  }
  var c = ro, l = c.Buffer, d = no, p = d.inspect, h = p && p.custom || "inspect";
  function g(m, v, _) {
    l.prototype.copy.call(m, v, _);
  }
  return Dp = /* @__PURE__ */ function() {
    function m() {
      i(this, m), this.head = null, this.tail = null, this.length = 0;
    }
    return s(m, [{
      key: "push",
      value: function(_) {
        var y = {
          data: _,
          next: null
        };
        this.length > 0 ? this.tail.next = y : this.head = y, this.tail = y, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(_) {
        var y = {
          data: _,
          next: this.head
        };
        this.length === 0 && (this.tail = y), this.head = y, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var _ = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, _;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(_) {
        if (this.length === 0)
          return "";
        for (var y = this.head, w = "" + y.data; y = y.next; )
          w += _ + y.data;
        return w;
      }
    }, {
      key: "concat",
      value: function(_) {
        if (this.length === 0)
          return l.alloc(0);
        for (var y = l.allocUnsafe(_ >>> 0), w = this.head, $ = 0; w; )
          g(w.data, y, $), $ += w.data.length, w = w.next;
        return y;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(_, y) {
        var w;
        return _ < this.head.data.length ? (w = this.head.data.slice(0, _), this.head.data = this.head.data.slice(_)) : _ === this.head.data.length ? w = this.shift() : w = y ? this._getString(_) : this._getBuffer(_), w;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(_) {
        var y = this.head, w = 1, $ = y.data;
        for (_ -= $.length; y = y.next; ) {
          var E = y.data, S = _ > E.length ? E.length : _;
          if (S === E.length ? $ += E : $ += E.slice(0, _), _ -= S, _ === 0) {
            S === E.length ? (++w, y.next ? this.head = y.next : this.head = this.tail = null) : (this.head = y, y.data = E.slice(S));
            break;
          }
          ++w;
        }
        return this.length -= w, $;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(_) {
        var y = l.allocUnsafe(_), w = this.head, $ = 1;
        for (w.data.copy(y), _ -= w.data.length; w = w.next; ) {
          var E = w.data, S = _ > E.length ? E.length : _;
          if (E.copy(y, y.length - _, 0, S), _ -= S, _ === 0) {
            S === E.length ? (++$, w.next ? this.head = w.next : this.head = this.tail = null) : (this.head = w, w.data = E.slice(S));
            break;
          }
          ++$;
        }
        return this.length -= $, y;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: h,
      value: function(_, y) {
        return p(this, t(t({}, y), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), m;
  }(), Dp;
}
function d6(e, t) {
  var r = this, i = this._readableState && this._readableState.destroyed, n = this._writableState && this._writableState.destroyed;
  return i || n ? (t ? t(e) : e && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, qe.process.nextTick(by, this, e)) : qe.process.nextTick(by, this, e)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(e || null, function(s) {
    !t && s ? r._writableState ? r._writableState.errorEmitted ? qe.process.nextTick(xl, r) : (r._writableState.errorEmitted = !0, qe.process.nextTick(F1, r, s)) : qe.process.nextTick(F1, r, s) : t ? (qe.process.nextTick(xl, r), t(s)) : qe.process.nextTick(xl, r);
  }), this);
}
function F1(e, t) {
  by(e, t), xl(e);
}
function xl(e) {
  e._writableState && !e._writableState.emitClose || e._readableState && !e._readableState.emitClose || e.emit("close");
}
function p6() {
  this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
}
function by(e, t) {
  e.emit("error", t);
}
function h6(e, t) {
  var r = e._readableState, i = e._writableState;
  r && r.autoDestroy || i && i.autoDestroy ? e.destroy(t) : e.emit("error", t);
}
var iO = {
  destroy: d6,
  undestroy: p6,
  errorOrDestroy: h6
}, Ys = {};
function m6(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e.__proto__ = t;
}
var sO = {};
function hn(e, t, r) {
  r || (r = Error);
  function i(s, a, o) {
    return typeof t == "string" ? t : t(s, a, o);
  }
  var n = /* @__PURE__ */ function(s) {
    m6(a, s);
    function a(o, c, l) {
      return s.call(this, i(o, c, l)) || this;
    }
    return a;
  }(r);
  n.prototype.name = r.name, n.prototype.code = e, sO[e] = n;
}
function U1(e, t) {
  if (Array.isArray(e)) {
    var r = e.length;
    return e = e.map(function(i) {
      return String(i);
    }), r > 2 ? "one of ".concat(t, " ").concat(e.slice(0, r - 1).join(", "), ", or ") + e[r - 1] : r === 2 ? "one of ".concat(t, " ").concat(e[0], " or ").concat(e[1]) : "of ".concat(t, " ").concat(e[0]);
  } else
    return "of ".concat(t, " ").concat(String(e));
}
function y6(e, t, r) {
  return e.substr(!r || r < 0 ? 0 : +r, t.length) === t;
}
function g6(e, t, r) {
  return (r === void 0 || r > e.length) && (r = e.length), e.substring(r - t.length, r) === t;
}
function v6(e, t, r) {
  return typeof r != "number" && (r = 0), r + t.length > e.length ? !1 : e.indexOf(t, r) !== -1;
}
hn("ERR_INVALID_OPT_VALUE", function(e, t) {
  return 'The value "' + t + '" is invalid for option "' + e + '"';
}, TypeError);
hn("ERR_INVALID_ARG_TYPE", function(e, t, r) {
  var i;
  typeof t == "string" && y6(t, "not ") ? (i = "must not be", t = t.replace(/^not /, "")) : i = "must be";
  var n;
  if (g6(e, " argument"))
    n = "The ".concat(e, " ").concat(i, " ").concat(U1(t, "type"));
  else {
    var s = v6(e, ".") ? "property" : "argument";
    n = 'The "'.concat(e, '" ').concat(s, " ").concat(i, " ").concat(U1(t, "type"));
  }
  return n += ". Received type ".concat(typeof r), n;
}, TypeError);
hn("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
hn("ERR_METHOD_NOT_IMPLEMENTED", function(e) {
  return "The " + e + " method is not implemented";
});
hn("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
hn("ERR_STREAM_DESTROYED", function(e) {
  return "Cannot call " + e + " after a stream was destroyed";
});
hn("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
hn("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
hn("ERR_STREAM_WRITE_AFTER_END", "write after end");
hn("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
hn("ERR_UNKNOWN_ENCODING", function(e) {
  return "Unknown encoding: " + e;
}, TypeError);
hn("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
Ys.codes = sO;
var b6 = Ys.codes.ERR_INVALID_OPT_VALUE;
function _6(e, t, r) {
  return e.highWaterMark != null ? e.highWaterMark : t ? e[r] : null;
}
function w6(e, t, r, i) {
  var n = _6(t, i, r);
  if (n != null) {
    if (!(isFinite(n) && Math.floor(n) === n) || n < 0) {
      var s = i ? r : "highWaterMark";
      throw new b6(s, n);
    }
    return Math.floor(n);
  }
  return e.objectMode ? 16 : 16 * 1024;
}
var aO = {
  getHighWaterMark: w6
}, $6 = E6;
function E6(e, t) {
  if (Lp("noDeprecation"))
    return e;
  var r = !1;
  function i() {
    if (!r) {
      if (Lp("throwDeprecation"))
        throw new Error(t);
      Lp("traceDeprecation") ? console.trace(t) : console.warn(t), r = !0;
    }
    return e.apply(this, arguments);
  }
  return i;
}
function Lp(e) {
  try {
    if (!tt.localStorage)
      return !1;
  } catch {
    return !1;
  }
  var t = tt.localStorage[e];
  return t == null ? !1 : String(t).toLowerCase() === "true";
}
var qp, B1;
function oO() {
  if (B1)
    return qp;
  B1 = 1, qp = L;
  function e(D) {
    var U = this;
    this.next = null, this.entry = null, this.finish = function() {
      F(U, D);
    };
  }
  var t;
  L.WritableState = R;
  var r = {
    deprecate: $6
  }, i = nO, n = ro.Buffer, s = (typeof tt < "u" ? tt : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function a(D) {
    return n.from(D);
  }
  function o(D) {
    return n.isBuffer(D) || D instanceof s;
  }
  var c = iO, l = aO, d = l.getHighWaterMark, p = Ys.codes, h = p.ERR_INVALID_ARG_TYPE, g = p.ERR_METHOD_NOT_IMPLEMENTED, m = p.ERR_MULTIPLE_CALLBACK, v = p.ERR_STREAM_CANNOT_PIPE, _ = p.ERR_STREAM_DESTROYED, y = p.ERR_STREAM_NULL_VALUES, w = p.ERR_STREAM_WRITE_AFTER_END, $ = p.ERR_UNKNOWN_ENCODING, E = c.errorOrDestroy;
  ls(L, i);
  function S() {
  }
  function R(D, U, k) {
    t = t || Qa(), D = D || {}, typeof k != "boolean" && (k = U instanceof t), this.objectMode = !!D.objectMode, k && (this.objectMode = this.objectMode || !!D.writableObjectMode), this.highWaterMark = d(this, D, "writableHighWaterMark", k), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var Z = D.decodeStrings === !1;
    this.decodeStrings = !Z, this.defaultEncoding = D.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(J) {
      de(U, J);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = D.emitClose !== !1, this.autoDestroy = !!D.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new e(this);
  }
  R.prototype.getBuffer = function() {
    for (var U = this.bufferedRequest, k = []; U; )
      k.push(U), U = U.next;
    return k;
  }, function() {
    try {
      Object.defineProperty(R.prototype, "buffer", {
        get: r.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var j;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (j = Function.prototype[Symbol.hasInstance], Object.defineProperty(L, Symbol.hasInstance, {
    value: function(U) {
      return j.call(this, U) ? !0 : this !== L ? !1 : U && U._writableState instanceof R;
    }
  })) : j = function(U) {
    return U instanceof this;
  };
  function L(D) {
    t = t || Qa();
    var U = this instanceof t;
    if (!U && !j.call(L, this))
      return new L(D);
    this._writableState = new R(D, this, U), this.writable = !0, D && (typeof D.write == "function" && (this._write = D.write), typeof D.writev == "function" && (this._writev = D.writev), typeof D.destroy == "function" && (this._destroy = D.destroy), typeof D.final == "function" && (this._final = D.final)), i.call(this);
  }
  L.prototype.pipe = function() {
    E(this, new v());
  };
  function K(D, U) {
    var k = new w();
    E(D, k), qe.process.nextTick(U, k);
  }
  function ae(D, U, k, Z) {
    var J;
    return k === null ? J = new y() : typeof k != "string" && !U.objectMode && (J = new h("chunk", ["string", "Buffer"], k)), J ? (E(D, J), qe.process.nextTick(Z, J), !1) : !0;
  }
  L.prototype.write = function(D, U, k) {
    var Z = this._writableState, J = !1, A = !Z.objectMode && o(D);
    return A && !n.isBuffer(D) && (D = a(D)), typeof U == "function" && (k = U, U = null), A ? U = "buffer" : U || (U = Z.defaultEncoding), typeof k != "function" && (k = S), Z.ending ? K(this, k) : (A || ae(this, Z, D, k)) && (Z.pendingcb++, J = xe(this, Z, A, D, U, k)), J;
  }, L.prototype.cork = function() {
    this._writableState.corked++;
  }, L.prototype.uncork = function() {
    var D = this._writableState;
    D.corked && (D.corked--, !D.writing && !D.corked && !D.bufferProcessing && D.bufferedRequest && _e(this, D));
  }, L.prototype.setDefaultEncoding = function(U) {
    if (typeof U == "string" && (U = U.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((U + "").toLowerCase()) > -1))
      throw new $(U);
    return this._writableState.defaultEncoding = U, this;
  }, Object.defineProperty(L.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function ye(D, U, k) {
    return !D.objectMode && D.decodeStrings !== !1 && typeof U == "string" && (U = n.from(U, k)), U;
  }
  Object.defineProperty(L.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function xe(D, U, k, Z, J, A) {
    if (!k) {
      var I = ye(U, Z, J);
      Z !== I && (k = !0, J = "buffer", Z = I);
    }
    var X = U.objectMode ? 1 : Z.length;
    U.length += X;
    var oe = U.length < U.highWaterMark;
    if (oe || (U.needDrain = !0), U.writing || U.corked) {
      var Ae = U.lastBufferedRequest;
      U.lastBufferedRequest = {
        chunk: Z,
        encoding: J,
        isBuf: k,
        callback: A,
        next: null
      }, Ae ? Ae.next = U.lastBufferedRequest : U.bufferedRequest = U.lastBufferedRequest, U.bufferedRequestCount += 1;
    } else
      Pe(D, U, !1, X, Z, J, A);
    return oe;
  }
  function Pe(D, U, k, Z, J, A, I) {
    U.writelen = Z, U.writecb = I, U.writing = !0, U.sync = !0, U.destroyed ? U.onwrite(new _("write")) : k ? D._writev(J, U.onwrite) : D._write(J, A, U.onwrite), U.sync = !1;
  }
  function te(D, U, k, Z, J) {
    --U.pendingcb, k ? (qe.process.nextTick(J, Z), qe.process.nextTick(z, D, U), D._writableState.errorEmitted = !0, E(D, Z)) : (J(Z), D._writableState.errorEmitted = !0, E(D, Z), z(D, U));
  }
  function pe(D) {
    D.writing = !1, D.writecb = null, D.length -= D.writelen, D.writelen = 0;
  }
  function de(D, U) {
    var k = D._writableState, Z = k.sync, J = k.writecb;
    if (typeof J != "function")
      throw new m();
    if (pe(k), U)
      te(D, k, Z, U, J);
    else {
      var A = ie(k) || D.destroyed;
      !A && !k.corked && !k.bufferProcessing && k.bufferedRequest && _e(D, k), Z ? qe.process.nextTick(Ee, D, k, A, J) : Ee(D, k, A, J);
    }
  }
  function Ee(D, U, k, Z) {
    k || Re(D, U), U.pendingcb--, Z(), z(D, U);
  }
  function Re(D, U) {
    U.length === 0 && U.needDrain && (U.needDrain = !1, D.emit("drain"));
  }
  function _e(D, U) {
    U.bufferProcessing = !0;
    var k = U.bufferedRequest;
    if (D._writev && k && k.next) {
      var Z = U.bufferedRequestCount, J = new Array(Z), A = U.corkedRequestsFree;
      A.entry = k;
      for (var I = 0, X = !0; k; )
        J[I] = k, k.isBuf || (X = !1), k = k.next, I += 1;
      J.allBuffers = X, Pe(D, U, !0, U.length, J, "", A.finish), U.pendingcb++, U.lastBufferedRequest = null, A.next ? (U.corkedRequestsFree = A.next, A.next = null) : U.corkedRequestsFree = new e(U), U.bufferedRequestCount = 0;
    } else {
      for (; k; ) {
        var oe = k.chunk, Ae = k.encoding, je = k.callback, Be = U.objectMode ? 1 : oe.length;
        if (Pe(D, U, !1, Be, oe, Ae, je), k = k.next, U.bufferedRequestCount--, U.writing)
          break;
      }
      k === null && (U.lastBufferedRequest = null);
    }
    U.bufferedRequest = k, U.bufferProcessing = !1;
  }
  L.prototype._write = function(D, U, k) {
    k(new g("_write()"));
  }, L.prototype._writev = null, L.prototype.end = function(D, U, k) {
    var Z = this._writableState;
    return typeof D == "function" ? (k = D, D = null, U = null) : typeof U == "function" && (k = U, U = null), D != null && this.write(D, U), Z.corked && (Z.corked = 1, this.uncork()), Z.ending || T(this, Z, k), this;
  }, Object.defineProperty(L.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function ie(D) {
    return D.ending && D.length === 0 && D.bufferedRequest === null && !D.finished && !D.writing;
  }
  function Y(D, U) {
    D._final(function(k) {
      U.pendingcb--, k && E(D, k), U.prefinished = !0, D.emit("prefinish"), z(D, U);
    });
  }
  function V(D, U) {
    !U.prefinished && !U.finalCalled && (typeof D._final == "function" && !U.destroyed ? (U.pendingcb++, U.finalCalled = !0, qe.process.nextTick(Y, D, U)) : (U.prefinished = !0, D.emit("prefinish")));
  }
  function z(D, U) {
    var k = ie(U);
    if (k && (V(D, U), U.pendingcb === 0 && (U.finished = !0, D.emit("finish"), U.autoDestroy))) {
      var Z = D._readableState;
      (!Z || Z.autoDestroy && Z.endEmitted) && D.destroy();
    }
    return k;
  }
  function T(D, U, k) {
    U.ending = !0, z(D, U), k && (U.finished ? qe.process.nextTick(k) : D.once("finish", k)), U.ended = !0, D.writable = !1;
  }
  function F(D, U, k) {
    var Z = D.entry;
    for (D.entry = null; Z; ) {
      var J = Z.callback;
      U.pendingcb--, J(k), Z = Z.next;
    }
    U.corkedRequestsFree.next = D;
  }
  return Object.defineProperty(L.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(U) {
      this._writableState && (this._writableState.destroyed = U);
    }
  }), L.prototype.destroy = c.destroy, L.prototype._undestroy = c.undestroy, L.prototype._destroy = function(D, U) {
    U(D);
  }, qp;
}
var Fp, V1;
function Qa() {
  if (V1)
    return Fp;
  V1 = 1;
  var e = Object.keys || function(l) {
    var d = [];
    for (var p in l)
      d.push(p);
    return d;
  };
  Fp = a;
  var t = cO(), r = oO();
  ls(a, t);
  for (var i = e(r.prototype), n = 0; n < i.length; n++) {
    var s = i[n];
    a.prototype[s] || (a.prototype[s] = r.prototype[s]);
  }
  function a(l) {
    if (!(this instanceof a))
      return new a(l);
    t.call(this, l), r.call(this, l), this.allowHalfOpen = !0, l && (l.readable === !1 && (this.readable = !1), l.writable === !1 && (this.writable = !1), l.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", o)));
  }
  Object.defineProperty(a.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(a.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(a.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function o() {
    this._writableState.ended || qe.process.nextTick(c, this);
  }
  function c(l) {
    l.end();
  }
  return Object.defineProperty(a.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(d) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = d, this._writableState.destroyed = d);
    }
  }), Fp;
}
var Up = {}, zc = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var Z1;
function x6() {
  return Z1 || (Z1 = 1, function(e, t) {
    var r = ro, i = r.Buffer;
    function n(a, o) {
      for (var c in a)
        o[c] = a[c];
    }
    i.from && i.alloc && i.allocUnsafe && i.allocUnsafeSlow ? e.exports = r : (n(r, t), t.Buffer = s);
    function s(a, o, c) {
      return i(a, o, c);
    }
    s.prototype = Object.create(i.prototype), n(i, s), s.from = function(a, o, c) {
      if (typeof a == "number")
        throw new TypeError("Argument must not be a number");
      return i(a, o, c);
    }, s.alloc = function(a, o, c) {
      if (typeof a != "number")
        throw new TypeError("Argument must be a number");
      var l = i(a);
      return o !== void 0 ? typeof c == "string" ? l.fill(o, c) : l.fill(o) : l.fill(0), l;
    }, s.allocUnsafe = function(a) {
      if (typeof a != "number")
        throw new TypeError("Argument must be a number");
      return i(a);
    }, s.allocUnsafeSlow = function(a) {
      if (typeof a != "number")
        throw new TypeError("Argument must be a number");
      return r.SlowBuffer(a);
    };
  }(zc, zc.exports)), zc.exports;
}
var z1;
function W1() {
  if (z1)
    return Up;
  z1 = 1;
  var e = x6().Buffer, t = e.isEncoding || function(y) {
    switch (y = "" + y, y && y.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return !0;
      default:
        return !1;
    }
  };
  function r(y) {
    if (!y)
      return "utf8";
    for (var w; ; )
      switch (y) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return y;
        default:
          if (w)
            return;
          y = ("" + y).toLowerCase(), w = !0;
      }
  }
  function i(y) {
    var w = r(y);
    if (typeof w != "string" && (e.isEncoding === t || !t(y)))
      throw new Error("Unknown encoding: " + y);
    return w || y;
  }
  Up.StringDecoder = n;
  function n(y) {
    this.encoding = i(y);
    var w;
    switch (this.encoding) {
      case "utf16le":
        this.text = p, this.end = h, w = 4;
        break;
      case "utf8":
        this.fillLast = c, w = 4;
        break;
      case "base64":
        this.text = g, this.end = m, w = 3;
        break;
      default:
        this.write = v, this.end = _;
        return;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = e.allocUnsafe(w);
  }
  n.prototype.write = function(y) {
    if (y.length === 0)
      return "";
    var w, $;
    if (this.lastNeed) {
      if (w = this.fillLast(y), w === void 0)
        return "";
      $ = this.lastNeed, this.lastNeed = 0;
    } else
      $ = 0;
    return $ < y.length ? w ? w + this.text(y, $) : this.text(y, $) : w || "";
  }, n.prototype.end = d, n.prototype.text = l, n.prototype.fillLast = function(y) {
    if (this.lastNeed <= y.length)
      return y.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    y.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, y.length), this.lastNeed -= y.length;
  };
  function s(y) {
    return y <= 127 ? 0 : y >> 5 === 6 ? 2 : y >> 4 === 14 ? 3 : y >> 3 === 30 ? 4 : y >> 6 === 2 ? -1 : -2;
  }
  function a(y, w, $) {
    var E = w.length - 1;
    if (E < $)
      return 0;
    var S = s(w[E]);
    return S >= 0 ? (S > 0 && (y.lastNeed = S - 1), S) : --E < $ || S === -2 ? 0 : (S = s(w[E]), S >= 0 ? (S > 0 && (y.lastNeed = S - 2), S) : --E < $ || S === -2 ? 0 : (S = s(w[E]), S >= 0 ? (S > 0 && (S === 2 ? S = 0 : y.lastNeed = S - 3), S) : 0));
  }
  function o(y, w, $) {
    if ((w[0] & 192) !== 128)
      return y.lastNeed = 0, "";
    if (y.lastNeed > 1 && w.length > 1) {
      if ((w[1] & 192) !== 128)
        return y.lastNeed = 1, "";
      if (y.lastNeed > 2 && w.length > 2 && (w[2] & 192) !== 128)
        return y.lastNeed = 2, "";
    }
  }
  function c(y) {
    var w = this.lastTotal - this.lastNeed, $ = o(this, y);
    if ($ !== void 0)
      return $;
    if (this.lastNeed <= y.length)
      return y.copy(this.lastChar, w, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    y.copy(this.lastChar, w, 0, y.length), this.lastNeed -= y.length;
  }
  function l(y, w) {
    var $ = a(this, y, w);
    if (!this.lastNeed)
      return y.toString("utf8", w);
    this.lastTotal = $;
    var E = y.length - ($ - this.lastNeed);
    return y.copy(this.lastChar, 0, E), y.toString("utf8", w, E);
  }
  function d(y) {
    var w = y && y.length ? this.write(y) : "";
    return this.lastNeed ? w + "" : w;
  }
  function p(y, w) {
    if ((y.length - w) % 2 === 0) {
      var $ = y.toString("utf16le", w);
      if ($) {
        var E = $.charCodeAt($.length - 1);
        if (E >= 55296 && E <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = y[y.length - 2], this.lastChar[1] = y[y.length - 1], $.slice(0, -1);
      }
      return $;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = y[y.length - 1], y.toString("utf16le", w, y.length - 1);
  }
  function h(y) {
    var w = y && y.length ? this.write(y) : "";
    if (this.lastNeed) {
      var $ = this.lastTotal - this.lastNeed;
      return w + this.lastChar.toString("utf16le", 0, $);
    }
    return w;
  }
  function g(y, w) {
    var $ = (y.length - w) % 3;
    return $ === 0 ? y.toString("base64", w) : (this.lastNeed = 3 - $, this.lastTotal = 3, $ === 1 ? this.lastChar[0] = y[y.length - 1] : (this.lastChar[0] = y[y.length - 2], this.lastChar[1] = y[y.length - 1]), y.toString("base64", w, y.length - $));
  }
  function m(y) {
    var w = y && y.length ? this.write(y) : "";
    return this.lastNeed ? w + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : w;
  }
  function v(y) {
    return y.toString(this.encoding);
  }
  function _(y) {
    return y && y.length ? this.write(y) : "";
  }
  return Up;
}
var H1 = Ys.codes.ERR_STREAM_PREMATURE_CLOSE;
function O6(e) {
  var t = !1;
  return function() {
    if (!t) {
      t = !0;
      for (var r = arguments.length, i = new Array(r), n = 0; n < r; n++)
        i[n] = arguments[n];
      e.apply(this, i);
    }
  };
}
function P6() {
}
function S6(e) {
  return e.setHeader && typeof e.abort == "function";
}
function uO(e, t, r) {
  if (typeof t == "function")
    return uO(e, null, t);
  t || (t = {}), r = O6(r || P6);
  var i = t.readable || t.readable !== !1 && e.readable, n = t.writable || t.writable !== !1 && e.writable, s = function() {
    e.writable || o();
  }, a = e._writableState && e._writableState.finished, o = function() {
    n = !1, a = !0, i || r.call(e);
  }, c = e._readableState && e._readableState.endEmitted, l = function() {
    i = !1, c = !0, n || r.call(e);
  }, d = function(m) {
    r.call(e, m);
  }, p = function() {
    var m;
    if (i && !c)
      return (!e._readableState || !e._readableState.ended) && (m = new H1()), r.call(e, m);
    if (n && !a)
      return (!e._writableState || !e._writableState.ended) && (m = new H1()), r.call(e, m);
  }, h = function() {
    e.req.on("finish", o);
  };
  return S6(e) ? (e.on("complete", o), e.on("abort", p), e.req ? h() : e.on("request", h)) : n && !e._writableState && (e.on("end", s), e.on("close", s)), e.on("end", l), e.on("finish", o), t.error !== !1 && e.on("error", d), e.on("close", p), function() {
    e.removeListener("complete", o), e.removeListener("abort", p), e.removeListener("request", h), e.req && e.req.removeListener("finish", o), e.removeListener("end", s), e.removeListener("close", s), e.removeListener("finish", o), e.removeListener("end", l), e.removeListener("error", d), e.removeListener("close", p);
  };
}
var Sg = uO, Bp, G1;
function A6() {
  if (G1)
    return Bp;
  G1 = 1;
  var e;
  function t($, E, S) {
    return E = r(E), E in $ ? Object.defineProperty($, E, { value: S, enumerable: !0, configurable: !0, writable: !0 }) : $[E] = S, $;
  }
  function r($) {
    var E = i($, "string");
    return typeof E == "symbol" ? E : String(E);
  }
  function i($, E) {
    if (typeof $ != "object" || $ === null)
      return $;
    var S = $[Symbol.toPrimitive];
    if (S !== void 0) {
      var R = S.call($, E || "default");
      if (typeof R != "object")
        return R;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (E === "string" ? String : Number)($);
  }
  var n = Sg, s = Symbol("lastResolve"), a = Symbol("lastReject"), o = Symbol("error"), c = Symbol("ended"), l = Symbol("lastPromise"), d = Symbol("handlePromise"), p = Symbol("stream");
  function h($, E) {
    return {
      value: $,
      done: E
    };
  }
  function g($) {
    var E = $[s];
    if (E !== null) {
      var S = $[p].read();
      S !== null && ($[l] = null, $[s] = null, $[a] = null, E(h(S, !1)));
    }
  }
  function m($) {
    qe.process.nextTick(g, $);
  }
  function v($, E) {
    return function(S, R) {
      $.then(function() {
        if (E[c]) {
          S(h(void 0, !0));
          return;
        }
        E[d](S, R);
      }, R);
    };
  }
  var _ = Object.getPrototypeOf(function() {
  }), y = Object.setPrototypeOf((e = {
    get stream() {
      return this[p];
    },
    next: function() {
      var E = this, S = this[o];
      if (S !== null)
        return Promise.reject(S);
      if (this[c])
        return Promise.resolve(h(void 0, !0));
      if (this[p].destroyed)
        return new Promise(function(K, ae) {
          qe.process.nextTick(function() {
            E[o] ? ae(E[o]) : K(h(void 0, !0));
          });
        });
      var R = this[l], j;
      if (R)
        j = new Promise(v(R, this));
      else {
        var L = this[p].read();
        if (L !== null)
          return Promise.resolve(h(L, !1));
        j = new Promise(this[d]);
      }
      return this[l] = j, j;
    }
  }, t(e, Symbol.asyncIterator, function() {
    return this;
  }), t(e, "return", function() {
    var E = this;
    return new Promise(function(S, R) {
      E[p].destroy(null, function(j) {
        if (j) {
          R(j);
          return;
        }
        S(h(void 0, !0));
      });
    });
  }), e), _), w = function(E) {
    var S, R = Object.create(y, (S = {}, t(S, p, {
      value: E,
      writable: !0
    }), t(S, s, {
      value: null,
      writable: !0
    }), t(S, a, {
      value: null,
      writable: !0
    }), t(S, o, {
      value: null,
      writable: !0
    }), t(S, c, {
      value: E._readableState.endEmitted,
      writable: !0
    }), t(S, d, {
      value: function(L, K) {
        var ae = R[p].read();
        ae ? (R[l] = null, R[s] = null, R[a] = null, L(h(ae, !1))) : (R[s] = L, R[a] = K);
      },
      writable: !0
    }), S));
    return R[l] = null, n(E, function(j) {
      if (j && j.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var L = R[a];
        L !== null && (R[l] = null, R[s] = null, R[a] = null, L(j)), R[o] = j;
        return;
      }
      var K = R[s];
      K !== null && (R[l] = null, R[s] = null, R[a] = null, K(h(void 0, !0))), R[c] = !0;
    }), E.on("readable", m.bind(null, R)), R;
  };
  return Bp = w, Bp;
}
var Vp, K1;
function C6() {
  return K1 || (K1 = 1, Vp = function() {
    throw new Error("Readable.from is not available in the browser");
  }), Vp;
}
var Zp, Y1;
function cO() {
  if (Y1)
    return Zp;
  Y1 = 1, Zp = K;
  var e;
  K.ReadableState = L, lg.EventEmitter;
  var t = function(I, X) {
    return I.listeners(X).length;
  }, r = nO, i = ro.Buffer, n = (typeof tt < "u" ? tt : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function s(A) {
    return i.from(A);
  }
  function a(A) {
    return i.isBuffer(A) || A instanceof n;
  }
  var o = no, c;
  o && o.debuglog ? c = o.debuglog("stream") : c = function() {
  };
  var l = f6(), d = iO, p = aO, h = p.getHighWaterMark, g = Ys.codes, m = g.ERR_INVALID_ARG_TYPE, v = g.ERR_STREAM_PUSH_AFTER_EOF, _ = g.ERR_METHOD_NOT_IMPLEMENTED, y = g.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, w, $, E;
  ls(K, r);
  var S = d.errorOrDestroy, R = ["error", "close", "destroy", "pause", "resume"];
  function j(A, I, X) {
    if (typeof A.prependListener == "function")
      return A.prependListener(I, X);
    !A._events || !A._events[I] ? A.on(I, X) : Array.isArray(A._events[I]) ? A._events[I].unshift(X) : A._events[I] = [X, A._events[I]];
  }
  function L(A, I, X) {
    e = e || Qa(), A = A || {}, typeof X != "boolean" && (X = I instanceof e), this.objectMode = !!A.objectMode, X && (this.objectMode = this.objectMode || !!A.readableObjectMode), this.highWaterMark = h(this, A, "readableHighWaterMark", X), this.buffer = new l(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = A.emitClose !== !1, this.autoDestroy = !!A.autoDestroy, this.destroyed = !1, this.defaultEncoding = A.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, A.encoding && (w || (w = W1().StringDecoder), this.decoder = new w(A.encoding), this.encoding = A.encoding);
  }
  function K(A) {
    if (e = e || Qa(), !(this instanceof K))
      return new K(A);
    var I = this instanceof e;
    this._readableState = new L(A, this, I), this.readable = !0, A && (typeof A.read == "function" && (this._read = A.read), typeof A.destroy == "function" && (this._destroy = A.destroy)), r.call(this);
  }
  Object.defineProperty(K.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(I) {
      this._readableState && (this._readableState.destroyed = I);
    }
  }), K.prototype.destroy = d.destroy, K.prototype._undestroy = d.undestroy, K.prototype._destroy = function(A, I) {
    I(A);
  }, K.prototype.push = function(A, I) {
    var X = this._readableState, oe;
    return X.objectMode ? oe = !0 : typeof A == "string" && (I = I || X.defaultEncoding, I !== X.encoding && (A = i.from(A, I), I = ""), oe = !0), ae(this, A, I, !1, oe);
  }, K.prototype.unshift = function(A) {
    return ae(this, A, null, !0, !1);
  };
  function ae(A, I, X, oe, Ae) {
    c("readableAddChunk", I);
    var je = A._readableState;
    if (I === null)
      je.reading = !1, de(A, je);
    else {
      var Be;
      if (Ae || (Be = xe(je, I)), Be)
        S(A, Be);
      else if (je.objectMode || I && I.length > 0)
        if (typeof I != "string" && !je.objectMode && Object.getPrototypeOf(I) !== i.prototype && (I = s(I)), oe)
          je.endEmitted ? S(A, new y()) : ye(A, je, I, !0);
        else if (je.ended)
          S(A, new v());
        else {
          if (je.destroyed)
            return !1;
          je.reading = !1, je.decoder && !X ? (I = je.decoder.write(I), je.objectMode || I.length !== 0 ? ye(A, je, I, !1) : _e(A, je)) : ye(A, je, I, !1);
        }
      else
        oe || (je.reading = !1, _e(A, je));
    }
    return !je.ended && (je.length < je.highWaterMark || je.length === 0);
  }
  function ye(A, I, X, oe) {
    I.flowing && I.length === 0 && !I.sync ? (I.awaitDrain = 0, A.emit("data", X)) : (I.length += I.objectMode ? 1 : X.length, oe ? I.buffer.unshift(X) : I.buffer.push(X), I.needReadable && Ee(A)), _e(A, I);
  }
  function xe(A, I) {
    var X;
    return !a(I) && typeof I != "string" && I !== void 0 && !A.objectMode && (X = new m("chunk", ["string", "Buffer", "Uint8Array"], I)), X;
  }
  K.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, K.prototype.setEncoding = function(A) {
    w || (w = W1().StringDecoder);
    var I = new w(A);
    this._readableState.decoder = I, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var X = this._readableState.buffer.head, oe = ""; X !== null; )
      oe += I.write(X.data), X = X.next;
    return this._readableState.buffer.clear(), oe !== "" && this._readableState.buffer.push(oe), this._readableState.length = oe.length, this;
  };
  var Pe = 1073741824;
  function te(A) {
    return A >= Pe ? A = Pe : (A--, A |= A >>> 1, A |= A >>> 2, A |= A >>> 4, A |= A >>> 8, A |= A >>> 16, A++), A;
  }
  function pe(A, I) {
    return A <= 0 || I.length === 0 && I.ended ? 0 : I.objectMode ? 1 : A !== A ? I.flowing && I.length ? I.buffer.head.data.length : I.length : (A > I.highWaterMark && (I.highWaterMark = te(A)), A <= I.length ? A : I.ended ? I.length : (I.needReadable = !0, 0));
  }
  K.prototype.read = function(A) {
    c("read", A), A = parseInt(A, 10);
    var I = this._readableState, X = A;
    if (A !== 0 && (I.emittedReadable = !1), A === 0 && I.needReadable && ((I.highWaterMark !== 0 ? I.length >= I.highWaterMark : I.length > 0) || I.ended))
      return c("read: emitReadable", I.length, I.ended), I.length === 0 && I.ended ? k(this) : Ee(this), null;
    if (A = pe(A, I), A === 0 && I.ended)
      return I.length === 0 && k(this), null;
    var oe = I.needReadable;
    c("need readable", oe), (I.length === 0 || I.length - A < I.highWaterMark) && (oe = !0, c("length less than watermark", oe)), I.ended || I.reading ? (oe = !1, c("reading or ended", oe)) : oe && (c("do read"), I.reading = !0, I.sync = !0, I.length === 0 && (I.needReadable = !0), this._read(I.highWaterMark), I.sync = !1, I.reading || (A = pe(X, I)));
    var Ae;
    return A > 0 ? Ae = U(A, I) : Ae = null, Ae === null ? (I.needReadable = I.length <= I.highWaterMark, A = 0) : (I.length -= A, I.awaitDrain = 0), I.length === 0 && (I.ended || (I.needReadable = !0), X !== A && I.ended && k(this)), Ae !== null && this.emit("data", Ae), Ae;
  };
  function de(A, I) {
    if (c("onEofChunk"), !I.ended) {
      if (I.decoder) {
        var X = I.decoder.end();
        X && X.length && (I.buffer.push(X), I.length += I.objectMode ? 1 : X.length);
      }
      I.ended = !0, I.sync ? Ee(A) : (I.needReadable = !1, I.emittedReadable || (I.emittedReadable = !0, Re(A)));
    }
  }
  function Ee(A) {
    var I = A._readableState;
    c("emitReadable", I.needReadable, I.emittedReadable), I.needReadable = !1, I.emittedReadable || (c("emitReadable", I.flowing), I.emittedReadable = !0, qe.process.nextTick(Re, A));
  }
  function Re(A) {
    var I = A._readableState;
    c("emitReadable_", I.destroyed, I.length, I.ended), !I.destroyed && (I.length || I.ended) && (A.emit("readable"), I.emittedReadable = !1), I.needReadable = !I.flowing && !I.ended && I.length <= I.highWaterMark, D(A);
  }
  function _e(A, I) {
    I.readingMore || (I.readingMore = !0, qe.process.nextTick(ie, A, I));
  }
  function ie(A, I) {
    for (; !I.reading && !I.ended && (I.length < I.highWaterMark || I.flowing && I.length === 0); ) {
      var X = I.length;
      if (c("maybeReadMore read 0"), A.read(0), X === I.length)
        break;
    }
    I.readingMore = !1;
  }
  K.prototype._read = function(A) {
    S(this, new _("_read()"));
  }, K.prototype.pipe = function(A, I) {
    var X = this, oe = this._readableState;
    switch (oe.pipesCount) {
      case 0:
        oe.pipes = A;
        break;
      case 1:
        oe.pipes = [oe.pipes, A];
        break;
      default:
        oe.pipes.push(A);
        break;
    }
    oe.pipesCount += 1, c("pipe count=%d opts=%j", oe.pipesCount, I);
    var Ae = (!I || I.end !== !1) && A !== qe.process.stdout && A !== qe.process.stderr, je = Ae ? vt : Ue;
    oe.endEmitted ? qe.process.nextTick(je) : X.once("end", je), A.on("unpipe", Be);
    function Be(q, x) {
      c("onunpipe"), q === X && x && x.hasUnpiped === !1 && (x.hasUnpiped = !0, nt());
    }
    function vt() {
      c("onend"), A.end();
    }
    var $e = Y(X);
    A.on("drain", $e);
    var ht = !1;
    function nt() {
      c("cleanup"), A.removeListener("close", at), A.removeListener("finish", mt), A.removeListener("drain", $e), A.removeListener("error", Le), A.removeListener("unpipe", Be), X.removeListener("end", vt), X.removeListener("end", Ue), X.removeListener("data", De), ht = !0, oe.awaitDrain && (!A._writableState || A._writableState.needDrain) && $e();
    }
    X.on("data", De);
    function De(q) {
      c("ondata");
      var x = A.write(q);
      c("dest.write", x), x === !1 && ((oe.pipesCount === 1 && oe.pipes === A || oe.pipesCount > 1 && J(oe.pipes, A) !== -1) && !ht && (c("false write response, pause", oe.awaitDrain), oe.awaitDrain++), X.pause());
    }
    function Le(q) {
      c("onerror", q), Ue(), A.removeListener("error", Le), t(A, "error") === 0 && S(A, q);
    }
    j(A, "error", Le);
    function at() {
      A.removeListener("finish", mt), Ue();
    }
    A.once("close", at);
    function mt() {
      c("onfinish"), A.removeListener("close", at), Ue();
    }
    A.once("finish", mt);
    function Ue() {
      c("unpipe"), X.unpipe(A);
    }
    return A.emit("pipe", X), oe.flowing || (c("pipe resume"), X.resume()), A;
  };
  function Y(A) {
    return function() {
      var X = A._readableState;
      c("pipeOnDrain", X.awaitDrain), X.awaitDrain && X.awaitDrain--, X.awaitDrain === 0 && t(A, "data") && (X.flowing = !0, D(A));
    };
  }
  K.prototype.unpipe = function(A) {
    var I = this._readableState, X = {
      hasUnpiped: !1
    };
    if (I.pipesCount === 0)
      return this;
    if (I.pipesCount === 1)
      return A && A !== I.pipes ? this : (A || (A = I.pipes), I.pipes = null, I.pipesCount = 0, I.flowing = !1, A && A.emit("unpipe", this, X), this);
    if (!A) {
      var oe = I.pipes, Ae = I.pipesCount;
      I.pipes = null, I.pipesCount = 0, I.flowing = !1;
      for (var je = 0; je < Ae; je++)
        oe[je].emit("unpipe", this, {
          hasUnpiped: !1
        });
      return this;
    }
    var Be = J(I.pipes, A);
    return Be === -1 ? this : (I.pipes.splice(Be, 1), I.pipesCount -= 1, I.pipesCount === 1 && (I.pipes = I.pipes[0]), A.emit("unpipe", this, X), this);
  }, K.prototype.on = function(A, I) {
    var X = r.prototype.on.call(this, A, I), oe = this._readableState;
    return A === "data" ? (oe.readableListening = this.listenerCount("readable") > 0, oe.flowing !== !1 && this.resume()) : A === "readable" && !oe.endEmitted && !oe.readableListening && (oe.readableListening = oe.needReadable = !0, oe.flowing = !1, oe.emittedReadable = !1, c("on readable", oe.length, oe.reading), oe.length ? Ee(this) : oe.reading || qe.process.nextTick(z, this)), X;
  }, K.prototype.addListener = K.prototype.on, K.prototype.removeListener = function(A, I) {
    var X = r.prototype.removeListener.call(this, A, I);
    return A === "readable" && qe.process.nextTick(V, this), X;
  }, K.prototype.removeAllListeners = function(A) {
    var I = r.prototype.removeAllListeners.apply(this, arguments);
    return (A === "readable" || A === void 0) && qe.process.nextTick(V, this), I;
  };
  function V(A) {
    var I = A._readableState;
    I.readableListening = A.listenerCount("readable") > 0, I.resumeScheduled && !I.paused ? I.flowing = !0 : A.listenerCount("data") > 0 && A.resume();
  }
  function z(A) {
    c("readable nexttick read 0"), A.read(0);
  }
  K.prototype.resume = function() {
    var A = this._readableState;
    return A.flowing || (c("resume"), A.flowing = !A.readableListening, T(this, A)), A.paused = !1, this;
  };
  function T(A, I) {
    I.resumeScheduled || (I.resumeScheduled = !0, qe.process.nextTick(F, A, I));
  }
  function F(A, I) {
    c("resume", I.reading), I.reading || A.read(0), I.resumeScheduled = !1, A.emit("resume"), D(A), I.flowing && !I.reading && A.read(0);
  }
  K.prototype.pause = function() {
    return c("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (c("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function D(A) {
    var I = A._readableState;
    for (c("flow", I.flowing); I.flowing && A.read() !== null; )
      ;
  }
  K.prototype.wrap = function(A) {
    var I = this, X = this._readableState, oe = !1;
    A.on("end", function() {
      if (c("wrapped end"), X.decoder && !X.ended) {
        var Be = X.decoder.end();
        Be && Be.length && I.push(Be);
      }
      I.push(null);
    }), A.on("data", function(Be) {
      if (c("wrapped data"), X.decoder && (Be = X.decoder.write(Be)), !(X.objectMode && Be == null) && !(!X.objectMode && (!Be || !Be.length))) {
        var vt = I.push(Be);
        vt || (oe = !0, A.pause());
      }
    });
    for (var Ae in A)
      this[Ae] === void 0 && typeof A[Ae] == "function" && (this[Ae] = function(vt) {
        return function() {
          return A[vt].apply(A, arguments);
        };
      }(Ae));
    for (var je = 0; je < R.length; je++)
      A.on(R[je], this.emit.bind(this, R[je]));
    return this._read = function(Be) {
      c("wrapped _read", Be), oe && (oe = !1, A.resume());
    }, this;
  }, typeof Symbol == "function" && (K.prototype[Symbol.asyncIterator] = function() {
    return $ === void 0 && ($ = A6()), $(this);
  }), Object.defineProperty(K.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(K.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(K.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(I) {
      this._readableState && (this._readableState.flowing = I);
    }
  }), K._fromList = U, Object.defineProperty(K.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function U(A, I) {
    if (I.length === 0)
      return null;
    var X;
    return I.objectMode ? X = I.buffer.shift() : !A || A >= I.length ? (I.decoder ? X = I.buffer.join("") : I.buffer.length === 1 ? X = I.buffer.first() : X = I.buffer.concat(I.length), I.buffer.clear()) : X = I.buffer.consume(A, I.decoder), X;
  }
  function k(A) {
    var I = A._readableState;
    c("endReadable", I.endEmitted), I.endEmitted || (I.ended = !0, qe.process.nextTick(Z, I, A));
  }
  function Z(A, I) {
    if (c("endReadableNT", A.endEmitted, A.length), !A.endEmitted && A.length === 0 && (A.endEmitted = !0, I.readable = !1, I.emit("end"), A.autoDestroy)) {
      var X = I._writableState;
      (!X || X.autoDestroy && X.finished) && I.destroy();
    }
  }
  typeof Symbol == "function" && (K.from = function(A, I) {
    return E === void 0 && (E = C6()), E(K, A, I);
  });
  function J(A, I) {
    for (var X = 0, oe = A.length; X < oe; X++)
      if (A[X] === I)
        return X;
    return -1;
  }
  return Zp;
}
var lO = Si, qf = Ys.codes, R6 = qf.ERR_METHOD_NOT_IMPLEMENTED, T6 = qf.ERR_MULTIPLE_CALLBACK, I6 = qf.ERR_TRANSFORM_ALREADY_TRANSFORMING, j6 = qf.ERR_TRANSFORM_WITH_LENGTH_0, Ff = Qa();
ls(Si, Ff);
function k6(e, t) {
  var r = this._transformState;
  r.transforming = !1;
  var i = r.writecb;
  if (i === null)
    return this.emit("error", new T6());
  r.writechunk = null, r.writecb = null, t != null && this.push(t), i(e);
  var n = this._readableState;
  n.reading = !1, (n.needReadable || n.length < n.highWaterMark) && this._read(n.highWaterMark);
}
function Si(e) {
  if (!(this instanceof Si))
    return new Si(e);
  Ff.call(this, e), this._transformState = {
    afterTransform: k6.bind(this),
    needTransform: !1,
    transforming: !1,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }, this._readableState.needReadable = !0, this._readableState.sync = !1, e && (typeof e.transform == "function" && (this._transform = e.transform), typeof e.flush == "function" && (this._flush = e.flush)), this.on("prefinish", M6);
}
function M6() {
  var e = this;
  typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(t, r) {
    J1(e, t, r);
  }) : J1(this, null, null);
}
Si.prototype.push = function(e, t) {
  return this._transformState.needTransform = !1, Ff.prototype.push.call(this, e, t);
};
Si.prototype._transform = function(e, t, r) {
  r(new R6("_transform()"));
};
Si.prototype._write = function(e, t, r) {
  var i = this._transformState;
  if (i.writecb = r, i.writechunk = e, i.writeencoding = t, !i.transforming) {
    var n = this._readableState;
    (i.needTransform || n.needReadable || n.length < n.highWaterMark) && this._read(n.highWaterMark);
  }
};
Si.prototype._read = function(e) {
  var t = this._transformState;
  t.writechunk !== null && !t.transforming ? (t.transforming = !0, this._transform(t.writechunk, t.writeencoding, t.afterTransform)) : t.needTransform = !0;
};
Si.prototype._destroy = function(e, t) {
  Ff.prototype._destroy.call(this, e, function(r) {
    t(r);
  });
};
function J1(e, t, r) {
  if (t)
    return e.emit("error", t);
  if (r != null && e.push(r), e._writableState.length)
    throw new j6();
  if (e._transformState.transforming)
    throw new I6();
  return e.push(null);
}
var N6 = Tu, fO = lO;
ls(Tu, fO);
function Tu(e) {
  if (!(this instanceof Tu))
    return new Tu(e);
  fO.call(this, e);
}
Tu.prototype._transform = function(e, t, r) {
  r(null, e);
};
var zp;
function D6(e) {
  var t = !1;
  return function() {
    t || (t = !0, e.apply(void 0, arguments));
  };
}
var dO = Ys.codes, L6 = dO.ERR_MISSING_ARGS, q6 = dO.ERR_STREAM_DESTROYED;
function X1(e) {
  if (e)
    throw e;
}
function F6(e) {
  return e.setHeader && typeof e.abort == "function";
}
function U6(e, t, r, i) {
  i = D6(i);
  var n = !1;
  e.on("close", function() {
    n = !0;
  }), zp === void 0 && (zp = Sg), zp(e, {
    readable: t,
    writable: r
  }, function(a) {
    if (a)
      return i(a);
    n = !0, i();
  });
  var s = !1;
  return function(a) {
    if (!n && !s) {
      if (s = !0, F6(e))
        return e.abort();
      if (typeof e.destroy == "function")
        return e.destroy();
      i(a || new q6("pipe"));
    }
  };
}
function Q1(e) {
  e();
}
function B6(e, t) {
  return e.pipe(t);
}
function V6(e) {
  return !e.length || typeof e[e.length - 1] != "function" ? X1 : e.pop();
}
function Z6() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  var i = V6(t);
  if (Array.isArray(t[0]) && (t = t[0]), t.length < 2)
    throw new L6("streams");
  var n, s = t.map(function(a, o) {
    var c = o < t.length - 1, l = o > 0;
    return U6(a, c, l, function(d) {
      n || (n = d), d && s.forEach(Q1), !c && (s.forEach(Q1), i(n));
    });
  });
  return t.reduce(B6);
}
var z6 = Z6;
(function(e, t) {
  t = e.exports = cO(), t.Stream = t, t.Readable = t, t.Writable = oO(), t.Duplex = Qa(), t.Transform = lO, t.PassThrough = N6, t.finished = Sg, t.pipeline = z6;
})(vy, vy.exports);
var pO = vy.exports, e_ = Pg, W6 = ls, hO = pO, Wc = Lf.readyStates = {
  UNSENT: 0,
  OPENED: 1,
  HEADERS_RECEIVED: 2,
  LOADING: 3,
  DONE: 4
}, Ag = Lf.IncomingMessage = function(e, t, r, i) {
  var n = this;
  if (hO.Readable.call(n), n._mode = r, n.headers = {}, n.rawHeaders = [], n.trailers = {}, n.rawTrailers = [], n.on("end", function() {
    qe.process.nextTick(function() {
      n.emit("close");
    });
  }), r === "fetch") {
    let d = function() {
      a.read().then(function(p) {
        if (!n._destroyed) {
          if (i(p.done), p.done) {
            n.push(null);
            return;
          }
          n.push(qe.Buffer.from(p.value)), d();
        }
      }).catch(function(p) {
        i(!0), n._destroyed || n.emit("error", p);
      });
    };
    if (n._fetchResponse = t, n.url = t.url, n.statusCode = t.status, n.statusMessage = t.statusText, t.headers.forEach(function(p, h) {
      n.headers[h.toLowerCase()] = p, n.rawHeaders.push(h, p);
    }), e_.writableStream) {
      var s = new WritableStream({
        write: function(p) {
          return i(!1), new Promise(function(h, g) {
            n._destroyed ? g() : n.push(qe.Buffer.from(p)) ? h() : n._resumeFetch = h;
          });
        },
        close: function() {
          i(!0), n._destroyed || n.push(null);
        },
        abort: function(p) {
          i(!0), n._destroyed || n.emit("error", p);
        }
      });
      try {
        t.body.pipeTo(s).catch(function(p) {
          i(!0), n._destroyed || n.emit("error", p);
        });
        return;
      } catch {
      }
    }
    var a = t.body.getReader();
    d();
  } else {
    n._xhr = e, n._pos = 0, n.url = e.responseURL, n.statusCode = e.status, n.statusMessage = e.statusText;
    var o = e.getAllResponseHeaders().split(/\r?\n/);
    if (o.forEach(function(d) {
      var p = d.match(/^([^:]+):\s*(.*)/);
      if (p) {
        var h = p[1].toLowerCase();
        h === "set-cookie" ? (n.headers[h] === void 0 && (n.headers[h] = []), n.headers[h].push(p[2])) : n.headers[h] !== void 0 ? n.headers[h] += ", " + p[2] : n.headers[h] = p[2], n.rawHeaders.push(p[1], p[2]);
      }
    }), n._charset = "x-user-defined", !e_.overrideMimeType) {
      var c = n.rawHeaders["mime-type"];
      if (c) {
        var l = c.match(/;\s*charset=([^;])(;|$)/);
        l && (n._charset = l[1].toLowerCase());
      }
      n._charset || (n._charset = "utf-8");
    }
  }
};
W6(Ag, hO.Readable);
Ag.prototype._read = function() {
  var e = this, t = e._resumeFetch;
  t && (e._resumeFetch = null, t());
};
Ag.prototype._onXHRProgress = function(e) {
  var t = this, r = t._xhr, i = null;
  switch (t._mode) {
    case "text":
      if (i = r.responseText, i.length > t._pos) {
        var n = i.substr(t._pos);
        if (t._charset === "x-user-defined") {
          for (var s = qe.Buffer.alloc(n.length), a = 0; a < n.length; a++)
            s[a] = n.charCodeAt(a) & 255;
          t.push(s);
        } else
          t.push(n, t._charset);
        t._pos = i.length;
      }
      break;
    case "arraybuffer":
      if (r.readyState !== Wc.DONE || !r.response)
        break;
      i = r.response, t.push(qe.Buffer.from(new Uint8Array(i)));
      break;
    case "moz-chunked-arraybuffer":
      if (i = r.response, r.readyState !== Wc.LOADING || !i)
        break;
      t.push(qe.Buffer.from(new Uint8Array(i)));
      break;
    case "ms-stream":
      if (i = r.response, r.readyState !== Wc.LOADING)
        break;
      var o = new tt.MSStreamReader();
      o.onprogress = function() {
        o.result.byteLength > t._pos && (t.push(qe.Buffer.from(new Uint8Array(o.result.slice(t._pos)))), t._pos = o.result.byteLength);
      }, o.onload = function() {
        e(!0), t.push(null);
      }, o.readAsArrayBuffer(i);
      break;
  }
  t._xhr.readyState === Wc.DONE && t._mode !== "ms-stream" && (e(!0), t.push(null));
};
var qs = Pg, H6 = ls, mO = Lf, Cg = pO, G6 = mO.IncomingMessage, t_ = mO.readyStates;
function K6(e, t) {
  return qs.fetch && t ? "fetch" : qs.mozchunkedarraybuffer ? "moz-chunked-arraybuffer" : qs.msstream ? "ms-stream" : qs.arraybuffer && e ? "arraybuffer" : "text";
}
var Pr = rO.exports = function(e) {
  var t = this;
  Cg.Writable.call(t), t._opts = e, t._body = [], t._headers = {}, e.auth && t.setHeader("Authorization", "Basic " + qe.Buffer.from(e.auth).toString("base64")), Object.keys(e.headers).forEach(function(n) {
    t.setHeader(n, e.headers[n]);
  });
  var r, i = !0;
  if (e.mode === "disable-fetch" || "requestTimeout" in e && !qs.abortController)
    i = !1, r = !0;
  else if (e.mode === "prefer-streaming")
    r = !1;
  else if (e.mode === "allow-wrong-content-type")
    r = !qs.overrideMimeType;
  else if (!e.mode || e.mode === "default" || e.mode === "prefer-fast")
    r = !0;
  else
    throw new Error("Invalid value for opts.mode");
  t._mode = K6(r, i), t._fetchTimer = null, t._socketTimeout = null, t._socketTimer = null, t.on("finish", function() {
    t._onFinish();
  });
};
H6(Pr, Cg.Writable);
Pr.prototype.setHeader = function(e, t) {
  var r = this, i = e.toLowerCase();
  J6.indexOf(i) === -1 && (r._headers[i] = {
    name: e,
    value: t
  });
};
Pr.prototype.getHeader = function(e) {
  var t = this._headers[e.toLowerCase()];
  return t ? t.value : null;
};
Pr.prototype.removeHeader = function(e) {
  var t = this;
  delete t._headers[e.toLowerCase()];
};
Pr.prototype._onFinish = function() {
  var e = this;
  if (!e._destroyed) {
    var t = e._opts;
    "timeout" in t && t.timeout !== 0 && e.setTimeout(t.timeout);
    var r = e._headers, i = null;
    t.method !== "GET" && t.method !== "HEAD" && (i = new Blob(e._body, {
      type: (r["content-type"] || {}).value || ""
    }));
    var n = [];
    if (Object.keys(r).forEach(function(c) {
      var l = r[c].name, d = r[c].value;
      Array.isArray(d) ? d.forEach(function(p) {
        n.push([l, p]);
      }) : n.push([l, d]);
    }), e._mode === "fetch") {
      var s = null;
      if (qs.abortController) {
        var a = new AbortController();
        s = a.signal, e._fetchAbortController = a, "requestTimeout" in t && t.requestTimeout !== 0 && (e._fetchTimer = tt.setTimeout(function() {
          e.emit("requestTimeout"), e._fetchAbortController && e._fetchAbortController.abort();
        }, t.requestTimeout));
      }
      tt.fetch(e._opts.url, {
        method: e._opts.method,
        headers: n,
        body: i || void 0,
        mode: "cors",
        credentials: t.withCredentials ? "include" : "same-origin",
        signal: s
      }).then(function(c) {
        e._fetchResponse = c, e._resetTimers(!1), e._connect();
      }, function(c) {
        e._resetTimers(!0), e._destroyed || e.emit("error", c);
      });
    } else {
      var o = e._xhr = new tt.XMLHttpRequest();
      try {
        o.open(e._opts.method, e._opts.url, !0);
      } catch (c) {
        qe.process.nextTick(function() {
          e.emit("error", c);
        });
        return;
      }
      "responseType" in o && (o.responseType = e._mode), "withCredentials" in o && (o.withCredentials = !!t.withCredentials), e._mode === "text" && "overrideMimeType" in o && o.overrideMimeType("text/plain; charset=x-user-defined"), "requestTimeout" in t && (o.timeout = t.requestTimeout, o.ontimeout = function() {
        e.emit("requestTimeout");
      }), n.forEach(function(c) {
        o.setRequestHeader(c[0], c[1]);
      }), e._response = null, o.onreadystatechange = function() {
        switch (o.readyState) {
          case t_.LOADING:
          case t_.DONE:
            e._onXHRProgress();
            break;
        }
      }, e._mode === "moz-chunked-arraybuffer" && (o.onprogress = function() {
        e._onXHRProgress();
      }), o.onerror = function() {
        e._destroyed || (e._resetTimers(!0), e.emit("error", new Error("XHR error")));
      };
      try {
        o.send(i);
      } catch (c) {
        qe.process.nextTick(function() {
          e.emit("error", c);
        });
        return;
      }
    }
  }
};
function Y6(e) {
  try {
    var t = e.status;
    return t !== null && t !== 0;
  } catch {
    return !1;
  }
}
Pr.prototype._onXHRProgress = function() {
  var e = this;
  e._resetTimers(!1), !(!Y6(e._xhr) || e._destroyed) && (e._response || e._connect(), e._response._onXHRProgress(e._resetTimers.bind(e)));
};
Pr.prototype._connect = function() {
  var e = this;
  e._destroyed || (e._response = new G6(e._xhr, e._fetchResponse, e._mode, e._resetTimers.bind(e)), e._response.on("error", function(t) {
    e.emit("error", t);
  }), e.emit("response", e._response));
};
Pr.prototype._write = function(e, t, r) {
  var i = this;
  i._body.push(e), r();
};
Pr.prototype._resetTimers = function(e) {
  var t = this;
  tt.clearTimeout(t._socketTimer), t._socketTimer = null, e ? (tt.clearTimeout(t._fetchTimer), t._fetchTimer = null) : t._socketTimeout && (t._socketTimer = tt.setTimeout(function() {
    t.emit("timeout");
  }, t._socketTimeout));
};
Pr.prototype.abort = Pr.prototype.destroy = function(e) {
  var t = this;
  t._destroyed = !0, t._resetTimers(!0), t._response && (t._response._destroyed = !0), t._xhr ? t._xhr.abort() : t._fetchAbortController && t._fetchAbortController.abort(), e && t.emit("error", e);
};
Pr.prototype.end = function(e, t, r) {
  var i = this;
  typeof e == "function" && (r = e, e = void 0), Cg.Writable.prototype.end.call(i, e, t, r);
};
Pr.prototype.setTimeout = function(e, t) {
  var r = this;
  t && r.once("timeout", t), r._socketTimeout = e, r._resetTimers(!1);
};
Pr.prototype.flushHeaders = function() {
};
Pr.prototype.setNoDelay = function() {
};
Pr.prototype.setSocketKeepAlive = function() {
};
var J6 = [
  "accept-charset",
  "accept-encoding",
  "access-control-request-headers",
  "access-control-request-method",
  "connection",
  "content-length",
  "cookie",
  "cookie2",
  "date",
  "dnt",
  "expect",
  "host",
  "keep-alive",
  "origin",
  "referer",
  "te",
  "trailer",
  "transfer-encoding",
  "upgrade",
  "via"
], X6 = rO.exports, Q6 = t4, e4 = Object.prototype.hasOwnProperty;
function t4() {
  for (var e = {}, t = 0; t < arguments.length; t++) {
    var r = arguments[t];
    for (var i in r)
      e4.call(r, i) && (e[i] = r[i]);
  }
  return e;
}
var r4 = {
  100: "Continue",
  101: "Switching Protocols",
  102: "Processing",
  200: "OK",
  201: "Created",
  202: "Accepted",
  203: "Non-Authoritative Information",
  204: "No Content",
  205: "Reset Content",
  206: "Partial Content",
  207: "Multi-Status",
  208: "Already Reported",
  226: "IM Used",
  300: "Multiple Choices",
  301: "Moved Permanently",
  302: "Found",
  303: "See Other",
  304: "Not Modified",
  305: "Use Proxy",
  307: "Temporary Redirect",
  308: "Permanent Redirect",
  400: "Bad Request",
  401: "Unauthorized",
  402: "Payment Required",
  403: "Forbidden",
  404: "Not Found",
  405: "Method Not Allowed",
  406: "Not Acceptable",
  407: "Proxy Authentication Required",
  408: "Request Timeout",
  409: "Conflict",
  410: "Gone",
  411: "Length Required",
  412: "Precondition Failed",
  413: "Payload Too Large",
  414: "URI Too Long",
  415: "Unsupported Media Type",
  416: "Range Not Satisfiable",
  417: "Expectation Failed",
  418: "I'm a teapot",
  421: "Misdirected Request",
  422: "Unprocessable Entity",
  423: "Locked",
  424: "Failed Dependency",
  425: "Unordered Collection",
  426: "Upgrade Required",
  428: "Precondition Required",
  429: "Too Many Requests",
  431: "Request Header Fields Too Large",
  451: "Unavailable For Legal Reasons",
  500: "Internal Server Error",
  501: "Not Implemented",
  502: "Bad Gateway",
  503: "Service Unavailable",
  504: "Gateway Timeout",
  505: "HTTP Version Not Supported",
  506: "Variant Also Negotiates",
  507: "Insufficient Storage",
  508: "Loop Detected",
  509: "Bandwidth Limit Exceeded",
  510: "Not Extended",
  511: "Network Authentication Required"
};
(function(e) {
  var t = X6, r = Lf, i = Q6, n = r4, s = Ou, a = e;
  a.request = function(o, c) {
    typeof o == "string" ? o = s.parse(o) : o = i(o);
    var l = tt.location.protocol.search(/^https?:$/) === -1 ? "http:" : "", d = o.protocol || l, p = o.hostname || o.host, h = o.port, g = o.path || "/";
    p && p.indexOf(":") !== -1 && (p = "[" + p + "]"), o.url = (p ? d + "//" + p : "") + (h ? ":" + h : "") + g, o.method = (o.method || "GET").toUpperCase(), o.headers = o.headers || {};
    var m = new t(o);
    return c && m.on("response", c), m;
  }, a.get = function(c, l) {
    var d = a.request(c, l);
    return d.end(), d;
  }, a.ClientRequest = t, a.IncomingMessage = r.IncomingMessage, a.Agent = function() {
  }, a.Agent.defaultMaxSockets = 4, a.globalAgent = new a.Agent(), a.STATUS_CODES = n, a.METHODS = [
    "CHECKOUT",
    "CONNECT",
    "COPY",
    "DELETE",
    "GET",
    "HEAD",
    "LOCK",
    "M-SEARCH",
    "MERGE",
    "MKACTIVITY",
    "MKCOL",
    "MOVE",
    "NOTIFY",
    "OPTIONS",
    "PATCH",
    "POST",
    "PROPFIND",
    "PROPPATCH",
    "PURGE",
    "PUT",
    "REPORT",
    "SEARCH",
    "SUBSCRIBE",
    "TRACE",
    "UNLOCK",
    "UNSUBSCRIBE"
  ];
})(Df);
var yO = { exports: {} };
(function(e) {
  var t = Df, r = Ou, i = e.exports;
  for (var n in t)
    t.hasOwnProperty(n) && (i[n] = t[n]);
  i.request = function(a, o) {
    return a = s(a), t.request.call(this, a, o);
  }, i.get = function(a, o) {
    return a = s(a), t.get.call(this, a, o);
  };
  function s(a) {
    if (typeof a == "string" && (a = r.parse(a)), a.protocol || (a.protocol = "https:"), a.protocol !== "https:")
      throw new Error('Protocol "' + a.protocol + '" not supported. Expected "https:"');
    return a;
  }
})(yO);
var gO = yO.exports;
const n4 = Df, i4 = gO, { ono: Hc } = In, { ResolverError: r_ } = ir, su = pn;
function s4(e, t) {
  return new Promise((r, i) => {
    const s = (e.protocol === "https:" ? i4 : n4).get({
      hostname: e.hostname,
      port: e.port,
      path: e.path,
      auth: e.auth,
      protocol: e.protocol,
      headers: t.headers || {},
      withCredentials: t.withCredentials
    });
    typeof s.setTimeout == "function" && s.setTimeout(t.timeout), s.on("timeout", () => {
      s.abort();
    }), s.on("error", i), s.once("response", (a) => {
      a.body = qe.Buffer.alloc(0), a.on("data", (o) => {
        a.body = qe.Buffer.concat([a.body, qe.Buffer.from(o)]);
      }), a.on("error", i), a.on("end", () => {
        r(a);
      });
    });
  });
}
function vO(e, t, r) {
  return new Promise((i, n) => {
    e = su.parse(e), r = r || [], r.push(e.href), s4(e, t).then((s) => {
      if (s.statusCode >= 400)
        throw Hc({ status: s.statusCode }, `HTTP ERROR ${s.statusCode}`);
      if (s.statusCode >= 300)
        if (r.length > t.redirects)
          n(
            new r_(
              Hc(
                { status: s.statusCode },
                `Error downloading ${r[0]}. 
Too many redirects: 
  ${r.join(` 
  `)}`
              )
            )
          );
        else if (s.headers.location) {
          const a = su.resolve(e, s.headers.location);
          vO(a, t, r).then(i, n);
        } else
          throw Hc({ status: s.statusCode }, `HTTP ${s.statusCode} redirect with no location header`);
      else
        i(s.body || qe.Buffer.alloc(0));
    }).catch((s) => {
      n(new r_(Hc(s, `Error downloading ${e.href}`), e.href));
    });
  });
}
var a4 = {
  /**
   * The order that this resolver will run, in relation to other resolvers.
   *
   * @type {number}
   */
  order: 200,
  /**
   * HTTP headers to send when downloading files.
   *
   * @example:
   * {
   *   "User-Agent": "JSON Schema $Ref Parser",
   *   Accept: "application/json"
   * }
   *
   * @type {object}
   */
  headers: null,
  /**
   * HTTP request timeout (in milliseconds).
   *
   * @type {number}
   */
  timeout: 5e3,
  // 5 seconds
  /**
   * The maximum number of HTTP redirects to follow.
   * To disable automatic following of redirects, set this to zero.
   *
   * @type {number}
   */
  redirects: 5,
  /**
   * The `withCredentials` option of XMLHttpRequest.
   * Set this to `true` if you're downloading files from a CORS-enabled server that requires authentication
   *
   * @type {boolean}
   */
  withCredentials: !1,
  /**
   * Determines whether this resolver can read a given file reference.
   * Resolvers that return true will be tried in order, until one successfully resolves the file.
   * Resolvers that return false will not be given a chance to resolve the file.
   *
   * @param {object} file           - An object containing information about the referenced file
   * @param {string} file.url       - The full URL of the referenced file
   * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
   * @returns {boolean}
   */
  canRead(e) {
    return su.isHttp(e.url);
  },
  /**
   * Reads the given URL and returns its raw contents as a Buffer.
   *
   * @param {object} file           - An object containing information about the referenced file
   * @param {string} file.url       - The full URL of the referenced file
   * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
   * @returns {Promise<Buffer>}
   */
  read(e) {
    const t = su.parse(e.url);
    return qe.process.browser && !t.protocol && (t.protocol = su.parse(location.href).protocol), vO(t, this);
  }
};
const o4 = D5, u4 = q5, c4 = B5, l4 = a6, f4 = l6, d4 = a4;
var bO = Rg;
function Rg(e) {
  _y(this, Rg.defaults), _y(this, e);
}
Rg.defaults = {
  /**
   * Determines how different types of files will be parsed.
   *
   * You can add additional parsers of your own, replace an existing one with
   * your own implementation, or disable any parser by setting it to false.
   */
  parse: {
    json: u4,
    yaml: l4,
    text: c4,
    binary: o4
  },
  /**
   * Determines how JSON References will be resolved.
   *
   * You can add additional resolvers of your own, replace an existing one with
   * your own implementation, or disable any resolver by setting it to false.
   */
  resolve: {
    file: f4,
    http: d4,
    /**
     * Determines whether external $ref pointers will be resolved.
     * If this option is disabled, then none of above resolvers will be called.
     * Instead, external $ref pointers will simply be ignored.
     *
     * @type {boolean}
     */
    external: !0
  },
  /**
   * By default, JSON Schema $Ref Parser throws the first error it encounters. Setting `continueOnError` to `true`
   * causes it to keep processing as much as possible and then throw a single error that contains all errors
   * that were encountered.
   */
  continueOnError: !1,
  /**
   * Determines the types of JSON references that are allowed.
   */
  dereference: {
    /**
     * Dereference circular (recursive) JSON references?
     * If false, then a {@link ReferenceError} will be thrown if a circular reference is found.
     * If "ignore", then circular references will not be dereferenced.
     *
     * @type {boolean|string}
     */
    circular: !0
  }
};
function _y(e, t) {
  if (n_(t)) {
    const r = Object.keys(t);
    for (let i = 0; i < r.length; i++) {
      const n = r[i], s = t[n], a = e[n];
      n_(s) ? e[n] = _y(a || {}, s) : s !== void 0 && (e[n] = s);
    }
  }
  return e;
}
function n_(e) {
  return e && typeof e == "object" && !Array.isArray(e) && !(e instanceof RegExp) && !(e instanceof Date);
}
const i_ = bO;
var _O = function(t) {
  let r, i, n, s;
  return t = Array.prototype.slice.call(t), typeof t[t.length - 1] == "function" && (s = t.pop()), typeof t[0] == "string" ? (r = t[0], typeof t[2] == "object" ? (i = t[1], n = t[2]) : (i = void 0, n = t[1])) : (r = "", i = t[0], n = t[1]), n instanceof i_ || (n = new i_(n)), {
    path: r,
    schema: i,
    options: n,
    callback: s
  };
}, Ku = {};
Ku.all = function(e) {
  return Object.keys(e).filter((t) => typeof e[t] == "object").map((t) => (e[t].name = t, e[t]));
};
Ku.filter = function(e, t, r) {
  return e.filter((i) => !!wO(i, t, r));
};
Ku.sort = function(e) {
  for (const t of e)
    t.order = t.order || Number.MAX_SAFE_INTEGER;
  return e.sort((t, r) => t.order - r.order);
};
Ku.run = function(e, t, r, i) {
  let n, s, a = 0;
  return new Promise((o, c) => {
    l();
    function l() {
      if (n = e[a++], !n)
        return c(s);
      try {
        const g = wO(n, t, r, d, i);
        if (g && typeof g.then == "function")
          g.then(p, h);
        else if (g !== void 0)
          p(g);
        else if (a === e.length)
          throw new Error("No promise has been returned or callback has been called.");
      } catch (g) {
        h(g);
      }
    }
    function d(g, m) {
      g ? h(g) : p(m);
    }
    function p(g) {
      o({
        plugin: n,
        result: g
      });
    }
    function h(g) {
      s = {
        plugin: n,
        error: g
      }, l();
    }
  });
};
function wO(e, t, r, i, n) {
  const s = e[t];
  if (typeof s == "function")
    return s.apply(e, [r, i, n]);
  if (!i) {
    if (s instanceof RegExp)
      return s.test(r.url);
    if (typeof s == "string")
      return s === r.extension;
    if (Array.isArray(s))
      return s.indexOf(r.extension) !== -1;
  }
  return s;
}
const { ono: wy } = In, {
  ResolverError: s_,
  ParserError: a_,
  UnmatchedParserError: p4,
  UnmatchedResolverError: h4,
  isHandledError: m4
} = ir, Qi = Ku, o_ = pn;
var $O = async function(t, r, i) {
  t = o_.stripHash(t);
  const n = r._add(t), s = {
    url: t,
    extension: o_.getExtension(t)
  };
  try {
    const a = await y4(s, i, r);
    n.pathType = a.plugin.name, s.data = a.result;
    const o = await g4(s, i, r);
    return n.value = o.result, o.result;
  } catch (a) {
    throw m4(a) && (n.value = a), a;
  }
};
function y4(e, t, r) {
  return new Promise((i, n) => {
    let s = Qi.all(t.resolve);
    s = Qi.filter(s, "canRead", e), Qi.sort(s), Qi.run(s, "read", e, r).then(i, a);
    function a(o) {
      !o && t.continueOnError ? n(new h4(e.url)) : !o || !("error" in o) ? n(wy.syntax(`Unable to resolve $ref pointer "${e.url}"`)) : o.error instanceof s_ ? n(o.error) : n(new s_(o, e.url));
    }
  });
}
function g4(e, t, r) {
  return new Promise((i, n) => {
    const s = Qi.all(t.parse), a = Qi.filter(s, "canParse", e), o = a.length > 0 ? a : s;
    Qi.sort(o), Qi.run(o, "parse", e, r).then(c, l);
    function c(d) {
      !d.plugin.allowEmpty && v4(d.result) ? n(wy.syntax(`Error parsing "${e.url}" as ${d.plugin.name}. 
Parsed value is empty`)) : i(d);
    }
    function l(d) {
      !d && t.continueOnError ? n(new p4(e.url)) : !d || !("error" in d) ? n(wy.syntax(`Unable to parse ${e.url}`)) : d.error instanceof a_ ? n(d.error) : n(new a_(d.error.message, e.url));
    }
  });
}
function v4(e) {
  return e === void 0 || typeof e == "object" && Object.keys(e).length === 0 || typeof e == "string" && e.trim().length === 0 || qe.Buffer.isBuffer(e) && e.length === 0;
}
const { ono: EO } = In, b4 = Wu(), cs = pn;
var _4 = Tn;
function Tn() {
  this.circular = !1, this.circularRefs = [], this._$refs = {}, this._root$Ref = null;
}
Tn.prototype.paths = function(e) {
  return xO(this._$refs, arguments).map((r) => r.decoded);
};
Tn.prototype.values = function(e) {
  const t = this._$refs;
  return xO(t, arguments).reduce((i, n) => (i[n.decoded] = t[n.encoded].value, i), {});
};
Tn.prototype.toJSON = Tn.prototype.values;
Tn.prototype.exists = function(e, t) {
  try {
    return this._resolve(e, "", t), !0;
  } catch {
    return !1;
  }
};
Tn.prototype.get = function(e, t) {
  return this._resolve(e, "", t).value;
};
Tn.prototype.set = function(e, t) {
  const r = cs.resolve(this._root$Ref.path, e), i = cs.stripHash(r), n = this._$refs[i];
  if (!n)
    throw EO(`Error resolving $ref pointer "${e}". 
"${i}" not found.`);
  n.set(r, t);
};
Tn.prototype._add = function(e) {
  const t = cs.stripHash(e), r = new b4();
  return r.path = t, r.$refs = this, this._$refs[t] = r, this._root$Ref = this._root$Ref || r, r;
};
Tn.prototype._resolve = function(e, t, r) {
  const i = cs.resolve(this._root$Ref.path, e), n = cs.stripHash(i), s = this._$refs[n];
  if (!s)
    throw EO(`Error resolving $ref pointer "${e}". 
"${n}" not found.`);
  return s.resolve(i, r, e, t);
};
Tn.prototype._get$Ref = function(e) {
  e = cs.resolve(this._root$Ref.path, e);
  const t = cs.stripHash(e);
  return this._$refs[t];
};
function xO(e, t) {
  let r = Object.keys(e);
  return t = Array.isArray(t[0]) ? t[0] : Array.prototype.slice.call(t), t.length > 0 && t[0] && (r = r.filter((i) => t.indexOf(e[i].pathType) !== -1)), r.map((i) => ({
    encoded: i,
    decoded: e[i].pathType === "file" ? cs.toFileSystemPath(i, !0) : i
  }));
}
const w4 = $O, $4 = kf(), u_ = Wu(), { isHandledError: E4 } = ir, qo = pn;
var x4 = O4;
function O4(e, t) {
  if (!t.resolve.external)
    return Promise.resolve();
  try {
    const r = Tg(e.schema, `${e.$refs._root$Ref.path}#`, e.$refs, t);
    return Promise.all(r);
  } catch (r) {
    return Promise.reject(r);
  }
}
function Tg(e, t, r, i, n) {
  n = n || /* @__PURE__ */ new Set();
  let s = [];
  if (e && typeof e == "object" && !ArrayBuffer.isView(e) && !n.has(e))
    if (n.add(e), u_.isExternal$Ref(e))
      s.push(c_(e, t, r, i));
    else
      for (const a of Object.keys(e)) {
        const o = $4.join(t, a), c = e[a];
        u_.isExternal$Ref(c) ? s.push(c_(c, o, r, i)) : s = s.concat(Tg(c, o, r, i, n));
      }
  return s;
}
async function c_(e, t, r, i) {
  const n = qo.resolve(t, e.$ref), s = qo.stripHash(n);
  if (e = r._$refs[s], e)
    return Promise.resolve(e.value);
  try {
    const a = await w4(n, r, i), o = Tg(a, `${s}#`, r, i);
    return Promise.all(o);
  } catch (a) {
    if (!i.continueOnError || !E4(a))
      throw a;
    return r._$refs[s] && (a.source = qo.stripHash(t), a.path = qo.safePointerToPath(qo.getHash(t))), [];
  }
}
const { ono: l_ } = In, On = DE, P4 = R5, S4 = cx, Uf = _O, A4 = $O, OO = _4, C4 = x4, {
  JSONParserError: R4,
  InvalidPointerError: T4,
  MissingPointerError: I4,
  ResolverError: j4,
  ParserError: k4,
  UnmatchedParserError: M4,
  UnmatchedResolverError: N4,
  isHandledError: D4,
  JSONParserErrorGroup: f_
} = ir, xa = pn;
ti.exports = ri;
ti.exports.default = ri;
ti.exports.JSONParserError = R4;
ti.exports.InvalidPointerError = T4;
ti.exports.MissingPointerError = I4;
ti.exports.ResolverError = j4;
ti.exports.ParserError = k4;
ti.exports.UnmatchedParserError = M4;
ti.exports.UnmatchedResolverError = N4;
function ri() {
  this.schema = null, this.$refs = new OO();
}
ri.parse = function(t, r, i, n) {
  const s = this, a = new s();
  return a.parse.apply(a, arguments);
};
ri.prototype.parse = async function(t, r, i, n) {
  const s = Uf(arguments);
  let a;
  if (!s.path && !s.schema) {
    const l = l_(`Expected a file path, URL, or object. Got ${s.path || s.schema}`);
    return On(s.callback, Promise.reject(l));
  }
  this.schema = null, this.$refs = new OO();
  let o = "http";
  if (xa.isFileSystemPath(s.path) && (s.path = xa.fromFileSystemPath(s.path), o = "file"), s.path = xa.resolve(xa.cwd(), s.path), s.schema && typeof s.schema == "object") {
    const l = this.$refs._add(s.path);
    l.value = s.schema, l.pathType = o, a = Promise.resolve(s.schema);
  } else
    a = A4(s.path, this.$refs, s.options);
  const c = this;
  try {
    const l = await a;
    if (l !== null && typeof l == "object" && !qe.Buffer.isBuffer(l))
      return c.schema = l, On(s.callback, Promise.resolve(c.schema));
    if (s.options.continueOnError)
      return c.schema = null, On(s.callback, Promise.resolve(c.schema));
    throw l_.syntax(`"${c.$refs._root$Ref.path || l}" is not a valid JSON Schema`);
  } catch (l) {
    return !s.options.continueOnError || !D4(l) ? On(s.callback, Promise.reject(l)) : (this.$refs._$refs[xa.stripHash(s.path)] && this.$refs._$refs[xa.stripHash(s.path)].addError(l), On(s.callback, Promise.resolve(null)));
  }
};
ri.resolve = function(t, r, i, n) {
  const s = this, a = new s();
  return a.resolve.apply(a, arguments);
};
ri.prototype.resolve = async function(t, r, i, n) {
  const s = this, a = Uf(arguments);
  try {
    return await this.parse(a.path, a.schema, a.options), await C4(s, a.options), Ig(s), On(a.callback, Promise.resolve(s.$refs));
  } catch (o) {
    return On(a.callback, Promise.reject(o));
  }
};
ri.bundle = function(t, r, i, n) {
  const s = this, a = new s();
  return a.bundle.apply(a, arguments);
};
ri.prototype.bundle = async function(t, r, i, n) {
  const s = this, a = Uf(arguments);
  try {
    return await this.resolve(a.path, a.schema, a.options), P4(s, a.options), Ig(s), On(a.callback, Promise.resolve(s.schema));
  } catch (o) {
    return On(a.callback, Promise.reject(o));
  }
};
ri.dereference = function(t, r, i, n) {
  const s = this, a = new s();
  return a.dereference.apply(a, arguments);
};
ri.prototype.dereference = async function(t, r, i, n) {
  const s = this, a = Uf(arguments);
  try {
    return await this.resolve(a.path, a.schema, a.options), S4(s, a.options), Ig(s), On(a.callback, Promise.resolve(s.schema));
  } catch (o) {
    return On(a.callback, Promise.reject(o));
  }
};
function Ig(e) {
  if (f_.getParserErrors(e).length > 0)
    throw new f_(e);
}
var L4 = ti.exports, ni = {};
const PO = no, q4 = pn;
ni.format = PO.format;
ni.inherits = PO.inherits;
ni.swaggerParamRegExp = /\{([^/}]+)}/g;
const F4 = ["get", "post", "put", "delete", "patch", "options", "head", "trace"];
function Wp(e, t) {
  if (e.url && e.url.startsWith("/")) {
    const r = q4.parse(t), i = `${r.protocol}//${r.hostname}${e.url}`;
    e.url = i;
  }
  return e;
}
function U4(e, t) {
  e.openapi && t && (t.startsWith("http:") || t.startsWith("https:")) && (e.servers && e.servers.map((r) => Wp(r, t)), ["paths", "webhooks"].forEach((r) => {
    Object.keys(e[r] || []).forEach((i) => {
      const n = e[r][i];
      Object.keys(n).forEach((s) => {
        s === "servers" ? n[s].map((a) => Wp(a, t)) : F4.includes(s) && n[s].servers && n[s].servers.map((a) => Wp(a, t));
      });
    });
  }));
}
function B4(e) {
  return e.swagger ? "Swagger" : "OpenAPI";
}
ni.fixOasRelativeServers = U4;
ni.getSpecificationName = B4;
var $y = { exports: {} };
const V4 = "https://raw.githubusercontent.com/OAI/OpenAPI-Specification/master/schemas/v1.2/apiDeclaration.json#", Z4 = "http://json-schema.org/draft-04/schema#", z4 = "object", W4 = [
  "swaggerVersion",
  "basePath",
  "apis"
], H4 = {
  swaggerVersion: {
    enum: [
      "1.2"
    ]
  },
  apiVersion: {
    type: "string"
  },
  basePath: {
    type: "string",
    format: "uri",
    pattern: "^https?://"
  },
  resourcePath: {
    type: "string",
    format: "uri",
    pattern: "^/"
  },
  apis: {
    type: "array",
    items: {
      $ref: "#/definitions/apiObject"
    }
  },
  models: {
    type: "object",
    additionalProperties: {
      $ref: "modelsObject.json#"
    }
  },
  produces: {
    $ref: "#/definitions/mimeTypeArray"
  },
  consumes: {
    $ref: "#/definitions/mimeTypeArray"
  },
  authorizations: {
    $ref: "authorizationObject.json#"
  }
}, G4 = !1, K4 = {
  apiObject: {
    type: "object",
    required: [
      "path",
      "operations"
    ],
    properties: {
      path: {
        type: "string",
        format: "uri-template",
        pattern: "^/"
      },
      description: {
        type: "string"
      },
      operations: {
        type: "array",
        items: {
          $ref: "operationObject.json#"
        }
      }
    },
    additionalProperties: !1
  },
  mimeTypeArray: {
    type: "array",
    items: {
      type: "string",
      format: "mime-type"
    },
    uniqueItems: !0
  }
}, Y4 = {
  id: V4,
  $schema: Z4,
  type: z4,
  required: W4,
  properties: H4,
  additionalProperties: G4,
  definitions: K4
}, J4 = "A JSON Schema for Swagger 2.0 API.", X4 = "http://swagger.io/v2/schema.json#", Q4 = "http://json-schema.org/draft-04/schema#", eq = "object", tq = [
  "swagger",
  "info",
  "paths"
], rq = !1, nq = {
  "^x-": {
    $ref: "#/definitions/vendorExtension"
  }
}, iq = {
  swagger: {
    type: "string",
    enum: [
      "2.0"
    ],
    description: "The Swagger version of this document."
  },
  info: {
    $ref: "#/definitions/info"
  },
  host: {
    type: "string",
    pattern: "^[^{}/ :\\\\]+(?::\\d+)?$",
    description: "The host (name or ip) of the API. Example: 'swagger.io'"
  },
  basePath: {
    type: "string",
    pattern: "^/",
    description: "The base path to the API. Example: '/api'."
  },
  schemes: {
    $ref: "#/definitions/schemesList"
  },
  consumes: {
    description: "A list of MIME types accepted by the API.",
    allOf: [
      {
        $ref: "#/definitions/mediaTypeList"
      }
    ]
  },
  produces: {
    description: "A list of MIME types the API can produce.",
    allOf: [
      {
        $ref: "#/definitions/mediaTypeList"
      }
    ]
  },
  paths: {
    $ref: "#/definitions/paths"
  },
  definitions: {
    $ref: "#/definitions/definitions"
  },
  parameters: {
    $ref: "#/definitions/parameterDefinitions"
  },
  responses: {
    $ref: "#/definitions/responseDefinitions"
  },
  security: {
    $ref: "#/definitions/security"
  },
  securityDefinitions: {
    $ref: "#/definitions/securityDefinitions"
  },
  tags: {
    type: "array",
    items: {
      $ref: "#/definitions/tag"
    },
    uniqueItems: !0
  },
  externalDocs: {
    $ref: "#/definitions/externalDocs"
  }
}, sq = {
  info: {
    type: "object",
    description: "General information about the API.",
    required: [
      "version",
      "title"
    ],
    additionalProperties: !1,
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    },
    properties: {
      title: {
        type: "string",
        description: "A unique and precise title of the API."
      },
      version: {
        type: "string",
        description: "A semantic version number of the API."
      },
      description: {
        type: "string",
        description: "A longer description of the API. Should be different from the title.  GitHub Flavored Markdown is allowed."
      },
      termsOfService: {
        type: "string",
        description: "The terms of service for the API."
      },
      contact: {
        $ref: "#/definitions/contact"
      },
      license: {
        $ref: "#/definitions/license"
      }
    }
  },
  contact: {
    type: "object",
    description: "Contact information for the owners of the API.",
    additionalProperties: !1,
    properties: {
      name: {
        type: "string",
        description: "The identifying name of the contact person/organization."
      },
      url: {
        type: "string",
        description: "The URL pointing to the contact information.",
        format: "uri"
      },
      email: {
        type: "string",
        description: "The email address of the contact person/organization.",
        format: "email"
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  license: {
    type: "object",
    required: [
      "name"
    ],
    additionalProperties: !1,
    properties: {
      name: {
        type: "string",
        description: "The name of the license type. It's encouraged to use an OSI compatible license."
      },
      url: {
        type: "string",
        description: "The URL pointing to the license.",
        format: "uri"
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  paths: {
    type: "object",
    description: "Relative paths to the individual endpoints. They must be relative to the 'basePath'.",
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      },
      "^/": {
        $ref: "#/definitions/pathItem"
      }
    },
    additionalProperties: !1
  },
  definitions: {
    type: "object",
    additionalProperties: {
      $ref: "#/definitions/schema"
    },
    description: "One or more JSON objects describing the schemas being consumed and produced by the API."
  },
  parameterDefinitions: {
    type: "object",
    additionalProperties: {
      $ref: "#/definitions/parameter"
    },
    description: "One or more JSON representations for parameters"
  },
  responseDefinitions: {
    type: "object",
    additionalProperties: {
      $ref: "#/definitions/response"
    },
    description: "One or more JSON representations for responses"
  },
  externalDocs: {
    type: "object",
    additionalProperties: !1,
    description: "information about external documentation",
    required: [
      "url"
    ],
    properties: {
      description: {
        type: "string"
      },
      url: {
        type: "string",
        format: "uri"
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  examples: {
    type: "object",
    additionalProperties: !0
  },
  mimeType: {
    type: "string",
    description: "The MIME type of the HTTP message."
  },
  operation: {
    type: "object",
    required: [
      "responses"
    ],
    additionalProperties: !1,
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    },
    properties: {
      tags: {
        type: "array",
        items: {
          type: "string"
        },
        uniqueItems: !0
      },
      summary: {
        type: "string",
        description: "A brief summary of the operation."
      },
      description: {
        type: "string",
        description: "A longer description of the operation, GitHub Flavored Markdown is allowed."
      },
      externalDocs: {
        $ref: "#/definitions/externalDocs"
      },
      operationId: {
        type: "string",
        description: "A unique identifier of the operation."
      },
      produces: {
        description: "A list of MIME types the API can produce.",
        allOf: [
          {
            $ref: "#/definitions/mediaTypeList"
          }
        ]
      },
      consumes: {
        description: "A list of MIME types the API can consume.",
        allOf: [
          {
            $ref: "#/definitions/mediaTypeList"
          }
        ]
      },
      parameters: {
        $ref: "#/definitions/parametersList"
      },
      responses: {
        $ref: "#/definitions/responses"
      },
      schemes: {
        $ref: "#/definitions/schemesList"
      },
      deprecated: {
        type: "boolean",
        default: !1
      },
      security: {
        $ref: "#/definitions/security"
      }
    }
  },
  pathItem: {
    type: "object",
    additionalProperties: !1,
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    },
    properties: {
      $ref: {
        type: "string"
      },
      get: {
        $ref: "#/definitions/operation"
      },
      put: {
        $ref: "#/definitions/operation"
      },
      post: {
        $ref: "#/definitions/operation"
      },
      delete: {
        $ref: "#/definitions/operation"
      },
      options: {
        $ref: "#/definitions/operation"
      },
      head: {
        $ref: "#/definitions/operation"
      },
      patch: {
        $ref: "#/definitions/operation"
      },
      parameters: {
        $ref: "#/definitions/parametersList"
      }
    }
  },
  responses: {
    type: "object",
    description: "Response objects names can either be any valid HTTP status code or 'default'.",
    minProperties: 1,
    additionalProperties: !1,
    patternProperties: {
      "^([0-9]{3})$|^(default)$": {
        $ref: "#/definitions/responseValue"
      },
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    },
    not: {
      type: "object",
      additionalProperties: !1,
      patternProperties: {
        "^x-": {
          $ref: "#/definitions/vendorExtension"
        }
      }
    }
  },
  responseValue: {
    oneOf: [
      {
        $ref: "#/definitions/response"
      },
      {
        $ref: "#/definitions/jsonReference"
      }
    ]
  },
  response: {
    type: "object",
    required: [
      "description"
    ],
    properties: {
      description: {
        type: "string"
      },
      schema: {
        oneOf: [
          {
            $ref: "#/definitions/schema"
          },
          {
            $ref: "#/definitions/fileSchema"
          }
        ]
      },
      headers: {
        $ref: "#/definitions/headers"
      },
      examples: {
        $ref: "#/definitions/examples"
      }
    },
    additionalProperties: !1,
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  headers: {
    type: "object",
    additionalProperties: {
      $ref: "#/definitions/header"
    }
  },
  header: {
    type: "object",
    additionalProperties: !1,
    required: [
      "type"
    ],
    properties: {
      type: {
        type: "string",
        enum: [
          "string",
          "number",
          "integer",
          "boolean",
          "array"
        ]
      },
      format: {
        type: "string"
      },
      items: {
        $ref: "#/definitions/primitivesItems"
      },
      collectionFormat: {
        $ref: "#/definitions/collectionFormat"
      },
      default: {
        $ref: "#/definitions/default"
      },
      maximum: {
        $ref: "#/definitions/maximum"
      },
      exclusiveMaximum: {
        $ref: "#/definitions/exclusiveMaximum"
      },
      minimum: {
        $ref: "#/definitions/minimum"
      },
      exclusiveMinimum: {
        $ref: "#/definitions/exclusiveMinimum"
      },
      maxLength: {
        $ref: "#/definitions/maxLength"
      },
      minLength: {
        $ref: "#/definitions/minLength"
      },
      pattern: {
        $ref: "#/definitions/pattern"
      },
      maxItems: {
        $ref: "#/definitions/maxItems"
      },
      minItems: {
        $ref: "#/definitions/minItems"
      },
      uniqueItems: {
        $ref: "#/definitions/uniqueItems"
      },
      enum: {
        $ref: "#/definitions/enum"
      },
      multipleOf: {
        $ref: "#/definitions/multipleOf"
      },
      description: {
        type: "string"
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  vendorExtension: {
    description: "Any property starting with x- is valid.",
    additionalProperties: !0,
    additionalItems: !0
  },
  bodyParameter: {
    type: "object",
    required: [
      "name",
      "in",
      "schema"
    ],
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    },
    properties: {
      description: {
        type: "string",
        description: "A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed."
      },
      name: {
        type: "string",
        description: "The name of the parameter."
      },
      in: {
        type: "string",
        description: "Determines the location of the parameter.",
        enum: [
          "body"
        ]
      },
      required: {
        type: "boolean",
        description: "Determines whether or not this parameter is required or optional.",
        default: !1
      },
      schema: {
        $ref: "#/definitions/schema"
      }
    },
    additionalProperties: !1
  },
  headerParameterSubSchema: {
    additionalProperties: !1,
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    },
    properties: {
      required: {
        type: "boolean",
        description: "Determines whether or not this parameter is required or optional.",
        default: !1
      },
      in: {
        type: "string",
        description: "Determines the location of the parameter.",
        enum: [
          "header"
        ]
      },
      description: {
        type: "string",
        description: "A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed."
      },
      name: {
        type: "string",
        description: "The name of the parameter."
      },
      type: {
        type: "string",
        enum: [
          "string",
          "number",
          "boolean",
          "integer",
          "array"
        ]
      },
      format: {
        type: "string"
      },
      items: {
        $ref: "#/definitions/primitivesItems"
      },
      collectionFormat: {
        $ref: "#/definitions/collectionFormat"
      },
      default: {
        $ref: "#/definitions/default"
      },
      maximum: {
        $ref: "#/definitions/maximum"
      },
      exclusiveMaximum: {
        $ref: "#/definitions/exclusiveMaximum"
      },
      minimum: {
        $ref: "#/definitions/minimum"
      },
      exclusiveMinimum: {
        $ref: "#/definitions/exclusiveMinimum"
      },
      maxLength: {
        $ref: "#/definitions/maxLength"
      },
      minLength: {
        $ref: "#/definitions/minLength"
      },
      pattern: {
        $ref: "#/definitions/pattern"
      },
      maxItems: {
        $ref: "#/definitions/maxItems"
      },
      minItems: {
        $ref: "#/definitions/minItems"
      },
      uniqueItems: {
        $ref: "#/definitions/uniqueItems"
      },
      enum: {
        $ref: "#/definitions/enum"
      },
      multipleOf: {
        $ref: "#/definitions/multipleOf"
      }
    }
  },
  queryParameterSubSchema: {
    additionalProperties: !1,
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    },
    properties: {
      required: {
        type: "boolean",
        description: "Determines whether or not this parameter is required or optional.",
        default: !1
      },
      in: {
        type: "string",
        description: "Determines the location of the parameter.",
        enum: [
          "query"
        ]
      },
      description: {
        type: "string",
        description: "A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed."
      },
      name: {
        type: "string",
        description: "The name of the parameter."
      },
      allowEmptyValue: {
        type: "boolean",
        default: !1,
        description: "allows sending a parameter by name only or with an empty value."
      },
      type: {
        type: "string",
        enum: [
          "string",
          "number",
          "boolean",
          "integer",
          "array"
        ]
      },
      format: {
        type: "string"
      },
      items: {
        $ref: "#/definitions/primitivesItems"
      },
      collectionFormat: {
        $ref: "#/definitions/collectionFormatWithMulti"
      },
      default: {
        $ref: "#/definitions/default"
      },
      maximum: {
        $ref: "#/definitions/maximum"
      },
      exclusiveMaximum: {
        $ref: "#/definitions/exclusiveMaximum"
      },
      minimum: {
        $ref: "#/definitions/minimum"
      },
      exclusiveMinimum: {
        $ref: "#/definitions/exclusiveMinimum"
      },
      maxLength: {
        $ref: "#/definitions/maxLength"
      },
      minLength: {
        $ref: "#/definitions/minLength"
      },
      pattern: {
        $ref: "#/definitions/pattern"
      },
      maxItems: {
        $ref: "#/definitions/maxItems"
      },
      minItems: {
        $ref: "#/definitions/minItems"
      },
      uniqueItems: {
        $ref: "#/definitions/uniqueItems"
      },
      enum: {
        $ref: "#/definitions/enum"
      },
      multipleOf: {
        $ref: "#/definitions/multipleOf"
      }
    }
  },
  formDataParameterSubSchema: {
    additionalProperties: !1,
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    },
    properties: {
      required: {
        type: "boolean",
        description: "Determines whether or not this parameter is required or optional.",
        default: !1
      },
      in: {
        type: "string",
        description: "Determines the location of the parameter.",
        enum: [
          "formData"
        ]
      },
      description: {
        type: "string",
        description: "A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed."
      },
      name: {
        type: "string",
        description: "The name of the parameter."
      },
      allowEmptyValue: {
        type: "boolean",
        default: !1,
        description: "allows sending a parameter by name only or with an empty value."
      },
      type: {
        type: "string",
        enum: [
          "string",
          "number",
          "boolean",
          "integer",
          "array",
          "file"
        ]
      },
      format: {
        type: "string"
      },
      items: {
        $ref: "#/definitions/primitivesItems"
      },
      collectionFormat: {
        $ref: "#/definitions/collectionFormatWithMulti"
      },
      default: {
        $ref: "#/definitions/default"
      },
      maximum: {
        $ref: "#/definitions/maximum"
      },
      exclusiveMaximum: {
        $ref: "#/definitions/exclusiveMaximum"
      },
      minimum: {
        $ref: "#/definitions/minimum"
      },
      exclusiveMinimum: {
        $ref: "#/definitions/exclusiveMinimum"
      },
      maxLength: {
        $ref: "#/definitions/maxLength"
      },
      minLength: {
        $ref: "#/definitions/minLength"
      },
      pattern: {
        $ref: "#/definitions/pattern"
      },
      maxItems: {
        $ref: "#/definitions/maxItems"
      },
      minItems: {
        $ref: "#/definitions/minItems"
      },
      uniqueItems: {
        $ref: "#/definitions/uniqueItems"
      },
      enum: {
        $ref: "#/definitions/enum"
      },
      multipleOf: {
        $ref: "#/definitions/multipleOf"
      }
    }
  },
  pathParameterSubSchema: {
    additionalProperties: !1,
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    },
    required: [
      "required"
    ],
    properties: {
      required: {
        type: "boolean",
        enum: [
          !0
        ],
        description: "Determines whether or not this parameter is required or optional."
      },
      in: {
        type: "string",
        description: "Determines the location of the parameter.",
        enum: [
          "path"
        ]
      },
      description: {
        type: "string",
        description: "A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed."
      },
      name: {
        type: "string",
        description: "The name of the parameter."
      },
      type: {
        type: "string",
        enum: [
          "string",
          "number",
          "boolean",
          "integer",
          "array"
        ]
      },
      format: {
        type: "string"
      },
      items: {
        $ref: "#/definitions/primitivesItems"
      },
      collectionFormat: {
        $ref: "#/definitions/collectionFormat"
      },
      default: {
        $ref: "#/definitions/default"
      },
      maximum: {
        $ref: "#/definitions/maximum"
      },
      exclusiveMaximum: {
        $ref: "#/definitions/exclusiveMaximum"
      },
      minimum: {
        $ref: "#/definitions/minimum"
      },
      exclusiveMinimum: {
        $ref: "#/definitions/exclusiveMinimum"
      },
      maxLength: {
        $ref: "#/definitions/maxLength"
      },
      minLength: {
        $ref: "#/definitions/minLength"
      },
      pattern: {
        $ref: "#/definitions/pattern"
      },
      maxItems: {
        $ref: "#/definitions/maxItems"
      },
      minItems: {
        $ref: "#/definitions/minItems"
      },
      uniqueItems: {
        $ref: "#/definitions/uniqueItems"
      },
      enum: {
        $ref: "#/definitions/enum"
      },
      multipleOf: {
        $ref: "#/definitions/multipleOf"
      }
    }
  },
  nonBodyParameter: {
    type: "object",
    required: [
      "name",
      "in",
      "type"
    ],
    oneOf: [
      {
        $ref: "#/definitions/headerParameterSubSchema"
      },
      {
        $ref: "#/definitions/formDataParameterSubSchema"
      },
      {
        $ref: "#/definitions/queryParameterSubSchema"
      },
      {
        $ref: "#/definitions/pathParameterSubSchema"
      }
    ]
  },
  parameter: {
    oneOf: [
      {
        $ref: "#/definitions/bodyParameter"
      },
      {
        $ref: "#/definitions/nonBodyParameter"
      }
    ]
  },
  schema: {
    type: "object",
    description: "A deterministic version of a JSON Schema object.",
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    },
    properties: {
      $ref: {
        type: "string"
      },
      format: {
        type: "string"
      },
      title: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/title"
      },
      description: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/description"
      },
      default: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/default"
      },
      multipleOf: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/multipleOf"
      },
      maximum: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/maximum"
      },
      exclusiveMaximum: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/exclusiveMaximum"
      },
      minimum: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/minimum"
      },
      exclusiveMinimum: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/exclusiveMinimum"
      },
      maxLength: {
        $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveInteger"
      },
      minLength: {
        $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0"
      },
      pattern: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/pattern"
      },
      maxItems: {
        $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveInteger"
      },
      minItems: {
        $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0"
      },
      uniqueItems: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/uniqueItems"
      },
      maxProperties: {
        $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveInteger"
      },
      minProperties: {
        $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0"
      },
      required: {
        $ref: "http://json-schema.org/draft-04/schema#/definitions/stringArray"
      },
      enum: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/enum"
      },
      additionalProperties: {
        anyOf: [
          {
            $ref: "#/definitions/schema"
          },
          {
            type: "boolean"
          }
        ],
        default: {}
      },
      type: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/type"
      },
      items: {
        anyOf: [
          {
            $ref: "#/definitions/schema"
          },
          {
            type: "array",
            minItems: 1,
            items: {
              $ref: "#/definitions/schema"
            }
          }
        ],
        default: {}
      },
      allOf: {
        type: "array",
        minItems: 1,
        items: {
          $ref: "#/definitions/schema"
        }
      },
      properties: {
        type: "object",
        additionalProperties: {
          $ref: "#/definitions/schema"
        },
        default: {}
      },
      discriminator: {
        type: "string"
      },
      readOnly: {
        type: "boolean",
        default: !1
      },
      xml: {
        $ref: "#/definitions/xml"
      },
      externalDocs: {
        $ref: "#/definitions/externalDocs"
      },
      example: {}
    },
    additionalProperties: !1
  },
  fileSchema: {
    type: "object",
    description: "A deterministic version of a JSON Schema object.",
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    },
    required: [
      "type"
    ],
    properties: {
      format: {
        type: "string"
      },
      title: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/title"
      },
      description: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/description"
      },
      default: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/default"
      },
      required: {
        $ref: "http://json-schema.org/draft-04/schema#/definitions/stringArray"
      },
      type: {
        type: "string",
        enum: [
          "file"
        ]
      },
      readOnly: {
        type: "boolean",
        default: !1
      },
      externalDocs: {
        $ref: "#/definitions/externalDocs"
      },
      example: {}
    },
    additionalProperties: !1
  },
  primitivesItems: {
    type: "object",
    additionalProperties: !1,
    properties: {
      type: {
        type: "string",
        enum: [
          "string",
          "number",
          "integer",
          "boolean",
          "array"
        ]
      },
      format: {
        type: "string"
      },
      items: {
        $ref: "#/definitions/primitivesItems"
      },
      collectionFormat: {
        $ref: "#/definitions/collectionFormat"
      },
      default: {
        $ref: "#/definitions/default"
      },
      maximum: {
        $ref: "#/definitions/maximum"
      },
      exclusiveMaximum: {
        $ref: "#/definitions/exclusiveMaximum"
      },
      minimum: {
        $ref: "#/definitions/minimum"
      },
      exclusiveMinimum: {
        $ref: "#/definitions/exclusiveMinimum"
      },
      maxLength: {
        $ref: "#/definitions/maxLength"
      },
      minLength: {
        $ref: "#/definitions/minLength"
      },
      pattern: {
        $ref: "#/definitions/pattern"
      },
      maxItems: {
        $ref: "#/definitions/maxItems"
      },
      minItems: {
        $ref: "#/definitions/minItems"
      },
      uniqueItems: {
        $ref: "#/definitions/uniqueItems"
      },
      enum: {
        $ref: "#/definitions/enum"
      },
      multipleOf: {
        $ref: "#/definitions/multipleOf"
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  security: {
    type: "array",
    items: {
      $ref: "#/definitions/securityRequirement"
    },
    uniqueItems: !0
  },
  securityRequirement: {
    type: "object",
    additionalProperties: {
      type: "array",
      items: {
        type: "string"
      },
      uniqueItems: !0
    }
  },
  xml: {
    type: "object",
    additionalProperties: !1,
    properties: {
      name: {
        type: "string"
      },
      namespace: {
        type: "string"
      },
      prefix: {
        type: "string"
      },
      attribute: {
        type: "boolean",
        default: !1
      },
      wrapped: {
        type: "boolean",
        default: !1
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  tag: {
    type: "object",
    additionalProperties: !1,
    required: [
      "name"
    ],
    properties: {
      name: {
        type: "string"
      },
      description: {
        type: "string"
      },
      externalDocs: {
        $ref: "#/definitions/externalDocs"
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  securityDefinitions: {
    type: "object",
    additionalProperties: {
      oneOf: [
        {
          $ref: "#/definitions/basicAuthenticationSecurity"
        },
        {
          $ref: "#/definitions/apiKeySecurity"
        },
        {
          $ref: "#/definitions/oauth2ImplicitSecurity"
        },
        {
          $ref: "#/definitions/oauth2PasswordSecurity"
        },
        {
          $ref: "#/definitions/oauth2ApplicationSecurity"
        },
        {
          $ref: "#/definitions/oauth2AccessCodeSecurity"
        }
      ]
    }
  },
  basicAuthenticationSecurity: {
    type: "object",
    additionalProperties: !1,
    required: [
      "type"
    ],
    properties: {
      type: {
        type: "string",
        enum: [
          "basic"
        ]
      },
      description: {
        type: "string"
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  apiKeySecurity: {
    type: "object",
    additionalProperties: !1,
    required: [
      "type",
      "name",
      "in"
    ],
    properties: {
      type: {
        type: "string",
        enum: [
          "apiKey"
        ]
      },
      name: {
        type: "string"
      },
      in: {
        type: "string",
        enum: [
          "header",
          "query"
        ]
      },
      description: {
        type: "string"
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  oauth2ImplicitSecurity: {
    type: "object",
    additionalProperties: !1,
    required: [
      "type",
      "flow",
      "authorizationUrl"
    ],
    properties: {
      type: {
        type: "string",
        enum: [
          "oauth2"
        ]
      },
      flow: {
        type: "string",
        enum: [
          "implicit"
        ]
      },
      scopes: {
        $ref: "#/definitions/oauth2Scopes"
      },
      authorizationUrl: {
        type: "string",
        format: "uri"
      },
      description: {
        type: "string"
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  oauth2PasswordSecurity: {
    type: "object",
    additionalProperties: !1,
    required: [
      "type",
      "flow",
      "tokenUrl"
    ],
    properties: {
      type: {
        type: "string",
        enum: [
          "oauth2"
        ]
      },
      flow: {
        type: "string",
        enum: [
          "password"
        ]
      },
      scopes: {
        $ref: "#/definitions/oauth2Scopes"
      },
      tokenUrl: {
        type: "string",
        format: "uri"
      },
      description: {
        type: "string"
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  oauth2ApplicationSecurity: {
    type: "object",
    additionalProperties: !1,
    required: [
      "type",
      "flow",
      "tokenUrl"
    ],
    properties: {
      type: {
        type: "string",
        enum: [
          "oauth2"
        ]
      },
      flow: {
        type: "string",
        enum: [
          "application"
        ]
      },
      scopes: {
        $ref: "#/definitions/oauth2Scopes"
      },
      tokenUrl: {
        type: "string",
        format: "uri"
      },
      description: {
        type: "string"
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  oauth2AccessCodeSecurity: {
    type: "object",
    additionalProperties: !1,
    required: [
      "type",
      "flow",
      "authorizationUrl",
      "tokenUrl"
    ],
    properties: {
      type: {
        type: "string",
        enum: [
          "oauth2"
        ]
      },
      flow: {
        type: "string",
        enum: [
          "accessCode"
        ]
      },
      scopes: {
        $ref: "#/definitions/oauth2Scopes"
      },
      authorizationUrl: {
        type: "string",
        format: "uri"
      },
      tokenUrl: {
        type: "string",
        format: "uri"
      },
      description: {
        type: "string"
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  oauth2Scopes: {
    type: "object",
    additionalProperties: {
      type: "string"
    }
  },
  mediaTypeList: {
    type: "array",
    items: {
      $ref: "#/definitions/mimeType"
    },
    uniqueItems: !0
  },
  parametersList: {
    type: "array",
    description: "The parameters needed to send a valid API call.",
    additionalItems: !1,
    items: {
      oneOf: [
        {
          $ref: "#/definitions/parameter"
        },
        {
          $ref: "#/definitions/jsonReference"
        }
      ]
    },
    uniqueItems: !0
  },
  schemesList: {
    type: "array",
    description: "The transfer protocol of the API.",
    items: {
      type: "string",
      enum: [
        "http",
        "https",
        "ws",
        "wss"
      ]
    },
    uniqueItems: !0
  },
  collectionFormat: {
    type: "string",
    enum: [
      "csv",
      "ssv",
      "tsv",
      "pipes"
    ],
    default: "csv"
  },
  collectionFormatWithMulti: {
    type: "string",
    enum: [
      "csv",
      "ssv",
      "tsv",
      "pipes",
      "multi"
    ],
    default: "csv"
  },
  title: {
    $ref: "http://json-schema.org/draft-04/schema#/properties/title"
  },
  description: {
    $ref: "http://json-schema.org/draft-04/schema#/properties/description"
  },
  default: {
    $ref: "http://json-schema.org/draft-04/schema#/properties/default"
  },
  multipleOf: {
    $ref: "http://json-schema.org/draft-04/schema#/properties/multipleOf"
  },
  maximum: {
    $ref: "http://json-schema.org/draft-04/schema#/properties/maximum"
  },
  exclusiveMaximum: {
    $ref: "http://json-schema.org/draft-04/schema#/properties/exclusiveMaximum"
  },
  minimum: {
    $ref: "http://json-schema.org/draft-04/schema#/properties/minimum"
  },
  exclusiveMinimum: {
    $ref: "http://json-schema.org/draft-04/schema#/properties/exclusiveMinimum"
  },
  maxLength: {
    $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveInteger"
  },
  minLength: {
    $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0"
  },
  pattern: {
    $ref: "http://json-schema.org/draft-04/schema#/properties/pattern"
  },
  maxItems: {
    $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveInteger"
  },
  minItems: {
    $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0"
  },
  uniqueItems: {
    $ref: "http://json-schema.org/draft-04/schema#/properties/uniqueItems"
  },
  enum: {
    $ref: "http://json-schema.org/draft-04/schema#/properties/enum"
  },
  jsonReference: {
    type: "object",
    required: [
      "$ref"
    ],
    additionalProperties: !1,
    properties: {
      $ref: {
        type: "string"
      }
    }
  }
}, aq = {
  title: J4,
  id: X4,
  $schema: Q4,
  type: eq,
  required: tq,
  additionalProperties: rq,
  patternProperties: nq,
  properties: iq,
  definitions: sq
}, oq = "https://spec.openapis.org/oas/3.0/schema/2019-04-02", uq = "http://json-schema.org/draft-04/schema#", cq = "Validation schema for OpenAPI Specification 3.0.X.", lq = "object", fq = [
  "openapi",
  "info",
  "paths"
], dq = {
  openapi: {
    type: "string",
    pattern: "^3\\.0\\.\\d(-.+)?$"
  },
  info: {
    $ref: "#/definitions/Info"
  },
  externalDocs: {
    $ref: "#/definitions/ExternalDocumentation"
  },
  servers: {
    type: "array",
    items: {
      $ref: "#/definitions/Server"
    }
  },
  security: {
    type: "array",
    items: {
      $ref: "#/definitions/SecurityRequirement"
    }
  },
  tags: {
    type: "array",
    items: {
      $ref: "#/definitions/Tag"
    },
    uniqueItems: !0
  },
  paths: {
    $ref: "#/definitions/Paths"
  },
  components: {
    $ref: "#/definitions/Components"
  }
}, pq = {
  "^x-": {}
}, hq = !1, mq = {
  Reference: {
    type: "object",
    required: [
      "$ref"
    ],
    patternProperties: {
      "^\\$ref$": {
        type: "string",
        format: "uri-reference"
      }
    }
  },
  Info: {
    type: "object",
    required: [
      "title",
      "version"
    ],
    properties: {
      title: {
        type: "string"
      },
      description: {
        type: "string"
      },
      termsOfService: {
        type: "string",
        format: "uri-reference"
      },
      contact: {
        $ref: "#/definitions/Contact"
      },
      license: {
        $ref: "#/definitions/License"
      },
      version: {
        type: "string"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  Contact: {
    type: "object",
    properties: {
      name: {
        type: "string"
      },
      url: {
        type: "string",
        format: "uri-reference"
      },
      email: {
        type: "string",
        format: "email"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  License: {
    type: "object",
    required: [
      "name"
    ],
    properties: {
      name: {
        type: "string"
      },
      url: {
        type: "string",
        format: "uri-reference"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  Server: {
    type: "object",
    required: [
      "url"
    ],
    properties: {
      url: {
        type: "string"
      },
      description: {
        type: "string"
      },
      variables: {
        type: "object",
        additionalProperties: {
          $ref: "#/definitions/ServerVariable"
        }
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  ServerVariable: {
    type: "object",
    required: [
      "default"
    ],
    properties: {
      enum: {
        type: "array",
        items: {
          type: "string"
        }
      },
      default: {
        type: "string"
      },
      description: {
        type: "string"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  Components: {
    type: "object",
    properties: {
      schemas: {
        type: "object",
        patternProperties: {
          "^[a-zA-Z0-9\\.\\-_]+$": {
            oneOf: [
              {
                $ref: "#/definitions/Schema"
              },
              {
                $ref: "#/definitions/Reference"
              }
            ]
          }
        }
      },
      responses: {
        type: "object",
        patternProperties: {
          "^[a-zA-Z0-9\\.\\-_]+$": {
            oneOf: [
              {
                $ref: "#/definitions/Reference"
              },
              {
                $ref: "#/definitions/Response"
              }
            ]
          }
        }
      },
      parameters: {
        type: "object",
        patternProperties: {
          "^[a-zA-Z0-9\\.\\-_]+$": {
            oneOf: [
              {
                $ref: "#/definitions/Reference"
              },
              {
                $ref: "#/definitions/Parameter"
              }
            ]
          }
        }
      },
      examples: {
        type: "object",
        patternProperties: {
          "^[a-zA-Z0-9\\.\\-_]+$": {
            oneOf: [
              {
                $ref: "#/definitions/Reference"
              },
              {
                $ref: "#/definitions/Example"
              }
            ]
          }
        }
      },
      requestBodies: {
        type: "object",
        patternProperties: {
          "^[a-zA-Z0-9\\.\\-_]+$": {
            oneOf: [
              {
                $ref: "#/definitions/Reference"
              },
              {
                $ref: "#/definitions/RequestBody"
              }
            ]
          }
        }
      },
      headers: {
        type: "object",
        patternProperties: {
          "^[a-zA-Z0-9\\.\\-_]+$": {
            oneOf: [
              {
                $ref: "#/definitions/Reference"
              },
              {
                $ref: "#/definitions/Header"
              }
            ]
          }
        }
      },
      securitySchemes: {
        type: "object",
        patternProperties: {
          "^[a-zA-Z0-9\\.\\-_]+$": {
            oneOf: [
              {
                $ref: "#/definitions/Reference"
              },
              {
                $ref: "#/definitions/SecurityScheme"
              }
            ]
          }
        }
      },
      links: {
        type: "object",
        patternProperties: {
          "^[a-zA-Z0-9\\.\\-_]+$": {
            oneOf: [
              {
                $ref: "#/definitions/Reference"
              },
              {
                $ref: "#/definitions/Link"
              }
            ]
          }
        }
      },
      callbacks: {
        type: "object",
        patternProperties: {
          "^[a-zA-Z0-9\\.\\-_]+$": {
            oneOf: [
              {
                $ref: "#/definitions/Reference"
              },
              {
                $ref: "#/definitions/Callback"
              }
            ]
          }
        }
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  Schema: {
    type: "object",
    properties: {
      title: {
        type: "string"
      },
      multipleOf: {
        type: "number",
        minimum: 0,
        exclusiveMinimum: !0
      },
      maximum: {
        type: "number"
      },
      exclusiveMaximum: {
        type: "boolean",
        default: !1
      },
      minimum: {
        type: "number"
      },
      exclusiveMinimum: {
        type: "boolean",
        default: !1
      },
      maxLength: {
        type: "integer",
        minimum: 0
      },
      minLength: {
        type: "integer",
        minimum: 0,
        default: 0
      },
      pattern: {
        type: "string",
        format: "regex"
      },
      maxItems: {
        type: "integer",
        minimum: 0
      },
      minItems: {
        type: "integer",
        minimum: 0,
        default: 0
      },
      uniqueItems: {
        type: "boolean",
        default: !1
      },
      maxProperties: {
        type: "integer",
        minimum: 0
      },
      minProperties: {
        type: "integer",
        minimum: 0,
        default: 0
      },
      required: {
        type: "array",
        items: {
          type: "string"
        },
        minItems: 1,
        uniqueItems: !0
      },
      enum: {
        type: "array",
        items: {},
        minItems: 1,
        uniqueItems: !1
      },
      type: {
        type: "string",
        enum: [
          "array",
          "boolean",
          "integer",
          "number",
          "object",
          "string"
        ]
      },
      not: {
        oneOf: [
          {
            $ref: "#/definitions/Schema"
          },
          {
            $ref: "#/definitions/Reference"
          }
        ]
      },
      allOf: {
        type: "array",
        items: {
          oneOf: [
            {
              $ref: "#/definitions/Schema"
            },
            {
              $ref: "#/definitions/Reference"
            }
          ]
        }
      },
      oneOf: {
        type: "array",
        items: {
          oneOf: [
            {
              $ref: "#/definitions/Schema"
            },
            {
              $ref: "#/definitions/Reference"
            }
          ]
        }
      },
      anyOf: {
        type: "array",
        items: {
          oneOf: [
            {
              $ref: "#/definitions/Schema"
            },
            {
              $ref: "#/definitions/Reference"
            }
          ]
        }
      },
      items: {
        oneOf: [
          {
            $ref: "#/definitions/Schema"
          },
          {
            $ref: "#/definitions/Reference"
          }
        ]
      },
      properties: {
        type: "object",
        additionalProperties: {
          oneOf: [
            {
              $ref: "#/definitions/Schema"
            },
            {
              $ref: "#/definitions/Reference"
            }
          ]
        }
      },
      additionalProperties: {
        oneOf: [
          {
            $ref: "#/definitions/Schema"
          },
          {
            $ref: "#/definitions/Reference"
          },
          {
            type: "boolean"
          }
        ],
        default: !0
      },
      description: {
        type: "string"
      },
      format: {
        type: "string"
      },
      default: {},
      nullable: {
        type: "boolean",
        default: !1
      },
      discriminator: {
        $ref: "#/definitions/Discriminator"
      },
      readOnly: {
        type: "boolean",
        default: !1
      },
      writeOnly: {
        type: "boolean",
        default: !1
      },
      example: {},
      externalDocs: {
        $ref: "#/definitions/ExternalDocumentation"
      },
      deprecated: {
        type: "boolean",
        default: !1
      },
      xml: {
        $ref: "#/definitions/XML"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  Discriminator: {
    type: "object",
    required: [
      "propertyName"
    ],
    properties: {
      propertyName: {
        type: "string"
      },
      mapping: {
        type: "object",
        additionalProperties: {
          type: "string"
        }
      }
    }
  },
  XML: {
    type: "object",
    properties: {
      name: {
        type: "string"
      },
      namespace: {
        type: "string",
        format: "uri"
      },
      prefix: {
        type: "string"
      },
      attribute: {
        type: "boolean",
        default: !1
      },
      wrapped: {
        type: "boolean",
        default: !1
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  Response: {
    type: "object",
    required: [
      "description"
    ],
    properties: {
      description: {
        type: "string"
      },
      headers: {
        type: "object",
        additionalProperties: {
          oneOf: [
            {
              $ref: "#/definitions/Header"
            },
            {
              $ref: "#/definitions/Reference"
            }
          ]
        }
      },
      content: {
        type: "object",
        additionalProperties: {
          $ref: "#/definitions/MediaType"
        }
      },
      links: {
        type: "object",
        additionalProperties: {
          oneOf: [
            {
              $ref: "#/definitions/Link"
            },
            {
              $ref: "#/definitions/Reference"
            }
          ]
        }
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  MediaType: {
    type: "object",
    properties: {
      schema: {
        oneOf: [
          {
            $ref: "#/definitions/Schema"
          },
          {
            $ref: "#/definitions/Reference"
          }
        ]
      },
      example: {},
      examples: {
        type: "object",
        additionalProperties: {
          oneOf: [
            {
              $ref: "#/definitions/Example"
            },
            {
              $ref: "#/definitions/Reference"
            }
          ]
        }
      },
      encoding: {
        type: "object",
        additionalProperties: {
          $ref: "#/definitions/Encoding"
        }
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1,
    allOf: [
      {
        $ref: "#/definitions/ExampleXORExamples"
      }
    ]
  },
  Example: {
    type: "object",
    properties: {
      summary: {
        type: "string"
      },
      description: {
        type: "string"
      },
      value: {},
      externalValue: {
        type: "string",
        format: "uri-reference"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  Header: {
    type: "object",
    properties: {
      description: {
        type: "string"
      },
      required: {
        type: "boolean",
        default: !1
      },
      deprecated: {
        type: "boolean",
        default: !1
      },
      allowEmptyValue: {
        type: "boolean",
        default: !1
      },
      style: {
        type: "string",
        enum: [
          "simple"
        ],
        default: "simple"
      },
      explode: {
        type: "boolean"
      },
      allowReserved: {
        type: "boolean",
        default: !1
      },
      schema: {
        oneOf: [
          {
            $ref: "#/definitions/Schema"
          },
          {
            $ref: "#/definitions/Reference"
          }
        ]
      },
      content: {
        type: "object",
        additionalProperties: {
          $ref: "#/definitions/MediaType"
        },
        minProperties: 1,
        maxProperties: 1
      },
      example: {},
      examples: {
        type: "object",
        additionalProperties: {
          oneOf: [
            {
              $ref: "#/definitions/Example"
            },
            {
              $ref: "#/definitions/Reference"
            }
          ]
        }
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1,
    allOf: [
      {
        $ref: "#/definitions/ExampleXORExamples"
      },
      {
        $ref: "#/definitions/SchemaXORContent"
      }
    ]
  },
  Paths: {
    type: "object",
    patternProperties: {
      "^\\/": {
        $ref: "#/definitions/PathItem"
      },
      "^x-": {}
    },
    additionalProperties: !1
  },
  PathItem: {
    type: "object",
    properties: {
      $ref: {
        type: "string"
      },
      summary: {
        type: "string"
      },
      description: {
        type: "string"
      },
      servers: {
        type: "array",
        items: {
          $ref: "#/definitions/Server"
        }
      },
      parameters: {
        type: "array",
        items: {
          oneOf: [
            {
              $ref: "#/definitions/Parameter"
            },
            {
              $ref: "#/definitions/Reference"
            }
          ]
        },
        uniqueItems: !0
      }
    },
    patternProperties: {
      "^(get|put|post|delete|options|head|patch|trace)$": {
        $ref: "#/definitions/Operation"
      },
      "^x-": {}
    },
    additionalProperties: !1
  },
  Operation: {
    type: "object",
    required: [
      "responses"
    ],
    properties: {
      tags: {
        type: "array",
        items: {
          type: "string"
        }
      },
      summary: {
        type: "string"
      },
      description: {
        type: "string"
      },
      externalDocs: {
        $ref: "#/definitions/ExternalDocumentation"
      },
      operationId: {
        type: "string"
      },
      parameters: {
        type: "array",
        items: {
          oneOf: [
            {
              $ref: "#/definitions/Parameter"
            },
            {
              $ref: "#/definitions/Reference"
            }
          ]
        },
        uniqueItems: !0
      },
      requestBody: {
        oneOf: [
          {
            $ref: "#/definitions/RequestBody"
          },
          {
            $ref: "#/definitions/Reference"
          }
        ]
      },
      responses: {
        $ref: "#/definitions/Responses"
      },
      callbacks: {
        type: "object",
        additionalProperties: {
          oneOf: [
            {
              $ref: "#/definitions/Callback"
            },
            {
              $ref: "#/definitions/Reference"
            }
          ]
        }
      },
      deprecated: {
        type: "boolean",
        default: !1
      },
      security: {
        type: "array",
        items: {
          $ref: "#/definitions/SecurityRequirement"
        }
      },
      servers: {
        type: "array",
        items: {
          $ref: "#/definitions/Server"
        }
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  Responses: {
    type: "object",
    properties: {
      default: {
        oneOf: [
          {
            $ref: "#/definitions/Response"
          },
          {
            $ref: "#/definitions/Reference"
          }
        ]
      }
    },
    patternProperties: {
      "^[1-5](?:\\d{2}|XX)$": {
        oneOf: [
          {
            $ref: "#/definitions/Response"
          },
          {
            $ref: "#/definitions/Reference"
          }
        ]
      },
      "^x-": {}
    },
    minProperties: 1,
    additionalProperties: !1
  },
  SecurityRequirement: {
    type: "object",
    additionalProperties: {
      type: "array",
      items: {
        type: "string"
      }
    }
  },
  Tag: {
    type: "object",
    required: [
      "name"
    ],
    properties: {
      name: {
        type: "string"
      },
      description: {
        type: "string"
      },
      externalDocs: {
        $ref: "#/definitions/ExternalDocumentation"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  ExternalDocumentation: {
    type: "object",
    required: [
      "url"
    ],
    properties: {
      description: {
        type: "string"
      },
      url: {
        type: "string",
        format: "uri-reference"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  ExampleXORExamples: {
    description: "Example and examples are mutually exclusive",
    not: {
      required: [
        "example",
        "examples"
      ]
    }
  },
  SchemaXORContent: {
    description: "Schema and content are mutually exclusive, at least one is required",
    not: {
      required: [
        "schema",
        "content"
      ]
    },
    oneOf: [
      {
        required: [
          "schema"
        ]
      },
      {
        required: [
          "content"
        ],
        description: "Some properties are not allowed if content is present",
        allOf: [
          {
            not: {
              required: [
                "style"
              ]
            }
          },
          {
            not: {
              required: [
                "explode"
              ]
            }
          },
          {
            not: {
              required: [
                "allowReserved"
              ]
            }
          },
          {
            not: {
              required: [
                "example"
              ]
            }
          },
          {
            not: {
              required: [
                "examples"
              ]
            }
          }
        ]
      }
    ]
  },
  Parameter: {
    type: "object",
    properties: {
      name: {
        type: "string"
      },
      in: {
        type: "string"
      },
      description: {
        type: "string"
      },
      required: {
        type: "boolean",
        default: !1
      },
      deprecated: {
        type: "boolean",
        default: !1
      },
      allowEmptyValue: {
        type: "boolean",
        default: !1
      },
      style: {
        type: "string"
      },
      explode: {
        type: "boolean"
      },
      allowReserved: {
        type: "boolean",
        default: !1
      },
      schema: {
        oneOf: [
          {
            $ref: "#/definitions/Schema"
          },
          {
            $ref: "#/definitions/Reference"
          }
        ]
      },
      content: {
        type: "object",
        additionalProperties: {
          $ref: "#/definitions/MediaType"
        },
        minProperties: 1,
        maxProperties: 1
      },
      example: {},
      examples: {
        type: "object",
        additionalProperties: {
          oneOf: [
            {
              $ref: "#/definitions/Example"
            },
            {
              $ref: "#/definitions/Reference"
            }
          ]
        }
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1,
    required: [
      "name",
      "in"
    ],
    allOf: [
      {
        $ref: "#/definitions/ExampleXORExamples"
      },
      {
        $ref: "#/definitions/SchemaXORContent"
      },
      {
        $ref: "#/definitions/ParameterLocation"
      }
    ]
  },
  ParameterLocation: {
    description: "Parameter location",
    oneOf: [
      {
        description: "Parameter in path",
        required: [
          "required"
        ],
        properties: {
          in: {
            enum: [
              "path"
            ]
          },
          style: {
            enum: [
              "matrix",
              "label",
              "simple"
            ],
            default: "simple"
          },
          required: {
            enum: [
              !0
            ]
          }
        }
      },
      {
        description: "Parameter in query",
        properties: {
          in: {
            enum: [
              "query"
            ]
          },
          style: {
            enum: [
              "form",
              "spaceDelimited",
              "pipeDelimited",
              "deepObject"
            ],
            default: "form"
          }
        }
      },
      {
        description: "Parameter in header",
        properties: {
          in: {
            enum: [
              "header"
            ]
          },
          style: {
            enum: [
              "simple"
            ],
            default: "simple"
          }
        }
      },
      {
        description: "Parameter in cookie",
        properties: {
          in: {
            enum: [
              "cookie"
            ]
          },
          style: {
            enum: [
              "form"
            ],
            default: "form"
          }
        }
      }
    ]
  },
  RequestBody: {
    type: "object",
    required: [
      "content"
    ],
    properties: {
      description: {
        type: "string"
      },
      content: {
        type: "object",
        additionalProperties: {
          $ref: "#/definitions/MediaType"
        }
      },
      required: {
        type: "boolean",
        default: !1
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  SecurityScheme: {
    oneOf: [
      {
        $ref: "#/definitions/APIKeySecurityScheme"
      },
      {
        $ref: "#/definitions/HTTPSecurityScheme"
      },
      {
        $ref: "#/definitions/OAuth2SecurityScheme"
      },
      {
        $ref: "#/definitions/OpenIdConnectSecurityScheme"
      }
    ]
  },
  APIKeySecurityScheme: {
    type: "object",
    required: [
      "type",
      "name",
      "in"
    ],
    properties: {
      type: {
        type: "string",
        enum: [
          "apiKey"
        ]
      },
      name: {
        type: "string"
      },
      in: {
        type: "string",
        enum: [
          "header",
          "query",
          "cookie"
        ]
      },
      description: {
        type: "string"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  HTTPSecurityScheme: {
    type: "object",
    required: [
      "scheme",
      "type"
    ],
    properties: {
      scheme: {
        type: "string"
      },
      bearerFormat: {
        type: "string"
      },
      description: {
        type: "string"
      },
      type: {
        type: "string",
        enum: [
          "http"
        ]
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1,
    oneOf: [
      {
        description: "Bearer",
        properties: {
          scheme: {
            enum: [
              "bearer"
            ]
          }
        }
      },
      {
        description: "Non Bearer",
        not: {
          required: [
            "bearerFormat"
          ]
        },
        properties: {
          scheme: {
            not: {
              enum: [
                "bearer"
              ]
            }
          }
        }
      }
    ]
  },
  OAuth2SecurityScheme: {
    type: "object",
    required: [
      "type",
      "flows"
    ],
    properties: {
      type: {
        type: "string",
        enum: [
          "oauth2"
        ]
      },
      flows: {
        $ref: "#/definitions/OAuthFlows"
      },
      description: {
        type: "string"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  OpenIdConnectSecurityScheme: {
    type: "object",
    required: [
      "type",
      "openIdConnectUrl"
    ],
    properties: {
      type: {
        type: "string",
        enum: [
          "openIdConnect"
        ]
      },
      openIdConnectUrl: {
        type: "string",
        format: "uri-reference"
      },
      description: {
        type: "string"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  OAuthFlows: {
    type: "object",
    properties: {
      implicit: {
        $ref: "#/definitions/ImplicitOAuthFlow"
      },
      password: {
        $ref: "#/definitions/PasswordOAuthFlow"
      },
      clientCredentials: {
        $ref: "#/definitions/ClientCredentialsFlow"
      },
      authorizationCode: {
        $ref: "#/definitions/AuthorizationCodeOAuthFlow"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  ImplicitOAuthFlow: {
    type: "object",
    required: [
      "authorizationUrl",
      "scopes"
    ],
    properties: {
      authorizationUrl: {
        type: "string",
        format: "uri-reference"
      },
      refreshUrl: {
        type: "string",
        format: "uri-reference"
      },
      scopes: {
        type: "object",
        additionalProperties: {
          type: "string"
        }
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  PasswordOAuthFlow: {
    type: "object",
    required: [
      "tokenUrl"
    ],
    properties: {
      tokenUrl: {
        type: "string",
        format: "uri-reference"
      },
      refreshUrl: {
        type: "string",
        format: "uri-reference"
      },
      scopes: {
        type: "object",
        additionalProperties: {
          type: "string"
        }
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  ClientCredentialsFlow: {
    type: "object",
    required: [
      "tokenUrl"
    ],
    properties: {
      tokenUrl: {
        type: "string",
        format: "uri-reference"
      },
      refreshUrl: {
        type: "string",
        format: "uri-reference"
      },
      scopes: {
        type: "object",
        additionalProperties: {
          type: "string"
        }
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  AuthorizationCodeOAuthFlow: {
    type: "object",
    required: [
      "authorizationUrl",
      "tokenUrl"
    ],
    properties: {
      authorizationUrl: {
        type: "string",
        format: "uri-reference"
      },
      tokenUrl: {
        type: "string",
        format: "uri-reference"
      },
      refreshUrl: {
        type: "string",
        format: "uri-reference"
      },
      scopes: {
        type: "object",
        additionalProperties: {
          type: "string"
        }
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  Link: {
    type: "object",
    properties: {
      operationId: {
        type: "string"
      },
      operationRef: {
        type: "string",
        format: "uri-reference"
      },
      parameters: {
        type: "object",
        additionalProperties: {}
      },
      requestBody: {},
      description: {
        type: "string"
      },
      server: {
        $ref: "#/definitions/Server"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1,
    not: {
      description: "Operation Id and Operation Ref are mutually exclusive",
      required: [
        "operationId",
        "operationRef"
      ]
    }
  },
  Callback: {
    type: "object",
    additionalProperties: {
      $ref: "#/definitions/PathItem"
    },
    patternProperties: {
      "^x-": {}
    }
  },
  Encoding: {
    type: "object",
    properties: {
      contentType: {
        type: "string"
      },
      headers: {
        type: "object",
        additionalProperties: {
          $ref: "#/definitions/Header"
        }
      },
      style: {
        type: "string",
        enum: [
          "form",
          "spaceDelimited",
          "pipeDelimited",
          "deepObject"
        ]
      },
      explode: {
        type: "boolean"
      },
      allowReserved: {
        type: "boolean",
        default: !1
      }
    },
    additionalProperties: !1
  }
}, yq = {
  id: oq,
  $schema: uq,
  description: cq,
  type: lq,
  required: fq,
  properties: dq,
  patternProperties: pq,
  additionalProperties: hq,
  definitions: mq
}, gq = "https://spec.openapis.org/oas/3.1/schema/2021-04-15", vq = "https://json-schema.org/draft/2020-12/schema", bq = "object", _q = {
  openapi: {
    type: "string",
    pattern: "^3\\.1\\.\\d+(-.+)?$"
  },
  info: {
    $ref: "#/$defs/info"
  },
  jsonSchemaDialect: {
    $ref: "#/$defs/uri",
    default: "https://spec.openapis.org/oas/3.1/dialect/base"
  },
  servers: {
    type: "array",
    items: {
      $ref: "#/$defs/server"
    }
  },
  paths: {
    $ref: "#/$defs/paths"
  },
  webhooks: {
    type: "object",
    additionalProperties: {
      $ref: "#/$defs/path-item-or-reference"
    }
  },
  components: {
    $ref: "#/$defs/components"
  },
  security: {
    type: "array",
    items: {
      $ref: "#/$defs/security-requirement"
    }
  },
  tags: {
    type: "array",
    items: {
      $ref: "#/$defs/tag"
    }
  },
  externalDocs: {
    $ref: "#/$defs/external-documentation"
  }
}, wq = [
  "openapi",
  "info"
], $q = [
  {
    required: [
      "paths"
    ]
  },
  {
    required: [
      "components"
    ]
  },
  {
    required: [
      "webhooks"
    ]
  }
], Eq = "#/$defs/specification-extensions", xq = !1, Oq = {
  info: {
    type: "object",
    properties: {
      title: {
        type: "string"
      },
      summary: {
        type: "string"
      },
      description: {
        type: "string"
      },
      termsOfService: {
        type: "string"
      },
      contact: {
        $ref: "#/$defs/contact"
      },
      license: {
        $ref: "#/$defs/license"
      },
      version: {
        type: "string"
      }
    },
    required: [
      "title",
      "version"
    ],
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  contact: {
    type: "object",
    properties: {
      name: {
        type: "string"
      },
      url: {
        type: "string"
      },
      email: {
        type: "string"
      }
    },
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  license: {
    type: "object",
    properties: {
      name: {
        type: "string"
      },
      identifier: {
        type: "string"
      },
      url: {
        $ref: "#/$defs/uri"
      }
    },
    required: [
      "name"
    ],
    oneOf: [
      {
        required: [
          "identifier"
        ]
      },
      {
        required: [
          "url"
        ]
      }
    ],
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  server: {
    type: "object",
    properties: {
      url: {
        $ref: "#/$defs/uri"
      },
      description: {
        type: "string"
      },
      variables: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/server-variable"
        }
      }
    },
    required: [
      "url"
    ],
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  "server-variable": {
    type: "object",
    properties: {
      enum: {
        type: "array",
        items: {
          type: "string"
        },
        minItems: 1
      },
      default: {
        type: "string"
      },
      descriptions: {
        type: "string"
      }
    },
    required: [
      "default"
    ],
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  components: {
    type: "object",
    properties: {
      schemas: {
        type: "object",
        additionalProperties: {
          $dynamicRef: "#meta"
        }
      },
      responses: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/response-or-reference"
        }
      },
      parameters: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/parameter-or-reference"
        }
      },
      examples: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/example-or-reference"
        }
      },
      requestBodies: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/request-body-or-reference"
        }
      },
      headers: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/header-or-reference"
        }
      },
      securitySchemes: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/security-scheme-or-reference"
        }
      },
      links: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/link-or-reference"
        }
      },
      callbacks: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/callbacks-or-reference"
        }
      },
      pathItems: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/path-item-or-reference"
        }
      }
    },
    patternProperties: {
      "^(schemas|responses|parameters|examples|requestBodies|headers|securitySchemes|links|callbacks|pathItems)$": {
        $comment: "Enumerating all of the property names in the regex above is necessary for unevaluatedProperties to work as expected",
        propertyNames: {
          pattern: "^[a-zA-Z0-9._-]+$"
        }
      }
    },
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  paths: {
    type: "object",
    patternProperties: {
      "^/": {
        $ref: "#/$defs/path-item"
      }
    },
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  "path-item": {
    type: "object",
    properties: {
      summary: {
        type: "string"
      },
      description: {
        type: "string"
      },
      servers: {
        type: "array",
        items: {
          $ref: "#/$defs/server"
        }
      },
      parameters: {
        type: "array",
        items: {
          $ref: "#/$defs/parameter-or-reference"
        }
      }
    },
    patternProperties: {
      "^(get|put|post|delete|options|head|patch|trace)$": {
        $ref: "#/$defs/operation"
      }
    },
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  "path-item-or-reference": {
    if: {
      required: [
        "$ref"
      ]
    },
    then: {
      $ref: "#/$defs/reference"
    },
    else: {
      $ref: "#/$defs/path-item"
    }
  },
  operation: {
    type: "object",
    properties: {
      tags: {
        type: "array",
        items: {
          type: "string"
        }
      },
      summary: {
        type: "string"
      },
      description: {
        type: "string"
      },
      externalDocs: {
        $ref: "#/$defs/external-documentation"
      },
      operationId: {
        type: "string"
      },
      parameters: {
        type: "array",
        items: {
          $ref: "#/$defs/parameter-or-reference"
        }
      },
      requestBody: {
        $ref: "#/$defs/request-body-or-reference"
      },
      responses: {
        $ref: "#/$defs/responses"
      },
      callbacks: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/callbacks-or-reference"
        }
      },
      deprecated: {
        default: !1,
        type: "boolean"
      },
      security: {
        type: "array",
        items: {
          $ref: "#/$defs/security-requirement"
        }
      },
      servers: {
        type: "array",
        items: {
          $ref: "#/$defs/server"
        }
      }
    },
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  "external-documentation": {
    type: "object",
    properties: {
      description: {
        type: "string"
      },
      url: {
        $ref: "#/$defs/uri"
      }
    },
    required: [
      "url"
    ],
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  parameter: {
    type: "object",
    properties: {
      name: {
        type: "string"
      },
      in: {
        enum: [
          "query",
          "header",
          "path",
          "cookie"
        ]
      },
      description: {
        type: "string"
      },
      required: {
        default: !1,
        type: "boolean"
      },
      deprecated: {
        default: !1,
        type: "boolean"
      },
      allowEmptyValue: {
        default: !1,
        type: "boolean"
      },
      schema: {
        $dynamicRef: "#meta"
      },
      content: {
        $ref: "#/$defs/content"
      }
    },
    required: [
      "in"
    ],
    oneOf: [
      {
        required: [
          "schema"
        ]
      },
      {
        required: [
          "content"
        ]
      }
    ],
    dependentSchemas: {
      schema: {
        properties: {
          style: {
            type: "string"
          },
          explode: {
            type: "boolean"
          },
          allowReserved: {
            default: !1,
            type: "boolean"
          }
        },
        allOf: [
          {
            $ref: "#/$defs/examples"
          },
          {
            $ref: "#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-path"
          },
          {
            $ref: "#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-header"
          },
          {
            $ref: "#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-query"
          },
          {
            $ref: "#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-cookie"
          },
          {
            $ref: "#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-form"
          }
        ],
        $defs: {
          "styles-for-path": {
            if: {
              properties: {
                in: {
                  const: "path"
                }
              },
              required: [
                "in"
              ]
            },
            then: {
              properties: {
                style: {
                  default: "simple",
                  enum: [
                    "matrix",
                    "label",
                    "simple"
                  ]
                },
                required: {
                  const: !0
                }
              },
              required: [
                "required"
              ]
            }
          },
          "styles-for-header": {
            if: {
              properties: {
                in: {
                  const: "header"
                }
              },
              required: [
                "in"
              ]
            },
            then: {
              properties: {
                style: {
                  default: "simple",
                  enum: [
                    "simple"
                  ]
                }
              }
            }
          },
          "styles-for-query": {
            if: {
              properties: {
                in: {
                  const: "query"
                }
              },
              required: [
                "in"
              ]
            },
            then: {
              properties: {
                style: {
                  default: "form",
                  enum: [
                    "form",
                    "spaceDelimited",
                    "pipeDelimited",
                    "deepObject"
                  ]
                }
              }
            }
          },
          "styles-for-cookie": {
            if: {
              properties: {
                in: {
                  const: "cookie"
                }
              },
              required: [
                "in"
              ]
            },
            then: {
              properties: {
                style: {
                  default: "form",
                  enum: [
                    "form"
                  ]
                }
              }
            }
          },
          "styles-for-form": {
            if: {
              properties: {
                style: {
                  const: "form"
                }
              },
              required: [
                "style"
              ]
            },
            then: {
              properties: {
                explode: {
                  default: !0
                }
              }
            },
            else: {
              properties: {
                explode: {
                  default: !1
                }
              }
            }
          }
        }
      }
    },
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  "parameter-or-reference": {
    if: {
      required: [
        "$ref"
      ]
    },
    then: {
      $ref: "#/$defs/reference"
    },
    else: {
      $ref: "#/$defs/parameter"
    }
  },
  "request-body": {
    type: "object",
    properties: {
      description: {
        type: "string"
      },
      content: {
        $ref: "#/$defs/content"
      },
      required: {
        default: !1,
        type: "boolean"
      }
    },
    required: [
      "content"
    ],
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  "request-body-or-reference": {
    if: {
      required: [
        "$ref"
      ]
    },
    then: {
      $ref: "#/$defs/reference"
    },
    else: {
      $ref: "#/$defs/request-body"
    }
  },
  content: {
    type: "object",
    additionalProperties: {
      $ref: "#/$defs/media-type"
    },
    propertyNames: {
      format: "media-range"
    }
  },
  "media-type": {
    type: "object",
    properties: {
      schema: {
        $dynamicRef: "#meta"
      },
      encoding: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/encoding"
        }
      }
    },
    allOf: [
      {
        $ref: "#/$defs/specification-extensions"
      },
      {
        $ref: "#/$defs/examples"
      }
    ],
    unevaluatedProperties: !1
  },
  encoding: {
    type: "object",
    properties: {
      contentType: {
        type: "string",
        format: "media-range"
      },
      headers: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/header-or-reference"
        }
      },
      style: {
        default: "form",
        enum: [
          "form",
          "spaceDelimited",
          "pipeDelimited",
          "deepObject"
        ]
      },
      explode: {
        type: "boolean"
      },
      allowReserved: {
        default: !1,
        type: "boolean"
      }
    },
    allOf: [
      {
        $ref: "#/$defs/specification-extensions"
      },
      {
        $ref: "#/$defs/encoding/$defs/explode-default"
      }
    ],
    unevaluatedProperties: !1,
    $defs: {
      "explode-default": {
        if: {
          properties: {
            style: {
              const: "form"
            }
          },
          required: [
            "style"
          ]
        },
        then: {
          properties: {
            explode: {
              default: !0
            }
          }
        },
        else: {
          properties: {
            explode: {
              default: !1
            }
          }
        }
      }
    }
  },
  responses: {
    type: "object",
    properties: {
      default: {
        $ref: "#/$defs/response-or-reference"
      }
    },
    patternProperties: {
      "^[1-5][0-9X]{2}$": {
        $ref: "#/$defs/response-or-reference"
      }
    },
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  response: {
    type: "object",
    properties: {
      description: {
        type: "string"
      },
      headers: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/header-or-reference"
        }
      },
      content: {
        $ref: "#/$defs/content"
      },
      links: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/link-or-reference"
        }
      }
    },
    required: [
      "description"
    ],
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  "response-or-reference": {
    if: {
      required: [
        "$ref"
      ]
    },
    then: {
      $ref: "#/$defs/reference"
    },
    else: {
      $ref: "#/$defs/response"
    }
  },
  callbacks: {
    type: "object",
    $ref: "#/$defs/specification-extensions",
    additionalProperties: {
      $ref: "#/$defs/path-item-or-reference"
    }
  },
  "callbacks-or-reference": {
    if: {
      required: [
        "$ref"
      ]
    },
    then: {
      $ref: "#/$defs/reference"
    },
    else: {
      $ref: "#/$defs/callbacks"
    }
  },
  example: {
    type: "object",
    properties: {
      summary: {
        type: "string"
      },
      description: {
        type: "string"
      },
      value: !0,
      externalValue: {
        $ref: "#/$defs/uri"
      }
    },
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  "example-or-reference": {
    if: {
      required: [
        "$ref"
      ]
    },
    then: {
      $ref: "#/$defs/reference"
    },
    else: {
      $ref: "#/$defs/example"
    }
  },
  link: {
    type: "object",
    properties: {
      operationRef: {
        $ref: "#/$defs/uri"
      },
      operationId: !0,
      parameters: {
        $ref: "#/$defs/map-of-strings"
      },
      requestBody: !0,
      description: {
        type: "string"
      },
      body: {
        $ref: "#/$defs/server"
      }
    },
    oneOf: [
      {
        required: [
          "operationRef"
        ]
      },
      {
        required: [
          "operationId"
        ]
      }
    ],
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  "link-or-reference": {
    if: {
      required: [
        "$ref"
      ]
    },
    then: {
      $ref: "#/$defs/reference"
    },
    else: {
      $ref: "#/$defs/link"
    }
  },
  header: {
    type: "object",
    properties: {
      description: {
        type: "string"
      },
      required: {
        default: !1,
        type: "boolean"
      },
      deprecated: {
        default: !1,
        type: "boolean"
      },
      allowEmptyValue: {
        default: !1,
        type: "boolean"
      }
    },
    dependentSchemas: {
      schema: {
        properties: {
          style: {
            default: "simple",
            enum: [
              "simple"
            ]
          },
          explode: {
            default: !1,
            type: "boolean"
          },
          allowReserved: {
            default: !1,
            type: "boolean"
          },
          schema: {
            $dynamicRef: "#meta"
          }
        },
        $ref: "#/$defs/examples"
      },
      content: {
        properties: {
          content: {
            $ref: "#/$defs/content"
          }
        }
      }
    },
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  "header-or-reference": {
    if: {
      required: [
        "$ref"
      ]
    },
    then: {
      $ref: "#/$defs/reference"
    },
    else: {
      $ref: "#/$defs/header"
    }
  },
  tag: {
    type: "object",
    properties: {
      name: {
        type: "string"
      },
      description: {
        type: "string"
      },
      externalDocs: {
        $ref: "#/$defs/external-documentation"
      }
    },
    required: [
      "name"
    ],
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  reference: {
    type: "object",
    properties: {
      $ref: {
        $ref: "#/$defs/uri"
      },
      summary: {
        type: "string"
      },
      description: {
        type: "string"
      }
    },
    unevaluatedProperties: !1
  },
  schema: {
    $dynamicAnchor: "meta",
    type: [
      "object",
      "boolean"
    ]
  },
  "security-scheme": {
    type: "object",
    properties: {
      type: {
        enum: [
          "apiKey",
          "http",
          "mutualTLS",
          "oauth2",
          "openIdConnect"
        ]
      },
      description: {
        type: "string"
      }
    },
    required: [
      "type"
    ],
    allOf: [
      {
        $ref: "#/$defs/specification-extensions"
      },
      {
        $ref: "#/$defs/security-scheme/$defs/type-apikey"
      },
      {
        $ref: "#/$defs/security-scheme/$defs/type-http"
      },
      {
        $ref: "#/$defs/security-scheme/$defs/type-http-bearer"
      },
      {
        $ref: "#/$defs/security-scheme/$defs/type-oauth2"
      },
      {
        $ref: "#/$defs/security-scheme/$defs/type-oidc"
      }
    ],
    unevaluatedProperties: !1,
    $defs: {
      "type-apikey": {
        if: {
          properties: {
            type: {
              const: "apiKey"
            }
          },
          required: [
            "type"
          ]
        },
        then: {
          properties: {
            name: {
              type: "string"
            },
            in: {
              enum: [
                "query",
                "header",
                "cookie"
              ]
            }
          },
          required: [
            "name",
            "in"
          ]
        }
      },
      "type-http": {
        if: {
          properties: {
            type: {
              const: "http"
            }
          },
          required: [
            "type"
          ]
        },
        then: {
          properties: {
            scheme: {
              type: "string"
            }
          },
          required: [
            "scheme"
          ]
        }
      },
      "type-http-bearer": {
        if: {
          properties: {
            type: {
              const: "http"
            },
            scheme: {
              const: "bearer"
            }
          },
          required: [
            "type",
            "scheme"
          ]
        },
        then: {
          properties: {
            bearerFormat: {
              type: "string"
            }
          },
          required: [
            "scheme"
          ]
        }
      },
      "type-oauth2": {
        if: {
          properties: {
            type: {
              const: "oauth2"
            }
          },
          required: [
            "type"
          ]
        },
        then: {
          properties: {
            flows: {
              $ref: "#/$defs/oauth-flows"
            }
          },
          required: [
            "flows"
          ]
        }
      },
      "type-oidc": {
        if: {
          properties: {
            type: {
              const: "openIdConnect"
            }
          },
          required: [
            "type"
          ]
        },
        then: {
          properties: {
            openIdConnectUrl: {
              $ref: "#/$defs/uri"
            }
          },
          required: [
            "openIdConnectUrl"
          ]
        }
      }
    }
  },
  "security-scheme-or-reference": {
    if: {
      required: [
        "$ref"
      ]
    },
    then: {
      $ref: "#/$defs/reference"
    },
    else: {
      $ref: "#/$defs/security-scheme"
    }
  },
  "oauth-flows": {
    type: "object",
    properties: {
      implicit: {
        $ref: "#/$defs/oauth-flows/$defs/implicit"
      },
      password: {
        $ref: "#/$defs/oauth-flows/$defs/password"
      },
      clientCredentials: {
        $ref: "#/$defs/oauth-flows/$defs/client-credentials"
      },
      authorizationCode: {
        $ref: "#/$defs/oauth-flows/$defs/authorization-code"
      }
    },
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1,
    $defs: {
      implicit: {
        type: "object",
        properties: {
          authorizationUrl: {
            type: "string"
          },
          refreshUrl: {
            type: "string"
          },
          scopes: {
            $ref: "#/$defs/map-of-strings"
          }
        },
        required: [
          "authorizationUrl",
          "scopes"
        ],
        $ref: "#/$defs/specification-extensions",
        unevaluatedProperties: !1
      },
      password: {
        type: "object",
        properties: {
          tokenUrl: {
            type: "string"
          },
          refreshUrl: {
            type: "string"
          },
          scopes: {
            $ref: "#/$defs/map-of-strings"
          }
        },
        required: [
          "tokenUrl",
          "scopes"
        ],
        $ref: "#/$defs/specification-extensions",
        unevaluatedProperties: !1
      },
      "client-credentials": {
        type: "object",
        properties: {
          tokenUrl: {
            type: "string"
          },
          refreshUrl: {
            type: "string"
          },
          scopes: {
            $ref: "#/$defs/map-of-strings"
          }
        },
        required: [
          "tokenUrl",
          "scopes"
        ],
        $ref: "#/$defs/specification-extensions",
        unevaluatedProperties: !1
      },
      "authorization-code": {
        type: "object",
        properties: {
          authorizationUrl: {
            type: "string"
          },
          tokenUrl: {
            type: "string"
          },
          refreshUrl: {
            type: "string"
          },
          scopes: {
            $ref: "#/$defs/map-of-strings"
          }
        },
        required: [
          "authorizationUrl",
          "tokenUrl",
          "scopes"
        ],
        $ref: "#/$defs/specification-extensions",
        unevaluatedProperties: !1
      }
    }
  },
  "security-requirement": {
    type: "object",
    additionalProperties: {
      type: "array",
      items: {
        type: "string"
      }
    }
  },
  "specification-extensions": {
    patternProperties: {
      "^x-": !0
    }
  },
  examples: {
    properties: {
      example: !0,
      examples: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/example-or-reference"
        }
      }
    }
  },
  uri: {
    type: "string",
    format: "uri"
  },
  "map-of-strings": {
    type: "object",
    additionalProperties: {
      type: "string"
    }
  }
}, Pq = {
  $id: gq,
  $schema: vq,
  type: bq,
  properties: _q,
  required: wq,
  anyOf: $q,
  $ref: Eq,
  unevaluatedProperties: xq,
  $defs: Oq
};
(function(e, t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.openapi = t.openapiV31 = t.openapiV3 = t.openapiV2 = t.openapiV1 = void 0, t.openapiV1 = Y4, t.openapiV2 = aq, t.openapiV3 = yq, t.openapiV31 = Pq, t.openapi = {
    v1: t.openapiV1,
    v2: t.openapiV2,
    v3: t.openapiV3,
    v31: t.openapiV31
  }, t.default = t.openapi, e.exports = Object.assign(e.exports.default, e.exports);
})($y, $y.exports);
var Sq = $y.exports, Ey = { exports: {} }, SO = { exports: {} };
(function(e) {
  function t(r) {
    return r && r.__esModule ? r : {
      default: r
    };
  }
  e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports;
})(SO);
var kn = SO.exports, Ri = {};
Object.defineProperty(Ri, "__esModule", { value: !0 });
const Aq = "[", Cq = "]", Rq = "{", Tq = "}", Iq = ":", jq = ",", AO = "true", CO = "false", RO = "null", d_ = '"', kq = /* @__PURE__ */ new Map([
  ["t", AO],
  ["f", CO],
  ["n", RO]
]), xy = /* @__PURE__ */ new Map([
  [d_, d_],
  ["\\", "\\"],
  ["/", "/"],
  ["b", "\b"],
  ["n", `
`],
  ["f", "\f"],
  ["r", "\r"],
  ["t", "	"]
]), Hp = /* @__PURE__ */ new Map([
  [Aq, "Punctuator"],
  [Cq, "Punctuator"],
  [Rq, "Punctuator"],
  [Tq, "Punctuator"],
  [Iq, "Punctuator"],
  [jq, "Punctuator"],
  [AO, "Boolean"],
  [CO, "Boolean"],
  [RO, "Null"]
]);
class Iu extends Error {
  /**
   * 
   * @param {string} message The error message to report. 
   * @param {int} loc.line The line on which the error occurred.
   * @param {int} loc.column The column in the line where the error occurrred.
   * @param {int} loc.index The index in the string where the error occurred.
   */
  constructor(t, { line: r, column: i, index: n }) {
    super(`${t} (${r}:${i})`), this.line = r, this.column = i, this.index = n;
  }
}
class Mq extends Iu {
  /**
   * Creates a new instance.
   * @param {string} unexpected The character that was found.
   * @param {Object} loc The location information for the found character.
   */
  constructor(t, r) {
    super(`Unexpected character ${t} found.`, r);
  }
}
class Gc extends Iu {
  /**
   * Creates a new instance.
   * @param {string} expected The character that was expected. 
   * @param {string} unexpected The character that was found.
   * @param {Object} loc The location information for the found character.
   */
  constructor(t) {
    super(`Unexpected token ${t.type}(${t.value}) found.`, t.loc.start);
  }
}
class Nq extends Iu {
  /**
   * Creates a new instance.
   * @param {Object} loc The location information for the found character.
   */
  constructor(t) {
    super("Unexpected end of input found.", t);
  }
}
const p_ = '"', h_ = "/", m_ = "*", Dq = {
  comments: !1,
  ranges: !1
};
function Lq(e) {
  return /[\s\n]/.test(e);
}
function Yi(e) {
  return e >= "0" && e <= "9";
}
function qq(e) {
  return Yi(e) || /[a-f]/i.test(e);
}
function Fq(e) {
  return e >= "1" && e <= "9";
}
function Uq(e) {
  return /[tfn]/.test(e);
}
function Bq(e) {
  return Yi(e) || e === "." || e === "-";
}
function TO(e, t) {
  t = Object.freeze({
    ...Dq,
    ...t
  });
  let r = -1, i = 1, n = 0, s = !1;
  const a = [];
  function o(y, w, $, E) {
    const S = $.offset + w.length;
    let R = t.ranges ? {
      range: [$.offset, S]
    } : void 0;
    return {
      type: y,
      value: w,
      loc: {
        start: $,
        end: E || {
          line: $.line,
          column: $.column + w.length,
          offset: S
        }
      },
      ...R
    };
  }
  function c() {
    let y = e.charAt(++r);
    return s ? (i++, n = 1, s = !1) : n++, y === "\r" ? (s = !0, e.charAt(r + 1) === `
` && r++) : y === `
` && (s = !0), y;
  }
  function l() {
    return {
      line: i,
      column: n,
      offset: r
    };
  }
  function d(y) {
    let w = kq.get(y);
    if (e.slice(r, r + w.length) === w)
      return r += w.length - 1, n += w.length - 1, { value: w, c: c() };
    for (let $ = 1; $ < w.length; $++)
      w[$] !== e.charAt(r + $) && m(c());
  }
  function p(y) {
    let w = y;
    for (y = c(); y && y !== p_; ) {
      if (y === "\\")
        if (w += y, y = c(), xy.has(y))
          w += y;
        else if (y === "u") {
          w += y;
          for (let $ = 0; $ < 4; $++)
            y = c(), qq(y) ? w += y : m(y);
        } else
          m(y);
      else
        w += y;
      y = c();
    }
    return y || v(), w += y, { value: w, c: c() };
  }
  function h(y) {
    let w = "";
    if (y === "-" && (w += y, y = c(), Yi(y) || m(y)), y === "0")
      w += y, y = c(), Yi(y) && m(y);
    else {
      Fq(y) || m(y);
      do
        w += y, y = c();
      while (Yi(y));
    }
    if (y === ".")
      do
        w += y, y = c();
      while (Yi(y));
    if (y === "e" || y === "E")
      for (w += y, y = c(), (y === "+" || y === "-") && (w += y, y = c()), Yi(y) || m(y); Yi(y); )
        w += y, y = c();
    return { value: w, c: y };
  }
  function g(y) {
    let w = y;
    if (y = c(), y === "/") {
      do
        w += y, y = c();
      while (y && y !== "\r" && y !== `
`);
      return { value: w, c: y };
    }
    if (y === m_) {
      for (; y; )
        if (w += y, y = c(), y === m_ && (w += y, y = c(), y === h_))
          return w += y, y = c(), { value: w, c: y };
      v();
    }
    m(y);
  }
  function m(y) {
    throw new Mq(y, l());
  }
  function v() {
    throw new Nq(l());
  }
  let _ = c();
  for (; r < e.length; ) {
    for (; Lq(_); )
      _ = c();
    if (!_)
      break;
    const y = l();
    if (Hp.has(_))
      a.push(o(Hp.get(_), _, y)), _ = c();
    else if (Uq(_)) {
      const w = d(_);
      let $ = w.value;
      _ = w.c, a.push(o(Hp.get($), $, y));
    } else if (Bq(_)) {
      const w = h(_);
      let $ = w.value;
      _ = w.c, a.push(o("Number", $, y));
    } else if (_ === p_) {
      const w = p(_);
      let $ = w.value;
      _ = w.c, a.push(o("String", $, y));
    } else if (_ === h_ && t.comments) {
      const w = g(_);
      let $ = w.value;
      _ = w.c, a.push(o($.startsWith("//") ? "LineComment" : "BlockComment", $, y, l()));
    } else
      m(_);
  }
  return a;
}
const Xo = {
  document(e, t = {}) {
    return {
      type: "Document",
      body: e,
      ...t
    };
  },
  string(e, t = {}) {
    return {
      type: "String",
      value: e,
      ...t
    };
  },
  number(e, t = {}) {
    return {
      type: "Number",
      value: e,
      ...t
    };
  },
  boolean(e, t = {}) {
    return {
      type: "Boolean",
      value: e,
      ...t
    };
  },
  null(e = {}) {
    return {
      type: "Null",
      value: "null",
      ...e
    };
  },
  array(e, t = {}) {
    return {
      type: "Array",
      elements: e,
      ...t
    };
  },
  object(e, t = {}) {
    return {
      type: "Object",
      members: e,
      ...t
    };
  },
  member(e, t, r = {}) {
    return {
      type: "Member",
      name: e,
      value: t,
      ...r
    };
  }
}, Vq = {
  tokens: !1,
  comments: !1,
  ranges: !1
};
function Zq(e) {
  let t = e.value.slice(1, -1), r = "", i = t.indexOf("\\"), n = 0;
  for (; i >= 0; ) {
    r += t.slice(n, i);
    const s = t.charAt(i + 1);
    if (xy.has(s))
      r += xy.get(s), n = i + 2;
    else if (s === "u") {
      const a = t.slice(i + 2, i + 6);
      if (a.length < 4 || /[^0-9a-f]/i.test(a))
        throw new Iu(
          `Invalid unicode escape \\u${a}.`,
          {
            line: e.loc.start.line,
            column: e.loc.start.column + i,
            offset: e.loc.start.offset + i
          }
        );
      r += String.fromCharCode(parseInt(a, 16)), n = i + 6;
    } else
      throw new Iu(
        `Invalid escape \\${s}.`,
        {
          line: e.loc.start.line,
          column: e.loc.start.column + i,
          offset: e.loc.start.offset + i
        }
      );
    i = t.indexOf("\\", n);
  }
  return r += t.slice(n), r;
}
function zq(e) {
  switch (e.type) {
    case "Boolean":
      return e.value === "true";
    case "Number":
      return Number(e.value);
    case "Null":
      return null;
    case "String":
      return Zq(e);
  }
}
function Wq(e, t) {
  t = Object.freeze({
    ...Vq,
    ...t
  });
  const r = TO(e, {
    comments: !!t.comments,
    ranges: !!t.ranges
  });
  let i = 0;
  function n() {
    return r[i++];
  }
  function s() {
    const w = r[i++];
    return w && w.type.endsWith("Comment") ? s() : w;
  }
  const a = t.comments ? s : n;
  function o(w, $) {
    if (!w || w.value !== $)
      throw new Gc(w);
  }
  function c(w, $) {
    if (!w || w.type !== $)
      throw new Gc(w);
  }
  function l(w, $) {
    return t.ranges ? {
      range: [w.offset, $.offset]
    } : void 0;
  }
  function d(w) {
    const $ = l(w.loc.start, w.loc.end);
    return {
      type: w.type,
      value: zq(w),
      loc: {
        start: {
          ...w.loc.start
        },
        end: {
          ...w.loc.end
        }
      },
      ...$
    };
  }
  function p(w) {
    c(w, "String");
    const $ = d(w);
    w = a(), o(w, ":");
    const E = m(), S = l($.loc.start, E.loc.end);
    return Xo.member($, E, {
      loc: {
        start: {
          ...$.loc.start
        },
        end: {
          ...E.loc.end
        }
      },
      ...S
    });
  }
  function h(w) {
    o(w, "{");
    const $ = [];
    let E = a();
    if (E && E.value !== "}")
      do
        if ($.push(p(E)), E = a(), E.value === ",")
          E = a();
        else
          break;
      while (E);
    o(E, "}");
    const S = l(w.loc.start, E.loc.end);
    return Xo.object($, {
      loc: {
        start: {
          ...w.loc.start
        },
        end: {
          ...E.loc.end
        }
      },
      ...S
    });
  }
  function g(w) {
    o(w, "[");
    const $ = [];
    let E = a();
    if (E && E.value !== "]")
      do
        if ($.push(m(E)), E = a(), E.value === ",")
          E = a();
        else
          break;
      while (E);
    o(E, "]");
    const S = l(w.loc.start, E.loc.end);
    return Xo.array($, {
      type: "Array",
      elements: $,
      loc: {
        start: {
          ...w.loc.start
        },
        end: {
          ...E.loc.end
        }
      },
      ...S
    });
  }
  function m(w) {
    switch (w = w || a(), w.type) {
      case "String":
      case "Boolean":
      case "Number":
      case "Null":
        return d(w);
      case "Punctuator":
        if (w.value === "{")
          return h(w);
        if (w.value === "[")
          return g(w);
      default:
        throw new Gc(w);
    }
  }
  const v = m(), _ = a();
  if (_)
    throw new Gc(_);
  const y = {
    loc: {
      start: {
        line: 1,
        column: 1,
        offset: 0
      },
      end: {
        ...v.loc.end
      }
    }
  };
  return t.tokens && (y.tokens = r), t.ranges && (y.range = l(y.loc.start, y.loc.end)), Xo.document(v, y);
}
const Hq = /* @__PURE__ */ new Map([
  ["Document", ["body"]],
  ["Object", ["members"]],
  ["Member", ["name", "value"]],
  ["Array", ["elements"]],
  ["String", []],
  ["Number", []],
  ["Boolean", []],
  ["Null", []]
]);
function IO(e) {
  return e && typeof e == "object";
}
function Gq(e) {
  return IO(e) && typeof e.type == "string";
}
function jO(e, t) {
  function r(i, n) {
    typeof t.enter == "function" && t.enter(i, n);
    for (const s of Hq.get(i.type)) {
      const a = i[s];
      IO(a) && (Array.isArray(a) ? a.forEach((o) => r(o, i)) : Gq(a) && r(a, i));
    }
    typeof t.exit == "function" && t.exit(i, n);
  }
  r(e);
}
function Kq(e, t = () => !0) {
  const r = [];
  return jO(e, {
    enter(i, n) {
      r.push({ node: i, parent: n, phase: "enter" });
    },
    exit(i, n) {
      r.push({ node: i, parent: n, phase: "exit" });
    }
  }), r.filter(t).values();
}
function La(e) {
  switch (e.type) {
    case "String":
    case "Number":
    case "Boolean":
      return e.value;
    case "Null":
      return null;
    case "Array":
      return e.elements.map(La);
    case "Object": {
      const t = {};
      return e.members.forEach((r) => {
        t[La(r.name)] = La(r.value);
      }), t;
    }
    case "Document":
      return La(e.body);
    case "Property":
      throw new Error("Cannot evaluate object property outside of an object.");
    default:
      throw new Error(`Unknown node type ${e.type}.`);
  }
}
function Yq(e, { indent: t = 0 } = {}) {
  const r = La(e);
  return JSON.stringify(r, null, t);
}
Ri.evaluate = La;
Ri.iterator = Kq;
Ri.parse = Wq;
Ri.print = Yq;
Ri.tokenize = TO;
Ri.traverse = jO;
Ri.types = Xo;
var Gp = {}, Kp = { exports: {} }, Yp = { exports: {} }, Jp = { exports: {} }, y_;
function jg() {
  return y_ || (y_ = 1, function(e) {
    function t(r) {
      "@babel/helpers - typeof";
      return e.exports = t = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(i) {
        return typeof i;
      } : function(i) {
        return i && typeof Symbol == "function" && i.constructor === Symbol && i !== Symbol.prototype ? "symbol" : typeof i;
      }, e.exports.__esModule = !0, e.exports.default = e.exports, t(r);
    }
    e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(Jp)), Jp.exports;
}
var Xp = { exports: {} }, g_;
function Jq() {
  return g_ || (g_ = 1, function(e) {
    var t = jg().default;
    function r(i, n) {
      if (t(i) !== "object" || i === null)
        return i;
      var s = i[Symbol.toPrimitive];
      if (s !== void 0) {
        var a = s.call(i, n || "default");
        if (t(a) !== "object")
          return a;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (n === "string" ? String : Number)(i);
    }
    e.exports = r, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(Xp)), Xp.exports;
}
var v_;
function kO() {
  return v_ || (v_ = 1, function(e) {
    var t = jg().default, r = Jq();
    function i(n) {
      var s = r(n, "string");
      return t(s) === "symbol" ? s : String(s);
    }
    e.exports = i, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(Yp)), Yp.exports;
}
var b_;
function Js() {
  return b_ || (b_ = 1, function(e) {
    var t = kO();
    function r(i, n, s) {
      return n = t(n), n in i ? Object.defineProperty(i, n, {
        value: s,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }) : i[n] = s, i;
    }
    e.exports = r, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(Kp)), Kp.exports;
}
var Qp = { exports: {} }, eh = { exports: {} }, th = { exports: {} }, __;
function MO() {
  return __ || (__ = 1, function(e) {
    function t(r, i) {
      (i == null || i > r.length) && (i = r.length);
      for (var n = 0, s = new Array(i); n < i; n++)
        s[n] = r[n];
      return s;
    }
    e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(th)), th.exports;
}
var w_;
function Xq() {
  return w_ || (w_ = 1, function(e) {
    var t = MO();
    function r(i) {
      if (Array.isArray(i))
        return t(i);
    }
    e.exports = r, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(eh)), eh.exports;
}
var rh = { exports: {} }, $_;
function Qq() {
  return $_ || ($_ = 1, function(e) {
    function t(r) {
      if (typeof Symbol < "u" && r[Symbol.iterator] != null || r["@@iterator"] != null)
        return Array.from(r);
    }
    e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(rh)), rh.exports;
}
var nh = { exports: {} }, E_;
function NO() {
  return E_ || (E_ = 1, function(e) {
    var t = MO();
    function r(i, n) {
      if (i) {
        if (typeof i == "string")
          return t(i, n);
        var s = Object.prototype.toString.call(i).slice(8, -1);
        if (s === "Object" && i.constructor && (s = i.constructor.name), s === "Map" || s === "Set")
          return Array.from(i);
        if (s === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(s))
          return t(i, n);
      }
    }
    e.exports = r, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(nh)), nh.exports;
}
var ih = { exports: {} }, x_;
function e8() {
  return x_ || (x_ = 1, function(e) {
    function t() {
      throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(ih)), ih.exports;
}
var O_;
function t8() {
  return O_ || (O_ = 1, function(e) {
    var t = Xq(), r = Qq(), i = NO(), n = e8();
    function s(a) {
      return t(a) || r(a) || i(a) || n();
    }
    e.exports = s, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(Qp)), Qp.exports;
}
var sh = { exports: {} }, ah = { exports: {} }, P_;
function r8() {
  return P_ || (P_ = 1, function(e) {
    function t(r) {
      if (Array.isArray(r))
        return r;
    }
    e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(ah)), ah.exports;
}
var oh = { exports: {} }, S_;
function n8() {
  return S_ || (S_ = 1, function(e) {
    function t(r, i) {
      var n = r == null ? null : typeof Symbol < "u" && r[Symbol.iterator] || r["@@iterator"];
      if (n != null) {
        var s, a, o, c, l = [], d = !0, p = !1;
        try {
          if (o = (n = n.call(r)).next, i === 0) {
            if (Object(n) !== n)
              return;
            d = !1;
          } else
            for (; !(d = (s = o.call(n)).done) && (l.push(s.value), l.length !== i); d = !0)
              ;
        } catch (h) {
          p = !0, a = h;
        } finally {
          try {
            if (!d && n.return != null && (c = n.return(), Object(c) !== c))
              return;
          } finally {
            if (p)
              throw a;
          }
        }
        return l;
      }
    }
    e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(oh)), oh.exports;
}
var uh = { exports: {} }, A_;
function i8() {
  return A_ || (A_ = 1, function(e) {
    function t() {
      throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(uh)), uh.exports;
}
var C_;
function s8() {
  return C_ || (C_ = 1, function(e) {
    var t = r8(), r = n8(), i = NO(), n = i8();
    function s(a, o) {
      return t(a) || r(a, o) || i(a, o) || n();
    }
    e.exports = s, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(sh)), sh.exports;
}
var or = {}, R_;
function a8() {
  if (R_)
    return or;
  R_ = 1, Object.defineProperty(or, "__esModule", {
    value: !0
  }), or.notUndefined = or.isRequiredError = or.isEnumError = or.isAnyOfError = or.getSiblings = or.getErrors = or.getChildren = or.concatAll = void 0;
  var e = function(g) {
    return function(m) {
      return g === m;
    };
  }, t = function(g) {
    return function(m) {
      return !g(m);
    };
  }, r = function(g) {
    return Object.values(g);
  }, i = function(g) {
    return g !== void 0;
  };
  or.notUndefined = i;
  var n = function(g) {
    return function(m) {
      return m.keyword === g;
    };
  }, s = n("required");
  or.isRequiredError = s;
  var a = n("anyOf");
  or.isAnyOfError = a;
  var o = n("enum");
  or.isEnumError = o;
  var c = function(g) {
    return g && g.errors || [];
  };
  or.getErrors = c;
  var l = function(g) {
    return g && r(g.children) || [];
  };
  or.getChildren = l;
  var d = function(g) {
    return function(m) {
      return l(g).filter(t(e(m)));
    };
  };
  or.getSiblings = d;
  var p = (
    /* ::<T> */
    function(g) {
      return function(m) {
        return m.reduce(function(v, _) {
          return v.concat(_);
        }, g);
      };
    }
  );
  return or.concatAll = p, or;
}
var ch = {}, Kc = { exports: {} }, lh = { exports: {} }, T_;
function io() {
  return T_ || (T_ = 1, function(e) {
    function t(r, i) {
      return i || (i = r.slice(0)), Object.freeze(Object.defineProperties(r, {
        raw: {
          value: Object.freeze(i)
        }
      }));
    }
    e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(lh)), lh.exports;
}
var fh = { exports: {} }, I_;
function Xs() {
  return I_ || (I_ = 1, function(e) {
    function t(r, i) {
      if (!(r instanceof i))
        throw new TypeError("Cannot call a class as a function");
    }
    e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(fh)), fh.exports;
}
var dh = { exports: {} }, j_;
function Qs() {
  return j_ || (j_ = 1, function(e) {
    var t = kO();
    function r(n, s) {
      for (var a = 0; a < s.length; a++) {
        var o = s[a];
        o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(n, t(o.key), o);
      }
    }
    function i(n, s, a) {
      return s && r(n.prototype, s), a && r(n, a), Object.defineProperty(n, "prototype", {
        writable: !1
      }), n;
    }
    e.exports = i, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(dh)), dh.exports;
}
var ph = { exports: {} }, hh = { exports: {} }, k_;
function o8() {
  return k_ || (k_ = 1, function(e) {
    function t(r, i) {
      return e.exports = t = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(s, a) {
        return s.__proto__ = a, s;
      }, e.exports.__esModule = !0, e.exports.default = e.exports, t(r, i);
    }
    e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(hh)), hh.exports;
}
var M_;
function so() {
  return M_ || (M_ = 1, function(e) {
    var t = o8();
    function r(i, n) {
      if (typeof n != "function" && n !== null)
        throw new TypeError("Super expression must either be null or a function");
      i.prototype = Object.create(n && n.prototype, {
        constructor: {
          value: i,
          writable: !0,
          configurable: !0
        }
      }), Object.defineProperty(i, "prototype", {
        writable: !1
      }), n && t(i, n);
    }
    e.exports = r, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(ph)), ph.exports;
}
var mh = { exports: {} }, yh = { exports: {} }, N_;
function u8() {
  return N_ || (N_ = 1, function(e) {
    function t(r) {
      if (r === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return r;
    }
    e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(yh)), yh.exports;
}
var D_;
function ao() {
  return D_ || (D_ = 1, function(e) {
    var t = jg().default, r = u8();
    function i(n, s) {
      if (s && (t(s) === "object" || typeof s == "function"))
        return s;
      if (s !== void 0)
        throw new TypeError("Derived constructors may only return object or undefined");
      return r(n);
    }
    e.exports = i, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(mh)), mh.exports;
}
var gh = { exports: {} }, L_;
function ea() {
  return L_ || (L_ = 1, function(e) {
    function t(r) {
      return e.exports = t = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {
        return n.__proto__ || Object.getPrototypeOf(n);
      }, e.exports.__esModule = !0, e.exports.default = e.exports, t(r);
    }
    e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(gh)), gh.exports;
}
var Yc = { exports: {} }, Fo = {}, Oa = {}, Uo = {}, q_;
function c8() {
  return q_ || (q_ = 1, Object.defineProperty(Uo, "__esModule", {
    value: !0
  }), Uo.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g, Uo.matchToToken = function(e) {
    var t = { type: "invalid", value: e[0], closed: void 0 };
    return e[1] ? (t.type = "string", t.closed = !!(e[3] || e[4])) : e[5] ? t.type = "comment" : e[6] ? (t.type = "comment", t.closed = !!e[7]) : e[8] ? t.type = "regex" : e[9] ? t.type = "number" : e[10] ? t.type = "name" : e[11] ? t.type = "punctuator" : e[12] && (t.type = "whitespace"), t;
  }), Uo;
}
var vh = {}, Pa = {}, F_;
function l8() {
  if (F_)
    return Pa;
  F_ = 1, Object.defineProperty(Pa, "__esModule", {
    value: !0
  }), Pa.isIdentifierChar = c, Pa.isIdentifierName = l, Pa.isIdentifierStart = o;
  let e = "------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------", t = "-----------------------------------------------------------------------------------------------------------------------------------------------------";
  const r = new RegExp("[" + e + "]"), i = new RegExp("[" + e + t + "]");
  e = t = null;
  const n = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938, 6, 4191], s = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function a(d, p) {
    let h = 65536;
    for (let g = 0, m = p.length; g < m; g += 2) {
      if (h += p[g], h > d)
        return !1;
      if (h += p[g + 1], h >= d)
        return !0;
    }
    return !1;
  }
  function o(d) {
    return d < 65 ? d === 36 : d <= 90 ? !0 : d < 97 ? d === 95 : d <= 122 ? !0 : d <= 65535 ? d >= 170 && r.test(String.fromCharCode(d)) : a(d, n);
  }
  function c(d) {
    return d < 48 ? d === 36 : d < 58 ? !0 : d < 65 ? !1 : d <= 90 ? !0 : d < 97 ? d === 95 : d <= 122 ? !0 : d <= 65535 ? d >= 170 && i.test(String.fromCharCode(d)) : a(d, n) || a(d, s);
  }
  function l(d) {
    let p = !0;
    for (let h = 0; h < d.length; h++) {
      let g = d.charCodeAt(h);
      if ((g & 64512) === 55296 && h + 1 < d.length) {
        const m = d.charCodeAt(++h);
        (m & 64512) === 56320 && (g = 65536 + ((g & 1023) << 10) + (m & 1023));
      }
      if (p) {
        if (p = !1, !o(g))
          return !1;
      } else if (!c(g))
        return !1;
    }
    return !p;
  }
  return Pa;
}
var Wi = {}, U_;
function f8() {
  if (U_)
    return Wi;
  U_ = 1, Object.defineProperty(Wi, "__esModule", {
    value: !0
  }), Wi.isKeyword = c, Wi.isReservedWord = n, Wi.isStrictBindOnlyReservedWord = a, Wi.isStrictBindReservedWord = o, Wi.isStrictReservedWord = s;
  const e = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  }, t = new Set(e.keyword), r = new Set(e.strict), i = new Set(e.strictBind);
  function n(l, d) {
    return d && l === "await" || l === "enum";
  }
  function s(l, d) {
    return n(l, d) || r.has(l);
  }
  function a(l) {
    return i.has(l);
  }
  function o(l, d) {
    return s(l, d) || a(l);
  }
  function c(l) {
    return t.has(l);
  }
  return Wi;
}
var B_;
function d8() {
  return B_ || (B_ = 1, function(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), Object.defineProperty(e, "isIdentifierChar", {
      enumerable: !0,
      get: function() {
        return t.isIdentifierChar;
      }
    }), Object.defineProperty(e, "isIdentifierName", {
      enumerable: !0,
      get: function() {
        return t.isIdentifierName;
      }
    }), Object.defineProperty(e, "isIdentifierStart", {
      enumerable: !0,
      get: function() {
        return t.isIdentifierStart;
      }
    }), Object.defineProperty(e, "isKeyword", {
      enumerable: !0,
      get: function() {
        return r.isKeyword;
      }
    }), Object.defineProperty(e, "isReservedWord", {
      enumerable: !0,
      get: function() {
        return r.isReservedWord;
      }
    }), Object.defineProperty(e, "isStrictBindOnlyReservedWord", {
      enumerable: !0,
      get: function() {
        return r.isStrictBindOnlyReservedWord;
      }
    }), Object.defineProperty(e, "isStrictBindReservedWord", {
      enumerable: !0,
      get: function() {
        return r.isStrictBindReservedWord;
      }
    }), Object.defineProperty(e, "isStrictReservedWord", {
      enumerable: !0,
      get: function() {
        return r.isStrictReservedWord;
      }
    });
    var t = l8(), r = f8();
  }(vh)), vh;
}
var bh = { exports: {} }, _h, V_;
function p8() {
  if (V_)
    return _h;
  V_ = 1;
  var e = /[|\\{}()[\]^$+*?.]/g;
  return _h = function(t) {
    if (typeof t != "string")
      throw new TypeError("Expected a string");
    return t.replace(e, "\\$&");
  }, _h;
}
var Ol = { exports: {} }, wh = { exports: {} }, $h, Z_;
function h8() {
  return Z_ || (Z_ = 1, $h = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  }), $h;
}
var z_;
function DO() {
  if (z_)
    return wh.exports;
  z_ = 1;
  var e = h8(), t = {};
  for (var r in e)
    e.hasOwnProperty(r) && (t[e[r]] = r);
  var i = wh.exports = {
    rgb: { channels: 3, labels: "rgb" },
    hsl: { channels: 3, labels: "hsl" },
    hsv: { channels: 3, labels: "hsv" },
    hwb: { channels: 3, labels: "hwb" },
    cmyk: { channels: 4, labels: "cmyk" },
    xyz: { channels: 3, labels: "xyz" },
    lab: { channels: 3, labels: "lab" },
    lch: { channels: 3, labels: "lch" },
    hex: { channels: 1, labels: ["hex"] },
    keyword: { channels: 1, labels: ["keyword"] },
    ansi16: { channels: 1, labels: ["ansi16"] },
    ansi256: { channels: 1, labels: ["ansi256"] },
    hcg: { channels: 3, labels: ["h", "c", "g"] },
    apple: { channels: 3, labels: ["r16", "g16", "b16"] },
    gray: { channels: 1, labels: ["gray"] }
  };
  for (var n in i)
    if (i.hasOwnProperty(n)) {
      if (!("channels" in i[n]))
        throw new Error("missing channels property: " + n);
      if (!("labels" in i[n]))
        throw new Error("missing channel labels property: " + n);
      if (i[n].labels.length !== i[n].channels)
        throw new Error("channel and label counts mismatch: " + n);
      var s = i[n].channels, a = i[n].labels;
      delete i[n].channels, delete i[n].labels, Object.defineProperty(i[n], "channels", { value: s }), Object.defineProperty(i[n], "labels", { value: a });
    }
  i.rgb.hsl = function(c) {
    var l = c[0] / 255, d = c[1] / 255, p = c[2] / 255, h = Math.min(l, d, p), g = Math.max(l, d, p), m = g - h, v, _, y;
    return g === h ? v = 0 : l === g ? v = (d - p) / m : d === g ? v = 2 + (p - l) / m : p === g && (v = 4 + (l - d) / m), v = Math.min(v * 60, 360), v < 0 && (v += 360), y = (h + g) / 2, g === h ? _ = 0 : y <= 0.5 ? _ = m / (g + h) : _ = m / (2 - g - h), [v, _ * 100, y * 100];
  }, i.rgb.hsv = function(c) {
    var l, d, p, h, g, m = c[0] / 255, v = c[1] / 255, _ = c[2] / 255, y = Math.max(m, v, _), w = y - Math.min(m, v, _), $ = function(E) {
      return (y - E) / 6 / w + 1 / 2;
    };
    return w === 0 ? h = g = 0 : (g = w / y, l = $(m), d = $(v), p = $(_), m === y ? h = p - d : v === y ? h = 1 / 3 + l - p : _ === y && (h = 2 / 3 + d - l), h < 0 ? h += 1 : h > 1 && (h -= 1)), [
      h * 360,
      g * 100,
      y * 100
    ];
  }, i.rgb.hwb = function(c) {
    var l = c[0], d = c[1], p = c[2], h = i.rgb.hsl(c)[0], g = 1 / 255 * Math.min(l, Math.min(d, p));
    return p = 1 - 1 / 255 * Math.max(l, Math.max(d, p)), [h, g * 100, p * 100];
  }, i.rgb.cmyk = function(c) {
    var l = c[0] / 255, d = c[1] / 255, p = c[2] / 255, h, g, m, v;
    return v = Math.min(1 - l, 1 - d, 1 - p), h = (1 - l - v) / (1 - v) || 0, g = (1 - d - v) / (1 - v) || 0, m = (1 - p - v) / (1 - v) || 0, [h * 100, g * 100, m * 100, v * 100];
  };
  function o(c, l) {
    return Math.pow(c[0] - l[0], 2) + Math.pow(c[1] - l[1], 2) + Math.pow(c[2] - l[2], 2);
  }
  return i.rgb.keyword = function(c) {
    var l = t[c];
    if (l)
      return l;
    var d = 1 / 0, p;
    for (var h in e)
      if (e.hasOwnProperty(h)) {
        var g = e[h], m = o(c, g);
        m < d && (d = m, p = h);
      }
    return p;
  }, i.keyword.rgb = function(c) {
    return e[c];
  }, i.rgb.xyz = function(c) {
    var l = c[0] / 255, d = c[1] / 255, p = c[2] / 255;
    l = l > 0.04045 ? Math.pow((l + 0.055) / 1.055, 2.4) : l / 12.92, d = d > 0.04045 ? Math.pow((d + 0.055) / 1.055, 2.4) : d / 12.92, p = p > 0.04045 ? Math.pow((p + 0.055) / 1.055, 2.4) : p / 12.92;
    var h = l * 0.4124 + d * 0.3576 + p * 0.1805, g = l * 0.2126 + d * 0.7152 + p * 0.0722, m = l * 0.0193 + d * 0.1192 + p * 0.9505;
    return [h * 100, g * 100, m * 100];
  }, i.rgb.lab = function(c) {
    var l = i.rgb.xyz(c), d = l[0], p = l[1], h = l[2], g, m, v;
    return d /= 95.047, p /= 100, h /= 108.883, d = d > 8856e-6 ? Math.pow(d, 1 / 3) : 7.787 * d + 16 / 116, p = p > 8856e-6 ? Math.pow(p, 1 / 3) : 7.787 * p + 16 / 116, h = h > 8856e-6 ? Math.pow(h, 1 / 3) : 7.787 * h + 16 / 116, g = 116 * p - 16, m = 500 * (d - p), v = 200 * (p - h), [g, m, v];
  }, i.hsl.rgb = function(c) {
    var l = c[0] / 360, d = c[1] / 100, p = c[2] / 100, h, g, m, v, _;
    if (d === 0)
      return _ = p * 255, [_, _, _];
    p < 0.5 ? g = p * (1 + d) : g = p + d - p * d, h = 2 * p - g, v = [0, 0, 0];
    for (var y = 0; y < 3; y++)
      m = l + 1 / 3 * -(y - 1), m < 0 && m++, m > 1 && m--, 6 * m < 1 ? _ = h + (g - h) * 6 * m : 2 * m < 1 ? _ = g : 3 * m < 2 ? _ = h + (g - h) * (2 / 3 - m) * 6 : _ = h, v[y] = _ * 255;
    return v;
  }, i.hsl.hsv = function(c) {
    var l = c[0], d = c[1] / 100, p = c[2] / 100, h = d, g = Math.max(p, 0.01), m, v;
    return p *= 2, d *= p <= 1 ? p : 2 - p, h *= g <= 1 ? g : 2 - g, v = (p + d) / 2, m = p === 0 ? 2 * h / (g + h) : 2 * d / (p + d), [l, m * 100, v * 100];
  }, i.hsv.rgb = function(c) {
    var l = c[0] / 60, d = c[1] / 100, p = c[2] / 100, h = Math.floor(l) % 6, g = l - Math.floor(l), m = 255 * p * (1 - d), v = 255 * p * (1 - d * g), _ = 255 * p * (1 - d * (1 - g));
    switch (p *= 255, h) {
      case 0:
        return [p, _, m];
      case 1:
        return [v, p, m];
      case 2:
        return [m, p, _];
      case 3:
        return [m, v, p];
      case 4:
        return [_, m, p];
      case 5:
        return [p, m, v];
    }
  }, i.hsv.hsl = function(c) {
    var l = c[0], d = c[1] / 100, p = c[2] / 100, h = Math.max(p, 0.01), g, m, v;
    return v = (2 - d) * p, g = (2 - d) * h, m = d * h, m /= g <= 1 ? g : 2 - g, m = m || 0, v /= 2, [l, m * 100, v * 100];
  }, i.hwb.rgb = function(c) {
    var l = c[0] / 360, d = c[1] / 100, p = c[2] / 100, h = d + p, g, m, v, _;
    h > 1 && (d /= h, p /= h), g = Math.floor(6 * l), m = 1 - p, v = 6 * l - g, g & 1 && (v = 1 - v), _ = d + v * (m - d);
    var y, w, $;
    switch (g) {
      default:
      case 6:
      case 0:
        y = m, w = _, $ = d;
        break;
      case 1:
        y = _, w = m, $ = d;
        break;
      case 2:
        y = d, w = m, $ = _;
        break;
      case 3:
        y = d, w = _, $ = m;
        break;
      case 4:
        y = _, w = d, $ = m;
        break;
      case 5:
        y = m, w = d, $ = _;
        break;
    }
    return [y * 255, w * 255, $ * 255];
  }, i.cmyk.rgb = function(c) {
    var l = c[0] / 100, d = c[1] / 100, p = c[2] / 100, h = c[3] / 100, g, m, v;
    return g = 1 - Math.min(1, l * (1 - h) + h), m = 1 - Math.min(1, d * (1 - h) + h), v = 1 - Math.min(1, p * (1 - h) + h), [g * 255, m * 255, v * 255];
  }, i.xyz.rgb = function(c) {
    var l = c[0] / 100, d = c[1] / 100, p = c[2] / 100, h, g, m;
    return h = l * 3.2406 + d * -1.5372 + p * -0.4986, g = l * -0.9689 + d * 1.8758 + p * 0.0415, m = l * 0.0557 + d * -0.204 + p * 1.057, h = h > 31308e-7 ? 1.055 * Math.pow(h, 1 / 2.4) - 0.055 : h * 12.92, g = g > 31308e-7 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g * 12.92, m = m > 31308e-7 ? 1.055 * Math.pow(m, 1 / 2.4) - 0.055 : m * 12.92, h = Math.min(Math.max(0, h), 1), g = Math.min(Math.max(0, g), 1), m = Math.min(Math.max(0, m), 1), [h * 255, g * 255, m * 255];
  }, i.xyz.lab = function(c) {
    var l = c[0], d = c[1], p = c[2], h, g, m;
    return l /= 95.047, d /= 100, p /= 108.883, l = l > 8856e-6 ? Math.pow(l, 1 / 3) : 7.787 * l + 16 / 116, d = d > 8856e-6 ? Math.pow(d, 1 / 3) : 7.787 * d + 16 / 116, p = p > 8856e-6 ? Math.pow(p, 1 / 3) : 7.787 * p + 16 / 116, h = 116 * d - 16, g = 500 * (l - d), m = 200 * (d - p), [h, g, m];
  }, i.lab.xyz = function(c) {
    var l = c[0], d = c[1], p = c[2], h, g, m;
    g = (l + 16) / 116, h = d / 500 + g, m = g - p / 200;
    var v = Math.pow(g, 3), _ = Math.pow(h, 3), y = Math.pow(m, 3);
    return g = v > 8856e-6 ? v : (g - 16 / 116) / 7.787, h = _ > 8856e-6 ? _ : (h - 16 / 116) / 7.787, m = y > 8856e-6 ? y : (m - 16 / 116) / 7.787, h *= 95.047, g *= 100, m *= 108.883, [h, g, m];
  }, i.lab.lch = function(c) {
    var l = c[0], d = c[1], p = c[2], h, g, m;
    return h = Math.atan2(p, d), g = h * 360 / 2 / Math.PI, g < 0 && (g += 360), m = Math.sqrt(d * d + p * p), [l, m, g];
  }, i.lch.lab = function(c) {
    var l = c[0], d = c[1], p = c[2], h, g, m;
    return m = p / 360 * 2 * Math.PI, h = d * Math.cos(m), g = d * Math.sin(m), [l, h, g];
  }, i.rgb.ansi16 = function(c) {
    var l = c[0], d = c[1], p = c[2], h = 1 in arguments ? arguments[1] : i.rgb.hsv(c)[2];
    if (h = Math.round(h / 50), h === 0)
      return 30;
    var g = 30 + (Math.round(p / 255) << 2 | Math.round(d / 255) << 1 | Math.round(l / 255));
    return h === 2 && (g += 60), g;
  }, i.hsv.ansi16 = function(c) {
    return i.rgb.ansi16(i.hsv.rgb(c), c[2]);
  }, i.rgb.ansi256 = function(c) {
    var l = c[0], d = c[1], p = c[2];
    if (l === d && d === p)
      return l < 8 ? 16 : l > 248 ? 231 : Math.round((l - 8) / 247 * 24) + 232;
    var h = 16 + 36 * Math.round(l / 255 * 5) + 6 * Math.round(d / 255 * 5) + Math.round(p / 255 * 5);
    return h;
  }, i.ansi16.rgb = function(c) {
    var l = c % 10;
    if (l === 0 || l === 7)
      return c > 50 && (l += 3.5), l = l / 10.5 * 255, [l, l, l];
    var d = (~~(c > 50) + 1) * 0.5, p = (l & 1) * d * 255, h = (l >> 1 & 1) * d * 255, g = (l >> 2 & 1) * d * 255;
    return [p, h, g];
  }, i.ansi256.rgb = function(c) {
    if (c >= 232) {
      var l = (c - 232) * 10 + 8;
      return [l, l, l];
    }
    c -= 16;
    var d, p = Math.floor(c / 36) / 5 * 255, h = Math.floor((d = c % 36) / 6) / 5 * 255, g = d % 6 / 5 * 255;
    return [p, h, g];
  }, i.rgb.hex = function(c) {
    var l = ((Math.round(c[0]) & 255) << 16) + ((Math.round(c[1]) & 255) << 8) + (Math.round(c[2]) & 255), d = l.toString(16).toUpperCase();
    return "000000".substring(d.length) + d;
  }, i.hex.rgb = function(c) {
    var l = c.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!l)
      return [0, 0, 0];
    var d = l[0];
    l[0].length === 3 && (d = d.split("").map(function(v) {
      return v + v;
    }).join(""));
    var p = parseInt(d, 16), h = p >> 16 & 255, g = p >> 8 & 255, m = p & 255;
    return [h, g, m];
  }, i.rgb.hcg = function(c) {
    var l = c[0] / 255, d = c[1] / 255, p = c[2] / 255, h = Math.max(Math.max(l, d), p), g = Math.min(Math.min(l, d), p), m = h - g, v, _;
    return m < 1 ? v = g / (1 - m) : v = 0, m <= 0 ? _ = 0 : h === l ? _ = (d - p) / m % 6 : h === d ? _ = 2 + (p - l) / m : _ = 4 + (l - d) / m + 4, _ /= 6, _ %= 1, [_ * 360, m * 100, v * 100];
  }, i.hsl.hcg = function(c) {
    var l = c[1] / 100, d = c[2] / 100, p = 1, h = 0;
    return d < 0.5 ? p = 2 * l * d : p = 2 * l * (1 - d), p < 1 && (h = (d - 0.5 * p) / (1 - p)), [c[0], p * 100, h * 100];
  }, i.hsv.hcg = function(c) {
    var l = c[1] / 100, d = c[2] / 100, p = l * d, h = 0;
    return p < 1 && (h = (d - p) / (1 - p)), [c[0], p * 100, h * 100];
  }, i.hcg.rgb = function(c) {
    var l = c[0] / 360, d = c[1] / 100, p = c[2] / 100;
    if (d === 0)
      return [p * 255, p * 255, p * 255];
    var h = [0, 0, 0], g = l % 1 * 6, m = g % 1, v = 1 - m, _ = 0;
    switch (Math.floor(g)) {
      case 0:
        h[0] = 1, h[1] = m, h[2] = 0;
        break;
      case 1:
        h[0] = v, h[1] = 1, h[2] = 0;
        break;
      case 2:
        h[0] = 0, h[1] = 1, h[2] = m;
        break;
      case 3:
        h[0] = 0, h[1] = v, h[2] = 1;
        break;
      case 4:
        h[0] = m, h[1] = 0, h[2] = 1;
        break;
      default:
        h[0] = 1, h[1] = 0, h[2] = v;
    }
    return _ = (1 - d) * p, [
      (d * h[0] + _) * 255,
      (d * h[1] + _) * 255,
      (d * h[2] + _) * 255
    ];
  }, i.hcg.hsv = function(c) {
    var l = c[1] / 100, d = c[2] / 100, p = l + d * (1 - l), h = 0;
    return p > 0 && (h = l / p), [c[0], h * 100, p * 100];
  }, i.hcg.hsl = function(c) {
    var l = c[1] / 100, d = c[2] / 100, p = d * (1 - l) + 0.5 * l, h = 0;
    return p > 0 && p < 0.5 ? h = l / (2 * p) : p >= 0.5 && p < 1 && (h = l / (2 * (1 - p))), [c[0], h * 100, p * 100];
  }, i.hcg.hwb = function(c) {
    var l = c[1] / 100, d = c[2] / 100, p = l + d * (1 - l);
    return [c[0], (p - l) * 100, (1 - p) * 100];
  }, i.hwb.hcg = function(c) {
    var l = c[1] / 100, d = c[2] / 100, p = 1 - d, h = p - l, g = 0;
    return h < 1 && (g = (p - h) / (1 - h)), [c[0], h * 100, g * 100];
  }, i.apple.rgb = function(c) {
    return [c[0] / 65535 * 255, c[1] / 65535 * 255, c[2] / 65535 * 255];
  }, i.rgb.apple = function(c) {
    return [c[0] / 255 * 65535, c[1] / 255 * 65535, c[2] / 255 * 65535];
  }, i.gray.rgb = function(c) {
    return [c[0] / 100 * 255, c[0] / 100 * 255, c[0] / 100 * 255];
  }, i.gray.hsl = i.gray.hsv = function(c) {
    return [0, 0, c[0]];
  }, i.gray.hwb = function(c) {
    return [0, 100, c[0]];
  }, i.gray.cmyk = function(c) {
    return [0, 0, 0, c[0]];
  }, i.gray.lab = function(c) {
    return [c[0], 0, 0];
  }, i.gray.hex = function(c) {
    var l = Math.round(c[0] / 100 * 255) & 255, d = (l << 16) + (l << 8) + l, p = d.toString(16).toUpperCase();
    return "000000".substring(p.length) + p;
  }, i.rgb.gray = function(c) {
    var l = (c[0] + c[1] + c[2]) / 3;
    return [l / 255 * 100];
  }, wh.exports;
}
var Eh, W_;
function m8() {
  if (W_)
    return Eh;
  W_ = 1;
  var e = DO();
  function t() {
    for (var s = {}, a = Object.keys(e), o = a.length, c = 0; c < o; c++)
      s[a[c]] = {
        // http://jsperf.com/1-vs-infinity
        // micro-opt, but this is simple.
        distance: -1,
        parent: null
      };
    return s;
  }
  function r(s) {
    var a = t(), o = [s];
    for (a[s].distance = 0; o.length; )
      for (var c = o.pop(), l = Object.keys(e[c]), d = l.length, p = 0; p < d; p++) {
        var h = l[p], g = a[h];
        g.distance === -1 && (g.distance = a[c].distance + 1, g.parent = c, o.unshift(h));
      }
    return a;
  }
  function i(s, a) {
    return function(o) {
      return a(s(o));
    };
  }
  function n(s, a) {
    for (var o = [a[s].parent, s], c = e[a[s].parent][s], l = a[s].parent; a[l].parent; )
      o.unshift(a[l].parent), c = i(e[a[l].parent][l], c), l = a[l].parent;
    return c.conversion = o, c;
  }
  return Eh = function(s) {
    for (var a = r(s), o = {}, c = Object.keys(a), l = c.length, d = 0; d < l; d++) {
      var p = c[d], h = a[p];
      h.parent !== null && (o[p] = n(p, a));
    }
    return o;
  }, Eh;
}
var xh, H_;
function y8() {
  if (H_)
    return xh;
  H_ = 1;
  var e = DO(), t = m8(), r = {}, i = Object.keys(e);
  function n(a) {
    var o = function(c) {
      return c == null ? c : (arguments.length > 1 && (c = Array.prototype.slice.call(arguments)), a(c));
    };
    return "conversion" in a && (o.conversion = a.conversion), o;
  }
  function s(a) {
    var o = function(c) {
      if (c == null)
        return c;
      arguments.length > 1 && (c = Array.prototype.slice.call(arguments));
      var l = a(c);
      if (typeof l == "object")
        for (var d = l.length, p = 0; p < d; p++)
          l[p] = Math.round(l[p]);
      return l;
    };
    return "conversion" in a && (o.conversion = a.conversion), o;
  }
  return i.forEach(function(a) {
    r[a] = {}, Object.defineProperty(r[a], "channels", { value: e[a].channels }), Object.defineProperty(r[a], "labels", { value: e[a].labels });
    var o = t(a), c = Object.keys(o);
    c.forEach(function(l) {
      var d = o[l];
      r[a][l] = s(d), r[a][l].raw = n(d);
    });
  }), xh = r, xh;
}
Ol.exports;
var G_;
function g8() {
  return G_ || (G_ = 1, function(e) {
    const t = y8(), r = (a, o) => function() {
      return `\x1B[${a.apply(t, arguments) + o}m`;
    }, i = (a, o) => function() {
      const c = a.apply(t, arguments);
      return `\x1B[${38 + o};5;${c}m`;
    }, n = (a, o) => function() {
      const c = a.apply(t, arguments);
      return `\x1B[${38 + o};2;${c[0]};${c[1]};${c[2]}m`;
    };
    function s() {
      const a = /* @__PURE__ */ new Map(), o = {
        modifier: {
          reset: [0, 0],
          // 21 isn't widely supported and 22 does the same thing
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          gray: [90, 39],
          // Bright color
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          // Bright color
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      o.color.grey = o.color.gray;
      for (const d of Object.keys(o)) {
        const p = o[d];
        for (const h of Object.keys(p)) {
          const g = p[h];
          o[h] = {
            open: `\x1B[${g[0]}m`,
            close: `\x1B[${g[1]}m`
          }, p[h] = o[h], a.set(g[0], g[1]);
        }
        Object.defineProperty(o, d, {
          value: p,
          enumerable: !1
        }), Object.defineProperty(o, "codes", {
          value: a,
          enumerable: !1
        });
      }
      const c = (d) => d, l = (d, p, h) => [d, p, h];
      o.color.close = "\x1B[39m", o.bgColor.close = "\x1B[49m", o.color.ansi = {
        ansi: r(c, 0)
      }, o.color.ansi256 = {
        ansi256: i(c, 0)
      }, o.color.ansi16m = {
        rgb: n(l, 0)
      }, o.bgColor.ansi = {
        ansi: r(c, 10)
      }, o.bgColor.ansi256 = {
        ansi256: i(c, 10)
      }, o.bgColor.ansi16m = {
        rgb: n(l, 10)
      };
      for (let d of Object.keys(t)) {
        if (typeof t[d] != "object")
          continue;
        const p = t[d];
        d === "ansi16" && (d = "ansi"), "ansi16" in p && (o.color.ansi[d] = r(p.ansi16, 0), o.bgColor.ansi[d] = r(p.ansi16, 10)), "ansi256" in p && (o.color.ansi256[d] = i(p.ansi256, 0), o.bgColor.ansi256[d] = i(p.ansi256, 10)), "rgb" in p && (o.color.ansi16m[d] = n(p.rgb, 0), o.bgColor.ansi16m[d] = n(p.rgb, 10));
      }
      return o;
    }
    Object.defineProperty(e, "exports", {
      enumerable: !0,
      get: s
    });
  }(Ol)), Ol.exports;
}
var Oh, K_;
function v8() {
  return K_ || (K_ = 1, Oh = {
    stdout: !1,
    stderr: !1
  }), Oh;
}
var Ph, Y_;
function b8() {
  if (Y_)
    return Ph;
  Y_ = 1;
  const e = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi, t = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, r = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, i = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi, n = /* @__PURE__ */ new Map([
    ["n", `
`],
    ["r", "\r"],
    ["t", "	"],
    ["b", "\b"],
    ["f", "\f"],
    ["v", "\v"],
    ["0", "\0"],
    ["\\", "\\"],
    ["e", "\x1B"],
    ["a", "\x07"]
  ]);
  function s(l) {
    return l[0] === "u" && l.length === 5 || l[0] === "x" && l.length === 3 ? String.fromCharCode(parseInt(l.slice(1), 16)) : n.get(l) || l;
  }
  function a(l, d) {
    const p = [], h = d.trim().split(/\s*,\s*/g);
    let g;
    for (const m of h)
      if (!isNaN(m))
        p.push(Number(m));
      else if (g = m.match(r))
        p.push(g[2].replace(i, (v, _, y) => _ ? s(_) : y));
      else
        throw new Error(`Invalid Chalk template style argument: ${m} (in style '${l}')`);
    return p;
  }
  function o(l) {
    t.lastIndex = 0;
    const d = [];
    let p;
    for (; (p = t.exec(l)) !== null; ) {
      const h = p[1];
      if (p[2]) {
        const g = a(h, p[2]);
        d.push([h].concat(g));
      } else
        d.push([h]);
    }
    return d;
  }
  function c(l, d) {
    const p = {};
    for (const g of d)
      for (const m of g.styles)
        p[m[0]] = g.inverse ? null : m.slice(1);
    let h = l;
    for (const g of Object.keys(p))
      if (Array.isArray(p[g])) {
        if (!(g in h))
          throw new Error(`Unknown Chalk style: ${g}`);
        p[g].length > 0 ? h = h[g].apply(h, p[g]) : h = h[g];
      }
    return h;
  }
  return Ph = (l, d) => {
    const p = [], h = [];
    let g = [];
    if (d.replace(e, (m, v, _, y, w, $) => {
      if (v)
        g.push(s(v));
      else if (y) {
        const E = g.join("");
        g = [], h.push(p.length === 0 ? E : c(l, p)(E)), p.push({ inverse: _, styles: o(y) });
      } else if (w) {
        if (p.length === 0)
          throw new Error("Found extraneous } in Chalk template literal");
        h.push(c(l, p)(g.join(""))), g = [], p.pop();
      } else
        g.push($);
    }), h.push(g.join("")), p.length > 0) {
      const m = `Chalk template literal is missing ${p.length} closing bracket${p.length === 1 ? "" : "s"} (\`}\`)`;
      throw new Error(m);
    }
    return h.join("");
  }, Ph;
}
var J_;
function LO() {
  return J_ || (J_ = 1, function(e) {
    const t = p8(), r = g8(), i = v8().stdout, n = b8(), s = qe.process.platform === "win32" && !(qe.process.env.TERM || "").toLowerCase().startsWith("xterm"), a = ["ansi", "ansi", "ansi256", "ansi16m"], o = /* @__PURE__ */ new Set(["gray"]), c = /* @__PURE__ */ Object.create(null);
    function l(v, _) {
      _ = _ || {};
      const y = i ? i.level : 0;
      v.level = _.level === void 0 ? y : _.level, v.enabled = "enabled" in _ ? _.enabled : v.level > 0;
    }
    function d(v) {
      if (!this || !(this instanceof d) || this.template) {
        const _ = {};
        return l(_, v), _.template = function() {
          const y = [].slice.call(arguments);
          return m.apply(null, [_.template].concat(y));
        }, Object.setPrototypeOf(_, d.prototype), Object.setPrototypeOf(_.template, _), _.template.constructor = d, _.template;
      }
      l(this, v);
    }
    s && (r.blue.open = "\x1B[94m");
    for (const v of Object.keys(r))
      r[v].closeRe = new RegExp(t(r[v].close), "g"), c[v] = {
        get() {
          const _ = r[v];
          return h.call(this, this._styles ? this._styles.concat(_) : [_], this._empty, v);
        }
      };
    c.visible = {
      get() {
        return h.call(this, this._styles || [], !0, "visible");
      }
    }, r.color.closeRe = new RegExp(t(r.color.close), "g");
    for (const v of Object.keys(r.color.ansi))
      o.has(v) || (c[v] = {
        get() {
          const _ = this.level;
          return function() {
            const w = {
              open: r.color[a[_]][v].apply(null, arguments),
              close: r.color.close,
              closeRe: r.color.closeRe
            };
            return h.call(this, this._styles ? this._styles.concat(w) : [w], this._empty, v);
          };
        }
      });
    r.bgColor.closeRe = new RegExp(t(r.bgColor.close), "g");
    for (const v of Object.keys(r.bgColor.ansi)) {
      if (o.has(v))
        continue;
      const _ = "bg" + v[0].toUpperCase() + v.slice(1);
      c[_] = {
        get() {
          const y = this.level;
          return function() {
            const $ = {
              open: r.bgColor[a[y]][v].apply(null, arguments),
              close: r.bgColor.close,
              closeRe: r.bgColor.closeRe
            };
            return h.call(this, this._styles ? this._styles.concat($) : [$], this._empty, v);
          };
        }
      };
    }
    const p = Object.defineProperties(() => {
    }, c);
    function h(v, _, y) {
      const w = function() {
        return g.apply(w, arguments);
      };
      w._styles = v, w._empty = _;
      const $ = this;
      return Object.defineProperty(w, "level", {
        enumerable: !0,
        get() {
          return $.level;
        },
        set(E) {
          $.level = E;
        }
      }), Object.defineProperty(w, "enabled", {
        enumerable: !0,
        get() {
          return $.enabled;
        },
        set(E) {
          $.enabled = E;
        }
      }), w.hasGrey = this.hasGrey || y === "gray" || y === "grey", w.__proto__ = p, w;
    }
    function g() {
      const v = arguments, _ = v.length;
      let y = String(arguments[0]);
      if (_ === 0)
        return "";
      if (_ > 1)
        for (let $ = 1; $ < _; $++)
          y += " " + v[$];
      if (!this.enabled || this.level <= 0 || !y)
        return this._empty ? "" : y;
      const w = r.dim.open;
      s && this.hasGrey && (r.dim.open = "");
      for (const $ of this._styles.slice().reverse())
        y = $.open + y.replace($.closeRe, $.open) + $.close, y = y.replace(/\r?\n/g, `${$.close}$&${$.open}`);
      return r.dim.open = w, y;
    }
    function m(v, _) {
      if (!Array.isArray(_))
        return [].slice.call(arguments, 1).join(" ");
      const y = [].slice.call(arguments, 2), w = [_.raw[0]];
      for (let $ = 1; $ < _.length; $++)
        w.push(String(y[$ - 1]).replace(/[{}\\]/g, "\\$&")), w.push(String(_.raw[$]));
      return n(v, w.join(""));
    }
    Object.defineProperties(d.prototype, c), e.exports = d(), e.exports.supportsColor = i, e.exports.default = e.exports;
  }(bh)), bh.exports;
}
var X_;
function _8() {
  if (X_)
    return Oa;
  X_ = 1, Object.defineProperty(Oa, "__esModule", {
    value: !0
  }), Oa.default = m, Oa.shouldHighlight = p;
  var e = c8(), t = d8(), r = n(LO(), !0);
  function i(v) {
    if (typeof WeakMap != "function")
      return null;
    var _ = /* @__PURE__ */ new WeakMap(), y = /* @__PURE__ */ new WeakMap();
    return (i = function(w) {
      return w ? y : _;
    })(v);
  }
  function n(v, _) {
    if (!_ && v && v.__esModule)
      return v;
    if (v === null || typeof v != "object" && typeof v != "function")
      return { default: v };
    var y = i(_);
    if (y && y.has(v))
      return y.get(v);
    var w = {}, $ = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var E in v)
      if (E !== "default" && Object.prototype.hasOwnProperty.call(v, E)) {
        var S = $ ? Object.getOwnPropertyDescriptor(v, E) : null;
        S && (S.get || S.set) ? Object.defineProperty(w, E, S) : w[E] = v[E];
      }
    return w.default = v, y && y.set(v, w), w;
  }
  const s = /* @__PURE__ */ new Set(["as", "async", "from", "get", "of", "set"]);
  function a(v) {
    return {
      keyword: v.cyan,
      capitalized: v.yellow,
      jsxIdentifier: v.yellow,
      punctuator: v.yellow,
      number: v.magenta,
      string: v.green,
      regex: v.magenta,
      comment: v.grey,
      invalid: v.white.bgRed.bold
    };
  }
  const o = /\r\n|[\n\r\u2028\u2029]/, c = /^[()[\]{}]$/;
  let l;
  {
    const v = /^[a-z][\w-]*$/i, _ = function(y, w, $) {
      if (y.type === "name") {
        if ((0, t.isKeyword)(y.value) || (0, t.isStrictReservedWord)(y.value, !0) || s.has(y.value))
          return "keyword";
        if (v.test(y.value) && ($[w - 1] === "<" || $.slice(w - 2, w) == "</"))
          return "jsxIdentifier";
        if (y.value[0] !== y.value[0].toLowerCase())
          return "capitalized";
      }
      return y.type === "punctuator" && c.test(y.value) ? "bracket" : y.type === "invalid" && (y.value === "@" || y.value === "#") ? "punctuator" : y.type;
    };
    l = function* (y) {
      let w;
      for (; w = e.default.exec(y); ) {
        const $ = e.matchToToken(w);
        yield {
          type: _($, w.index, y),
          value: $.value
        };
      }
    };
  }
  function d(v, _) {
    let y = "";
    for (const {
      type: w,
      value: $
    } of l(_)) {
      const E = v[w];
      E ? y += $.split(o).map((S) => E(S)).join(`
`) : y += $;
    }
    return y;
  }
  function p(v) {
    return r.default.level > 0 || v.forceColor;
  }
  let h;
  function g(v) {
    if (v) {
      var _;
      return (_ = h) != null || (h = new r.default.constructor({
        enabled: !0,
        level: 1
      })), h;
    }
    return r.default;
  }
  Oa.getChalk = (v) => g(v.forceColor);
  function m(v, _ = {}) {
    if (v !== "" && p(_)) {
      const y = a(g(_.forceColor));
      return d(y, v);
    } else
      return v;
  }
  return Oa;
}
var Q_;
function w8() {
  if (Q_)
    return Fo;
  Q_ = 1, Object.defineProperty(Fo, "__esModule", {
    value: !0
  }), Fo.codeFrameColumns = d, Fo.default = p;
  var e = _8(), t = i(LO(), !0);
  function r(h) {
    if (typeof WeakMap != "function")
      return null;
    var g = /* @__PURE__ */ new WeakMap(), m = /* @__PURE__ */ new WeakMap();
    return (r = function(v) {
      return v ? m : g;
    })(h);
  }
  function i(h, g) {
    if (!g && h && h.__esModule)
      return h;
    if (h === null || typeof h != "object" && typeof h != "function")
      return { default: h };
    var m = r(g);
    if (m && m.has(h))
      return m.get(h);
    var v = {}, _ = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var y in h)
      if (y !== "default" && Object.prototype.hasOwnProperty.call(h, y)) {
        var w = _ ? Object.getOwnPropertyDescriptor(h, y) : null;
        w && (w.get || w.set) ? Object.defineProperty(v, y, w) : v[y] = h[y];
      }
    return v.default = h, m && m.set(h, v), v;
  }
  let n;
  function s(h) {
    if (h) {
      var g;
      return (g = n) != null || (n = new t.default.constructor({
        enabled: !0,
        level: 1
      })), n;
    }
    return t.default;
  }
  let a = !1;
  function o(h) {
    return {
      gutter: h.grey,
      marker: h.red.bold,
      message: h.red.bold
    };
  }
  const c = /\r\n|[\n\r\u2028\u2029]/;
  function l(h, g, m) {
    const v = Object.assign({
      column: 0,
      line: -1
    }, h.start), _ = Object.assign({}, v, h.end), {
      linesAbove: y = 2,
      linesBelow: w = 3
    } = m || {}, $ = v.line, E = v.column, S = _.line, R = _.column;
    let j = Math.max($ - (y + 1), 0), L = Math.min(g.length, S + w);
    $ === -1 && (j = 0), S === -1 && (L = g.length);
    const K = S - $, ae = {};
    if (K)
      for (let ye = 0; ye <= K; ye++) {
        const xe = ye + $;
        if (!E)
          ae[xe] = !0;
        else if (ye === 0) {
          const Pe = g[xe - 1].length;
          ae[xe] = [E, Pe - E + 1];
        } else if (ye === K)
          ae[xe] = [0, R];
        else {
          const Pe = g[xe - ye].length;
          ae[xe] = [0, Pe];
        }
      }
    else
      E === R ? E ? ae[$] = [E, 0] : ae[$] = !0 : ae[$] = [E, R - E];
    return {
      start: j,
      end: L,
      markerLines: ae
    };
  }
  function d(h, g, m = {}) {
    const v = (m.highlightCode || m.forceColor) && (0, e.shouldHighlight)(m), _ = s(m.forceColor), y = o(_), w = (ye, xe) => v ? ye(xe) : xe, $ = h.split(c), {
      start: E,
      end: S,
      markerLines: R
    } = l(g, $, m), j = g.start && typeof g.start.column == "number", L = String(S).length;
    let ae = (v ? (0, e.default)(h, m) : h).split(c, S).slice(E, S).map((ye, xe) => {
      const Pe = E + 1 + xe, pe = ` ${` ${Pe}`.slice(-L)} |`, de = R[Pe], Ee = !R[Pe + 1];
      if (de) {
        let Re = "";
        if (Array.isArray(de)) {
          const _e = ye.slice(0, Math.max(de[0] - 1, 0)).replace(/[^\t]/g, " "), ie = de[1] || 1;
          Re = [`
 `, w(y.gutter, pe.replace(/\d/g, " ")), " ", _e, w(y.marker, "^").repeat(ie)].join(""), Ee && m.message && (Re += " " + w(y.message, m.message));
        }
        return [w(y.marker, ">"), w(y.gutter, pe), ye.length > 0 ? ` ${ye}` : "", Re].join("");
      } else
        return ` ${w(y.gutter, pe)}${ye.length > 0 ? ` ${ye}` : ""}`;
    }).join(`
`);
    return m.message && !j && (ae = `${" ".repeat(L + 1)}${m.message}
${ae}`), v ? _.reset(ae) : ae;
  }
  function p(h, g, m, v = {}) {
    if (!a) {
      a = !0;
      const y = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
      if (qe.process.emitWarning)
        qe.process.emitWarning(y, "DeprecationWarning");
      else {
        const w = new Error(y);
        w.name = "DeprecationWarning", console.warn(new Error(y));
      }
    }
    return m = Math.max(m, 0), d(h, {
      start: {
        column: m,
        line: g
      }
    }, v);
  }
  return Fo;
}
var Pl = { exports: {} }, Sh, ew;
function $8() {
  return ew || (ew = 1, Sh = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  }), Sh;
}
var Ah, tw;
function qO() {
  if (tw)
    return Ah;
  tw = 1;
  const e = $8(), t = {};
  for (const n of Object.keys(e))
    t[e[n]] = n;
  const r = {
    rgb: { channels: 3, labels: "rgb" },
    hsl: { channels: 3, labels: "hsl" },
    hsv: { channels: 3, labels: "hsv" },
    hwb: { channels: 3, labels: "hwb" },
    cmyk: { channels: 4, labels: "cmyk" },
    xyz: { channels: 3, labels: "xyz" },
    lab: { channels: 3, labels: "lab" },
    lch: { channels: 3, labels: "lch" },
    hex: { channels: 1, labels: ["hex"] },
    keyword: { channels: 1, labels: ["keyword"] },
    ansi16: { channels: 1, labels: ["ansi16"] },
    ansi256: { channels: 1, labels: ["ansi256"] },
    hcg: { channels: 3, labels: ["h", "c", "g"] },
    apple: { channels: 3, labels: ["r16", "g16", "b16"] },
    gray: { channels: 1, labels: ["gray"] }
  };
  Ah = r;
  for (const n of Object.keys(r)) {
    if (!("channels" in r[n]))
      throw new Error("missing channels property: " + n);
    if (!("labels" in r[n]))
      throw new Error("missing channel labels property: " + n);
    if (r[n].labels.length !== r[n].channels)
      throw new Error("channel and label counts mismatch: " + n);
    const { channels: s, labels: a } = r[n];
    delete r[n].channels, delete r[n].labels, Object.defineProperty(r[n], "channels", { value: s }), Object.defineProperty(r[n], "labels", { value: a });
  }
  r.rgb.hsl = function(n) {
    const s = n[0] / 255, a = n[1] / 255, o = n[2] / 255, c = Math.min(s, a, o), l = Math.max(s, a, o), d = l - c;
    let p, h;
    l === c ? p = 0 : s === l ? p = (a - o) / d : a === l ? p = 2 + (o - s) / d : o === l && (p = 4 + (s - a) / d), p = Math.min(p * 60, 360), p < 0 && (p += 360);
    const g = (c + l) / 2;
    return l === c ? h = 0 : g <= 0.5 ? h = d / (l + c) : h = d / (2 - l - c), [p, h * 100, g * 100];
  }, r.rgb.hsv = function(n) {
    let s, a, o, c, l;
    const d = n[0] / 255, p = n[1] / 255, h = n[2] / 255, g = Math.max(d, p, h), m = g - Math.min(d, p, h), v = function(_) {
      return (g - _) / 6 / m + 1 / 2;
    };
    return m === 0 ? (c = 0, l = 0) : (l = m / g, s = v(d), a = v(p), o = v(h), d === g ? c = o - a : p === g ? c = 1 / 3 + s - o : h === g && (c = 2 / 3 + a - s), c < 0 ? c += 1 : c > 1 && (c -= 1)), [
      c * 360,
      l * 100,
      g * 100
    ];
  }, r.rgb.hwb = function(n) {
    const s = n[0], a = n[1];
    let o = n[2];
    const c = r.rgb.hsl(n)[0], l = 1 / 255 * Math.min(s, Math.min(a, o));
    return o = 1 - 1 / 255 * Math.max(s, Math.max(a, o)), [c, l * 100, o * 100];
  }, r.rgb.cmyk = function(n) {
    const s = n[0] / 255, a = n[1] / 255, o = n[2] / 255, c = Math.min(1 - s, 1 - a, 1 - o), l = (1 - s - c) / (1 - c) || 0, d = (1 - a - c) / (1 - c) || 0, p = (1 - o - c) / (1 - c) || 0;
    return [l * 100, d * 100, p * 100, c * 100];
  };
  function i(n, s) {
    return (n[0] - s[0]) ** 2 + (n[1] - s[1]) ** 2 + (n[2] - s[2]) ** 2;
  }
  return r.rgb.keyword = function(n) {
    const s = t[n];
    if (s)
      return s;
    let a = 1 / 0, o;
    for (const c of Object.keys(e)) {
      const l = e[c], d = i(n, l);
      d < a && (a = d, o = c);
    }
    return o;
  }, r.keyword.rgb = function(n) {
    return e[n];
  }, r.rgb.xyz = function(n) {
    let s = n[0] / 255, a = n[1] / 255, o = n[2] / 255;
    s = s > 0.04045 ? ((s + 0.055) / 1.055) ** 2.4 : s / 12.92, a = a > 0.04045 ? ((a + 0.055) / 1.055) ** 2.4 : a / 12.92, o = o > 0.04045 ? ((o + 0.055) / 1.055) ** 2.4 : o / 12.92;
    const c = s * 0.4124 + a * 0.3576 + o * 0.1805, l = s * 0.2126 + a * 0.7152 + o * 0.0722, d = s * 0.0193 + a * 0.1192 + o * 0.9505;
    return [c * 100, l * 100, d * 100];
  }, r.rgb.lab = function(n) {
    const s = r.rgb.xyz(n);
    let a = s[0], o = s[1], c = s[2];
    a /= 95.047, o /= 100, c /= 108.883, a = a > 8856e-6 ? a ** (1 / 3) : 7.787 * a + 16 / 116, o = o > 8856e-6 ? o ** (1 / 3) : 7.787 * o + 16 / 116, c = c > 8856e-6 ? c ** (1 / 3) : 7.787 * c + 16 / 116;
    const l = 116 * o - 16, d = 500 * (a - o), p = 200 * (o - c);
    return [l, d, p];
  }, r.hsl.rgb = function(n) {
    const s = n[0] / 360, a = n[1] / 100, o = n[2] / 100;
    let c, l, d;
    if (a === 0)
      return d = o * 255, [d, d, d];
    o < 0.5 ? c = o * (1 + a) : c = o + a - o * a;
    const p = 2 * o - c, h = [0, 0, 0];
    for (let g = 0; g < 3; g++)
      l = s + 1 / 3 * -(g - 1), l < 0 && l++, l > 1 && l--, 6 * l < 1 ? d = p + (c - p) * 6 * l : 2 * l < 1 ? d = c : 3 * l < 2 ? d = p + (c - p) * (2 / 3 - l) * 6 : d = p, h[g] = d * 255;
    return h;
  }, r.hsl.hsv = function(n) {
    const s = n[0];
    let a = n[1] / 100, o = n[2] / 100, c = a;
    const l = Math.max(o, 0.01);
    o *= 2, a *= o <= 1 ? o : 2 - o, c *= l <= 1 ? l : 2 - l;
    const d = (o + a) / 2, p = o === 0 ? 2 * c / (l + c) : 2 * a / (o + a);
    return [s, p * 100, d * 100];
  }, r.hsv.rgb = function(n) {
    const s = n[0] / 60, a = n[1] / 100;
    let o = n[2] / 100;
    const c = Math.floor(s) % 6, l = s - Math.floor(s), d = 255 * o * (1 - a), p = 255 * o * (1 - a * l), h = 255 * o * (1 - a * (1 - l));
    switch (o *= 255, c) {
      case 0:
        return [o, h, d];
      case 1:
        return [p, o, d];
      case 2:
        return [d, o, h];
      case 3:
        return [d, p, o];
      case 4:
        return [h, d, o];
      case 5:
        return [o, d, p];
    }
  }, r.hsv.hsl = function(n) {
    const s = n[0], a = n[1] / 100, o = n[2] / 100, c = Math.max(o, 0.01);
    let l, d;
    d = (2 - a) * o;
    const p = (2 - a) * c;
    return l = a * c, l /= p <= 1 ? p : 2 - p, l = l || 0, d /= 2, [s, l * 100, d * 100];
  }, r.hwb.rgb = function(n) {
    const s = n[0] / 360;
    let a = n[1] / 100, o = n[2] / 100;
    const c = a + o;
    let l;
    c > 1 && (a /= c, o /= c);
    const d = Math.floor(6 * s), p = 1 - o;
    l = 6 * s - d, d & 1 && (l = 1 - l);
    const h = a + l * (p - a);
    let g, m, v;
    switch (d) {
      default:
      case 6:
      case 0:
        g = p, m = h, v = a;
        break;
      case 1:
        g = h, m = p, v = a;
        break;
      case 2:
        g = a, m = p, v = h;
        break;
      case 3:
        g = a, m = h, v = p;
        break;
      case 4:
        g = h, m = a, v = p;
        break;
      case 5:
        g = p, m = a, v = h;
        break;
    }
    return [g * 255, m * 255, v * 255];
  }, r.cmyk.rgb = function(n) {
    const s = n[0] / 100, a = n[1] / 100, o = n[2] / 100, c = n[3] / 100, l = 1 - Math.min(1, s * (1 - c) + c), d = 1 - Math.min(1, a * (1 - c) + c), p = 1 - Math.min(1, o * (1 - c) + c);
    return [l * 255, d * 255, p * 255];
  }, r.xyz.rgb = function(n) {
    const s = n[0] / 100, a = n[1] / 100, o = n[2] / 100;
    let c, l, d;
    return c = s * 3.2406 + a * -1.5372 + o * -0.4986, l = s * -0.9689 + a * 1.8758 + o * 0.0415, d = s * 0.0557 + a * -0.204 + o * 1.057, c = c > 31308e-7 ? 1.055 * c ** (1 / 2.4) - 0.055 : c * 12.92, l = l > 31308e-7 ? 1.055 * l ** (1 / 2.4) - 0.055 : l * 12.92, d = d > 31308e-7 ? 1.055 * d ** (1 / 2.4) - 0.055 : d * 12.92, c = Math.min(Math.max(0, c), 1), l = Math.min(Math.max(0, l), 1), d = Math.min(Math.max(0, d), 1), [c * 255, l * 255, d * 255];
  }, r.xyz.lab = function(n) {
    let s = n[0], a = n[1], o = n[2];
    s /= 95.047, a /= 100, o /= 108.883, s = s > 8856e-6 ? s ** (1 / 3) : 7.787 * s + 16 / 116, a = a > 8856e-6 ? a ** (1 / 3) : 7.787 * a + 16 / 116, o = o > 8856e-6 ? o ** (1 / 3) : 7.787 * o + 16 / 116;
    const c = 116 * a - 16, l = 500 * (s - a), d = 200 * (a - o);
    return [c, l, d];
  }, r.lab.xyz = function(n) {
    const s = n[0], a = n[1], o = n[2];
    let c, l, d;
    l = (s + 16) / 116, c = a / 500 + l, d = l - o / 200;
    const p = l ** 3, h = c ** 3, g = d ** 3;
    return l = p > 8856e-6 ? p : (l - 16 / 116) / 7.787, c = h > 8856e-6 ? h : (c - 16 / 116) / 7.787, d = g > 8856e-6 ? g : (d - 16 / 116) / 7.787, c *= 95.047, l *= 100, d *= 108.883, [c, l, d];
  }, r.lab.lch = function(n) {
    const s = n[0], a = n[1], o = n[2];
    let c;
    c = Math.atan2(o, a) * 360 / 2 / Math.PI, c < 0 && (c += 360);
    const d = Math.sqrt(a * a + o * o);
    return [s, d, c];
  }, r.lch.lab = function(n) {
    const s = n[0], a = n[1], c = n[2] / 360 * 2 * Math.PI, l = a * Math.cos(c), d = a * Math.sin(c);
    return [s, l, d];
  }, r.rgb.ansi16 = function(n, s = null) {
    const [a, o, c] = n;
    let l = s === null ? r.rgb.hsv(n)[2] : s;
    if (l = Math.round(l / 50), l === 0)
      return 30;
    let d = 30 + (Math.round(c / 255) << 2 | Math.round(o / 255) << 1 | Math.round(a / 255));
    return l === 2 && (d += 60), d;
  }, r.hsv.ansi16 = function(n) {
    return r.rgb.ansi16(r.hsv.rgb(n), n[2]);
  }, r.rgb.ansi256 = function(n) {
    const s = n[0], a = n[1], o = n[2];
    return s === a && a === o ? s < 8 ? 16 : s > 248 ? 231 : Math.round((s - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(s / 255 * 5) + 6 * Math.round(a / 255 * 5) + Math.round(o / 255 * 5);
  }, r.ansi16.rgb = function(n) {
    let s = n % 10;
    if (s === 0 || s === 7)
      return n > 50 && (s += 3.5), s = s / 10.5 * 255, [s, s, s];
    const a = (~~(n > 50) + 1) * 0.5, o = (s & 1) * a * 255, c = (s >> 1 & 1) * a * 255, l = (s >> 2 & 1) * a * 255;
    return [o, c, l];
  }, r.ansi256.rgb = function(n) {
    if (n >= 232) {
      const l = (n - 232) * 10 + 8;
      return [l, l, l];
    }
    n -= 16;
    let s;
    const a = Math.floor(n / 36) / 5 * 255, o = Math.floor((s = n % 36) / 6) / 5 * 255, c = s % 6 / 5 * 255;
    return [a, o, c];
  }, r.rgb.hex = function(n) {
    const a = (((Math.round(n[0]) & 255) << 16) + ((Math.round(n[1]) & 255) << 8) + (Math.round(n[2]) & 255)).toString(16).toUpperCase();
    return "000000".substring(a.length) + a;
  }, r.hex.rgb = function(n) {
    const s = n.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!s)
      return [0, 0, 0];
    let a = s[0];
    s[0].length === 3 && (a = a.split("").map((p) => p + p).join(""));
    const o = parseInt(a, 16), c = o >> 16 & 255, l = o >> 8 & 255, d = o & 255;
    return [c, l, d];
  }, r.rgb.hcg = function(n) {
    const s = n[0] / 255, a = n[1] / 255, o = n[2] / 255, c = Math.max(Math.max(s, a), o), l = Math.min(Math.min(s, a), o), d = c - l;
    let p, h;
    return d < 1 ? p = l / (1 - d) : p = 0, d <= 0 ? h = 0 : c === s ? h = (a - o) / d % 6 : c === a ? h = 2 + (o - s) / d : h = 4 + (s - a) / d, h /= 6, h %= 1, [h * 360, d * 100, p * 100];
  }, r.hsl.hcg = function(n) {
    const s = n[1] / 100, a = n[2] / 100, o = a < 0.5 ? 2 * s * a : 2 * s * (1 - a);
    let c = 0;
    return o < 1 && (c = (a - 0.5 * o) / (1 - o)), [n[0], o * 100, c * 100];
  }, r.hsv.hcg = function(n) {
    const s = n[1] / 100, a = n[2] / 100, o = s * a;
    let c = 0;
    return o < 1 && (c = (a - o) / (1 - o)), [n[0], o * 100, c * 100];
  }, r.hcg.rgb = function(n) {
    const s = n[0] / 360, a = n[1] / 100, o = n[2] / 100;
    if (a === 0)
      return [o * 255, o * 255, o * 255];
    const c = [0, 0, 0], l = s % 1 * 6, d = l % 1, p = 1 - d;
    let h = 0;
    switch (Math.floor(l)) {
      case 0:
        c[0] = 1, c[1] = d, c[2] = 0;
        break;
      case 1:
        c[0] = p, c[1] = 1, c[2] = 0;
        break;
      case 2:
        c[0] = 0, c[1] = 1, c[2] = d;
        break;
      case 3:
        c[0] = 0, c[1] = p, c[2] = 1;
        break;
      case 4:
        c[0] = d, c[1] = 0, c[2] = 1;
        break;
      default:
        c[0] = 1, c[1] = 0, c[2] = p;
    }
    return h = (1 - a) * o, [
      (a * c[0] + h) * 255,
      (a * c[1] + h) * 255,
      (a * c[2] + h) * 255
    ];
  }, r.hcg.hsv = function(n) {
    const s = n[1] / 100, a = n[2] / 100, o = s + a * (1 - s);
    let c = 0;
    return o > 0 && (c = s / o), [n[0], c * 100, o * 100];
  }, r.hcg.hsl = function(n) {
    const s = n[1] / 100, o = n[2] / 100 * (1 - s) + 0.5 * s;
    let c = 0;
    return o > 0 && o < 0.5 ? c = s / (2 * o) : o >= 0.5 && o < 1 && (c = s / (2 * (1 - o))), [n[0], c * 100, o * 100];
  }, r.hcg.hwb = function(n) {
    const s = n[1] / 100, a = n[2] / 100, o = s + a * (1 - s);
    return [n[0], (o - s) * 100, (1 - o) * 100];
  }, r.hwb.hcg = function(n) {
    const s = n[1] / 100, o = 1 - n[2] / 100, c = o - s;
    let l = 0;
    return c < 1 && (l = (o - c) / (1 - c)), [n[0], c * 100, l * 100];
  }, r.apple.rgb = function(n) {
    return [n[0] / 65535 * 255, n[1] / 65535 * 255, n[2] / 65535 * 255];
  }, r.rgb.apple = function(n) {
    return [n[0] / 255 * 65535, n[1] / 255 * 65535, n[2] / 255 * 65535];
  }, r.gray.rgb = function(n) {
    return [n[0] / 100 * 255, n[0] / 100 * 255, n[0] / 100 * 255];
  }, r.gray.hsl = function(n) {
    return [0, 0, n[0]];
  }, r.gray.hsv = r.gray.hsl, r.gray.hwb = function(n) {
    return [0, 100, n[0]];
  }, r.gray.cmyk = function(n) {
    return [0, 0, 0, n[0]];
  }, r.gray.lab = function(n) {
    return [n[0], 0, 0];
  }, r.gray.hex = function(n) {
    const s = Math.round(n[0] / 100 * 255) & 255, o = ((s << 16) + (s << 8) + s).toString(16).toUpperCase();
    return "000000".substring(o.length) + o;
  }, r.rgb.gray = function(n) {
    return [(n[0] + n[1] + n[2]) / 3 / 255 * 100];
  }, Ah;
}
var Ch, rw;
function E8() {
  if (rw)
    return Ch;
  rw = 1;
  const e = qO();
  function t() {
    const s = {}, a = Object.keys(e);
    for (let o = a.length, c = 0; c < o; c++)
      s[a[c]] = {
        // http://jsperf.com/1-vs-infinity
        // micro-opt, but this is simple.
        distance: -1,
        parent: null
      };
    return s;
  }
  function r(s) {
    const a = t(), o = [s];
    for (a[s].distance = 0; o.length; ) {
      const c = o.pop(), l = Object.keys(e[c]);
      for (let d = l.length, p = 0; p < d; p++) {
        const h = l[p], g = a[h];
        g.distance === -1 && (g.distance = a[c].distance + 1, g.parent = c, o.unshift(h));
      }
    }
    return a;
  }
  function i(s, a) {
    return function(o) {
      return a(s(o));
    };
  }
  function n(s, a) {
    const o = [a[s].parent, s];
    let c = e[a[s].parent][s], l = a[s].parent;
    for (; a[l].parent; )
      o.unshift(a[l].parent), c = i(e[a[l].parent][l], c), l = a[l].parent;
    return c.conversion = o, c;
  }
  return Ch = function(s) {
    const a = r(s), o = {}, c = Object.keys(a);
    for (let l = c.length, d = 0; d < l; d++) {
      const p = c[d];
      a[p].parent !== null && (o[p] = n(p, a));
    }
    return o;
  }, Ch;
}
var Rh, nw;
function x8() {
  if (nw)
    return Rh;
  nw = 1;
  const e = qO(), t = E8(), r = {}, i = Object.keys(e);
  function n(a) {
    const o = function(...c) {
      const l = c[0];
      return l == null ? l : (l.length > 1 && (c = l), a(c));
    };
    return "conversion" in a && (o.conversion = a.conversion), o;
  }
  function s(a) {
    const o = function(...c) {
      const l = c[0];
      if (l == null)
        return l;
      l.length > 1 && (c = l);
      const d = a(c);
      if (typeof d == "object")
        for (let p = d.length, h = 0; h < p; h++)
          d[h] = Math.round(d[h]);
      return d;
    };
    return "conversion" in a && (o.conversion = a.conversion), o;
  }
  return i.forEach((a) => {
    r[a] = {}, Object.defineProperty(r[a], "channels", { value: e[a].channels }), Object.defineProperty(r[a], "labels", { value: e[a].labels });
    const o = t(a);
    Object.keys(o).forEach((l) => {
      const d = o[l];
      r[a][l] = s(d), r[a][l].raw = n(d);
    });
  }), Rh = r, Rh;
}
Pl.exports;
var iw;
function O8() {
  return iw || (iw = 1, function(e) {
    const t = (d, p) => (...h) => `\x1B[${d(...h) + p}m`, r = (d, p) => (...h) => {
      const g = d(...h);
      return `\x1B[${38 + p};5;${g}m`;
    }, i = (d, p) => (...h) => {
      const g = d(...h);
      return `\x1B[${38 + p};2;${g[0]};${g[1]};${g[2]}m`;
    }, n = (d) => d, s = (d, p, h) => [d, p, h], a = (d, p, h) => {
      Object.defineProperty(d, p, {
        get: () => {
          const g = h();
          return Object.defineProperty(d, p, {
            value: g,
            enumerable: !0,
            configurable: !0
          }), g;
        },
        enumerable: !0,
        configurable: !0
      });
    };
    let o;
    const c = (d, p, h, g) => {
      o === void 0 && (o = x8());
      const m = g ? 10 : 0, v = {};
      for (const [_, y] of Object.entries(o)) {
        const w = _ === "ansi16" ? "ansi" : _;
        _ === p ? v[w] = d(h, m) : typeof y == "object" && (v[w] = d(y[p], m));
      }
      return v;
    };
    function l() {
      const d = /* @__PURE__ */ new Map(), p = {
        modifier: {
          reset: [0, 0],
          // 21 isn't widely supported and 22 does the same thing
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          // Bright color
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          // Bright color
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      p.color.gray = p.color.blackBright, p.bgColor.bgGray = p.bgColor.bgBlackBright, p.color.grey = p.color.blackBright, p.bgColor.bgGrey = p.bgColor.bgBlackBright;
      for (const [h, g] of Object.entries(p)) {
        for (const [m, v] of Object.entries(g))
          p[m] = {
            open: `\x1B[${v[0]}m`,
            close: `\x1B[${v[1]}m`
          }, g[m] = p[m], d.set(v[0], v[1]);
        Object.defineProperty(p, h, {
          value: g,
          enumerable: !1
        });
      }
      return Object.defineProperty(p, "codes", {
        value: d,
        enumerable: !1
      }), p.color.close = "\x1B[39m", p.bgColor.close = "\x1B[49m", a(p.color, "ansi", () => c(t, "ansi16", n, !1)), a(p.color, "ansi256", () => c(r, "ansi256", n, !1)), a(p.color, "ansi16m", () => c(i, "rgb", s, !1)), a(p.bgColor, "ansi", () => c(t, "ansi16", n, !0)), a(p.bgColor, "ansi256", () => c(r, "ansi256", n, !0)), a(p.bgColor, "ansi16m", () => c(i, "rgb", s, !0)), p;
    }
    Object.defineProperty(e, "exports", {
      enumerable: !0,
      get: l
    });
  }(Pl)), Pl.exports;
}
var Th, sw;
function P8() {
  return sw || (sw = 1, Th = {
    stdout: !1,
    stderr: !1
  }), Th;
}
var Ih, aw;
function S8() {
  return aw || (aw = 1, Ih = {
    stringReplaceAll: (r, i, n) => {
      let s = r.indexOf(i);
      if (s === -1)
        return r;
      const a = i.length;
      let o = 0, c = "";
      do
        c += r.substr(o, s - o) + i + n, o = s + a, s = r.indexOf(i, o);
      while (s !== -1);
      return c += r.substr(o), c;
    },
    stringEncaseCRLFWithFirstIndex: (r, i, n, s) => {
      let a = 0, o = "";
      do {
        const c = r[s - 1] === "\r";
        o += r.substr(a, (c ? s - 1 : s) - a) + i + (c ? `\r
` : `
`) + n, a = s + 1, s = r.indexOf(`
`, a);
      } while (s !== -1);
      return o += r.substr(a), o;
    }
  }), Ih;
}
var jh, ow;
function A8() {
  if (ow)
    return jh;
  ow = 1;
  const e = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi, t = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, r = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, i = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi, n = /* @__PURE__ */ new Map([
    ["n", `
`],
    ["r", "\r"],
    ["t", "	"],
    ["b", "\b"],
    ["f", "\f"],
    ["v", "\v"],
    ["0", "\0"],
    ["\\", "\\"],
    ["e", "\x1B"],
    ["a", "\x07"]
  ]);
  function s(l) {
    const d = l[0] === "u", p = l[1] === "{";
    return d && !p && l.length === 5 || l[0] === "x" && l.length === 3 ? String.fromCharCode(parseInt(l.slice(1), 16)) : d && p ? String.fromCodePoint(parseInt(l.slice(2, -1), 16)) : n.get(l) || l;
  }
  function a(l, d) {
    const p = [], h = d.trim().split(/\s*,\s*/g);
    let g;
    for (const m of h) {
      const v = Number(m);
      if (!Number.isNaN(v))
        p.push(v);
      else if (g = m.match(r))
        p.push(g[2].replace(i, (_, y, w) => y ? s(y) : w));
      else
        throw new Error(`Invalid Chalk template style argument: ${m} (in style '${l}')`);
    }
    return p;
  }
  function o(l) {
    t.lastIndex = 0;
    const d = [];
    let p;
    for (; (p = t.exec(l)) !== null; ) {
      const h = p[1];
      if (p[2]) {
        const g = a(h, p[2]);
        d.push([h].concat(g));
      } else
        d.push([h]);
    }
    return d;
  }
  function c(l, d) {
    const p = {};
    for (const g of d)
      for (const m of g.styles)
        p[m[0]] = g.inverse ? null : m.slice(1);
    let h = l;
    for (const [g, m] of Object.entries(p))
      if (Array.isArray(m)) {
        if (!(g in h))
          throw new Error(`Unknown Chalk style: ${g}`);
        h = m.length > 0 ? h[g](...m) : h[g];
      }
    return h;
  }
  return jh = (l, d) => {
    const p = [], h = [];
    let g = [];
    if (d.replace(e, (m, v, _, y, w, $) => {
      if (v)
        g.push(s(v));
      else if (y) {
        const E = g.join("");
        g = [], h.push(p.length === 0 ? E : c(l, p)(E)), p.push({ inverse: _, styles: o(y) });
      } else if (w) {
        if (p.length === 0)
          throw new Error("Found extraneous } in Chalk template literal");
        h.push(c(l, p)(g.join(""))), g = [], p.pop();
      } else
        g.push($);
    }), h.push(g.join("")), p.length > 0) {
      const m = `Chalk template literal is missing ${p.length} closing bracket${p.length === 1 ? "" : "s"} (\`}\`)`;
      throw new Error(m);
    }
    return h.join("");
  }, jh;
}
var kh, uw;
function C8() {
  if (uw)
    return kh;
  uw = 1;
  const e = O8(), { stdout: t, stderr: r } = P8(), {
    stringReplaceAll: i,
    stringEncaseCRLFWithFirstIndex: n
  } = S8(), { isArray: s } = Array, a = [
    "ansi",
    "ansi",
    "ansi256",
    "ansi16m"
  ], o = /* @__PURE__ */ Object.create(null), c = (E, S = {}) => {
    if (S.level && !(Number.isInteger(S.level) && S.level >= 0 && S.level <= 3))
      throw new Error("The `level` option should be an integer from 0 to 3");
    const R = t ? t.level : 0;
    E.level = S.level === void 0 ? R : S.level;
  };
  class l {
    constructor(S) {
      return d(S);
    }
  }
  const d = (E) => {
    const S = {};
    return c(S, E), S.template = (...R) => w(S.template, ...R), Object.setPrototypeOf(S, p.prototype), Object.setPrototypeOf(S.template, S), S.template.constructor = () => {
      throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
    }, S.template.Instance = l, S.template;
  };
  function p(E) {
    return d(E);
  }
  for (const [E, S] of Object.entries(e))
    o[E] = {
      get() {
        const R = v(this, m(S.open, S.close, this._styler), this._isEmpty);
        return Object.defineProperty(this, E, { value: R }), R;
      }
    };
  o.visible = {
    get() {
      const E = v(this, this._styler, !0);
      return Object.defineProperty(this, "visible", { value: E }), E;
    }
  };
  const h = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
  for (const E of h)
    o[E] = {
      get() {
        const { level: S } = this;
        return function(...R) {
          const j = m(e.color[a[S]][E](...R), e.color.close, this._styler);
          return v(this, j, this._isEmpty);
        };
      }
    };
  for (const E of h) {
    const S = "bg" + E[0].toUpperCase() + E.slice(1);
    o[S] = {
      get() {
        const { level: R } = this;
        return function(...j) {
          const L = m(e.bgColor[a[R]][E](...j), e.bgColor.close, this._styler);
          return v(this, L, this._isEmpty);
        };
      }
    };
  }
  const g = Object.defineProperties(() => {
  }, {
    ...o,
    level: {
      enumerable: !0,
      get() {
        return this._generator.level;
      },
      set(E) {
        this._generator.level = E;
      }
    }
  }), m = (E, S, R) => {
    let j, L;
    return R === void 0 ? (j = E, L = S) : (j = R.openAll + E, L = S + R.closeAll), {
      open: E,
      close: S,
      openAll: j,
      closeAll: L,
      parent: R
    };
  }, v = (E, S, R) => {
    const j = (...L) => s(L[0]) && s(L[0].raw) ? _(j, w(j, ...L)) : _(j, L.length === 1 ? "" + L[0] : L.join(" "));
    return Object.setPrototypeOf(j, g), j._generator = E, j._styler = S, j._isEmpty = R, j;
  }, _ = (E, S) => {
    if (E.level <= 0 || !S)
      return E._isEmpty ? "" : S;
    let R = E._styler;
    if (R === void 0)
      return S;
    const { openAll: j, closeAll: L } = R;
    if (S.indexOf("\x1B") !== -1)
      for (; R !== void 0; )
        S = i(S, R.close, R.open), R = R.parent;
    const K = S.indexOf(`
`);
    return K !== -1 && (S = n(S, L, j, K)), j + S + L;
  };
  let y;
  const w = (E, ...S) => {
    const [R] = S;
    if (!s(R) || !s(R.raw))
      return S.join(" ");
    const j = S.slice(1), L = [R.raw[0]];
    for (let K = 1; K < R.length; K++)
      L.push(
        String(j[K - 1]).replace(/[{}\\]/g, "\\$&"),
        String(R.raw[K])
      );
    return y === void 0 && (y = A8()), y(E, L.join(""));
  };
  Object.defineProperties(p.prototype, o);
  const $ = p();
  return $.supportsColor = t, $.stderr = p({ level: r ? r.level : 0 }), $.stderr.supportsColor = r, kh = $, kh;
}
var Mh = {}, Jc = { exports: {} }, Bo = {}, cw;
function FO() {
  if (cw)
    return Bo;
  cw = 1, Object.defineProperty(Bo, "__esModule", {
    value: !0
  }), Bo.getPointers = void 0;
  var e = function(r) {
    var i = r.split("/").slice(1);
    for (var n in i)
      i[n] = i[n].split("~1").join("/").split("~0").join("~");
    return i;
  };
  return Bo.getPointers = e, Bo;
}
var lw;
function R8() {
  return lw || (lw = 1, function(e, t) {
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = i;
    var r = FO();
    function i(n, s, a) {
      var o = (0, r.getPointers)(s), c = o.length - 1;
      return o.reduce(function(l, d, p) {
        switch (l.type) {
          case "Object": {
            var h = l.members.filter(function(_) {
              return _.name.value === d;
            });
            if (h.length !== 1)
              throw new Error("Couldn't find property ".concat(d, " of ").concat(s));
            var g = h[0], m = g.name, v = g.value;
            return a && p === c ? m : v;
          }
          case "Array":
            return l.elements[d];
          default:
            console.log(l);
        }
      }, n.body);
    }
    e.exports = t.default;
  }(Jc, Jc.exports)), Jc.exports;
}
var Xc = { exports: {} }, fw;
function T8() {
  return fw || (fw = 1, function(e, t) {
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = n;
    var r = FO();
    function i(s) {
      if (!s || !s.elements)
        return "";
      var a = s.elements.filter(function(o) {
        return o && o.name && o.name.value === "type";
      });
      return a.length && a[0].value && ":".concat(a[0].value.value) || "";
    }
    function n(s, a) {
      var o = "";
      return (0, r.getPointers)(a).reduce(function(c, l) {
        switch (c.type) {
          case "Object": {
            o += "/".concat(l);
            var d = c.members.filter(function(p) {
              return p.name.value === l;
            });
            if (d.length !== 1)
              throw new Error("Couldn't find property ".concat(l, " of ").concat(a));
            return d[0].value;
          }
          case "Array":
            return o += "/".concat(l).concat(i(c.elements[l])), c.elements[l];
          default:
            console.log(c);
        }
      }, s.body), o;
    }
    e.exports = t.default;
  }(Xc, Xc.exports)), Xc.exports;
}
var dw;
function I8() {
  return dw || (dw = 1, function(e) {
    var t = kn;
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), Object.defineProperty(e, "getDecoratedDataPath", {
      enumerable: !0,
      get: function() {
        return i.default;
      }
    }), Object.defineProperty(e, "getMetaFromPath", {
      enumerable: !0,
      get: function() {
        return r.default;
      }
    });
    var r = t(R8()), i = t(T8());
  }(Mh)), Mh;
}
var pw;
function oo() {
  return pw || (pw = 1, function(e, t) {
    var r = kn;
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = void 0;
    var i = r(Xs()), n = r(Qs()), s = w8(), a = r(C8()), o = I8(), c = /* @__PURE__ */ function() {
      function l() {
        var d = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
          isIdentifierLocation: !1
        }, p = arguments.length > 1 ? arguments[1] : void 0, h = p.colorize, g = p.data, m = p.schema, v = p.jsonAst, _ = p.jsonRaw;
        (0, i.default)(this, l), this.options = d, this.colorize = !!(h || h === void 0), this.data = g, this.schema = m, this.jsonAst = v, this.jsonRaw = _;
      }
      return (0, n.default)(l, [{
        key: "getChalk",
        value: function() {
          return this.colorize ? a.default : new a.default.Instance({
            level: 0
          });
        }
      }, {
        key: "getLocation",
        value: function() {
          var p = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.instancePath, h = this.options, g = h.isIdentifierLocation, m = h.isSkipEndLocation, v = (0, o.getMetaFromPath)(this.jsonAst, p, g), _ = v.loc;
          return {
            start: _.start,
            end: m ? void 0 : _.end
          };
        }
      }, {
        key: "getDecoratedPath",
        value: function() {
          var p = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.instancePath;
          return (0, o.getDecoratedDataPath)(this.jsonAst, p);
        }
      }, {
        key: "getCodeFrame",
        value: function(p) {
          var h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.instancePath;
          return (0, s.codeFrameColumns)(this.jsonRaw, this.getLocation(h), {
            /**
             * `@babel/highlight`, by way of `@babel/code-frame`, highlights out entire block of raw JSON
             * instead of just our `location` block -- so if you have a block of raw JSON that's upwards
             * of 2mb+ and have a lot of errors to generate code frames for then we're re-highlighting
             * the same huge chunk of code over and over and over and over again, all just so
             * `@babel/code-frame` will eventually extract a small <10 line chunk out of it to return to
             * us.
             *
             * Disabling `highlightCode` here will only disable highlighting the code we're showing users;
             * if `options.colorize` is supplied to this library then the error message we're adding will
             * still be highlighted.
             */
            highlightCode: !1,
            message: p
          });
        }
        /**
         * @return {string}
         */
      }, {
        key: "instancePath",
        get: function() {
          return typeof this.options.instancePath < "u" ? this.options.instancePath : this.options.dataPath;
        }
      }, {
        key: "print",
        value: function() {
          throw new Error("Implement the 'print' method inside ".concat(this.constructor.name, "!"));
        }
      }, {
        key: "getError",
        value: function() {
          throw new Error("Implement the 'getError' method inside ".concat(this.constructor.name, "!"));
        }
      }]), l;
    }();
    t.default = c, e.exports = t.default;
  }(Yc, Yc.exports)), Yc.exports;
}
var hw;
function j8() {
  return hw || (hw = 1, function(e, t) {
    var r = kn;
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = void 0;
    var i = r(Js()), n = r(io()), s = r(Xs()), a = r(Qs()), o = r(so()), c = r(ao()), l = r(ea()), d = r(oo()), p, h;
    function g(w, $) {
      var E = Object.keys(w);
      if (Object.getOwnPropertySymbols) {
        var S = Object.getOwnPropertySymbols(w);
        $ && (S = S.filter(function(R) {
          return Object.getOwnPropertyDescriptor(w, R).enumerable;
        })), E.push.apply(E, S);
      }
      return E;
    }
    function m(w) {
      for (var $ = 1; $ < arguments.length; $++) {
        var E = arguments[$] != null ? arguments[$] : {};
        $ % 2 ? g(Object(E), !0).forEach(function(S) {
          (0, i.default)(w, S, E[S]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(w, Object.getOwnPropertyDescriptors(E)) : g(Object(E)).forEach(function(S) {
          Object.defineProperty(w, S, Object.getOwnPropertyDescriptor(E, S));
        });
      }
      return w;
    }
    function v(w) {
      var $ = _();
      return function() {
        var S = (0, l.default)(w), R;
        if ($) {
          var j = (0, l.default)(this).constructor;
          R = Reflect.construct(S, arguments, j);
        } else
          R = S.apply(this, arguments);
        return (0, c.default)(this, R);
      };
    }
    function _() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    var y = /* @__PURE__ */ function(w) {
      (0, o.default)(E, w);
      var $ = v(E);
      function E() {
        var S;
        (0, s.default)(this, E);
        for (var R = arguments.length, j = new Array(R), L = 0; L < R; L++)
          j[L] = arguments[L];
        return S = $.call.apply($, [this].concat(j)), S.name = "AdditionalPropValidationError", S.options.isIdentifierLocation = !0, S;
      }
      return (0, a.default)(E, [{
        key: "print",
        value: function() {
          var R = this.options, j = R.message, L = R.params, K = this.getChalk(), ae = [K(p || (p = (0, n.default)(["{red {bold ADDITIONAL PROPERTY} ", `}
`], ["{red {bold ADDITIONAL PROPERTY} ", "}\\n"])), j)];
          return ae.concat(this.getCodeFrame(K(h || (h = (0, n.default)(["  {magentaBright ", "} is not expected to be here!"])), L.additionalProperty), "".concat(this.instancePath, "/").concat(L.additionalProperty)));
        }
      }, {
        key: "getError",
        value: function() {
          var R = this.options.params;
          return m(m({}, this.getLocation("".concat(this.instancePath, "/").concat(R.additionalProperty))), {}, {
            error: "".concat(this.getDecoratedPath(), " Property ").concat(R.additionalProperty, " is not expected to be here"),
            path: this.instancePath
          });
        }
      }]), E;
    }(d.default);
    t.default = y, e.exports = t.default;
  }(Kc, Kc.exports)), Kc.exports;
}
var Qc = { exports: {} }, mw;
function k8() {
  return mw || (mw = 1, function(e, t) {
    var r = kn;
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = void 0;
    var i = r(Js()), n = r(io()), s = r(Xs()), a = r(Qs()), o = r(so()), c = r(ao()), l = r(ea()), d = r(oo()), p, h;
    function g(w, $) {
      var E = Object.keys(w);
      if (Object.getOwnPropertySymbols) {
        var S = Object.getOwnPropertySymbols(w);
        $ && (S = S.filter(function(R) {
          return Object.getOwnPropertyDescriptor(w, R).enumerable;
        })), E.push.apply(E, S);
      }
      return E;
    }
    function m(w) {
      for (var $ = 1; $ < arguments.length; $++) {
        var E = arguments[$] != null ? arguments[$] : {};
        $ % 2 ? g(Object(E), !0).forEach(function(S) {
          (0, i.default)(w, S, E[S]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(w, Object.getOwnPropertyDescriptors(E)) : g(Object(E)).forEach(function(S) {
          Object.defineProperty(w, S, Object.getOwnPropertyDescriptor(E, S));
        });
      }
      return w;
    }
    function v(w) {
      var $ = _();
      return function() {
        var S = (0, l.default)(w), R;
        if ($) {
          var j = (0, l.default)(this).constructor;
          R = Reflect.construct(S, arguments, j);
        } else
          R = S.apply(this, arguments);
        return (0, c.default)(this, R);
      };
    }
    function _() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    var y = /* @__PURE__ */ function(w) {
      (0, o.default)(E, w);
      var $ = v(E);
      function E() {
        var S;
        (0, s.default)(this, E);
        for (var R = arguments.length, j = new Array(R), L = 0; L < R; L++)
          j[L] = arguments[L];
        return S = $.call.apply($, [this].concat(j)), S.name = "DefaultValidationError", S.options.isSkipEndLocation = !0, S;
      }
      return (0, a.default)(E, [{
        key: "print",
        value: function() {
          var R = this.options, j = R.keyword, L = R.message, K = this.getChalk(), ae = [K(p || (p = (0, n.default)(["{red {bold ", "} ", `}
`], ["{red {bold ", "} ", "}\\n"])), j.toUpperCase(), L)];
          return ae.concat(this.getCodeFrame(K(h || (h = (0, n.default)(["  {magentaBright ", "} ", ""])), j, L)));
        }
      }, {
        key: "getError",
        value: function() {
          var R = this.options, j = R.keyword, L = R.message;
          return m(m({}, this.getLocation()), {}, {
            error: "".concat(this.getDecoratedPath(), ": ").concat(j, " ").concat(L),
            path: this.instancePath
          });
        }
      }]), E;
    }(d.default);
    t.default = y, e.exports = t.default;
  }(Qc, Qc.exports)), Qc.exports;
}
var el = { exports: {} }, Vo = {}, yw;
function M8() {
  if (yw)
    return Vo;
  yw = 1;
  var e = /~/, t = /~[01]/g;
  function r(l) {
    switch (l) {
      case "~1":
        return "/";
      case "~0":
        return "~";
    }
    throw new Error("Invalid tilde escape: " + l);
  }
  function i(l) {
    return e.test(l) ? l.replace(t, r) : l;
  }
  function n(l, d, p) {
    for (var h, g, m = 1, v = d.length; m < v; ) {
      if (d[m] === "constructor" || d[m] === "prototype" || d[m] === "__proto__")
        return l;
      if (h = i(d[m++]), g = v > m, typeof l[h] > "u" && (Array.isArray(l) && h === "-" && (h = l.length), g && (d[m] !== "" && d[m] < 1 / 0 || d[m] === "-" ? l[h] = [] : l[h] = {})), !g)
        break;
      l = l[h];
    }
    var _ = l[h];
    return p === void 0 ? delete l[h] : l[h] = p, _;
  }
  function s(l) {
    if (typeof l == "string") {
      if (l = l.split("/"), l[0] === "")
        return l;
      throw new Error("Invalid JSON pointer.");
    } else if (Array.isArray(l)) {
      for (const d of l)
        if (typeof d != "string" && typeof d != "number")
          throw new Error("Invalid JSON pointer. Must be of type string or number.");
      return l;
    }
    throw new Error("Invalid JSON pointer.");
  }
  function a(l, d) {
    if (typeof l != "object")
      throw new Error("Invalid input object.");
    d = s(d);
    var p = d.length;
    if (p === 1)
      return l;
    for (var h = 1; h < p; ) {
      if (l = l[i(d[h++])], p === h)
        return l;
      if (typeof l != "object" || l === null)
        return;
    }
  }
  function o(l, d, p) {
    if (typeof l != "object")
      throw new Error("Invalid input object.");
    if (d = s(d), d.length === 0)
      throw new Error("Invalid JSON pointer for set.");
    return n(l, d, p);
  }
  function c(l) {
    var d = s(l);
    return {
      get: function(p) {
        return a(p, d);
      },
      set: function(p, h) {
        return o(p, d, h);
      }
    };
  }
  return Vo.get = a, Vo.set = o, Vo.compile = c, Vo;
}
var tl = { exports: {} }, gw;
function N8() {
  if (gw)
    return tl.exports;
  gw = 1;
  const e = [], t = [], r = (i, n) => {
    if (i === n)
      return 0;
    const s = i;
    i.length > n.length && (i = n, n = s);
    let a = i.length, o = n.length;
    for (; a > 0 && i.charCodeAt(~-a) === n.charCodeAt(~-o); )
      a--, o--;
    let c = 0;
    for (; c < a && i.charCodeAt(c) === n.charCodeAt(c); )
      c++;
    if (a -= c, o -= c, a === 0)
      return o;
    let l, d, p, h, g = 0, m = 0;
    for (; g < a; )
      t[g] = i.charCodeAt(c + g), e[g] = ++g;
    for (; m < o; )
      for (l = n.charCodeAt(c + m), p = m++, d = m, g = 0; g < a; g++)
        h = l === t[g] ? p : p + 1, p = e[g], d = e[g] = p > d ? h > d ? d + 1 : h : h > p ? p + 1 : h;
    return d;
  };
  return tl.exports = r, tl.exports.default = r, tl.exports;
}
var vw;
function D8() {
  return vw || (vw = 1, function(e, t) {
    var r = kn;
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = void 0;
    var i = r(Js()), n = r(io()), s = r(Xs()), a = r(Qs()), o = r(so()), c = r(ao()), l = r(ea()), d = r(M8()), p = r(N8()), h = r(oo()), g, m, v, _;
    function y(R, j) {
      var L = Object.keys(R);
      if (Object.getOwnPropertySymbols) {
        var K = Object.getOwnPropertySymbols(R);
        j && (K = K.filter(function(ae) {
          return Object.getOwnPropertyDescriptor(R, ae).enumerable;
        })), L.push.apply(L, K);
      }
      return L;
    }
    function w(R) {
      for (var j = 1; j < arguments.length; j++) {
        var L = arguments[j] != null ? arguments[j] : {};
        j % 2 ? y(Object(L), !0).forEach(function(K) {
          (0, i.default)(R, K, L[K]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(R, Object.getOwnPropertyDescriptors(L)) : y(Object(L)).forEach(function(K) {
          Object.defineProperty(R, K, Object.getOwnPropertyDescriptor(L, K));
        });
      }
      return R;
    }
    function $(R) {
      var j = E();
      return function() {
        var K = (0, l.default)(R), ae;
        if (j) {
          var ye = (0, l.default)(this).constructor;
          ae = Reflect.construct(K, arguments, ye);
        } else
          ae = K.apply(this, arguments);
        return (0, c.default)(this, ae);
      };
    }
    function E() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    var S = /* @__PURE__ */ function(R) {
      (0, o.default)(L, R);
      var j = $(L);
      function L() {
        var K;
        (0, s.default)(this, L);
        for (var ae = arguments.length, ye = new Array(ae), xe = 0; xe < ae; xe++)
          ye[xe] = arguments[xe];
        return K = j.call.apply(j, [this].concat(ye)), K.name = "EnumValidationError", K;
      }
      return (0, a.default)(L, [{
        key: "print",
        value: function() {
          var ae = this.options, ye = ae.message, xe = ae.params.allowedValues, Pe = this.getChalk(), te = this.findBestMatch(), pe = [Pe(g || (g = (0, n.default)(["{red {bold ENUM} ", "}"])), ye), Pe(m || (m = (0, n.default)(["{red (", `)}
`], ["{red (", ")}\\n"])), xe.join(", "))];
          return pe.concat(this.getCodeFrame(te !== null ? Pe(v || (v = (0, n.default)(["  Did you mean {magentaBright ", "} here?"])), te) : Pe(_ || (_ = (0, n.default)(["  Unexpected value, should be equal to one of the allowed values"])))));
        }
      }, {
        key: "getError",
        value: function() {
          var ae = this.options, ye = ae.message, xe = ae.params, Pe = this.findBestMatch(), te = xe.allowedValues.join(", "), pe = w(w({}, this.getLocation()), {}, {
            error: "".concat(this.getDecoratedPath(), " ").concat(ye, ": ").concat(te),
            path: this.instancePath
          });
          return Pe !== null && (pe.suggestion = "Did you mean ".concat(Pe, "?")), pe;
        }
      }, {
        key: "findBestMatch",
        value: function() {
          var ae = this.options.params.allowedValues, ye = this.instancePath === "" ? this.data : d.default.get(this.data, this.instancePath);
          if (!ye)
            return null;
          var xe = ae.map(function(Pe) {
            return {
              value: Pe,
              weight: (0, p.default)(Pe, ye.toString())
            };
          }).sort(function(Pe, te) {
            return Pe.weight > te.weight ? 1 : Pe.weight < te.weight ? -1 : 0;
          })[0];
          return ae.length === 1 || xe.weight < xe.value.length ? xe.value : null;
        }
      }]), L;
    }(h.default);
    t.default = S, e.exports = t.default;
  }(el, el.exports)), el.exports;
}
var rl = { exports: {} }, bw;
function L8() {
  return bw || (bw = 1, function(e, t) {
    var r = kn;
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = void 0;
    var i = r(Js()), n = r(io()), s = r(Xs()), a = r(Qs()), o = r(so()), c = r(ao()), l = r(ea()), d = r(oo()), p, h;
    function g(w, $) {
      var E = Object.keys(w);
      if (Object.getOwnPropertySymbols) {
        var S = Object.getOwnPropertySymbols(w);
        $ && (S = S.filter(function(R) {
          return Object.getOwnPropertyDescriptor(w, R).enumerable;
        })), E.push.apply(E, S);
      }
      return E;
    }
    function m(w) {
      for (var $ = 1; $ < arguments.length; $++) {
        var E = arguments[$] != null ? arguments[$] : {};
        $ % 2 ? g(Object(E), !0).forEach(function(S) {
          (0, i.default)(w, S, E[S]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(w, Object.getOwnPropertyDescriptors(E)) : g(Object(E)).forEach(function(S) {
          Object.defineProperty(w, S, Object.getOwnPropertyDescriptor(E, S));
        });
      }
      return w;
    }
    function v(w) {
      var $ = _();
      return function() {
        var S = (0, l.default)(w), R;
        if ($) {
          var j = (0, l.default)(this).constructor;
          R = Reflect.construct(S, arguments, j);
        } else
          R = S.apply(this, arguments);
        return (0, c.default)(this, R);
      };
    }
    function _() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    var y = /* @__PURE__ */ function(w) {
      (0, o.default)(E, w);
      var $ = v(E);
      function E() {
        var S;
        (0, s.default)(this, E);
        for (var R = arguments.length, j = new Array(R), L = 0; L < R; L++)
          j[L] = arguments[L];
        return S = $.call.apply($, [this].concat(j)), S.name = "PatternValidationError", S.options.isIdentifierLocation = !0, S;
      }
      return (0, a.default)(E, [{
        key: "print",
        value: function() {
          var R = this.options, j = R.message, L = R.params, K = R.propertyName, ae = this.getChalk(), ye = [ae(p || (p = (0, n.default)(["{red {bold PROPERTY} ", `}
`], ["{red {bold PROPERTY} ", "}\\n"])), j)];
          return ye.concat(this.getCodeFrame(ae(h || (h = (0, n.default)(["  must match pattern {magentaBright ", "}"])), L.pattern), "".concat(this.instancePath, "/").concat(K)));
        }
      }, {
        key: "getError",
        value: function() {
          var R = this.options, j = R.params, L = R.propertyName;
          return m(m({}, this.getLocation()), {}, {
            error: "".concat(this.getDecoratedPath(), ' Property "').concat(L, '" must match pattern ').concat(j.pattern),
            path: this.instancePath
          });
        }
      }]), E;
    }(d.default);
    t.default = y, e.exports = t.default;
  }(rl, rl.exports)), rl.exports;
}
var nl = { exports: {} }, Nh = { exports: {} }, Dh = { exports: {} }, _w;
function q8() {
  return _w || (_w = 1, function(e) {
    var t = ea();
    function r(i, n) {
      for (; !Object.prototype.hasOwnProperty.call(i, n) && (i = t(i), i !== null); )
        ;
      return i;
    }
    e.exports = r, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(Dh)), Dh.exports;
}
var ww;
function F8() {
  return ww || (ww = 1, function(e) {
    var t = q8();
    function r() {
      return typeof Reflect < "u" && Reflect.get ? (e.exports = r = Reflect.get.bind(), e.exports.__esModule = !0, e.exports.default = e.exports) : (e.exports = r = function(n, s, a) {
        var o = t(n, s);
        if (o) {
          var c = Object.getOwnPropertyDescriptor(o, s);
          return c.get ? c.get.call(arguments.length < 3 ? n : a) : c.value;
        }
      }, e.exports.__esModule = !0, e.exports.default = e.exports), r.apply(this, arguments);
    }
    e.exports = r, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(Nh)), Nh.exports;
}
var $w;
function U8() {
  return $w || ($w = 1, function(e, t) {
    var r = kn;
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = void 0;
    var i = r(Js()), n = r(io()), s = r(Xs()), a = r(Qs()), o = r(F8()), c = r(so()), l = r(ao()), d = r(ea()), p = r(oo()), h, g;
    function m($, E) {
      var S = Object.keys($);
      if (Object.getOwnPropertySymbols) {
        var R = Object.getOwnPropertySymbols($);
        E && (R = R.filter(function(j) {
          return Object.getOwnPropertyDescriptor($, j).enumerable;
        })), S.push.apply(S, R);
      }
      return S;
    }
    function v($) {
      for (var E = 1; E < arguments.length; E++) {
        var S = arguments[E] != null ? arguments[E] : {};
        E % 2 ? m(Object(S), !0).forEach(function(R) {
          (0, i.default)($, R, S[R]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties($, Object.getOwnPropertyDescriptors(S)) : m(Object(S)).forEach(function(R) {
          Object.defineProperty($, R, Object.getOwnPropertyDescriptor(S, R));
        });
      }
      return $;
    }
    function _($) {
      var E = y();
      return function() {
        var R = (0, d.default)($), j;
        if (E) {
          var L = (0, d.default)(this).constructor;
          j = Reflect.construct(R, arguments, L);
        } else
          j = R.apply(this, arguments);
        return (0, l.default)(this, j);
      };
    }
    function y() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    var w = /* @__PURE__ */ function($) {
      (0, c.default)(S, $);
      var E = _(S);
      function S() {
        var R;
        (0, s.default)(this, S);
        for (var j = arguments.length, L = new Array(j), K = 0; K < j; K++)
          L[K] = arguments[K];
        return R = E.call.apply(E, [this].concat(L)), R.name = "RequiredValidationError", R;
      }
      return (0, a.default)(S, [{
        key: "getLocation",
        value: function() {
          var j = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.instancePath, L = (0, o.default)((0, d.default)(S.prototype), "getLocation", this).call(this, j), K = L.start;
          return {
            start: K
          };
        }
      }, {
        key: "print",
        value: function() {
          var j = this.options, L = j.message, K = j.params, ae = this.getChalk(), ye = [ae(h || (h = (0, n.default)(["{red {bold REQUIRED} ", `}
`], ["{red {bold REQUIRED} ", "}\\n"])), L)];
          return ye.concat(this.getCodeFrame(ae(g || (g = (0, n.default)(["  {magentaBright ", "} is missing here!"])), K.missingProperty)));
        }
      }, {
        key: "getError",
        value: function() {
          var j = this.options.message;
          return v(v({}, this.getLocation()), {}, {
            error: "".concat(this.getDecoratedPath(), " ").concat(j),
            path: this.instancePath
          });
        }
      }]), S;
    }(p.default);
    t.default = w, e.exports = t.default;
  }(nl, nl.exports)), nl.exports;
}
var il = { exports: {} }, Ew;
function B8() {
  return Ew || (Ew = 1, function(e, t) {
    var r = kn;
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = void 0;
    var i = r(Js()), n = r(io()), s = r(Xs()), a = r(Qs()), o = r(so()), c = r(ao()), l = r(ea()), d = r(oo()), p, h;
    function g(w, $) {
      var E = Object.keys(w);
      if (Object.getOwnPropertySymbols) {
        var S = Object.getOwnPropertySymbols(w);
        $ && (S = S.filter(function(R) {
          return Object.getOwnPropertyDescriptor(w, R).enumerable;
        })), E.push.apply(E, S);
      }
      return E;
    }
    function m(w) {
      for (var $ = 1; $ < arguments.length; $++) {
        var E = arguments[$] != null ? arguments[$] : {};
        $ % 2 ? g(Object(E), !0).forEach(function(S) {
          (0, i.default)(w, S, E[S]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(w, Object.getOwnPropertyDescriptors(E)) : g(Object(E)).forEach(function(S) {
          Object.defineProperty(w, S, Object.getOwnPropertyDescriptor(E, S));
        });
      }
      return w;
    }
    function v(w) {
      var $ = _();
      return function() {
        var S = (0, l.default)(w), R;
        if ($) {
          var j = (0, l.default)(this).constructor;
          R = Reflect.construct(S, arguments, j);
        } else
          R = S.apply(this, arguments);
        return (0, c.default)(this, R);
      };
    }
    function _() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    var y = /* @__PURE__ */ function(w) {
      (0, o.default)(E, w);
      var $ = v(E);
      function E() {
        var S;
        (0, s.default)(this, E);
        for (var R = arguments.length, j = new Array(R), L = 0; L < R; L++)
          j[L] = arguments[L];
        return S = $.call.apply($, [this].concat(j)), S.name = "UnevaluatedPropValidationError", S.options.isIdentifierLocation = !0, S;
      }
      return (0, a.default)(E, [{
        key: "print",
        value: function() {
          var R = this.options, j = R.message, L = R.params, K = this.getChalk(), ae = [K(p || (p = (0, n.default)(["{red {bold UNEVALUATED PROPERTY} ", `}
`], ["{red {bold UNEVALUATED PROPERTY} ", "}\\n"])), j)];
          return ae.concat(this.getCodeFrame(K(h || (h = (0, n.default)(["  {magentaBright ", "} is not expected to be here!"])), L.unevaluatedProperty), "".concat(this.instancePath, "/").concat(L.unevaluatedProperty)));
        }
      }, {
        key: "getError",
        value: function() {
          var R = this.options.params;
          return m(m({}, this.getLocation("".concat(this.instancePath, "/").concat(R.unevaluatedProperty))), {}, {
            error: "".concat(this.getDecoratedPath(), " Property ").concat(R.unevaluatedProperty, " is not expected to be here"),
            path: this.instancePath
          });
        }
      }]), E;
    }(d.default);
    t.default = y, e.exports = t.default;
  }(il, il.exports)), il.exports;
}
var xw;
function V8() {
  return xw || (xw = 1, function(e) {
    var t = kn;
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), Object.defineProperty(e, "AdditionalPropValidationError", {
      enumerable: !0,
      get: function() {
        return r.default;
      }
    }), Object.defineProperty(e, "DefaultValidationError", {
      enumerable: !0,
      get: function() {
        return i.default;
      }
    }), Object.defineProperty(e, "EnumValidationError", {
      enumerable: !0,
      get: function() {
        return n.default;
      }
    }), Object.defineProperty(e, "PatternValidationError", {
      enumerable: !0,
      get: function() {
        return s.default;
      }
    }), Object.defineProperty(e, "RequiredValidationError", {
      enumerable: !0,
      get: function() {
        return a.default;
      }
    }), Object.defineProperty(e, "UnevaluatedPropValidationError", {
      enumerable: !0,
      get: function() {
        return o.default;
      }
    });
    var r = t(j8()), i = t(k8()), n = t(D8()), s = t(L8()), a = t(U8()), o = t(B8());
  }(ch)), ch;
}
var Ow;
function Z8() {
  return Ow || (Ow = 1, function(e) {
    var t = kn;
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.createErrorInstances = h, e.default = g, e.filterRedundantErrors = p, e.makeTree = d;
    var r = t(Js()), i = t(t8()), n = t(s8()), s = a8(), a = V8();
    function o(m, v) {
      var _ = Object.keys(m);
      if (Object.getOwnPropertySymbols) {
        var y = Object.getOwnPropertySymbols(m);
        v && (y = y.filter(function(w) {
          return Object.getOwnPropertyDescriptor(m, w).enumerable;
        })), _.push.apply(_, y);
      }
      return _;
    }
    function c(m) {
      for (var v = 1; v < arguments.length; v++) {
        var _ = arguments[v] != null ? arguments[v] : {};
        v % 2 ? o(Object(_), !0).forEach(function(y) {
          (0, r.default)(m, y, _[y]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(m, Object.getOwnPropertyDescriptors(_)) : o(Object(_)).forEach(function(y) {
          Object.defineProperty(m, y, Object.getOwnPropertyDescriptor(_, y));
        });
      }
      return m;
    }
    var l = /\/[\w_-]+(\/\d+)?/g;
    function d() {
      var m = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], v = {
        children: {}
      };
      return m.forEach(function(_) {
        var y = typeof _.instancePath < "u" ? _.instancePath : _.dataPath, w = y === "" ? [""] : y.match(l);
        w && w.reduce(function($, E, S) {
          return $.children[E] = $.children[E] || {
            children: {},
            errors: []
          }, S === w.length - 1 && $.children[E].errors.push(_), $.children[E];
        }, v);
      }), v;
    }
    function p(m, v, _) {
      (0, s.getErrors)(m).forEach(function(y) {
        (0, s.isRequiredError)(y) && (m.errors = [y], m.children = {});
      }), (0, s.getErrors)(m).some(s.isAnyOfError) && Object.keys(m.children).length > 0 && delete m.errors, m.errors && m.errors.length && (0, s.getErrors)(m).every(s.isEnumError) && (0, s.getSiblings)(v)(m).filter(s.notUndefined).some(s.getErrors) && delete v.children[_], Object.entries(m.children).forEach(function(y) {
        var w = (0, n.default)(y, 2), $ = w[0], E = w[1];
        return p(E, m, $);
      });
    }
    function h(m, v) {
      var _ = (0, s.getErrors)(m);
      if (_.length && _.every(s.isEnumError)) {
        var y = new Set((0, s.concatAll)([])(_.map(function(E) {
          return E.params.allowedValues;
        }))), w = (0, i.default)(y), $ = _[0];
        return [new a.EnumValidationError(c(c({}, $), {}, {
          params: {
            allowedValues: w
          }
        }), v)];
      }
      return (0, s.concatAll)(_.reduce(function(E, S) {
        switch (S.keyword) {
          case "additionalProperties":
            return E.concat(new a.AdditionalPropValidationError(S, v));
          case "pattern":
            return E.concat(new a.PatternValidationError(S, v));
          case "required":
            return E.concat(new a.RequiredValidationError(S, v));
          case "unevaluatedProperties":
            return E.concat(new a.UnevaluatedPropValidationError(S, v));
          default:
            return E.concat(new a.DefaultValidationError(S, v));
        }
      }, []))((0, s.getChildren)(m).map(function(E) {
        return h(E, v);
      }));
    }
    function g(m, v) {
      var _ = d(m || []);
      return p(_), h(_, v);
    }
  }(Gp)), Gp;
}
(function(e, t) {
  var r = kn;
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.default = s;
  var i = Ri, n = r(Z8());
  function s(a, o, c) {
    var l = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, d = l.colorize, p = d === void 0 ? !0 : d, h = l.format, g = h === void 0 ? "cli" : h, m = l.indent, v = m === void 0 ? null : m, _ = l.json, y = _ === void 0 ? null : _, w = y || JSON.stringify(o, null, v), $ = (0, i.parse)(w), E = function(L) {
      return L.print().join(`
`);
    }, S = function(L) {
      return L.getError();
    }, R = (0, n.default)(c, {
      colorize: p,
      data: o,
      schema: a,
      jsonAst: $,
      jsonRaw: w
    });
    return g === "cli" ? R.map(E).join(`

`) : R.map(S);
  }
  e.exports = t.default;
})(Ey, Ey.exports);
var z8 = Ey.exports, Oy = { exports: {} }, za = {}, hi = {}, Rs = {}, Yu = {}, pt = {}, ju = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.regexpCode = e.getEsmExportName = e.getProperty = e.safeStringify = e.stringify = e.strConcat = e.addCodeArg = e.str = e._ = e.nil = e._Code = e.Name = e.IDENTIFIER = e._CodeOrName = void 0;
  class t {
  }
  e._CodeOrName = t, e.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
  class r extends t {
    constructor(w) {
      if (super(), !e.IDENTIFIER.test(w))
        throw new Error("CodeGen: name must be a valid identifier");
      this.str = w;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      return !1;
    }
    get names() {
      return { [this.str]: 1 };
    }
  }
  e.Name = r;
  class i extends t {
    constructor(w) {
      super(), this._items = typeof w == "string" ? [w] : w;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      if (this._items.length > 1)
        return !1;
      const w = this._items[0];
      return w === "" || w === '""';
    }
    get str() {
      var w;
      return (w = this._str) !== null && w !== void 0 ? w : this._str = this._items.reduce(($, E) => `${$}${E}`, "");
    }
    get names() {
      var w;
      return (w = this._names) !== null && w !== void 0 ? w : this._names = this._items.reduce(($, E) => (E instanceof r && ($[E.str] = ($[E.str] || 0) + 1), $), {});
    }
  }
  e._Code = i, e.nil = new i("");
  function n(y, ...w) {
    const $ = [y[0]];
    let E = 0;
    for (; E < w.length; )
      o($, w[E]), $.push(y[++E]);
    return new i($);
  }
  e._ = n;
  const s = new i("+");
  function a(y, ...w) {
    const $ = [g(y[0])];
    let E = 0;
    for (; E < w.length; )
      $.push(s), o($, w[E]), $.push(s, g(y[++E]));
    return c($), new i($);
  }
  e.str = a;
  function o(y, w) {
    w instanceof i ? y.push(...w._items) : w instanceof r ? y.push(w) : y.push(p(w));
  }
  e.addCodeArg = o;
  function c(y) {
    let w = 1;
    for (; w < y.length - 1; ) {
      if (y[w] === s) {
        const $ = l(y[w - 1], y[w + 1]);
        if ($ !== void 0) {
          y.splice(w - 1, 3, $);
          continue;
        }
        y[w++] = "+";
      }
      w++;
    }
  }
  function l(y, w) {
    if (w === '""')
      return y;
    if (y === '""')
      return w;
    if (typeof y == "string")
      return w instanceof r || y[y.length - 1] !== '"' ? void 0 : typeof w != "string" ? `${y.slice(0, -1)}${w}"` : w[0] === '"' ? y.slice(0, -1) + w.slice(1) : void 0;
    if (typeof w == "string" && w[0] === '"' && !(y instanceof r))
      return `"${y}${w.slice(1)}`;
  }
  function d(y, w) {
    return w.emptyStr() ? y : y.emptyStr() ? w : a`${y}${w}`;
  }
  e.strConcat = d;
  function p(y) {
    return typeof y == "number" || typeof y == "boolean" || y === null ? y : g(Array.isArray(y) ? y.join(",") : y);
  }
  function h(y) {
    return new i(g(y));
  }
  e.stringify = h;
  function g(y) {
    return JSON.stringify(y).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
  }
  e.safeStringify = g;
  function m(y) {
    return typeof y == "string" && e.IDENTIFIER.test(y) ? new i(`.${y}`) : n`[${y}]`;
  }
  e.getProperty = m;
  function v(y) {
    if (typeof y == "string" && e.IDENTIFIER.test(y))
      return new i(`${y}`);
    throw new Error(`CodeGen: invalid export name: ${y}, use explicit $id name mapping`);
  }
  e.getEsmExportName = v;
  function _(y) {
    return new i(y.toString());
  }
  e.regexpCode = _;
})(ju);
var Py = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.ValueScope = e.ValueScopeName = e.Scope = e.varKinds = e.UsedValueState = void 0;
  const t = ju;
  class r extends Error {
    constructor(l) {
      super(`CodeGen: "code" for ${l} not defined`), this.value = l.value;
    }
  }
  var i;
  (function(c) {
    c[c.Started = 0] = "Started", c[c.Completed = 1] = "Completed";
  })(i = e.UsedValueState || (e.UsedValueState = {})), e.varKinds = {
    const: new t.Name("const"),
    let: new t.Name("let"),
    var: new t.Name("var")
  };
  class n {
    constructor({ prefixes: l, parent: d } = {}) {
      this._names = {}, this._prefixes = l, this._parent = d;
    }
    toName(l) {
      return l instanceof t.Name ? l : this.name(l);
    }
    name(l) {
      return new t.Name(this._newName(l));
    }
    _newName(l) {
      const d = this._names[l] || this._nameGroup(l);
      return `${l}${d.index++}`;
    }
    _nameGroup(l) {
      var d, p;
      if (!((p = (d = this._parent) === null || d === void 0 ? void 0 : d._prefixes) === null || p === void 0) && p.has(l) || this._prefixes && !this._prefixes.has(l))
        throw new Error(`CodeGen: prefix "${l}" is not allowed in this scope`);
      return this._names[l] = { prefix: l, index: 0 };
    }
  }
  e.Scope = n;
  class s extends t.Name {
    constructor(l, d) {
      super(d), this.prefix = l;
    }
    setValue(l, { property: d, itemIndex: p }) {
      this.value = l, this.scopePath = (0, t._)`.${new t.Name(d)}[${p}]`;
    }
  }
  e.ValueScopeName = s;
  const a = (0, t._)`\n`;
  class o extends n {
    constructor(l) {
      super(l), this._values = {}, this._scope = l.scope, this.opts = { ...l, _n: l.lines ? a : t.nil };
    }
    get() {
      return this._scope;
    }
    name(l) {
      return new s(l, this._newName(l));
    }
    value(l, d) {
      var p;
      if (d.ref === void 0)
        throw new Error("CodeGen: ref must be passed in value");
      const h = this.toName(l), { prefix: g } = h, m = (p = d.key) !== null && p !== void 0 ? p : d.ref;
      let v = this._values[g];
      if (v) {
        const w = v.get(m);
        if (w)
          return w;
      } else
        v = this._values[g] = /* @__PURE__ */ new Map();
      v.set(m, h);
      const _ = this._scope[g] || (this._scope[g] = []), y = _.length;
      return _[y] = d.ref, h.setValue(d, { property: g, itemIndex: y }), h;
    }
    getValue(l, d) {
      const p = this._values[l];
      if (p)
        return p.get(d);
    }
    scopeRefs(l, d = this._values) {
      return this._reduceValues(d, (p) => {
        if (p.scopePath === void 0)
          throw new Error(`CodeGen: name "${p}" has no value`);
        return (0, t._)`${l}${p.scopePath}`;
      });
    }
    scopeCode(l = this._values, d, p) {
      return this._reduceValues(l, (h) => {
        if (h.value === void 0)
          throw new Error(`CodeGen: name "${h}" has no value`);
        return h.value.code;
      }, d, p);
    }
    _reduceValues(l, d, p = {}, h) {
      let g = t.nil;
      for (const m in l) {
        const v = l[m];
        if (!v)
          continue;
        const _ = p[m] = p[m] || /* @__PURE__ */ new Map();
        v.forEach((y) => {
          if (_.has(y))
            return;
          _.set(y, i.Started);
          let w = d(y);
          if (w) {
            const $ = this.opts.es5 ? e.varKinds.var : e.varKinds.const;
            g = (0, t._)`${g}${$} ${y} = ${w};${this.opts._n}`;
          } else if (w = h == null ? void 0 : h(y))
            g = (0, t._)`${g}${w}${this.opts._n}`;
          else
            throw new r(y);
          _.set(y, i.Completed);
        });
      }
      return g;
    }
  }
  e.ValueScope = o;
})(Py);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.or = e.and = e.not = e.CodeGen = e.operators = e.varKinds = e.ValueScopeName = e.ValueScope = e.Scope = e.Name = e.regexpCode = e.stringify = e.getProperty = e.nil = e.strConcat = e.str = e._ = void 0;
  const t = ju, r = Py;
  var i = ju;
  Object.defineProperty(e, "_", { enumerable: !0, get: function() {
    return i._;
  } }), Object.defineProperty(e, "str", { enumerable: !0, get: function() {
    return i.str;
  } }), Object.defineProperty(e, "strConcat", { enumerable: !0, get: function() {
    return i.strConcat;
  } }), Object.defineProperty(e, "nil", { enumerable: !0, get: function() {
    return i.nil;
  } }), Object.defineProperty(e, "getProperty", { enumerable: !0, get: function() {
    return i.getProperty;
  } }), Object.defineProperty(e, "stringify", { enumerable: !0, get: function() {
    return i.stringify;
  } }), Object.defineProperty(e, "regexpCode", { enumerable: !0, get: function() {
    return i.regexpCode;
  } }), Object.defineProperty(e, "Name", { enumerable: !0, get: function() {
    return i.Name;
  } });
  var n = Py;
  Object.defineProperty(e, "Scope", { enumerable: !0, get: function() {
    return n.Scope;
  } }), Object.defineProperty(e, "ValueScope", { enumerable: !0, get: function() {
    return n.ValueScope;
  } }), Object.defineProperty(e, "ValueScopeName", { enumerable: !0, get: function() {
    return n.ValueScopeName;
  } }), Object.defineProperty(e, "varKinds", { enumerable: !0, get: function() {
    return n.varKinds;
  } }), e.operators = {
    GT: new t._Code(">"),
    GTE: new t._Code(">="),
    LT: new t._Code("<"),
    LTE: new t._Code("<="),
    EQ: new t._Code("==="),
    NEQ: new t._Code("!=="),
    NOT: new t._Code("!"),
    OR: new t._Code("||"),
    AND: new t._Code("&&"),
    ADD: new t._Code("+")
  };
  class s {
    optimizeNodes() {
      return this;
    }
    optimizeNames(T, F) {
      return this;
    }
  }
  class a extends s {
    constructor(T, F, D) {
      super(), this.varKind = T, this.name = F, this.rhs = D;
    }
    render({ es5: T, _n: F }) {
      const D = T ? r.varKinds.var : this.varKind, U = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
      return `${D} ${this.name}${U};` + F;
    }
    optimizeNames(T, F) {
      if (T[this.name.str])
        return this.rhs && (this.rhs = te(this.rhs, T, F)), this;
    }
    get names() {
      return this.rhs instanceof t._CodeOrName ? this.rhs.names : {};
    }
  }
  class o extends s {
    constructor(T, F, D) {
      super(), this.lhs = T, this.rhs = F, this.sideEffects = D;
    }
    render({ _n: T }) {
      return `${this.lhs} = ${this.rhs};` + T;
    }
    optimizeNames(T, F) {
      if (!(this.lhs instanceof t.Name && !T[this.lhs.str] && !this.sideEffects))
        return this.rhs = te(this.rhs, T, F), this;
    }
    get names() {
      const T = this.lhs instanceof t.Name ? {} : { ...this.lhs.names };
      return Pe(T, this.rhs);
    }
  }
  class c extends o {
    constructor(T, F, D, U) {
      super(T, D, U), this.op = F;
    }
    render({ _n: T }) {
      return `${this.lhs} ${this.op}= ${this.rhs};` + T;
    }
  }
  class l extends s {
    constructor(T) {
      super(), this.label = T, this.names = {};
    }
    render({ _n: T }) {
      return `${this.label}:` + T;
    }
  }
  class d extends s {
    constructor(T) {
      super(), this.label = T, this.names = {};
    }
    render({ _n: T }) {
      return `break${this.label ? ` ${this.label}` : ""};` + T;
    }
  }
  class p extends s {
    constructor(T) {
      super(), this.error = T;
    }
    render({ _n: T }) {
      return `throw ${this.error};` + T;
    }
    get names() {
      return this.error.names;
    }
  }
  class h extends s {
    constructor(T) {
      super(), this.code = T;
    }
    render({ _n: T }) {
      return `${this.code};` + T;
    }
    optimizeNodes() {
      return `${this.code}` ? this : void 0;
    }
    optimizeNames(T, F) {
      return this.code = te(this.code, T, F), this;
    }
    get names() {
      return this.code instanceof t._CodeOrName ? this.code.names : {};
    }
  }
  class g extends s {
    constructor(T = []) {
      super(), this.nodes = T;
    }
    render(T) {
      return this.nodes.reduce((F, D) => F + D.render(T), "");
    }
    optimizeNodes() {
      const { nodes: T } = this;
      let F = T.length;
      for (; F--; ) {
        const D = T[F].optimizeNodes();
        Array.isArray(D) ? T.splice(F, 1, ...D) : D ? T[F] = D : T.splice(F, 1);
      }
      return T.length > 0 ? this : void 0;
    }
    optimizeNames(T, F) {
      const { nodes: D } = this;
      let U = D.length;
      for (; U--; ) {
        const k = D[U];
        k.optimizeNames(T, F) || (pe(T, k.names), D.splice(U, 1));
      }
      return D.length > 0 ? this : void 0;
    }
    get names() {
      return this.nodes.reduce((T, F) => xe(T, F.names), {});
    }
  }
  class m extends g {
    render(T) {
      return "{" + T._n + super.render(T) + "}" + T._n;
    }
  }
  class v extends g {
  }
  class _ extends m {
  }
  _.kind = "else";
  class y extends m {
    constructor(T, F) {
      super(F), this.condition = T;
    }
    render(T) {
      let F = `if(${this.condition})` + super.render(T);
      return this.else && (F += "else " + this.else.render(T)), F;
    }
    optimizeNodes() {
      super.optimizeNodes();
      const T = this.condition;
      if (T === !0)
        return this.nodes;
      let F = this.else;
      if (F) {
        const D = F.optimizeNodes();
        F = this.else = Array.isArray(D) ? new _(D) : D;
      }
      if (F)
        return T === !1 ? F instanceof y ? F : F.nodes : this.nodes.length ? this : new y(de(T), F instanceof y ? [F] : F.nodes);
      if (!(T === !1 || !this.nodes.length))
        return this;
    }
    optimizeNames(T, F) {
      var D;
      if (this.else = (D = this.else) === null || D === void 0 ? void 0 : D.optimizeNames(T, F), !!(super.optimizeNames(T, F) || this.else))
        return this.condition = te(this.condition, T, F), this;
    }
    get names() {
      const T = super.names;
      return Pe(T, this.condition), this.else && xe(T, this.else.names), T;
    }
  }
  y.kind = "if";
  class w extends m {
  }
  w.kind = "for";
  class $ extends w {
    constructor(T) {
      super(), this.iteration = T;
    }
    render(T) {
      return `for(${this.iteration})` + super.render(T);
    }
    optimizeNames(T, F) {
      if (super.optimizeNames(T, F))
        return this.iteration = te(this.iteration, T, F), this;
    }
    get names() {
      return xe(super.names, this.iteration.names);
    }
  }
  class E extends w {
    constructor(T, F, D, U) {
      super(), this.varKind = T, this.name = F, this.from = D, this.to = U;
    }
    render(T) {
      const F = T.es5 ? r.varKinds.var : this.varKind, { name: D, from: U, to: k } = this;
      return `for(${F} ${D}=${U}; ${D}<${k}; ${D}++)` + super.render(T);
    }
    get names() {
      const T = Pe(super.names, this.from);
      return Pe(T, this.to);
    }
  }
  class S extends w {
    constructor(T, F, D, U) {
      super(), this.loop = T, this.varKind = F, this.name = D, this.iterable = U;
    }
    render(T) {
      return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(T);
    }
    optimizeNames(T, F) {
      if (super.optimizeNames(T, F))
        return this.iterable = te(this.iterable, T, F), this;
    }
    get names() {
      return xe(super.names, this.iterable.names);
    }
  }
  class R extends m {
    constructor(T, F, D) {
      super(), this.name = T, this.args = F, this.async = D;
    }
    render(T) {
      return `${this.async ? "async " : ""}function ${this.name}(${this.args})` + super.render(T);
    }
  }
  R.kind = "func";
  class j extends g {
    render(T) {
      return "return " + super.render(T);
    }
  }
  j.kind = "return";
  class L extends m {
    render(T) {
      let F = "try" + super.render(T);
      return this.catch && (F += this.catch.render(T)), this.finally && (F += this.finally.render(T)), F;
    }
    optimizeNodes() {
      var T, F;
      return super.optimizeNodes(), (T = this.catch) === null || T === void 0 || T.optimizeNodes(), (F = this.finally) === null || F === void 0 || F.optimizeNodes(), this;
    }
    optimizeNames(T, F) {
      var D, U;
      return super.optimizeNames(T, F), (D = this.catch) === null || D === void 0 || D.optimizeNames(T, F), (U = this.finally) === null || U === void 0 || U.optimizeNames(T, F), this;
    }
    get names() {
      const T = super.names;
      return this.catch && xe(T, this.catch.names), this.finally && xe(T, this.finally.names), T;
    }
  }
  class K extends m {
    constructor(T) {
      super(), this.error = T;
    }
    render(T) {
      return `catch(${this.error})` + super.render(T);
    }
  }
  K.kind = "catch";
  class ae extends m {
    render(T) {
      return "finally" + super.render(T);
    }
  }
  ae.kind = "finally";
  class ye {
    constructor(T, F = {}) {
      this._values = {}, this._blockStarts = [], this._constants = {}, this.opts = { ...F, _n: F.lines ? `
` : "" }, this._extScope = T, this._scope = new r.Scope({ parent: T }), this._nodes = [new v()];
    }
    toString() {
      return this._root.render(this.opts);
    }
    // returns unique name in the internal scope
    name(T) {
      return this._scope.name(T);
    }
    // reserves unique name in the external scope
    scopeName(T) {
      return this._extScope.name(T);
    }
    // reserves unique name in the external scope and assigns value to it
    scopeValue(T, F) {
      const D = this._extScope.value(T, F);
      return (this._values[D.prefix] || (this._values[D.prefix] = /* @__PURE__ */ new Set())).add(D), D;
    }
    getScopeValue(T, F) {
      return this._extScope.getValue(T, F);
    }
    // return code that assigns values in the external scope to the names that are used internally
    // (same names that were returned by gen.scopeName or gen.scopeValue)
    scopeRefs(T) {
      return this._extScope.scopeRefs(T, this._values);
    }
    scopeCode() {
      return this._extScope.scopeCode(this._values);
    }
    _def(T, F, D, U) {
      const k = this._scope.toName(F);
      return D !== void 0 && U && (this._constants[k.str] = D), this._leafNode(new a(T, k, D)), k;
    }
    // `const` declaration (`var` in es5 mode)
    const(T, F, D) {
      return this._def(r.varKinds.const, T, F, D);
    }
    // `let` declaration with optional assignment (`var` in es5 mode)
    let(T, F, D) {
      return this._def(r.varKinds.let, T, F, D);
    }
    // `var` declaration with optional assignment
    var(T, F, D) {
      return this._def(r.varKinds.var, T, F, D);
    }
    // assignment code
    assign(T, F, D) {
      return this._leafNode(new o(T, F, D));
    }
    // `+=` code
    add(T, F) {
      return this._leafNode(new c(T, e.operators.ADD, F));
    }
    // appends passed SafeExpr to code or executes Block
    code(T) {
      return typeof T == "function" ? T() : T !== t.nil && this._leafNode(new h(T)), this;
    }
    // returns code for object literal for the passed argument list of key-value pairs
    object(...T) {
      const F = ["{"];
      for (const [D, U] of T)
        F.length > 1 && F.push(","), F.push(D), (D !== U || this.opts.es5) && (F.push(":"), (0, t.addCodeArg)(F, U));
      return F.push("}"), new t._Code(F);
    }
    // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
    if(T, F, D) {
      if (this._blockNode(new y(T)), F && D)
        this.code(F).else().code(D).endIf();
      else if (F)
        this.code(F).endIf();
      else if (D)
        throw new Error('CodeGen: "else" body without "then" body');
      return this;
    }
    // `else if` clause - invalid without `if` or after `else` clauses
    elseIf(T) {
      return this._elseNode(new y(T));
    }
    // `else` clause - only valid after `if` or `else if` clauses
    else() {
      return this._elseNode(new _());
    }
    // end `if` statement (needed if gen.if was used only with condition)
    endIf() {
      return this._endBlockNode(y, _);
    }
    _for(T, F) {
      return this._blockNode(T), F && this.code(F).endFor(), this;
    }
    // a generic `for` clause (or statement if `forBody` is passed)
    for(T, F) {
      return this._for(new $(T), F);
    }
    // `for` statement for a range of values
    forRange(T, F, D, U, k = this.opts.es5 ? r.varKinds.var : r.varKinds.let) {
      const Z = this._scope.toName(T);
      return this._for(new E(k, Z, F, D), () => U(Z));
    }
    // `for-of` statement (in es5 mode replace with a normal for loop)
    forOf(T, F, D, U = r.varKinds.const) {
      const k = this._scope.toName(T);
      if (this.opts.es5) {
        const Z = F instanceof t.Name ? F : this.var("_arr", F);
        return this.forRange("_i", 0, (0, t._)`${Z}.length`, (J) => {
          this.var(k, (0, t._)`${Z}[${J}]`), D(k);
        });
      }
      return this._for(new S("of", U, k, F), () => D(k));
    }
    // `for-in` statement.
    // With option `ownProperties` replaced with a `for-of` loop for object keys
    forIn(T, F, D, U = this.opts.es5 ? r.varKinds.var : r.varKinds.const) {
      if (this.opts.ownProperties)
        return this.forOf(T, (0, t._)`Object.keys(${F})`, D);
      const k = this._scope.toName(T);
      return this._for(new S("in", U, k, F), () => D(k));
    }
    // end `for` loop
    endFor() {
      return this._endBlockNode(w);
    }
    // `label` statement
    label(T) {
      return this._leafNode(new l(T));
    }
    // `break` statement
    break(T) {
      return this._leafNode(new d(T));
    }
    // `return` statement
    return(T) {
      const F = new j();
      if (this._blockNode(F), this.code(T), F.nodes.length !== 1)
        throw new Error('CodeGen: "return" should have one node');
      return this._endBlockNode(j);
    }
    // `try` statement
    try(T, F, D) {
      if (!F && !D)
        throw new Error('CodeGen: "try" without "catch" and "finally"');
      const U = new L();
      if (this._blockNode(U), this.code(T), F) {
        const k = this.name("e");
        this._currNode = U.catch = new K(k), F(k);
      }
      return D && (this._currNode = U.finally = new ae(), this.code(D)), this._endBlockNode(K, ae);
    }
    // `throw` statement
    throw(T) {
      return this._leafNode(new p(T));
    }
    // start self-balancing block
    block(T, F) {
      return this._blockStarts.push(this._nodes.length), T && this.code(T).endBlock(F), this;
    }
    // end the current self-balancing block
    endBlock(T) {
      const F = this._blockStarts.pop();
      if (F === void 0)
        throw new Error("CodeGen: not in self-balancing block");
      const D = this._nodes.length - F;
      if (D < 0 || T !== void 0 && D !== T)
        throw new Error(`CodeGen: wrong number of nodes: ${D} vs ${T} expected`);
      return this._nodes.length = F, this;
    }
    // `function` heading (or definition if funcBody is passed)
    func(T, F = t.nil, D, U) {
      return this._blockNode(new R(T, F, D)), U && this.code(U).endFunc(), this;
    }
    // end function definition
    endFunc() {
      return this._endBlockNode(R);
    }
    optimize(T = 1) {
      for (; T-- > 0; )
        this._root.optimizeNodes(), this._root.optimizeNames(this._root.names, this._constants);
    }
    _leafNode(T) {
      return this._currNode.nodes.push(T), this;
    }
    _blockNode(T) {
      this._currNode.nodes.push(T), this._nodes.push(T);
    }
    _endBlockNode(T, F) {
      const D = this._currNode;
      if (D instanceof T || F && D instanceof F)
        return this._nodes.pop(), this;
      throw new Error(`CodeGen: not in block "${F ? `${T.kind}/${F.kind}` : T.kind}"`);
    }
    _elseNode(T) {
      const F = this._currNode;
      if (!(F instanceof y))
        throw new Error('CodeGen: "else" without "if"');
      return this._currNode = F.else = T, this;
    }
    get _root() {
      return this._nodes[0];
    }
    get _currNode() {
      const T = this._nodes;
      return T[T.length - 1];
    }
    set _currNode(T) {
      const F = this._nodes;
      F[F.length - 1] = T;
    }
  }
  e.CodeGen = ye;
  function xe(z, T) {
    for (const F in T)
      z[F] = (z[F] || 0) + (T[F] || 0);
    return z;
  }
  function Pe(z, T) {
    return T instanceof t._CodeOrName ? xe(z, T.names) : z;
  }
  function te(z, T, F) {
    if (z instanceof t.Name)
      return D(z);
    if (!U(z))
      return z;
    return new t._Code(z._items.reduce((k, Z) => (Z instanceof t.Name && (Z = D(Z)), Z instanceof t._Code ? k.push(...Z._items) : k.push(Z), k), []));
    function D(k) {
      const Z = F[k.str];
      return Z === void 0 || T[k.str] !== 1 ? k : (delete T[k.str], Z);
    }
    function U(k) {
      return k instanceof t._Code && k._items.some((Z) => Z instanceof t.Name && T[Z.str] === 1 && F[Z.str] !== void 0);
    }
  }
  function pe(z, T) {
    for (const F in T)
      z[F] = (z[F] || 0) - (T[F] || 0);
  }
  function de(z) {
    return typeof z == "boolean" || typeof z == "number" || z === null ? !z : (0, t._)`!${V(z)}`;
  }
  e.not = de;
  const Ee = Y(e.operators.AND);
  function Re(...z) {
    return z.reduce(Ee);
  }
  e.and = Re;
  const _e = Y(e.operators.OR);
  function ie(...z) {
    return z.reduce(_e);
  }
  e.or = ie;
  function Y(z) {
    return (T, F) => T === t.nil ? F : F === t.nil ? T : (0, t._)`${V(T)} ${z} ${V(F)}`;
  }
  function V(z) {
    return z instanceof t.Name ? z : (0, t._)`(${z})`;
  }
})(pt);
var Pt = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.checkStrictMode = e.getErrorPath = e.Type = e.useFunc = e.setEvaluated = e.evaluatedPropsToName = e.mergeEvaluated = e.eachItem = e.unescapeJsonPointer = e.escapeJsonPointer = e.escapeFragment = e.unescapeFragment = e.schemaRefOrVal = e.schemaHasRulesButRef = e.schemaHasRules = e.checkUnknownRules = e.alwaysValidSchema = e.toHash = void 0;
  const t = pt, r = ju;
  function i(R) {
    const j = {};
    for (const L of R)
      j[L] = !0;
    return j;
  }
  e.toHash = i;
  function n(R, j) {
    return typeof j == "boolean" ? j : Object.keys(j).length === 0 ? !0 : (s(R, j), !a(j, R.self.RULES.all));
  }
  e.alwaysValidSchema = n;
  function s(R, j = R.schema) {
    const { opts: L, self: K } = R;
    if (!L.strictSchema || typeof j == "boolean")
      return;
    const ae = K.RULES.keywords;
    for (const ye in j)
      ae[ye] || S(R, `unknown keyword: "${ye}"`);
  }
  e.checkUnknownRules = s;
  function a(R, j) {
    if (typeof R == "boolean")
      return !R;
    for (const L in R)
      if (j[L])
        return !0;
    return !1;
  }
  e.schemaHasRules = a;
  function o(R, j) {
    if (typeof R == "boolean")
      return !R;
    for (const L in R)
      if (L !== "$ref" && j.all[L])
        return !0;
    return !1;
  }
  e.schemaHasRulesButRef = o;
  function c({ topSchemaRef: R, schemaPath: j }, L, K, ae) {
    if (!ae) {
      if (typeof L == "number" || typeof L == "boolean")
        return L;
      if (typeof L == "string")
        return (0, t._)`${L}`;
    }
    return (0, t._)`${R}${j}${(0, t.getProperty)(K)}`;
  }
  e.schemaRefOrVal = c;
  function l(R) {
    return h(decodeURIComponent(R));
  }
  e.unescapeFragment = l;
  function d(R) {
    return encodeURIComponent(p(R));
  }
  e.escapeFragment = d;
  function p(R) {
    return typeof R == "number" ? `${R}` : R.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  e.escapeJsonPointer = p;
  function h(R) {
    return R.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  e.unescapeJsonPointer = h;
  function g(R, j) {
    if (Array.isArray(R))
      for (const L of R)
        j(L);
    else
      j(R);
  }
  e.eachItem = g;
  function m({ mergeNames: R, mergeToName: j, mergeValues: L, resultToName: K }) {
    return (ae, ye, xe, Pe) => {
      const te = xe === void 0 ? ye : xe instanceof t.Name ? (ye instanceof t.Name ? R(ae, ye, xe) : j(ae, ye, xe), xe) : ye instanceof t.Name ? (j(ae, xe, ye), ye) : L(ye, xe);
      return Pe === t.Name && !(te instanceof t.Name) ? K(ae, te) : te;
    };
  }
  e.mergeEvaluated = {
    props: m({
      mergeNames: (R, j, L) => R.if((0, t._)`${L} !== true && ${j} !== undefined`, () => {
        R.if((0, t._)`${j} === true`, () => R.assign(L, !0), () => R.assign(L, (0, t._)`${L} || {}`).code((0, t._)`Object.assign(${L}, ${j})`));
      }),
      mergeToName: (R, j, L) => R.if((0, t._)`${L} !== true`, () => {
        j === !0 ? R.assign(L, !0) : (R.assign(L, (0, t._)`${L} || {}`), _(R, L, j));
      }),
      mergeValues: (R, j) => R === !0 ? !0 : { ...R, ...j },
      resultToName: v
    }),
    items: m({
      mergeNames: (R, j, L) => R.if((0, t._)`${L} !== true && ${j} !== undefined`, () => R.assign(L, (0, t._)`${j} === true ? true : ${L} > ${j} ? ${L} : ${j}`)),
      mergeToName: (R, j, L) => R.if((0, t._)`${L} !== true`, () => R.assign(L, j === !0 ? !0 : (0, t._)`${L} > ${j} ? ${L} : ${j}`)),
      mergeValues: (R, j) => R === !0 ? !0 : Math.max(R, j),
      resultToName: (R, j) => R.var("items", j)
    })
  };
  function v(R, j) {
    if (j === !0)
      return R.var("props", !0);
    const L = R.var("props", (0, t._)`{}`);
    return j !== void 0 && _(R, L, j), L;
  }
  e.evaluatedPropsToName = v;
  function _(R, j, L) {
    Object.keys(L).forEach((K) => R.assign((0, t._)`${j}${(0, t.getProperty)(K)}`, !0));
  }
  e.setEvaluated = _;
  const y = {};
  function w(R, j) {
    return R.scopeValue("func", {
      ref: j,
      code: y[j.code] || (y[j.code] = new r._Code(j.code))
    });
  }
  e.useFunc = w;
  var $;
  (function(R) {
    R[R.Num = 0] = "Num", R[R.Str = 1] = "Str";
  })($ = e.Type || (e.Type = {}));
  function E(R, j, L) {
    if (R instanceof t.Name) {
      const K = j === $.Num;
      return L ? K ? (0, t._)`"[" + ${R} + "]"` : (0, t._)`"['" + ${R} + "']"` : K ? (0, t._)`"/" + ${R}` : (0, t._)`"/" + ${R}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
    }
    return L ? (0, t.getProperty)(R).toString() : "/" + p(R);
  }
  e.getErrorPath = E;
  function S(R, j, L = R.opts.strictSchema) {
    if (L) {
      if (j = `strict mode: ${j}`, L === !0)
        throw new Error(j);
      R.self.logger.warn(j);
    }
  }
  e.checkStrictMode = S;
})(Pt);
var Qr = {};
Object.defineProperty(Qr, "__esModule", { value: !0 });
const wr = pt, W8 = {
  // validation function arguments
  data: new wr.Name("data"),
  // args passed from referencing schema
  valCxt: new wr.Name("valCxt"),
  instancePath: new wr.Name("instancePath"),
  parentData: new wr.Name("parentData"),
  parentDataProperty: new wr.Name("parentDataProperty"),
  rootData: new wr.Name("rootData"),
  dynamicAnchors: new wr.Name("dynamicAnchors"),
  // function scoped variables
  vErrors: new wr.Name("vErrors"),
  errors: new wr.Name("errors"),
  this: new wr.Name("this"),
  // "globals"
  self: new wr.Name("self"),
  scope: new wr.Name("scope"),
  // JTD serialize/parse name for JSON string and position
  json: new wr.Name("json"),
  jsonPos: new wr.Name("jsonPos"),
  jsonLen: new wr.Name("jsonLen"),
  jsonPart: new wr.Name("jsonPart")
};
Qr.default = W8;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.extendErrors = e.resetErrorsCount = e.reportExtraError = e.reportError = e.keyword$DataError = e.keywordError = void 0;
  const t = pt, r = Pt, i = Qr;
  e.keywordError = {
    message: ({ keyword: _ }) => (0, t.str)`must pass "${_}" keyword validation`
  }, e.keyword$DataError = {
    message: ({ keyword: _, schemaType: y }) => y ? (0, t.str)`"${_}" keyword must be ${y} ($data)` : (0, t.str)`"${_}" keyword is invalid ($data)`
  };
  function n(_, y = e.keywordError, w, $) {
    const { it: E } = _, { gen: S, compositeRule: R, allErrors: j } = E, L = p(_, y, w);
    $ ?? (R || j) ? c(S, L) : l(E, (0, t._)`[${L}]`);
  }
  e.reportError = n;
  function s(_, y = e.keywordError, w) {
    const { it: $ } = _, { gen: E, compositeRule: S, allErrors: R } = $, j = p(_, y, w);
    c(E, j), S || R || l($, i.default.vErrors);
  }
  e.reportExtraError = s;
  function a(_, y) {
    _.assign(i.default.errors, y), _.if((0, t._)`${i.default.vErrors} !== null`, () => _.if(y, () => _.assign((0, t._)`${i.default.vErrors}.length`, y), () => _.assign(i.default.vErrors, null)));
  }
  e.resetErrorsCount = a;
  function o({ gen: _, keyword: y, schemaValue: w, data: $, errsCount: E, it: S }) {
    if (E === void 0)
      throw new Error("ajv implementation error");
    const R = _.name("err");
    _.forRange("i", E, i.default.errors, (j) => {
      _.const(R, (0, t._)`${i.default.vErrors}[${j}]`), _.if((0, t._)`${R}.instancePath === undefined`, () => _.assign((0, t._)`${R}.instancePath`, (0, t.strConcat)(i.default.instancePath, S.errorPath))), _.assign((0, t._)`${R}.schemaPath`, (0, t.str)`${S.errSchemaPath}/${y}`), S.opts.verbose && (_.assign((0, t._)`${R}.schema`, w), _.assign((0, t._)`${R}.data`, $));
    });
  }
  e.extendErrors = o;
  function c(_, y) {
    const w = _.const("err", y);
    _.if((0, t._)`${i.default.vErrors} === null`, () => _.assign(i.default.vErrors, (0, t._)`[${w}]`), (0, t._)`${i.default.vErrors}.push(${w})`), _.code((0, t._)`${i.default.errors}++`);
  }
  function l(_, y) {
    const { gen: w, validateName: $, schemaEnv: E } = _;
    E.$async ? w.throw((0, t._)`new ${_.ValidationError}(${y})`) : (w.assign((0, t._)`${$}.errors`, y), w.return(!1));
  }
  const d = {
    keyword: new t.Name("keyword"),
    schemaPath: new t.Name("schemaPath"),
    params: new t.Name("params"),
    propertyName: new t.Name("propertyName"),
    message: new t.Name("message"),
    schema: new t.Name("schema"),
    parentSchema: new t.Name("parentSchema")
  };
  function p(_, y, w) {
    const { createErrors: $ } = _.it;
    return $ === !1 ? (0, t._)`{}` : h(_, y, w);
  }
  function h(_, y, w = {}) {
    const { gen: $, it: E } = _, S = [
      g(E, w),
      m(_, w)
    ];
    return v(_, y, S), $.object(...S);
  }
  function g({ errorPath: _ }, { instancePath: y }) {
    const w = y ? (0, t.str)`${_}${(0, r.getErrorPath)(y, r.Type.Str)}` : _;
    return [i.default.instancePath, (0, t.strConcat)(i.default.instancePath, w)];
  }
  function m({ keyword: _, it: { errSchemaPath: y } }, { schemaPath: w, parentSchema: $ }) {
    let E = $ ? y : (0, t.str)`${y}/${_}`;
    return w && (E = (0, t.str)`${E}${(0, r.getErrorPath)(w, r.Type.Str)}`), [d.schemaPath, E];
  }
  function v(_, { params: y, message: w }, $) {
    const { keyword: E, data: S, schemaValue: R, it: j } = _, { opts: L, propertyName: K, topSchemaRef: ae, schemaPath: ye } = j;
    $.push([d.keyword, E], [d.params, typeof y == "function" ? y(_) : y || (0, t._)`{}`]), L.messages && $.push([d.message, typeof w == "function" ? w(_) : w]), L.verbose && $.push([d.schema, R], [d.parentSchema, (0, t._)`${ae}${ye}`], [i.default.data, S]), K && $.push([d.propertyName, K]);
  }
})(Yu);
var Pw;
function H8() {
  if (Pw)
    return Rs;
  Pw = 1, Object.defineProperty(Rs, "__esModule", { value: !0 }), Rs.boolOrEmptySchema = Rs.topBoolOrEmptySchema = void 0;
  const e = Yu, t = pt, r = Qr, i = {
    message: "boolean schema is false"
  };
  function n(o) {
    const { gen: c, schema: l, validateName: d } = o;
    l === !1 ? a(o, !1) : typeof l == "object" && l.$async === !0 ? c.return(r.default.data) : (c.assign((0, t._)`${d}.errors`, null), c.return(!0));
  }
  Rs.topBoolOrEmptySchema = n;
  function s(o, c) {
    const { gen: l, schema: d } = o;
    d === !1 ? (l.var(c, !1), a(o)) : l.var(c, !0);
  }
  Rs.boolOrEmptySchema = s;
  function a(o, c) {
    const { gen: l, data: d } = o, p = {
      gen: l,
      keyword: "false schema",
      data: d,
      schema: !1,
      schemaCode: !1,
      schemaValue: !1,
      params: {},
      it: o
    };
    (0, e.reportError)(p, i, void 0, c);
  }
  return Rs;
}
var ku = {}, Gs = {};
Object.defineProperty(Gs, "__esModule", { value: !0 });
Gs.getRules = Gs.isJSONType = void 0;
const G8 = ["string", "number", "integer", "boolean", "null", "object", "array"], K8 = new Set(G8);
function Y8(e) {
  return typeof e == "string" && K8.has(e);
}
Gs.isJSONType = Y8;
function J8() {
  const e = {
    number: { type: "number", rules: [] },
    string: { type: "string", rules: [] },
    array: { type: "array", rules: [] },
    object: { type: "object", rules: [] }
  };
  return {
    types: { ...e, integer: !0, boolean: !0, null: !0 },
    rules: [{ rules: [] }, e.number, e.string, e.array, e.object],
    post: { rules: [] },
    all: {},
    keywords: {}
  };
}
Gs.getRules = J8;
var $i = {};
Object.defineProperty($i, "__esModule", { value: !0 });
$i.shouldUseRule = $i.shouldUseGroup = $i.schemaHasRulesForType = void 0;
function X8({ schema: e, self: t }, r) {
  const i = t.RULES.types[r];
  return i && i !== !0 && UO(e, i);
}
$i.schemaHasRulesForType = X8;
function UO(e, t) {
  return t.rules.some((r) => BO(e, r));
}
$i.shouldUseGroup = UO;
function BO(e, t) {
  var r;
  return e[t.keyword] !== void 0 || ((r = t.definition.implements) === null || r === void 0 ? void 0 : r.some((i) => e[i] !== void 0));
}
$i.shouldUseRule = BO;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.reportTypeError = e.checkDataTypes = e.checkDataType = e.coerceAndCheckDataType = e.getJSONTypes = e.getSchemaTypes = e.DataType = void 0;
  const t = Gs, r = $i, i = Yu, n = pt, s = Pt;
  var a;
  (function($) {
    $[$.Correct = 0] = "Correct", $[$.Wrong = 1] = "Wrong";
  })(a = e.DataType || (e.DataType = {}));
  function o($) {
    const E = c($.type);
    if (E.includes("null")) {
      if ($.nullable === !1)
        throw new Error("type: null contradicts nullable: false");
    } else {
      if (!E.length && $.nullable !== void 0)
        throw new Error('"nullable" cannot be used without "type"');
      $.nullable === !0 && E.push("null");
    }
    return E;
  }
  e.getSchemaTypes = o;
  function c($) {
    const E = Array.isArray($) ? $ : $ ? [$] : [];
    if (E.every(t.isJSONType))
      return E;
    throw new Error("type must be JSONType or JSONType[]: " + E.join(","));
  }
  e.getJSONTypes = c;
  function l($, E) {
    const { gen: S, data: R, opts: j } = $, L = p(E, j.coerceTypes), K = E.length > 0 && !(L.length === 0 && E.length === 1 && (0, r.schemaHasRulesForType)($, E[0]));
    if (K) {
      const ae = v(E, R, j.strictNumbers, a.Wrong);
      S.if(ae, () => {
        L.length ? h($, E, L) : y($);
      });
    }
    return K;
  }
  e.coerceAndCheckDataType = l;
  const d = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
  function p($, E) {
    return E ? $.filter((S) => d.has(S) || E === "array" && S === "array") : [];
  }
  function h($, E, S) {
    const { gen: R, data: j, opts: L } = $, K = R.let("dataType", (0, n._)`typeof ${j}`), ae = R.let("coerced", (0, n._)`undefined`);
    L.coerceTypes === "array" && R.if((0, n._)`${K} == 'object' && Array.isArray(${j}) && ${j}.length == 1`, () => R.assign(j, (0, n._)`${j}[0]`).assign(K, (0, n._)`typeof ${j}`).if(v(E, j, L.strictNumbers), () => R.assign(ae, j))), R.if((0, n._)`${ae} !== undefined`);
    for (const xe of S)
      (d.has(xe) || xe === "array" && L.coerceTypes === "array") && ye(xe);
    R.else(), y($), R.endIf(), R.if((0, n._)`${ae} !== undefined`, () => {
      R.assign(j, ae), g($, ae);
    });
    function ye(xe) {
      switch (xe) {
        case "string":
          R.elseIf((0, n._)`${K} == "number" || ${K} == "boolean"`).assign(ae, (0, n._)`"" + ${j}`).elseIf((0, n._)`${j} === null`).assign(ae, (0, n._)`""`);
          return;
        case "number":
          R.elseIf((0, n._)`${K} == "boolean" || ${j} === null
              || (${K} == "string" && ${j} && ${j} == +${j})`).assign(ae, (0, n._)`+${j}`);
          return;
        case "integer":
          R.elseIf((0, n._)`${K} === "boolean" || ${j} === null
              || (${K} === "string" && ${j} && ${j} == +${j} && !(${j} % 1))`).assign(ae, (0, n._)`+${j}`);
          return;
        case "boolean":
          R.elseIf((0, n._)`${j} === "false" || ${j} === 0 || ${j} === null`).assign(ae, !1).elseIf((0, n._)`${j} === "true" || ${j} === 1`).assign(ae, !0);
          return;
        case "null":
          R.elseIf((0, n._)`${j} === "" || ${j} === 0 || ${j} === false`), R.assign(ae, null);
          return;
        case "array":
          R.elseIf((0, n._)`${K} === "string" || ${K} === "number"
              || ${K} === "boolean" || ${j} === null`).assign(ae, (0, n._)`[${j}]`);
      }
    }
  }
  function g({ gen: $, parentData: E, parentDataProperty: S }, R) {
    $.if((0, n._)`${E} !== undefined`, () => $.assign((0, n._)`${E}[${S}]`, R));
  }
  function m($, E, S, R = a.Correct) {
    const j = R === a.Correct ? n.operators.EQ : n.operators.NEQ;
    let L;
    switch ($) {
      case "null":
        return (0, n._)`${E} ${j} null`;
      case "array":
        L = (0, n._)`Array.isArray(${E})`;
        break;
      case "object":
        L = (0, n._)`${E} && typeof ${E} == "object" && !Array.isArray(${E})`;
        break;
      case "integer":
        L = K((0, n._)`!(${E} % 1) && !isNaN(${E})`);
        break;
      case "number":
        L = K();
        break;
      default:
        return (0, n._)`typeof ${E} ${j} ${$}`;
    }
    return R === a.Correct ? L : (0, n.not)(L);
    function K(ae = n.nil) {
      return (0, n.and)((0, n._)`typeof ${E} == "number"`, ae, S ? (0, n._)`isFinite(${E})` : n.nil);
    }
  }
  e.checkDataType = m;
  function v($, E, S, R) {
    if ($.length === 1)
      return m($[0], E, S, R);
    let j;
    const L = (0, s.toHash)($);
    if (L.array && L.object) {
      const K = (0, n._)`typeof ${E} != "object"`;
      j = L.null ? K : (0, n._)`!${E} || ${K}`, delete L.null, delete L.array, delete L.object;
    } else
      j = n.nil;
    L.number && delete L.integer;
    for (const K in L)
      j = (0, n.and)(j, m(K, E, S, R));
    return j;
  }
  e.checkDataTypes = v;
  const _ = {
    message: ({ schema: $ }) => `must be ${$}`,
    params: ({ schema: $, schemaValue: E }) => typeof $ == "string" ? (0, n._)`{type: ${$}}` : (0, n._)`{type: ${E}}`
  };
  function y($) {
    const E = w($);
    (0, i.reportError)(E, _);
  }
  e.reportTypeError = y;
  function w($) {
    const { gen: E, data: S, schema: R } = $, j = (0, s.schemaRefOrVal)($, R, "type");
    return {
      gen: E,
      keyword: "type",
      data: S,
      schema: R.type,
      schemaCode: j,
      schemaValue: j,
      parentSchema: R,
      params: {},
      it: $
    };
  }
})(ku);
var Zo = {}, Sw;
function Q8() {
  if (Sw)
    return Zo;
  Sw = 1, Object.defineProperty(Zo, "__esModule", { value: !0 }), Zo.assignDefaults = void 0;
  const e = pt, t = Pt;
  function r(n, s) {
    const { properties: a, items: o } = n.schema;
    if (s === "object" && a)
      for (const c in a)
        i(n, c, a[c].default);
    else
      s === "array" && Array.isArray(o) && o.forEach((c, l) => i(n, l, c.default));
  }
  Zo.assignDefaults = r;
  function i(n, s, a) {
    const { gen: o, compositeRule: c, data: l, opts: d } = n;
    if (a === void 0)
      return;
    const p = (0, e._)`${l}${(0, e.getProperty)(s)}`;
    if (c) {
      (0, t.checkStrictMode)(n, `default is ignored for: ${p}`);
      return;
    }
    let h = (0, e._)`${p} === undefined`;
    d.useDefaults === "empty" && (h = (0, e._)`${h} || ${p} === null || ${p} === ""`), o.if(h, (0, e._)`${p} = ${(0, e.stringify)(a)}`);
  }
  return Zo;
}
var _n = {}, Lt = {}, Aw;
function Mn() {
  if (Aw)
    return Lt;
  Aw = 1, Object.defineProperty(Lt, "__esModule", { value: !0 }), Lt.validateUnion = Lt.validateArray = Lt.usePattern = Lt.callValidateCode = Lt.schemaProperties = Lt.allSchemaProperties = Lt.noPropertyInData = Lt.propertyInData = Lt.isOwnProperty = Lt.hasPropFunc = Lt.reportMissingProp = Lt.checkMissingProp = Lt.checkReportMissingProp = void 0;
  const e = pt, t = Pt, r = Qr, i = Pt;
  function n(w, $) {
    const { gen: E, data: S, it: R } = w;
    E.if(d(E, S, $, R.opts.ownProperties), () => {
      w.setParams({ missingProperty: (0, e._)`${$}` }, !0), w.error();
    });
  }
  Lt.checkReportMissingProp = n;
  function s({ gen: w, data: $, it: { opts: E } }, S, R) {
    return (0, e.or)(...S.map((j) => (0, e.and)(d(w, $, j, E.ownProperties), (0, e._)`${R} = ${j}`)));
  }
  Lt.checkMissingProp = s;
  function a(w, $) {
    w.setParams({ missingProperty: $ }, !0), w.error();
  }
  Lt.reportMissingProp = a;
  function o(w) {
    return w.scopeValue("func", {
      // eslint-disable-next-line @typescript-eslint/unbound-method
      ref: Object.prototype.hasOwnProperty,
      code: (0, e._)`Object.prototype.hasOwnProperty`
    });
  }
  Lt.hasPropFunc = o;
  function c(w, $, E) {
    return (0, e._)`${o(w)}.call(${$}, ${E})`;
  }
  Lt.isOwnProperty = c;
  function l(w, $, E, S) {
    const R = (0, e._)`${$}${(0, e.getProperty)(E)} !== undefined`;
    return S ? (0, e._)`${R} && ${c(w, $, E)}` : R;
  }
  Lt.propertyInData = l;
  function d(w, $, E, S) {
    const R = (0, e._)`${$}${(0, e.getProperty)(E)} === undefined`;
    return S ? (0, e.or)(R, (0, e.not)(c(w, $, E))) : R;
  }
  Lt.noPropertyInData = d;
  function p(w) {
    return w ? Object.keys(w).filter(($) => $ !== "__proto__") : [];
  }
  Lt.allSchemaProperties = p;
  function h(w, $) {
    return p($).filter((E) => !(0, t.alwaysValidSchema)(w, $[E]));
  }
  Lt.schemaProperties = h;
  function g({ schemaCode: w, data: $, it: { gen: E, topSchemaRef: S, schemaPath: R, errorPath: j }, it: L }, K, ae, ye) {
    const xe = ye ? (0, e._)`${w}, ${$}, ${S}${R}` : $, Pe = [
      [r.default.instancePath, (0, e.strConcat)(r.default.instancePath, j)],
      [r.default.parentData, L.parentData],
      [r.default.parentDataProperty, L.parentDataProperty],
      [r.default.rootData, r.default.rootData]
    ];
    L.opts.dynamicRef && Pe.push([r.default.dynamicAnchors, r.default.dynamicAnchors]);
    const te = (0, e._)`${xe}, ${E.object(...Pe)}`;
    return ae !== e.nil ? (0, e._)`${K}.call(${ae}, ${te})` : (0, e._)`${K}(${te})`;
  }
  Lt.callValidateCode = g;
  const m = (0, e._)`new RegExp`;
  function v({ gen: w, it: { opts: $ } }, E) {
    const S = $.unicodeRegExp ? "u" : "", { regExp: R } = $.code, j = R(E, S);
    return w.scopeValue("pattern", {
      key: j.toString(),
      ref: j,
      code: (0, e._)`${R.code === "new RegExp" ? m : (0, i.useFunc)(w, R)}(${E}, ${S})`
    });
  }
  Lt.usePattern = v;
  function _(w) {
    const { gen: $, data: E, keyword: S, it: R } = w, j = $.name("valid");
    if (R.allErrors) {
      const K = $.let("valid", !0);
      return L(() => $.assign(K, !1)), K;
    }
    return $.var(j, !0), L(() => $.break()), j;
    function L(K) {
      const ae = $.const("len", (0, e._)`${E}.length`);
      $.forRange("i", 0, ae, (ye) => {
        w.subschema({
          keyword: S,
          dataProp: ye,
          dataPropType: t.Type.Num
        }, j), $.if((0, e.not)(j), K);
      });
    }
  }
  Lt.validateArray = _;
  function y(w) {
    const { gen: $, schema: E, keyword: S, it: R } = w;
    if (!Array.isArray(E))
      throw new Error("ajv implementation error");
    if (E.some((ae) => (0, t.alwaysValidSchema)(R, ae)) && !R.opts.unevaluated)
      return;
    const L = $.let("valid", !1), K = $.name("_valid");
    $.block(() => E.forEach((ae, ye) => {
      const xe = w.subschema({
        keyword: S,
        schemaProp: ye,
        compositeRule: !0
      }, K);
      $.assign(L, (0, e._)`${L} || ${K}`), w.mergeValidEvaluated(xe, K) || $.if((0, e.not)(L));
    })), w.result(L, () => w.reset(), () => w.error(!0));
  }
  return Lt.validateUnion = y, Lt;
}
var Cw;
function eF() {
  if (Cw)
    return _n;
  Cw = 1, Object.defineProperty(_n, "__esModule", { value: !0 }), _n.validateKeywordUsage = _n.validSchemaType = _n.funcKeywordCode = _n.macroKeywordCode = void 0;
  const e = pt, t = Qr, r = Mn(), i = Yu;
  function n(h, g) {
    const { gen: m, keyword: v, schema: _, parentSchema: y, it: w } = h, $ = g.macro.call(w.self, _, y, w), E = l(m, v, $);
    w.opts.validateSchema !== !1 && w.self.validateSchema($, !0);
    const S = m.name("valid");
    h.subschema({
      schema: $,
      schemaPath: e.nil,
      errSchemaPath: `${w.errSchemaPath}/${v}`,
      topSchemaRef: E,
      compositeRule: !0
    }, S), h.pass(S, () => h.error(!0));
  }
  _n.macroKeywordCode = n;
  function s(h, g) {
    var m;
    const { gen: v, keyword: _, schema: y, parentSchema: w, $data: $, it: E } = h;
    c(E, g);
    const S = !$ && g.compile ? g.compile.call(E.self, y, w, E) : g.validate, R = l(v, _, S), j = v.let("valid");
    h.block$data(j, L), h.ok((m = g.valid) !== null && m !== void 0 ? m : j);
    function L() {
      if (g.errors === !1)
        ye(), g.modifying && a(h), xe(() => h.error());
      else {
        const Pe = g.async ? K() : ae();
        g.modifying && a(h), xe(() => o(h, Pe));
      }
    }
    function K() {
      const Pe = v.let("ruleErrs", null);
      return v.try(() => ye((0, e._)`await `), (te) => v.assign(j, !1).if((0, e._)`${te} instanceof ${E.ValidationError}`, () => v.assign(Pe, (0, e._)`${te}.errors`), () => v.throw(te))), Pe;
    }
    function ae() {
      const Pe = (0, e._)`${R}.errors`;
      return v.assign(Pe, null), ye(e.nil), Pe;
    }
    function ye(Pe = g.async ? (0, e._)`await ` : e.nil) {
      const te = E.opts.passContext ? t.default.this : t.default.self, pe = !("compile" in g && !$ || g.schema === !1);
      v.assign(j, (0, e._)`${Pe}${(0, r.callValidateCode)(h, R, te, pe)}`, g.modifying);
    }
    function xe(Pe) {
      var te;
      v.if((0, e.not)((te = g.valid) !== null && te !== void 0 ? te : j), Pe);
    }
  }
  _n.funcKeywordCode = s;
  function a(h) {
    const { gen: g, data: m, it: v } = h;
    g.if(v.parentData, () => g.assign(m, (0, e._)`${v.parentData}[${v.parentDataProperty}]`));
  }
  function o(h, g) {
    const { gen: m } = h;
    m.if((0, e._)`Array.isArray(${g})`, () => {
      m.assign(t.default.vErrors, (0, e._)`${t.default.vErrors} === null ? ${g} : ${t.default.vErrors}.concat(${g})`).assign(t.default.errors, (0, e._)`${t.default.vErrors}.length`), (0, i.extendErrors)(h);
    }, () => h.error());
  }
  function c({ schemaEnv: h }, g) {
    if (g.async && !h.$async)
      throw new Error("async keyword in sync schema");
  }
  function l(h, g, m) {
    if (m === void 0)
      throw new Error(`keyword "${g}" failed to compile`);
    return h.scopeValue("keyword", typeof m == "function" ? { ref: m } : { ref: m, code: (0, e.stringify)(m) });
  }
  function d(h, g, m = !1) {
    return !g.length || g.some((v) => v === "array" ? Array.isArray(h) : v === "object" ? h && typeof h == "object" && !Array.isArray(h) : typeof h == v || m && typeof h > "u");
  }
  _n.validSchemaType = d;
  function p({ schema: h, opts: g, self: m, errSchemaPath: v }, _, y) {
    if (Array.isArray(_.keyword) ? !_.keyword.includes(y) : _.keyword !== y)
      throw new Error("ajv implementation error");
    const w = _.dependencies;
    if (w != null && w.some(($) => !Object.prototype.hasOwnProperty.call(h, $)))
      throw new Error(`parent schema must have dependencies of ${y}: ${w.join(",")}`);
    if (_.validateSchema && !_.validateSchema(h[y])) {
      const E = `keyword "${y}" value is invalid at path "${v}": ` + m.errorsText(_.validateSchema.errors);
      if (g.validateSchema === "log")
        m.logger.error(E);
      else
        throw new Error(E);
    }
  }
  return _n.validateKeywordUsage = p, _n;
}
var mi = {}, Rw;
function tF() {
  if (Rw)
    return mi;
  Rw = 1, Object.defineProperty(mi, "__esModule", { value: !0 }), mi.extendSubschemaMode = mi.extendSubschemaData = mi.getSubschema = void 0;
  const e = pt, t = Pt;
  function r(s, { keyword: a, schemaProp: o, schema: c, schemaPath: l, errSchemaPath: d, topSchemaRef: p }) {
    if (a !== void 0 && c !== void 0)
      throw new Error('both "keyword" and "schema" passed, only one allowed');
    if (a !== void 0) {
      const h = s.schema[a];
      return o === void 0 ? {
        schema: h,
        schemaPath: (0, e._)`${s.schemaPath}${(0, e.getProperty)(a)}`,
        errSchemaPath: `${s.errSchemaPath}/${a}`
      } : {
        schema: h[o],
        schemaPath: (0, e._)`${s.schemaPath}${(0, e.getProperty)(a)}${(0, e.getProperty)(o)}`,
        errSchemaPath: `${s.errSchemaPath}/${a}/${(0, t.escapeFragment)(o)}`
      };
    }
    if (c !== void 0) {
      if (l === void 0 || d === void 0 || p === void 0)
        throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
      return {
        schema: c,
        schemaPath: l,
        topSchemaRef: p,
        errSchemaPath: d
      };
    }
    throw new Error('either "keyword" or "schema" must be passed');
  }
  mi.getSubschema = r;
  function i(s, a, { dataProp: o, dataPropType: c, data: l, dataTypes: d, propertyName: p }) {
    if (l !== void 0 && o !== void 0)
      throw new Error('both "data" and "dataProp" passed, only one allowed');
    const { gen: h } = a;
    if (o !== void 0) {
      const { errorPath: m, dataPathArr: v, opts: _ } = a, y = h.let("data", (0, e._)`${a.data}${(0, e.getProperty)(o)}`, !0);
      g(y), s.errorPath = (0, e.str)`${m}${(0, t.getErrorPath)(o, c, _.jsPropertySyntax)}`, s.parentDataProperty = (0, e._)`${o}`, s.dataPathArr = [...v, s.parentDataProperty];
    }
    if (l !== void 0) {
      const m = l instanceof e.Name ? l : h.let("data", l, !0);
      g(m), p !== void 0 && (s.propertyName = p);
    }
    d && (s.dataTypes = d);
    function g(m) {
      s.data = m, s.dataLevel = a.dataLevel + 1, s.dataTypes = [], a.definedProperties = /* @__PURE__ */ new Set(), s.parentData = a.data, s.dataNames = [...a.dataNames, m];
    }
  }
  mi.extendSubschemaData = i;
  function n(s, { jtdDiscriminator: a, jtdMetadata: o, compositeRule: c, createErrors: l, allErrors: d }) {
    c !== void 0 && (s.compositeRule = c), l !== void 0 && (s.createErrors = l), d !== void 0 && (s.allErrors = d), s.jtdDiscriminator = a, s.jtdMetadata = o;
  }
  return mi.extendSubschemaMode = n, mi;
}
var mr = {}, VO = function e(t, r) {
  if (t === r)
    return !0;
  if (t && r && typeof t == "object" && typeof r == "object") {
    if (t.constructor !== r.constructor)
      return !1;
    var i, n, s;
    if (Array.isArray(t)) {
      if (i = t.length, i != r.length)
        return !1;
      for (n = i; n-- !== 0; )
        if (!e(t[n], r[n]))
          return !1;
      return !0;
    }
    if (t.constructor === RegExp)
      return t.source === r.source && t.flags === r.flags;
    if (t.valueOf !== Object.prototype.valueOf)
      return t.valueOf() === r.valueOf();
    if (t.toString !== Object.prototype.toString)
      return t.toString() === r.toString();
    if (s = Object.keys(t), i = s.length, i !== Object.keys(r).length)
      return !1;
    for (n = i; n-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(r, s[n]))
        return !1;
    for (n = i; n-- !== 0; ) {
      var a = s[n];
      if (!e(t[a], r[a]))
        return !1;
    }
    return !0;
  }
  return t !== t && r !== r;
}, ZO = { exports: {} }, es = ZO.exports = function(e, t, r) {
  typeof t == "function" && (r = t, t = {}), r = t.cb || r;
  var i = typeof r == "function" ? r : r.pre || function() {
  }, n = r.post || function() {
  };
  Sl(t, i, n, e, "", e);
};
es.keywords = {
  additionalItems: !0,
  items: !0,
  contains: !0,
  additionalProperties: !0,
  propertyNames: !0,
  not: !0,
  if: !0,
  then: !0,
  else: !0
};
es.arrayKeywords = {
  items: !0,
  allOf: !0,
  anyOf: !0,
  oneOf: !0
};
es.propsKeywords = {
  $defs: !0,
  definitions: !0,
  properties: !0,
  patternProperties: !0,
  dependencies: !0
};
es.skipKeywords = {
  default: !0,
  enum: !0,
  const: !0,
  required: !0,
  maximum: !0,
  minimum: !0,
  exclusiveMaximum: !0,
  exclusiveMinimum: !0,
  multipleOf: !0,
  maxLength: !0,
  minLength: !0,
  pattern: !0,
  format: !0,
  maxItems: !0,
  minItems: !0,
  uniqueItems: !0,
  maxProperties: !0,
  minProperties: !0
};
function Sl(e, t, r, i, n, s, a, o, c, l) {
  if (i && typeof i == "object" && !Array.isArray(i)) {
    t(i, n, s, a, o, c, l);
    for (var d in i) {
      var p = i[d];
      if (Array.isArray(p)) {
        if (d in es.arrayKeywords)
          for (var h = 0; h < p.length; h++)
            Sl(e, t, r, p[h], n + "/" + d + "/" + h, s, n, d, i, h);
      } else if (d in es.propsKeywords) {
        if (p && typeof p == "object")
          for (var g in p)
            Sl(e, t, r, p[g], n + "/" + d + "/" + rF(g), s, n, d, i, g);
      } else
        (d in es.keywords || e.allKeys && !(d in es.skipKeywords)) && Sl(e, t, r, p, n + "/" + d, s, n, d, i);
    }
    r(i, n, s, a, o, c, l);
  }
}
function rF(e) {
  return e.replace(/~/g, "~0").replace(/\//g, "~1");
}
var nF = ZO.exports;
Object.defineProperty(mr, "__esModule", { value: !0 });
mr.getSchemaRefs = mr.resolveUrl = mr.normalizeId = mr._getFullPath = mr.getFullPath = mr.inlineRef = void 0;
const iF = Pt, sF = VO, aF = nF, oF = /* @__PURE__ */ new Set([
  "type",
  "format",
  "pattern",
  "maxLength",
  "minLength",
  "maxProperties",
  "minProperties",
  "maxItems",
  "minItems",
  "maximum",
  "minimum",
  "uniqueItems",
  "multipleOf",
  "required",
  "enum",
  "const"
]);
function uF(e, t = !0) {
  return typeof e == "boolean" ? !0 : t === !0 ? !Sy(e) : t ? zO(e) <= t : !1;
}
mr.inlineRef = uF;
const cF = /* @__PURE__ */ new Set([
  "$ref",
  "$recursiveRef",
  "$recursiveAnchor",
  "$dynamicRef",
  "$dynamicAnchor"
]);
function Sy(e) {
  for (const t in e) {
    if (cF.has(t))
      return !0;
    const r = e[t];
    if (Array.isArray(r) && r.some(Sy) || typeof r == "object" && Sy(r))
      return !0;
  }
  return !1;
}
function zO(e) {
  let t = 0;
  for (const r in e) {
    if (r === "$ref")
      return 1 / 0;
    if (t++, !oF.has(r) && (typeof e[r] == "object" && (0, iF.eachItem)(e[r], (i) => t += zO(i)), t === 1 / 0))
      return 1 / 0;
  }
  return t;
}
function WO(e, t = "", r) {
  r !== !1 && (t = Wa(t));
  const i = e.parse(t);
  return HO(e, i);
}
mr.getFullPath = WO;
function HO(e, t) {
  return e.serialize(t).split("#")[0] + "#";
}
mr._getFullPath = HO;
const lF = /#\/?$/;
function Wa(e) {
  return e ? e.replace(lF, "") : "";
}
mr.normalizeId = Wa;
function fF(e, t, r) {
  return r = Wa(r), e.resolve(t, r);
}
mr.resolveUrl = fF;
const dF = /^[a-z_][-a-z0-9._]*$/i;
function pF(e, t) {
  if (typeof e == "boolean")
    return {};
  const { schemaId: r, uriResolver: i } = this.opts, n = Wa(e[r] || t), s = { "": n }, a = WO(i, n, !1), o = {}, c = /* @__PURE__ */ new Set();
  return aF(e, { allKeys: !0 }, (p, h, g, m) => {
    if (m === void 0)
      return;
    const v = a + h;
    let _ = s[m];
    typeof p[r] == "string" && (_ = y.call(this, p[r])), w.call(this, p.$anchor), w.call(this, p.$dynamicAnchor), s[h] = _;
    function y($) {
      const E = this.opts.uriResolver.resolve;
      if ($ = Wa(_ ? E(_, $) : $), c.has($))
        throw d($);
      c.add($);
      let S = this.refs[$];
      return typeof S == "string" && (S = this.refs[S]), typeof S == "object" ? l(p, S.schema, $) : $ !== Wa(v) && ($[0] === "#" ? (l(p, o[$], $), o[$] = p) : this.refs[$] = v), $;
    }
    function w($) {
      if (typeof $ == "string") {
        if (!dF.test($))
          throw new Error(`invalid anchor "${$}"`);
        y.call(this, `#${$}`);
      }
    }
  }), o;
  function l(p, h, g) {
    if (h !== void 0 && !sF(p, h))
      throw d(g);
  }
  function d(p) {
    return new Error(`reference "${p}" resolves to more than one schema`);
  }
}
mr.getSchemaRefs = pF;
var Tw;
function Bf() {
  if (Tw)
    return hi;
  Tw = 1, Object.defineProperty(hi, "__esModule", { value: !0 }), hi.getData = hi.KeywordCxt = hi.validateFunctionCode = void 0;
  const e = H8(), t = ku, r = $i, i = ku, n = Q8(), s = eF(), a = tF(), o = pt, c = Qr, l = mr, d = Pt, p = Yu;
  function h(A) {
    if (S(A) && (j(A), E(A))) {
      _(A);
      return;
    }
    g(A, () => (0, e.topBoolOrEmptySchema)(A));
  }
  hi.validateFunctionCode = h;
  function g({ gen: A, validateName: I, schema: X, schemaEnv: oe, opts: Ae }, je) {
    Ae.code.es5 ? A.func(I, (0, o._)`${c.default.data}, ${c.default.valCxt}`, oe.$async, () => {
      A.code((0, o._)`"use strict"; ${w(X, Ae)}`), v(A, Ae), A.code(je);
    }) : A.func(I, (0, o._)`${c.default.data}, ${m(Ae)}`, oe.$async, () => A.code(w(X, Ae)).code(je));
  }
  function m(A) {
    return (0, o._)`{${c.default.instancePath}="", ${c.default.parentData}, ${c.default.parentDataProperty}, ${c.default.rootData}=${c.default.data}${A.dynamicRef ? (0, o._)`, ${c.default.dynamicAnchors}={}` : o.nil}}={}`;
  }
  function v(A, I) {
    A.if(c.default.valCxt, () => {
      A.var(c.default.instancePath, (0, o._)`${c.default.valCxt}.${c.default.instancePath}`), A.var(c.default.parentData, (0, o._)`${c.default.valCxt}.${c.default.parentData}`), A.var(c.default.parentDataProperty, (0, o._)`${c.default.valCxt}.${c.default.parentDataProperty}`), A.var(c.default.rootData, (0, o._)`${c.default.valCxt}.${c.default.rootData}`), I.dynamicRef && A.var(c.default.dynamicAnchors, (0, o._)`${c.default.valCxt}.${c.default.dynamicAnchors}`);
    }, () => {
      A.var(c.default.instancePath, (0, o._)`""`), A.var(c.default.parentData, (0, o._)`undefined`), A.var(c.default.parentDataProperty, (0, o._)`undefined`), A.var(c.default.rootData, c.default.data), I.dynamicRef && A.var(c.default.dynamicAnchors, (0, o._)`{}`);
    });
  }
  function _(A) {
    const { schema: I, opts: X, gen: oe } = A;
    g(A, () => {
      X.$comment && I.$comment && Pe(A), ae(A), oe.let(c.default.vErrors, null), oe.let(c.default.errors, 0), X.unevaluated && y(A), L(A), te(A);
    });
  }
  function y(A) {
    const { gen: I, validateName: X } = A;
    A.evaluated = I.const("evaluated", (0, o._)`${X}.evaluated`), I.if((0, o._)`${A.evaluated}.dynamicProps`, () => I.assign((0, o._)`${A.evaluated}.props`, (0, o._)`undefined`)), I.if((0, o._)`${A.evaluated}.dynamicItems`, () => I.assign((0, o._)`${A.evaluated}.items`, (0, o._)`undefined`));
  }
  function w(A, I) {
    const X = typeof A == "object" && A[I.schemaId];
    return X && (I.code.source || I.code.process) ? (0, o._)`/*# sourceURL=${X} */` : o.nil;
  }
  function $(A, I) {
    if (S(A) && (j(A), E(A))) {
      R(A, I);
      return;
    }
    (0, e.boolOrEmptySchema)(A, I);
  }
  function E({ schema: A, self: I }) {
    if (typeof A == "boolean")
      return !A;
    for (const X in A)
      if (I.RULES.all[X])
        return !0;
    return !1;
  }
  function S(A) {
    return typeof A.schema != "boolean";
  }
  function R(A, I) {
    const { schema: X, gen: oe, opts: Ae } = A;
    Ae.$comment && X.$comment && Pe(A), ye(A), xe(A);
    const je = oe.const("_errs", c.default.errors);
    L(A, je), oe.var(I, (0, o._)`${je} === ${c.default.errors}`);
  }
  function j(A) {
    (0, d.checkUnknownRules)(A), K(A);
  }
  function L(A, I) {
    if (A.opts.jtd)
      return de(A, [], !1, I);
    const X = (0, t.getSchemaTypes)(A.schema), oe = (0, t.coerceAndCheckDataType)(A, X);
    de(A, X, !oe, I);
  }
  function K(A) {
    const { schema: I, errSchemaPath: X, opts: oe, self: Ae } = A;
    I.$ref && oe.ignoreKeywordsWithRef && (0, d.schemaHasRulesButRef)(I, Ae.RULES) && Ae.logger.warn(`$ref: keywords ignored in schema at path "${X}"`);
  }
  function ae(A) {
    const { schema: I, opts: X } = A;
    I.default !== void 0 && X.useDefaults && X.strictSchema && (0, d.checkStrictMode)(A, "default is ignored in the schema root");
  }
  function ye(A) {
    const I = A.schema[A.opts.schemaId];
    I && (A.baseId = (0, l.resolveUrl)(A.opts.uriResolver, A.baseId, I));
  }
  function xe(A) {
    if (A.schema.$async && !A.schemaEnv.$async)
      throw new Error("async schema in sync schema");
  }
  function Pe({ gen: A, schemaEnv: I, schema: X, errSchemaPath: oe, opts: Ae }) {
    const je = X.$comment;
    if (Ae.$comment === !0)
      A.code((0, o._)`${c.default.self}.logger.log(${je})`);
    else if (typeof Ae.$comment == "function") {
      const Be = (0, o.str)`${oe}/$comment`, vt = A.scopeValue("root", { ref: I.root });
      A.code((0, o._)`${c.default.self}.opts.$comment(${je}, ${Be}, ${vt}.schema)`);
    }
  }
  function te(A) {
    const { gen: I, schemaEnv: X, validateName: oe, ValidationError: Ae, opts: je } = A;
    X.$async ? I.if((0, o._)`${c.default.errors} === 0`, () => I.return(c.default.data), () => I.throw((0, o._)`new ${Ae}(${c.default.vErrors})`)) : (I.assign((0, o._)`${oe}.errors`, c.default.vErrors), je.unevaluated && pe(A), I.return((0, o._)`${c.default.errors} === 0`));
  }
  function pe({ gen: A, evaluated: I, props: X, items: oe }) {
    X instanceof o.Name && A.assign((0, o._)`${I}.props`, X), oe instanceof o.Name && A.assign((0, o._)`${I}.items`, oe);
  }
  function de(A, I, X, oe) {
    const { gen: Ae, schema: je, data: Be, allErrors: vt, opts: $e, self: ht } = A, { RULES: nt } = ht;
    if (je.$ref && ($e.ignoreKeywordsWithRef || !(0, d.schemaHasRulesButRef)(je, nt))) {
      Ae.block(() => U(A, "$ref", nt.all.$ref.definition));
      return;
    }
    $e.jtd || Re(A, I), Ae.block(() => {
      for (const Le of nt.rules)
        De(Le);
      De(nt.post);
    });
    function De(Le) {
      (0, r.shouldUseGroup)(je, Le) && (Le.type ? (Ae.if((0, i.checkDataType)(Le.type, Be, $e.strictNumbers)), Ee(A, Le), I.length === 1 && I[0] === Le.type && X && (Ae.else(), (0, i.reportTypeError)(A)), Ae.endIf()) : Ee(A, Le), vt || Ae.if((0, o._)`${c.default.errors} === ${oe || 0}`));
    }
  }
  function Ee(A, I) {
    const { gen: X, schema: oe, opts: { useDefaults: Ae } } = A;
    Ae && (0, n.assignDefaults)(A, I.type), X.block(() => {
      for (const je of I.rules)
        (0, r.shouldUseRule)(oe, je) && U(A, je.keyword, je.definition, I.type);
    });
  }
  function Re(A, I) {
    A.schemaEnv.meta || !A.opts.strictTypes || (_e(A, I), A.opts.allowUnionTypes || ie(A, I), Y(A, A.dataTypes));
  }
  function _e(A, I) {
    if (I.length) {
      if (!A.dataTypes.length) {
        A.dataTypes = I;
        return;
      }
      I.forEach((X) => {
        z(A.dataTypes, X) || F(A, `type "${X}" not allowed by context "${A.dataTypes.join(",")}"`);
      }), T(A, I);
    }
  }
  function ie(A, I) {
    I.length > 1 && !(I.length === 2 && I.includes("null")) && F(A, "use allowUnionTypes to allow union type keyword");
  }
  function Y(A, I) {
    const X = A.self.RULES.all;
    for (const oe in X) {
      const Ae = X[oe];
      if (typeof Ae == "object" && (0, r.shouldUseRule)(A.schema, Ae)) {
        const { type: je } = Ae.definition;
        je.length && !je.some((Be) => V(I, Be)) && F(A, `missing type "${je.join(",")}" for keyword "${oe}"`);
      }
    }
  }
  function V(A, I) {
    return A.includes(I) || I === "number" && A.includes("integer");
  }
  function z(A, I) {
    return A.includes(I) || I === "integer" && A.includes("number");
  }
  function T(A, I) {
    const X = [];
    for (const oe of A.dataTypes)
      z(I, oe) ? X.push(oe) : I.includes("integer") && oe === "number" && X.push("integer");
    A.dataTypes = X;
  }
  function F(A, I) {
    const X = A.schemaEnv.baseId + A.errSchemaPath;
    I += ` at "${X}" (strictTypes)`, (0, d.checkStrictMode)(A, I, A.opts.strictTypes);
  }
  class D {
    constructor(I, X, oe) {
      if ((0, s.validateKeywordUsage)(I, X, oe), this.gen = I.gen, this.allErrors = I.allErrors, this.keyword = oe, this.data = I.data, this.schema = I.schema[oe], this.$data = X.$data && I.opts.$data && this.schema && this.schema.$data, this.schemaValue = (0, d.schemaRefOrVal)(I, this.schema, oe, this.$data), this.schemaType = X.schemaType, this.parentSchema = I.schema, this.params = {}, this.it = I, this.def = X, this.$data)
        this.schemaCode = I.gen.const("vSchema", J(this.$data, I));
      else if (this.schemaCode = this.schemaValue, !(0, s.validSchemaType)(this.schema, X.schemaType, X.allowUndefined))
        throw new Error(`${oe} value must be ${JSON.stringify(X.schemaType)}`);
      ("code" in X ? X.trackErrors : X.errors !== !1) && (this.errsCount = I.gen.const("_errs", c.default.errors));
    }
    result(I, X, oe) {
      this.failResult((0, o.not)(I), X, oe);
    }
    failResult(I, X, oe) {
      this.gen.if(I), oe ? oe() : this.error(), X ? (this.gen.else(), X(), this.allErrors && this.gen.endIf()) : this.allErrors ? this.gen.endIf() : this.gen.else();
    }
    pass(I, X) {
      this.failResult((0, o.not)(I), void 0, X);
    }
    fail(I) {
      if (I === void 0) {
        this.error(), this.allErrors || this.gen.if(!1);
        return;
      }
      this.gen.if(I), this.error(), this.allErrors ? this.gen.endIf() : this.gen.else();
    }
    fail$data(I) {
      if (!this.$data)
        return this.fail(I);
      const { schemaCode: X } = this;
      this.fail((0, o._)`${X} !== undefined && (${(0, o.or)(this.invalid$data(), I)})`);
    }
    error(I, X, oe) {
      if (X) {
        this.setParams(X), this._error(I, oe), this.setParams({});
        return;
      }
      this._error(I, oe);
    }
    _error(I, X) {
      (I ? p.reportExtraError : p.reportError)(this, this.def.error, X);
    }
    $dataError() {
      (0, p.reportError)(this, this.def.$dataError || p.keyword$DataError);
    }
    reset() {
      if (this.errsCount === void 0)
        throw new Error('add "trackErrors" to keyword definition');
      (0, p.resetErrorsCount)(this.gen, this.errsCount);
    }
    ok(I) {
      this.allErrors || this.gen.if(I);
    }
    setParams(I, X) {
      X ? Object.assign(this.params, I) : this.params = I;
    }
    block$data(I, X, oe = o.nil) {
      this.gen.block(() => {
        this.check$data(I, oe), X();
      });
    }
    check$data(I = o.nil, X = o.nil) {
      if (!this.$data)
        return;
      const { gen: oe, schemaCode: Ae, schemaType: je, def: Be } = this;
      oe.if((0, o.or)((0, o._)`${Ae} === undefined`, X)), I !== o.nil && oe.assign(I, !0), (je.length || Be.validateSchema) && (oe.elseIf(this.invalid$data()), this.$dataError(), I !== o.nil && oe.assign(I, !1)), oe.else();
    }
    invalid$data() {
      const { gen: I, schemaCode: X, schemaType: oe, def: Ae, it: je } = this;
      return (0, o.or)(Be(), vt());
      function Be() {
        if (oe.length) {
          if (!(X instanceof o.Name))
            throw new Error("ajv implementation error");
          const $e = Array.isArray(oe) ? oe : [oe];
          return (0, o._)`${(0, i.checkDataTypes)($e, X, je.opts.strictNumbers, i.DataType.Wrong)}`;
        }
        return o.nil;
      }
      function vt() {
        if (Ae.validateSchema) {
          const $e = I.scopeValue("validate$data", { ref: Ae.validateSchema });
          return (0, o._)`!${$e}(${X})`;
        }
        return o.nil;
      }
    }
    subschema(I, X) {
      const oe = (0, a.getSubschema)(this.it, I);
      (0, a.extendSubschemaData)(oe, this.it, I), (0, a.extendSubschemaMode)(oe, I);
      const Ae = { ...this.it, ...oe, items: void 0, props: void 0 };
      return $(Ae, X), Ae;
    }
    mergeEvaluated(I, X) {
      const { it: oe, gen: Ae } = this;
      oe.opts.unevaluated && (oe.props !== !0 && I.props !== void 0 && (oe.props = d.mergeEvaluated.props(Ae, I.props, oe.props, X)), oe.items !== !0 && I.items !== void 0 && (oe.items = d.mergeEvaluated.items(Ae, I.items, oe.items, X)));
    }
    mergeValidEvaluated(I, X) {
      const { it: oe, gen: Ae } = this;
      if (oe.opts.unevaluated && (oe.props !== !0 || oe.items !== !0))
        return Ae.if(X, () => this.mergeEvaluated(I, o.Name)), !0;
    }
  }
  hi.KeywordCxt = D;
  function U(A, I, X, oe) {
    const Ae = new D(A, X, I);
    "code" in X ? X.code(Ae, oe) : Ae.$data && X.validate ? (0, s.funcKeywordCode)(Ae, X) : "macro" in X ? (0, s.macroKeywordCode)(Ae, X) : (X.compile || X.validate) && (0, s.funcKeywordCode)(Ae, X);
  }
  const k = /^\/(?:[^~]|~0|~1)*$/, Z = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
  function J(A, { dataLevel: I, dataNames: X, dataPathArr: oe }) {
    let Ae, je;
    if (A === "")
      return c.default.rootData;
    if (A[0] === "/") {
      if (!k.test(A))
        throw new Error(`Invalid JSON-pointer: ${A}`);
      Ae = A, je = c.default.rootData;
    } else {
      const ht = Z.exec(A);
      if (!ht)
        throw new Error(`Invalid JSON-pointer: ${A}`);
      const nt = +ht[1];
      if (Ae = ht[2], Ae === "#") {
        if (nt >= I)
          throw new Error($e("property/index", nt));
        return oe[I - nt];
      }
      if (nt > I)
        throw new Error($e("data", nt));
      if (je = X[I - nt], !Ae)
        return je;
    }
    let Be = je;
    const vt = Ae.split("/");
    for (const ht of vt)
      ht && (je = (0, o._)`${je}${(0, o.getProperty)((0, d.unescapeJsonPointer)(ht))}`, Be = (0, o._)`${Be} && ${je}`);
    return Be;
    function $e(ht, nt) {
      return `Cannot access ${ht} ${nt} levels up, current level is ${I}`;
    }
  }
  return hi.getData = J, hi;
}
var Ju = {};
Object.defineProperty(Ju, "__esModule", { value: !0 });
class hF extends Error {
  constructor(t) {
    super("validation failed"), this.errors = t, this.ajv = this.validation = !0;
  }
}
Ju.default = hF;
var Xu = {};
Object.defineProperty(Xu, "__esModule", { value: !0 });
const Lh = mr;
class mF extends Error {
  constructor(t, r, i, n) {
    super(n || `can't resolve reference ${i} from id ${r}`), this.missingRef = (0, Lh.resolveUrl)(t, r, i), this.missingSchema = (0, Lh.normalizeId)((0, Lh.getFullPath)(t, this.missingRef));
  }
}
Xu.default = mF;
var Ir = {};
Object.defineProperty(Ir, "__esModule", { value: !0 });
Ir.resolveSchema = Ir.getCompilingSchema = Ir.resolveRef = Ir.compileSchema = Ir.SchemaEnv = void 0;
const wn = pt, yF = Ju, Ts = Qr, Pn = mr, Iw = Pt, gF = Bf();
class Vf {
  constructor(t) {
    var r;
    this.refs = {}, this.dynamicAnchors = {};
    let i;
    typeof t.schema == "object" && (i = t.schema), this.schema = t.schema, this.schemaId = t.schemaId, this.root = t.root || this, this.baseId = (r = t.baseId) !== null && r !== void 0 ? r : (0, Pn.normalizeId)(i == null ? void 0 : i[t.schemaId || "$id"]), this.schemaPath = t.schemaPath, this.localRefs = t.localRefs, this.meta = t.meta, this.$async = i == null ? void 0 : i.$async, this.refs = {};
  }
}
Ir.SchemaEnv = Vf;
function kg(e) {
  const t = GO.call(this, e);
  if (t)
    return t;
  const r = (0, Pn.getFullPath)(this.opts.uriResolver, e.root.baseId), { es5: i, lines: n } = this.opts.code, { ownProperties: s } = this.opts, a = new wn.CodeGen(this.scope, { es5: i, lines: n, ownProperties: s });
  let o;
  e.$async && (o = a.scopeValue("Error", {
    ref: yF.default,
    code: (0, wn._)`require("ajv/dist/runtime/validation_error").default`
  }));
  const c = a.scopeName("validate");
  e.validateName = c;
  const l = {
    gen: a,
    allErrors: this.opts.allErrors,
    data: Ts.default.data,
    parentData: Ts.default.parentData,
    parentDataProperty: Ts.default.parentDataProperty,
    dataNames: [Ts.default.data],
    dataPathArr: [wn.nil],
    dataLevel: 0,
    dataTypes: [],
    definedProperties: /* @__PURE__ */ new Set(),
    topSchemaRef: a.scopeValue("schema", this.opts.code.source === !0 ? { ref: e.schema, code: (0, wn.stringify)(e.schema) } : { ref: e.schema }),
    validateName: c,
    ValidationError: o,
    schema: e.schema,
    schemaEnv: e,
    rootId: r,
    baseId: e.baseId || r,
    schemaPath: wn.nil,
    errSchemaPath: e.schemaPath || (this.opts.jtd ? "" : "#"),
    errorPath: (0, wn._)`""`,
    opts: this.opts,
    self: this
  };
  let d;
  try {
    this._compilations.add(e), (0, gF.validateFunctionCode)(l), a.optimize(this.opts.code.optimize);
    const p = a.toString();
    d = `${a.scopeRefs(Ts.default.scope)}return ${p}`, this.opts.code.process && (d = this.opts.code.process(d, e));
    const g = new Function(`${Ts.default.self}`, `${Ts.default.scope}`, d)(this, this.scope.get());
    if (this.scope.value(c, { ref: g }), g.errors = null, g.schema = e.schema, g.schemaEnv = e, e.$async && (g.$async = !0), this.opts.code.source === !0 && (g.source = { validateName: c, validateCode: p, scopeValues: a._values }), this.opts.unevaluated) {
      const { props: m, items: v } = l;
      g.evaluated = {
        props: m instanceof wn.Name ? void 0 : m,
        items: v instanceof wn.Name ? void 0 : v,
        dynamicProps: m instanceof wn.Name,
        dynamicItems: v instanceof wn.Name
      }, g.source && (g.source.evaluated = (0, wn.stringify)(g.evaluated));
    }
    return e.validate = g, e;
  } catch (p) {
    throw delete e.validate, delete e.validateName, d && this.logger.error("Error compiling schema, function code:", d), p;
  } finally {
    this._compilations.delete(e);
  }
}
Ir.compileSchema = kg;
function vF(e, t, r) {
  var i;
  r = (0, Pn.resolveUrl)(this.opts.uriResolver, t, r);
  const n = e.refs[r];
  if (n)
    return n;
  let s = wF.call(this, e, r);
  if (s === void 0) {
    const a = (i = e.localRefs) === null || i === void 0 ? void 0 : i[r], { schemaId: o } = this.opts;
    a && (s = new Vf({ schema: a, schemaId: o, root: e, baseId: t }));
  }
  if (s !== void 0)
    return e.refs[r] = bF.call(this, s);
}
Ir.resolveRef = vF;
function bF(e) {
  return (0, Pn.inlineRef)(e.schema, this.opts.inlineRefs) ? e.schema : e.validate ? e : kg.call(this, e);
}
function GO(e) {
  for (const t of this._compilations)
    if (_F(t, e))
      return t;
}
Ir.getCompilingSchema = GO;
function _F(e, t) {
  return e.schema === t.schema && e.root === t.root && e.baseId === t.baseId;
}
function wF(e, t) {
  let r;
  for (; typeof (r = this.refs[t]) == "string"; )
    t = r;
  return r || this.schemas[t] || Zf.call(this, e, t);
}
function Zf(e, t) {
  const r = this.opts.uriResolver.parse(t), i = (0, Pn._getFullPath)(this.opts.uriResolver, r);
  let n = (0, Pn.getFullPath)(this.opts.uriResolver, e.baseId, void 0);
  if (Object.keys(e.schema).length > 0 && i === n)
    return qh.call(this, r, e);
  const s = (0, Pn.normalizeId)(i), a = this.refs[s] || this.schemas[s];
  if (typeof a == "string") {
    const o = Zf.call(this, e, a);
    return typeof (o == null ? void 0 : o.schema) != "object" ? void 0 : qh.call(this, r, o);
  }
  if (typeof (a == null ? void 0 : a.schema) == "object") {
    if (a.validate || kg.call(this, a), s === (0, Pn.normalizeId)(t)) {
      const { schema: o } = a, { schemaId: c } = this.opts, l = o[c];
      return l && (n = (0, Pn.resolveUrl)(this.opts.uriResolver, n, l)), new Vf({ schema: o, schemaId: c, root: e, baseId: n });
    }
    return qh.call(this, r, a);
  }
}
Ir.resolveSchema = Zf;
const $F = /* @__PURE__ */ new Set([
  "properties",
  "patternProperties",
  "enum",
  "dependencies",
  "definitions"
]);
function qh(e, { baseId: t, schema: r, root: i }) {
  var n;
  if (((n = e.fragment) === null || n === void 0 ? void 0 : n[0]) !== "/")
    return;
  for (const o of e.fragment.slice(1).split("/")) {
    if (typeof r == "boolean")
      return;
    const c = r[(0, Iw.unescapeFragment)(o)];
    if (c === void 0)
      return;
    r = c;
    const l = typeof r == "object" && r[this.opts.schemaId];
    !$F.has(o) && l && (t = (0, Pn.resolveUrl)(this.opts.uriResolver, t, l));
  }
  let s;
  if (typeof r != "boolean" && r.$ref && !(0, Iw.schemaHasRulesButRef)(r, this.RULES)) {
    const o = (0, Pn.resolveUrl)(this.opts.uriResolver, t, r.$ref);
    s = Zf.call(this, i, o);
  }
  const { schemaId: a } = this.opts;
  if (s = s || new Vf({ schema: r, schemaId: a, root: i, baseId: t }), s.schema !== s.root.schema)
    return s;
}
const EF = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#", xF = "Meta-schema for $data reference (JSON AnySchema extension proposal)", OF = "object", PF = [
  "$data"
], SF = {
  $data: {
    type: "string",
    anyOf: [
      {
        format: "relative-json-pointer"
      },
      {
        format: "json-pointer"
      }
    ]
  }
}, AF = !1, CF = {
  $id: EF,
  description: xF,
  type: OF,
  required: PF,
  properties: SF,
  additionalProperties: AF
};
var Mg = {}, Ay = { exports: {} };
/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
(function(e, t) {
  (function(r, i) {
    i(t);
  })(tt, function(r) {
    function i() {
      for (var ue = arguments.length, Q = Array(ue), le = 0; le < ue; le++)
        Q[le] = arguments[le];
      if (Q.length > 1) {
        Q[0] = Q[0].slice(0, -1);
        for (var be = Q.length - 1, ve = 1; ve < be; ++ve)
          Q[ve] = Q[ve].slice(1, -1);
        return Q[be] = Q[be].slice(1), Q.join("");
      } else
        return Q[0];
    }
    function n(ue) {
      return "(?:" + ue + ")";
    }
    function s(ue) {
      return ue === void 0 ? "undefined" : ue === null ? "null" : Object.prototype.toString.call(ue).split(" ").pop().split("]").shift().toLowerCase();
    }
    function a(ue) {
      return ue.toUpperCase();
    }
    function o(ue) {
      return ue != null ? ue instanceof Array ? ue : typeof ue.length != "number" || ue.split || ue.setInterval || ue.call ? [ue] : Array.prototype.slice.call(ue) : [];
    }
    function c(ue, Q) {
      var le = ue;
      if (Q)
        for (var be in Q)
          le[be] = Q[be];
      return le;
    }
    function l(ue) {
      var Q = "[A-Za-z]", le = "[0-9]", be = i(le, "[A-Fa-f]"), ve = n(n("%[EFef]" + be + "%" + be + be + "%" + be + be) + "|" + n("%[89A-Fa-f]" + be + "%" + be + be) + "|" + n("%" + be + be)), Ye = "[\\:\\/\\?\\#\\[\\]\\@]", Xe = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", xt = i(Ye, Xe), Mt = ue ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", Zt = ue ? "[\\uE000-\\uF8FF]" : "[]", bt = i(Q, le, "[\\-\\.\\_\\~]", Mt);
      n(Q + i(Q, le, "[\\+\\-\\.]") + "*"), n(n(ve + "|" + i(bt, Xe, "[\\:]")) + "*");
      var ee = n(n("25[0-5]") + "|" + n("2[0-4]" + le) + "|" + n("1" + le + le) + "|" + n("0?[1-9]" + le) + "|0?0?" + le), O = n(ee + "\\." + ee + "\\." + ee + "\\." + ee), M = n(be + "{1,4}"), W = n(n(M + "\\:" + M) + "|" + O), se = n(n(M + "\\:") + "{6}" + W), ne = n("\\:\\:" + n(M + "\\:") + "{5}" + W), Me = n(n(M) + "?\\:\\:" + n(M + "\\:") + "{4}" + W), Ce = n(n(n(M + "\\:") + "{0,1}" + M) + "?\\:\\:" + n(M + "\\:") + "{3}" + W), Ke = n(n(n(M + "\\:") + "{0,2}" + M) + "?\\:\\:" + n(M + "\\:") + "{2}" + W), We = n(n(n(M + "\\:") + "{0,3}" + M) + "?\\:\\:" + M + "\\:" + W), ct = n(n(n(M + "\\:") + "{0,4}" + M) + "?\\:\\:" + W), qt = n(n(n(M + "\\:") + "{0,5}" + M) + "?\\:\\:" + M), Dr = n(n(n(M + "\\:") + "{0,6}" + M) + "?\\:\\:"), Zr = n([se, ne, Me, Ce, Ke, We, ct, qt, Dr].join("|")), mn = n(n(bt + "|" + ve) + "+");
      n("[vV]" + be + "+\\." + i(bt, Xe, "[\\:]") + "+"), n(n(ve + "|" + i(bt, Xe)) + "*");
      var gs = n(ve + "|" + i(bt, Xe, "[\\:\\@]"));
      return n(n(ve + "|" + i(bt, Xe, "[\\@]")) + "+"), n(n(gs + "|" + i("[\\/\\?]", Zt)) + "*"), {
        NOT_SCHEME: new RegExp(i("[^]", Q, le, "[\\+\\-\\.]"), "g"),
        NOT_USERINFO: new RegExp(i("[^\\%\\:]", bt, Xe), "g"),
        NOT_HOST: new RegExp(i("[^\\%\\[\\]\\:]", bt, Xe), "g"),
        NOT_PATH: new RegExp(i("[^\\%\\/\\:\\@]", bt, Xe), "g"),
        NOT_PATH_NOSCHEME: new RegExp(i("[^\\%\\/\\@]", bt, Xe), "g"),
        NOT_QUERY: new RegExp(i("[^\\%]", bt, Xe, "[\\:\\@\\/\\?]", Zt), "g"),
        NOT_FRAGMENT: new RegExp(i("[^\\%]", bt, Xe, "[\\:\\@\\/\\?]"), "g"),
        ESCAPE: new RegExp(i("[^]", bt, Xe), "g"),
        UNRESERVED: new RegExp(bt, "g"),
        OTHER_CHARS: new RegExp(i("[^\\%]", bt, xt), "g"),
        PCT_ENCODED: new RegExp(ve, "g"),
        IPV4ADDRESS: new RegExp("^(" + O + ")$"),
        IPV6ADDRESS: new RegExp("^\\[?(" + Zr + ")" + n(n("\\%25|\\%(?!" + be + "{2})") + "(" + mn + ")") + "?\\]?$")
        //RFC 6874, with relaxed parsing rules
      };
    }
    var d = l(!1), p = l(!0), h = function() {
      function ue(Q, le) {
        var be = [], ve = !0, Ye = !1, Xe = void 0;
        try {
          for (var xt = Q[Symbol.iterator](), Mt; !(ve = (Mt = xt.next()).done) && (be.push(Mt.value), !(le && be.length === le)); ve = !0)
            ;
        } catch (Zt) {
          Ye = !0, Xe = Zt;
        } finally {
          try {
            !ve && xt.return && xt.return();
          } finally {
            if (Ye)
              throw Xe;
          }
        }
        return be;
      }
      return function(Q, le) {
        if (Array.isArray(Q))
          return Q;
        if (Symbol.iterator in Object(Q))
          return ue(Q, le);
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      };
    }(), g = function(ue) {
      if (Array.isArray(ue)) {
        for (var Q = 0, le = Array(ue.length); Q < ue.length; Q++)
          le[Q] = ue[Q];
        return le;
      } else
        return Array.from(ue);
    }, m = 2147483647, v = 36, _ = 1, y = 26, w = 38, $ = 700, E = 72, S = 128, R = "-", j = /^xn--/, L = /[^\0-\x7E]/, K = /[\x2E\u3002\uFF0E\uFF61]/g, ae = {
      overflow: "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    }, ye = v - _, xe = Math.floor, Pe = String.fromCharCode;
    function te(ue) {
      throw new RangeError(ae[ue]);
    }
    function pe(ue, Q) {
      for (var le = [], be = ue.length; be--; )
        le[be] = Q(ue[be]);
      return le;
    }
    function de(ue, Q) {
      var le = ue.split("@"), be = "";
      le.length > 1 && (be = le[0] + "@", ue = le[1]), ue = ue.replace(K, ".");
      var ve = ue.split("."), Ye = pe(ve, Q).join(".");
      return be + Ye;
    }
    function Ee(ue) {
      for (var Q = [], le = 0, be = ue.length; le < be; ) {
        var ve = ue.charCodeAt(le++);
        if (ve >= 55296 && ve <= 56319 && le < be) {
          var Ye = ue.charCodeAt(le++);
          (Ye & 64512) == 56320 ? Q.push(((ve & 1023) << 10) + (Ye & 1023) + 65536) : (Q.push(ve), le--);
        } else
          Q.push(ve);
      }
      return Q;
    }
    var Re = function(Q) {
      return String.fromCodePoint.apply(String, g(Q));
    }, _e = function(Q) {
      return Q - 48 < 10 ? Q - 22 : Q - 65 < 26 ? Q - 65 : Q - 97 < 26 ? Q - 97 : v;
    }, ie = function(Q, le) {
      return Q + 22 + 75 * (Q < 26) - ((le != 0) << 5);
    }, Y = function(Q, le, be) {
      var ve = 0;
      for (
        Q = be ? xe(Q / $) : Q >> 1, Q += xe(Q / le);
        /* no initialization */
        Q > ye * y >> 1;
        ve += v
      )
        Q = xe(Q / ye);
      return xe(ve + (ye + 1) * Q / (Q + w));
    }, V = function(Q) {
      var le = [], be = Q.length, ve = 0, Ye = S, Xe = E, xt = Q.lastIndexOf(R);
      xt < 0 && (xt = 0);
      for (var Mt = 0; Mt < xt; ++Mt)
        Q.charCodeAt(Mt) >= 128 && te("not-basic"), le.push(Q.charCodeAt(Mt));
      for (var Zt = xt > 0 ? xt + 1 : 0; Zt < be; ) {
        for (
          var bt = ve, ee = 1, O = v;
          ;
          /* no condition */
          O += v
        ) {
          Zt >= be && te("invalid-input");
          var M = _e(Q.charCodeAt(Zt++));
          (M >= v || M > xe((m - ve) / ee)) && te("overflow"), ve += M * ee;
          var W = O <= Xe ? _ : O >= Xe + y ? y : O - Xe;
          if (M < W)
            break;
          var se = v - W;
          ee > xe(m / se) && te("overflow"), ee *= se;
        }
        var ne = le.length + 1;
        Xe = Y(ve - bt, ne, bt == 0), xe(ve / ne) > m - Ye && te("overflow"), Ye += xe(ve / ne), ve %= ne, le.splice(ve++, 0, Ye);
      }
      return String.fromCodePoint.apply(String, le);
    }, z = function(Q) {
      var le = [];
      Q = Ee(Q);
      var be = Q.length, ve = S, Ye = 0, Xe = E, xt = !0, Mt = !1, Zt = void 0;
      try {
        for (var bt = Q[Symbol.iterator](), ee; !(xt = (ee = bt.next()).done); xt = !0) {
          var O = ee.value;
          O < 128 && le.push(Pe(O));
        }
      } catch (Ln) {
        Mt = !0, Zt = Ln;
      } finally {
        try {
          !xt && bt.return && bt.return();
        } finally {
          if (Mt)
            throw Zt;
        }
      }
      var M = le.length, W = M;
      for (M && le.push(R); W < be; ) {
        var se = m, ne = !0, Me = !1, Ce = void 0;
        try {
          for (var Ke = Q[Symbol.iterator](), We; !(ne = (We = Ke.next()).done); ne = !0) {
            var ct = We.value;
            ct >= ve && ct < se && (se = ct);
          }
        } catch (Ln) {
          Me = !0, Ce = Ln;
        } finally {
          try {
            !ne && Ke.return && Ke.return();
          } finally {
            if (Me)
              throw Ce;
          }
        }
        var qt = W + 1;
        se - ve > xe((m - Ye) / qt) && te("overflow"), Ye += (se - ve) * qt, ve = se;
        var Dr = !0, Zr = !1, mn = void 0;
        try {
          for (var gs = Q[Symbol.iterator](), nc; !(Dr = (nc = gs.next()).done); Dr = !0) {
            var _o = nc.value;
            if (_o < ve && ++Ye > m && te("overflow"), _o == ve) {
              for (
                var vs = Ye, bs = v;
                ;
                /* no condition */
                bs += v
              ) {
                var ki = bs <= Xe ? _ : bs >= Xe + y ? y : bs - Xe;
                if (vs < ki)
                  break;
                var ic = vs - ki, wo = v - ki;
                le.push(Pe(ie(ki + ic % wo, 0))), vs = xe(ic / wo);
              }
              le.push(Pe(ie(vs, 0))), Xe = Y(Ye, qt, W == M), Ye = 0, ++W;
            }
          }
        } catch (Ln) {
          Zr = !0, mn = Ln;
        } finally {
          try {
            !Dr && gs.return && gs.return();
          } finally {
            if (Zr)
              throw mn;
          }
        }
        ++Ye, ++ve;
      }
      return le.join("");
    }, T = function(Q) {
      return de(Q, function(le) {
        return j.test(le) ? V(le.slice(4).toLowerCase()) : le;
      });
    }, F = function(Q) {
      return de(Q, function(le) {
        return L.test(le) ? "xn--" + z(le) : le;
      });
    }, D = {
      /**
       * A string representing the current Punycode.js version number.
       * @memberOf punycode
       * @type String
       */
      version: "2.1.0",
      /**
       * An object of methods to convert from JavaScript's internal character
       * representation (UCS-2) to Unicode code points, and back.
       * @see <https://mathiasbynens.be/notes/javascript-encoding>
       * @memberOf punycode
       * @type Object
       */
      ucs2: {
        decode: Ee,
        encode: Re
      },
      decode: V,
      encode: z,
      toASCII: F,
      toUnicode: T
    }, U = {};
    function k(ue) {
      var Q = ue.charCodeAt(0), le = void 0;
      return Q < 16 ? le = "%0" + Q.toString(16).toUpperCase() : Q < 128 ? le = "%" + Q.toString(16).toUpperCase() : Q < 2048 ? le = "%" + (Q >> 6 | 192).toString(16).toUpperCase() + "%" + (Q & 63 | 128).toString(16).toUpperCase() : le = "%" + (Q >> 12 | 224).toString(16).toUpperCase() + "%" + (Q >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (Q & 63 | 128).toString(16).toUpperCase(), le;
    }
    function Z(ue) {
      for (var Q = "", le = 0, be = ue.length; le < be; ) {
        var ve = parseInt(ue.substr(le + 1, 2), 16);
        if (ve < 128)
          Q += String.fromCharCode(ve), le += 3;
        else if (ve >= 194 && ve < 224) {
          if (be - le >= 6) {
            var Ye = parseInt(ue.substr(le + 4, 2), 16);
            Q += String.fromCharCode((ve & 31) << 6 | Ye & 63);
          } else
            Q += ue.substr(le, 6);
          le += 6;
        } else if (ve >= 224) {
          if (be - le >= 9) {
            var Xe = parseInt(ue.substr(le + 4, 2), 16), xt = parseInt(ue.substr(le + 7, 2), 16);
            Q += String.fromCharCode((ve & 15) << 12 | (Xe & 63) << 6 | xt & 63);
          } else
            Q += ue.substr(le, 9);
          le += 9;
        } else
          Q += ue.substr(le, 3), le += 3;
      }
      return Q;
    }
    function J(ue, Q) {
      function le(be) {
        var ve = Z(be);
        return ve.match(Q.UNRESERVED) ? ve : be;
      }
      return ue.scheme && (ue.scheme = String(ue.scheme).replace(Q.PCT_ENCODED, le).toLowerCase().replace(Q.NOT_SCHEME, "")), ue.userinfo !== void 0 && (ue.userinfo = String(ue.userinfo).replace(Q.PCT_ENCODED, le).replace(Q.NOT_USERINFO, k).replace(Q.PCT_ENCODED, a)), ue.host !== void 0 && (ue.host = String(ue.host).replace(Q.PCT_ENCODED, le).toLowerCase().replace(Q.NOT_HOST, k).replace(Q.PCT_ENCODED, a)), ue.path !== void 0 && (ue.path = String(ue.path).replace(Q.PCT_ENCODED, le).replace(ue.scheme ? Q.NOT_PATH : Q.NOT_PATH_NOSCHEME, k).replace(Q.PCT_ENCODED, a)), ue.query !== void 0 && (ue.query = String(ue.query).replace(Q.PCT_ENCODED, le).replace(Q.NOT_QUERY, k).replace(Q.PCT_ENCODED, a)), ue.fragment !== void 0 && (ue.fragment = String(ue.fragment).replace(Q.PCT_ENCODED, le).replace(Q.NOT_FRAGMENT, k).replace(Q.PCT_ENCODED, a)), ue;
    }
    function A(ue) {
      return ue.replace(/^0*(.*)/, "$1") || "0";
    }
    function I(ue, Q) {
      var le = ue.match(Q.IPV4ADDRESS) || [], be = h(le, 2), ve = be[1];
      return ve ? ve.split(".").map(A).join(".") : ue;
    }
    function X(ue, Q) {
      var le = ue.match(Q.IPV6ADDRESS) || [], be = h(le, 3), ve = be[1], Ye = be[2];
      if (ve) {
        for (var Xe = ve.toLowerCase().split("::").reverse(), xt = h(Xe, 2), Mt = xt[0], Zt = xt[1], bt = Zt ? Zt.split(":").map(A) : [], ee = Mt.split(":").map(A), O = Q.IPV4ADDRESS.test(ee[ee.length - 1]), M = O ? 7 : 8, W = ee.length - M, se = Array(M), ne = 0; ne < M; ++ne)
          se[ne] = bt[ne] || ee[W + ne] || "";
        O && (se[M - 1] = I(se[M - 1], Q));
        var Me = se.reduce(function(qt, Dr, Zr) {
          if (!Dr || Dr === "0") {
            var mn = qt[qt.length - 1];
            mn && mn.index + mn.length === Zr ? mn.length++ : qt.push({ index: Zr, length: 1 });
          }
          return qt;
        }, []), Ce = Me.sort(function(qt, Dr) {
          return Dr.length - qt.length;
        })[0], Ke = void 0;
        if (Ce && Ce.length > 1) {
          var We = se.slice(0, Ce.index), ct = se.slice(Ce.index + Ce.length);
          Ke = We.join(":") + "::" + ct.join(":");
        } else
          Ke = se.join(":");
        return Ye && (Ke += "%" + Ye), Ke;
      } else
        return ue;
    }
    var oe = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i, Ae = "".match(/(){0}/)[1] === void 0;
    function je(ue) {
      var Q = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, le = {}, be = Q.iri !== !1 ? p : d;
      Q.reference === "suffix" && (ue = (Q.scheme ? Q.scheme + ":" : "") + "//" + ue);
      var ve = ue.match(oe);
      if (ve) {
        Ae ? (le.scheme = ve[1], le.userinfo = ve[3], le.host = ve[4], le.port = parseInt(ve[5], 10), le.path = ve[6] || "", le.query = ve[7], le.fragment = ve[8], isNaN(le.port) && (le.port = ve[5])) : (le.scheme = ve[1] || void 0, le.userinfo = ue.indexOf("@") !== -1 ? ve[3] : void 0, le.host = ue.indexOf("//") !== -1 ? ve[4] : void 0, le.port = parseInt(ve[5], 10), le.path = ve[6] || "", le.query = ue.indexOf("?") !== -1 ? ve[7] : void 0, le.fragment = ue.indexOf("#") !== -1 ? ve[8] : void 0, isNaN(le.port) && (le.port = ue.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? ve[4] : void 0)), le.host && (le.host = X(I(le.host, be), be)), le.scheme === void 0 && le.userinfo === void 0 && le.host === void 0 && le.port === void 0 && !le.path && le.query === void 0 ? le.reference = "same-document" : le.scheme === void 0 ? le.reference = "relative" : le.fragment === void 0 ? le.reference = "absolute" : le.reference = "uri", Q.reference && Q.reference !== "suffix" && Q.reference !== le.reference && (le.error = le.error || "URI is not a " + Q.reference + " reference.");
        var Ye = U[(Q.scheme || le.scheme || "").toLowerCase()];
        if (!Q.unicodeSupport && (!Ye || !Ye.unicodeSupport)) {
          if (le.host && (Q.domainHost || Ye && Ye.domainHost))
            try {
              le.host = D.toASCII(le.host.replace(be.PCT_ENCODED, Z).toLowerCase());
            } catch (Xe) {
              le.error = le.error || "Host's domain name can not be converted to ASCII via punycode: " + Xe;
            }
          J(le, d);
        } else
          J(le, be);
        Ye && Ye.parse && Ye.parse(le, Q);
      } else
        le.error = le.error || "URI can not be parsed.";
      return le;
    }
    function Be(ue, Q) {
      var le = Q.iri !== !1 ? p : d, be = [];
      return ue.userinfo !== void 0 && (be.push(ue.userinfo), be.push("@")), ue.host !== void 0 && be.push(X(I(String(ue.host), le), le).replace(le.IPV6ADDRESS, function(ve, Ye, Xe) {
        return "[" + Ye + (Xe ? "%25" + Xe : "") + "]";
      })), (typeof ue.port == "number" || typeof ue.port == "string") && (be.push(":"), be.push(String(ue.port))), be.length ? be.join("") : void 0;
    }
    var vt = /^\.\.?\//, $e = /^\/\.(\/|$)/, ht = /^\/\.\.(\/|$)/, nt = /^\/?(?:.|\n)*?(?=\/|$)/;
    function De(ue) {
      for (var Q = []; ue.length; )
        if (ue.match(vt))
          ue = ue.replace(vt, "");
        else if (ue.match($e))
          ue = ue.replace($e, "/");
        else if (ue.match(ht))
          ue = ue.replace(ht, "/"), Q.pop();
        else if (ue === "." || ue === "..")
          ue = "";
        else {
          var le = ue.match(nt);
          if (le) {
            var be = le[0];
            ue = ue.slice(be.length), Q.push(be);
          } else
            throw new Error("Unexpected dot segment condition");
        }
      return Q.join("");
    }
    function Le(ue) {
      var Q = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, le = Q.iri ? p : d, be = [], ve = U[(Q.scheme || ue.scheme || "").toLowerCase()];
      if (ve && ve.serialize && ve.serialize(ue, Q), ue.host && !le.IPV6ADDRESS.test(ue.host)) {
        if (Q.domainHost || ve && ve.domainHost)
          try {
            ue.host = Q.iri ? D.toUnicode(ue.host) : D.toASCII(ue.host.replace(le.PCT_ENCODED, Z).toLowerCase());
          } catch (xt) {
            ue.error = ue.error || "Host's domain name can not be converted to " + (Q.iri ? "Unicode" : "ASCII") + " via punycode: " + xt;
          }
      }
      J(ue, le), Q.reference !== "suffix" && ue.scheme && (be.push(ue.scheme), be.push(":"));
      var Ye = Be(ue, Q);
      if (Ye !== void 0 && (Q.reference !== "suffix" && be.push("//"), be.push(Ye), ue.path && ue.path.charAt(0) !== "/" && be.push("/")), ue.path !== void 0) {
        var Xe = ue.path;
        !Q.absolutePath && (!ve || !ve.absolutePath) && (Xe = De(Xe)), Ye === void 0 && (Xe = Xe.replace(/^\/\//, "/%2F")), be.push(Xe);
      }
      return ue.query !== void 0 && (be.push("?"), be.push(ue.query)), ue.fragment !== void 0 && (be.push("#"), be.push(ue.fragment)), be.join("");
    }
    function at(ue, Q) {
      var le = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, be = arguments[3], ve = {};
      return be || (ue = je(Le(ue, le), le), Q = je(Le(Q, le), le)), le = le || {}, !le.tolerant && Q.scheme ? (ve.scheme = Q.scheme, ve.userinfo = Q.userinfo, ve.host = Q.host, ve.port = Q.port, ve.path = De(Q.path || ""), ve.query = Q.query) : (Q.userinfo !== void 0 || Q.host !== void 0 || Q.port !== void 0 ? (ve.userinfo = Q.userinfo, ve.host = Q.host, ve.port = Q.port, ve.path = De(Q.path || ""), ve.query = Q.query) : (Q.path ? (Q.path.charAt(0) === "/" ? ve.path = De(Q.path) : ((ue.userinfo !== void 0 || ue.host !== void 0 || ue.port !== void 0) && !ue.path ? ve.path = "/" + Q.path : ue.path ? ve.path = ue.path.slice(0, ue.path.lastIndexOf("/") + 1) + Q.path : ve.path = Q.path, ve.path = De(ve.path)), ve.query = Q.query) : (ve.path = ue.path, Q.query !== void 0 ? ve.query = Q.query : ve.query = ue.query), ve.userinfo = ue.userinfo, ve.host = ue.host, ve.port = ue.port), ve.scheme = ue.scheme), ve.fragment = Q.fragment, ve;
    }
    function mt(ue, Q, le) {
      var be = c({ scheme: "null" }, le);
      return Le(at(je(ue, be), je(Q, be), be, !0), be);
    }
    function Ue(ue, Q) {
      return typeof ue == "string" ? ue = Le(je(ue, Q), Q) : s(ue) === "object" && (ue = je(Le(ue, Q), Q)), ue;
    }
    function q(ue, Q, le) {
      return typeof ue == "string" ? ue = Le(je(ue, le), le) : s(ue) === "object" && (ue = Le(ue, le)), typeof Q == "string" ? Q = Le(je(Q, le), le) : s(Q) === "object" && (Q = Le(Q, le)), ue === Q;
    }
    function x(ue, Q) {
      return ue && ue.toString().replace(!Q || !Q.iri ? d.ESCAPE : p.ESCAPE, k);
    }
    function C(ue, Q) {
      return ue && ue.toString().replace(!Q || !Q.iri ? d.PCT_ENCODED : p.PCT_ENCODED, Z);
    }
    var G = {
      scheme: "http",
      domainHost: !0,
      parse: function(Q, le) {
        return Q.host || (Q.error = Q.error || "HTTP URIs must have a host."), Q;
      },
      serialize: function(Q, le) {
        var be = String(Q.scheme).toLowerCase() === "https";
        return (Q.port === (be ? 443 : 80) || Q.port === "") && (Q.port = void 0), Q.path || (Q.path = "/"), Q;
      }
    }, fe = {
      scheme: "https",
      domainHost: G.domainHost,
      parse: G.parse,
      serialize: G.serialize
    };
    function ge(ue) {
      return typeof ue.secure == "boolean" ? ue.secure : String(ue.scheme).toLowerCase() === "wss";
    }
    var Oe = {
      scheme: "ws",
      domainHost: !0,
      parse: function(Q, le) {
        var be = Q;
        return be.secure = ge(be), be.resourceName = (be.path || "/") + (be.query ? "?" + be.query : ""), be.path = void 0, be.query = void 0, be;
      },
      serialize: function(Q, le) {
        if ((Q.port === (ge(Q) ? 443 : 80) || Q.port === "") && (Q.port = void 0), typeof Q.secure == "boolean" && (Q.scheme = Q.secure ? "wss" : "ws", Q.secure = void 0), Q.resourceName) {
          var be = Q.resourceName.split("?"), ve = h(be, 2), Ye = ve[0], Xe = ve[1];
          Q.path = Ye && Ye !== "/" ? Ye : void 0, Q.query = Xe, Q.resourceName = void 0;
        }
        return Q.fragment = void 0, Q;
      }
    }, ut = {
      scheme: "wss",
      domainHost: Oe.domainHost,
      parse: Oe.parse,
      serialize: Oe.serialize
    }, kt = {}, Rt = "[A-Za-z0-9\\-\\.\\_\\~\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]", $t = "[0-9A-Fa-f]", Tt = n(n("%[EFef]" + $t + "%" + $t + $t + "%" + $t + $t) + "|" + n("%[89A-Fa-f]" + $t + "%" + $t + $t) + "|" + n("%" + $t + $t)), ho = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]", mo = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]", ra = i(mo, '[\\"\\\\]'), na = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]", yo = new RegExp(Rt, "g"), Dn = new RegExp(Tt, "g"), go = new RegExp(i("[^]", ho, "[\\.]", '[\\"]', ra), "g"), ia = new RegExp(i("[^]", Rt, na), "g"), sa = ia;
    function ys(ue) {
      var Q = Z(ue);
      return Q.match(yo) ? Q : ue;
    }
    var aa = {
      scheme: "mailto",
      parse: function(Q, le) {
        var be = Q, ve = be.to = be.path ? be.path.split(",") : [];
        if (be.path = void 0, be.query) {
          for (var Ye = !1, Xe = {}, xt = be.query.split("&"), Mt = 0, Zt = xt.length; Mt < Zt; ++Mt) {
            var bt = xt[Mt].split("=");
            switch (bt[0]) {
              case "to":
                for (var ee = bt[1].split(","), O = 0, M = ee.length; O < M; ++O)
                  ve.push(ee[O]);
                break;
              case "subject":
                be.subject = C(bt[1], le);
                break;
              case "body":
                be.body = C(bt[1], le);
                break;
              default:
                Ye = !0, Xe[C(bt[0], le)] = C(bt[1], le);
                break;
            }
          }
          Ye && (be.headers = Xe);
        }
        be.query = void 0;
        for (var W = 0, se = ve.length; W < se; ++W) {
          var ne = ve[W].split("@");
          if (ne[0] = C(ne[0]), le.unicodeSupport)
            ne[1] = C(ne[1], le).toLowerCase();
          else
            try {
              ne[1] = D.toASCII(C(ne[1], le).toLowerCase());
            } catch (Me) {
              be.error = be.error || "Email address's domain name can not be converted to ASCII via punycode: " + Me;
            }
          ve[W] = ne.join("@");
        }
        return be;
      },
      serialize: function(Q, le) {
        var be = Q, ve = o(Q.to);
        if (ve) {
          for (var Ye = 0, Xe = ve.length; Ye < Xe; ++Ye) {
            var xt = String(ve[Ye]), Mt = xt.lastIndexOf("@"), Zt = xt.slice(0, Mt).replace(Dn, ys).replace(Dn, a).replace(go, k), bt = xt.slice(Mt + 1);
            try {
              bt = le.iri ? D.toUnicode(bt) : D.toASCII(C(bt, le).toLowerCase());
            } catch (W) {
              be.error = be.error || "Email address's domain name can not be converted to " + (le.iri ? "Unicode" : "ASCII") + " via punycode: " + W;
            }
            ve[Ye] = Zt + "@" + bt;
          }
          be.path = ve.join(",");
        }
        var ee = Q.headers = Q.headers || {};
        Q.subject && (ee.subject = Q.subject), Q.body && (ee.body = Q.body);
        var O = [];
        for (var M in ee)
          ee[M] !== kt[M] && O.push(M.replace(Dn, ys).replace(Dn, a).replace(ia, k) + "=" + ee[M].replace(Dn, ys).replace(Dn, a).replace(sa, k));
        return O.length && (be.query = O.join("&")), be;
      }
    }, vo = /^([^\:]+)\:(.*)/, Ii = {
      scheme: "urn",
      parse: function(Q, le) {
        var be = Q.path && Q.path.match(vo), ve = Q;
        if (be) {
          var Ye = le.scheme || ve.scheme || "urn", Xe = be[1].toLowerCase(), xt = be[2], Mt = Ye + ":" + (le.nid || Xe), Zt = U[Mt];
          ve.nid = Xe, ve.nss = xt, ve.path = void 0, Zt && (ve = Zt.parse(ve, le));
        } else
          ve.error = ve.error || "URN can not be parsed.";
        return ve;
      },
      serialize: function(Q, le) {
        var be = le.scheme || Q.scheme || "urn", ve = Q.nid, Ye = be + ":" + (le.nid || ve), Xe = U[Ye];
        Xe && (Q = Xe.serialize(Q, le));
        var xt = Q, Mt = Q.nss;
        return xt.path = (ve || le.nid) + ":" + Mt, xt;
      }
    }, bo = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/, ji = {
      scheme: "urn:uuid",
      parse: function(Q, le) {
        var be = Q;
        return be.uuid = be.nss, be.nss = void 0, !le.tolerant && (!be.uuid || !be.uuid.match(bo)) && (be.error = be.error || "UUID is not valid."), be;
      },
      serialize: function(Q, le) {
        var be = Q;
        return be.nss = (Q.uuid || "").toLowerCase(), be;
      }
    };
    U[G.scheme] = G, U[fe.scheme] = fe, U[Oe.scheme] = Oe, U[ut.scheme] = ut, U[aa.scheme] = aa, U[Ii.scheme] = Ii, U[ji.scheme] = ji, r.SCHEMES = U, r.pctEncChar = k, r.pctDecChars = Z, r.parse = je, r.removeDotSegments = De, r.serialize = Le, r.resolveComponents = at, r.resolve = mt, r.normalize = Ue, r.equal = q, r.escapeComponent = x, r.unescapeComponent = C, Object.defineProperty(r, "__esModule", { value: !0 });
  });
})(Ay, Ay.exports);
var RF = Ay.exports;
Object.defineProperty(Mg, "__esModule", { value: !0 });
const KO = RF;
KO.code = 'require("ajv/dist/runtime/uri").default';
Mg.default = KO;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CodeGen = e.Name = e.nil = e.stringify = e.str = e._ = e.KeywordCxt = void 0;
  var t = Bf();
  Object.defineProperty(e, "KeywordCxt", { enumerable: !0, get: function() {
    return t.KeywordCxt;
  } });
  var r = pt;
  Object.defineProperty(e, "_", { enumerable: !0, get: function() {
    return r._;
  } }), Object.defineProperty(e, "str", { enumerable: !0, get: function() {
    return r.str;
  } }), Object.defineProperty(e, "stringify", { enumerable: !0, get: function() {
    return r.stringify;
  } }), Object.defineProperty(e, "nil", { enumerable: !0, get: function() {
    return r.nil;
  } }), Object.defineProperty(e, "Name", { enumerable: !0, get: function() {
    return r.Name;
  } }), Object.defineProperty(e, "CodeGen", { enumerable: !0, get: function() {
    return r.CodeGen;
  } });
  const i = Ju, n = Xu, s = Gs, a = Ir, o = pt, c = mr, l = ku, d = Pt, p = CF, h = Mg, g = (ie, Y) => new RegExp(ie, Y);
  g.code = "new RegExp";
  const m = ["removeAdditional", "useDefaults", "coerceTypes"], v = /* @__PURE__ */ new Set([
    "validate",
    "serialize",
    "parse",
    "wrapper",
    "root",
    "schema",
    "keyword",
    "pattern",
    "formats",
    "validate$data",
    "func",
    "obj",
    "Error"
  ]), _ = {
    errorDataPath: "",
    format: "`validateFormats: false` can be used instead.",
    nullable: '"nullable" keyword is supported by default.',
    jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
    extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
    missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
    processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
    sourceCode: "Use option `code: {source: true}`",
    strictDefaults: "It is default now, see option `strict`.",
    strictKeywords: "It is default now, see option `strict`.",
    uniqueItems: '"uniqueItems" keyword is always validated.',
    unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
    cache: "Map is used as cache, schema object as key.",
    serialize: "Map is used as cache, schema object as key.",
    ajvErrors: "It is default now."
  }, y = {
    ignoreKeywordsWithRef: "",
    jsPropertySyntax: "",
    unicode: '"minLength"/"maxLength" account for unicode characters by default.'
  }, w = 200;
  function $(ie) {
    var Y, V, z, T, F, D, U, k, Z, J, A, I, X, oe, Ae, je, Be, vt, $e, ht, nt, De, Le, at, mt;
    const Ue = ie.strict, q = (Y = ie.code) === null || Y === void 0 ? void 0 : Y.optimize, x = q === !0 || q === void 0 ? 1 : q || 0, C = (z = (V = ie.code) === null || V === void 0 ? void 0 : V.regExp) !== null && z !== void 0 ? z : g, G = (T = ie.uriResolver) !== null && T !== void 0 ? T : h.default;
    return {
      strictSchema: (D = (F = ie.strictSchema) !== null && F !== void 0 ? F : Ue) !== null && D !== void 0 ? D : !0,
      strictNumbers: (k = (U = ie.strictNumbers) !== null && U !== void 0 ? U : Ue) !== null && k !== void 0 ? k : !0,
      strictTypes: (J = (Z = ie.strictTypes) !== null && Z !== void 0 ? Z : Ue) !== null && J !== void 0 ? J : "log",
      strictTuples: (I = (A = ie.strictTuples) !== null && A !== void 0 ? A : Ue) !== null && I !== void 0 ? I : "log",
      strictRequired: (oe = (X = ie.strictRequired) !== null && X !== void 0 ? X : Ue) !== null && oe !== void 0 ? oe : !1,
      code: ie.code ? { ...ie.code, optimize: x, regExp: C } : { optimize: x, regExp: C },
      loopRequired: (Ae = ie.loopRequired) !== null && Ae !== void 0 ? Ae : w,
      loopEnum: (je = ie.loopEnum) !== null && je !== void 0 ? je : w,
      meta: (Be = ie.meta) !== null && Be !== void 0 ? Be : !0,
      messages: (vt = ie.messages) !== null && vt !== void 0 ? vt : !0,
      inlineRefs: ($e = ie.inlineRefs) !== null && $e !== void 0 ? $e : !0,
      schemaId: (ht = ie.schemaId) !== null && ht !== void 0 ? ht : "$id",
      addUsedSchema: (nt = ie.addUsedSchema) !== null && nt !== void 0 ? nt : !0,
      validateSchema: (De = ie.validateSchema) !== null && De !== void 0 ? De : !0,
      validateFormats: (Le = ie.validateFormats) !== null && Le !== void 0 ? Le : !0,
      unicodeRegExp: (at = ie.unicodeRegExp) !== null && at !== void 0 ? at : !0,
      int32range: (mt = ie.int32range) !== null && mt !== void 0 ? mt : !0,
      uriResolver: G
    };
  }
  class E {
    constructor(Y = {}) {
      this.schemas = {}, this.refs = {}, this.formats = {}, this._compilations = /* @__PURE__ */ new Set(), this._loading = {}, this._cache = /* @__PURE__ */ new Map(), Y = this.opts = { ...Y, ...$(Y) };
      const { es5: V, lines: z } = this.opts.code;
      this.scope = new o.ValueScope({ scope: {}, prefixes: v, es5: V, lines: z }), this.logger = xe(Y.logger);
      const T = Y.validateFormats;
      Y.validateFormats = !1, this.RULES = (0, s.getRules)(), S.call(this, _, Y, "NOT SUPPORTED"), S.call(this, y, Y, "DEPRECATED", "warn"), this._metaOpts = ae.call(this), Y.formats && L.call(this), this._addVocabularies(), this._addDefaultMetaSchema(), Y.keywords && K.call(this, Y.keywords), typeof Y.meta == "object" && this.addMetaSchema(Y.meta), j.call(this), Y.validateFormats = T;
    }
    _addVocabularies() {
      this.addKeyword("$async");
    }
    _addDefaultMetaSchema() {
      const { $data: Y, meta: V, schemaId: z } = this.opts;
      let T = p;
      z === "id" && (T = { ...p }, T.id = T.$id, delete T.$id), V && Y && this.addMetaSchema(T, T[z], !1);
    }
    defaultMeta() {
      const { meta: Y, schemaId: V } = this.opts;
      return this.opts.defaultMeta = typeof Y == "object" ? Y[V] || Y : void 0;
    }
    validate(Y, V) {
      let z;
      if (typeof Y == "string") {
        if (z = this.getSchema(Y), !z)
          throw new Error(`no schema with key or ref "${Y}"`);
      } else
        z = this.compile(Y);
      const T = z(V);
      return "$async" in z || (this.errors = z.errors), T;
    }
    compile(Y, V) {
      const z = this._addSchema(Y, V);
      return z.validate || this._compileSchemaEnv(z);
    }
    compileAsync(Y, V) {
      if (typeof this.opts.loadSchema != "function")
        throw new Error("options.loadSchema should be a function");
      const { loadSchema: z } = this.opts;
      return T.call(this, Y, V);
      async function T(J, A) {
        await F.call(this, J.$schema);
        const I = this._addSchema(J, A);
        return I.validate || D.call(this, I);
      }
      async function F(J) {
        J && !this.getSchema(J) && await T.call(this, { $ref: J }, !0);
      }
      async function D(J) {
        try {
          return this._compileSchemaEnv(J);
        } catch (A) {
          if (!(A instanceof n.default))
            throw A;
          return U.call(this, A), await k.call(this, A.missingSchema), D.call(this, J);
        }
      }
      function U({ missingSchema: J, missingRef: A }) {
        if (this.refs[J])
          throw new Error(`AnySchema ${J} is loaded but ${A} cannot be resolved`);
      }
      async function k(J) {
        const A = await Z.call(this, J);
        this.refs[J] || await F.call(this, A.$schema), this.refs[J] || this.addSchema(A, J, V);
      }
      async function Z(J) {
        const A = this._loading[J];
        if (A)
          return A;
        try {
          return await (this._loading[J] = z(J));
        } finally {
          delete this._loading[J];
        }
      }
    }
    // Adds schema to the instance
    addSchema(Y, V, z, T = this.opts.validateSchema) {
      if (Array.isArray(Y)) {
        for (const D of Y)
          this.addSchema(D, void 0, z, T);
        return this;
      }
      let F;
      if (typeof Y == "object") {
        const { schemaId: D } = this.opts;
        if (F = Y[D], F !== void 0 && typeof F != "string")
          throw new Error(`schema ${D} must be string`);
      }
      return V = (0, c.normalizeId)(V || F), this._checkUnique(V), this.schemas[V] = this._addSchema(Y, z, V, T, !0), this;
    }
    // Add schema that will be used to validate other schemas
    // options in META_IGNORE_OPTIONS are alway set to false
    addMetaSchema(Y, V, z = this.opts.validateSchema) {
      return this.addSchema(Y, V, !0, z), this;
    }
    //  Validate schema against its meta-schema
    validateSchema(Y, V) {
      if (typeof Y == "boolean")
        return !0;
      let z;
      if (z = Y.$schema, z !== void 0 && typeof z != "string")
        throw new Error("$schema must be a string");
      if (z = z || this.opts.defaultMeta || this.defaultMeta(), !z)
        return this.logger.warn("meta-schema not available"), this.errors = null, !0;
      const T = this.validate(z, Y);
      if (!T && V) {
        const F = "schema is invalid: " + this.errorsText();
        if (this.opts.validateSchema === "log")
          this.logger.error(F);
        else
          throw new Error(F);
      }
      return T;
    }
    // Get compiled schema by `key` or `ref`.
    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
    getSchema(Y) {
      let V;
      for (; typeof (V = R.call(this, Y)) == "string"; )
        Y = V;
      if (V === void 0) {
        const { schemaId: z } = this.opts, T = new a.SchemaEnv({ schema: {}, schemaId: z });
        if (V = a.resolveSchema.call(this, T, Y), !V)
          return;
        this.refs[Y] = V;
      }
      return V.validate || this._compileSchemaEnv(V);
    }
    // Remove cached schema(s).
    // If no parameter is passed all schemas but meta-schemas are removed.
    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
    removeSchema(Y) {
      if (Y instanceof RegExp)
        return this._removeAllSchemas(this.schemas, Y), this._removeAllSchemas(this.refs, Y), this;
      switch (typeof Y) {
        case "undefined":
          return this._removeAllSchemas(this.schemas), this._removeAllSchemas(this.refs), this._cache.clear(), this;
        case "string": {
          const V = R.call(this, Y);
          return typeof V == "object" && this._cache.delete(V.schema), delete this.schemas[Y], delete this.refs[Y], this;
        }
        case "object": {
          const V = Y;
          this._cache.delete(V);
          let z = Y[this.opts.schemaId];
          return z && (z = (0, c.normalizeId)(z), delete this.schemas[z], delete this.refs[z]), this;
        }
        default:
          throw new Error("ajv.removeSchema: invalid parameter");
      }
    }
    // add "vocabulary" - a collection of keywords
    addVocabulary(Y) {
      for (const V of Y)
        this.addKeyword(V);
      return this;
    }
    addKeyword(Y, V) {
      let z;
      if (typeof Y == "string")
        z = Y, typeof V == "object" && (this.logger.warn("these parameters are deprecated, see docs for addKeyword"), V.keyword = z);
      else if (typeof Y == "object" && V === void 0) {
        if (V = Y, z = V.keyword, Array.isArray(z) && !z.length)
          throw new Error("addKeywords: keyword must be string or non-empty array");
      } else
        throw new Error("invalid addKeywords parameters");
      if (te.call(this, z, V), !V)
        return (0, d.eachItem)(z, (F) => pe.call(this, F)), this;
      Ee.call(this, V);
      const T = {
        ...V,
        type: (0, l.getJSONTypes)(V.type),
        schemaType: (0, l.getJSONTypes)(V.schemaType)
      };
      return (0, d.eachItem)(z, T.type.length === 0 ? (F) => pe.call(this, F, T) : (F) => T.type.forEach((D) => pe.call(this, F, T, D))), this;
    }
    getKeyword(Y) {
      const V = this.RULES.all[Y];
      return typeof V == "object" ? V.definition : !!V;
    }
    // Remove keyword
    removeKeyword(Y) {
      const { RULES: V } = this;
      delete V.keywords[Y], delete V.all[Y];
      for (const z of V.rules) {
        const T = z.rules.findIndex((F) => F.keyword === Y);
        T >= 0 && z.rules.splice(T, 1);
      }
      return this;
    }
    // Add format
    addFormat(Y, V) {
      return typeof V == "string" && (V = new RegExp(V)), this.formats[Y] = V, this;
    }
    errorsText(Y = this.errors, { separator: V = ", ", dataVar: z = "data" } = {}) {
      return !Y || Y.length === 0 ? "No errors" : Y.map((T) => `${z}${T.instancePath} ${T.message}`).reduce((T, F) => T + V + F);
    }
    $dataMetaSchema(Y, V) {
      const z = this.RULES.all;
      Y = JSON.parse(JSON.stringify(Y));
      for (const T of V) {
        const F = T.split("/").slice(1);
        let D = Y;
        for (const U of F)
          D = D[U];
        for (const U in z) {
          const k = z[U];
          if (typeof k != "object")
            continue;
          const { $data: Z } = k.definition, J = D[U];
          Z && J && (D[U] = _e(J));
        }
      }
      return Y;
    }
    _removeAllSchemas(Y, V) {
      for (const z in Y) {
        const T = Y[z];
        (!V || V.test(z)) && (typeof T == "string" ? delete Y[z] : T && !T.meta && (this._cache.delete(T.schema), delete Y[z]));
      }
    }
    _addSchema(Y, V, z, T = this.opts.validateSchema, F = this.opts.addUsedSchema) {
      let D;
      const { schemaId: U } = this.opts;
      if (typeof Y == "object")
        D = Y[U];
      else {
        if (this.opts.jtd)
          throw new Error("schema must be object");
        if (typeof Y != "boolean")
          throw new Error("schema must be object or boolean");
      }
      let k = this._cache.get(Y);
      if (k !== void 0)
        return k;
      z = (0, c.normalizeId)(D || z);
      const Z = c.getSchemaRefs.call(this, Y, z);
      return k = new a.SchemaEnv({ schema: Y, schemaId: U, meta: V, baseId: z, localRefs: Z }), this._cache.set(k.schema, k), F && !z.startsWith("#") && (z && this._checkUnique(z), this.refs[z] = k), T && this.validateSchema(Y, !0), k;
    }
    _checkUnique(Y) {
      if (this.schemas[Y] || this.refs[Y])
        throw new Error(`schema with key or id "${Y}" already exists`);
    }
    _compileSchemaEnv(Y) {
      if (Y.meta ? this._compileMetaSchema(Y) : a.compileSchema.call(this, Y), !Y.validate)
        throw new Error("ajv implementation error");
      return Y.validate;
    }
    _compileMetaSchema(Y) {
      const V = this.opts;
      this.opts = this._metaOpts;
      try {
        a.compileSchema.call(this, Y);
      } finally {
        this.opts = V;
      }
    }
  }
  e.default = E, E.ValidationError = i.default, E.MissingRefError = n.default;
  function S(ie, Y, V, z = "error") {
    for (const T in ie) {
      const F = T;
      F in Y && this.logger[z](`${V}: option ${T}. ${ie[F]}`);
    }
  }
  function R(ie) {
    return ie = (0, c.normalizeId)(ie), this.schemas[ie] || this.refs[ie];
  }
  function j() {
    const ie = this.opts.schemas;
    if (ie)
      if (Array.isArray(ie))
        this.addSchema(ie);
      else
        for (const Y in ie)
          this.addSchema(ie[Y], Y);
  }
  function L() {
    for (const ie in this.opts.formats) {
      const Y = this.opts.formats[ie];
      Y && this.addFormat(ie, Y);
    }
  }
  function K(ie) {
    if (Array.isArray(ie)) {
      this.addVocabulary(ie);
      return;
    }
    this.logger.warn("keywords option as map is deprecated, pass array");
    for (const Y in ie) {
      const V = ie[Y];
      V.keyword || (V.keyword = Y), this.addKeyword(V);
    }
  }
  function ae() {
    const ie = { ...this.opts };
    for (const Y of m)
      delete ie[Y];
    return ie;
  }
  const ye = { log() {
  }, warn() {
  }, error() {
  } };
  function xe(ie) {
    if (ie === !1)
      return ye;
    if (ie === void 0)
      return console;
    if (ie.log && ie.warn && ie.error)
      return ie;
    throw new Error("logger must implement log, warn and error methods");
  }
  const Pe = /^[a-z_$][a-z0-9_$:-]*$/i;
  function te(ie, Y) {
    const { RULES: V } = this;
    if ((0, d.eachItem)(ie, (z) => {
      if (V.keywords[z])
        throw new Error(`Keyword ${z} is already defined`);
      if (!Pe.test(z))
        throw new Error(`Keyword ${z} has invalid name`);
    }), !!Y && Y.$data && !("code" in Y || "validate" in Y))
      throw new Error('$data keyword must have "code" or "validate" function');
  }
  function pe(ie, Y, V) {
    var z;
    const T = Y == null ? void 0 : Y.post;
    if (V && T)
      throw new Error('keyword with "post" flag cannot have "type"');
    const { RULES: F } = this;
    let D = T ? F.post : F.rules.find(({ type: k }) => k === V);
    if (D || (D = { type: V, rules: [] }, F.rules.push(D)), F.keywords[ie] = !0, !Y)
      return;
    const U = {
      keyword: ie,
      definition: {
        ...Y,
        type: (0, l.getJSONTypes)(Y.type),
        schemaType: (0, l.getJSONTypes)(Y.schemaType)
      }
    };
    Y.before ? de.call(this, D, U, Y.before) : D.rules.push(U), F.all[ie] = U, (z = Y.implements) === null || z === void 0 || z.forEach((k) => this.addKeyword(k));
  }
  function de(ie, Y, V) {
    const z = ie.rules.findIndex((T) => T.keyword === V);
    z >= 0 ? ie.rules.splice(z, 0, Y) : (ie.rules.push(Y), this.logger.warn(`rule ${V} is not defined`));
  }
  function Ee(ie) {
    let { metaSchema: Y } = ie;
    Y !== void 0 && (ie.$data && this.opts.$data && (Y = _e(Y)), ie.validateSchema = this.compile(Y, !0));
  }
  const Re = {
    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
  };
  function _e(ie) {
    return { anyOf: [ie, Re] };
  }
})(za);
var Ng = {}, Dg = {}, Lg = {};
Object.defineProperty(Lg, "__esModule", { value: !0 });
const TF = {
  keyword: "id",
  code() {
    throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
  }
};
Lg.default = TF;
var Qn = {};
Object.defineProperty(Qn, "__esModule", { value: !0 });
Qn.callRef = Qn.getValidate = void 0;
const IF = Xu, jw = Mn(), Br = pt, Sa = Qr, kw = Ir, sl = Pt, jF = {
  keyword: "$ref",
  schemaType: "string",
  code(e) {
    const { gen: t, schema: r, it: i } = e, { baseId: n, schemaEnv: s, validateName: a, opts: o, self: c } = i, { root: l } = s;
    if ((r === "#" || r === "#/") && n === l.baseId)
      return p();
    const d = kw.resolveRef.call(c, l, n, r);
    if (d === void 0)
      throw new IF.default(i.opts.uriResolver, n, r);
    if (d instanceof kw.SchemaEnv)
      return h(d);
    return g(d);
    function p() {
      if (s === l)
        return Al(e, a, s, s.$async);
      const m = t.scopeValue("root", { ref: l });
      return Al(e, (0, Br._)`${m}.validate`, l, l.$async);
    }
    function h(m) {
      const v = YO(e, m);
      Al(e, v, m, m.$async);
    }
    function g(m) {
      const v = t.scopeValue("schema", o.code.source === !0 ? { ref: m, code: (0, Br.stringify)(m) } : { ref: m }), _ = t.name("valid"), y = e.subschema({
        schema: m,
        dataTypes: [],
        schemaPath: Br.nil,
        topSchemaRef: v,
        errSchemaPath: r
      }, _);
      e.mergeEvaluated(y), e.ok(_);
    }
  }
};
function YO(e, t) {
  const { gen: r } = e;
  return t.validate ? r.scopeValue("validate", { ref: t.validate }) : (0, Br._)`${r.scopeValue("wrapper", { ref: t })}.validate`;
}
Qn.getValidate = YO;
function Al(e, t, r, i) {
  const { gen: n, it: s } = e, { allErrors: a, schemaEnv: o, opts: c } = s, l = c.passContext ? Sa.default.this : Br.nil;
  i ? d() : p();
  function d() {
    if (!o.$async)
      throw new Error("async schema referenced by sync schema");
    const m = n.let("valid");
    n.try(() => {
      n.code((0, Br._)`await ${(0, jw.callValidateCode)(e, t, l)}`), g(t), a || n.assign(m, !0);
    }, (v) => {
      n.if((0, Br._)`!(${v} instanceof ${s.ValidationError})`, () => n.throw(v)), h(v), a || n.assign(m, !1);
    }), e.ok(m);
  }
  function p() {
    e.result((0, jw.callValidateCode)(e, t, l), () => g(t), () => h(t));
  }
  function h(m) {
    const v = (0, Br._)`${m}.errors`;
    n.assign(Sa.default.vErrors, (0, Br._)`${Sa.default.vErrors} === null ? ${v} : ${Sa.default.vErrors}.concat(${v})`), n.assign(Sa.default.errors, (0, Br._)`${Sa.default.vErrors}.length`);
  }
  function g(m) {
    var v;
    if (!s.opts.unevaluated)
      return;
    const _ = (v = r == null ? void 0 : r.validate) === null || v === void 0 ? void 0 : v.evaluated;
    if (s.props !== !0)
      if (_ && !_.dynamicProps)
        _.props !== void 0 && (s.props = sl.mergeEvaluated.props(n, _.props, s.props));
      else {
        const y = n.var("props", (0, Br._)`${m}.evaluated.props`);
        s.props = sl.mergeEvaluated.props(n, y, s.props, Br.Name);
      }
    if (s.items !== !0)
      if (_ && !_.dynamicItems)
        _.items !== void 0 && (s.items = sl.mergeEvaluated.items(n, _.items, s.items));
      else {
        const y = n.var("items", (0, Br._)`${m}.evaluated.items`);
        s.items = sl.mergeEvaluated.items(n, y, s.items, Br.Name);
      }
  }
}
Qn.callRef = Al;
Qn.default = jF;
Object.defineProperty(Dg, "__esModule", { value: !0 });
const kF = Lg, MF = Qn, NF = [
  "$schema",
  "$id",
  "$defs",
  "$vocabulary",
  { keyword: "$comment" },
  "definitions",
  kF.default,
  MF.default
];
Dg.default = NF;
var qg = {}, Fg = {};
Object.defineProperty(Fg, "__esModule", { value: !0 });
const uf = pt, Hi = uf.operators, cf = {
  maximum: { okStr: "<=", ok: Hi.LTE, fail: Hi.GT },
  minimum: { okStr: ">=", ok: Hi.GTE, fail: Hi.LT },
  exclusiveMaximum: { okStr: "<", ok: Hi.LT, fail: Hi.GTE },
  exclusiveMinimum: { okStr: ">", ok: Hi.GT, fail: Hi.LTE }
}, DF = {
  message: ({ keyword: e, schemaCode: t }) => (0, uf.str)`must be ${cf[e].okStr} ${t}`,
  params: ({ keyword: e, schemaCode: t }) => (0, uf._)`{comparison: ${cf[e].okStr}, limit: ${t}}`
}, LF = {
  keyword: Object.keys(cf),
  type: "number",
  schemaType: "number",
  $data: !0,
  error: DF,
  code(e) {
    const { keyword: t, data: r, schemaCode: i } = e;
    e.fail$data((0, uf._)`${r} ${cf[t].fail} ${i} || isNaN(${r})`);
  }
};
Fg.default = LF;
var zf = {};
Object.defineProperty(zf, "__esModule", { value: !0 });
const au = pt, qF = {
  message: ({ schemaCode: e }) => (0, au.str)`must be multiple of ${e}`,
  params: ({ schemaCode: e }) => (0, au._)`{multipleOf: ${e}}`
}, FF = {
  keyword: "multipleOf",
  type: "number",
  schemaType: "number",
  $data: !0,
  error: qF,
  code(e) {
    const { gen: t, data: r, schemaCode: i, it: n } = e, s = n.opts.multipleOfPrecision, a = t.let("res"), o = s ? (0, au._)`Math.abs(Math.round(${a}) - ${a}) > 1e-${s}` : (0, au._)`${a} !== parseInt(${a})`;
    e.fail$data((0, au._)`(${i} === 0 || (${a} = ${r}/${i}, ${o}))`);
  }
};
zf.default = FF;
var Wf = {}, Ug = {};
Object.defineProperty(Ug, "__esModule", { value: !0 });
function JO(e) {
  const t = e.length;
  let r = 0, i = 0, n;
  for (; i < t; )
    r++, n = e.charCodeAt(i++), n >= 55296 && n <= 56319 && i < t && (n = e.charCodeAt(i), (n & 64512) === 56320 && i++);
  return r;
}
Ug.default = JO;
JO.code = 'require("ajv/dist/runtime/ucs2length").default';
Object.defineProperty(Wf, "__esModule", { value: !0 });
const ks = pt, UF = Pt, BF = Ug, VF = {
  message({ keyword: e, schemaCode: t }) {
    const r = e === "maxLength" ? "more" : "fewer";
    return (0, ks.str)`must NOT have ${r} than ${t} characters`;
  },
  params: ({ schemaCode: e }) => (0, ks._)`{limit: ${e}}`
}, ZF = {
  keyword: ["maxLength", "minLength"],
  type: "string",
  schemaType: "number",
  $data: !0,
  error: VF,
  code(e) {
    const { keyword: t, data: r, schemaCode: i, it: n } = e, s = t === "maxLength" ? ks.operators.GT : ks.operators.LT, a = n.opts.unicode === !1 ? (0, ks._)`${r}.length` : (0, ks._)`${(0, UF.useFunc)(e.gen, BF.default)}(${r})`;
    e.fail$data((0, ks._)`${a} ${s} ${i}`);
  }
};
Wf.default = ZF;
var Hf = {};
Object.defineProperty(Hf, "__esModule", { value: !0 });
const zF = Mn(), lf = pt, WF = {
  message: ({ schemaCode: e }) => (0, lf.str)`must match pattern "${e}"`,
  params: ({ schemaCode: e }) => (0, lf._)`{pattern: ${e}}`
}, HF = {
  keyword: "pattern",
  type: "string",
  schemaType: "string",
  $data: !0,
  error: WF,
  code(e) {
    const { data: t, $data: r, schema: i, schemaCode: n, it: s } = e, a = s.opts.unicodeRegExp ? "u" : "", o = r ? (0, lf._)`(new RegExp(${n}, ${a}))` : (0, zF.usePattern)(e, i);
    e.fail$data((0, lf._)`!${o}.test(${t})`);
  }
};
Hf.default = HF;
var Gf = {};
Object.defineProperty(Gf, "__esModule", { value: !0 });
const ou = pt, GF = {
  message({ keyword: e, schemaCode: t }) {
    const r = e === "maxProperties" ? "more" : "fewer";
    return (0, ou.str)`must NOT have ${r} than ${t} properties`;
  },
  params: ({ schemaCode: e }) => (0, ou._)`{limit: ${e}}`
}, KF = {
  keyword: ["maxProperties", "minProperties"],
  type: "object",
  schemaType: "number",
  $data: !0,
  error: GF,
  code(e) {
    const { keyword: t, data: r, schemaCode: i } = e, n = t === "maxProperties" ? ou.operators.GT : ou.operators.LT;
    e.fail$data((0, ou._)`Object.keys(${r}).length ${n} ${i}`);
  }
};
Gf.default = KF;
var Kf = {};
Object.defineProperty(Kf, "__esModule", { value: !0 });
const zo = Mn(), uu = pt, YF = Pt, JF = {
  message: ({ params: { missingProperty: e } }) => (0, uu.str)`must have required property '${e}'`,
  params: ({ params: { missingProperty: e } }) => (0, uu._)`{missingProperty: ${e}}`
}, XF = {
  keyword: "required",
  type: "object",
  schemaType: "array",
  $data: !0,
  error: JF,
  code(e) {
    const { gen: t, schema: r, schemaCode: i, data: n, $data: s, it: a } = e, { opts: o } = a;
    if (!s && r.length === 0)
      return;
    const c = r.length >= o.loopRequired;
    if (a.allErrors ? l() : d(), o.strictRequired) {
      const g = e.parentSchema.properties, { definedProperties: m } = e.it;
      for (const v of r)
        if ((g == null ? void 0 : g[v]) === void 0 && !m.has(v)) {
          const _ = a.schemaEnv.baseId + a.errSchemaPath, y = `required property "${v}" is not defined at "${_}" (strictRequired)`;
          (0, YF.checkStrictMode)(a, y, a.opts.strictRequired);
        }
    }
    function l() {
      if (c || s)
        e.block$data(uu.nil, p);
      else
        for (const g of r)
          (0, zo.checkReportMissingProp)(e, g);
    }
    function d() {
      const g = t.let("missing");
      if (c || s) {
        const m = t.let("valid", !0);
        e.block$data(m, () => h(g, m)), e.ok(m);
      } else
        t.if((0, zo.checkMissingProp)(e, r, g)), (0, zo.reportMissingProp)(e, g), t.else();
    }
    function p() {
      t.forOf("prop", i, (g) => {
        e.setParams({ missingProperty: g }), t.if((0, zo.noPropertyInData)(t, n, g, o.ownProperties), () => e.error());
      });
    }
    function h(g, m) {
      e.setParams({ missingProperty: g }), t.forOf(g, i, () => {
        t.assign(m, (0, zo.propertyInData)(t, n, g, o.ownProperties)), t.if((0, uu.not)(m), () => {
          e.error(), t.break();
        });
      }, uu.nil);
    }
  }
};
Kf.default = XF;
var Yf = {};
Object.defineProperty(Yf, "__esModule", { value: !0 });
const cu = pt, QF = {
  message({ keyword: e, schemaCode: t }) {
    const r = e === "maxItems" ? "more" : "fewer";
    return (0, cu.str)`must NOT have ${r} than ${t} items`;
  },
  params: ({ schemaCode: e }) => (0, cu._)`{limit: ${e}}`
}, eU = {
  keyword: ["maxItems", "minItems"],
  type: "array",
  schemaType: "number",
  $data: !0,
  error: QF,
  code(e) {
    const { keyword: t, data: r, schemaCode: i } = e, n = t === "maxItems" ? cu.operators.GT : cu.operators.LT;
    e.fail$data((0, cu._)`${r}.length ${n} ${i}`);
  }
};
Yf.default = eU;
var Jf = {}, Qu = {};
Object.defineProperty(Qu, "__esModule", { value: !0 });
const XO = VO;
XO.code = 'require("ajv/dist/runtime/equal").default';
Qu.default = XO;
Object.defineProperty(Jf, "__esModule", { value: !0 });
const Fh = ku, hr = pt, tU = Pt, rU = Qu, nU = {
  message: ({ params: { i: e, j: t } }) => (0, hr.str)`must NOT have duplicate items (items ## ${t} and ${e} are identical)`,
  params: ({ params: { i: e, j: t } }) => (0, hr._)`{i: ${e}, j: ${t}}`
}, iU = {
  keyword: "uniqueItems",
  type: "array",
  schemaType: "boolean",
  $data: !0,
  error: nU,
  code(e) {
    const { gen: t, data: r, $data: i, schema: n, parentSchema: s, schemaCode: a, it: o } = e;
    if (!i && !n)
      return;
    const c = t.let("valid"), l = s.items ? (0, Fh.getSchemaTypes)(s.items) : [];
    e.block$data(c, d, (0, hr._)`${a} === false`), e.ok(c);
    function d() {
      const m = t.let("i", (0, hr._)`${r}.length`), v = t.let("j");
      e.setParams({ i: m, j: v }), t.assign(c, !0), t.if((0, hr._)`${m} > 1`, () => (p() ? h : g)(m, v));
    }
    function p() {
      return l.length > 0 && !l.some((m) => m === "object" || m === "array");
    }
    function h(m, v) {
      const _ = t.name("item"), y = (0, Fh.checkDataTypes)(l, _, o.opts.strictNumbers, Fh.DataType.Wrong), w = t.const("indices", (0, hr._)`{}`);
      t.for((0, hr._)`;${m}--;`, () => {
        t.let(_, (0, hr._)`${r}[${m}]`), t.if(y, (0, hr._)`continue`), l.length > 1 && t.if((0, hr._)`typeof ${_} == "string"`, (0, hr._)`${_} += "_"`), t.if((0, hr._)`typeof ${w}[${_}] == "number"`, () => {
          t.assign(v, (0, hr._)`${w}[${_}]`), e.error(), t.assign(c, !1).break();
        }).code((0, hr._)`${w}[${_}] = ${m}`);
      });
    }
    function g(m, v) {
      const _ = (0, tU.useFunc)(t, rU.default), y = t.name("outer");
      t.label(y).for((0, hr._)`;${m}--;`, () => t.for((0, hr._)`${v} = ${m}; ${v}--;`, () => t.if((0, hr._)`${_}(${r}[${m}], ${r}[${v}])`, () => {
        e.error(), t.assign(c, !1).break(y);
      })));
    }
  }
};
Jf.default = iU;
var Xf = {};
Object.defineProperty(Xf, "__esModule", { value: !0 });
const Cy = pt, sU = Pt, aU = Qu, oU = {
  message: "must be equal to constant",
  params: ({ schemaCode: e }) => (0, Cy._)`{allowedValue: ${e}}`
}, uU = {
  keyword: "const",
  $data: !0,
  error: oU,
  code(e) {
    const { gen: t, data: r, $data: i, schemaCode: n, schema: s } = e;
    i || s && typeof s == "object" ? e.fail$data((0, Cy._)`!${(0, sU.useFunc)(t, aU.default)}(${r}, ${n})`) : e.fail((0, Cy._)`${s} !== ${r}`);
  }
};
Xf.default = uU;
var Qf = {};
Object.defineProperty(Qf, "__esModule", { value: !0 });
const Qo = pt, cU = Pt, lU = Qu, fU = {
  message: "must be equal to one of the allowed values",
  params: ({ schemaCode: e }) => (0, Qo._)`{allowedValues: ${e}}`
}, dU = {
  keyword: "enum",
  schemaType: "array",
  $data: !0,
  error: fU,
  code(e) {
    const { gen: t, data: r, $data: i, schema: n, schemaCode: s, it: a } = e;
    if (!i && n.length === 0)
      throw new Error("enum must have non-empty array");
    const o = n.length >= a.opts.loopEnum;
    let c;
    const l = () => c ?? (c = (0, cU.useFunc)(t, lU.default));
    let d;
    if (o || i)
      d = t.let("valid"), e.block$data(d, p);
    else {
      if (!Array.isArray(n))
        throw new Error("ajv implementation error");
      const g = t.const("vSchema", s);
      d = (0, Qo.or)(...n.map((m, v) => h(g, v)));
    }
    e.pass(d);
    function p() {
      t.assign(d, !1), t.forOf("v", s, (g) => t.if((0, Qo._)`${l()}(${r}, ${g})`, () => t.assign(d, !0).break()));
    }
    function h(g, m) {
      const v = n[m];
      return typeof v == "object" && v !== null ? (0, Qo._)`${l()}(${r}, ${g}[${m}])` : (0, Qo._)`${r} === ${v}`;
    }
  }
};
Qf.default = dU;
Object.defineProperty(qg, "__esModule", { value: !0 });
const pU = Fg, hU = zf, mU = Wf, yU = Hf, gU = Gf, vU = Kf, bU = Yf, _U = Jf, wU = Xf, $U = Qf, EU = [
  // number
  pU.default,
  hU.default,
  // string
  mU.default,
  yU.default,
  // object
  gU.default,
  vU.default,
  // array
  bU.default,
  _U.default,
  // any
  { keyword: "type", schemaType: ["string", "array"] },
  { keyword: "nullable", schemaType: "boolean" },
  wU.default,
  $U.default
];
qg.default = EU;
var ed = {}, uo = {};
Object.defineProperty(uo, "__esModule", { value: !0 });
uo.validateAdditionalItems = void 0;
const Ms = pt, Ry = Pt, xU = {
  message: ({ params: { len: e } }) => (0, Ms.str)`must NOT have more than ${e} items`,
  params: ({ params: { len: e } }) => (0, Ms._)`{limit: ${e}}`
}, OU = {
  keyword: "additionalItems",
  type: "array",
  schemaType: ["boolean", "object"],
  before: "uniqueItems",
  error: xU,
  code(e) {
    const { parentSchema: t, it: r } = e, { items: i } = t;
    if (!Array.isArray(i)) {
      (0, Ry.checkStrictMode)(r, '"additionalItems" is ignored when "items" is not an array of schemas');
      return;
    }
    QO(e, i);
  }
};
function QO(e, t) {
  const { gen: r, schema: i, data: n, keyword: s, it: a } = e;
  a.items = !0;
  const o = r.const("len", (0, Ms._)`${n}.length`);
  if (i === !1)
    e.setParams({ len: t.length }), e.pass((0, Ms._)`${o} <= ${t.length}`);
  else if (typeof i == "object" && !(0, Ry.alwaysValidSchema)(a, i)) {
    const l = r.var("valid", (0, Ms._)`${o} <= ${t.length}`);
    r.if((0, Ms.not)(l), () => c(l)), e.ok(l);
  }
  function c(l) {
    r.forRange("i", t.length, o, (d) => {
      e.subschema({ keyword: s, dataProp: d, dataPropType: Ry.Type.Num }, l), a.allErrors || r.if((0, Ms.not)(l), () => r.break());
    });
  }
}
uo.validateAdditionalItems = QO;
uo.default = OU;
var Bg = {}, co = {};
Object.defineProperty(co, "__esModule", { value: !0 });
co.validateTuple = void 0;
const Mw = pt, Cl = Pt, PU = Mn(), SU = {
  keyword: "items",
  type: "array",
  schemaType: ["object", "array", "boolean"],
  before: "uniqueItems",
  code(e) {
    const { schema: t, it: r } = e;
    if (Array.isArray(t))
      return eP(e, "additionalItems", t);
    r.items = !0, !(0, Cl.alwaysValidSchema)(r, t) && e.ok((0, PU.validateArray)(e));
  }
};
function eP(e, t, r = e.schema) {
  const { gen: i, parentSchema: n, data: s, keyword: a, it: o } = e;
  d(n), o.opts.unevaluated && r.length && o.items !== !0 && (o.items = Cl.mergeEvaluated.items(i, r.length, o.items));
  const c = i.name("valid"), l = i.const("len", (0, Mw._)`${s}.length`);
  r.forEach((p, h) => {
    (0, Cl.alwaysValidSchema)(o, p) || (i.if((0, Mw._)`${l} > ${h}`, () => e.subschema({
      keyword: a,
      schemaProp: h,
      dataProp: h
    }, c)), e.ok(c));
  });
  function d(p) {
    const { opts: h, errSchemaPath: g } = o, m = r.length, v = m === p.minItems && (m === p.maxItems || p[t] === !1);
    if (h.strictTuples && !v) {
      const _ = `"${a}" is ${m}-tuple, but minItems or maxItems/${t} are not specified or different at path "${g}"`;
      (0, Cl.checkStrictMode)(o, _, h.strictTuples);
    }
  }
}
co.validateTuple = eP;
co.default = SU;
Object.defineProperty(Bg, "__esModule", { value: !0 });
const AU = co, CU = {
  keyword: "prefixItems",
  type: "array",
  schemaType: ["array"],
  before: "uniqueItems",
  code: (e) => (0, AU.validateTuple)(e, "items")
};
Bg.default = CU;
var Vg = {};
Object.defineProperty(Vg, "__esModule", { value: !0 });
const Nw = pt, RU = Pt, TU = Mn(), IU = uo, jU = {
  message: ({ params: { len: e } }) => (0, Nw.str)`must NOT have more than ${e} items`,
  params: ({ params: { len: e } }) => (0, Nw._)`{limit: ${e}}`
}, kU = {
  keyword: "items",
  type: "array",
  schemaType: ["object", "boolean"],
  before: "uniqueItems",
  error: jU,
  code(e) {
    const { schema: t, parentSchema: r, it: i } = e, { prefixItems: n } = r;
    i.items = !0, !(0, RU.alwaysValidSchema)(i, t) && (n ? (0, IU.validateAdditionalItems)(e, n) : e.ok((0, TU.validateArray)(e)));
  }
};
Vg.default = kU;
var Zg = {};
Object.defineProperty(Zg, "__esModule", { value: !0 });
const ln = pt, al = Pt, MU = {
  message: ({ params: { min: e, max: t } }) => t === void 0 ? (0, ln.str)`must contain at least ${e} valid item(s)` : (0, ln.str)`must contain at least ${e} and no more than ${t} valid item(s)`,
  params: ({ params: { min: e, max: t } }) => t === void 0 ? (0, ln._)`{minContains: ${e}}` : (0, ln._)`{minContains: ${e}, maxContains: ${t}}`
}, NU = {
  keyword: "contains",
  type: "array",
  schemaType: ["object", "boolean"],
  before: "uniqueItems",
  trackErrors: !0,
  error: MU,
  code(e) {
    const { gen: t, schema: r, parentSchema: i, data: n, it: s } = e;
    let a, o;
    const { minContains: c, maxContains: l } = i;
    s.opts.next ? (a = c === void 0 ? 1 : c, o = l) : a = 1;
    const d = t.const("len", (0, ln._)`${n}.length`);
    if (e.setParams({ min: a, max: o }), o === void 0 && a === 0) {
      (0, al.checkStrictMode)(s, '"minContains" == 0 without "maxContains": "contains" keyword ignored');
      return;
    }
    if (o !== void 0 && a > o) {
      (0, al.checkStrictMode)(s, '"minContains" > "maxContains" is always invalid'), e.fail();
      return;
    }
    if ((0, al.alwaysValidSchema)(s, r)) {
      let v = (0, ln._)`${d} >= ${a}`;
      o !== void 0 && (v = (0, ln._)`${v} && ${d} <= ${o}`), e.pass(v);
      return;
    }
    s.items = !0;
    const p = t.name("valid");
    o === void 0 && a === 1 ? g(p, () => t.if(p, () => t.break())) : a === 0 ? (t.let(p, !0), o !== void 0 && t.if((0, ln._)`${n}.length > 0`, h)) : (t.let(p, !1), h()), e.result(p, () => e.reset());
    function h() {
      const v = t.name("_valid"), _ = t.let("count", 0);
      g(v, () => t.if(v, () => m(_)));
    }
    function g(v, _) {
      t.forRange("i", 0, d, (y) => {
        e.subschema({
          keyword: "contains",
          dataProp: y,
          dataPropType: al.Type.Num,
          compositeRule: !0
        }, v), _();
      });
    }
    function m(v) {
      t.code((0, ln._)`${v}++`), o === void 0 ? t.if((0, ln._)`${v} >= ${a}`, () => t.assign(p, !0).break()) : (t.if((0, ln._)`${v} > ${o}`, () => t.assign(p, !1).break()), a === 1 ? t.assign(p, !0) : t.if((0, ln._)`${v} >= ${a}`, () => t.assign(p, !0)));
    }
  }
};
Zg.default = NU;
var td = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.validateSchemaDeps = e.validatePropertyDeps = e.error = void 0;
  const t = pt, r = Pt, i = Mn();
  e.error = {
    message: ({ params: { property: c, depsCount: l, deps: d } }) => {
      const p = l === 1 ? "property" : "properties";
      return (0, t.str)`must have ${p} ${d} when property ${c} is present`;
    },
    params: ({ params: { property: c, depsCount: l, deps: d, missingProperty: p } }) => (0, t._)`{property: ${c},
    missingProperty: ${p},
    depsCount: ${l},
    deps: ${d}}`
    // TODO change to reference
  };
  const n = {
    keyword: "dependencies",
    type: "object",
    schemaType: "object",
    error: e.error,
    code(c) {
      const [l, d] = s(c);
      a(c, l), o(c, d);
    }
  };
  function s({ schema: c }) {
    const l = {}, d = {};
    for (const p in c) {
      if (p === "__proto__")
        continue;
      const h = Array.isArray(c[p]) ? l : d;
      h[p] = c[p];
    }
    return [l, d];
  }
  function a(c, l = c.schema) {
    const { gen: d, data: p, it: h } = c;
    if (Object.keys(l).length === 0)
      return;
    const g = d.let("missing");
    for (const m in l) {
      const v = l[m];
      if (v.length === 0)
        continue;
      const _ = (0, i.propertyInData)(d, p, m, h.opts.ownProperties);
      c.setParams({
        property: m,
        depsCount: v.length,
        deps: v.join(", ")
      }), h.allErrors ? d.if(_, () => {
        for (const y of v)
          (0, i.checkReportMissingProp)(c, y);
      }) : (d.if((0, t._)`${_} && (${(0, i.checkMissingProp)(c, v, g)})`), (0, i.reportMissingProp)(c, g), d.else());
    }
  }
  e.validatePropertyDeps = a;
  function o(c, l = c.schema) {
    const { gen: d, data: p, keyword: h, it: g } = c, m = d.name("valid");
    for (const v in l)
      (0, r.alwaysValidSchema)(g, l[v]) || (d.if(
        (0, i.propertyInData)(d, p, v, g.opts.ownProperties),
        () => {
          const _ = c.subschema({ keyword: h, schemaProp: v }, m);
          c.mergeValidEvaluated(_, m);
        },
        () => d.var(m, !0)
        // TODO var
      ), c.ok(m));
  }
  e.validateSchemaDeps = o, e.default = n;
})(td);
var zg = {};
Object.defineProperty(zg, "__esModule", { value: !0 });
const tP = pt, DU = Pt, LU = {
  message: "property name must be valid",
  params: ({ params: e }) => (0, tP._)`{propertyName: ${e.propertyName}}`
}, qU = {
  keyword: "propertyNames",
  type: "object",
  schemaType: ["object", "boolean"],
  error: LU,
  code(e) {
    const { gen: t, schema: r, data: i, it: n } = e;
    if ((0, DU.alwaysValidSchema)(n, r))
      return;
    const s = t.name("valid");
    t.forIn("key", i, (a) => {
      e.setParams({ propertyName: a }), e.subschema({
        keyword: "propertyNames",
        data: a,
        dataTypes: ["string"],
        propertyName: a,
        compositeRule: !0
      }, s), t.if((0, tP.not)(s), () => {
        e.error(!0), n.allErrors || t.break();
      });
    }), e.ok(s);
  }
};
zg.default = qU;
var rd = {};
Object.defineProperty(rd, "__esModule", { value: !0 });
const ol = Mn(), $n = pt, FU = Qr, ul = Pt, UU = {
  message: "must NOT have additional properties",
  params: ({ params: e }) => (0, $n._)`{additionalProperty: ${e.additionalProperty}}`
}, BU = {
  keyword: "additionalProperties",
  type: ["object"],
  schemaType: ["boolean", "object"],
  allowUndefined: !0,
  trackErrors: !0,
  error: UU,
  code(e) {
    const { gen: t, schema: r, parentSchema: i, data: n, errsCount: s, it: a } = e;
    if (!s)
      throw new Error("ajv implementation error");
    const { allErrors: o, opts: c } = a;
    if (a.props = !0, c.removeAdditional !== "all" && (0, ul.alwaysValidSchema)(a, r))
      return;
    const l = (0, ol.allSchemaProperties)(i.properties), d = (0, ol.allSchemaProperties)(i.patternProperties);
    p(), e.ok((0, $n._)`${s} === ${FU.default.errors}`);
    function p() {
      t.forIn("key", n, (_) => {
        !l.length && !d.length ? m(_) : t.if(h(_), () => m(_));
      });
    }
    function h(_) {
      let y;
      if (l.length > 8) {
        const w = (0, ul.schemaRefOrVal)(a, i.properties, "properties");
        y = (0, ol.isOwnProperty)(t, w, _);
      } else
        l.length ? y = (0, $n.or)(...l.map((w) => (0, $n._)`${_} === ${w}`)) : y = $n.nil;
      return d.length && (y = (0, $n.or)(y, ...d.map((w) => (0, $n._)`${(0, ol.usePattern)(e, w)}.test(${_})`))), (0, $n.not)(y);
    }
    function g(_) {
      t.code((0, $n._)`delete ${n}[${_}]`);
    }
    function m(_) {
      if (c.removeAdditional === "all" || c.removeAdditional && r === !1) {
        g(_);
        return;
      }
      if (r === !1) {
        e.setParams({ additionalProperty: _ }), e.error(), o || t.break();
        return;
      }
      if (typeof r == "object" && !(0, ul.alwaysValidSchema)(a, r)) {
        const y = t.name("valid");
        c.removeAdditional === "failing" ? (v(_, y, !1), t.if((0, $n.not)(y), () => {
          e.reset(), g(_);
        })) : (v(_, y), o || t.if((0, $n.not)(y), () => t.break()));
      }
    }
    function v(_, y, w) {
      const $ = {
        keyword: "additionalProperties",
        dataProp: _,
        dataPropType: ul.Type.Str
      };
      w === !1 && Object.assign($, {
        compositeRule: !0,
        createErrors: !1,
        allErrors: !1
      }), e.subschema($, y);
    }
  }
};
rd.default = BU;
var Wg = {};
Object.defineProperty(Wg, "__esModule", { value: !0 });
const VU = Bf(), Dw = Mn(), Uh = Pt, Lw = rd, ZU = {
  keyword: "properties",
  type: "object",
  schemaType: "object",
  code(e) {
    const { gen: t, schema: r, parentSchema: i, data: n, it: s } = e;
    s.opts.removeAdditional === "all" && i.additionalProperties === void 0 && Lw.default.code(new VU.KeywordCxt(s, Lw.default, "additionalProperties"));
    const a = (0, Dw.allSchemaProperties)(r);
    for (const p of a)
      s.definedProperties.add(p);
    s.opts.unevaluated && a.length && s.props !== !0 && (s.props = Uh.mergeEvaluated.props(t, (0, Uh.toHash)(a), s.props));
    const o = a.filter((p) => !(0, Uh.alwaysValidSchema)(s, r[p]));
    if (o.length === 0)
      return;
    const c = t.name("valid");
    for (const p of o)
      l(p) ? d(p) : (t.if((0, Dw.propertyInData)(t, n, p, s.opts.ownProperties)), d(p), s.allErrors || t.else().var(c, !0), t.endIf()), e.it.definedProperties.add(p), e.ok(c);
    function l(p) {
      return s.opts.useDefaults && !s.compositeRule && r[p].default !== void 0;
    }
    function d(p) {
      e.subschema({
        keyword: "properties",
        schemaProp: p,
        dataProp: p
      }, c);
    }
  }
};
Wg.default = ZU;
var Hg = {};
Object.defineProperty(Hg, "__esModule", { value: !0 });
const qw = Mn(), cl = pt, Fw = Pt, Uw = Pt, zU = {
  keyword: "patternProperties",
  type: "object",
  schemaType: "object",
  code(e) {
    const { gen: t, schema: r, data: i, parentSchema: n, it: s } = e, { opts: a } = s, o = (0, qw.allSchemaProperties)(r), c = o.filter((v) => (0, Fw.alwaysValidSchema)(s, r[v]));
    if (o.length === 0 || c.length === o.length && (!s.opts.unevaluated || s.props === !0))
      return;
    const l = a.strictSchema && !a.allowMatchingProperties && n.properties, d = t.name("valid");
    s.props !== !0 && !(s.props instanceof cl.Name) && (s.props = (0, Uw.evaluatedPropsToName)(t, s.props));
    const { props: p } = s;
    h();
    function h() {
      for (const v of o)
        l && g(v), s.allErrors ? m(v) : (t.var(d, !0), m(v), t.if(d));
    }
    function g(v) {
      for (const _ in l)
        new RegExp(v).test(_) && (0, Fw.checkStrictMode)(s, `property ${_} matches pattern ${v} (use allowMatchingProperties)`);
    }
    function m(v) {
      t.forIn("key", i, (_) => {
        t.if((0, cl._)`${(0, qw.usePattern)(e, v)}.test(${_})`, () => {
          const y = c.includes(v);
          y || e.subschema({
            keyword: "patternProperties",
            schemaProp: v,
            dataProp: _,
            dataPropType: Uw.Type.Str
          }, d), s.opts.unevaluated && p !== !0 ? t.assign((0, cl._)`${p}[${_}]`, !0) : !y && !s.allErrors && t.if((0, cl.not)(d), () => t.break());
        });
      });
    }
  }
};
Hg.default = zU;
var Gg = {};
Object.defineProperty(Gg, "__esModule", { value: !0 });
const WU = Pt, HU = {
  keyword: "not",
  schemaType: ["object", "boolean"],
  trackErrors: !0,
  code(e) {
    const { gen: t, schema: r, it: i } = e;
    if ((0, WU.alwaysValidSchema)(i, r)) {
      e.fail();
      return;
    }
    const n = t.name("valid");
    e.subschema({
      keyword: "not",
      compositeRule: !0,
      createErrors: !1,
      allErrors: !1
    }, n), e.failResult(n, () => e.reset(), () => e.error());
  },
  error: { message: "must NOT be valid" }
};
Gg.default = HU;
var Kg = {};
Object.defineProperty(Kg, "__esModule", { value: !0 });
const GU = Mn(), KU = {
  keyword: "anyOf",
  schemaType: "array",
  trackErrors: !0,
  code: GU.validateUnion,
  error: { message: "must match a schema in anyOf" }
};
Kg.default = KU;
var Yg = {};
Object.defineProperty(Yg, "__esModule", { value: !0 });
const Rl = pt, YU = Pt, JU = {
  message: "must match exactly one schema in oneOf",
  params: ({ params: e }) => (0, Rl._)`{passingSchemas: ${e.passing}}`
}, XU = {
  keyword: "oneOf",
  schemaType: "array",
  trackErrors: !0,
  error: JU,
  code(e) {
    const { gen: t, schema: r, parentSchema: i, it: n } = e;
    if (!Array.isArray(r))
      throw new Error("ajv implementation error");
    if (n.opts.discriminator && i.discriminator)
      return;
    const s = r, a = t.let("valid", !1), o = t.let("passing", null), c = t.name("_valid");
    e.setParams({ passing: o }), t.block(l), e.result(a, () => e.reset(), () => e.error(!0));
    function l() {
      s.forEach((d, p) => {
        let h;
        (0, YU.alwaysValidSchema)(n, d) ? t.var(c, !0) : h = e.subschema({
          keyword: "oneOf",
          schemaProp: p,
          compositeRule: !0
        }, c), p > 0 && t.if((0, Rl._)`${c} && ${a}`).assign(a, !1).assign(o, (0, Rl._)`[${o}, ${p}]`).else(), t.if(c, () => {
          t.assign(a, !0), t.assign(o, p), h && e.mergeEvaluated(h, Rl.Name);
        });
      });
    }
  }
};
Yg.default = XU;
var Jg = {};
Object.defineProperty(Jg, "__esModule", { value: !0 });
const QU = Pt, eB = {
  keyword: "allOf",
  schemaType: "array",
  code(e) {
    const { gen: t, schema: r, it: i } = e;
    if (!Array.isArray(r))
      throw new Error("ajv implementation error");
    const n = t.name("valid");
    r.forEach((s, a) => {
      if ((0, QU.alwaysValidSchema)(i, s))
        return;
      const o = e.subschema({ keyword: "allOf", schemaProp: a }, n);
      e.ok(n), e.mergeEvaluated(o);
    });
  }
};
Jg.default = eB;
var Xg = {};
Object.defineProperty(Xg, "__esModule", { value: !0 });
const ff = pt, rP = Pt, tB = {
  message: ({ params: e }) => (0, ff.str)`must match "${e.ifClause}" schema`,
  params: ({ params: e }) => (0, ff._)`{failingKeyword: ${e.ifClause}}`
}, rB = {
  keyword: "if",
  schemaType: ["object", "boolean"],
  trackErrors: !0,
  error: tB,
  code(e) {
    const { gen: t, parentSchema: r, it: i } = e;
    r.then === void 0 && r.else === void 0 && (0, rP.checkStrictMode)(i, '"if" without "then" and "else" is ignored');
    const n = Bw(i, "then"), s = Bw(i, "else");
    if (!n && !s)
      return;
    const a = t.let("valid", !0), o = t.name("_valid");
    if (c(), e.reset(), n && s) {
      const d = t.let("ifClause");
      e.setParams({ ifClause: d }), t.if(o, l("then", d), l("else", d));
    } else
      n ? t.if(o, l("then")) : t.if((0, ff.not)(o), l("else"));
    e.pass(a, () => e.error(!0));
    function c() {
      const d = e.subschema({
        keyword: "if",
        compositeRule: !0,
        createErrors: !1,
        allErrors: !1
      }, o);
      e.mergeEvaluated(d);
    }
    function l(d, p) {
      return () => {
        const h = e.subschema({ keyword: d }, o);
        t.assign(a, o), e.mergeValidEvaluated(h, a), p ? t.assign(p, (0, ff._)`${d}`) : e.setParams({ ifClause: d });
      };
    }
  }
};
function Bw(e, t) {
  const r = e.schema[t];
  return r !== void 0 && !(0, rP.alwaysValidSchema)(e, r);
}
Xg.default = rB;
var Qg = {};
Object.defineProperty(Qg, "__esModule", { value: !0 });
const nB = Pt, iB = {
  keyword: ["then", "else"],
  schemaType: ["object", "boolean"],
  code({ keyword: e, parentSchema: t, it: r }) {
    t.if === void 0 && (0, nB.checkStrictMode)(r, `"${e}" without "if" is ignored`);
  }
};
Qg.default = iB;
Object.defineProperty(ed, "__esModule", { value: !0 });
const sB = uo, aB = Bg, oB = co, uB = Vg, cB = Zg, lB = td, fB = zg, dB = rd, pB = Wg, hB = Hg, mB = Gg, yB = Kg, gB = Yg, vB = Jg, bB = Xg, _B = Qg;
function wB(e = !1) {
  const t = [
    // any
    mB.default,
    yB.default,
    gB.default,
    vB.default,
    bB.default,
    _B.default,
    // object
    fB.default,
    dB.default,
    lB.default,
    pB.default,
    hB.default
  ];
  return e ? t.push(aB.default, uB.default) : t.push(sB.default, oB.default), t.push(cB.default), t;
}
ed.default = wB;
var e0 = {}, lo = {};
Object.defineProperty(lo, "__esModule", { value: !0 });
lo.dynamicAnchor = void 0;
const Bh = pt, $B = Qr, Vw = Ir, EB = Qn, xB = {
  keyword: "$dynamicAnchor",
  schemaType: "string",
  code: (e) => nP(e, e.schema)
};
function nP(e, t) {
  const { gen: r, it: i } = e;
  i.schemaEnv.root.dynamicAnchors[t] = !0;
  const n = (0, Bh._)`${$B.default.dynamicAnchors}${(0, Bh.getProperty)(t)}`, s = i.errSchemaPath === "#" ? i.validateName : OB(e);
  r.if((0, Bh._)`!${n}`, () => r.assign(n, s));
}
lo.dynamicAnchor = nP;
function OB(e) {
  const { schemaEnv: t, schema: r, self: i } = e.it, { root: n, baseId: s, localRefs: a, meta: o } = t.root, { schemaId: c } = i.opts, l = new Vw.SchemaEnv({ schema: r, schemaId: c, root: n, baseId: s, localRefs: a, meta: o });
  return Vw.compileSchema.call(i, l), (0, EB.getValidate)(e, l);
}
lo.default = xB;
var fo = {};
Object.defineProperty(fo, "__esModule", { value: !0 });
fo.dynamicRef = void 0;
const Zw = pt, PB = Qr, zw = Qn, SB = {
  keyword: "$dynamicRef",
  schemaType: "string",
  code: (e) => iP(e, e.schema)
};
function iP(e, t) {
  const { gen: r, keyword: i, it: n } = e;
  if (t[0] !== "#")
    throw new Error(`"${i}" only supports hash fragment reference`);
  const s = t.slice(1);
  if (n.allErrors)
    a();
  else {
    const c = r.let("valid", !1);
    a(c), e.ok(c);
  }
  function a(c) {
    if (n.schemaEnv.root.dynamicAnchors[s]) {
      const l = r.let("_v", (0, Zw._)`${PB.default.dynamicAnchors}${(0, Zw.getProperty)(s)}`);
      r.if(l, o(l, c), o(n.validateName, c));
    } else
      o(n.validateName, c)();
  }
  function o(c, l) {
    return l ? () => r.block(() => {
      (0, zw.callRef)(e, c), r.let(l, !0);
    }) : () => (0, zw.callRef)(e, c);
  }
}
fo.dynamicRef = iP;
fo.default = SB;
var t0 = {};
Object.defineProperty(t0, "__esModule", { value: !0 });
const AB = lo, CB = Pt, RB = {
  keyword: "$recursiveAnchor",
  schemaType: "boolean",
  code(e) {
    e.schema ? (0, AB.dynamicAnchor)(e, "") : (0, CB.checkStrictMode)(e.it, "$recursiveAnchor: false is ignored");
  }
};
t0.default = RB;
var r0 = {};
Object.defineProperty(r0, "__esModule", { value: !0 });
const TB = fo, IB = {
  keyword: "$recursiveRef",
  schemaType: "string",
  code: (e) => (0, TB.dynamicRef)(e, e.schema)
};
r0.default = IB;
Object.defineProperty(e0, "__esModule", { value: !0 });
const jB = lo, kB = fo, MB = t0, NB = r0, DB = [jB.default, kB.default, MB.default, NB.default];
e0.default = DB;
var n0 = {}, i0 = {};
Object.defineProperty(i0, "__esModule", { value: !0 });
const Ww = td, LB = {
  keyword: "dependentRequired",
  type: "object",
  schemaType: "object",
  error: Ww.error,
  code: (e) => (0, Ww.validatePropertyDeps)(e)
};
i0.default = LB;
var s0 = {};
Object.defineProperty(s0, "__esModule", { value: !0 });
const qB = td, FB = {
  keyword: "dependentSchemas",
  type: "object",
  schemaType: "object",
  code: (e) => (0, qB.validateSchemaDeps)(e)
};
s0.default = FB;
var a0 = {};
Object.defineProperty(a0, "__esModule", { value: !0 });
const UB = Pt, BB = {
  keyword: ["maxContains", "minContains"],
  type: "array",
  schemaType: "number",
  code({ keyword: e, parentSchema: t, it: r }) {
    t.contains === void 0 && (0, UB.checkStrictMode)(r, `"${e}" without "contains" is ignored`);
  }
};
a0.default = BB;
Object.defineProperty(n0, "__esModule", { value: !0 });
const VB = i0, ZB = s0, zB = a0, WB = [VB.default, ZB.default, zB.default];
n0.default = WB;
var o0 = {}, u0 = {};
Object.defineProperty(u0, "__esModule", { value: !0 });
const Ki = pt, Hw = Pt, HB = Qr, GB = {
  message: "must NOT have unevaluated properties",
  params: ({ params: e }) => (0, Ki._)`{unevaluatedProperty: ${e.unevaluatedProperty}}`
}, KB = {
  keyword: "unevaluatedProperties",
  type: "object",
  schemaType: ["boolean", "object"],
  trackErrors: !0,
  error: GB,
  code(e) {
    const { gen: t, schema: r, data: i, errsCount: n, it: s } = e;
    if (!n)
      throw new Error("ajv implementation error");
    const { allErrors: a, props: o } = s;
    o instanceof Ki.Name ? t.if((0, Ki._)`${o} !== true`, () => t.forIn("key", i, (p) => t.if(l(o, p), () => c(p)))) : o !== !0 && t.forIn("key", i, (p) => o === void 0 ? c(p) : t.if(d(o, p), () => c(p))), s.props = !0, e.ok((0, Ki._)`${n} === ${HB.default.errors}`);
    function c(p) {
      if (r === !1) {
        e.setParams({ unevaluatedProperty: p }), e.error(), a || t.break();
        return;
      }
      if (!(0, Hw.alwaysValidSchema)(s, r)) {
        const h = t.name("valid");
        e.subschema({
          keyword: "unevaluatedProperties",
          dataProp: p,
          dataPropType: Hw.Type.Str
        }, h), a || t.if((0, Ki.not)(h), () => t.break());
      }
    }
    function l(p, h) {
      return (0, Ki._)`!${p} || !${p}[${h}]`;
    }
    function d(p, h) {
      const g = [];
      for (const m in p)
        p[m] === !0 && g.push((0, Ki._)`${h} !== ${m}`);
      return (0, Ki.and)(...g);
    }
  }
};
u0.default = KB;
var c0 = {};
Object.defineProperty(c0, "__esModule", { value: !0 });
const Ns = pt, Gw = Pt, YB = {
  message: ({ params: { len: e } }) => (0, Ns.str)`must NOT have more than ${e} items`,
  params: ({ params: { len: e } }) => (0, Ns._)`{limit: ${e}}`
}, JB = {
  keyword: "unevaluatedItems",
  type: "array",
  schemaType: ["boolean", "object"],
  error: YB,
  code(e) {
    const { gen: t, schema: r, data: i, it: n } = e, s = n.items || 0;
    if (s === !0)
      return;
    const a = t.const("len", (0, Ns._)`${i}.length`);
    if (r === !1)
      e.setParams({ len: s }), e.fail((0, Ns._)`${a} > ${s}`);
    else if (typeof r == "object" && !(0, Gw.alwaysValidSchema)(n, r)) {
      const c = t.var("valid", (0, Ns._)`${a} <= ${s}`);
      t.if((0, Ns.not)(c), () => o(c, s)), e.ok(c);
    }
    n.items = !0;
    function o(c, l) {
      t.forRange("i", l, a, (d) => {
        e.subschema({ keyword: "unevaluatedItems", dataProp: d, dataPropType: Gw.Type.Num }, c), n.allErrors || t.if((0, Ns.not)(c), () => t.break());
      });
    }
  }
};
c0.default = JB;
Object.defineProperty(o0, "__esModule", { value: !0 });
const XB = u0, QB = c0, e9 = [XB.default, QB.default];
o0.default = e9;
var nd = {}, l0 = {};
Object.defineProperty(l0, "__esModule", { value: !0 });
const Qt = pt, t9 = {
  message: ({ schemaCode: e }) => (0, Qt.str)`must match format "${e}"`,
  params: ({ schemaCode: e }) => (0, Qt._)`{format: ${e}}`
}, r9 = {
  keyword: "format",
  type: ["number", "string"],
  schemaType: "string",
  $data: !0,
  error: t9,
  code(e, t) {
    const { gen: r, data: i, $data: n, schema: s, schemaCode: a, it: o } = e, { opts: c, errSchemaPath: l, schemaEnv: d, self: p } = o;
    if (!c.validateFormats)
      return;
    n ? h() : g();
    function h() {
      const m = r.scopeValue("formats", {
        ref: p.formats,
        code: c.code.formats
      }), v = r.const("fDef", (0, Qt._)`${m}[${a}]`), _ = r.let("fType"), y = r.let("format");
      r.if((0, Qt._)`typeof ${v} == "object" && !(${v} instanceof RegExp)`, () => r.assign(_, (0, Qt._)`${v}.type || "string"`).assign(y, (0, Qt._)`${v}.validate`), () => r.assign(_, (0, Qt._)`"string"`).assign(y, v)), e.fail$data((0, Qt.or)(w(), $()));
      function w() {
        return c.strictSchema === !1 ? Qt.nil : (0, Qt._)`${a} && !${y}`;
      }
      function $() {
        const E = d.$async ? (0, Qt._)`(${v}.async ? await ${y}(${i}) : ${y}(${i}))` : (0, Qt._)`${y}(${i})`, S = (0, Qt._)`(typeof ${y} == "function" ? ${E} : ${y}.test(${i}))`;
        return (0, Qt._)`${y} && ${y} !== true && ${_} === ${t} && !${S}`;
      }
    }
    function g() {
      const m = p.formats[s];
      if (!m) {
        w();
        return;
      }
      if (m === !0)
        return;
      const [v, _, y] = $(m);
      v === t && e.pass(E());
      function w() {
        if (c.strictSchema === !1) {
          p.logger.warn(S());
          return;
        }
        throw new Error(S());
        function S() {
          return `unknown format "${s}" ignored in schema at path "${l}"`;
        }
      }
      function $(S) {
        const R = S instanceof RegExp ? (0, Qt.regexpCode)(S) : c.code.formats ? (0, Qt._)`${c.code.formats}${(0, Qt.getProperty)(s)}` : void 0, j = r.scopeValue("formats", { key: s, ref: S, code: R });
        return typeof S == "object" && !(S instanceof RegExp) ? [S.type || "string", S.validate, (0, Qt._)`${j}.validate`] : ["string", S, j];
      }
      function E() {
        if (typeof m == "object" && !(m instanceof RegExp) && m.async) {
          if (!d.$async)
            throw new Error("async format in sync schema");
          return (0, Qt._)`await ${y}(${i})`;
        }
        return typeof _ == "function" ? (0, Qt._)`${y}(${i})` : (0, Qt._)`${y}.test(${i})`;
      }
    }
  }
};
l0.default = r9;
Object.defineProperty(nd, "__esModule", { value: !0 });
const n9 = l0, i9 = [n9.default];
nd.default = i9;
var eo = {};
Object.defineProperty(eo, "__esModule", { value: !0 });
eo.contentVocabulary = eo.metadataVocabulary = void 0;
eo.metadataVocabulary = [
  "title",
  "description",
  "default",
  "deprecated",
  "readOnly",
  "writeOnly",
  "examples"
];
eo.contentVocabulary = [
  "contentMediaType",
  "contentEncoding",
  "contentSchema"
];
Object.defineProperty(Ng, "__esModule", { value: !0 });
const s9 = Dg, a9 = qg, o9 = ed, u9 = e0, c9 = n0, l9 = o0, f9 = nd, Kw = eo, d9 = [
  u9.default,
  s9.default,
  a9.default,
  (0, o9.default)(!0),
  f9.default,
  Kw.metadataVocabulary,
  Kw.contentVocabulary,
  c9.default,
  l9.default
];
Ng.default = d9;
var id = {}, sP = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DiscrError = void 0, function(t) {
    t.Tag = "tag", t.Mapping = "mapping";
  }(e.DiscrError || (e.DiscrError = {}));
})(sP);
Object.defineProperty(id, "__esModule", { value: !0 });
const ja = pt, Ty = sP, Yw = Ir, p9 = Pt, h9 = {
  message: ({ params: { discrError: e, tagName: t } }) => e === Ty.DiscrError.Tag ? `tag "${t}" must be string` : `value of tag "${t}" must be in oneOf`,
  params: ({ params: { discrError: e, tag: t, tagName: r } }) => (0, ja._)`{error: ${e}, tag: ${r}, tagValue: ${t}}`
}, m9 = {
  keyword: "discriminator",
  type: "object",
  schemaType: "object",
  error: h9,
  code(e) {
    const { gen: t, data: r, schema: i, parentSchema: n, it: s } = e, { oneOf: a } = n;
    if (!s.opts.discriminator)
      throw new Error("discriminator: requires discriminator option");
    const o = i.propertyName;
    if (typeof o != "string")
      throw new Error("discriminator: requires propertyName");
    if (i.mapping)
      throw new Error("discriminator: mapping is not supported");
    if (!a)
      throw new Error("discriminator: requires oneOf keyword");
    const c = t.let("valid", !1), l = t.const("tag", (0, ja._)`${r}${(0, ja.getProperty)(o)}`);
    t.if((0, ja._)`typeof ${l} == "string"`, () => d(), () => e.error(!1, { discrError: Ty.DiscrError.Tag, tag: l, tagName: o })), e.ok(c);
    function d() {
      const g = h();
      t.if(!1);
      for (const m in g)
        t.elseIf((0, ja._)`${l} === ${m}`), t.assign(c, p(g[m]));
      t.else(), e.error(!1, { discrError: Ty.DiscrError.Mapping, tag: l, tagName: o }), t.endIf();
    }
    function p(g) {
      const m = t.name("valid"), v = e.subschema({ keyword: "oneOf", schemaProp: g }, m);
      return e.mergeEvaluated(v, ja.Name), m;
    }
    function h() {
      var g;
      const m = {}, v = y(n);
      let _ = !0;
      for (let E = 0; E < a.length; E++) {
        let S = a[E];
        S != null && S.$ref && !(0, p9.schemaHasRulesButRef)(S, s.self.RULES) && (S = Yw.resolveRef.call(s.self, s.schemaEnv.root, s.baseId, S == null ? void 0 : S.$ref), S instanceof Yw.SchemaEnv && (S = S.schema));
        const R = (g = S == null ? void 0 : S.properties) === null || g === void 0 ? void 0 : g[o];
        if (typeof R != "object")
          throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${o}"`);
        _ = _ && (v || y(S)), w(R, E);
      }
      if (!_)
        throw new Error(`discriminator: "${o}" must be required`);
      return m;
      function y({ required: E }) {
        return Array.isArray(E) && E.includes(o);
      }
      function w(E, S) {
        if (E.const)
          $(E.const, S);
        else if (E.enum)
          for (const R of E.enum)
            $(R, S);
        else
          throw new Error(`discriminator: "properties/${o}" must have "const" or "enum"`);
      }
      function $(E, S) {
        if (typeof E != "string" || E in m)
          throw new Error(`discriminator: "${o}" values must be unique strings`);
        m[E] = S;
      }
    }
  }
};
id.default = m9;
var f0 = {};
const y9 = "https://json-schema.org/draft/2020-12/schema", g9 = "https://json-schema.org/draft/2020-12/schema", v9 = {
  "https://json-schema.org/draft/2020-12/vocab/core": !0,
  "https://json-schema.org/draft/2020-12/vocab/applicator": !0,
  "https://json-schema.org/draft/2020-12/vocab/unevaluated": !0,
  "https://json-schema.org/draft/2020-12/vocab/validation": !0,
  "https://json-schema.org/draft/2020-12/vocab/meta-data": !0,
  "https://json-schema.org/draft/2020-12/vocab/format-annotation": !0,
  "https://json-schema.org/draft/2020-12/vocab/content": !0
}, b9 = "meta", _9 = "Core and Validation specifications meta-schema", w9 = [
  {
    $ref: "meta/core"
  },
  {
    $ref: "meta/applicator"
  },
  {
    $ref: "meta/unevaluated"
  },
  {
    $ref: "meta/validation"
  },
  {
    $ref: "meta/meta-data"
  },
  {
    $ref: "meta/format-annotation"
  },
  {
    $ref: "meta/content"
  }
], $9 = [
  "object",
  "boolean"
], E9 = "This meta-schema also defines keywords that have appeared in previous drafts in order to prevent incompatible extensions as they remain in common use.", x9 = {
  definitions: {
    $comment: '"definitions" has been replaced by "$defs".',
    type: "object",
    additionalProperties: {
      $dynamicRef: "#meta"
    },
    deprecated: !0,
    default: {}
  },
  dependencies: {
    $comment: '"dependencies" has been split and replaced by "dependentSchemas" and "dependentRequired" in order to serve their differing semantics.',
    type: "object",
    additionalProperties: {
      anyOf: [
        {
          $dynamicRef: "#meta"
        },
        {
          $ref: "meta/validation#/$defs/stringArray"
        }
      ]
    },
    deprecated: !0,
    default: {}
  },
  $recursiveAnchor: {
    $comment: '"$recursiveAnchor" has been replaced by "$dynamicAnchor".',
    $ref: "meta/core#/$defs/anchorString",
    deprecated: !0
  },
  $recursiveRef: {
    $comment: '"$recursiveRef" has been replaced by "$dynamicRef".',
    $ref: "meta/core#/$defs/uriReferenceString",
    deprecated: !0
  }
}, O9 = {
  $schema: y9,
  $id: g9,
  $vocabulary: v9,
  $dynamicAnchor: b9,
  title: _9,
  allOf: w9,
  type: $9,
  $comment: E9,
  properties: x9
}, P9 = "https://json-schema.org/draft/2020-12/schema", S9 = "https://json-schema.org/draft/2020-12/meta/applicator", A9 = {
  "https://json-schema.org/draft/2020-12/vocab/applicator": !0
}, C9 = "meta", R9 = "Applicator vocabulary meta-schema", T9 = [
  "object",
  "boolean"
], I9 = {
  prefixItems: {
    $ref: "#/$defs/schemaArray"
  },
  items: {
    $dynamicRef: "#meta"
  },
  contains: {
    $dynamicRef: "#meta"
  },
  additionalProperties: {
    $dynamicRef: "#meta"
  },
  properties: {
    type: "object",
    additionalProperties: {
      $dynamicRef: "#meta"
    },
    default: {}
  },
  patternProperties: {
    type: "object",
    additionalProperties: {
      $dynamicRef: "#meta"
    },
    propertyNames: {
      format: "regex"
    },
    default: {}
  },
  dependentSchemas: {
    type: "object",
    additionalProperties: {
      $dynamicRef: "#meta"
    },
    default: {}
  },
  propertyNames: {
    $dynamicRef: "#meta"
  },
  if: {
    $dynamicRef: "#meta"
  },
  then: {
    $dynamicRef: "#meta"
  },
  else: {
    $dynamicRef: "#meta"
  },
  allOf: {
    $ref: "#/$defs/schemaArray"
  },
  anyOf: {
    $ref: "#/$defs/schemaArray"
  },
  oneOf: {
    $ref: "#/$defs/schemaArray"
  },
  not: {
    $dynamicRef: "#meta"
  }
}, j9 = {
  schemaArray: {
    type: "array",
    minItems: 1,
    items: {
      $dynamicRef: "#meta"
    }
  }
}, k9 = {
  $schema: P9,
  $id: S9,
  $vocabulary: A9,
  $dynamicAnchor: C9,
  title: R9,
  type: T9,
  properties: I9,
  $defs: j9
}, M9 = "https://json-schema.org/draft/2020-12/schema", N9 = "https://json-schema.org/draft/2020-12/meta/unevaluated", D9 = {
  "https://json-schema.org/draft/2020-12/vocab/unevaluated": !0
}, L9 = "meta", q9 = "Unevaluated applicator vocabulary meta-schema", F9 = [
  "object",
  "boolean"
], U9 = {
  unevaluatedItems: {
    $dynamicRef: "#meta"
  },
  unevaluatedProperties: {
    $dynamicRef: "#meta"
  }
}, B9 = {
  $schema: M9,
  $id: N9,
  $vocabulary: D9,
  $dynamicAnchor: L9,
  title: q9,
  type: F9,
  properties: U9
}, V9 = "https://json-schema.org/draft/2020-12/schema", Z9 = "https://json-schema.org/draft/2020-12/meta/content", z9 = {
  "https://json-schema.org/draft/2020-12/vocab/content": !0
}, W9 = "meta", H9 = "Content vocabulary meta-schema", G9 = [
  "object",
  "boolean"
], K9 = {
  contentEncoding: {
    type: "string"
  },
  contentMediaType: {
    type: "string"
  },
  contentSchema: {
    $dynamicRef: "#meta"
  }
}, Y9 = {
  $schema: V9,
  $id: Z9,
  $vocabulary: z9,
  $dynamicAnchor: W9,
  title: H9,
  type: G9,
  properties: K9
}, J9 = "https://json-schema.org/draft/2020-12/schema", X9 = "https://json-schema.org/draft/2020-12/meta/core", Q9 = {
  "https://json-schema.org/draft/2020-12/vocab/core": !0
}, e7 = "meta", t7 = "Core vocabulary meta-schema", r7 = [
  "object",
  "boolean"
], n7 = {
  $id: {
    $ref: "#/$defs/uriReferenceString",
    $comment: "Non-empty fragments not allowed.",
    pattern: "^[^#]*#?$"
  },
  $schema: {
    $ref: "#/$defs/uriString"
  },
  $ref: {
    $ref: "#/$defs/uriReferenceString"
  },
  $anchor: {
    $ref: "#/$defs/anchorString"
  },
  $dynamicRef: {
    $ref: "#/$defs/uriReferenceString"
  },
  $dynamicAnchor: {
    $ref: "#/$defs/anchorString"
  },
  $vocabulary: {
    type: "object",
    propertyNames: {
      $ref: "#/$defs/uriString"
    },
    additionalProperties: {
      type: "boolean"
    }
  },
  $comment: {
    type: "string"
  },
  $defs: {
    type: "object",
    additionalProperties: {
      $dynamicRef: "#meta"
    }
  }
}, i7 = {
  anchorString: {
    type: "string",
    pattern: "^[A-Za-z_][-A-Za-z0-9._]*$"
  },
  uriString: {
    type: "string",
    format: "uri"
  },
  uriReferenceString: {
    type: "string",
    format: "uri-reference"
  }
}, s7 = {
  $schema: J9,
  $id: X9,
  $vocabulary: Q9,
  $dynamicAnchor: e7,
  title: t7,
  type: r7,
  properties: n7,
  $defs: i7
}, a7 = "https://json-schema.org/draft/2020-12/schema", o7 = "https://json-schema.org/draft/2020-12/meta/format-annotation", u7 = {
  "https://json-schema.org/draft/2020-12/vocab/format-annotation": !0
}, c7 = "meta", l7 = "Format vocabulary meta-schema for annotation results", f7 = [
  "object",
  "boolean"
], d7 = {
  format: {
    type: "string"
  }
}, p7 = {
  $schema: a7,
  $id: o7,
  $vocabulary: u7,
  $dynamicAnchor: c7,
  title: l7,
  type: f7,
  properties: d7
}, h7 = "https://json-schema.org/draft/2020-12/schema", m7 = "https://json-schema.org/draft/2020-12/meta/meta-data", y7 = {
  "https://json-schema.org/draft/2020-12/vocab/meta-data": !0
}, g7 = "meta", v7 = "Meta-data vocabulary meta-schema", b7 = [
  "object",
  "boolean"
], _7 = {
  title: {
    type: "string"
  },
  description: {
    type: "string"
  },
  default: !0,
  deprecated: {
    type: "boolean",
    default: !1
  },
  readOnly: {
    type: "boolean",
    default: !1
  },
  writeOnly: {
    type: "boolean",
    default: !1
  },
  examples: {
    type: "array",
    items: !0
  }
}, w7 = {
  $schema: h7,
  $id: m7,
  $vocabulary: y7,
  $dynamicAnchor: g7,
  title: v7,
  type: b7,
  properties: _7
}, $7 = "https://json-schema.org/draft/2020-12/schema", E7 = "https://json-schema.org/draft/2020-12/meta/validation", x7 = {
  "https://json-schema.org/draft/2020-12/vocab/validation": !0
}, O7 = "meta", P7 = "Validation vocabulary meta-schema", S7 = [
  "object",
  "boolean"
], A7 = {
  type: {
    anyOf: [
      {
        $ref: "#/$defs/simpleTypes"
      },
      {
        type: "array",
        items: {
          $ref: "#/$defs/simpleTypes"
        },
        minItems: 1,
        uniqueItems: !0
      }
    ]
  },
  const: !0,
  enum: {
    type: "array",
    items: !0
  },
  multipleOf: {
    type: "number",
    exclusiveMinimum: 0
  },
  maximum: {
    type: "number"
  },
  exclusiveMaximum: {
    type: "number"
  },
  minimum: {
    type: "number"
  },
  exclusiveMinimum: {
    type: "number"
  },
  maxLength: {
    $ref: "#/$defs/nonNegativeInteger"
  },
  minLength: {
    $ref: "#/$defs/nonNegativeIntegerDefault0"
  },
  pattern: {
    type: "string",
    format: "regex"
  },
  maxItems: {
    $ref: "#/$defs/nonNegativeInteger"
  },
  minItems: {
    $ref: "#/$defs/nonNegativeIntegerDefault0"
  },
  uniqueItems: {
    type: "boolean",
    default: !1
  },
  maxContains: {
    $ref: "#/$defs/nonNegativeInteger"
  },
  minContains: {
    $ref: "#/$defs/nonNegativeInteger",
    default: 1
  },
  maxProperties: {
    $ref: "#/$defs/nonNegativeInteger"
  },
  minProperties: {
    $ref: "#/$defs/nonNegativeIntegerDefault0"
  },
  required: {
    $ref: "#/$defs/stringArray"
  },
  dependentRequired: {
    type: "object",
    additionalProperties: {
      $ref: "#/$defs/stringArray"
    }
  }
}, C7 = {
  nonNegativeInteger: {
    type: "integer",
    minimum: 0
  },
  nonNegativeIntegerDefault0: {
    $ref: "#/$defs/nonNegativeInteger",
    default: 0
  },
  simpleTypes: {
    enum: [
      "array",
      "boolean",
      "integer",
      "null",
      "number",
      "object",
      "string"
    ]
  },
  stringArray: {
    type: "array",
    items: {
      type: "string"
    },
    uniqueItems: !0,
    default: []
  }
}, R7 = {
  $schema: $7,
  $id: E7,
  $vocabulary: x7,
  $dynamicAnchor: O7,
  title: P7,
  type: S7,
  properties: A7,
  $defs: C7
};
Object.defineProperty(f0, "__esModule", { value: !0 });
const T7 = O9, I7 = k9, j7 = B9, k7 = Y9, M7 = s7, N7 = p7, D7 = w7, L7 = R7, q7 = ["/properties"];
function F7(e) {
  return [
    T7,
    I7,
    j7,
    k7,
    M7,
    t(this, N7),
    D7,
    t(this, L7)
  ].forEach((r) => this.addMetaSchema(r, void 0, !1)), this;
  function t(r, i) {
    return e ? r.$dataMetaSchema(i, q7) : i;
  }
}
f0.default = F7;
(function(e, t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.MissingRefError = t.ValidationError = t.CodeGen = t.Name = t.nil = t.stringify = t.str = t._ = t.KeywordCxt = void 0;
  const r = za, i = Ng, n = id, s = f0, a = "https://json-schema.org/draft/2020-12/schema";
  class o extends r.default {
    constructor(g = {}) {
      super({
        ...g,
        dynamicRef: !0,
        next: !0,
        unevaluated: !0
      });
    }
    _addVocabularies() {
      super._addVocabularies(), i.default.forEach((g) => this.addVocabulary(g)), this.opts.discriminator && this.addKeyword(n.default);
    }
    _addDefaultMetaSchema() {
      super._addDefaultMetaSchema();
      const { $data: g, meta: m } = this.opts;
      m && (s.default.call(this, g), this.refs["http://json-schema.org/schema"] = a);
    }
    defaultMeta() {
      return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(a) ? a : void 0);
    }
  }
  e.exports = t = o, Object.defineProperty(t, "__esModule", { value: !0 }), t.default = o;
  var c = Bf();
  Object.defineProperty(t, "KeywordCxt", { enumerable: !0, get: function() {
    return c.KeywordCxt;
  } });
  var l = pt;
  Object.defineProperty(t, "_", { enumerable: !0, get: function() {
    return l._;
  } }), Object.defineProperty(t, "str", { enumerable: !0, get: function() {
    return l.str;
  } }), Object.defineProperty(t, "stringify", { enumerable: !0, get: function() {
    return l.stringify;
  } }), Object.defineProperty(t, "nil", { enumerable: !0, get: function() {
    return l.nil;
  } }), Object.defineProperty(t, "Name", { enumerable: !0, get: function() {
    return l.Name;
  } }), Object.defineProperty(t, "CodeGen", { enumerable: !0, get: function() {
    return l.CodeGen;
  } });
  var d = Ju;
  Object.defineProperty(t, "ValidationError", { enumerable: !0, get: function() {
    return d.default;
  } });
  var p = Xu;
  Object.defineProperty(t, "MissingRefError", { enumerable: !0, get: function() {
    return p.default;
  } });
})(Oy, Oy.exports);
var U7 = Oy.exports, Iy = { exports: {} }, d0 = {}, p0 = {};
Object.defineProperty(p0, "__esModule", { value: !0 });
const B7 = Qn, V7 = [
  "$schema",
  "id",
  "$defs",
  { keyword: "$comment" },
  "definitions",
  B7.default
];
p0.default = V7;
var h0 = {}, m0 = {};
Object.defineProperty(m0, "__esModule", { value: !0 });
const jy = za, Z7 = pt, Gi = Z7.operators, ky = {
  maximum: {
    exclusive: "exclusiveMaximum",
    ops: [
      { okStr: "<=", ok: Gi.LTE, fail: Gi.GT },
      { okStr: "<", ok: Gi.LT, fail: Gi.GTE }
    ]
  },
  minimum: {
    exclusive: "exclusiveMinimum",
    ops: [
      { okStr: ">=", ok: Gi.GTE, fail: Gi.LT },
      { okStr: ">", ok: Gi.GT, fail: Gi.LTE }
    ]
  }
}, z7 = {
  message: (e) => jy.str`must be ${My(e).okStr} ${e.schemaCode}`,
  params: (e) => jy._`{comparison: ${My(e).okStr}, limit: ${e.schemaCode}}`
}, W7 = {
  keyword: Object.keys(ky),
  type: "number",
  schemaType: "number",
  $data: !0,
  error: z7,
  code(e) {
    const { data: t, schemaCode: r } = e;
    e.fail$data(jy._`${t} ${My(e).fail} ${r} || isNaN(${t})`);
  }
};
function My(e) {
  var t;
  const r = e.keyword, i = !((t = e.parentSchema) === null || t === void 0) && t[ky[r].exclusive] ? 1 : 0;
  return ky[r].ops[i];
}
m0.default = W7;
var y0 = {};
Object.defineProperty(y0, "__esModule", { value: !0 });
const Jw = {
  exclusiveMaximum: "maximum",
  exclusiveMinimum: "minimum"
}, H7 = {
  keyword: Object.keys(Jw),
  type: "number",
  schemaType: "boolean",
  code({ keyword: e, parentSchema: t }) {
    const r = Jw[e];
    if (t[r] === void 0)
      throw new Error(`${e} can only be used with ${r}`);
  }
};
y0.default = H7;
Object.defineProperty(h0, "__esModule", { value: !0 });
const G7 = m0, K7 = y0, Y7 = zf, J7 = Wf, X7 = Hf, Q7 = Gf, eV = Kf, tV = Yf, rV = Jf, nV = Xf, iV = Qf, sV = [
  // number
  G7.default,
  K7.default,
  Y7.default,
  // string
  J7.default,
  X7.default,
  // object
  Q7.default,
  eV.default,
  // array
  tV.default,
  rV.default,
  // any
  { keyword: "type", schemaType: ["string", "array"] },
  { keyword: "nullable", schemaType: "boolean" },
  nV.default,
  iV.default
];
h0.default = sV;
Object.defineProperty(d0, "__esModule", { value: !0 });
const aV = p0, oV = h0, uV = ed, cV = nd, lV = ["title", "description", "default"], fV = [
  aV.default,
  oV.default,
  uV.default(),
  cV.default,
  lV
];
d0.default = fV;
const dV = "http://json-schema.org/draft-04/schema#", pV = "http://json-schema.org/draft-04/schema#", hV = "Core schema meta-schema", mV = {
  schemaArray: {
    type: "array",
    minItems: 1,
    items: {
      $ref: "#"
    }
  },
  positiveInteger: {
    type: "integer",
    minimum: 0
  },
  positiveIntegerDefault0: {
    allOf: [
      {
        $ref: "#/definitions/positiveInteger"
      },
      {
        default: 0
      }
    ]
  },
  simpleTypes: {
    enum: [
      "array",
      "boolean",
      "integer",
      "null",
      "number",
      "object",
      "string"
    ]
  },
  stringArray: {
    type: "array",
    items: {
      type: "string"
    },
    minItems: 1,
    uniqueItems: !0
  }
}, yV = "object", gV = {
  id: {
    type: "string",
    format: "uri"
  },
  $schema: {
    type: "string",
    format: "uri"
  },
  title: {
    type: "string"
  },
  description: {
    type: "string"
  },
  default: {},
  multipleOf: {
    type: "number",
    minimum: 0,
    exclusiveMinimum: !0
  },
  maximum: {
    type: "number"
  },
  exclusiveMaximum: {
    type: "boolean",
    default: !1
  },
  minimum: {
    type: "number"
  },
  exclusiveMinimum: {
    type: "boolean",
    default: !1
  },
  maxLength: {
    $ref: "#/definitions/positiveInteger"
  },
  minLength: {
    $ref: "#/definitions/positiveIntegerDefault0"
  },
  pattern: {
    type: "string",
    format: "regex"
  },
  additionalItems: {
    anyOf: [
      {
        type: "boolean"
      },
      {
        $ref: "#"
      }
    ],
    default: {}
  },
  items: {
    anyOf: [
      {
        $ref: "#"
      },
      {
        $ref: "#/definitions/schemaArray"
      }
    ],
    default: {}
  },
  maxItems: {
    $ref: "#/definitions/positiveInteger"
  },
  minItems: {
    $ref: "#/definitions/positiveIntegerDefault0"
  },
  uniqueItems: {
    type: "boolean",
    default: !1
  },
  maxProperties: {
    $ref: "#/definitions/positiveInteger"
  },
  minProperties: {
    $ref: "#/definitions/positiveIntegerDefault0"
  },
  required: {
    $ref: "#/definitions/stringArray"
  },
  additionalProperties: {
    anyOf: [
      {
        type: "boolean"
      },
      {
        $ref: "#"
      }
    ],
    default: {}
  },
  definitions: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    default: {}
  },
  properties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    default: {}
  },
  patternProperties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    default: {}
  },
  dependencies: {
    type: "object",
    additionalProperties: {
      anyOf: [
        {
          $ref: "#"
        },
        {
          $ref: "#/definitions/stringArray"
        }
      ]
    }
  },
  enum: {
    type: "array",
    minItems: 1,
    uniqueItems: !0
  },
  type: {
    anyOf: [
      {
        $ref: "#/definitions/simpleTypes"
      },
      {
        type: "array",
        items: {
          $ref: "#/definitions/simpleTypes"
        },
        minItems: 1,
        uniqueItems: !0
      }
    ]
  },
  allOf: {
    $ref: "#/definitions/schemaArray"
  },
  anyOf: {
    $ref: "#/definitions/schemaArray"
  },
  oneOf: {
    $ref: "#/definitions/schemaArray"
  },
  not: {
    $ref: "#"
  }
}, vV = {
  exclusiveMaximum: [
    "maximum"
  ],
  exclusiveMinimum: [
    "minimum"
  ]
}, bV = {
  id: dV,
  $schema: pV,
  description: hV,
  definitions: mV,
  type: yV,
  properties: gV,
  dependencies: vV,
  default: {}
};
(function(e, t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.CodeGen = t.Name = t.nil = t.stringify = t.str = t._ = t.KeywordCxt = void 0;
  const r = za, i = d0, n = id, s = bV, a = ["/properties"], o = "http://json-schema.org/draft-04/schema";
  class c extends r.default {
    constructor(h = {}) {
      super({
        ...h,
        schemaId: "id"
      });
    }
    _addVocabularies() {
      super._addVocabularies(), i.default.forEach((h) => this.addVocabulary(h)), this.opts.discriminator && this.addKeyword(n.default);
    }
    _addDefaultMetaSchema() {
      if (super._addDefaultMetaSchema(), !this.opts.meta)
        return;
      const h = this.opts.$data ? this.$dataMetaSchema(s, a) : s;
      this.addMetaSchema(h, o, !1), this.refs["http://json-schema.org/schema"] = o;
    }
    defaultMeta() {
      return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(o) ? o : void 0);
    }
  }
  e.exports = t = c, Object.defineProperty(t, "__esModule", { value: !0 }), t.default = c;
  var l = za;
  Object.defineProperty(t, "KeywordCxt", { enumerable: !0, get: function() {
    return l.KeywordCxt;
  } });
  var d = za;
  Object.defineProperty(t, "_", { enumerable: !0, get: function() {
    return d._;
  } }), Object.defineProperty(t, "str", { enumerable: !0, get: function() {
    return d.str;
  } }), Object.defineProperty(t, "stringify", { enumerable: !0, get: function() {
    return d.stringify;
  } }), Object.defineProperty(t, "nil", { enumerable: !0, get: function() {
    return d.nil;
  } }), Object.defineProperty(t, "Name", { enumerable: !0, get: function() {
    return d.Name;
  } }), Object.defineProperty(t, "CodeGen", { enumerable: !0, get: function() {
    return d.CodeGen;
  } });
})(Iy, Iy.exports);
var _V = Iy.exports;
const { openapi: Vh } = Sq, { ono: wV } = In, $V = z8, EV = U7, xV = _V, { getSpecificationName: OV } = ni, PV = 20, SV = 5e6;
var aP = AV;
function AV(e, t) {
  let r, i;
  if (e.swagger)
    i = Vh.v2, r = Zh();
  else if (e.openapi.startsWith("3.1")) {
    i = Vh.v31;
    const s = i.$defs.schema;
    delete s.$dynamicAnchor, i.$defs.components.properties.schemas.additionalProperties = s, i.$defs.header.dependentSchemas.schema.properties.schema = s, i.$defs["media-type"].properties.schema = s, i.$defs.parameter.properties.schema = s, r = Zh(!1);
  } else
    i = Vh.v3, r = Zh();
  if (!r.validate(i, e)) {
    const s = r.errors;
    let a = 0, o = CV(s);
    if (o.length >= PV)
      try {
        JSON.stringify(e).length >= SV && (a = o.length - 20, o = o.slice(0, 20));
      } catch {
      }
    let c = `${OV(e)} schema validation failed.
`;
    throw c += `
`, c += $V(i, e, o, {
      colorize: t.validate.colorizeErrors,
      indent: 2
    }), a && (c += `

`, c += `Plus an additional ${a} errors. Please resolve the above and re-run validation to see more.`), wV.syntax(s, { details: s }, c);
  }
}
function Zh(e = !0) {
  const t = {
    allErrors: !0,
    strict: !1,
    validateFormats: !1
  };
  return e ? new xV(t) : new EV(t);
}
function CV(e) {
  const t = /* @__PURE__ */ new Map();
  return e.forEach((r) => {
    if (["must have required property '$ref'", "must match exactly one schema in oneOf"].includes(r.message))
      return;
    if (t.size) {
      if (t.has(r.instancePath))
        return;
    } else {
      t.set(r.instancePath, r);
      return;
    }
    let i = !0;
    t.forEach((n) => {
      n.instancePath.includes(r.instancePath) && (i = !1);
    }), i && t.set(r.instancePath, r);
  }), t.size ? [...t.values()] : e;
}
var oP = [
  "get",
  "put",
  "post",
  "delete",
  "options",
  "head",
  "patch"
];
const RV = oP, { ono: Ei } = In, TV = ni;
var IV = jV;
function jV(e) {
  const t = [];
  Object.keys(e.paths || {}).forEach((r) => {
    const i = e.paths[r], n = `/paths${r}`;
    i && r.indexOf("/") === 0 && kV(e, i, n, t);
  }), e.openapi.startsWith("3.0") && e.components && Object.keys(e.components).forEach((r) => {
    Object.keys(e.components[r]).forEach((i) => {
      const n = `/components/${r}/${i}`;
      if (!/^[a-zA-Z0-9.\-_]+$/.test(i))
        throw Ei.syntax(
          `Validation failed. ${n} has an invalid name. Component names should match against: /^[a-zA-Z0-9.-_]+$/`
        );
    });
  });
}
function kV(e, t, r, i) {
  [...RV, "trace"].forEach((n) => {
    const s = t[n], a = `${r}/${n}`;
    if (s) {
      const o = s.operationId;
      if (o)
        if (i.indexOf(o) === -1)
          i.push(o);
        else
          throw Ei.syntax(`Validation failed. Duplicate operation id '${o}'`);
      MV(e, t, r, s, a), Object.keys(s.responses || {}).forEach((c) => {
        const l = s.responses[c], d = `${a}/responses/${c}`;
        LV(c, l || {}, d);
      });
    }
  });
}
function MV(e, t, r, i, n) {
  const s = t.parameters || [], a = i.parameters || [];
  try {
    Xw(s);
  } catch (c) {
    throw Ei.syntax(c, `Validation failed. ${r} has duplicate parameters`);
  }
  try {
    Xw(a);
  } catch (c) {
    throw Ei.syntax(c, `Validation failed. ${n} has duplicate parameters`);
  }
  const o = s.reduce((c, l) => (c.some((p) => p.in === l.in && p.name === l.name) || c.push(l), c), a.slice());
  NV(o, r, n), DV(o, e, i, n);
}
function NV(e, t, r) {
  const i = [...new Set(t.match(TV.swaggerParamRegExp) || [])];
  if (e.filter((n) => n.in === "path").forEach((n) => {
    if (n.required !== !0)
      throw Ei.syntax(
        `Validation failed. Path parameters cannot be optional. Set required=true for the "${n.name}" parameter at ${r}`
      );
    const s = i.indexOf(`{${n.name}}`);
    if (s === -1)
      throw Ei.syntax(
        `Validation failed. ${r} has a path parameter named "${n.name}", but there is no corresponding {${n.name}} in the path string`
      );
    i.splice(s, 1);
  }), i.length > 0)
    throw Ei.syntax(`Validation failed. ${r} is missing path parameter(s) for ${i}`);
}
function DV(e, t, r, i) {
  e.forEach((n) => {
    if (!n.schema && n.content)
      return;
    const s = `${i}/parameters/${n.name}`;
    Tl(n.schema, s);
  });
}
function Xw(e) {
  for (let t = 0; t < e.length - 1; t++) {
    const r = e[t];
    for (let i = t + 1; i < e.length; i++) {
      const n = e[i];
      if (r.name === n.name && r.in === n.in)
        throw Ei.syntax(`Validation failed. Found multiple ${r.in} parameters named "${r.name}"`);
    }
  }
}
function LV(e, t, r) {
  Object.keys(t.headers || {}).forEach((i) => {
    const n = t.headers[i], s = `${r}/headers/${i}`;
    n.schema ? Tl(n.schema, s) : n.content && Object.keys(n.content).forEach((a) => {
      n.content[a].schema && Tl(n.content[a].schema || {}, `${s}/content/${a}/schema`);
    });
  }), t.content && Object.keys(t.content).forEach((i) => {
    t.content[i].schema && Tl(t.content[i].schema || {}, `${r}/content/${i}/schema`);
  });
}
function Tl(e, t) {
  if (e.type === "array" && !e.items)
    throw Ei.syntax(`Validation failed. ${t} is an array, so it must include an "items" schema`);
}
const qV = oP, { ono: yr } = In, FV = ni, Ny = ["array", "boolean", "integer", "number", "string"], uP = ["array", "boolean", "integer", "number", "string", "object", "null", void 0];
var UV = BV;
function BV(e) {
  const t = [];
  Object.keys(e.paths || {}).forEach((r) => {
    const i = e.paths[r], n = `/paths${r}`;
    i && r.indexOf("/") === 0 && VV(e, i, n, t);
  }), Object.keys(e.definitions || {}).forEach((r) => {
    const i = e.definitions[r], n = `/definitions/${r}`;
    if (!/^[a-zA-Z0-9.\-_]+$/.test(r))
      throw yr.syntax(
        `Validation failed. ${n} has an invalid name. Definition names should match against: /^[a-zA-Z0-9.-_]+$/`
      );
    cP(i, n);
  });
}
function VV(e, t, r, i) {
  qV.forEach((n) => {
    const s = t[n], a = `${r}/${n}`;
    if (s) {
      const o = s.operationId;
      if (o)
        if (i.indexOf(o) === -1)
          i.push(o);
        else
          throw yr.syntax(`Validation failed. Duplicate operation id '${o}'`);
      ZV(e, t, r, s, a), Object.keys(s.responses || {}).forEach((c) => {
        const l = s.responses[c], d = `${a}/responses/${c}`;
        GV(c, l || {}, d);
      });
    }
  });
}
function ZV(e, t, r, i, n) {
  const s = t.parameters || [], a = i.parameters || [];
  try {
    Qw(s);
  } catch (c) {
    throw yr.syntax(c, `Validation failed. ${r} has duplicate parameters`);
  }
  try {
    Qw(a);
  } catch (c) {
    throw yr.syntax(c, `Validation failed. ${n} has duplicate parameters`);
  }
  const o = s.reduce((c, l) => (c.some((p) => p.in === l.in && p.name === l.name) || c.push(l), c), a.slice());
  zV(o, n), WV(o, r, n), HV(o, e, i, n);
}
function zV(e, t) {
  const r = e.filter((n) => n.in === "body"), i = e.filter((n) => n.in === "formData");
  if (r.length > 1)
    throw yr.syntax(
      `Validation failed. ${t} has ${r.length} body parameters. Only one is allowed.`
    );
  if (r.length > 0 && i.length > 0)
    throw yr.syntax(
      `Validation failed. ${t} has body parameters and formData parameters. Only one or the other is allowed.`
    );
}
function WV(e, t, r) {
  const i = t.match(FV.swaggerParamRegExp) || [];
  for (let n = 0; n < i.length; n++)
    for (let s = n + 1; s < i.length; s++)
      if (i[n] === i[s])
        throw yr.syntax(`Validation failed. ${r} has multiple path placeholders named ${i[n]}`);
  if (e.filter((n) => n.in === "path").forEach((n) => {
    if (n.required !== !0)
      throw yr.syntax(
        `Validation failed. Path parameters cannot be optional. Set required=true for the "${n.name}" parameter at ${r}`
      );
    const s = i.indexOf(`{${n.name}}`);
    if (s === -1)
      throw yr.syntax(
        `Validation failed. ${r} has a path parameter named "${n.name}", but there is no corresponding {${n.name}} in the path string`
      );
    i.splice(s, 1);
  }), i.length > 0)
    throw yr.syntax(`Validation failed. ${r} is missing path parameter(s) for ${i}`);
}
function HV(e, t, r, i) {
  e.forEach((n) => {
    const s = `${i}/parameters/${n.name}`;
    let a, o;
    switch (n.in) {
      case "body":
        a = n.schema, o = uP;
        break;
      case "formData":
        a = n, o = Ny.concat("file");
        break;
      default:
        a = n, o = Ny;
    }
    if (Dy(a, s, o), cP(a, s), a.type === "file") {
      const c = /multipart\/(.*\+)?form-data/, l = /application\/(.*\+)?x-www-form-urlencoded/;
      if (!(r.consumes || t.consumes || []).some((h) => c.test(h) || l.test(h)))
        throw yr.syntax(
          `Validation failed. ${i} has a file parameter, so it must consume multipart/form-data or application/x-www-form-urlencoded`
        );
    }
  });
}
function Qw(e) {
  for (let t = 0; t < e.length - 1; t++) {
    const r = e[t];
    for (let i = t + 1; i < e.length; i++) {
      const n = e[i];
      if (r.name === n.name && r.in === n.in)
        throw yr.syntax(`Validation failed. Found multiple ${r.in} parameters named "${r.name}"`);
    }
  }
}
function GV(e, t, r) {
  if (e !== "default" && (e < 100 || e > 599))
    throw yr.syntax(`Validation failed. ${r} has an invalid response code (${e})`);
  if (Object.keys(t.headers || {}).forEach((i) => {
    const n = t.headers[i], s = `${r}/headers/${i}`;
    Dy(n, s, Ny);
  }), t.schema) {
    const i = uP.concat("file");
    if (i.indexOf(t.schema.type) === -1)
      throw yr.syntax(
        `Validation failed. ${r} has an invalid response schema type (${t.schema.type})`
      );
    Dy(t.schema, `${r}/schema`, i);
  }
}
function Dy(e, t, r) {
  if (r.indexOf(e.type) === -1)
    throw yr.syntax(`Validation failed. ${t} has an invalid type (${e.type})`);
  if (e.type === "array" && !e.items)
    throw yr.syntax(`Validation failed. ${t} is an array, so it must include an "items" schema`);
}
function cP(e, t) {
  function r(i, n) {
    i.properties && Object.keys(i.properties).forEach((s) => {
      i.properties.hasOwnProperty(s) && (n[s] = i.properties[s]);
    }), i.allOf && i.allOf.forEach((s) => {
      r(s, n);
    });
  }
  if (e.required && Array.isArray(e.required)) {
    const i = {};
    r(e, i), e.required.forEach((n) => {
      if (!i[n])
        throw yr.syntax(
          `Validation failed. Property '${n}' listed as required but does not exist in '${t}'`
        );
    });
  }
}
const KV = IV, YV = UV;
var lP = function(t) {
  return t.openapi ? KV(t) : YV(t);
};
const Ly = bO, JV = ni, XV = aP, QV = lP;
var eZ = sd;
function sd(e) {
  Ly.call(this, sd.defaults), Ly.apply(this, arguments);
}
sd.defaults = {
  /**
   * Determines how the API definition will be validated.
   *
   * You can add additional validators of your own, replace an existing one with
   * your own implemenation, or disable any validator by setting it to false.
   */
  validate: {
    colorizeErrors: !1,
    schema: XV,
    spec: QV
  }
};
JV.inherits(sd, Ly);
const { ono: En } = In, ta = L4, tZ = cx, fP = _O, df = DE, dP = eZ, pP = ni, rZ = aP, nZ = lP;
function Ti() {
  ta.apply(this, arguments);
}
pP.inherits(Ti, ta);
Ti.parse = ta.parse;
Ti.resolve = ta.resolve;
Ti.bundle = ta.bundle;
Ti.dereference = ta.dereference;
Object.defineProperty(Ti.prototype, "api", {
  configurable: !0,
  enumerable: !0,
  get() {
    return this.schema;
  }
});
Ti.prototype.parse = async function(e, t, r, i) {
  const n = fP(arguments);
  n.options = new dP(n.options);
  try {
    const s = await ta.prototype.parse.call(this, n.path, n.schema, n.options);
    if (s.swagger) {
      if (s.swagger === void 0 || s.info === void 0 || s.paths === void 0)
        throw En.syntax(`${n.path || "Supplied schema"} is not a valid Swagger API definition.`);
      if (typeof s.swagger == "number")
        throw En.syntax('Swagger version number must be a string (e.g. "2.0") not a number.');
      if (typeof s.info.version == "number")
        throw En.syntax('API version number must be a string (e.g. "1.0.0") not a number.');
      if (s.swagger !== "2.0")
        throw En.syntax(`Unrecognized Swagger version: ${s.swagger}. Expected 2.0`);
    } else {
      const a = ["3.0.0", "3.0.1", "3.0.2", "3.0.3", "3.1.0"];
      if (s.openapi === void 0 || s.info === void 0)
        throw En.syntax(`${n.path || "Supplied schema"} is not a valid OpenAPI definition.`);
      if (s.paths === void 0)
        if (s.openapi === "3.1.0") {
          if (s.webhooks === void 0)
            throw En.syntax(`${n.path || "Supplied schema"} is not a valid OpenAPI definition.`);
        } else
          throw En.syntax(`${n.path || "Supplied schema"} is not a valid OpenAPI definition.`);
      else {
        if (typeof s.openapi == "number")
          throw En.syntax('OpenAPI version number must be a string (e.g. "3.0.0") not a number.');
        if (typeof s.info.version == "number")
          throw En.syntax('API version number must be a string (e.g. "1.0.0") not a number.');
        if (a.indexOf(s.openapi) === -1)
          throw En.syntax(
            `Unsupported OpenAPI version: ${s.openapi}. Swagger Parser only supports versions ${a.join(", ")}`
          );
      }
      pP.fixOasRelativeServers(s, n.path);
    }
    return df(n.callback, Promise.resolve(s));
  } catch (s) {
    return df(n.callback, Promise.reject(s));
  }
};
Ti.validate = function(e, t, r, i) {
  const n = this, s = new n();
  return s.validate.apply(s, arguments);
};
Ti.prototype.validate = async function(e, t, r, i) {
  const n = this, s = fP(arguments);
  s.options = new dP(s.options);
  const a = s.options.dereference.circular;
  s.options.validate.schema && (s.options.dereference.circular = "ignore");
  try {
    if (await this.dereference(s.path, s.schema, s.options), s.options.dereference.circular = a, s.options.validate.schema && (rZ(n.api, s.options), n.$refs.circular)) {
      if (a === !0)
        tZ(n, s.options);
      else if (a === !1)
        throw En.reference("The API contains circular references");
    }
    return s.options.validate.spec && nZ(n.api), df(s.callback, Promise.resolve(n.schema));
  } catch (o) {
    return df(s.callback, Promise.reject(o));
  }
};
var qy = { exports: {} }, zh, e$;
function iZ() {
  if (e$)
    return zh;
  e$ = 1;
  var e = 1e3, t = e * 60, r = t * 60, i = r * 24, n = i * 7, s = i * 365.25;
  zh = function(d, p) {
    p = p || {};
    var h = typeof d;
    if (h === "string" && d.length > 0)
      return a(d);
    if (h === "number" && isFinite(d))
      return p.long ? c(d) : o(d);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(d)
    );
  };
  function a(d) {
    if (d = String(d), !(d.length > 100)) {
      var p = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        d
      );
      if (p) {
        var h = parseFloat(p[1]), g = (p[2] || "ms").toLowerCase();
        switch (g) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return h * s;
          case "weeks":
          case "week":
          case "w":
            return h * n;
          case "days":
          case "day":
          case "d":
            return h * i;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return h * r;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return h * t;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return h * e;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return h;
          default:
            return;
        }
      }
    }
  }
  function o(d) {
    var p = Math.abs(d);
    return p >= i ? Math.round(d / i) + "d" : p >= r ? Math.round(d / r) + "h" : p >= t ? Math.round(d / t) + "m" : p >= e ? Math.round(d / e) + "s" : d + "ms";
  }
  function c(d) {
    var p = Math.abs(d);
    return p >= i ? l(d, p, i, "day") : p >= r ? l(d, p, r, "hour") : p >= t ? l(d, p, t, "minute") : p >= e ? l(d, p, e, "second") : d + " ms";
  }
  function l(d, p, h, g) {
    var m = p >= h * 1.5;
    return Math.round(d / h) + " " + g + (m ? "s" : "");
  }
  return zh;
}
function sZ(e) {
  r.debug = r, r.default = r, r.coerce = c, r.disable = s, r.enable = n, r.enabled = a, r.humanize = iZ(), r.destroy = l, Object.keys(e).forEach((d) => {
    r[d] = e[d];
  }), r.names = [], r.skips = [], r.formatters = {};
  function t(d) {
    let p = 0;
    for (let h = 0; h < d.length; h++)
      p = (p << 5) - p + d.charCodeAt(h), p |= 0;
    return r.colors[Math.abs(p) % r.colors.length];
  }
  r.selectColor = t;
  function r(d) {
    let p, h = null, g, m;
    function v(..._) {
      if (!v.enabled)
        return;
      const y = v, w = Number(/* @__PURE__ */ new Date()), $ = w - (p || w);
      y.diff = $, y.prev = p, y.curr = w, p = w, _[0] = r.coerce(_[0]), typeof _[0] != "string" && _.unshift("%O");
      let E = 0;
      _[0] = _[0].replace(/%([a-zA-Z%])/g, (R, j) => {
        if (R === "%%")
          return "%";
        E++;
        const L = r.formatters[j];
        if (typeof L == "function") {
          const K = _[E];
          R = L.call(y, K), _.splice(E, 1), E--;
        }
        return R;
      }), r.formatArgs.call(y, _), (y.log || r.log).apply(y, _);
    }
    return v.namespace = d, v.useColors = r.useColors(), v.color = r.selectColor(d), v.extend = i, v.destroy = r.destroy, Object.defineProperty(v, "enabled", {
      enumerable: !0,
      configurable: !1,
      get: () => h !== null ? h : (g !== r.namespaces && (g = r.namespaces, m = r.enabled(d)), m),
      set: (_) => {
        h = _;
      }
    }), typeof r.init == "function" && r.init(v), v;
  }
  function i(d, p) {
    const h = r(this.namespace + (typeof p > "u" ? ":" : p) + d);
    return h.log = this.log, h;
  }
  function n(d) {
    r.save(d), r.namespaces = d, r.names = [], r.skips = [];
    let p;
    const h = (typeof d == "string" ? d : "").split(/[\s,]+/), g = h.length;
    for (p = 0; p < g; p++)
      h[p] && (d = h[p].replace(/\*/g, ".*?"), d[0] === "-" ? r.skips.push(new RegExp("^" + d.slice(1) + "$")) : r.names.push(new RegExp("^" + d + "$")));
  }
  function s() {
    const d = [
      ...r.names.map(o),
      ...r.skips.map(o).map((p) => "-" + p)
    ].join(",");
    return r.enable(""), d;
  }
  function a(d) {
    if (d[d.length - 1] === "*")
      return !0;
    let p, h;
    for (p = 0, h = r.skips.length; p < h; p++)
      if (r.skips[p].test(d))
        return !1;
    for (p = 0, h = r.names.length; p < h; p++)
      if (r.names[p].test(d))
        return !0;
    return !1;
  }
  function o(d) {
    return d.toString().substring(2, d.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  function c(d) {
    return d instanceof Error ? d.stack || d.message : d;
  }
  function l() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  return r.enable(r.load()), r;
}
var aZ = sZ;
(function(e, t) {
  t.formatArgs = i, t.save = n, t.load = s, t.useColors = r, t.storage = a(), t.destroy = (() => {
    let c = !1;
    return () => {
      c || (c = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
    };
  })(), t.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function r() {
    return typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? !0 : typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? !1 : typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function i(c) {
    if (c[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + c[0] + (this.useColors ? "%c " : " ") + "+" + e.exports.humanize(this.diff), !this.useColors)
      return;
    const l = "color: " + this.color;
    c.splice(1, 0, l, "color: inherit");
    let d = 0, p = 0;
    c[0].replace(/%[a-zA-Z%]/g, (h) => {
      h !== "%%" && (d++, h === "%c" && (p = d));
    }), c.splice(p, 0, l);
  }
  t.log = console.debug || console.log || (() => {
  });
  function n(c) {
    try {
      c ? t.storage.setItem("debug", c) : t.storage.removeItem("debug");
    } catch {
    }
  }
  function s() {
    let c;
    try {
      c = t.storage.getItem("debug");
    } catch {
    }
    return !c && typeof qe.process < "u" && "env" in qe.process && (c = qe.process.env.DEBUG), c;
  }
  function a() {
    try {
      return localStorage;
    } catch {
    }
  }
  e.exports = aZ(t);
  const { formatters: o } = e.exports;
  o.j = function(c) {
    try {
      return JSON.stringify(c);
    } catch (l) {
      return "[UnexpectedJSONParseError]: " + l.message;
    }
  };
})(qy, qy.exports);
var oZ = qy.exports;
function t$({ schema: e }) {
  return OE.generateSchema(e);
}
function ad(e) {
  return oZ.debug(e);
}
function uZ() {
  var e, t, r, i;
  return ((t = (e = qe.process) == null ? void 0 : e.env) == null ? void 0 : t.DEBUG) || !((i = (r = import.meta) == null ? void 0 : r.env) != null && i.PROD);
}
function Il(e) {
  return dn.isBuffer(e) ? e.byteLength : new Blob([typeof e == "object" ? JSON.stringify(e) : e]).size || 0;
}
function cZ(e) {
  return typeof e != "string" ? !1 : !isNaN(e) && !isNaN(parseFloat(e));
}
function lZ(e) {
  return typeof e != "string" ? e : cZ(e) ? e.indexOf(".") !== -1 ? parseFloat(e) : parseInt(e) : e;
}
const od = ({ ms: e, fn: t }) => new Promise((r, i) => {
  const n = setTimeout(() => {
    i({ error: "timeout" });
  }, e);
  t.then((s) => {
    clearTimeout(n), r(s);
  }, i);
}), Fy = ad("security"), hP = new Vu({
  ttl: 1e3 * 1e3
});
async function fZ({ ip: e, request_id: t }) {
  const r = Tf();
  return hP.put(r, { ip: e, request_id: t }), r;
}
async function dZ({
  challenge: e,
  ip: t,
  request_id: r
}) {
  const i = hP.get(e);
  return i ? i.ip !== t || i.request_id !== r ? (Fy(`challenge ${e} does not match ip ${t} or request_id ${r}`), !1) : !0 : (Fy(`challenge ${e} not found`), !1);
}
function to({ str: e }) {
  return Yk(dn.isBuffer(e) ? e : dn.from(e, "hex"));
}
function pZ({
  message: e,
  signature: t,
  public_key: r
}) {
  const i = Xr({ input: to({ str: e }) });
  return y3(t, i, r);
}
async function hZ(e) {
  if (e && typeof e == "object" && "auth" in e && "params" in e) {
    const t = e.auth;
    if (!await dZ({ challenge: e.auth.n || "", ip: e.ip, request_id: e.request_id }))
      return !1;
    Fy(`verifying signature for ${e.request_id}`);
    const r = to({
      str: JSON.stringify({ offer: e.offer, params: e.params || {}, nonce: e.auth.n, request_id: e.id })
    });
    return pZ({ message: Xr({ input: r }), signature: t.s, public_key: t.pk });
  } else
    return { error: "Missing auth or params" };
}
async function mP() {
  const e = g3.randomPrivateKey(), t = H2(e);
  return { private_key: dn.toString(e, "hex"), public_key: dn.toString(t, "hex") };
}
async function pf(e, t) {
  const r = dn.isBuffer(e) ? dn.from(e) : e, i = Xr({ input: to({ str: r }) });
  return (await m3(i, Xr({ input: t }))).toCompactRawBytes();
}
async function mZ({ private_key: e }) {
  return Xr({ input: await H2(e) });
}
function Xr({ input: e, add0x: t = !1 }) {
  const r = dn.toString(e, "hex");
  return t ? "0x" + r : r;
}
function hf({ input: e }) {
  return dn.from(e.replace(/^0x/, ""), "hex");
}
async function $W() {
  const e = await mP();
  return {
    ...e,
    user_id: e.public_key
  };
}
var yP = { exports: {} };
(function(e) {
  var t = Object.prototype.hasOwnProperty, r = "~";
  function i() {
  }
  Object.create && (i.prototype = /* @__PURE__ */ Object.create(null), new i().__proto__ || (r = !1));
  function n(c, l, d) {
    this.fn = c, this.context = l, this.once = d || !1;
  }
  function s(c, l, d, p, h) {
    if (typeof d != "function")
      throw new TypeError("The listener must be a function");
    var g = new n(d, p || c, h), m = r ? r + l : l;
    return c._events[m] ? c._events[m].fn ? c._events[m] = [c._events[m], g] : c._events[m].push(g) : (c._events[m] = g, c._eventsCount++), c;
  }
  function a(c, l) {
    --c._eventsCount === 0 ? c._events = new i() : delete c._events[l];
  }
  function o() {
    this._events = new i(), this._eventsCount = 0;
  }
  o.prototype.eventNames = function() {
    var l = [], d, p;
    if (this._eventsCount === 0)
      return l;
    for (p in d = this._events)
      t.call(d, p) && l.push(r ? p.slice(1) : p);
    return Object.getOwnPropertySymbols ? l.concat(Object.getOwnPropertySymbols(d)) : l;
  }, o.prototype.listeners = function(l) {
    var d = r ? r + l : l, p = this._events[d];
    if (!p)
      return [];
    if (p.fn)
      return [p.fn];
    for (var h = 0, g = p.length, m = new Array(g); h < g; h++)
      m[h] = p[h].fn;
    return m;
  }, o.prototype.listenerCount = function(l) {
    var d = r ? r + l : l, p = this._events[d];
    return p ? p.fn ? 1 : p.length : 0;
  }, o.prototype.emit = function(l, d, p, h, g, m) {
    var v = r ? r + l : l;
    if (!this._events[v])
      return !1;
    var _ = this._events[v], y = arguments.length, w, $;
    if (_.fn) {
      switch (_.once && this.removeListener(l, _.fn, void 0, !0), y) {
        case 1:
          return _.fn.call(_.context), !0;
        case 2:
          return _.fn.call(_.context, d), !0;
        case 3:
          return _.fn.call(_.context, d, p), !0;
        case 4:
          return _.fn.call(_.context, d, p, h), !0;
        case 5:
          return _.fn.call(_.context, d, p, h, g), !0;
        case 6:
          return _.fn.call(_.context, d, p, h, g, m), !0;
      }
      for ($ = 1, w = new Array(y - 1); $ < y; $++)
        w[$ - 1] = arguments[$];
      _.fn.apply(_.context, w);
    } else {
      var E = _.length, S;
      for ($ = 0; $ < E; $++)
        switch (_[$].once && this.removeListener(l, _[$].fn, void 0, !0), y) {
          case 1:
            _[$].fn.call(_[$].context);
            break;
          case 2:
            _[$].fn.call(_[$].context, d);
            break;
          case 3:
            _[$].fn.call(_[$].context, d, p);
            break;
          case 4:
            _[$].fn.call(_[$].context, d, p, h);
            break;
          default:
            if (!w)
              for (S = 1, w = new Array(y - 1); S < y; S++)
                w[S - 1] = arguments[S];
            _[$].fn.apply(_[$].context, w);
        }
    }
    return !0;
  }, o.prototype.on = function(l, d, p) {
    return s(this, l, d, p, !1);
  }, o.prototype.once = function(l, d, p) {
    return s(this, l, d, p, !0);
  }, o.prototype.removeListener = function(l, d, p, h) {
    var g = r ? r + l : l;
    if (!this._events[g])
      return this;
    if (!d)
      return a(this, g), this;
    var m = this._events[g];
    if (m.fn)
      m.fn === d && (!h || m.once) && (!p || m.context === p) && a(this, g);
    else {
      for (var v = 0, _ = [], y = m.length; v < y; v++)
        (m[v].fn !== d || h && !m[v].once || p && m[v].context !== p) && _.push(m[v]);
      _.length ? this._events[g] = _.length === 1 ? _[0] : _ : a(this, g);
    }
    return this;
  }, o.prototype.removeAllListeners = function(l) {
    var d;
    return l ? (d = r ? r + l : l, this._events[d] && a(this, d)) : (this._events = new i(), this._eventsCount = 0), this;
  }, o.prototype.off = o.prototype.removeListener, o.prototype.addListener = o.prototype.on, o.prefixed = r, o.EventEmitter = o, e.exports = o;
})(yP);
var yZ = yP.exports;
const gZ = /* @__PURE__ */ Ks(yZ), vi = new gZ();
async function gP({ request_id: e, data: t, onData: r, onDone: i, onError: n }) {
  if ("error" in t)
    return n && n(t);
  if (t.request_id && t.status === "ready") {
    e = t.request_id;
    return;
  } else {
    if (t.request_id === e && t.status === "data")
      return r && r(t);
    if (t.request_id === e && t.status === "complete")
      return i && i(t);
    if (t.request_id === e)
      return n && n({ error: `Unknown type of response: ${JSON.stringify(t)}`, code: 500 });
  }
}
async function vZ({
  request_id: e,
  onData: t,
  onDone: r,
  onError: i
}) {
  const n = {
    write: async (s) => {
      const { offer: a } = s.input;
      vi.emit(`${a.call.module_id}:/${a.call.method_id}:post`, s);
    },
    close: async () => !0
  };
  return vi.on(e, async (s) => {
    gP({ request_id: e, data: s, onData: t, onDone: r, onError: i });
  }), n;
}
async function bZ({ API: e }) {
  vi.on("registerModule", async ({ module: t }) => {
    const { code: r } = await e.registerModule({ module: t });
    return r !== 200 ? { error: "Failed to register module", code: r } : { code: r };
  }), vi.on("registerProtocol", async ({ protocol: t }) => ({ code: 200 }));
  for (const t of e.getModules())
    for (const r in t.schema.paths) {
      const i = t.schema.paths[r];
      for (const n in i)
        vi.on(
          `${t.id}:${r}:${n}`,
          async ({
            input: s,
            globals: a,
            abort: o
          }) => {
            if (o)
              return e.abort({ request_id: s.id });
            const c = await e.execute({
              input: s,
              globals: a,
              // ...channel,
              onData: (l) => {
                vi.emit(`${s.id}`, { request_id: s.id, data: l, status: "data" });
              },
              onDone: (l) => {
                vi.emit(`${s.id}`, { request_id: s.id, status: "complete", data: l });
              },
              onError: (l) => {
                vi.emit(`${s.id}`, { request_id: s.id, error: l, status: "error" });
              }
            });
            return c && "error" in c ? vi.emit(`${s.id}`, { request_id: s.id, error: c == null ? void 0 : c.error, status: "error" }) : c;
          }
        );
    }
}
var vP = function() {
  throw new Error(
    "ws does not work in the browser. Browser clients must use the native WebSocket object"
  );
};
const _Z = /* @__PURE__ */ Ks(vP), Wh = new Vu({ ttl: 1e3 * 60 * 1 });
async function wZ({
  request_id: e,
  host: t,
  onData: r,
  onDone: i,
  onError: n
}) {
  const s = async () => {
    const c = Wh.get(t);
    if (!c || (c == null ? void 0 : c.readyState) !== 1) {
      const l = new _Z(`ws://${t}:8080`);
      return Wh.put(t, l), new Promise((d) => {
        l.onopen = () => {
          d(l);
        };
      });
    }
    return c;
  }, a = {
    write: async (c) => {
      (await s()).send(JSON.stringify(c));
    },
    close: async () => {
      const c = await s();
      return c && (c.close(), Wh.del(t)), !0;
    }
  }, o = await s();
  return o.onmessage = (c) => {
    try {
      if (dn.isBuffer(c == null ? void 0 : c.data))
        return { error: "buffer not supported yet " };
      const l = typeof c.data == "object" ? c.data : JSON.parse(c.data);
      gP({ request_id: e, data: l, onData: r, onDone: i, onError: n });
    } catch (l) {
      return { error: l };
    }
  }, a;
}
async function $Z({
  API: e,
  ws: t,
  input: r,
  globals: i,
  abort: n
}) {
  if (n)
    return e.abort({ request_id: r.id });
  const s = await e.execute({
    input: r,
    globals: i,
    // ...channel,
    onData: (a) => {
      t.send(JSON.stringify({ request_id: r.id, data: a, status: "data" }));
    },
    onDone: (a) => {
      t.send(JSON.stringify({ request_id: r.id, status: "complete", data: a }));
    },
    onError: (a) => {
      t.send(JSON.stringify({ request_id: r.id, error: a, status: "error" }));
    }
  });
  return s && "error" in s ? t.send(JSON.stringify({ request_id: r.id, error: s == null ? void 0 : s.error, status: "error" })) : s;
}
async function EZ({
  API: e,
  host: t = "127.0.0.1",
  port: r = 8080
}) {
  new vP.WebSocketServer({ host: t, port: r }).on("connection", function(s) {
    s.on("error", console.error), s.on("message", function(o) {
      const c = dn.isBuffer(o) ? dn.toString(o) : typeof o == "string" ? o : "{}";
      let l = JSON.parse(c);
      $Z({ ...l, ws: s, API: e });
    });
  });
}
var ec = {}, g0 = {};
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
(function(e) {
  e.binary = /^(?:[01]{8})+$/, e.boolean = /^(?:true|false)$/, e.byte = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/, e.date = /^(\d{4})-(\d{2})-(\d{2})$/, e.dateTime = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(Z|([+-]\d{2}:?\d{2}))$/i, e.integer = /^-?\d+$/, e.number = /^-?\d+(?:\.\d+)?$/, e["date-time"] = e.dateTime;
})(g0);
const xZ = /* @__PURE__ */ xf(YN);
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
const OZ = no;
let PZ = OZ.inspect.custom || "inspect";
var Nn = Mr;
function Mr(e) {
  if (!(this instanceof Mr))
    return new Mr(e);
  this.header = e, this.children = {
    at: {},
    nest: [],
    message: []
  };
}
Mr.prototype.at = function(e) {
  const t = this.children.at;
  return t[e] || (t[e] = new Mr("")), t[e];
};
Mr.prototype.clearCache = function() {
  return this;
};
Mr.prototype[PZ] = function() {
  return this.hasException ? "[ EnforcerException: " + lu(this, null, "  ") + " ]" : "[ EnforcerException ]";
};
Mr.prototype.nest = function(e) {
  const t = new Mr(e);
  return this.children.nest.push(t), t;
};
Mr.prototype.merge = function(e) {
  const t = this.children, r = e.children, i = t.at;
  return Object.keys(r.at).forEach((n) => {
    i[n] ? i[n].merge(r.at[n]) : i[n] = r.at[n];
  }), r.nest.forEach((n) => {
    t.nest.push(n);
  }), r.message.forEach((n) => {
    t.message.push(n);
  }), this;
};
Mr.prototype.message = function(e) {
  return this.children.message.push(e), this;
};
Mr.prototype.push = function(e) {
  const t = typeof e;
  if (t === "string" && e.length)
    this.children.message.push(e);
  else if (t === "object" && e instanceof Mr)
    this.children.nest.push(e);
  else
    throw Error("Can only push string or EnforcerException instance");
  return this;
};
Mr.prototype.toString = function() {
  return lu(this, null, "");
};
Object.defineProperties(Mr.prototype, {
  count: {
    get: function() {
      const e = this.children;
      return e.message.length + e.nest.reduce((t, r) => t + r.count, 0) + Object.keys(e.at).reduce((t, r) => t + e.at[r].count, 0);
    }
  },
  hasException: {
    get: function() {
      const e = this.children;
      if (e.message.length)
        return !0;
      {
        const t = e.nest, r = t.length;
        for (let s = 0; s < r; s++)
          if (t[s].hasException)
            return !0;
        const i = Object.keys(e.at), n = i.length;
        for (let s = 0; s < n; s++)
          if (e.at[i[s]].hasException)
            return !0;
      }
      return !1;
    }
  }
});
function lu(e, t, r) {
  if (!e.hasException)
    return "";
  const i = r + "  ", n = e.children;
  let s = "";
  e.header && (s += (t ? r : "") + e.header);
  const a = n.at, o = Object.keys(a).filter((l) => a[l].hasException), c = o.length === 1;
  return o.forEach((l) => {
    const d = n.at[l];
    e.header || !c || n.nest.length > 0 || n.message.length > 0 ? s += `
` + i + "at: " + l + lu(d, e, i) : s += " > " + l + lu(d, e, r);
  }), n.nest.forEach((l) => {
    l.hasException && (s += `
` + lu(l, e, i));
  }), n.message.forEach((l) => {
    s += `
` + i + l;
  }), s;
}
const bP = xZ, r$ = g0, n$ = Nn, i$ = /^([\s\S]+?)\/(?:([\s\S]+?)\+)?([\s\S]+?)$/, _P = ",,,,,,,,,,.................................:;!?", SZ = _P.length, wP = "lorem ipsum dolor sit amet consectetur adipiscing elit suspendisse sollicitudin felis pretium laoreet tortor facilisis a integer eu metus velit praesent varius sed erat quis ornare nunc porttitor nulla at ultrices nam ac vestibulum metus maecenas malesuada lectus leo blandit a congue gravida phasellus consectetur libero et tincidunt diam pellentesque lacus neque eros sed porta nunc id lobortis eget ligula mollis nulla nunc maximus gravida felis finibus est ullamcorper pellentesque ex in turpis pharetra dictum in fermentum arcu mauris odio molestie iaculis accumsan nec convallis nec nunc vestibulum nisl curabitur tristique non porttitor vivamus dui ipsum orci eget vulputate lacus interdum suscipit massa elementum sodales at interdum fames ante primis in faucibus duis mi pulvinar accumsan donec odio enim sed dignissim turpis quisque vitae turpis ut nibh tincidunt aliquam magna semper aliquam feugiat sapien justo egestas condimentum metus tincidunt odio volutpat vehicula pulvinar arcu diam bibendum sem leo sodales eleifend vehicula fusce faucibus quam lorem rhoncus amet hendrerit rhoncus augue mattis commodo lobortis urna consequat hendrerit enim risus placerat eros euismod ligula tellus tempus condimentum ac lectus erat ultrices mi lacus nisi scelerisque vehicula cursus cras enim elit aenean aliquam tempor ullamcorper est proin aliquet orci et augue posuere viverra massa augue purus orci purus neque ut elit pretium molestie vel tellus ex consequat tristique urna fringilla dignissim ex lectus imperdiet lobortis potenti efficitur feugiat facilisi placerat posuere bibendum velit volutpat dapibus donec".split(" "), AZ = wP.length;
var Yt = {
  arrayRemoveItem: CZ,
  copy: (e) => Uy(/* @__PURE__ */ new Map(), e),
  determineSchemaFromSchemas: jl,
  edgeSlashes: RZ,
  findMediaMatch: TZ,
  freeze: kl,
  getDateFromValidDateString: IZ,
  getDefinitionType: kZ,
  greatestCommonDenominator: $P,
  isDate: By,
  isNumber: Ml,
  isInteger: MZ,
  isPlainObject: tc,
  isObject: mf,
  isObjectStringMap: NZ,
  leastCommonMultiple: DZ,
  leastOf: LZ,
  lowerCaseObjectProperties: qZ,
  mapObject: FZ,
  merge: Vy,
  methods: UZ,
  mostOf: BZ,
  parseCookieString: VZ,
  parseQueryString: ZZ,
  randomNumber: EP,
  randomOneOf: zZ,
  randomText: WZ,
  reject: HZ,
  rxStringToRx: KZ,
  same: Zy,
  schemaObjectHasSkipCode: zy,
  smart: gi,
  toPlainObject: function(e, t) {
    const r = /* @__PURE__ */ new Map();
    if (t || (t = {}), typeof t != "object")
      throw Error('Parameter "options" must be an object');
    if (t.hasOwnProperty("allowInheritedProperties") || (t.allowInheritedProperties = !1), t.hasOwnProperty("preserve") || (t.preserve = []), !Array.isArray(t.preserve))
      throw Error('Option "preserve" must be an array');
    t.preserve = new Set(t.preserve), t.preserve.add(Date);
    const i = Wy(e, t, r);
    if (!i.set)
      throw Error("Unable to convert value to plain object");
    return i.value;
  },
  toQueryString: YZ,
  ucFirst: xP,
  validateExamples: JZ,
  validateMaxMin: XZ
};
function CZ(e, t) {
  const r = e.indexOf(t);
  return r !== -1 && e.splice(r, 1), e;
}
function Uy(e, t) {
  if (t instanceof Date)
    return /* @__PURE__ */ new Date(+t);
  if (t instanceof qe.Buffer)
    return t.slice(0);
  if (Array.isArray(t)) {
    let r = e.get(t);
    return r || (r = [], e.set(t, r), t.forEach((i) => r.push(Uy(e, i))), r);
  } else if (tc(t)) {
    let r = e.get(t);
    return r || (r = {}, e.set(t, r), Object.keys(t).forEach((i) => r[i] = Uy(e, t[i])), r);
  } else
    return t;
}
function $r() {
  throw Error("Date object cannot be modified");
}
function jl(e, t) {
  const r = typeof t, i = e.length;
  for (let n = 0; n < i; n++) {
    const s = e[n];
    if (s.type === "array" && Array.isArray(t) || s.type === "boolean" && r === "boolean" || s.type === "integer" && r === "number" && /^\d+$/.test(String(t)) || s.type === "number" && r === "number" || s.type === "string" && r === "string" || s.type === "object" && r === "object" && t !== null || t === null && (s.nullable || s["x-nullable"]))
      return s;
    if (s.anyOf) {
      const a = jl(a.anyOf, t);
      if (a !== null)
        return a;
    } else if (s.oneOf) {
      const a = jl(a.oneOf, t);
      if (a !== null)
        return a;
    } else if (s.allOf) {
      const a = s.allOf.length;
      for (let o = 0; o < a; o++) {
        const c = c.allOf[o];
        if (c.type !== void 0)
          return c;
        if (c.anyOf || c.oneOf)
          return jl(c.anyOf ?? c.oneOf, t);
      }
    }
  }
  return null;
}
function RZ(e, t, r) {
  return e = e.replace(/^\//, "").replace(/\/$/, ""), e.length === 0 && (t || r) ? "/" : (t && (e = "/" + e), r && (e += "/"), e);
}
function TZ(e, t) {
  const r = e.split(/, */).map((a, o) => {
    const c = a.split(";"), l = i$.exec(c[0]), d = /q=(\d(?:\.\d)?)/.exec(c[1]);
    if (l)
      return {
        extension: l[2] || "*",
        index: o,
        quality: +(d && d[1] || 1),
        subType: l[3],
        type: l[1]
      };
  }).filter((a) => !!a), i = [];
  r.forEach((a) => {
    t.forEach((o, c) => {
      const l = i$.exec(o);
      if (l) {
        const d = l[1], p = l[3], h = l[2] || "*";
        (a.type === d || a.type === "*" || d === "*") && (a.subType === p || a.subType === "*" || p === "*") && (a.extension === h || a.extension === "*" || h === "*") && i.push({
          index: a.index,
          order: c,
          quality: a.quality,
          score: (a.type === d ? 1 : 0) + (a.subType === p ? 1 : 0) + (a.extension === h ? 1 : 0),
          value: o
        });
      }
    });
  }), i.sort((a, o) => a.quality < o.quality ? 1 : a.quality > o.quality ? -1 : a.score < o.score ? 1 : a.score > o.score ? -1 : a.index < o.index ? 1 : a.index > o.index || a.order < o.order ? -1 : 1);
  const n = {}, s = [];
  return i.forEach((a) => {
    const o = a.value;
    n[o] || (n[o] = a, s.push(a.value));
  }), s;
}
function kl(e) {
  return !e || typeof e != "object" || e instanceof qe.Buffer || (e instanceof Date && (e.setDate = $r, e.setFullYear = $r, e.setHours = $r, e.setMilliseconds = $r, e.setMinutes = $r, e.setMonth = $r, e.setSeconds = $r, e.setTime = $r, e.setUTCDate = $r, e.setUTCFullYear = $r, e.setUTCHours = $r, e.setUTCMilliseconds = $r, e.setUTCMinutes = $r, e.setUTCMonth = $r, e.setUTCSeconds = $r, e.setYear = $r), Object.freeze(e)), e;
}
function IZ(e, t) {
  const r = new Date(t), i = r.toISOString(), n = e === "date" ? r$.date.exec(i.substring(0, 10)) : r$["date-time"].exec(i), s = +n[1], a = +n[2] - 1, o = +n[3], c = +n[4] || 0, l = +n[5] || 0, d = +n[6] || 0, h = +jZ(n[7]) || 0;
  return r.getUTCFullYear() === s && r.getUTCMonth() === a && r.getUTCDate() === o && r.getUTCHours() === c && r.getUTCMinutes() === l && r.getUTCSeconds() === d && r.getUTCMilliseconds() === h ? r : null;
}
function jZ(e) {
  if (e === void 0)
    return;
  var t = e;
  const r = 3 - e.length;
  return r > 0 ? t = e + "0".repeat(r) : r < 0 && (t = e.substr(0, 3)), t;
}
function kZ(e) {
  if (Array.isArray(e))
    return "array";
  if (tc(e))
    return "object";
  if (e === null)
    return "null";
  const t = typeof e;
  return t === "object" ? "decoratedObject" : t;
}
function $P(e, t) {
  for (e = Math.abs(e), t = Math.abs(t); t; ) {
    const r = t;
    t = e % t, e = r;
  }
  return e;
}
function By(e) {
  return e && !isNaN(e) && e instanceof Date;
}
function Ml(e) {
  return typeof e == "number" && !isNaN(e);
}
function MZ(e) {
  return !isNaN(e) && typeof e == "number" && e === Math.round(e);
}
function mf(e) {
  return e && typeof e == "object" && Object.prototype.toString.call(e) === "[object Object]";
}
function tc(e) {
  if (!mf(e))
    return !1;
  const t = e.constructor;
  if (typeof t != "function")
    return !1;
  const r = t.prototype;
  return mf(r) ? r.hasOwnProperty("isPrototypeOf") : !1;
}
function NZ(e) {
  if (!tc(e))
    return !1;
  const t = Object.keys(e), r = t.length;
  for (let i = 0; i < r; i++)
    if (typeof t[i] != "string" || typeof e[t[i]] != "string")
      return !1;
  return !0;
}
function DZ(e, t) {
  return typeof e != "number" || typeof t != "number" ? !1 : !e || !t ? 0 : Math.abs(e * t / $P(e, t));
}
function LZ(e) {
  const t = e.length;
  let r = e[0];
  for (let i = 1; i < t; i++)
    e[i] < r && (r = e[i]);
  return r;
}
function qZ(e) {
  const t = {};
  return Object.keys(e).forEach((r) => {
    t[r.toLowerCase()] = e[r];
  }), t;
}
function FZ(e, t) {
  const r = {};
  return Object.keys(e).forEach((i) => {
    r[i] = t(e[i], i);
  }), r;
}
function Vy(e, t, r = "") {
  if (tc(e)) {
    if (!mf(t))
      throw Error(r + ": Unable to merge non-object into plain object.");
    return Object.keys(t).forEach((i) => {
      e[i] = e.hasOwnProperty(i) ? Vy(e[i], t[i], r + "> " + i) : t[i];
    }), e;
  } else if (Array.isArray(e)) {
    if (!Array.isArray(t))
      throw Error(r + ": Unable to merge non-array into array");
    const i = e.length, n = i > t.length ? i : t.length;
    for (let s = 0; s < n; s++)
      s >= i ? e[s] = t[s] : e[s] = Vy(e[s], t[s], "> " + s);
    return e;
  } else
    return t;
}
function UZ() {
  return ["get", "put", "post", "delete", "options", "head", "patch", "trace"];
}
function BZ(e) {
  const t = e.length;
  let r = e[0];
  for (let i = 1; i < t; i++)
    e[i] > r && (r = e[i]);
  return r;
}
function VZ(e) {
  const t = {};
  return e.split(/; */).forEach((r) => {
    const [i, n] = r.split("=");
    t[i] || (t[i] = []), t[i].push(n || "");
  }), t;
}
function ZZ(e, t) {
  const r = bP.parse(e, t);
  return Object.keys(r).forEach((i) => {
    const n = r[i];
    Array.isArray(n) || (r[i] = [n]);
  }), Object.assign({}, r);
}
function EP({ min: e, max: t, multipleOf: r, exclusiveMin: i = !1, exclusiveMax: n = !1, decimalPlaces: s = 0, spread: a = 1e3 } = {}) {
  const o = Ml(e), c = Ml(t);
  if (t < e)
    throw Error("Maximum value must be greater than or equal to minimum value");
  if (Ml(r) && r > 0) {
    const l = e % r;
    return l !== 0 && (e += r - l), t -= t % r, t === e ? t : (Math.round(Math.random() * (t - e) / r) + e) * r;
  } else {
    const l = o && c ? t - e : a;
    let d = Math.random() * l;
    return o && (d += e), d = GZ(d, s), o && (d < e && (d = e), d === e && i && (d += Math.pow(10, -1 * s))), c && (d > t && (d = t), d === t && n && (d -= Math.pow(10, -1 * s))), o && (d < e || d === e && i) || c && (d > t || d === t && n) ? void 0 : d;
  }
}
function zZ(e) {
  const t = Math.floor(Math.random() * e.length);
  return e[t];
}
function WZ({ minLength: e = 1, maxLength: t = 250 } = {}) {
  const r = EP({ min: e, max: t }) + 1;
  let i = "", n = 1, s = !0;
  for (; i.length < r; ) {
    const a = Math.floor(Math.random() * AZ);
    let o = wP[a];
    if (s && (o = xP(o)), s = !1, i += o, Math.random() >= n) {
      n = 1;
      const c = Math.floor(Math.random() * SZ), l = _P[c];
      /[.!?]/.test(l) && (s = !0), i += l;
    } else
      n *= 0.9;
    i += " ";
  }
  return i = i.trim(), i = i.replace(/[,.:;!?]$/, ""), t > 5 ? (i.length >= t && (i = i.substr(0, t - 1)), i += ".") : i.length > t && (i = i.substr(0, t)), i;
}
function HZ(e) {
  return Promise.reject(Error(typeof e == "string" ? e : e.toString()));
}
function GZ(e, t = 0) {
  const r = Math.pow(10, t);
  return Math.round(e * r) / r;
}
function KZ(e) {
  if (typeof e == "string") {
    const r = /^\/([\s\S]+?)\/(\w*)?$/.exec(e);
    return r ? RegExp(r[1], r[2] || "") : RegExp(e);
  } else {
    if (e instanceof RegExp)
      return e;
    throw Error("Cannot convert value to RegExp instance");
  }
}
function Zy(e, t) {
  if (e === t)
    return !0;
  const r = typeof e;
  if (r !== typeof t)
    return !1;
  if (Array.isArray(e)) {
    if (!Array.isArray(t))
      return !1;
    const i = e.length;
    if (i !== t.length)
      return !1;
    for (let n = 0; n < i; n++)
      if (!Zy(e[n], t[n]))
        return !1;
    return !0;
  } else {
    if (qe.Buffer.isBuffer(e))
      return qe.Buffer.isBuffer(t) && e.toString() === t.toString();
    if (By(e))
      return By(t) && +t == +e;
    if (e && r === "object") {
      if (!t)
        return !1;
      const i = Object.keys(e), n = i.length;
      if (n !== Object.keys(t).length)
        return !1;
      for (let s = 0; s < n; s++) {
        const a = i[s];
        if (!Zy(e[a], t[a]))
          return !1;
      }
      return !0;
    } else
      return !1;
  }
}
function zy(e, t) {
  return (typeof e == "object" && e !== null ? e["x-enforcer-exception-skip-codes"] ?? "" : "").split(/ +/).map((n) => n.trim()).includes(t);
}
function gi(e) {
  const t = typeof e;
  if (t === "string")
    return '"' + e.replace(/"/g, '\\"') + '"';
  if (e instanceof Date)
    return isNaN(e) ? "invalid date object" : e.toISOString();
  if (Array.isArray(e)) {
    let r = "[" + String(e) + "]";
    const i = r.length;
    if (i > 15) {
      const n = i - 15, s = Math.floor(n / 2), a = n - s, o = Math.ceil(i / 2);
      r = r.substr(0, o - a) + "..." + r.substr(o + s);
    }
    return r;
  }
  if (e && t === "object") {
    const r = e.constructor ? e.constructor.name : "";
    return "[object" + (r ? " " + r : "") + "]";
  }
  return String(e);
}
function Wy(e, t, r) {
  if (e && e.constructor && t.preserve.has(e.constructor))
    return { set: !0, value: e };
  if (Array.isArray(e)) {
    if (r.has(e))
      return r.get(e);
    const i = { set: !0, value: [] };
    return r.set(e, i), e.forEach((n) => {
      const s = Wy(n, t, r);
      s.set && i.value.push(s.value);
    }), i;
  } else if (e && typeof e == "object") {
    if (r.has(e))
      return r.get(e);
    const i = { set: !0, value: {} };
    r.set(e, i);
    for (let n in e)
      if (t.allowInheritedProperties || e.hasOwnProperty(n)) {
        const s = Wy(e[n], t, r);
        s.set && (i.value[n] = s.value);
      }
    return i;
  } else
    return e instanceof Object ? { set: !1 } : { set: !0, value: e };
}
function YZ(e) {
  return bP.stringify(e);
}
function xP(e) {
  return e[0].toUpperCase() + e.substr(1);
}
function JZ(e, t, r, i) {
  const n = i.exceptionSkipCodes, s = i.exceptionEscalateCodes;
  if (e.hasOwnProperty("schema")) {
    if (e.hasOwnProperty("example")) {
      let a, o;
      if ([a, o] = e.schema.deserialize(e.example), o || (o = e.schema.validate(a)), o && !n.WSCH006 && !zy(e, "WSCH006")) {
        const c = new n$("Example not valid. [WSCH006]");
        c.push(o), (s.WSCH006 ? t : r).at("example").push(c);
      }
      Object.defineProperty(e, "example", {
        configurable: !0,
        enumerable: !0,
        value: kl(a)
      });
    }
    if (e.hasOwnProperty("examples")) {
      const a = e.enforcerData.major;
      Object.keys(e.examples).forEach((o) => {
        let c, l;
        const d = a === 2 ? e.examples[o] : e.examples[o].value;
        if ([c, l] = e.schema.deserialize(d), l || (l = e.schema.validate(c)), l && !n.WSCH006 && !zy(e, "WSCH006")) {
          const p = new n$("Example not valid. [WSCH006]");
          p.push(l), (s.WSCH006 ? t : r).at("examples").at(o).push(p);
        }
        a === 2 ? Object.defineProperty(e.examples, o, {
          configurable: !0,
          enumerable: !0,
          value: kl(c)
        }) : Object.defineProperty(e.examples[o], "value", {
          configurable: !0,
          enumerable: !0,
          value: kl(c)
        });
      });
    }
  }
}
function XZ(e, t, r, i, n, s, a, o, c) {
  if (t.hasOwnProperty(i)) {
    if (s && t.exclusiveMaximum && a >= o) {
      let l = t.serialize(t[i]).value || t[i], d = t.serialize(a).value || a;
      e.message("Expected " + r + " to be less than " + gi(l) + ". Received: " + gi(d));
    } else if (a > o) {
      let l = t.serialize(t[i]).value || t[i], d = t.serialize(a).value || a;
      e.message("Expected " + r + " to be less than or equal to " + gi(l) + ". Received: " + gi(d));
    }
  }
  if (t.hasOwnProperty(n)) {
    if (s && t.exclusiveMinimum && a <= c) {
      let l = t.serialize(t[n]).value || t[n], d = t.serialize(a).value || a;
      e.message("Expected " + r + " to be greater than " + gi(l) + ". Received: " + gi(d));
    } else if (a < c) {
      let l = t.serialize(t[n]).value || t[n], d = t.serialize(a).value || a;
      e.message("Expected " + r + " to be greater than or equal to " + gi(l) + ". Received: " + gi(d));
    }
  }
}
const ns = g0, fr = Yt, QZ = "00000000";
ec.binary = {
  constructors: [qe.Buffer],
  deserialize: function({ exception: e, value: t }) {
    if (t instanceof qe.Buffer)
      return t;
    if (typeof t != "string" || !ns.binary.test(t))
      e.message("Expected a binary octet string");
    else {
      const r = t.length, i = [];
      for (let n = 0; n < r; n += 8)
        i.push(parseInt(t.substr(n, 8), 2));
      return qe.Buffer.from(i, "binary");
    }
  },
  random: OP(8),
  serialize: function({ exception: e, value: t }) {
    if (t instanceof qe.Buffer) {
      let r = "";
      for (let i = 0; i < t.length; i++) {
        const n = t[i].toString(2);
        r += QZ.substr(n.length) + n;
      }
      return r;
    } else
      e.message("Expected a Buffer instance. Received: " + fr.smart(t));
  },
  validate: function({ exception: e, schema: t, value: r }) {
    qe.Buffer.isBuffer(r) ? fr.validateMaxMin(e, t, "binary length", "maxLength", "minLength", !0, r.length * 8, t.maxLength, t.minLength) : e.message("Expected value to be a buffer. Received: " + fr.smart(r));
  },
  validator: function(e) {
    const { exception: t } = e;
    this.hasOwnProperty("maxLength") && this.maxLength % 8 !== 0 && t.at("maxLength").message("Binary format requires maxLength to be a multiple of 8"), this.hasOwnProperty("minLength") && this.minLength % 8 !== 0 && t.at("minLength").message("Binary format requires minLength to be a multiple of 8");
  }
};
ec.byte = {
  constructors: [qe.Buffer],
  deserialize: function({ exception: e, value: t }) {
    if (t instanceof qe.Buffer)
      return t;
    if (typeof t == "string")
      if (t = t.replace(/(\s)/gm, ""), !ns.byte.test(t) || t.length % 4 !== 0)
        e.message("Expected a base64 string");
      else
        return qe.Buffer.from(t, "base64");
    else
      e.message("Expected a base64 string");
  },
  random: OP(4),
  serialize: function({ exception: e, value: t }) {
    if (t instanceof qe.Buffer)
      return t.toString("base64");
    e.message("Expected a Buffer instance. Received: " + fr.smart(t));
  },
  validate: function({ exception: e, schema: t, value: r }) {
    qe.Buffer.isBuffer(r) ? fr.validateMaxMin(e, t, "byte length", "maxLength", "minLength", !0, r.length, t.maxLength, t.minLength) : e.message("Expected value to be a buffer. Received: " + fr.smart(r));
  },
  validator: function(e) {
    const { exception: t } = e;
    this.hasOwnProperty("maxLength") && this.maxLength % 4 !== 0 && t.at("maxLength").message("Byte format requires maxLength to be a multiple of 4"), this.hasOwnProperty("minLength") && this.minLength % 4 !== 0 && t.at("minLength").message("Byte format requires minLength to be a multiple of 4");
  }
};
ec.date = {
  constructors: [Date],
  deserialize: function({ exception: e, value: t }) {
    if (t instanceof Date)
      return t;
    if (typeof t != "string" || !ns.date.test(t))
      e.message("Expected a date string of the format YYYY-MM-DD");
    else {
      const r = fr.getDateFromValidDateString("date", t);
      if (!r)
        e.message("Value is not a valid date");
      else
        return r;
    }
  },
  isNumeric: !0,
  random: PP,
  serialize: function({ exception: e, value: t }) {
    const r = t;
    if (typeof t === "string" && (ns.date.test(t) || ns.dateTime.test(t)) && (t = new Date(t)), fr.isDate(t))
      return t.toISOString().substr(0, 10);
    e.message("Expected a valid Date instance or date formatted string. Received: " + fr.smart(r));
  },
  validate: function({ exception: e, schema: t, value: r }) {
    fr.isDate(r) ? fr.validateMaxMin(e, t, t.format, "maximum", "minimum", !1, r, t.maximum, t.minimum) : e.message("Expected a valid date object. Received: " + fr.smart(r));
  },
  validator: function(e) {
    const { exception: t } = e;
    this.hasOwnProperty("maxLength") && this.maxLength !== 10 && t.at("maxLength").message("Date format requires maxLength to equal 10"), this.hasOwnProperty("minLength") && this.minLength % 4 !== 0 && t.at("minLength").message("Date format requires minLength to equal 10");
  }
};
ec.dateTime = {
  constructors: [Date],
  deserialize: function({ exception: e, value: t }) {
    if (t instanceof Date)
      return t;
    if (typeof t != "string" || !ns.dateTime.test(t))
      e.message("Expected a date-time string of the format YYYY-MM-DDThh:mm:ss.sssZ");
    else {
      const r = fr.getDateFromValidDateString("date-time", t);
      if (!r)
        e.message("Expected a date-time string of the format YYYY-MM-DDThh:mm:ss.sssZ");
      else
        return r;
    }
  },
  isNumeric: !0,
  random: PP,
  serialize: function({ exception: e, value: t }) {
    const r = t;
    if (typeof t === "string" && (ns.date.test(t) || ns.dateTime.test(t)) && (t = new Date(t)), fr.isDate(t))
      return t.toISOString();
    e.message("Expected a valid Date instance or an ISO date formatted string. Received: " + fr.smart(r));
  },
  validate: function({ exception: e, schema: t, value: r }) {
    fr.isDate(r) ? fr.validateMaxMin(e, t, t.format, "maximum", "minimum", !1, r, t.maximum, t.minimum) : e.message("Expected a valid date object. Received: " + fr.smart(r));
  },
  validator: function(e) {
    const { exception: t } = e;
    this.hasOwnProperty("maxLength") && this.maxLength !== 10 && t.at("maxLength").message("Date-time format requires maxLength to equal 24"), this.hasOwnProperty("minLength") && this.minLength % 4 !== 0 && t.at("minLength").message("Date-time format requires minLength to equal 24");
  }
};
function OP(e) {
  return function({ schema: t }, { randomNumber: r }) {
    const i = t.hasOwnProperty("minLength"), n = t.hasOwnProperty("maxLength"), s = {};
    i && n ? (s.min = t.minLength / e, s.max = t.maxLength / e) : i ? (s.min = +t.minLength / e, s.max = s.min + 25) : n ? (s.max = +t.maximum / e, s.min = s.max - 25) : (s.min = 1, s.max = 25);
    const a = r(s), o = [];
    for (let c = 0; c < a; c++)
      o.push(Math.floor(Math.random() * 256));
    return qe.Buffer.from(o);
  };
}
function PP({ schema: e }, { randomNumber: t }) {
  const i = e.hasOwnProperty("minimum"), n = e.hasOwnProperty("maximum"), s = {
    exclusiveMinimum: e.exclusiveMinimum,
    exclusiveMaximum: e.exclusiveMaximum
  };
  i && n ? (s.min = +e.minimum, s.max = +e.maximum) : i ? (s.min = +e.minimum, s.max = s.min + 157248e6) : n ? (s.max = +e.maximum, s.min = s.max - 157248e6) : (s.min = Date.now() - 78624e6, s.max = Date.now() + 78624e6);
  const a = t(s);
  if (a !== void 0)
    return new Date(a);
}
function Bn(e) {
  if (typeof e != "string")
    throw new TypeError("Path must be a string. Received " + JSON.stringify(e));
}
function s$(e, t) {
  for (var r = "", i = 0, n = -1, s = 0, a, o = 0; o <= e.length; ++o) {
    if (o < e.length)
      a = e.charCodeAt(o);
    else {
      if (a === 47)
        break;
      a = 47;
    }
    if (a === 47) {
      if (!(n === o - 1 || s === 1))
        if (n !== o - 1 && s === 2) {
          if (r.length < 2 || i !== 2 || r.charCodeAt(r.length - 1) !== 46 || r.charCodeAt(r.length - 2) !== 46) {
            if (r.length > 2) {
              var c = r.lastIndexOf("/");
              if (c !== r.length - 1) {
                c === -1 ? (r = "", i = 0) : (r = r.slice(0, c), i = r.length - 1 - r.lastIndexOf("/")), n = o, s = 0;
                continue;
              }
            } else if (r.length === 2 || r.length === 1) {
              r = "", i = 0, n = o, s = 0;
              continue;
            }
          }
          t && (r.length > 0 ? r += "/.." : r = "..", i = 2);
        } else
          r.length > 0 ? r += "/" + e.slice(n + 1, o) : r = e.slice(n + 1, o), i = o - n - 1;
      n = o, s = 0;
    } else
      a === 46 && s !== -1 ? ++s : s = -1;
  }
  return r;
}
function ez(e, t) {
  var r = t.dir || t.root, i = t.base || (t.name || "") + (t.ext || "");
  return r ? r === t.root ? r + i : r + e + i : i;
}
var Ha = {
  // path.resolve([from ...], to)
  resolve: function() {
    for (var t = "", r = !1, i, n = arguments.length - 1; n >= -1 && !r; n--) {
      var s;
      n >= 0 ? s = arguments[n] : (i === void 0 && (i = qe.process.cwd()), s = i), Bn(s), s.length !== 0 && (t = s + "/" + t, r = s.charCodeAt(0) === 47);
    }
    return t = s$(t, !r), r ? t.length > 0 ? "/" + t : "/" : t.length > 0 ? t : ".";
  },
  normalize: function(t) {
    if (Bn(t), t.length === 0)
      return ".";
    var r = t.charCodeAt(0) === 47, i = t.charCodeAt(t.length - 1) === 47;
    return t = s$(t, !r), t.length === 0 && !r && (t = "."), t.length > 0 && i && (t += "/"), r ? "/" + t : t;
  },
  isAbsolute: function(t) {
    return Bn(t), t.length > 0 && t.charCodeAt(0) === 47;
  },
  join: function() {
    if (arguments.length === 0)
      return ".";
    for (var t, r = 0; r < arguments.length; ++r) {
      var i = arguments[r];
      Bn(i), i.length > 0 && (t === void 0 ? t = i : t += "/" + i);
    }
    return t === void 0 ? "." : Ha.normalize(t);
  },
  relative: function(t, r) {
    if (Bn(t), Bn(r), t === r || (t = Ha.resolve(t), r = Ha.resolve(r), t === r))
      return "";
    for (var i = 1; i < t.length && t.charCodeAt(i) === 47; ++i)
      ;
    for (var n = t.length, s = n - i, a = 1; a < r.length && r.charCodeAt(a) === 47; ++a)
      ;
    for (var o = r.length, c = o - a, l = s < c ? s : c, d = -1, p = 0; p <= l; ++p) {
      if (p === l) {
        if (c > l) {
          if (r.charCodeAt(a + p) === 47)
            return r.slice(a + p + 1);
          if (p === 0)
            return r.slice(a + p);
        } else
          s > l && (t.charCodeAt(i + p) === 47 ? d = p : p === 0 && (d = 0));
        break;
      }
      var h = t.charCodeAt(i + p), g = r.charCodeAt(a + p);
      if (h !== g)
        break;
      h === 47 && (d = p);
    }
    var m = "";
    for (p = i + d + 1; p <= n; ++p)
      (p === n || t.charCodeAt(p) === 47) && (m.length === 0 ? m += ".." : m += "/..");
    return m.length > 0 ? m + r.slice(a + d) : (a += d, r.charCodeAt(a) === 47 && ++a, r.slice(a));
  },
  _makeLong: function(t) {
    return t;
  },
  dirname: function(t) {
    if (Bn(t), t.length === 0)
      return ".";
    for (var r = t.charCodeAt(0), i = r === 47, n = -1, s = !0, a = t.length - 1; a >= 1; --a)
      if (r = t.charCodeAt(a), r === 47) {
        if (!s) {
          n = a;
          break;
        }
      } else
        s = !1;
    return n === -1 ? i ? "/" : "." : i && n === 1 ? "//" : t.slice(0, n);
  },
  basename: function(t, r) {
    if (r !== void 0 && typeof r != "string")
      throw new TypeError('"ext" argument must be a string');
    Bn(t);
    var i = 0, n = -1, s = !0, a;
    if (r !== void 0 && r.length > 0 && r.length <= t.length) {
      if (r.length === t.length && r === t)
        return "";
      var o = r.length - 1, c = -1;
      for (a = t.length - 1; a >= 0; --a) {
        var l = t.charCodeAt(a);
        if (l === 47) {
          if (!s) {
            i = a + 1;
            break;
          }
        } else
          c === -1 && (s = !1, c = a + 1), o >= 0 && (l === r.charCodeAt(o) ? --o === -1 && (n = a) : (o = -1, n = c));
      }
      return i === n ? n = c : n === -1 && (n = t.length), t.slice(i, n);
    } else {
      for (a = t.length - 1; a >= 0; --a)
        if (t.charCodeAt(a) === 47) {
          if (!s) {
            i = a + 1;
            break;
          }
        } else
          n === -1 && (s = !1, n = a + 1);
      return n === -1 ? "" : t.slice(i, n);
    }
  },
  extname: function(t) {
    Bn(t);
    for (var r = -1, i = 0, n = -1, s = !0, a = 0, o = t.length - 1; o >= 0; --o) {
      var c = t.charCodeAt(o);
      if (c === 47) {
        if (!s) {
          i = o + 1;
          break;
        }
        continue;
      }
      n === -1 && (s = !1, n = o + 1), c === 46 ? r === -1 ? r = o : a !== 1 && (a = 1) : r !== -1 && (a = -1);
    }
    return r === -1 || n === -1 || // We saw a non-dot character immediately before the dot
    a === 0 || // The (right-most) trimmed path component is exactly '..'
    a === 1 && r === n - 1 && r === i + 1 ? "" : t.slice(r, n);
  },
  format: function(t) {
    if (t === null || typeof t != "object")
      throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof t);
    return ez("/", t);
  },
  parse: function(t) {
    Bn(t);
    var r = { root: "", dir: "", base: "", ext: "", name: "" };
    if (t.length === 0)
      return r;
    var i = t.charCodeAt(0), n = i === 47, s;
    n ? (r.root = "/", s = 1) : s = 0;
    for (var a = -1, o = 0, c = -1, l = !0, d = t.length - 1, p = 0; d >= s; --d) {
      if (i = t.charCodeAt(d), i === 47) {
        if (!l) {
          o = d + 1;
          break;
        }
        continue;
      }
      c === -1 && (l = !1, c = d + 1), i === 46 ? a === -1 ? a = d : p !== 1 && (p = 1) : a !== -1 && (p = -1);
    }
    return a === -1 || c === -1 || // We saw a non-dot character immediately before the dot
    p === 0 || // The (right-most) trimmed path component is exactly '..'
    p === 1 && a === c - 1 && a === o + 1 ? c !== -1 && (o === 0 && n ? r.base = r.name = t.slice(1, c) : r.base = r.name = t.slice(o, c)) : (o === 0 && n ? (r.name = t.slice(1, a), r.base = t.slice(1, c)) : (r.name = t.slice(o, a), r.base = t.slice(o, c)), r.ext = t.slice(a, c)), o > 0 ? r.dir = t.slice(0, o - 1) : n && (r.dir = "/"), r;
  },
  sep: "/",
  delimiter: ":",
  win32: null,
  posix: null
};
Ha.posix = Ha;
var tz = Ha;
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
const rz = ["value", "error", "warning"];
var hs = Mu;
function Mu(e, t, r) {
  if (!(this instanceof Mu))
    return new Mu(e, t, r);
  (!t || !t.hasException) && (t = void 0), (!r || !r.hasException) && (r = void 0), t && (e = void 0), this.error = t, this.value = e, this.warning = r, this.__iterableIndex = -1;
}
Mu.prototype[Symbol.iterator] = function() {
  return this;
};
Mu.prototype.next = function() {
  return this.__iterableIndex++, this.__iterableIndex > 2 && (this.__iterableIndex = 0), {
    done: !1,
    value: this[rz[this.__iterableIndex]]
  };
};
const v0 = Nn, nz = tO, Nu = tz, yf = hs, SP = Ou, AP = Yt, a$ = gr, iz = gO, sz = Df, Hy = /^https?:\/\//i, az = /\.ya?ml$/i, oz = /\.json$/i;
var CP = po;
const rc = /* @__PURE__ */ new WeakMap();
function po(e) {
  this.$refs = {}, rc.set(this, {
    bundled: null,
    dereferenced: null,
    // will hold dereference() returned EnforcerResult
    loads: {},
    // a map of loaded resources
    refs: this.$refs,
    sourceMap: { "": [] },
    // a map of source paths to nodes within the source
    source: e
  });
}
po.prototype.bundle = async function() {
  const e = rc.get(this);
  if (e.bundled) {
    const { value: s, error: a, warning: o } = e.bundled;
    return new yf(s, a, o);
  }
  const t = new v0("Unable to bundle definition for one or more reasons"), [r, i] = await this.dereference(), n = AP.copy(r);
  if (i)
    t.push(i);
  else {
    const s = Gy(n, null, "", "#", []), a = Array.from(s.keys()).map((l) => {
      const d = s.get(l);
      return { node: l, refs: d };
    }).filter((l) => l.refs.length > 1), c = cz(n) === 2 ? ["definitions", "parameters", "responses", "securityDefinitions", "security", "tags", "externalDocs"] : ["components/schemas", "components/responses", "components/parameters", "components/examples", "components/requestBodies", "components/headers", "components/securitySchemes", "components/links", "components/callbacks", "components", "security", "servers", "tags", "externalDocs"];
    a.forEach((l) => {
      const d = l.refs;
      d.sort((p, h) => {
        const g = p.path, m = h.path;
        let v = c.findIndex((y) => g.startsWith("#/" + y)), _ = c.findIndex((y) => m.startsWith("#/" + y));
        return v === -1 && (v = Number.MAX_SAFE_INTEGER), _ === -1 && (_ = Number.MAX_SAFE_INTEGER), v < _ ? -1 : v > _ ? 1 : g.split("/").length < m.split("/").length ? -1 : 1;
      }), l.ref = d[0];
    }), a.sort((l, d) => l.ref.pathLength > d.ref.pathLength ? -1 : 1), a.forEach((l) => {
      const d = l.refs, p = d.length;
      for (let h = 1; h < p; h++) {
        const g = d[h];
        g.parent[g.key] = { $ref: l.ref.path };
      }
    });
  }
  return e.bundled = new yf(n, t), e.bundled;
};
po.prototype.dereference = async function() {
  const e = rc.get(this);
  if (e.dereferenced) {
    const { value: s, error: a, warning: o } = e.dereferenced;
    return new yf(s, a, o);
  }
  const t = new v0("Unable to dereference definition for one or more reasons"), { source: r } = e, i = qe.process.cwd();
  let n;
  if (typeof r == "string") {
    const s = await TP(i, r, t, e);
    n = await qa(Nu.dirname(s.path), s.path, s.value, s.value, e, /* @__PURE__ */ new Map(), [], t.at(s.path)), e.refs[s.path] = n;
  } else {
    const s = AP.copy(r);
    n = await qa(i, "", s, s, e, /* @__PURE__ */ new Map(), [], t.at("root object")), e.refs[""] = n;
  }
  return e.dereferenced = new yf(n, t), e.dereferenced;
};
po.prototype.getSourceNode = function(e) {
  const t = this.getSourcePath(e);
  return this.$refs[t];
};
po.prototype.getSourcePath = function(e) {
  const t = rc.get(this);
  RP(t);
  const r = t.sourceMap, i = Object.keys(r), n = i.length;
  for (let s = 0; s < n; s++) {
    const a = i[s];
    if (r[a].includes(e))
      return a;
  }
};
po.prototype.resolvePath = function(e, t) {
  const r = rc.get(this);
  RP(r);
  const i = new v0("Could not resolve path from node"), [n, s] = t.split("#");
  let a;
  if (!n)
    a = gf(e, s, i);
  else {
    const o = this.getSourcePath(e);
    if (!o)
      i.message("Unable to resolve source path for provided node.");
    else {
      const c = Nu.dirname(o), l = Hy.test(c) ? SP.resolve(c, n) : Nu.resolve(c, n);
      this.$refs.hasOwnProperty(l) ? a = gf(this.$refs[l], s, i) : i.message("Unable to resolve paths that were not already resolved during dereference.");
    }
  }
  if (i.hasException)
    throw Error(i.toString());
  return a;
};
function uz() {
  const e = {};
  return e.promise = new Promise((t, r) => {
    e.resolve = t, e.reject = r;
  }), e;
}
function RP(e) {
  if (!e.dereferenced)
    throw Error("You must first call the dereference function before looking up node source.");
  if (e.dereferenced.error)
    throw Error("Cannot get source for a node when dereference has failed.");
}
function Gy(e, t, r, i, n, s = /* @__PURE__ */ new Map()) {
  if (e && typeof e == "object") {
    if (n.includes(e))
      return;
    n = n.slice(), n.push(e);
    const a = {
      key: r,
      parent: t,
      path: i,
      pathLength: n.length
    }, o = s.get(e);
    if (o)
      return o.push(a), s;
    s.set(e, [a]), Array.isArray(e) ? e.forEach((c, l) => {
      Gy(c, e, l, i + "/" + l, n, s);
    }) : Object.keys(e).forEach((c) => {
      Gy(e[c], e, c, i + "/" + c.replace(/~/g, "~0").replace(/\//g, "~1"), n, s);
    });
  }
  return s;
}
function cz(e) {
  if (e) {
    if (e.swagger)
      return 2;
    if (e.openapi) {
      const t = e.openapi.split(".")[0];
      if (/^\d$/.test(t))
        return +t;
    }
  }
}
async function qa(e, t, r, i, n, s, a, o) {
  if (Array.isArray(i)) {
    if (s.has(i))
      return s.get(i);
    s.set(i, i), n.sourceMap[t].push(i);
    const l = i.map(async (d, p) => {
      i[p] = await qa(e, t, r, d, n, s, a, o.at(String(p)));
    });
    return await Promise.all(l), i;
  } else if (i && typeof i == "object")
    if (i.hasOwnProperty("$ref") && typeof i.$ref == "string") {
      if (a.includes(i)) {
        o.message("Unresolvable infinite loop");
        return;
      }
      const [, l] = i.$ref.split("#");
      let d = e, p = t, h = r, g;
      if (i.$ref.startsWith("#/"))
        g = gf(r, l, o);
      else {
        const m = await TP(e, i.$ref, o, n), v = o.at(m.path);
        p = m.path, d = Nu.dirname(p), h = await qa(d, p, m.value, m.value, n, s, a, v), n.refs[m.path] = h, g = h ? gf(h, l, v) : void 0;
      }
      return g = await qa(d, p, h, g, n, s, a.concat([i]), o), g;
    } else {
      const c = s.get(i);
      if (c)
        return c;
      s.set(i, i), n.sourceMap[t].push(i);
      const l = Object.keys(i).map(async (d) => {
        i[d] = await qa(e, t, r, i[d], n, s, a, o.at(d));
      });
      return await Promise.all(l), i;
    }
  else
    return i;
}
async function TP(e, t, r, i) {
  const { loads: n, sourceMap: s } = i, { loadPath: a, loadMethod: o } = dz(e, t);
  if (n[a])
    return n[a];
  const c = uz();
  n[a] = c.promise;
  const l = await o(a, r.at(a));
  return s[a] = [], c.resolve({
    path: a,
    value: l
  }), c.promise;
}
function lz(e, t) {
  return new Promise((r, i) => {
    const s = (e.startsWith("https") ? iz : sz).request(e, {}, (a) => {
      if (a.statusCode < 200 || a.statusCode >= 300)
        t.message("Request failed with status code " + a.statusCode), r();
      else {
        const o = a.headers["content-type"];
        let c;
        /^application\/json/.test(o) && (c = "json"), /^(?:text|application)\/(?:x-)?yaml/.test(o) && (c = "yaml");
        let l = "";
        a.setEncoding("utf8"), a.on("data", (d) => {
          l += d;
        }), a.on("end", () => {
          const d = IP(l, c, t.nest("Unable to parse resource: " + e));
          r(d.value);
        }), a.on("error", (d) => {
          t.message("Unexpected error: " + d.message), r();
        });
      }
    });
    s.on("error", i), s.end();
  });
}
function fz(e, t) {
  return new Promise((r) => {
    nz.readFile(e, "utf8", (i, n) => {
      if (i && (i.code === "ENOENT" || i.code === "ENOTDIR"))
        t.message("Unable to find referenced file: " + e), r();
      else if (i)
        t.message('Unable to read file "' + e + '": ' + i.toString()), r();
      else {
        let s;
        oz.test(e) && (s = "json"), az.test(e) && (s = "yaml");
        const a = IP(n, s, t.nest("Unable to parse file: " + e));
        r(a.value);
      }
    });
  });
}
function IP(e, t, r) {
  let i;
  if (t === "json")
    try {
      i = JSON.parse(e);
    } catch (n) {
      r.message(n.toString());
    }
  else if (t === "yaml")
    try {
      i = a$.load(e);
    } catch (n) {
      r.message(n.toString());
    }
  else
    try {
      i = JSON.parse(e), t = "json";
    } catch {
      try {
        i = a$.load(e), t = "yaml";
      } catch {
        r.message("Not valid JSON or YAML");
      }
    }
  return {
    type: t,
    value: i
  };
}
function dz(e, t) {
  const [r] = t.split("#");
  return Hy.test(e) || Hy.test(t) ? {
    loadPath: SP.resolve(e, r),
    loadMethod: lz
  } : {
    loadPath: Nu.resolve(e, r),
    loadMethod: fz
  };
}
function gf(e, t, r) {
  if (!t)
    return e;
  if (!t.startsWith("/")) {
    r.message("References must start with #/");
    return;
  }
  const i = t.substring(1).split("/");
  let n = e;
  for (; i.length; ) {
    const s = i.shift().replace(/~1/g, "/").replace(/~0/g, "~");
    if (s !== "#")
      if (n && typeof n == "object" && s in n)
        n = n[s];
      else {
        r.message("Cannot resolve reference: #" + t);
        return;
      }
  }
  return n;
}
function pz(e) {
  throw new Error('Could not dynamically require "' + e + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var rr = Du;
function Du(e, t) {
  if (!(this instanceof Du))
    return new Du(e, t);
  this.config = t, this.value = e;
}
Du.isEnforcerRef = function(e) {
  return typeof e == "object" && e instanceof Du;
};
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
const Nl = rr, Ji = Yt, hz = /^x-.+/;
var mz = vf;
function eu(e, t, r) {
  const i = e.definition[t], n = !e.production, s = Ji.getDefinitionType(i);
  let a;
  return s === "array" ? a = [] : s === "object" ? a = {} : a = i, {
    context: e.context,
    definition: i,
    definitionType: s,
    defToInstanceMap: e.defToInstanceMap,
    exception: n ? e.exception.at(t) : e.exception,
    key: t,
    major: e.major,
    map: e.map,
    minor: e.minor,
    options: e.options,
    parent: e,
    patch: e.patch,
    plugins: e.plugins,
    production: e.production,
    refParser: e.refParser,
    result: a,
    root: e.root,
    staticData: null,
    usedDefault: !1,
    validator: r,
    warn: n ? e.warn.at(t) : e.warn
  };
}
function vf(e, t, r) {
  const { definitionType: i, exception: n, production: s, result: a } = e, o = r.exceptionSkipCodes;
  let c = e.definition;
  try {
    const l = Tr(e.validator, e), d = l.freeForm;
    if (!jP(i, e))
      return;
    if (c && typeof c == "object") {
      const h = yz(e);
      if (h)
        return h.value;
      Ho(e, a);
    }
    if (s)
      i === "array" ? (c.forEach((h, g) => {
        const m = eu(e, g, l.items);
        a.push(Go(m, t, r));
      }), Object.freeze(a)) : i === "object" ? (Object.keys(c).forEach((g) => {
        let m;
        typeof l != "object" ? m = l : l.properties && l.properties.hasOwnProperty(g) ? m = l.properties[g] : l.additionalProperties && (m = l.additionalProperties);
        const v = eu(e, g, m);
        Object.defineProperty(a, g, {
          configurable: !0,
          enumerable: !0,
          value: Go(v, t, r)
        });
      }), o$(l, e).forEach(({ data: g }) => {
        const m = g.key;
        if (!a.hasOwnProperty(m)) {
          const v = g.validator, _ = Nl.isEnforcerRef(v) ? v.config || {} : v;
          if ((_.hasOwnProperty("allowed") ? Tr(_.allowed, g) : !0) && _.hasOwnProperty("default")) {
            const w = Tr(_.default, g);
            Object.defineProperty(a, m, {
              configurable: !0,
              enumerable: !0,
              value: w
            });
          }
        }
      })) : (e.result = c, Ho(e, c));
    else {
      if (l.enum) {
        const h = Tr(l.enum, e);
        h.includes(c) || (h.length === 1 ? n.message("Value must be " + Ji.smart(h[0]) + ". Received: " + Ji.smart(c)) : n.message("Value must be one of: " + h.join(", ") + ". Received: " + Ji.smart(c)));
      }
      if (i === "array" && !d)
        c.forEach((h, g) => {
          const m = eu(e, g, l.items);
          a.push(Go(m, t, r));
        }), Object.freeze(a);
      else if (i === "object" && !d) {
        const h = [], g = [], m = [];
        l === !0 ? Object.keys(c).forEach((v) => {
          Object.defineProperty(a, v, {
            configurable: !0,
            enumerable: !0,
            value: c[v]
          });
        }) : l === !1 ? g.push.apply(g, Object.keys(c)) : l.additionalProperties ? Object.keys(c).forEach((v) => {
          const _ = eu(e, v, l.additionalProperties), y = Nl.isEnforcerRef(_.validator) ? _.validator.config || {} : _.validator, w = y.hasOwnProperty("allowed") ? Tr(y.allowed, _) : !0;
          let $ = !1;
          if (_.definition !== void 0 && (w ? (!y.ignored || !Tr(y.ignored, _)) && (Object.defineProperty(a, v, {
            configurable: !0,
            enumerable: !0,
            value: Go(_, t, r)
          }), $ = !0) : g.push(v)), $ && y.errors && y !== _.validator) {
            const E = Object.assign({}, _);
            E.definition = a[v], Tr(y.errors, E);
          }
        }) : (Object.keys(c).forEach((_) => {
          hz.test(_) ? Object.defineProperty(a, _, {
            configurable: !0,
            enumerable: !0,
            value: c[_]
          }) : m.push(_);
        }), o$(l, e).forEach((_) => {
          const y = _.data, w = y.key, $ = y.validator, E = Nl.isEnforcerRef($) ? $.config || {} : $, S = E.hasOwnProperty("allowed") ? Tr(E.allowed, y) : !0;
          if (Ji.arrayRemoveItem(m, w), y.definition === void 0 && S && E.hasOwnProperty("default")) {
            const R = Tr(E.default, y);
            R !== void 0 && (y.definition = R, y.usedDefault = !0, y.parent.definition[w] = y.definition, y.definitionType = Ji.getDefinitionType(y.definition));
          }
          y.definition !== void 0 ? S ? (!E.ignored || !Tr(E.ignored, y)) && Object.defineProperty(a, w, {
            configurable: !0,
            enumerable: !0,
            value: Go(y, t, r)
          }) : g.push(w) : S && E.required && Tr(E.required, y) && h.push(w);
        })), g.push.apply(g, m), g.length && !o.EDEV001 && !Ji.schemaObjectHasSkipCode(c, "EDEV001") && (g.sort(), n.message("Propert" + (g.length === 1 ? "y" : "ies") + " not allowed: " + g.join(", ") + " [EDEV001]")), h.length && (h.sort(), n.message("Missing required propert" + (h.length === 1 ? "y" : "ies") + ": " + h.join(", ")));
      } else if (d)
        e.result = c, Ho(e, c);
      else
        switch (i) {
          case "boolean":
          case "null":
          case "number":
          case "string":
            e.result = c, Ho(e, c);
            break;
          default:
            n.message("Unknown data type provided");
            break;
        }
    }
    let p = e.definition;
    if (l.deserialize) {
      const h = Object.assign({}, e);
      p = l.deserialize(h), e.result = p, Ho(e, c);
    }
    if (!s && l.errors) {
      const h = Object.assign({}, e);
      h.definition = p, Tr(l.errors, h);
    }
  } catch (l) {
    n.message("Unexpected error encountered: " + l.stack);
  }
  return e.result;
}
vf.isValidatorState = function(e) {
  return e instanceof kP;
};
function Wo(e) {
  return e === "array" ? "an array" : e === "object" ? "a plain object" : "a " + e;
}
function Tr(e, t) {
  if (typeof e == "function")
    try {
      return e(t);
    } catch (r) {
      t.exception.message("Unexpected error encountered: " + r.stack);
    }
  else
    return e;
}
function o$(e, t) {
  const r = Object.keys(e.properties || {}).map((i) => {
    const n = e.properties[i];
    return {
      data: eu(t, i, n),
      weight: n.weight || 0
    };
  });
  return r.sort((i, n) => i.weight < n.weight ? -1 : i.weight > n.weight ? 1 : i.data.key < n.data.key ? -1 : 1), r;
}
function yz(e) {
  const { definition: t, map: r, validator: i } = e, n = r.get(t);
  if (!n)
    return;
  let s = n.find((a) => a.validator === i);
  return s ? s.value : void 0;
}
function Ho(e, t) {
  const { definition: r, map: i, validator: n } = e;
  let s = i.get(r);
  s || (s = [], i.set(r, s));
  const a = s.find((o) => o.validator === n);
  a ? a.value = t : s.push({ validator: n, value: t });
}
function Go(e, t, r) {
  const i = Tr(e.validator, e);
  if (e.validator = i, Nl.isEnforcerRef(i)) {
    const n = e.validator.config;
    if (e.definitionType === "boolean")
      return e.validator = e.validator.config, vf(e, t, r);
    if (!n || jP(e.definitionType, Object.assign({}, e, { validator: n })))
      return new e.context[i.value](new kP(e), t, r);
  } else
    return e.validator ? vf(e, t, r) : e.result;
}
function jP(e, t) {
  const { definition: r, exception: i } = t, n = Tr(t.validator, t);
  if (!t.production && n.type && r !== void 0) {
    let s = Tr(n.type, t);
    if (Array.isArray(s) || (s = [s]), s = s.map((c) => c === "integer" ? "number" : c), s.includes("any") || s.includes(e))
      return !0;
    const a = s.length;
    let o;
    if (a === 1)
      o = Wo(s[0]);
    else if (a === 2)
      o = Wo(s[0]) + " or " + Wo(s[1]);
    else {
      const c = s.pop();
      o = s.map((l) => Wo(l)).join(", ") + ", or " + Wo(c);
    }
    return i.message("Value must be " + o + ". Received: " + Ji.smart(r)), !1;
  } else
    return !0;
}
function kP(e) {
  Object.assign(this, e);
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var gz = vz;
const Hh = mz, u$ = Nn, c$ = hs, ll = Yt, l$ = { post: !0, put: !0, options: !0, head: !0, patch: !0 };
function vz(e, t, r) {
  return r || (r = pz("./enforcers/" + t)), bz(e, t, r);
}
function bz(e, t, r) {
  const i = [], n = /* @__PURE__ */ new WeakMap(), s = new Function(
    "build",
    `const F = function ${t} (definition, refParser, options) {
            if (!(this instanceof F)) return new F(definition, refParser, options)
            return build(this, definition, refParser, options)
        }
        return F`
  )(o);
  s.prototype = Object.assign({}, r.prototype || {}), s.constructor = s, Object.defineProperty(s, "enforcerDefinition", {
    value: r
  }), Object.defineProperty(s.prototype, "enforcerData", {
    get: function() {
      return n.get(this);
    }
  }), s.prototype.toObject = function() {
    return c(this, /* @__PURE__ */ new Map());
  }, s.extend = function(l) {
    if (typeof l != "function")
      throw Error("Invalid input. Callback must be a function. Received: " + l);
    i.push(l);
  };
  const a = {};
  if (r.statics) {
    const l = r.statics(a);
    Object.keys(l).forEach((d) => {
      s[d] = l[d];
    });
  }
  function o(l, d, p, h = {}) {
    const g = !Hh.isValidatorState(d);
    h || (h = {}), g && (h = Object.assign({}, h)), h.requestBodyAllowedMethods = h.hasOwnProperty("requestBodyAllowedMethods") ? Object.assign({}, l$, h.requestBodyAllowedMethods) : l$, h.disablePathNormalization = h.hasOwnProperty("disablePathNormalization") ? !!h.disablePathNormalization : !1, h.apiSuggestions = h.hasOwnProperty("apiSuggestions") ? !!h.apiSuggestions : !0, h.production = !!h.production, h.exceptionSkipCodes = h.hasOwnProperty("exceptionSkipCodes") ? Array.isArray(h.exceptionSkipCodes) ? h.exceptionSkipCodes.reduce((y, w) => (y[w] = !0, y), {}) : h.exceptionSkipCodes : {}, h.exceptionEscalateCodes = h.hasOwnProperty("exceptionEscalateCodes") ? Array.isArray(h.exceptionEscalateCodes) ? h.exceptionEscalateCodes.reduce((y, w) => (y[w] = !0, y), {}) : h.exceptionEscalateCodes : {};
    let m;
    if (g) {
      const y = /^(\d+)(?:\.(\d+))(?:\.(\d+))?$/.exec(e.version);
      p || (d = ll.copy(d)), m = {
        context: e,
        definition: d,
        defToInstanceMap: /* @__PURE__ */ new WeakMap(),
        definitionType: ll.getDefinitionType(d),
        exception: u$("One or more errors exist in the " + t + " definition"),
        key: void 0,
        map: /* @__PURE__ */ new Map(),
        major: +y[1],
        minor: +y[2],
        parent: null,
        patch: +(y[3] || 0),
        plugins: [],
        production: h.production,
        refParser: p,
        result: l,
        staticData: a,
        validator: r.validator,
        warn: u$("One or more warnings exist in the " + t + " definition"),
        options: h
      }, m.root = m;
    } else
      m = d, m.staticData = a, m.validator = r.validator, m.result = l;
    const v = m.map.get(m.definition), _ = v ? v.find((y) => y.validator === m.validator) : void 0;
    if (_)
      m.result = l = _.value, Hh(m, p, h);
    else {
      if (n.set(l, m), m.definition && typeof m.definition == "object" && m.defToInstanceMap.set(m.definition, l), ll.isPlainObject(m.definition) ? Hh(m, p, h) : m.exception.message("Value must be a plain object"), m.exception.hasException && g)
        return new c$(void 0, m.exception, m.warn);
      r.init && r.init.call(l, m);
      const y = m.plugins;
      i.forEach((w) => y.push(function() {
        w.call(l, {
          enforcers: e,
          exception: m.exception,
          key: m.key,
          major: m.major,
          minor: m.minor,
          parent: m.parent && m.parent.result || null,
          patch: m.patch,
          root: m.root.result,
          warn: m.warn
        });
      }));
    }
    if (g)
      for (; m.plugins.length; )
        m.plugins.shift()();
    return g ? new c$(l, m.exception, m.warn) : l;
  }
  function c(l, d) {
    if (Array.isArray(l)) {
      const p = d.get(l);
      if (p)
        return p;
      const h = [];
      return d.set(l, h), l.forEach((g) => {
        h.push(c(g, d));
      }), h;
    } else if (ll.isPlainObject(l)) {
      const p = d.get(l);
      if (p)
        return p;
      const h = {};
      return d.set(l, h), Object.keys(l).forEach((g) => {
        h[g] = c(l[g], d);
      }), h;
    } else
      return l;
  }
  return s;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var Gh, f$;
function d$() {
  return f$ || (f$ = 1, Gh = {
    init: function(e) {
    },
    prototype: {},
    validator: function() {
      return {
        type: "object",
        properties: {
          name: {
            type: "string"
          },
          url: {
            type: "string"
          },
          email: {
            type: "string"
          }
        }
      };
    }
  }), Gh;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var Kh, p$;
function h$() {
  return p$ || (p$ = 1, Kh = {
    init: function(e) {
    },
    prototype: {},
    validator: function(e) {
      return {
        type: "object",
        properties: {
          description: "string",
          url: {
            type: "string",
            required: !0
          }
        }
      };
    }
  }), Kh;
}
var fl = {};
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var m$;
function MP() {
  if (m$)
    return fl;
  m$ = 1;
  const e = rr, t = [
    "default",
    "enum",
    "exclusiveMaximum",
    "exclusiveMinimum",
    "format",
    "items",
    "maximum",
    "maxItems",
    "maxLength",
    "minimum",
    "minItems",
    "minLength",
    "multipleOf",
    "pattern",
    "type",
    "uniqueItems"
  ];
  fl.extractSchemaDefinition = r, fl.validator = (i) => {
    const { major: n } = i, s = {
      type: "object"
    };
    return n === 2 ? (s.properties = {}, Object.assign(s.properties, {
      type: {
        weight: -15,
        required: !0,
        enum: ["array", "boolean", "integer", "number", "string"]
      },
      collectionFormat: {
        allowed: ({ parent: a }) => a.definition.type === "array",
        enum: ["csv", "ssv", "tsv", "pipes"],
        default: "csv"
      },
      default: { allowed: !0 },
      description: {
        type: "string"
      },
      enum: {
        allowed: !0,
        type: "array",
        items: { freeForm: !0 }
      },
      exclusiveMaximum: { allowed: !0 },
      exclusiveMinimum: { allowed: !0 },
      format: { allowed: !0 },
      items: {
        type: "object",
        allowed: ({ parent: a }) => a.definition.type === "array",
        required: ({ parent: a }) => a.definition.type === "array",
        properties: s.properties,
        errors: s.errors
      },
      maximum: { allowed: !0 },
      maxItems: { allowed: !0 },
      maxLength: { allowed: !0 },
      minimum: { allowed: !0 },
      minItems: { allowed: !0 },
      minLength: { allowed: !0 },
      multipleOf: { allowed: !0 },
      pattern: { allowed: !0 },
      uniqueItems: { allowed: !0 }
    }), s.errors = () => {
    }) : n === 3 && (s.properties = {
      content: {
        type: "object",
        additionalProperties: e("MediaType"),
        errors: ({ exception: a, definition: o }) => {
          const c = Object.keys(o);
          c.length !== 1 && a.message("Value must have exactly one key. Received: " + c.join(", "));
        }
      },
      deprecated: {
        type: "boolean"
      },
      description: {
        type: "string"
      },
      example: { allowed: !0, freeForm: !0 },
      examples: {
        type: "object",
        additionalProperties: e("Example")
      },
      schema: e("Schema")
    }, s.errors = ({ exception: a, major: o, definition: c }) => {
      c.hasOwnProperty("content") && c.hasOwnProperty("schema") ? a.message('Cannot have both "content" and "schema" properties') : !c.hasOwnProperty("content") && !c.hasOwnProperty("schema") && a.message('Missing required property "content" or "schema"'), c.hasOwnProperty("example") && c.hasOwnProperty("examples") && a.message('Cannot have both "example" and "examples" properties');
    }), s;
  };
  function r(i, n) {
    return t.forEach((s) => {
      if (n.hasOwnProperty(s)) {
        const a = n[s];
        switch (s) {
          case "items":
            i[s] = r({}, a);
            break;
          default:
            i[s] = a;
            break;
        }
      }
    }), i;
  }
  return fl;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var Yh, y$;
function g$() {
  if (y$)
    return Yh;
  y$ = 1;
  const e = MP(), t = Nn, r = hs, i = Yt;
  Yh = {
    init: function(a) {
      const { context: o, exception: c, major: l, warn: d, options: p } = a;
      if (l === 2) {
        const h = e.extractSchemaDefinition({}, this), [g, m, v] = o.Schema(h);
        g && (this.schema = g), m && c.merge(m), v && d.merge(v);
      }
      i.validateExamples(this, c, d, p);
    },
    prototype: {
      stringify: function(a) {
        const { major: o } = this.enforcerData, c = this.schema, l = t("Unable to stringify value");
        if (o === 2)
          return new r(s(this, this, l, a), l);
        if (o === 3) {
          const d = c && c.type;
          let p;
          if (d === "array")
            p = a.map((h, g) => n(this, c.items, l.at(g), h)).join(",");
          else if (d === "object") {
            const h = [];
            Object.keys(a).forEach((g) => {
              const m = c.properties.hasOwnProperty(g) ? c.properties[g] : c.additionalProperties;
              let v = a[g];
              m !== !0 ? v = n(this, m, l.at(g), v) : typeof v != "string" && l.message("Unable to stringify value: " + i.smart(v)), typeof v == "string" && (this.explode ? h.push(g + "=" + v) : h.push(g, v));
            }), p = h.join(",");
          } else
            p = n(this, c, l, a);
          return new r(p, l);
        }
      }
    },
    validator: function(a) {
      const { major: o } = a, c = e.validator(a);
      return Object.assign(c.properties, {
        explode: {
          type: "boolean",
          default: !1
        },
        required: {
          type: "boolean",
          default: !1
        },
        style: {
          weight: -5,
          allowed: o === 3,
          type: "string",
          default: "simple",
          enum: ["simple"]
        }
      }), c;
    }
  };
  function n(a, o, c, l) {
    if (l === void 0) {
      if (a.allowEmptyValue)
        return "";
      c.message("Empty value not allowed");
    } else if (l === null) {
      if (o.nullable)
        return "null";
      c.message("Null value not allowed");
    } else if (o.type === "boolean") {
      if (l === !0)
        return "true";
      if (l === !1)
        return "false";
      c.message("Expected true or false. Received: " + i.smart(l));
    } else if (o.type === "integer" || o.type === "number") {
      if (typeof l == "number" && !isNaN(l))
        return String(l);
      const d = o.type === "integer" ? "an integer" : "a number";
      c.message("Expected " + d + ". Received: " + i.smart(l));
    } else {
      if (o.type === "string")
        return l;
      c.message("Unable to stringify value: " + i.smart(l));
    }
  }
  function s(a, o, c, l) {
    if (o.type === "array") {
      const d = l.map((p, h) => o.items ? s(a, o.items, c.at(h), p) : p);
      switch (o.collectionFormat) {
        case "csv":
          return d.join(",");
        case "pipes":
          return d.join("|");
        case "ssv":
          return d.join(" ");
        case "tsv":
          return d.join("	");
      }
    } else
      return n(a, o, c, l);
  }
  return Yh;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var Jh, v$;
function b$() {
  if (v$)
    return Jh;
  v$ = 1;
  const e = rr;
  return Jh = {
    init: function(t) {
    },
    prototype: {},
    validator: function() {
      return {
        type: "object",
        properties: {
          title: {
            required: !0,
            type: "string"
          },
          description: {
            type: "string"
          },
          termsOfService: {
            type: "string"
          },
          contact: e("Contact"),
          license: e("License"),
          version: {
            required: !0,
            type: "string"
          }
        }
      };
    }
  }, Jh;
}
var Xh = { exports: {} };
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var _$;
function w$() {
  return _$ || (_$ = 1, function(e) {
    e.exports = {
      init: function(t) {
      },
      prototype: {},
      validator: function(t) {
        return {
          type: "object",
          properties: {
            name: {
              required: !0,
              type: "string"
            },
            url: {
              type: "string"
            }
          },
          errors: function(r) {
            e.exports, r.validator;
          }
        };
      }
    };
  }(Xh)), Xh.exports;
}
var Qh = { exports: {} };
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var em, $$;
function ms() {
  if ($$)
    return em;
  $$ = 1;
  const { isPlainObject: e } = Yt;
  em = n;
  const t = !0, r = !0, i = !0;
  function n(a, o = {}) {
    if (!(this instanceof n))
      return new n(a, o);
    if (typeof a == "object" && a instanceof n && (o = {
      populate: o.populate === void 0 ? a.populate : o.populate,
      serialize: o.serialize === void 0 ? a.serialize : o.serialize,
      validate: o.validate === void 0 ? a.validate : o.validate
    }, a = a.value), !o || typeof o != "object")
      throw Error("Invalid enforcer value configuration");
    const { populate: c, serialize: l, validate: d } = o;
    this.populate = c, this.serialize = l, this.validate = d, this.value = a;
  }
  n.prototype.attributes = function() {
    return {
      populate: this.populate === void 0 ? t : this.populate,
      serialize: this.serialize === void 0 ? r : this.serialize,
      validate: this.validate === void 0 ? i : this.validate,
      value: this.value
    };
  }, n.inherit = function(a, o) {
    return typeof a == "object" && a instanceof n ? (a.populate === void 0 && o.populate !== void 0 && (a.populate = o.populate), a.serialize === void 0 && o.serialize !== void 0 && (a.serialize = o.serialize), a.validate === void 0 && o.validate !== void 0 && (a.validate = o.validate), a) : new n(a, o);
  }, n.extract = s, n.getAttributes = function(a) {
    return typeof a == "object" && a instanceof n ? a.attributes() : {
      populate: t,
      serialize: r,
      validate: i,
      value: a
    };
  };
  function s(a) {
    if (Array.isArray(a))
      return a.map((o) => s(o));
    if (e(a)) {
      const o = {};
      return Object.keys(a).forEach((c) => {
        o[c] = s(a[c]);
      }), o;
    } else
      return typeof a == "object" && a instanceof n ? a.value : a;
  }
  return em;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var E$;
function bf() {
  return E$ || (E$ = 1, function(e) {
    const t = rr, r = Nn, i = hs, n = Yt, s = ms(), a = ["body", "headers", "method", "path", "query"], o = /^\d+$/, c = /^\d+(?:\.\d+)?$/;
    e.exports = {
      init: function(m) {
        const { major: v, parent: _, plugins: y, root: w } = m;
        y.push(() => {
          this.parameters || (this.parameters = []), this.parametersMap = {}, _ && _.result && _.result.parameters && l(this.parametersMap, _.result.parameters), l(this.parametersMap, this.parameters), this.allParameters = [], Object.keys(this.parametersMap).forEach(($) => {
            const E = this.parametersMap[$];
            Object.keys(E).forEach((S) => {
              this.allParameters.push(E[S]);
            });
          }), v === 2 && !this.produces && w.result.produces && (this.produces = w.result.produces);
        });
      },
      prototype: {
        /**
         * The the possible response mime types for the response code and accepts string.
         * @param {string, number} code
         * @param {string} accepts The allowed media type string. Example: text/html, application/xhtml+xml, application/xml;q=0.9, text/*;q=0.8
         * @returns {EnforcerResult<string[]>}
         */
        getResponseContentTypeMatches: function(m, v) {
          const _ = new r("Unable to determine acceptable response content types"), y = this.responses[m] || this.responses.default;
          let w;
          return y ? this.produces ? (w = n.findMediaMatch(v, this.produces), w.length || (_.message("Operation does not produce acceptable type"), _.code = "NO_MATCH")) : y.content ? (w = n.findMediaMatch(v, Object.keys(y.content)), w.length || (_.message("Operation does not produce acceptable type"), _.code = "NO_MATCH")) : (_.message("Response mime types not defined"), _.code = "NO_TYPES_SPECIFIED") : (_.message("Invalid response code"), _.code = "NO_CODE"), new i(w, _);
        },
        /**
         * Take the input parameters and deserialize and validate them.
         * @param {object} request
         * @param {string|object} [request.body] The request body
         * @param {Object<string,string>} [request.headers={}] The request headers
         * @param {object} [request.path={}] The path and query string
         * @param {string} [request.query=''] The request query string.
         * @param {object} [options]
         * @param {boolean,string[]} [options.allowOtherQueryParameters=false] Allow query parameter data that is not specified in the OAS document
         * @param {boolean} [options.pathParametersProcessed=false] Set to true if the path parameters have already been parsed, deserialized, and validated
         */
        request: function(m, v) {
          if (v || (v = {}), v && typeof v != "object")
            throw Error("Invalid options. Expected an object. Received: " + v);
          if (v = Object.assign({}, v), v.hasOwnProperty("allowOtherQueryParameters") || (v.allowOtherQueryParameters = !1), v.allowOtherQueryParameters) {
            if (Array.isArray(v.allowOtherQueryParameters))
              v.allowOtherQueryParameters.length === 0 ? v.allowOtherQueryParameters = !1 : v.allowOtherQueryParameters.forEach((j) => {
                if (typeof j != "string")
                  throw Error("Invalid option allowOtherQueryParameters. The value must be a boolean or an array of strings.");
              });
            else if (typeof v.allowOtherQueryParameters != "boolean")
              throw Error("Invalid option allowOtherQueryParameters. The value must be a boolean or an array of strings.");
          }
          if (!m || typeof m != "object")
            throw Error("Invalid request. Expected a non-null object. Received: " + m);
          if (m = this.toRequestObject(m), m.hasOwnProperty("headers") || (m.headers = {}), m.hasOwnProperty("path") || (m.path = {}), m.hasOwnProperty("query") || (m.query = ""), !n.isObjectStringMap(m.headers))
            throw Error("Invalid request headers. Expected an object with string keys and string values");
          if (!v.pathParametersProcessed && !n.isObjectStringMap(m.path))
            throw Error("Invalid request path. Expected an object with string keys and string values");
          if (typeof m.query != "string")
            throw Error("Invalid request query. Expected a string");
          const _ = {
            header: n.lowerCaseObjectProperties(m.headers),
            path: m.path,
            query: n.parseQueryString(decodeURI(m.query))
          };
          m.body !== void 0 && (_.body = m.body);
          const y = _.header.cookie || "", w = m.query;
          _.cookie = y ? n.parseCookieString(y) : {}, delete _.header.cookie;
          const $ = r("Request has one or more errors");
          $.statusCode = 400;
          const E = this.parametersMap, S = {
            cookie: {},
            headers: {},
            path: m.path,
            query: {}
          };
          if (E.formData && (!m.body || typeof m.body != "object"))
            throw Error('Parameters in "formData" require that the provided body be a non-null object');
          if (v.pathParametersProcessed) {
            const j = [];
            if (Object.keys(m.path).forEach((L) => {
              E.path.hasOwnProperty(L) || j.push(L);
            }), j.length) {
              const L = "Received unexpected parameter" + (j.length === 1 ? "" : "s") + ": " + j.join(", ");
              $.nest("In path parameters").message(L);
            }
          }
          const R = ["cookie", "header", "query"];
          if (v.pathParametersProcessed || R.push("path"), E.formData && R.push("formData"), R.forEach((j) => {
            const L = j === "formData", K = L ? $.nest("In body") : $.nest("In " + j + " parameters"), ae = L ? "body" : j, ye = _[ae] || {}, xe = [], Pe = [], te = (() => {
              if (j === "cookie" || j === "header")
                return [];
              const pe = Object.keys(ye);
              if (j === "query") {
                const de = v.allowOtherQueryParameters;
                return Array.isArray(de) ? pe.filter((Ee) => !de.includes(Ee)) : de ? [] : pe;
              }
              return pe;
            })();
            if (E[j]) {
              const pe = {};
              Object.keys(E[j]).forEach((de) => {
                const Ee = E[j][de], Re = Ee.schema && Ee.schema.type;
                if (ye.hasOwnProperty(de)) {
                  n.arrayRemoveItem(te, de);
                  const _e = j === "query" ? Ee.parse(w, ye) : j === "cookie" ? Ee.parse(y, ye) : Ee.parse(ye[de]);
                  p(K.at(de), Ee.schema, _e, "", (ie) => pe[de] = ie);
                } else if (Ee.in === "query" && Ee.style === "form" && Ee.explode && Re === "object") {
                  const _e = Ee.parse(w, ye);
                  if (_e.error) {
                    const ie = new r("In " + j + ' parameter "' + de + '"');
                    ie.message(_e.error), Pe.push(ie);
                  } else
                    p(K.at(de), Ee.schema, _e, "", (ie) => {
                      Object.keys(ie).forEach((Y) => n.arrayRemoveItem(te, Y)), pe[de] = ie;
                    });
                } else if (Ee.in === "query" && Ee.style === "deepObject" && Re === "object") {
                  const _e = Ee.parse(w, ye);
                  if (_e.error) {
                    const ie = new r("In " + j + ' parameter "' + de + '"');
                    ie.push(_e.error), Pe.push(ie);
                  } else
                    p(K.at(de), Ee.schema, _e, "", (ie) => {
                      Object.keys(ie).forEach((Y) => n.arrayRemoveItem(te, de + "[" + Y + "]")), pe[de] = ie;
                    });
                } else
                  Ee.required && xe.push(de);
                !pe.hasOwnProperty(de) && Ee.schema.hasOwnProperty("default") && (pe[de] = n.copy(Ee.schema.default));
              }), S[ae === "header" ? "headers" : ae] = s.extract(pe);
            }
            if (te.length) {
              const pe = "Received unexpected parameter" + (te.length === 1 ? "" : "s") + ": " + te.join(", ");
              if (Pe.length) {
                const de = K.nest(pe).nest("Possible causes");
                Pe.forEach((Ee) => de.push(Ee));
              } else
                K.message(pe);
            }
            xe.length && K.message("Missing required parameter" + (xe.length > 1 ? "s" : "") + ": " + xe.join(", "));
          }), _.hasOwnProperty("body")) {
            let j = _.body;
            if (E.body) {
              const L = d(E);
              j = g(j, L.schema), p($.nest("In body"), L.schema, { value: j }, "write", (K) => {
                S.body = s.extract(K);
              });
            } else if (this.requestBody) {
              const { content: L, contentType: K, matches: ae } = h(this, _), ye = ae.length;
              if (ye) {
                const xe = new r("In body");
                let Pe = !1;
                for (let te = 0; te < ye; te++) {
                  const pe = ae[te], de = L[pe];
                  if (de.schema && (j = g(j, de.schema), p(xe.nest("For Content-Type " + pe), de.schema, { value: j }, "write", (Ee) => {
                    S.body = s.extract(Ee), Pe = !0;
                  })), K === pe || Pe)
                    break;
                }
                Pe || $.push(xe);
              } else
                $.message("Content-Type not accepted"), $.statusCode = 415;
            } else
              E.formData || $.message("Body is not allowed");
          } else if (E.body && d(E).required)
            $.message("Missing required parameter: body");
          else if (this.requestBody && this.requestBody.required)
            $.message("Missing required request body");
          else {
            let j;
            if (E.body)
              j = d(E).schema;
            else if (this.requestBody) {
              const { content: L, matches: K } = h(this, _), ae = K.length;
              for (let ye = 0; ye < ae; ye++) {
                const xe = K[ye], Pe = L[xe].schema;
                if (Pe && Pe.hasOwnProperty("default")) {
                  j = Pe;
                  break;
                }
              }
            }
            j && j.hasOwnProperty("default") && (S.body = n.copy(j.default));
          }
          return new i(S, $);
        },
        response: function(m, v, _ = {}) {
          const y = new r("Response invalid"), w = new r("Response has one or more warnings"), $ = v !== void 0, E = (() => {
            const ae = String(m)[0];
            return this.responses[m] || this.responses[ae + "XX"] || this.responses.default;
          })(), S = { headers: {} }, R = this.enforcerData.major, j = this.enforcerData.options.exceptionSkipCodes, L = this.enforcerData.options.exceptionEscalateCodes;
          if (!n.isPlainObject(_) && n.isObject(_) && (_ = Object.create({}, _)), !n.isObject(_))
            throw Error("Invalid headers input parameter. Must be a plain object");
          if (_ = n.lowerCaseObjectProperties(_), E) {
            if ($) {
              if (R === 2) {
                const ae = E.schema;
                if (!ae)
                  S.body = v;
                else if (ae.type === "file")
                  S.schema = ae, S.body = v;
                else {
                  v = ae.formalize(v);
                  let ye = ae.validate(v, { readWriteMode: "read" });
                  ye || ([v, ye] = ae.serialize(v)), ye ? y.at("body").merge(ye) : (S.schema = ae, S.body = v);
                }
              } else if (R === 3) {
                const ae = E.content;
                if (!ae)
                  S.body = v;
                else {
                  const ye = Object.keys(ae);
                  let xe;
                  if (_.hasOwnProperty("content-type")) {
                    const te = _["content-type"].split(";")[0].trim();
                    ae.hasOwnProperty(te) ? xe = te : j.WOPE001 || (L.WOPE001 ? y : w).message("Content type specified is not defined as a possible mime-type: " + te + ". [WOPE001]");
                  } else
                    ye.length === 1 ? xe = ye[0] : y.message("Unable to determine content type to use. Please specify this value in the header object");
                  const Pe = xe && ae[xe] && ae[xe].schema;
                  if (Pe) {
                    v = Pe.formalize(v);
                    let te = Pe.validate(v, { readWriteMode: "read" });
                    te || ([v, te] = Pe.serialize(v)), te ? y.at("body").merge(te) : (S.schema = Pe, S.body = v);
                  } else
                    S.body = v;
                }
              }
            }
            const K = Object.keys(_);
            E.headers && Object.keys(E.headers).forEach((ae) => {
              const ye = ae.toLowerCase(), xe = E.headers[ae], Pe = xe.schema;
              let te;
              if (_.hasOwnProperty(ye) ? te = _[ye] : Pe.hasOwnProperty("default") && (te = n.copy(Pe.default)), te !== void 0) {
                n.arrayRemoveItem(K, ye), te = Pe.formalize(te);
                let pe = Pe.validate(te);
                pe || ([te, pe] = Pe.serialize(te)), pe || ([te, pe] = xe.stringify(te)), pe ? y.at("headers").at(ae).merge(pe) : S.headers[ae] = te;
              } else
                xe.required && y.at("headers").at(ae).message("Missing required header: " + ae);
            }), K.forEach((ae) => {
              typeof _[ae] != "string" && !j.WOPE002 && (L.WOPE002 ? y : w).at("headers").at(ae).message("Value has no schema and is not a string. [WOPE002]");
            });
          } else
            y.message("Invalid response code: " + m);
          return S.hasOwnProperty("body") && (S.body = s.extract(S.body)), S.headers && Object.keys(S.headers).forEach((K) => {
            S.headers[K] = s.extract(S.headers[K]);
          }), new i(S, y, w);
        },
        toRequestObject: function(m) {
          const v = {};
          return a.forEach((_) => {
            _ in m && (v[_] = m[_]);
          }), v;
        }
      },
      validator: function({ major: m, definition: v }) {
        return {
          type: "object",
          properties: {
            callbacks: {
              allowed: m === 3,
              type: "object",
              additionalProperties: t("Callback")
            },
            consumes: {
              allowed: m === 2,
              type: "array",
              items: {
                type: "string"
              }
            },
            deprecated: {
              type: "boolean",
              default: !1
            },
            description: {
              type: "string"
            },
            externalDocs: t("ExternalDocumentation"),
            operationId: {
              type: "string",
              errors: (_) => {
                const { exception: y, root: w, definition: $ } = _;
                w.__operationIdMap || (w.__operationIdMap = {}), w.__operationIdMap[$] ? y.message("The operationId must be unique") : w.__operationIdMap[$] = _;
              }
            },
            parameters: {
              type: "array",
              items: t("Parameter"),
              errors: e.exports.parametersValidation
            },
            produces: {
              allowed: m === 2,
              type: "array",
              items: {
                type: "string"
              }
            },
            requestBody: t("RequestBody", {
              // for easy unit testing default key to post if there is no parent key
              allowed: ({ options: _, parent: y }) => m === 3 && !!_.requestBodyAllowedMethods[y.key || "post"]
            }),
            responses: t("Responses", { required: !0 }),
            schemes: {
              allowed: m === 2,
              type: "array",
              items: {
                type: "string",
                enum: ["http", "https", "ws", "wss"]
              }
            },
            security: {
              type: "array",
              items: t("SecurityRequirement")
            },
            servers: {
              allowed: m === 3,
              type: "array",
              items: t("Server")
            },
            summary: {
              type: "string",
              errors: ({ definition: _, warn: y, options: w, parent: $ }) => {
                _.length >= 120 && !w.exceptionSkipCodes.WOPE003 && !n.schemaObjectHasSkipCode(v, "WOPE003") && (w.exceptionEscalateCodes.WOPE003 ? exception : y).message("Value should be less than 120 characters. [WOPE003]");
              }
            },
            tags: {
              type: "array",
              items: {
                type: "string"
              }
            }
          }
        };
      },
      parametersValidation: ({ exception: m, parent: v, root: _, definition: y }) => {
        const w = y.length, $ = [];
        let E = 0, S = !1, R = !1, j = !1;
        for (let L = 0; L < w; L++) {
          const K = y[L];
          K.in === "body" && (E++, S = !0), K.in === "formData" && (R = !0, K.type === "file" && (j = !0));
          for (let ae = 0; ae < w; ae++) {
            const ye = y[ae];
            if (K !== ye && K.name === ye.name && K.in === ye.in) {
              const xe = K.name + " in " + K.in;
              $.includes(xe) || $.push(xe);
            }
          }
        }
        if (E > 1 && m.message("Only one body parameter allowed"), S && R && m.message('Cannot have parameters in "body" and "formData" simultaneously'), $.length && m.message("Parameter name must be unique per location. Duplicates found: " + $.join(", ")), j) {
          const L = v.validator === e.exports.validator && v.definition.consumes || _.definition.consumes, K = Array.isArray(L) ? L.length : 0;
          let ae = !1;
          for (let ye = 0; ye < K; ye++) {
            const xe = L[ye];
            if (xe === "multipart/form-data" || xe === "application/x-www-form-urlencoded") {
              ae = !0;
              break;
            }
          }
          ae || m.message('Parameters of type "file" require the consumes property to be set to either "multipart/form-data" or "application/x-www-form-urlencoded"');
        }
      }
    };
    function l(m, v) {
      v && v.forEach((_) => {
        const y = _.in, w = y === "header" ? _.name.toLowerCase() : _.name;
        m.hasOwnProperty(y) || (m[y] = {}), m[y][w] = _;
      });
    }
    function d(m) {
      const v = Object.keys(m.body)[0];
      return m.body[v];
    }
    function p(m, v, _, y, w) {
      _.error || (_ = v.deserialize(_.value)), _.error || (_.error = v.validate(_.value, { readWriteMode: y })), _.error ? m && m.push(_.error) : w(_.value);
    }
    function h(m, v) {
      const _ = v.header.hasOwnProperty("content-type") ? v.header["content-type"].split(";")[0].trim() : "*/*", y = m.requestBody.content, w = Object.keys(y), $ = n.findMediaMatch(_, w);
      return {
        content: y,
        contentType: _,
        matches: $
      };
    }
    function g(m, v) {
      return typeof m == "string" && (v.type === "boolean" ? (m === "true" && (m = !0), (!m || m === "false") && (m = !1)) : v.type === "integer" ? o.test(m) && (m = parseInt(m)) : v.type === "number" && c.test(m) && (m = parseFloat(m))), m;
    }
  }(Qh)), Qh.exports;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var tm, x$;
function O$() {
  if (x$)
    return tm;
  x$ = 1;
  const e = MP(), t = rr, r = Nn, i = hs, n = Yt, s = ms(), a = /^false/i, o = /^true$/i, c = /^\./;
  tm = {
    init: function(v) {
      const { context: _, definition: y, exception: w, major: $, warn: E, options: S } = v;
      if (y.in === "header" && y.name !== y.name.toLowerCase() && !S.exceptionSkipCodes.WPAR001 && !n.schemaObjectHasSkipCode(y, "WPAR001") && (S.exceptionEscalateCodes.WPAR001 ? w : E).message("Header names are case insensitive and their lower case equivalent will be used. [WPAR001]"), !this.hasOwnProperty("required") && this.in !== "path" && (this.required = !1), $ === 2 && y.in !== "body") {
        const R = e.extractSchemaDefinition({}, this);
        R.type === "file" && (R.type = "string");
        const [j, L, K] = new _.Schema(R);
        j && (this.schema = j), L && w.merge(L), K && E.merge(K);
      } else if ($ === 3 && y.content) {
        const R = Object.keys(y.content)[0];
        y.content[R].schema && (this.schema = y.content[R].schema);
      }
      $ === 3 && this.schema && n.validateExamples(this, w, E, S);
    },
    prototype: {
      /**
       * Parse input. Does not validate.
       * @param {string} value
       * @param {object} [query={}]
       * @returns {EnforcerResult}
       */
      parse: function(v, _) {
        const { major: y } = this.enforcerData, w = this.schema, $ = w && w.type, E = r("Unable to parse value");
        if ((this.in === "path" || this.in === "query") && (v = decodeURIComponent(v)), y === 2)
          if (this.collectionFormat === "multi") {
            _ || (_ = n.parseQueryString(v));
            const S = _[this.name];
            if (S) {
              const R = [];
              return S.forEach((j, L) => {
                !j && !this.allowEmptyValue ? E.at(L).message("Empty value not allowed") : this.items ? R.push(m(this, this.items, E.at(L), j)) : R.push(j);
              }), new i(R, E);
            } else
              return new i(null, E);
          } else if (_ && _.hasOwnProperty(this.name)) {
            const S = _[this.name];
            return S.length ? new i(m(this, this, E, S[S.length - 1]), E) : new i(m(this, this, E, void 0), E);
          } else
            return new i(m(this, this, E, v), E);
        else if (y === 3) {
          const S = this.explode, R = this.style;
          let j;
          if (_ || (this.in === "query" ? _ = n.parseQueryString(v) : this.in === "cookie" && (_ = n.parseCookieString(v))), R === "deepObject") {
            const L = RegExp("(?:^|&)" + this.name + "\\[([^\\]]+)\\](?:=([^&]*))?", "g"), K = {};
            let ae, ye = !1;
            for (; ae = L.exec(v); )
              ye = !0, K[ae[1]] = ae[2];
            ye && (j = K);
          } else if (R === "form") {
            if (S && $ === "object") {
              const L = p("&", "=", "&" + v);
              L && (j = {}, Object.keys(L).forEach((K) => {
                (w.additionalProperties || w.properties && w.properties.hasOwnProperty(K)) && (j[K] = L[K]);
              }));
            } else if (_.hasOwnProperty(this.name)) {
              const L = _[this.name];
              if ($ === "array")
                S ? j = L : L.length > 0 && (j = L[L.length - 1].split(","));
              else if ($ === "object") {
                const K = h(",", L[L.length - 1]);
                K && (j = K);
              } else
                L.length > 0 && (j = L[L.length - 1]);
            }
          } else if (R === "label")
            c.test(v) && ($ === "array" ? j = v.substr(1).split(S ? "." : ",") : $ === "object" ? j = S ? p(".", "=", v) : h(",", v.substr(1)) : j = v.substr(1));
          else if (R === "matrix") {
            const L = this.name, K = RegExp("^;" + L + "(?:=|$)");
            if ($ === "array")
              if (S) {
                const ae = l(";", "=", L, v.substr(1));
                ae && (j = ae);
              } else
                j = v.substr(L.length + 2).split(",");
            else if ($ === "object") {
              if (S || K.test(v)) {
                const ae = S ? p(";", "=", v) : h(",", v.substr(L.length + 2));
                ae && (j = ae);
              }
            } else
              K.test(v) && (j = v.substr(L.length + 2));
          } else if (R === "pipeDelimited") {
            const L = _[this.name];
            L.length > 0 && (j = S ? L : d($, "|", L[L.length - 1]));
          } else if (R === "simple")
            $ === "array" ? j = v.split(",") : $ === "object" ? j = S ? p(",", "=", "," + v) : h(",", v) : j = v;
          else if (R === "spaceDelimited") {
            const L = _[this.name];
            L.length > 0 && (j = S ? L : d($, " ", L[L.length - 1]));
          }
          return j !== void 0 ? $ === "array" ? j = j.map((L, K) => g(this, w.items, E.at(K), L)) : $ === "object" ? Object.keys(j).forEach((L) => {
            w.properties && w.properties[L] ? j[L] = g(this, w.properties[L], E.at(L), j[L]) : typeof w.additionalProperties == "object" && (j[L] = g(this, w.additionalProperties, E.at(L), j[L]));
          }) : j = g(this, w, E, j) : E.message("The value is not formatted properly"), new i(j, E);
        }
      }
    },
    validator: function(v) {
      const { major: _, options: y, definition: w } = v, $ = e.validator(v), E = y.exceptionSkipCodes, S = v.options.exceptionEscalateCodes;
      return {
        type: "object",
        properties: Object.assign({}, $.properties, {
          allowEmptyValue: {
            allowed: ({ parent: R }) => ["query", "formData"].includes(R.definition.in),
            type: "boolean",
            default: !1,
            errors: ({ exception: R, warn: j, major: L, usedDefault: K }) => {
              L === 3 && !K && !E.WPAR002 && !n.schemaObjectHasSkipCode(w, "WPAR002") && (S.WPAR002 ? R : j).message('Per OAS 3.0.2: "Use of this property is NOT RECOMMENDED, as it is likely to be removed in a later revision." [WPAR002]');
            }
          },
          allowReserved: {
            allowed: ({ parent: R }) => _ === 3 && R.definition.in === "query",
            type: "boolean",
            default: !1
          },
          collectionFormat: {
            allowed: ({ major: R, parent: j }) => R === 2 && j.definition.type === "array",
            enum: ({ parent: R }) => ["query", "formData"].includes(R.definition.in) ? ["csv", "ssv", "tsv", "pipes", "multi"] : ["csv", "ssv", "tsv", "pipes"],
            default: "csv"
          },
          explode: {
            type: "boolean",
            allowed: _ === 3,
            default: ({ parent: R }) => R.result.style === "form",
            errors: ({ exception: R, parent: j }) => {
              const L = j.definition.schema && j.definition.schema.type;
              j.definition.in === "cookie" && j.definition.explode && (L === "array" || L === "object") && R.message("Cookies do not support exploded values for non-primitive schemas");
            }
          },
          format: {
            weight: -9,
            allowed: ({ major: R, parent: j }) => R === 2 && ["file", "integer", "number", "string"].includes(j.definition.type),
            type: "string",
            errors: ({ exception: R, parent: j, warn: L }) => {
              const K = j.definition.format;
              if (K) {
                const ae = [];
                switch (j.definition.type) {
                  case "file":
                    ae.push("binary", "byte");
                    break;
                  case "integer":
                    ae.push("int32", "int64");
                    break;
                  case "number":
                    ae.push("float", "double");
                    break;
                  case "string":
                    ae.push("binary", "byte", "date", "date-time", "password");
                    break;
                }
                !ae.includes(K) && !E.WPAR003 && !n.schemaObjectHasSkipCode(w, "WPAR003") && (S.WPAR003 ? R : L).message("Non standard format used: " + K + ". [WPAR003]");
              }
            }
          },
          in: {
            weight: -20,
            required: !0,
            type: "string",
            enum: ({ major: R }) => R === 2 ? ["body", "formData", "header", "query", "path"] : ["cookie", "header", "path", "query"]
          },
          name: {
            required: !0,
            type: "string"
          },
          required: {
            required: ({ parent: R }) => R.definition.in === "path",
            type: "boolean",
            // default: ({parent}) => parent.definition.in === 'path',
            // default: false,
            enum: ({ parent: R }) => R.definition.in === "path" ? [!0] : [!0, !1]
          },
          schema: t("Schema", {
            allowed: ({ parent: R }) => _ === 3 || R.definition.in === "body"
          }),
          style: {
            weight: -19,
            allowed: _ === 3,
            type: "string",
            default: ({ parent: R }) => {
              switch (R.definition.in) {
                case "cookie":
                  return "form";
                case "header":
                  return "simple";
                case "path":
                  return "simple";
                case "query":
                  return "form";
              }
            },
            enum: ({ parent: R }) => {
              switch (R.definition.in) {
                case "cookie":
                  return ["form"];
                case "header":
                  return ["simple"];
                case "path":
                  return ["simple", "label", "matrix"];
                case "query":
                  return ["form", "spaceDelimited", "pipeDelimited", "deepObject"];
              }
            },
            errors: ({ exception: R, parent: j }) => {
              const L = j.definition.style, K = j.definition.schema && j.definition.schema.type;
              if (!K || !L)
                return !1;
              j.definition.in === "query" && L !== "form" && !(L === "spaceDelimited" && K === "array") && !(L === "pipeDelimited" && K === "array") && !(L === "deepObject" && K === "object") && R.message('Style "' + L + '" is incompatible with schema type: ' + K);
            }
          },
          type: {
            weight: -10,
            allowed: ({ major: R, parent: j }) => R === 2 && j.definition.in !== "body",
            required: !0,
            enum: ({ parent: R }) => R.definition.in === "formData" ? ["array", "boolean", "file", "integer", "number", "string"] : ["array", "boolean", "integer", "number", "string"]
          }
        }),
        errors: _ === 3 ? $.errors : (R) => {
          const { exception: j, definition: L } = R;
          L.hasOwnProperty("default") && L.required && j.message('Cannot have a "default" and set "required" to true'), $.errors(R);
        }
      };
    }
  };
  function l(v, _, y, w) {
    const $ = w.split(v), E = $.length, S = [];
    for (let R = 0; R < E; R++) {
      const j = $[R].split(_);
      if (j[0] === y)
        S.push(j[1]);
      else
        return !1;
    }
    return S;
  }
  function d(v, _, y) {
    if (v === "array")
      return y.split(_);
    if (v === "object")
      return h(_, y);
  }
  function p(v, _, y) {
    const $ = RegExp("s([^v]+)v([^s]+)?".replace(/v/g, _).replace(/s/g, v), "g"), E = {};
    let S, R = 0;
    for (; S = $.exec(y); )
      E[S[1]] = S[2] || "", R = S.index + S[0].length;
    if (R === y.length)
      return E;
  }
  function h(v, _) {
    const y = {}, w = _.split(v), $ = w.length;
    if ($ % 2 === 0) {
      for (let E = 1; E < $; E += 2)
        y[w[E - 1]] = w[E];
      return y;
    }
  }
  function g(v, _, y, w) {
    if (w) {
      if (_.type === "boolean") {
        if (o.test(w))
          return !0;
        if (a.test(w))
          return !1;
        y.message('Expected "true" or "false". Received: ' + w);
      } else if (_.type === "integer") {
        const $ = +w;
        if (!isNaN($))
          return $;
        y.message("Expected an integer. Received: " + w);
      } else if (_.type === "number") {
        const $ = +w;
        if (!isNaN($))
          return $;
        y.message("Expected a number. Received: " + w);
      } else if (_.type === "string")
        return w;
    } else {
      if (v.allowEmptyValue)
        return new s(w, { serialize: !1, validate: !1 });
      y.message("Empty value not allowed");
    }
    return w;
  }
  function m(v, _, y, w) {
    if (_.type === "array") {
      let $;
      switch (_.collectionFormat) {
        case "csv":
          $ = w.split(",");
          break;
        case "pipes":
          $ = w.split("|");
          break;
        case "ssv":
          $ = w.split(" ");
          break;
        case "tsv":
          $ = w.split("	");
          break;
      }
      return $.map((E, S) => _.items ? m(v, _.items, y.at(S), E) : E);
    } else
      return g(v, _, y, w);
  }
  return tm;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var rm, P$;
function S$() {
  if (P$)
    return rm;
  P$ = 1;
  const e = rr, t = Yt, r = t.methods();
  return rm = {
    init: function() {
      this.methods = r.filter((i) => !!this[i]);
    },
    prototype: {},
    validator: function({ major: i, options: n, definition: s }) {
      const a = bf(), o = n.exceptionSkipCodes, c = n.exceptionEscalateCodes;
      return {
        type: "object",
        properties: {
          delete: e("Operation"),
          description: {
            type: "string"
          },
          get: e("Operation"),
          head: e("Operation"),
          options: e("Operation"),
          parameters: {
            weight: -1,
            type: "array",
            items: e("Parameter"),
            errors: a.parametersValidation
          },
          patch: e("Operation"),
          post: e("Operation"),
          put: e("Operation"),
          trace: e("Operation", { allowed: i === 3 }),
          servers: {
            allowed: i === 3,
            type: "array",
            items: e("Server")
          },
          summary: {
            type: "string"
          }
        },
        errors: ({ exception: l, definition: d, warn: p }) => {
          const h = r.length;
          let g = !1;
          for (let m = 0; m < h; m++)
            if (d.hasOwnProperty(r[m])) {
              g = !0;
              break;
            }
          !g && !o.WPAT001 && !t.schemaObjectHasSkipCode(s, "WPAT001") && (c.WPAT001 ? l : p).message("No methods defined. [WPAT001]");
        }
      };
    }
  }, rm;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var nm, A$;
function C$() {
  if (A$)
    return nm;
  A$ = 1;
  const e = rr, t = Yt, r = /{([^}]+)}/, i = t.methods();
  nm = {
    init: function(s) {
      const { exception: a, result: o, plugins: c } = s, l = {};
      s.options.disablePathNormalization || Object.keys(o).forEach((p) => {
        const h = t.edgeSlashes(p, !0, !1);
        h !== p && (o[h] = o[p], delete o[p]);
      }), c.push(() => {
        const d = _0().config;
        Object.keys(o).forEach((_, y) => {
          const w = o[_], $ = _.split("/").length - 1, E = [], S = new RegExp(r, "g");
          let R;
          for (; R = S.exec(_); )
            E.push(R[1]);
          const j = a.at(_).nest("Path parameter definitions inconsistent");
          w.methods.forEach((pe) => {
            const de = j.at(pe), Ee = Object.keys(w[pe].parametersMap.path || {}), Re = Ee.length, _e = [];
            for (let V = 0; V < Re; V++) {
              const z = Ee[V];
              E.includes(z) || _e.push(z);
            }
            _e.length && de.message("Path missing defined parameters: " + _e.join(", "));
            const ie = E.length, Y = [];
            for (let V = 0; V < ie; V++) {
              const z = E[V];
              Ee.includes(z) || Y.push(z);
            }
            Y.length && de.message("Definition missing path parameters: " + Y.join(", "));
          });
          const L = /{([^}]+)}/g;
          let K, ae = "", ye = 0, xe = "";
          for (; R = L.exec(_); )
            K = _.substring(ye, R.index), xe += "0".repeat(K.split("/").length) + "1", ae += n(K) + "([\\s\\S]+?)", ye = R.index + R[0].length;
          K = _.substr(ye), K && (xe += "0".repeat(K.split("/").length) + "0", ae += n(K));
          const Pe = d.useCaseSensitivePaths ? new RegExp("^" + ae + "$") : new RegExp("^" + ae + "$", "i"), te = (pe) => {
            const de = Pe.exec(pe);
            if (!de)
              return;
            const Ee = {};
            return E.forEach((Re, _e) => Ee[Re] = de[_e + 1]), {
              params: Ee,
              path: w,
              pathKey: _
            };
          };
          te.weight = xe + y, l[$] || (l[$] = []), l[$].push(te);
        });
        const p = Symbol("path parameter"), h = [];
        Object.keys(o).forEach((_, y) => {
          const w = /{([^}]+)}/g, $ = [];
          let E, S = 0;
          for (; E = w.exec(_); ) {
            const j = _.substring(S, E.index);
            $.push(j), $.push(p), S = E.index + E[0].length;
          }
          const R = _.substring(S);
          $.push(R), i.filter((j) => o[_].hasOwnProperty(j)).forEach((j) => {
            h.push({
              key: _,
              method: j,
              signature: d.useCaseSensitivePaths ? [j].concat($) : [j].concat($.map((L) => typeof L == "string" ? L.toLowerCase() : L))
            });
          });
        });
        const g = [], m = [];
        h.forEach((_) => {
          const y = h.filter((w) => {
            const $ = w.signature.length;
            if (_ === w || _.signature.length !== $ || m.includes(w.key))
              return !1;
            for (let E = 0; E < $; E++)
              if (w.signature[E] !== _.signature[E])
                return !1;
            return !0;
          });
          y.length > 0 && (y.unshift(_), y.forEach((w) => m.push(w.key)), g.push(y));
        });
        const v = a.nest("Equivalent paths are not allowed");
        g.forEach((_) => {
          const y = v.nest("Equivalent paths:");
          _.forEach((w) => y.push(w.method.toUpperCase() + " " + w.key));
        }), Object.keys(l).forEach((_) => {
          l[_].sort((y, w) => y.weight < w.weight ? -1 : 1);
        }), this.enforcerData.pathParsers = l;
      });
    },
    prototype: {
      /**
       * Find the Path object for the provided path.
       * @param {string} pathString
       * @returns {{ params: object, path: Path }|undefined}
       */
      findMatch: function(s) {
        return this.findMatches(s)[0];
      },
      findMatches: function(s) {
        const { pathParsers: a } = this.enforcerData, o = [];
        s = s.split("?")[0];
        const c = s.split("/").length - 1, l = a[c];
        if (!l)
          return o;
        const d = l.length;
        for (let p = 0; p < d; p++) {
          const h = l[p], g = h(s);
          g && o.push(g);
        }
        return o;
      }
    },
    validator: function(s) {
      const a = s.options.disablePathNormalization, o = s.options.exceptionSkipCodes, c = s.options.exceptionEscalateCodes, l = s.definition;
      return {
        required: !0,
        type: "object",
        additionalProperties: e("PathItem"),
        errors: ({ exception: d, definition: p, warn: h }) => {
          const g = d.nest("These paths are defined more than once exist due to path normalization:"), m = Object.keys(p), v = {}, _ = [], y = [];
          if (m.forEach((w) => {
            if ((w[0] !== "/" || w[1] === "/") && d.at(w).message("Path must begin with a single forward slash"), !a) {
              const $ = t.edgeSlashes(w, !0, !1);
              v[$] && g.message(w + " --> " + $), $ !== w && !o.WPAS001 && !t.schemaObjectHasSkipCode(l, "WPAS001") && (c.WPAS001 ? d : h).at(w).message("Path normalized from " + w + " to " + $ + ". [WPAS001]"), v[w] = $;
            }
            w !== "/" && (w[w.length - 1] === "/" ? _.push(w) : y.push(w));
          }), !m.length && !o.WPAS002 && !t.schemaObjectHasSkipCode(l, "WPAS002") && (c.WPAS002 ? d : h).message("No paths defined. [WPAS002]"), _.length > 0 && y.length > 0) {
            const w = (c.WPAS003 ? d : h).nest("Some defined paths end with slashes while some do not. This inconsistency may confuse users of your API."), $ = w.nest("Paths without trailing slashes:"), E = w.nest("Paths with trailing slashes:");
            y.forEach((S) => {
              !o.WPAS003 && !t.schemaObjectHasSkipCode(l, "WPAS003") && $.message(S + " [WPAS003]");
            }), _.forEach((S) => {
              !o.WPAS003 && !t.schemaObjectHasSkipCode(l, "WPAS003") && E.message(S + " [WPAS003]");
            });
          }
        }
      };
    }
  };
  function n(s) {
    return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  }
  return nm;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var im, R$;
function T$() {
  return R$ || (R$ = 1, im = {
    init: function(e) {
    },
    prototype: {},
    validator: function(e) {
      return {
        type: "object",
        properties: {
          $ref: {
            type: "string"
          }
        }
      };
    }
  }), im;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var sm, I$;
function j$() {
  if (I$)
    return sm;
  I$ = 1;
  const e = rr, t = Yt, r = /^content-type$/i, i = /^[a-zA-Z0-9.\-_]+$/;
  return sm = {
    init: function(n) {
      const { exception: s, warn: a, options: o } = n;
      t.validateExamples(this, s, a, o);
    },
    prototype: {},
    validator: function({ major: n }) {
      return {
        type: "object",
        properties: {
          description: {
            type: "string",
            required: !0
          },
          content: {
            allowed: n === 3,
            type: "object",
            additionalProperties: e("MediaType")
          },
          examples: {
            allowed: n === 2,
            type: "object",
            additionalProperties: {
              freeForm: !0
            }
          },
          headers: {
            type: "object",
            additionalProperties: e("Header", {
              ignored: ({ key: s }) => r.test(s)
            })
          },
          links: {
            allowed: n === 3,
            type: "object",
            additionalProperties: e("Link", {
              errors: ({ exception: s, key: a }) => {
                i.test(a) || s.message("Invalid key used for link value");
              }
            })
          },
          schema: n === 2 ? e("Schema") : { allowed: !1 }
        }
      };
    }
  }, sm;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var am, k$;
function M$() {
  if (k$)
    return am;
  k$ = 1;
  const e = rr, t = Yt, r = /^[1-5]\d{2}$/, i = /^location$/i, n = /^[1-5]X{2}$/;
  return am = {
    init: function(s) {
    },
    prototype: {},
    validator: function(s) {
      const { major: a, options: o, definition: c } = s, l = o.exceptionSkipCodes, d = o.exceptionEscalateCodes;
      return {
        type: "object",
        additionalProperties: e("Response", {
          allowed: ({ key: p }) => p === "default" || r.test(p) || a === 3 && n.test(p),
          errors: ({ exception: p, key: h, parent: g, warn: m, definition: v, major: _, options: y }) => {
            if (y.apiSuggestions && r.test(h) && g && g.parent && g.parent.key)
              if (g.parent.key.toLowerCase() === "post" && h === "201") {
                const $ = v.headers ? Object.keys(v.headers).filter((E) => i.test(E))[0] : null;
                (!$ || !v.headers[$]) && !l.WRES001 && !t.schemaObjectHasSkipCode(c, "WRES001") && (d.WRES001 ? p : m).message("A 201 response for a POST request should return a location header (https://tools.ietf.org/html/rfc7231#section-4.3.3) and this is not documented in your OpenAPI document. [WRES001]");
              } else
                h === "204" && (_ === 2 && v.schema && !l.WRES002 && !t.schemaObjectHasSkipCode(c, "WRES002") ? (d.WRES002 ? p : m).message("A 204 response must not contain a body (https://tools.ietf.org/html/rfc7231#section-6.3.5) but this response has a defined schema. [WRES002]") : _ === 3 && v.content && !l.WRES003 && !t.schemaObjectHasSkipCode(c, "WRES003") && (d.WRES003 ? p : m).message("A 204 response must not contain a body (https://tools.ietf.org/html/rfc7231#section-6.3.5) but this response has a defined content. [WRES003]"));
          }
        }),
        errors: ({ exception: p, definition: h }) => {
          Object.keys(h).length === 0 && !p.hasException && p.message("Response object cannot be empty");
        }
      };
    }
  }, am;
}
var om = { exports: {} }, um = {}, N$;
function b0() {
  return N$ || (N$ = 1, function(e) {
    e.after = function(t, r, i, n) {
      return e.runHooks(t, r, i, n).value;
    }, e.runHooks = function(t, r, i, n, s = !1) {
      if (t.enforcerData && t.enforcerData.staticData && t.enforcerData.staticData.hooks) {
        const a = t.enforcerData.staticData.hooks[r], o = a !== void 0 ? a.length : 0;
        let c = i, l = !1;
        if (s && o > 0 && (l = n.hasException), !l)
          for (let d = 0; d < o; d++) {
            const p = a[d](i, t, n);
            if (p && typeof p == "object") {
              if (p.done === !0)
                return p;
              if ("value" in p && (c = p.value), p.hasException || n.hasException) {
                l = !0;
                break;
              }
            }
          }
        return {
          done: l === !0,
          // if it has an exception then it is also done
          hasException: l,
          value: c
        };
      } else
        return {
          done: !1,
          hasException: !1,
          value: i
        };
    };
  }(um)), um;
}
var cm = {}, D$;
function NP() {
  if (D$)
    return cm;
  D$ = 1;
  const e = Nn, t = Yt, r = ms();
  return cm.anyOneOf = function(i, n, s, a, o, c, l) {
    n instanceof r && (n = n.value);
    const d = i.anyOf ? "anyOf" : "oneOf", p = [], h = [];
    if (i[d].forEach((g) => {
      const m = new e(""), v = new Map(a);
      if (c) {
        const y = g.validate(n);
        if (y) {
          p.push(y);
          return;
        }
      }
      const _ = o(m, v, g, t.copy(n), l);
      if (m.hasException)
        p.push(m);
      else {
        let y = 1;
        if (g.type === "object") {
          const w = g.properties || {}, $ = Object.keys(_), E = $.length;
          for (let S = 0; S < E; S++) {
            const R = $[S];
            if (w.hasOwnProperty(R))
              y++;
            else if (g.additionalProperties === !1) {
              y = 0;
              break;
            }
          }
        }
        y > 0 && !c && g.validate(_) && (y = 0), y > 0 && h.push({ score: y, result: t.copy(_) });
      }
    }), h.length > 1) {
      h.sort((v, _) => v.score > _.score ? -1 : 1);
      const g = h[0].score, m = h.filter((v) => v.score === g);
      if (m.length > 1) {
        const v = c ? "Unable to determine serialization schema because too many schemas match. Use of a discriminator or making your schemas more specific would help this problem." : "Unable to determine deserialization schema because too many schemas match. Use of a discriminator or making your schemas more specific would help this problem.";
        s.message(v);
      } else
        return t.merge(n, m[0].result);
    } else if (h.length === 0)
      if (p.length > 0) {
        const g = s.nest("No matching schemas");
        p.forEach((m) => g.push(m));
      } else
        s.message("No matching schemas");
    else
      return t.merge(n, h[0].result);
  }, cm;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var lm, L$;
function _z() {
  if (L$)
    return lm;
  L$ = 1;
  const e = b0(), t = NP(), r = Yt, i = ms(), n = /^\s*true\s*$/i, s = /^\s*false\s*$/i, a = /^\s*\d+\s*$/, o = /^\s*(?:\d+(?:\.\d+)?)|(?:\.\d+)\s*$/;
  lm = c;
  function c(l, d, p, h, g) {
    let { serialize: m, value: v } = i.getAttributes(h);
    if (!m)
      return h;
    const _ = p.type, y = typeof v;
    if (v && y === "object") {
      let $ = d.get(p);
      if ($ && $.includes(v))
        return v;
      d.set(p, [v]);
    }
    const w = e.runHooks(p, "beforeDeserialize", v, l);
    if (v = w.value, w.done)
      return v;
    if (v === null && (p.nullable || p["x-nullable"]))
      return e.after(p, "afterDeserialize", v, l);
    if (p.allOf) {
      const $ = l.at("allOf");
      if (p.allOf[0].type === "object") {
        const E = {};
        return p.allOf.forEach((S, R) => {
          const j = c($.at(R), d, S, h, g);
          Object.assign(E, j);
        }), e.after(p, "afterDeserialize", Object.assign(v, E), l);
      } else
        return c($.at("0"), d, p.allOf[0], h, g);
    } else if (p.anyOf || p.oneOf) {
      let $;
      if (p.discriminator) {
        const { name: E, key: S, schema: R } = p.discriminate(v, !0);
        R ? $ = Object.assign(v, c(l, d, R, h, g)) : l.message('Discriminator property "' + S + '" as "' + E + '" did not map to a schema');
      } else
        $ = t.anyOneOf(
          p,
          h,
          l,
          d,
          c,
          !1,
          g
        );
      return e.after(p, "afterDeserialize", $, l);
    } else if (_ === "array") {
      if (Array.isArray(v))
        return p.items && v.forEach(($, E) => {
          v[E] = c(l.at(E), d, p.items, i.inherit($, { serialize: m }), g);
        }), e.after(p, "afterDeserialize", v, l);
      l.message("Expected an array. Received: " + r.smart(v));
    } else if (_ === "object")
      if (r.isObject(v)) {
        const $ = p.additionalProperties, E = p.properties || {};
        if (Object.keys(v).forEach((S) => {
          E.hasOwnProperty(S) ? v[S] = c(l.at(S), d, E[S], i.inherit(v[S], { serialize: m }), g) : $ && (v[S] = c(l.at(S), d, $, i.inherit(v[S], { serialize: m }), g));
        }), p.discriminator) {
          const { name: S, key: R, schema: j } = p.discriminate(v, !0);
          j ? Object.assign(v, c(l, d, j, h, g)) : l.message('Discriminator property "' + R + '" as "' + S + '" did not map to a schema');
        }
        return e.after(p, "afterDeserialize", v, l);
      } else
        l.message("Expected an object. Received: " + r.smart(v));
    else if (p !== !0) {
      const $ = p.enforcerData.staticData.dataTypes, E = $[p.type] && $[p.type][p.format] || null;
      if (_ === "boolean")
        if (E && E.deserialize) {
          const S = E.deserialize({
            exception: l,
            schema: p,
            value: v
          });
          return e.after(p, "afterDeserialize", S, l);
        } else if (y !== "boolean") {
          if (!g.strict) {
            if (y === "string") {
              if (n.test(v))
                return !0;
              if (s.test(v))
                return !1;
            } else if (y === "number")
              return e.after(p, "afterDeserialize", !!v, l);
          }
          l.message("Expected a boolean. Received: " + r.smart(v));
        } else
          return e.after(p, "afterDeserialize", v, l);
      else if (_ === "integer")
        if (E && E.deserialize) {
          const S = E.deserialize({
            exception: l,
            schema: p,
            value: v
          });
          return e.after(p, "afterDeserialize", S, l);
        } else if (y !== "number" || !r.isInteger(v)) {
          if (!g.strict && y === "string" && a.test(v))
            return e.after(p, "afterDeserialize", +v, l);
          l.message("Expected an integer. Received: " + r.smart(v));
        } else
          return e.after(p, "afterDeserialize", v, l);
      else if (_ === "number")
        if (E && E.deserialize) {
          const S = E.deserialize({
            exception: l,
            schema: p,
            value: v
          });
          return e.after(p, "afterDeserialize", S, l);
        } else if (y !== "number") {
          if (!g.strict && y === "string" && o.test(v))
            return e.after(p, "afterDeserialize", +v, l);
          l.message("Expected a number. Received: " + r.smart(v));
        } else
          return e.after(p, "afterDeserialize", v, l);
      else if (_ === "string") {
        if (E && E.deserialize) {
          const S = E.deserialize({
            exception: l,
            schema: p,
            value: v
          });
          return e.after(p, "afterDeserialize", S, l);
        }
        if (y !== "string")
          l.message("Expected a string. Received: " + r.smart(v));
        else
          return e.after(p, "afterDeserialize", v, l);
      }
    } else
      return e.after(p, "afterDeserialize", v, l);
  }
  return lm;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var fm, q$;
function wz() {
  if (q$)
    return fm;
  q$ = 1;
  const e = Yt, t = ms();
  fm = r;
  function r(n, s, a, o, c, l, d, p) {
    const { populate: h, value: g } = t.getAttributes(l[d]), m = o.type;
    if (!h) {
      l[d] = g;
      return;
    }
    if (!(o.hasOwnProperty("x-condition") && !c[o["x-condition"]]))
      if (o.allOf)
        o.allOf.forEach((v) => {
          r(n, s, a, v, c, l, d, p);
        });
      else if (o.anyOf || o.oneOf) {
        const v = o.anyOf ? "anyOf" : "oneOf";
        if (!o.discriminator)
          n.message("Unable to populate " + v + " without a discriminator");
        else {
          const { name: _, key: y, schema: w } = o.discriminate(g, !0);
          w ? r(n, s, a, w, c, l, d, p) : n.message('Discriminator property "' + y + '" as "' + _ + '" did not map to a schema');
        }
      } else if (o.not)
        n.message('Cannot populate "not" schemas');
      else if (m === "array")
        if (g !== void 0 && !Array.isArray(g))
          n.message("Provided value must be an array. Received: " + e.smart(g));
        else {
          const v = i(n, o, c, l, d, p);
          o.items && Array.isArray(v) && (a < 0 ? s.message("Reached maximum depth") : v.forEach((_, y) => {
            r(n.at(y), s.at(y), a - 1, o.items, c, v, y, p);
          }));
        }
      else if (m === "object")
        if (g !== void 0 && (!g || typeof g != "object"))
          n.message("Provided value must be an object. Received: " + e.smart(g));
        else if (a < 0)
          s.message("Reached maximum depth");
        else {
          const v = i(n, o, c, l, d, p), _ = v || {}, y = o.additionalProperties;
          if (y) {
            const $ = o.properties || {};
            Object.keys(_).forEach((E) => {
              $.hasOwnProperty(E) || r(n.at(E), s.at(E), a - 1, y, c, _, E, p);
            });
          }
          const w = o.properties;
          w && Object.keys(w).forEach(($) => {
            r(n.at($), s.at($), a - 1, w[$], c, _, $, p);
          }), (v || Object.keys(_).length) && (l[d] = _);
        }
      else
        i(n, o, c, l, d, p);
  }
  function i(n, s, a, o, c, l) {
    if (!(s.hasOwnProperty("x-condition") && !a[s["x-condition"]])) {
      if (o[c] === void 0) {
        const d = s.type;
        if (l.variables && s.hasOwnProperty("x-variable") && a.hasOwnProperty(s["x-variable"])) {
          const p = a[s["x-variable"]];
          p !== void 0 && (o[c] = p);
        } else if (l.templates && d === "string" && s.hasOwnProperty("x-template"))
          o[c] = l.injector(s["x-template"], a);
        else if (l.defaults && s.hasOwnProperty("x-default")) {
          const p = s["x-default"];
          p !== void 0 && (o[c] = l.templateDefaults && typeof p == "string" ? l.injector(p, a) : p);
        } else if (l.defaults && s.hasOwnProperty("default")) {
          const p = s.default;
          p !== void 0 && (o[c] = l.templateDefaults && typeof p == "string" ? l.injector(p, a) : p);
        }
      }
      return o[c];
    }
  }
  return fm;
}
var dl = { exports: {} }, dm = {}, pm, F$;
function ud() {
  return F$ || (F$ = 1, pm = {
    ROOT: 0,
    GROUP: 1,
    POSITION: 2,
    SET: 3,
    RANGE: 4,
    REPETITION: 5,
    REFERENCE: 6,
    CHAR: 7
  }), pm;
}
var yi = {}, U$;
function DP() {
  if (U$)
    return yi;
  U$ = 1;
  const e = ud(), t = () => [{ type: e.RANGE, from: 48, to: 57 }], r = () => [
    { type: e.CHAR, value: 95 },
    { type: e.RANGE, from: 97, to: 122 },
    { type: e.RANGE, from: 65, to: 90 }
  ].concat(t()), i = () => [
    { type: e.CHAR, value: 9 },
    { type: e.CHAR, value: 10 },
    { type: e.CHAR, value: 11 },
    { type: e.CHAR, value: 12 },
    { type: e.CHAR, value: 13 },
    { type: e.CHAR, value: 32 },
    { type: e.CHAR, value: 160 },
    { type: e.CHAR, value: 5760 },
    { type: e.RANGE, from: 8192, to: 8202 },
    { type: e.CHAR, value: 8232 },
    { type: e.CHAR, value: 8233 },
    { type: e.CHAR, value: 8239 },
    { type: e.CHAR, value: 8287 },
    { type: e.CHAR, value: 12288 },
    { type: e.CHAR, value: 65279 }
  ], n = () => [
    { type: e.CHAR, value: 10 },
    { type: e.CHAR, value: 13 },
    { type: e.CHAR, value: 8232 },
    { type: e.CHAR, value: 8233 }
  ];
  return yi.words = () => ({ type: e.SET, set: r(), not: !1 }), yi.notWords = () => ({ type: e.SET, set: r(), not: !0 }), yi.ints = () => ({ type: e.SET, set: t(), not: !1 }), yi.notInts = () => ({ type: e.SET, set: t(), not: !0 }), yi.whitespace = () => ({ type: e.SET, set: i(), not: !1 }), yi.notWhitespace = () => ({ type: e.SET, set: i(), not: !0 }), yi.anyChar = () => ({ type: e.SET, set: n(), not: !0 }), yi;
}
var B$;
function $z() {
  return B$ || (B$ = 1, function(e) {
    const t = ud(), r = DP(), i = "@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^ ?", n = { 0: 0, t: 9, n: 10, v: 11, f: 12, r: 13 };
    e.strToChars = function(s) {
      var a = /(\[\\b\])|(\\)?\\(?:u([A-F0-9]{4})|x([A-F0-9]{2})|(0?[0-7]{2})|c([@A-Z[\\\]^?])|([0tnvfr]))/g;
      return s = s.replace(a, function(o, c, l, d, p, h, g, m) {
        if (l)
          return o;
        var v = c ? 8 : d ? parseInt(d, 16) : p ? parseInt(p, 16) : h ? parseInt(h, 8) : g ? i.indexOf(g) : n[m], _ = String.fromCharCode(v);
        return /[[\]{}^$.|?*+()]/.test(_) && (_ = "\\" + _), _;
      }), s;
    }, e.tokenizeClass = (s, a) => {
      for (var o = [], c = /\\(?:(w)|(d)|(s)|(W)|(D)|(S))|((?:(?:\\)(.)|([^\]\\]))-(?:\\)?([^\]]))|(\])|(?:\\)?([^])/g, l, d; (l = c.exec(s)) != null; )
        if (l[1])
          o.push(r.words());
        else if (l[2])
          o.push(r.ints());
        else if (l[3])
          o.push(r.whitespace());
        else if (l[4])
          o.push(r.notWords());
        else if (l[5])
          o.push(r.notInts());
        else if (l[6])
          o.push(r.notWhitespace());
        else if (l[7])
          o.push({
            type: t.RANGE,
            from: (l[8] || l[9]).charCodeAt(0),
            to: l[10].charCodeAt(0)
          });
        else if (d = l[12])
          o.push({
            type: t.CHAR,
            value: d.charCodeAt(0)
          });
        else
          return [o, c.lastIndex];
      e.error(a, "Unterminated character class");
    }, e.error = (s, a) => {
      throw new SyntaxError("Invalid regular expression: /" + s + "/: " + a);
    };
  }(dm)), dm;
}
var Aa = {}, V$;
function Ez() {
  if (V$)
    return Aa;
  V$ = 1;
  const e = ud();
  return Aa.wordBoundary = () => ({ type: e.POSITION, value: "b" }), Aa.nonWordBoundary = () => ({ type: e.POSITION, value: "B" }), Aa.begin = () => ({ type: e.POSITION, value: "^" }), Aa.end = () => ({ type: e.POSITION, value: "$" }), Aa;
}
var Z$;
function xz() {
  if (Z$)
    return dl.exports;
  Z$ = 1;
  const e = $z(), t = ud(), r = DP(), i = Ez();
  return dl.exports = (n) => {
    var s = 0, a, o, c = { type: t.ROOT, stack: [] }, l = c, d = c.stack, p = [], h = (S) => {
      e.error(n, `Nothing to repeat at column ${S - 1}`);
    }, g = e.strToChars(n);
    for (a = g.length; s < a; )
      switch (o = g[s++], o) {
        case "\\":
          switch (o = g[s++], o) {
            case "b":
              d.push(i.wordBoundary());
              break;
            case "B":
              d.push(i.nonWordBoundary());
              break;
            case "w":
              d.push(r.words());
              break;
            case "W":
              d.push(r.notWords());
              break;
            case "d":
              d.push(r.ints());
              break;
            case "D":
              d.push(r.notInts());
              break;
            case "s":
              d.push(r.whitespace());
              break;
            case "S":
              d.push(r.notWhitespace());
              break;
            default:
              /\d/.test(o) ? d.push({ type: t.REFERENCE, value: parseInt(o, 10) }) : d.push({ type: t.CHAR, value: o.charCodeAt(0) });
          }
          break;
        case "^":
          d.push(i.begin());
          break;
        case "$":
          d.push(i.end());
          break;
        case "[":
          var m;
          g[s] === "^" ? (m = !0, s++) : m = !1;
          var v = e.tokenizeClass(g.slice(s), n);
          s += v[1], d.push({
            type: t.SET,
            set: v[0],
            not: m
          });
          break;
        case ".":
          d.push(r.anyChar());
          break;
        case "(":
          var _ = {
            type: t.GROUP,
            stack: [],
            remember: !0
          };
          o = g[s], o === "?" && (o = g[s + 1], s += 2, o === "=" ? _.followedBy = !0 : o === "!" ? _.notFollowedBy = !0 : o !== ":" && e.error(
            n,
            `Invalid group, character '${o}' after '?' at column ${s - 1}`
          ), _.remember = !1), d.push(_), p.push(l), l = _, d = _.stack;
          break;
        case ")":
          p.length === 0 && e.error(n, `Unmatched ) at column ${s - 1}`), l = p.pop(), d = l.options ? l.options[l.options.length - 1] : l.stack;
          break;
        case "|":
          l.options || (l.options = [l.stack], delete l.stack);
          var y = [];
          l.options.push(y), d = y;
          break;
        case "{":
          var w = /^(\d+)(,(\d+)?)?\}/.exec(g.slice(s)), $, E;
          w !== null ? (d.length === 0 && h(s), $ = parseInt(w[1], 10), E = w[2] ? w[3] ? parseInt(w[3], 10) : 1 / 0 : $, s += w[0].length, d.push({
            type: t.REPETITION,
            min: $,
            max: E,
            value: d.pop()
          })) : d.push({
            type: t.CHAR,
            value: 123
          });
          break;
        case "?":
          d.length === 0 && h(s), d.push({
            type: t.REPETITION,
            min: 0,
            max: 1,
            value: d.pop()
          });
          break;
        case "+":
          d.length === 0 && h(s), d.push({
            type: t.REPETITION,
            min: 1,
            max: 1 / 0,
            value: d.pop()
          });
          break;
        case "*":
          d.length === 0 && h(s), d.push({
            type: t.REPETITION,
            min: 0,
            max: 1 / 0,
            value: d.pop()
          });
          break;
        default:
          d.push({
            type: t.CHAR,
            value: o.charCodeAt(0)
          });
      }
    return p.length !== 0 && e.error(n, "Unterminated group"), c;
  }, dl.exports.types = t, dl.exports;
}
var hm, z$;
function Oz() {
  if (z$)
    return hm;
  z$ = 1;
  class e {
    constructor(i, n) {
      this.low = i, this.high = n, this.length = 1 + n - i;
    }
    overlaps(i) {
      return !(this.high < i.low || this.low > i.high);
    }
    touches(i) {
      return !(this.high + 1 < i.low || this.low - 1 > i.high);
    }
    // Returns inclusive combination of SubRanges as a SubRange.
    add(i) {
      return new e(
        Math.min(this.low, i.low),
        Math.max(this.high, i.high)
      );
    }
    // Returns subtraction of SubRanges as an array of SubRanges.
    // (There's a case where subtraction divides it in 2)
    subtract(i) {
      return i.low <= this.low && i.high >= this.high ? [] : i.low > this.low && i.high < this.high ? [
        new e(this.low, i.low - 1),
        new e(i.high + 1, this.high)
      ] : i.low <= this.low ? [new e(i.high + 1, this.high)] : [new e(this.low, i.low - 1)];
    }
    toString() {
      return this.low == this.high ? this.low.toString() : this.low + "-" + this.high;
    }
  }
  class t {
    constructor(i, n) {
      this.ranges = [], this.length = 0, i != null && this.add(i, n);
    }
    _update_length() {
      this.length = this.ranges.reduce((i, n) => i + n.length, 0);
    }
    add(i, n) {
      var s = (a) => {
        for (var o = 0; o < this.ranges.length && !a.touches(this.ranges[o]); )
          o++;
        for (var c = this.ranges.slice(0, o); o < this.ranges.length && a.touches(this.ranges[o]); )
          a = a.add(this.ranges[o]), o++;
        c.push(a), this.ranges = c.concat(this.ranges.slice(o)), this._update_length();
      };
      return i instanceof t ? i.ranges.forEach(s) : (n == null && (n = i), s(new e(i, n))), this;
    }
    subtract(i, n) {
      var s = (a) => {
        for (var o = 0; o < this.ranges.length && !a.overlaps(this.ranges[o]); )
          o++;
        for (var c = this.ranges.slice(0, o); o < this.ranges.length && a.overlaps(this.ranges[o]); )
          c = c.concat(this.ranges[o].subtract(a)), o++;
        this.ranges = c.concat(this.ranges.slice(o)), this._update_length();
      };
      return i instanceof t ? i.ranges.forEach(s) : (n == null && (n = i), s(new e(i, n))), this;
    }
    intersect(i, n) {
      var s = [], a = (o) => {
        for (var c = 0; c < this.ranges.length && !o.overlaps(this.ranges[c]); )
          c++;
        for (; c < this.ranges.length && o.overlaps(this.ranges[c]); ) {
          var l = Math.max(this.ranges[c].low, o.low), d = Math.min(this.ranges[c].high, o.high);
          s.push(new e(l, d)), c++;
        }
      };
      return i instanceof t ? i.ranges.forEach(a) : (n == null && (n = i), a(new e(i, n))), this.ranges = s, this._update_length(), this;
    }
    index(i) {
      for (var n = 0; n < this.ranges.length && this.ranges[n].length <= i; )
        i -= this.ranges[n].length, n++;
      return this.ranges[n].low + i;
    }
    toString() {
      return "[ " + this.ranges.join(", ") + " ]";
    }
    clone() {
      return new t(this);
    }
    numbers() {
      return this.ranges.reduce((i, n) => {
        for (var s = n.low; s <= n.high; )
          i.push(s), s++;
        return i;
      }, []);
    }
    subranges() {
      return this.ranges.map((i) => ({
        low: i.low,
        high: i.high,
        length: 1 + i.high - i.low
      }));
    }
  }
  return hm = t, hm;
}
var mm, W$;
function Pz() {
  if (W$)
    return mm;
  W$ = 1;
  const e = xz(), t = Oz(), r = e.types;
  return mm = class tu {
    /**
     * @constructor
     * @param {RegExp|String} regexp
     * @param {String} m
     */
    constructor(n, s) {
      if (this._setDefaults(n), n instanceof RegExp)
        this.ignoreCase = n.ignoreCase, this.multiline = n.multiline, n = n.source;
      else if (typeof n == "string")
        this.ignoreCase = s && s.indexOf("i") !== -1, this.multiline = s && s.indexOf("m") !== -1;
      else
        throw new Error("Expected a regexp or string");
      this.tokens = e(n);
    }
    /**
     * Checks if some custom properties have been set for this regexp.
     *
     * @param {RandExp} randexp
     * @param {RegExp} regexp
     */
    _setDefaults(n) {
      this.max = n.max != null ? n.max : tu.prototype.max != null ? tu.prototype.max : 100, this.defaultRange = n.defaultRange ? n.defaultRange : this.defaultRange.clone(), n.randInt && (this.randInt = n.randInt);
    }
    /**
     * Generates the random string.
     *
     * @return {String}
     */
    gen() {
      return this._gen(this.tokens, []);
    }
    /**
     * Generate random string modeled after given tokens.
     *
     * @param {Object} token
     * @param {Array.<String>} groups
     * @return {String}
     */
    _gen(n, s) {
      var a, o, c, l, d;
      switch (n.type) {
        case r.ROOT:
        case r.GROUP:
          if (n.followedBy || n.notFollowedBy)
            return "";
          for (n.remember && n.groupNumber === void 0 && (n.groupNumber = s.push(null) - 1), a = n.options ? this._randSelect(n.options) : n.stack, o = "", l = 0, d = a.length; l < d; l++)
            o += this._gen(a[l], s);
          return n.remember && (s[n.groupNumber] = o), o;
        case r.POSITION:
          return "";
        case r.SET:
          var p = this._expand(n);
          return p.length ? String.fromCharCode(this._randSelect(p)) : "";
        case r.REPETITION:
          for (c = this.randInt(
            n.min,
            n.max === 1 / 0 ? n.min + this.max : n.max
          ), o = "", l = 0; l < c; l++)
            o += this._gen(n.value, s);
          return o;
        case r.REFERENCE:
          return s[n.value - 1] || "";
        case r.CHAR:
          var h = this.ignoreCase && this._randBool() ? this._toOtherCase(n.value) : n.value;
          return String.fromCharCode(h);
      }
    }
    /**
     * If code is alphabetic, converts to other case.
     * If not alphabetic, returns back code.
     *
     * @param {Number} code
     * @return {Number}
     */
    _toOtherCase(n) {
      return n + (97 <= n && n <= 122 ? -32 : 65 <= n && n <= 90 ? 32 : 0);
    }
    /**
     * Randomly returns a true or false value.
     *
     * @return {Boolean}
     */
    _randBool() {
      return !this.randInt(0, 1);
    }
    /**
     * Randomly selects and returns a value from the array.
     *
     * @param {Array.<Object>} arr
     * @return {Object}
     */
    _randSelect(n) {
      return n instanceof t ? n.index(this.randInt(0, n.length - 1)) : n[this.randInt(0, n.length - 1)];
    }
    /**
     * expands a token to a DiscontinuousRange of characters which has a
     * length and an index function (for random selecting)
     *
     * @param {Object} token
     * @return {DiscontinuousRange}
     */
    _expand(n) {
      if (n.type === e.types.CHAR)
        return new t(n.value);
      if (n.type === e.types.RANGE)
        return new t(n.from, n.to);
      {
        let s = new t();
        for (let a = 0; a < n.set.length; a++) {
          let o = this._expand(n.set[a]);
          if (s.add(o), this.ignoreCase)
            for (let c = 0; c < o.length; c++) {
              let l = o.index(c), d = this._toOtherCase(l);
              l !== d && s.add(d);
            }
        }
        return n.not ? this.defaultRange.clone().subtract(s) : this.defaultRange.clone().intersect(s);
      }
    }
    /**
     * Randomly generates and returns a number between a and b (inclusive).
     *
     * @param {Number} a
     * @param {Number} b
     * @return {Number}
     */
    randInt(n, s) {
      return n + Math.floor(Math.random() * (1 + s - n));
    }
    /**
     * Default range of characters to generate from.
     */
    get defaultRange() {
      return this._range = this._range || new t(32, 126);
    }
    set defaultRange(n) {
      this._range = n;
    }
    /**
     *
     * Enables use of randexp with a shorter call.
     *
     * @param {RegExp|String| regexp}
     * @param {String} m
     * @return {String}
     */
    static randexp(n, s) {
      var a;
      return typeof n == "string" && (n = new RegExp(n, s)), n._randexp === void 0 ? (a = new tu(n, s), n._randexp = a) : (a = n._randexp, a._setDefaults(n)), a.gen();
    }
    /**
     * Enables sugary /regexp/.gen syntax.
     */
    static sugar() {
      RegExp.prototype.gen = function() {
        return tu.randexp(this);
      };
    }
  }, mm;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var ym, H$;
function Sz() {
  if (H$)
    return ym;
  H$ = 1;
  const e = Pz(), t = Yt, { copy: r, randomOneOf: i, randomNumber: n, randomText: s } = t;
  ym = a;
  function a(c, l, d, p, h, g, m, v) {
    const _ = p.type, y = h[g];
    if (y && typeof y == "object") {
      if (d.get(y))
        return;
      d.set(y, !0);
    }
    if (!(v > m.maxDepth)) {
      if (p.hasOwnProperty("default") && Math.random() < m.defaultPossibility)
        h[g] = t.copy(p.default);
      else if (p.enum)
        h[g] = r(i(p.enum));
      else if (p.allOf) {
        const [w, $] = p.allOfMerged;
        $ ? l.nest("Cannot generate random value for schema with allOf").push($) : a(c, l, d, w, h, g, m, v);
      } else if (p.anyOf || p.oneOf) {
        const w = p.anyOf ? "anyOf" : "oneOf";
        if (p.discriminator) {
          const { name: $, key: E, schema: S } = p.discriminate(y, !0);
          if (S)
            a(c, l, d, S, h, g, m, v);
          else if ($ === void 0) {
            const R = i(p[w]);
            a(c, l, d, R, h, g, m, v);
          } else
            c.message('Discriminator property "' + E + '" as "' + $ + '" did not map to a schema');
        } else {
          const $ = i(p[w]);
          a(c, l, d, $, h, g, m, v);
        }
      } else if (p.not)
        l.message("Cannot generate random value for schema with not");
      else if (_ === "array") {
        const w = p.hasOwnProperty("minItems") ? p.minItems : 0;
        let $ = p.hasOwnProperty("maxItems") ? p.maxItems : w + m.arrayVariation - Math.round(0.5 * v);
        $ < w && ($ = w);
        const E = n({ min: w, max: $ });
        if (v > 0 && h.hasOwnProperty(g) && !Array.isArray(h[g]))
          c.message("Provided value is not an array");
        else {
          const S = Array.isArray(y) ? y : [];
          for (let R = 0; R < E; R++) {
            let j = !0, L = m.uniqueItemRetry;
            for (; j && L; ) {
              const K = {};
              a(c.at(R), l.at(R), d, p.items, K, "value", m, v + 1);
              const ae = K.value;
              j = p.uniqueItems && S.findIndex((ye) => t.same(ye, ae)) !== -1, j ? j && !L && l.message("Cannot generate example due to too narrowly scoped schema constraints") : S[R] = ae;
            }
          }
          h[g] = S;
        }
      } else if (_ === "object")
        if (v > 0 && h.hasOwnProperty(g) && !t.isObject(h[g]))
          c.message("Provided value is not a plain object");
        else {
          const w = p.properties ? Object.keys(p.properties) : [], $ = h[g] || {};
          let E = 0;
          p.required && p.required.forEach((j) => {
            const L = w.indexOf(j);
            L !== -1 && w.splice(L, 1);
            let K = p.properties && p.properties[j];
            K || (K = p.additionalProperties), K === !0 && (K = o(p)), a(c.at(j), l.at(j), d, K, $, j, m, v + 1), E++;
          });
          let S = w.length;
          const R = p.hasOwnProperty("maxProperties") ? p.maxProperties : Number.MAX_SAFE_INTEGER;
          for (; S && E < R; ) {
            if (Math.random() < m.definedPropertyPossibility) {
              const j = Math.floor(Math.random() * S), L = w[j];
              a(c.at(L), l.at(L), d, p.properties[L], $, L, m, v + 1), E++;
            }
            S--;
          }
          if (p.additionalProperties) {
            const j = p.hasOwnProperty("minProperties") ? p.minProperties : 0;
            let L = E < j || Math.random() < m.additionalPropertiesPossibility, K = 1;
            for (; L && E < R; ) {
              const ae = "additionalProperty" + K++;
              if (!$.hasOwnProperty(ae)) {
                const ye = p.additionalProperties === !0 ? o(p) : p.additionalProperties;
                a(c.at(ae), l.at(ae), d, ye, $, ae, m, v + 1), E++, L = E < j || Math.random() < m.additionalPropertiesPossibility;
              }
            }
          }
          h[g] = $;
        }
      else if (!h.hasOwnProperty(g) || v === 0) {
        const w = p.enforcerData.staticData.dataTypes, $ = w[p.type] && w[p.type][p.format] || null;
        if ($ && $.random)
          h[g] = $.random({ exception: c, schema: p }, { chooseOne: i, randomNumber: n, randomText: s });
        else if (_ === "boolean")
          h[g] = i([!0, !1]);
        else if (_ === "integer" || _ === "number") {
          const E = _ === "integer" ? 0 : n({ min: 1, max: 4 }), S = !!p.exclusiveMinimum, R = !!p.exclusiveMaximum, j = p.hasOwnProperty("multipleOf") ? p.multipleOf : 0, L = p.hasOwnProperty("minimum"), K = p.hasOwnProperty("maximum");
          let ae, ye;
          L && !K ? (ae = p.minimum, ye = ae + m.numberVariation) : !L && K ? (ye = p.maximum, ae = ye - m.numberVariation) : L && K ? (ae = p.minimum, ye = p.maximum) : (ae = -1 * Math.floor(m.numberVariation * 0.25), ye = Math.ceil(m.numberVariation * 0.75)), h[g] = n({ min: ae, max: ye, multipleOf: j, exclusiveMin: S, exclusiveMax: R, decimalPlaces: E });
        } else if (_ === "string")
          if (p.hasOwnProperty("pattern"))
            h[g] = new e(p.pattern).gen();
          else {
            const E = {};
            p.hasOwnProperty("minLength") && (E.minLength = p.minLength), p.hasOwnProperty("maxLength") && (E.maxLength = p.maxLength), h[g] = s(E);
          }
      }
    }
  }
  function o(c) {
    const l = i([
      { type: "boolean" },
      { type: "integer" },
      { type: "number" },
      { type: "string" },
      { type: "string", format: "date" },
      { type: "string", format: "date-time" }
    ]), [d] = new c.enforcerData.context.Schema(l);
    return d;
  }
  return ym;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var gm, G$;
function Az() {
  if (G$)
    return gm;
  G$ = 1;
  const e = b0(), t = NP(), r = Yt, i = ms();
  gm = n;
  function n(s, a, o, c) {
    let { serialize: l, value: d } = i.getAttributes(c);
    if (!l)
      return c;
    const p = o.type;
    if (d && typeof d == "object") {
      const g = a.get(o);
      if (g && g.includes(d))
        return d;
      a.set(o, [d]);
    }
    const h = e.runHooks(o, "beforeSerialize", d, s);
    if (d = h.value, h.done)
      return d;
    if (d === null && (o.nullable || o["x-nullable"]))
      return e.after(o, "afterSerialize", d, s);
    if (o.allOf) {
      const g = {}, m = s.nest("Unable to serialize allOf");
      return o.allOf.forEach((v, _) => {
        const y = n(m.at(_), a, v, c);
        Object.assign(g, y);
      }), e.after(o, "afterSerialize", Object.assign(d, g), s);
    } else if (o.anyOf || o.oneOf) {
      let g;
      if (o.discriminator) {
        const { name: m, key: v, schema: _ } = o.discriminate(d, !0);
        _ ? g = Object.assign(d, n(s, a, _, c)) : s.message('Discriminator property "' + v + '" as "' + m + '" did not map to a schema');
      } else
        g = t.anyOneOf(o, c, s, a, n, !0);
      return e.after(o, "afterSerialize", g, s);
    } else if (p === "array") {
      if (Array.isArray(d))
        return o.items && d.forEach((g, m) => {
          d[m] = n(s.at(m), a, o.items, i.inherit(g, { serialize: l }));
        }), e.after(o, "afterSerialize", d, s);
      s.message("Expected an array. Received: " + r.smart(d));
    } else if (p === "object")
      if (r.isObject(d)) {
        const g = o.additionalProperties, m = o.properties || {};
        if (Object.keys(d).forEach((v) => {
          m.hasOwnProperty(v) ? d[v] = n(s.at(v), a, m[v], d[v]) : g && (d[v] = n(s.at(v), a, g, d[v]));
        }), o.discriminator) {
          const { name: v, key: _, schema: y } = o.discriminate(d, !0);
          y ? Object.assign(d, n(s, a, y, c)) : s.message('Discriminator property "' + _ + '" as "' + v + '" did not map to a schema');
        }
        return e.after(o, "afterSerialize", d, s);
      } else
        s.message("Expected an object. Received: " + r.smart(c));
    else if (o !== !0) {
      const g = o.enforcerData.staticData.dataTypes, m = g[o.type] && g[o.type][o.format] || {};
      if (m.serialize || (m.serialize = function({ value: v }) {
        return v;
      }), p === "boolean") {
        let v = m.serialize({
          exception: s,
          schema: o,
          value: d
        });
        return typeof v != "boolean" && s.message("Unable to serialize to a boolean. Received: " + r.smart(d)), e.after(o, "afterSerialize", v, s);
      } else if (p === "integer") {
        let v = m.serialize({
          exception: s,
          schema: o,
          value: d
        });
        return (typeof v != "number" || isNaN(v) || v !== Math.round(v)) && s.message("Unable to serialize to an integer. Received: " + r.smart(d)), e.after(o, "afterSerialize", v, s);
      } else if (p === "number") {
        let v = m.serialize({
          exception: s,
          schema: o,
          value: d
        });
        return (typeof v != "number" || isNaN(v)) && s.message("Unable to serialize to a number. Received: " + r.smart(d)), e.after(o, "afterSerialize", v, s);
      } else if (p === "string") {
        let v = m.serialize({
          exception: s,
          schema: o,
          value: d
        });
        return typeof v != "string" && s.message("Unable to serialize to a string. Received: " + r.smart(d)), e.after(o, "afterSerialize", v, s);
      }
    } else
      return e.after(o, "afterSerialize", d, s);
  }
  return gm;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var vm, K$;
function Cz() {
  if (K$)
    return vm;
  K$ = 1;
  const e = b0(), t = Nn, r = Yt, i = ms();
  vm = n;
  function n(a, o, c, l, d) {
    let { validate: p, value: h } = i.getAttributes(l);
    if (!p)
      return l;
    const g = c.type;
    if (h && typeof h == "object") {
      let v = o.get(h);
      if (v && v.indexOf(c) !== -1)
        return;
      v || (v = [], o.set(h, v)), v.push(c);
    }
    const m = e.runHooks(c, "beforeValidate", h, a);
    if (h = m.value, m.done)
      return h;
    if (h === null && (c.nullable || c["x-nullable"]))
      return e.after(c, "afterValidate", h, a);
    if (c.allOf) {
      const v = a.nest("Did not validate against all schemas");
      c.allOf.forEach((_, y) => {
        n(v.at(y), o, _, l, d);
      });
    } else if (c.anyOf)
      if (c.discriminator) {
        const v = c.discriminate(h, !0), _ = v.schema, y = v.key;
        if (!_)
          a.message('Discriminator property "' + y + '" as "' + h[y] + '" did not map to a schema');
        else {
          const w = a.at(h[y]);
          n(w, o, _, h, d);
        }
      } else {
        const v = t("Did not validate against at least one schema"), _ = c.anyOf.length;
        let y = !1;
        for (let w = 0; w < _; w++) {
          const $ = v.at(w);
          if (n($, o, c.anyOf[w], h, d), !$.hasException) {
            y = !0;
            break;
          }
        }
        y || a.push(v);
      }
    else if (c.oneOf)
      if (c.discriminator) {
        const { name: v, key: _, schema: y } = c.discriminate(h, !0);
        if (!y)
          a.message('Discriminator property "' + _ + '" as "' + v + '" did not map to a schema');
        else {
          const w = a.at(h[_]);
          n(w, o, y, h, d);
        }
      } else {
        const v = t("Did not validate against exactly one schema"), _ = c.oneOf.length;
        let y = 0;
        for (let w = 0; w < _; w++) {
          const $ = t("Invalid value");
          n($, o, c.oneOf[w], h, d), $.hasException ? v.at(w).push($) : (y++, v.at(w).message("Valid value"));
        }
        y !== 1 && a.push(v);
      }
    else if (c.not) {
      const v = t("");
      n(v, o, c.not, h, d), v.hasException || a.message("Value should not validate against schema");
    } else if (g === "array")
      if (!Array.isArray(h))
        a.message("Expected an array. Received: " + r.smart(h));
      else {
        const v = h.length;
        if (c.hasOwnProperty("maxItems") && c.maxItems < v && a.message("Too many items in the array. Maximum of " + c.maxItems + ". Found " + v + " items"), c.hasOwnProperty("minItems") && c.minItems > v && a.message("Too few items in the array. Minimum of " + c.minItems + ". Found " + v + " items"), c.uniqueItems) {
          const _ = [];
          h.forEach((y, w) => {
            const $ = _.length;
            let E;
            for (let S = 0; S < $; S++)
              if (r.same(y, _[S])) {
                a.message("Array items must be unique. Value is not unique at index " + w), E = !0;
                break;
              }
            E || _.push(y);
          });
        }
        c.items && h.forEach((_, y) => {
          n(a.at(y), o, c.items, _, d);
        });
      }
    else if (g === "object")
      if (!r.isObject(h))
        a.message("Expected a non-null object. Received: " + r.smart(h));
      else {
        const v = c.properties || {}, _ = d.readWriteMode, y = [], w = c.required ? c.required.filter((E) => {
          const S = v[E];
          return !d.readWriteMode || !S || d.readWriteMode === "write" && !S.readOnly || d.readWriteMode === "read" && !S.writeOnly;
        }) : [], $ = Object.keys(h);
        if ($.forEach((E) => {
          const S = w.indexOf(E);
          if (S !== -1 && w.splice(S, 1), v.hasOwnProperty(E)) {
            const R = v[E];
            (_ === "write" && R.readOnly || _ === "read" && R.writeOnly) && y.push(E), n(a.at(E), o, R, h[E], d);
          } else if (c.additionalProperties === !1)
            a.at(E).message("Property not allowed");
          else if (typeof c.additionalProperties == "object") {
            const R = c.additionalProperties;
            (_ === "write" && R.readOnly || _ === "read" && R.writeOnly) && y.push(E), n(a.at(E), o, c.additionalProperties, h[E], d);
          } else
            d.isExample && _0().config.examplesWarnAdditionalProperty === !0 && a.at(E).message("Property is an additional property");
        }), w.length > 0 && a.message("One or more required properties missing: " + w.join(", ")), y.length > 0 && (_ === "write" ? a.message("Cannot write to read only properties: " + y.join(", ")) : _ === "read" && a.message("Cannot read from write only properties: " + y.join(", "))), s(a, c, "object property count", "maxProperties", "minProperties", !1, $.length, c.maxProperties, c.minProperties), c.discriminator) {
          const E = c.discriminate(h, !0), { name: S, key: R } = E;
          E.schema ? n(a, o, E.schema, h, d) : S && a.message('Discriminator property "' + R + '" as "' + S + '" did not map to a schema');
        }
      }
    else {
      const v = c.enforcerData.staticData.dataTypes, _ = v[c.type] && v[c.type][c.format] || { validate: null };
      if (_.validate)
        _.validate({ exception: a, schema: c, value: h });
      else if (g === "boolean")
        typeof h != "boolean" && a.message("Expected a boolean. Received: " + r.smart(h));
      else if (g === "integer")
        isNaN(h) || Math.round(h) !== h || typeof h != "number" ? a.message("Expected an integer. Received: " + r.smart(h)) : (d.maxMin !== !1 && s(a, c, "integer", "maximum", "minimum", !0, h, c.maximum, c.minimum), c.multipleOf && h % c.multipleOf !== 0 && a.message("Expected a multiple of " + c.multipleOf + ". Received: " + r.smart(h)));
      else if (g === "number")
        isNaN(h) || typeof h != "number" ? a.message("Expected a number. Received: " + r.smart(h)) : (d.maxMin !== !1 && s(a, c, "number", "maximum", "minimum", !0, h, c.maximum, c.minimum), c.multipleOf && !Number.isInteger(h / c.multipleOf) && a.message("Expected a multiple of " + c.multipleOf + ". Received: " + r.smart(h)));
      else if (c.type === "string")
        if (typeof h != "string")
          a.message("Expected a string. Received: " + r.smart(h));
        else {
          const y = h.length;
          c.hasOwnProperty("maxLength") && y > c.maxLength && a.message("String too long. " + r.smart(h) + " (" + y + ") above maximum length of " + c.maxLength), c.hasOwnProperty("minLength") && y < c.minLength && a.message("String too short. " + r.smart(h) + " (" + y + ") below minimum length of " + c.minLength), c.hasOwnProperty("pattern") && !c.pattern.test(h) && a.message("String does not match required pattern " + c.pattern + " with value: " + r.smart(h));
        }
    }
    if (c.enum && d.enum !== !1) {
      const v = c.enum.length;
      let _;
      for (let y = 0; y < v; y++)
        if (r.same(h, c.enum[y])) {
          _ = !0;
          break;
        }
      _ || a.message("Value " + r.smart(h) + " did not meet enum requirements");
    }
    e.after(c, "afterValidate", h, a, !0);
  }
  function s(a, o, c, l, d, p, h, g, m) {
    o.hasOwnProperty(l) && (p && o.exclusiveMaximum && h >= g ? a.message("Expected " + c + " to be less than " + r.smart(o.serialize(o[l]).value) + ". Received: " + r.smart(o.serialize(h).value)) : h > g && a.message("Expected " + c + " to be less than or equal to " + r.smart(o.serialize(o[l]).value) + ". Received: " + r.smart(o.serialize(h).value))), o.hasOwnProperty(d) && (p && o.exclusiveMinimum && h <= m ? a.message("Expected " + c + " to be greater than " + r.smart(o.serialize(o[d]).value) + ". Received: " + r.smart(o.serialize(h).value)) : h < m && a.message("Expected " + c + " to be greater than or equal to " + r.smart(o.serialize(o[d]).value) + ". Received: " + r.smart(o.serialize(h).value)));
  }
  return vm;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var Y$;
function J$() {
  return Y$ || (Y$ = 1, function(e) {
    const t = rr, r = Nn, i = CP, n = hs, s = _z(), a = wz(), o = Sz(), c = Az(), l = Cz(), d = Yt, p = ms(), h = d.freeze, g = /^https?:\/\//, m = {
      colon: w(() => /:([_$a-z][_$a-z0-9]*)/ig),
      doubleHandlebar: w(() => /{{([_$a-z][_$a-z0-9]*)}}/ig),
      handlebar: w(() => /{([_$a-z][_$a-z0-9]*)}/ig)
    }, v = [
      { type: "array", properties: ["items", "maxItems", "minItems", "uniqueItems"] },
      { type: "number", properties: ["exclusiveMaximum", "exclusiveMinimum", "maximum", "minimum", "multpleOf"] },
      { type: "object", properties: ["additionProperties", "maxProperties", "minProperties", "properties"] },
      { type: "string", properties: ["maxLength", "minLength", "pattern"] }
    ], _ = {
      /**
       * Take a serialized (ready for HTTP transmission) value and deserialize it.
       * Converts strings of binary, byte, date, and date-time to JavaScript equivalents.
       * @param {*} value
       * @param {object} [options]
       * @param {boolean} [options.strict=true] Whether to be strict on input when deserializing.
       * @returns {EnforcerResult<*>}
       */
      deserialize: function(te, pe) {
        pe || (pe = {}), pe.hasOwnProperty("strict") || (pe.strict = !0);
        const de = r("Unable to deserialize value"), Ee = s(de, /* @__PURE__ */ new Map(), this, d.copy(te), pe);
        return new n(Ee, de);
      },
      /**
       * Get discriminator key and schema.
       * @param {*} value
       * @param {boolean=false} details
       * @returns {Schema|{ key:string, name:string, schema:Schema }}
       */
      discriminate: function(te, pe) {
        const { major: de, root: Ee } = this.enforcerData, Re = this.discriminator, _e = Ee.result;
        let ie, Y, V;
        if (Re) {
          if (de === 2)
            ie = Re, Y = Re && te && te.hasOwnProperty(Re) ? te[Re] : void 0, Y && (V = _e.definitions && _e.definitions[Y]);
          else if (de === 3 && (ie = Re.propertyName, Y = Re && te && te.hasOwnProperty(Re.propertyName) ? te[Re.propertyName] : void 0, Y)) {
            const z = Re.mapping;
            V = z && z.hasOwnProperty(Y) ? z[Y] : _e.components && _e.components.schemas && _e.components.schemas[Y];
          }
          return pe ? { key: ie, name: Y, schema: V } : V;
        }
      },
      /**
       * Take a non plain object and convert it into a plain object far enough so that validation and serialization can occur.
       * @param {*} value
       * @returns {*}
       */
      formalize: function(te) {
        return this.enforcerData.context.Schema.formalize(te);
      },
      /**
       * Populate a value from a list of parameters.
       * @param {object} [params]
       * @param {*} [value]
       * @param {object} [options]
       * @param {boolean} [options.copy=false]
       * @param {boolean} [options.conditions=true]
       * @param {boolean} [options.defaults=true]
       * @param {number} [options.depth=100]
       * @param {string} [options.replacement='handlebar']
       * @param {boolean} [options.templateDefaults=true]
       * @param {boolean} [options.templates=true]
       * @param {boolean} [options.variables=true]
       * @returns {EnforcerResult<*>}
       */
      populate: function(te, pe, de = {}) {
        if (te == null && (te = {}), !te || !d.isObject(te))
          throw Error("Invalid params specified. Must be a plain object");
        if (!de || !d.isObject(de))
          throw Error("Invalid options specified. Must be a plain object");
        if (de.hasOwnProperty("copy") || (de.copy = !1), de.hasOwnProperty("conditions") || (de.conditions = !0), de.hasOwnProperty("defaults") || (de.defaults = !0), de.hasOwnProperty("depth") || (de.depth = 100), de.hasOwnProperty("replacement") || (de.replacement = "handlebar"), de.hasOwnProperty("templateDefaults") || (de.templateDefaults = !0), de.hasOwnProperty("templates") || (de.templates = !0), de.hasOwnProperty("variables") || (de.variables = !0), !d.isInteger(de.depth) || de.depth < 0)
          throw Error("Invalid depth specified. Expected a non-negative integer");
        if (!m.hasOwnProperty(de.replacement))
          throw Error("Invalid replacement type specified. Expected one of: " + Object.keys(m).join(", "));
        de.injector = m[de.replacement], te || (te = {}), de.copy && (pe = d.copy(pe));
        const Ee = { value: pe }, Re = r("Unable to populate value"), _e = r("One or more warnings found while populating value");
        return a(Re, _e, de.depth - 1, this, te, Ee, "value", de), new n(Ee.value, Re, _e);
      },
      /**
       * Produce a random value for the schema.
       * @param {*} [value] An initial value to add random values to.
       * @param {object} [options]
       * @param {number} [options.additionalPropertiesPossibility=0]
       * @param {number} [options.arrayVariation=4]
       * @param {boolean} [options.copy=false]
       * @param {number} [options.defaultPossibility=.25]
       * @param {number} [options.definedPropertyPossibility=.80]
       * @param {number} [options.maxDepth=10]
       * @param {number} [options.numberVariation=1000]
       * @param {number} [options.uniqueItemRetry=5]
       * @returns {EnforcerResult<*>}
       */
      random: function(te, pe = {}) {
        if (!pe || !d.isObject(pe))
          throw Error("Invalid options specified. Must be a plain object");
        if (pe.hasOwnProperty("additionalPropertiesPossibility") || (pe.additionalPropertiesPossibility = 0), pe.hasOwnProperty("arrayVariation") || (pe.arrayVariation = 4), pe.hasOwnProperty("copy") || (pe.copy = !1), pe.hasOwnProperty("defaultPossibility") || (pe.defaultPossibility = 0.25), pe.hasOwnProperty("definedPropertyPossibility") || (pe.definedPropertyPossibility = 0.8), pe.hasOwnProperty("maxDepth") || (pe.maxDepth = 10), pe.hasOwnProperty("numberVariation") || (pe.numberVariation = 1e3), pe.hasOwnProperty("uniqueItemRetry") || (pe.uniqueItemRetry = 5), pe.additionalPropertiesPossibility < 0 || pe.additionalPropertiesPossibility > 1)
          throw Error('The option "additionalPropertiesPossibility" must be between 0 and 1 inclusive');
        if (pe.defaultPossibility < 0 || pe.defaultPossibility > 1)
          throw Error('The option "defaultPossibility" must be between 0 and 1 inclusive');
        if (pe.definedPropertyPossibility < 0 || pe.definedPropertyPossibility > 1)
          throw Error('The option "definedPropertyPossibility" must be between 0 and 1 inclusive');
        const de = r("Unable to generate random value"), Ee = r("One or more warnings found while generating random value"), Re = { root: pe.copy ? d.copy(te) : te };
        return o(de, Ee, /* @__PURE__ */ new Map(), this, Re, "root", pe, 0), new n(Re.root, de, Ee);
      },
      /**
       * Take a deserialized (not ready for HTTP transmission) value and serialize it.
       * Converts Buffer and Date objects into string equivalent.
       * @param value
       * @returns {EnforcerResult<*>}
       */
      serialize: function(te) {
        const pe = r("Unable to serialize value"), de = c(pe, /* @__PURE__ */ new Map(), this, d.copy(te));
        return new n(de, pe);
      },
      /**
       * Check to see if the value is valid for this schema.
       * @param {*} value
       * @param {object} [options]
       * @param {string} [options.readWriteMode] Can be undefined, "read", or "write"
       * @returns {EnforcerException|undefined}
       */
      validate: function(te, pe) {
        const de = r("Invalid value");
        if (pe || (pe = {}), l(de, /* @__PURE__ */ new Map(), this, te, pe), de.hasException)
          return de;
      }
    };
    e.exports = {
      init: function(te) {
        const { exception: pe, major: de, plugins: Ee, refParser: Re, staticData: _e, warn: ie, options: Y, definition: V } = te, z = Y.exceptionSkipCodes, T = Y.exceptionEscalateCodes, F = _e.dataTypes, D = F && F[this.type] && F[this.type][this.format] || null;
        if (D && D.validator && D.validator.call(this, te), this.allOf) {
          const U = new r("Unable to merge allOf schemas"), k = new r("One or more warnings produced while merging allOf schemas"), Z = R(U, k, this.allOf.map((A) => A.toObject()), F, de, z, T), J = {
            exception: U,
            warning: k
          };
          if (!U.hasException) {
            const A = new r("Unable to serialize merged schemas"), I = xe(Z, A, F);
            if (A.hasException)
              U.push(A);
            else {
              const [X, oe] = new te.context.Schema(I);
              oe ? (oe.title = "One or more error exist when all schemas are considered", U.push(oe)) : J.value = X;
            }
          }
          Object.defineProperty(this, "allOfMerged", {
            get: () => new n(J.value, J.exception, J.warning)
          });
        }
        if (this.required && this.required.length > 0 && this.additionalProperties !== !1) {
          const U = this.required.slice(0);
          if (Object.keys(this.properties || {}).forEach((k) => {
            const Z = U.indexOf(k);
            Z !== -1 && U.splice(Z, 1);
          }), U.length > 0 && !z.WSCH007 && !d.schemaObjectHasSkipCode(V, "WSCH007")) {
            const k = T.WSCH007 ? pe : ie;
            U.length === 1 ? k.message("Required property not specified as a property but allowed via additionalProperties: " + U[0] + " [WSCH007]") : k.message("Required properties not specified as a property but allowed via additionalProperties: " + U.join(", ") + " [WSCH007]");
          }
        }
        Ee.push(() => {
          const U = this.discriminator;
          if (de === 3 && Re && U && U.mapping) {
            const k = Re instanceof i, Z = te.definition, J = this.enforcerData.defToInstanceMap;
            Object.keys(U.mapping).forEach((A) => {
              const I = U.mapping[A];
              let X;
              if (k) {
                const oe = g.test(I) || I.indexOf("/") !== -1 ? I : "#/components/schemas/" + I, Ae = Re.getSourceNode(Z);
                X = Re.resolvePath(Ae, oe);
              } else {
                const oe = g.test(I) || I.indexOf("/") !== -1 ? I : "#/components/schemas/" + I;
                X = Re.$refs.get(oe);
              }
              Pe(U.mapping, A, J.get(X));
            });
          }
          if (this.hasOwnProperty("enum")) {
            const k = pe.at("enum"), Z = this.enum.map((J, A) => $(this, k.at(A), J, {
              enum: !1,
              escalateCodes: T,
              skipCodes: z
            }));
            Object.freeze(Z), Pe(this, "enum", Z);
          }
          if (this.hasOwnProperty("default")) {
            const k = $(this, pe.at("default"), this.default, {});
            Pe(this, "default", h(k));
          }
          if (this.hasOwnProperty("example")) {
            const k = new r("Example not valid. [WSCH006]"), Z = $(this, k, this.example, {
              isExample: !0
            });
            k.hasException && !z.WSCH006 && !d.schemaObjectHasSkipCode(V, "WSCH006") && (T.WSCH006 ? pe : ie).at("example").push(k), Pe(this, "example", h(Z));
          }
        });
      },
      prototype: _,
      statics: function(te) {
        const pe = {}, de = /* @__PURE__ */ new Set(), Ee = te.dataTypes = {
          boolean: {},
          integer: {},
          number: {},
          string: {}
        }, Re = te.hooks = {
          afterDeserialize: [],
          afterSerialize: [],
          afterValidate: [],
          beforeDeserialize: [],
          beforeSerialize: [],
          beforeValidate: []
        };
        return te.dataTypeConstructors = function() {
          return Array.from(de.values());
        }, {
          defineDataTypeFormat: function(_e, ie, Y) {
            if (!Ee.hasOwnProperty(_e))
              throw Error("Invalid type specified. Must be one of: " + Object.keys(Ee).join(", "));
            if (!ie || typeof ie != "string")
              throw Error("Invalid format specified. Must be a non-empty string");
            if (Ee.hasOwnProperty(ie))
              throw Error('Format "' + ie + '" is already defined');
            if (Y !== null) {
              if (typeof Y != "object" || typeof Y.deserialize != "function" || typeof Y.serialize != "function" || typeof Y.validate != "function" || Y.random && typeof Y.random != "function")
                throw Error('Invalid data type definition. Must be an object that defines handlers for "deserialize", "serialize", and "validate" with optional "random" handler.');
              if (Y.constructors)
                Y.constructors.forEach((V) => {
                  if (typeof V != "function")
                    throw Error("Invalid constructor specified. Expected a function, received: " + V);
                  de.add(V);
                });
              else {
                const V = _e + "-" + ie;
                pe[V] || (pe[V] = !0, console.warn('WARNING: Data type definition missing recommended "constructors" property for type "' + _e + '" and format "' + ie + '".'));
              }
            }
            Ee[_e][ie] = Object.assign({}, Y, { type: _e, format: ie });
          },
          extractValue: p.extract,
          formalize: function(_e) {
            return _e instanceof this.constructor.Value ? (_e.value = d.toPlainObject(_e.value, {
              preserve: te.dataTypeConstructors()
            }), _e) : d.toPlainObject(_e, {
              preserve: te.dataTypeConstructors()
            });
          },
          hook: function(_e, ie) {
            if (!Re.hasOwnProperty(_e))
              throw Error("Invalid hook type. Choose one of: " + Object.keys(Re).join(", "));
            if (typeof ie != "function")
              throw Error("Invalid hook handler. Expected a function. Received: " + d.smart(ie));
            Re[_e].push(ie);
          },
          unhook: function(_e, ie) {
            const Y = Re[_e] || [], V = Y.indexOf(ie);
            V !== -1 && Y.splice(V, 1);
          },
          Value: p
        };
      },
      validator: function(te) {
        const { major: pe, options: de, definition: Ee } = te, Re = de.exceptionSkipCodes, _e = de.exceptionEscalateCodes, ie = {
          weight: -8,
          allowed: ({ parent: T }) => ae(T.result),
          type: ({ parent: T }) => ye(T.result),
          deserialize: ({ exception: T, parent: F, result: D }) => {
            const U = s(T, /* @__PURE__ */ new Map(), F.result, D);
            return T.hasException ? D : U;
          },
          errors: ({ exception: T, parent: F, result: D }) => {
            l(T, /* @__PURE__ */ new Map(), F.result, D, { maxMin: !1 });
          }
        }, Y = {
          allowed: ({ parent: T }) => T.definition.type === "array",
          type: "number",
          errors: ({ exception: T, result: F }) => {
            (!d.isInteger(F) || F < 0) && T.message("Value must be a non-negative integer");
          }
        }, V = {
          allowed: ({ parent: T }) => T.definition.type === "string" && !ae(T.result),
          type: "number",
          errors: ({ exception: T, result: F }) => {
            (!d.isInteger(F) || F < 0) && T.message("Value must be a non-negative integer");
          }
        }, z = {
          allowed: ({ parent: T }) => T.definition.type === "object",
          type: "number",
          errors: ({ exception: T, result: F }) => {
            (!d.isInteger(F) || F < 0) && T.message("Value must be a non-negative integer");
          }
        };
        return {
          type: "object",
          properties: {
            additionalProperties: t("Schema", {
              allowed: ({ parent: T }) => T.definition.type === "object",
              type: ["boolean", "object"],
              // either boolean or object
              default: !0
            }),
            allOf: {
              type: "array",
              items: t("Schema"),
              errors: ({ exception: T, definition: F }) => {
                const D = {}, U = {};
                F.forEach((Z) => {
                  Z.hasOwnProperty("type") && (D[Z.type] || (D[Z.type] = !0), Z.hasOwnProperty("format") && (Z.format, U[Z.format] = U[Z.format] ? U[Z.format] + 1 : 1));
                });
                const k = Object.keys(U).length;
                F.length === 0 && T.message("Must have at least one item"), Object.keys(D).length > 1 && T.message("All items must be of the same type"), k > 1 && T.message("All items must be of the same format");
              }
            },
            anyOf: {
              allowed: ({ major: T }) => T === 3,
              type: "array",
              items: t("Schema")
            },
            default: {
              freeForm: !0,
              type: ({ parent: T, definition: F }) => {
                const D = T.definition, U = [];
                if (D.type !== void 0)
                  U.push(D.type);
                else if (D.anyOf || D.oneOf) {
                  const k = d.determineSchemaFromSchemas(D.anyOf ?? D.oneOf, F);
                  k === null ? Array.isArray(F) ? U.push("array") : typeof F == "object" ? U.push("object") : U.push(typeof F) : k.type !== void 0 && U.push(k.type);
                } else if (D.allOf) {
                  const k = D.allOf.length;
                  for (let Z = 0; Z < k; Z++) {
                    const J = D.allOf[Z];
                    if (J.type !== void 0) {
                      U.push(J.type);
                      break;
                    }
                  }
                }
                return (D.nullable === !0 || D["x-nullable"] === !0) && U.push("null"), U;
              }
            },
            deprecated: {
              allowed: ({ major: T }) => T === 3,
              type: "boolean",
              default: !1
            },
            description: {
              type: "string"
            },
            discriminator: {
              allowed: ({ parent: T }) => T && T.validator === e.exports.validator && (T.definition.type === "object" || T.definition.anyOf || T.definition.oneOf),
              type: ({ major: T }) => T === 2 ? "string" : "object",
              properties: {
                propertyName: {
                  type: "string",
                  required: !0,
                  errors: ({ definition: T, parent: F }) => {
                    const D = F.parent.definition;
                    D.type === "object" && (!D.required || !D.required.includes(T)) && F.parent.exception.message('Property "' + T + '" must be required because it is used as the discriminator property');
                  }
                },
                mapping: {
                  type: "object",
                  additionalProperties: {
                    type: "string",
                    errors: ({ exception: T, parent: F, refParser: D, result: U }) => {
                      if (D) {
                        let k;
                        if (D instanceof i)
                          try {
                            const Z = g.test(U) || U.indexOf("/") !== -1 ? U : "#/components/schemas/" + U, J = D.getSourceNode(F.definition);
                            k = D.resolvePath(J, Z);
                          } catch {
                            T.message("Reference cannot be resolved: " + U);
                          }
                        else
                          try {
                            const Z = g.test(U) || U.indexOf("/") !== -1 ? U : "#/components/schemas/" + U;
                            k = D.$refs.get(Z);
                          } catch {
                            const J = ". If you are using multiple files to define your OpenAPI document then this may be a limitation of the original dereference function. You can try the custom reference parser (in beta) to see if this resolves the issue.";
                            T.message("Reference cannot be resolved: " + U + J);
                          }
                        if (k) {
                          const Z = F.parent.parent.definition;
                          Z.anyOf && !Z.anyOf.includes(k) ? T.message("Mapping reference must exist in anyOf: " + U) : Z.oneOf && !Z.oneOf.includes(k) && T.message("Mapping reference must exist in oneOf: " + U);
                        }
                      }
                    }
                  }
                }
              },
              errors: ({ exception: T, major: F, parent: D, definition: U }) => {
                F === 2 ? ((!D.definition.required || !D.definition.required.includes(U)) && T.message('Value "' + U + `" must be found in the parent's required properties list.`), (!D.definition.properties || !D.definition.properties.hasOwnProperty(U)) && T.message('Value "' + U + `" must be found in the parent's properties definition.`)) : F === 3 && U.hasOwnProperty("propertyName") && U.type === "object" && ((!D.definition.required || !D.definition.required.includes(U.propertyName)) && T.message('Value "' + U.propertyName + `" must be found in the parent's required properties list.`), (!D.definition.properties || !D.definition.properties.hasOwnProperty(U.propertyName)) && T.message('Value "' + U.propertyName + `" must be found in the parent's properties definition.`));
              }
            },
            enum: {
              weight: -7,
              type: "array",
              items: {
                allowed: ({ parent: T }) => !!(T && T.parent),
                type: ({ parent: T }) => {
                  const F = T.parent.definition, D = [F.type];
                  return (F.nullable === !0 || F["x-nullable"] === !0) && D.push("null"), D;
                },
                freeForm: !0
              }
            },
            example: {
              allowed: !0,
              freeForm: !0
            },
            exclusiveMaximum: {
              allowed: ({ parent: T }) => ae(T.result),
              type: "boolean",
              errors: ({ exception: T, definition: F, parent: D }) => {
                F && !D.definition.hasOwnProperty("maximum") && T.message("Cannot use exclusiveMaximum without defining a maximum");
              }
            },
            exclusiveMinimum: {
              allowed: ({ parent: T }) => ae(T.result),
              type: "boolean",
              errors: ({ exception: T, definition: F, parent: D }) => {
                F && !D.definition.hasOwnProperty("minimum") && T.message("Cannot use exclusiveMinimum without defining a minimum");
              }
            },
            externalDocs: t("ExternalDocumentation"),
            format: {
              weight: -9,
              allowed: ({ parent: T }) => ["boolean", "integer", "number", "string"].includes(T.definition.type),
              type: "string",
              errors: ({ exception: T, parent: F, warn: D }) => {
                const U = F.definition.format;
                if (U) {
                  const k = F.definition.type, J = F.staticData.dataTypes[k];
                  !(J ? Object.keys(J) : []).includes(U) && !Re.WSCH001 && !d.schemaObjectHasSkipCode(Ee, "WSCH001") && (_e.WSCH001 ? T : D).message('Non standard format "' + U + '" used for type "' + k + '". [WSCH001]');
                }
              }
            },
            items: t("Schema", {
              allowed: ({ parent: T }) => T.definition.type === "array",
              required: ({ parent: T }) => T.definition.type === "array"
            }),
            maximum: ie,
            maxItems: Y,
            maxLength: V,
            maxProperties: z,
            minimum: ie,
            minItems: Y,
            minLength: V,
            minProperties: z,
            multipleOf: {
              allowed: ({ parent: T }) => ["integer", "number"].includes(T.definition.type),
              type: "number"
            },
            not: t("Schema", { allowed: pe === 3 }),
            nullable: {
              allowed: ({ major: T }) => T === 3,
              type: "boolean",
              default: !1
            },
            oneOf: {
              allowed: ({ major: T }) => T === 3,
              type: "array",
              items: t("Schema")
            },
            pattern: {
              allowed: ({ parent: T }) => T.definition.type === "string",
              type: "string",
              deserialize: ({ exception: T, result: F }) => F ? new RegExp(F) : (T.message("Value must be a non-empty string"), /./),
              errors: ({ exception: T, result: F }) => {
                F || T.message("Value must be a non-empty string");
              }
            },
            properties: {
              weight: -5,
              allowed: ({ parent: T }) => T.definition.type === "object",
              type: "object",
              additionalProperties: t("Schema")
            },
            readOnly: {
              allowed: S,
              type: "boolean",
              default: !1,
              errors: ({ major: T, parent: F, definition: D }) => {
                T === 2 && D && F && F.parent && F.parent.parent && F.parent.parent.definition.required && F.parent.parent.definition.required.includes(F.key) && !Re.WSCH002 && !d.schemaObjectHasSkipCode(Ee, "WSCH002") && F[_e.WSCH002 ? "exception" : "warn"].message("Property should not be marked as both read only and required. [WSCH002]");
              }
            },
            required: {
              weight: 1,
              allowed: ({ parent: T }) => T.definition.type === "object",
              type: "array",
              items: { type: "string" },
              errors: ({ definition: T, exception: F, parent: D }) => {
                const U = D.definition.additionalProperties, k = D.definition.properties;
                T.forEach((Z) => {
                  (!k || !k[Z]) && !U && F.at(Z).message("Property is listed as required but is not defined in the schema properties and additional properties are not allowed.");
                });
              }
            },
            title: "string",
            type: {
              weight: -10,
              type: "string",
              default: ({ parent: T }) => {
                const F = T.definition;
                if (!(F.hasOwnProperty("allOf") || F.hasOwnProperty("anyOf") || F.hasOwnProperty("not") || F.hasOwnProperty("oneOf"))) {
                  for (let D = v.length; D--; D >= 0) {
                    const U = v[D].type, k = v[D].properties;
                    for (let Z = k.length; Z--; Z >= 0)
                      if (k[Z] in F)
                        return U;
                  }
                  if ("default" in F) {
                    const D = F.default;
                    if (Array.isArray(D))
                      return "array";
                    switch (typeof D) {
                      case "boolean":
                        return "boolean";
                      case "number":
                        return "number";
                      case "object":
                        return "object";
                      case "string":
                        return "string";
                    }
                  }
                  if ("enum" in F) {
                    const D = F.enum[0];
                    if (Array.isArray(D))
                      return "array";
                    switch (typeof D) {
                      case "boolean":
                        return "boolean";
                      case "number":
                        return "number";
                      case "object":
                        return "object";
                      case "string":
                        return "string";
                    }
                  }
                }
              },
              enum: ({ definition: T, exception: F, parent: D }) => {
                const U = e.exports.validator;
                let k = pe === 2, Z = D.parent;
                for (; k && Z; )
                  Z.validator === U && (k = !1), Z = Z.parent;
                return T === "file" && pe === 2 && !k && F.message('Value can only be "file" for non-nested schemas'), k ? ["array", "boolean", "file", "integer", "number", "object", "string"] : ["array", "boolean", "integer", "number", "object", "string"];
              }
            },
            uniqueItems: {
              allowed: ({ parent: T }) => T.definition.type === "array",
              type: "boolean"
            },
            writeOnly: {
              allowed: (T) => T.major === 3 && !!S(T),
              type: "boolean",
              default: !1
            },
            xml: t("Xml")
          },
          errors: (T) => {
            const { exception: F, definition: D, result: U, warn: k } = T;
            if (!D.hasOwnProperty("allOf") && !D.hasOwnProperty("anyOf") && !D.hasOwnProperty("not") && !D.hasOwnProperty("oneOf") && !("type" in D) && !Re.WSCH005 && !d.schemaObjectHasSkipCode(Ee, "WSCH005") && (_e.WSCH005 ? F : k).message("Schemas with an indeterminable type cannot serialize, deserialize, or validate values. [WSCH005]"), K(U.minItems, U.maxItems) || F.message('Property "minItems" must be less than or equal to "maxItems"'), K(U.minLength, U.maxLength) || F.message('Property "minLength" must be less than or equal to "maxLength"'), K(U.minProperties, U.maxProperties) || F.message('Property "minProperties" must be less than or equal to "maxProperties"'), U.required && U.hasOwnProperty("maxProperties") && U.required.length > U.maxProperties && F.message('There are more required properties than is allows by "maxProperties" contraint'), !K(U.minimum, U.maximum, U.exclusiveMinimum, U.exclusiveMaximum)) {
              const J = U.exclusiveMinimum || U.exclusiveMaximum ? "" : "or equal to ";
              F.message('Property "minimum" must be less than ' + J + '"maximum"');
            }
            U.hasOwnProperty("properties") && Object.keys(U.properties).forEach((J) => {
              const A = U.properties[J];
              A.readOnly && A.writeOnly && F.at("properties").at(J).message("Cannot be marked as both readOnly and writeOnly");
            });
            const Z = [];
            ["allOf", "anyOf", "oneOf", "not"].forEach((J) => {
              U.hasOwnProperty(J) && Z.push(J);
            }), Z.length > 1 && F.message("Cannot have multiple composites: " + Z.join(", "));
          }
        };
      }
    };
    function y(te, pe) {
      const de = "exclusive" + pe[0].toUpperCase() + pe.substring(1), Ee = {};
      return Ee[de] = !1, te.map((Re) => Re.hasOwnProperty(pe) && !Re.hasOwnProperty(de) ? Object.assign({}, Ee, Re) : Re);
    }
    function w(te) {
      return function(pe, de) {
        const Ee = te();
        let Re, _e = "", ie = 0;
        for (; Re = Ee.exec(pe); ) {
          const Y = Re[1];
          _e += pe.substring(ie, Re.index) + (de[Y] !== void 0 ? de[Y] : Re[0]), ie = Re.index + Re[0].length;
        }
        return _e + pe.substr(ie);
      };
    }
    function $(te, pe, de, Ee) {
      let Re;
      if ([de, Re] = te.deserialize(de), !Re) {
        const _e = r("Invalid value");
        l(_e, /* @__PURE__ */ new Map(), te, de, Ee), _e.hasException && (Re = _e);
      }
      return Re && pe.push(Re), de;
    }
    function E(te, pe = {}, de = {}) {
      return te.forEach((Ee) => {
        Ee.hasOwnProperty("format") && (de[Ee.format] = !0), Ee.hasOwnProperty("type") && (pe[Ee.type] = !0), Ee.hasOwnProperty("allOf") && E(Ee.allOf, pe, de);
      }), {
        formats: Object.keys(de),
        types: Object.keys(pe)
      };
    }
    function S({ parent: te }) {
      return te && te.parent && te.parent.key === "properties" && te.parent.parent && te.parent.parent.validator === e.exports.validator;
    }
    function R(te, pe, de, Ee, Re, _e, ie) {
      const { types: Y, formats: V } = E(de);
      if (Y.length > 1)
        return te.message("All items must be of the same type. Found: " + Y.join(", "));
      if (V.length > 1)
        return te.message("All items must be of the same format. Found: " + V.join(", "));
      const z = {};
      de.forEach((De) => {
        if (typeof De == "object" && De !== null) {
          const Le = De["x-enforcer-exception-skip-codes"];
          Le !== void 0 && (z["x-enforcer-exception-skip-codes"] === void 0 && (z["x-enforcer-exception-skip-codes"] = ""), z["x-enforcer-exception-skip-codes"] += " " + Le);
        }
      });
      const T = Y[0], F = V[0], D = V.length > 0 ? Ee[T][V[0]] : null, U = D ? D.isNumeric : !1, k = {};
      T && (k.type = T), F && (k.format = F);
      const Z = Array.from(new Set(de.filter((De) => De.hasOwnProperty("default")).map((De) => De.default)));
      Z.length > 1 && !_e.WSCH003 && !d.schemaObjectHasSkipCode(z, "WSCH003") && (ie.WSCH003 ? te : pe).message("Two or more defaults found. Using first default. [WSCH003]"), Z.length > 0 && (k.default = Z[0]);
      let J = 0;
      const A = te.at("enum"), I = [];
      de.forEach((De, Le) => {
        if (De.hasOwnProperty("enum"))
          if (J++, D && D.serialize) {
            const at = De.enum.map((mt) => D.serialize({
              exception: A.at(Le),
              schema: De,
              value: mt
            }));
            I.push(at);
          } else
            I.push(De.enum);
      });
      const X = {};
      I.forEach((De) => {
        De.forEach((Le) => {
          X[Le] ? X[Le]++ : X[Le] = 1;
        });
      });
      const Ae = Object.keys(X).filter((De) => X[De] === J);
      J && (Ae.length === 0 ? te.message("Enum values across schemas have nothing in common") : k.enum = Ae);
      const je = Array.from(new Set(de.filter((De) => De.hasOwnProperty("example")).map((De) => De.example)));
      je.length > 1 && !_e.WSCH004 && !d.schemaObjectHasSkipCode(z, "WSCH004") && (ie.WSCH004 ? te : pe).message("Two or more examples found. Using first example. [WSCH004]"), je.length > 0 && (k.example = je[0]);
      const Be = [], vt = [], $e = [], ht = [], nt = { hasTrue: !1, hasFalse: !1 };
      if (de.forEach((De) => {
        De.allOf && Be.push.apply(Be, De.allOf), De.oneOf && Be.push.apply(vt, De.oneOf), De.anyOf && Be.push.apply($e, De.anyOf), De.not && ht.push(De.not), De.hasOwnProperty("nullable") && (nt[De.nullable ? "hasTrue" : "hasFalse"] = !0);
      }), Be.length && Object.assign(k, R(te.at("allOf"), pe.at("allOf"), Be, Ee, Re, _e, ie)), vt.length && (k.oneOf = vt), $e.length && (k.anyOf = $e), ht.length === 1 && (k.not = ht[0]), ht.length > 1 && (k.not = R(te.at("not"), pe.at("not"), ht, Ee, Re, _e, ie)), nt.hasTrue && nt.hasFalse ? te.message("Unable to merge conflicting nullable values") : nt.hasTrue ? k.nullable = !0 : nt.hasFalse && (k.nullable = !1), j(k, de, "readOnly", L), j(k, de, "writeOnly", L), Re === 2) {
        const De = {};
        de.forEach((at) => {
          at.discriminator && (De[at.discriminator] = !0);
        });
        const Le = Object.keys(De);
        Le.length === 1 && (k.discriminator = Le[0]), Le.length > 1 && te.message("Unable to merge multiple discriminator values into one");
      } else if (Re === 3) {
        const De = {}, Le = {}, at = [];
        de.forEach((Ue) => {
          if (Ue.discriminator) {
            const q = Ue.discriminator;
            De[q.propertyName] = !0, q.mapping && Object.keys(q.mapping).forEach((x) => {
              const C = q.mapping[x];
              Le.hasOwnProperty(x) ? Le[x] !== C && at.push(x) : Le[x] = C;
            });
          }
        });
        const mt = Object.keys(De);
        mt.length === 1 && (k.discriminator = mt[0]), mt.length > 1 && te.message("Unable to merge multiple discriminator values into one"), at.length > 0 && te.message("Conflicting discriminator mappings attempt to map different values to same name");
      }
      if (T === "array") {
        const De = de.filter((Le) => Le.hasOwnProperty("items")).map((Le) => Le.items);
        k.items = R(te.at("items"), pe.at("items"), De, Ee, Re, _e, ie), j(k, de, "maxItems", (Le, at) => ({ value: Le < at ? Le : at })), j(k, de, "minItems", (Le, at) => ({ value: Le > at ? Le : at })), j(k, de, "uniqueItems", L);
      } else if (T === "integer" || T === "number" || U)
        j(k, de, "maximum", (De, Le) => ({ value: De < Le ? De : Le })), j(k, de, "minimum", (De, Le) => ({ value: De > Le ? De : Le })), j(k, de, "multipleOf", (De, Le) => ({ value: d.leastCommonMultiple(De, Le) })), j(k, y(de, "maximum"), "exclusiveMaximum", (De, Le, at, mt, Ue) => {
          const q = Ue[at].maximum, x = Ue[mt].maximum;
          return De === !0 && q <= x ? { index: at, value: !0 } : Le === !0 && x <= q ? { index: mt, value: !0 } : q <= x ? { index: at, value: !1 } : { index: mt, value: !1 };
        }), j(k, y(de, "minimum"), "exclusiveMinimum", (De, Le, at, mt, Ue) => {
          const q = Ue[at].minimum, x = Ue[mt].minimum;
          return De === !0 && q >= x ? { index: at, value: !0 } : Le === !0 && x >= q ? { index: mt, value: !0 } : q >= x ? { index: at, value: !1 } : { index: mt, value: !1 };
        });
      else if (T === "object") {
        const De = { true: !1, false: !1 }, Le = de.filter((C) => {
          const G = C.additionalProperties;
          return C.hasOwnProperty("additionalProperties") ? (G === !1 && (De.false = !0), G === !0 && (De.true = !0), typeof G == "object") : !1;
        }).map((C) => C.additionalProperties);
        De.false && (De.true || Le.length) ? te.message("Conflict with additionalProperties") : Le.length === 1 ? k.additionalProperties = Le[0] : Le.length > 1 && (k.additionalProperties = R(te.at("additionalProperties"), pe.at("additionalProperties"), Le, Ee, Re, _e, ie));
        const at = te.at("properties"), mt = te.at("properties"), Ue = {}, q = {};
        de.forEach((C) => {
          C.hasOwnProperty("properties") && Object.keys(C.properties).forEach((G) => {
            Ue[G] || (Ue[G] = []), Ue[G].push(C.properties[G]);
          }), C.hasOwnProperty("required") && C.required.forEach((G) => {
            q[G] = !0;
          });
        }), Object.keys(Ue).forEach((C) => {
          const G = Ue[C];
          G.length > 0 && (k.properties || (k.properties = {}), G.length === 1 ? k.properties[C] = G[0] : k.properties[C] = R(at.at(C), mt.at(C), G, Ee, Re, _e, ie));
        });
        const x = Object.keys(q);
        x.length && (k.required = x), j(k, de, "maxProperties", (C, G) => ({ value: C < G ? C : G })), j(k, de, "minProperties", (C, G) => ({ value: C > G ? C : G }));
      } else if (T === "string") {
        const De = de.filter((Le) => Le.hasOwnProperty("pattern"));
        De.length === 1 ? k.patterns = De[0] : De.length > 1 && te.message("Unable to merge multiple patterns"), j(k, de, "maxLength", (Le, at) => ({ value: Le < at ? Le : at })), j(k, de, "minLength", (Le, at) => ({ value: Le > at ? Le : at }));
      }
      return k;
    }
    function j(te, pe, de, Ee) {
      const Re = pe.length, _e = [];
      for (let ie = 0; ie < Re; ie++)
        if (pe[ie].hasOwnProperty(de)) {
          const Y = pe[ie][de];
          _e.push({ index: ie, value: Y });
        }
      if (_e.length === 1)
        te[de] = _e[0].value;
      else if (_e.length > 1) {
        const ie = _e.length;
        let Y = _e[0].value, V = _e[0].index;
        for (let z = 1; z < ie; z++) {
          const T = Ee(Y, _e[z].value, V, _e[z].index, pe);
          T !== void 0 && (Y = T.value, V = T.index);
        }
        te[de] = Y;
      }
    }
    function L(te, pe) {
      return { value: te === !0 || pe === !0 };
    }
    function K(te, pe, de, Ee) {
      return te === void 0 || pe === void 0 ? !0 : (te = te.valueOf(), pe = pe.valueOf(), te < pe || !de && !Ee && te === pe);
    }
    function ae(te) {
      if (["number", "integer"].includes(te.type))
        return !0;
      const pe = te.enforcerData.staticData.dataTypes, de = pe[te.type] && pe[te.type][te.format];
      return !!(de && de.isNumeric);
    }
    function ye(te) {
      const pe = te.enforcerData.staticData.dataTypes, de = pe[te.type] && pe[te.type][te.format];
      if (de && de.isNumeric)
        switch (te.type) {
          case "boolean":
            return "boolean";
          case "string":
            return "string";
          case "integer":
          case "number":
          default:
            return "number";
        }
      else
        return "number";
    }
    function xe(te, pe, de, Ee) {
      if (te.pattern && (te.pattern = te.pattern.source), !Ee)
        Ee = [te];
      else if (!Ee.includes(te))
        Ee.push(te);
      else
        return te;
      if (te.type === "array" && te.items)
        te.items = xe(te.items, pe.at("items"), de, Ee);
      else if (te.type === "object") {
        if (te.additionalProperties && typeof te.additionalProperties == "object" && (te.additionalProperties = xe(te.additionalProperties, pe.at("additionalProperties"), de, Ee)), te.properties) {
          const Re = pe.at("properties");
          Object.keys(te.properties).forEach((_e) => {
            te.properties[_e] = xe(te.properties[_e], Re.at(_e), de, Ee);
          });
        }
      } else {
        const Re = de.hasOwnProperty(te.type) && de[te.type].hasOwnProperty(te.format) && de[te.type][te.format];
        Re && Re.serialize && ["default", "maximum", "minimum", "multipleOf"].forEach((_e) => {
          te.hasOwnProperty(_e) && (te[_e] = Re.serialize({
            exception: pe.at(_e),
            schema: te,
            value: te[_e]
          }));
        });
      }
      return te;
    }
    function Pe(te, pe, de) {
      Object.defineProperty(te, pe, {
        configurable: !0,
        enumerable: !0,
        value: de
      });
    }
  }(om)), om.exports;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var bm, X$;
function Q$() {
  return X$ || (X$ = 1, bm = {
    init: function(e) {
    },
    prototype: {},
    validator: function({ major: e, root: t }) {
      return {
        type: "object",
        additionalProperties: {
          type: "array",
          items: {
            type: "string"
          },
          errors: ({ exception: r, parent: i, definition: n }) => {
            t.definition && Object.keys(i.definition).forEach((s) => {
              let a;
              if (e === 2 ? (a = t.definition && t.definition.securityDefinitions && t.definition.securityDefinitions[s], a || r.at(s).message("Security requirement name must be defined at the document root under the securityDefinitions")) : e === 3 && (a = t.definition && t.definition.components && t.definition.components.securitySchemes && t.definition.components.securitySchemes[s], a || r.at(s).message("Security requirement name must be defined at the document root under the components/securitySchemes")), a)
                if (a.type === "oauth2") {
                  let o;
                  e === 2 ? o = a.scopes && Object.keys(a.scopes) || [] : e === 3 && (o = [], Object.keys(a.flows || {}).forEach((c) => {
                    const l = a.flows[c];
                    l.scopes && o.push(...Object.keys(l.scopes));
                  })), n.forEach((c) => {
                    if (!o.includes(c)) {
                      const l = e === 2 ? "securityDefinitions" : "securitySchemes";
                      r.at(s).message("Oauth2 scope not defined in " + l);
                    }
                  });
                } else
                  n.length > 0 && a.type !== "openIdConnect" && r.at(s).message("Security requirement for " + a.type + " value must be an empty array");
            });
          }
        }
      };
    }
  }), bm;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var _m, e2;
function t2() {
  if (e2)
    return _m;
  e2 = 1;
  const e = rr;
  return _m = {
    init: function(t) {
    },
    prototype: {},
    validator: function({ major: t }) {
      return {
        type: "object",
        properties: {
          authorizationUrl: {
            allowed: ({ parent: r }) => t === 2 && r.definition.type === "oauth2",
            required: ({ parent: r }) => ["implicit", "accessCode"].includes(r.definition.flow),
            type: "string"
          },
          bearerFormat: {
            allowed: ({ parent: r }) => t === 3 && r.definition.type === "http",
            type: "string"
          },
          description: "string",
          flow: {
            allowed: ({ parent: r }) => t === 2 && r.definition.type === "oauth2",
            required: !0,
            type: "string",
            enum: ["implicit", "password", "application", "accessCode"]
          },
          flows: e("OAuthFlows", {
            allowed: ({ parent: r }) => t === 3 && r.definition.type === "oauth2"
          }),
          in: {
            allowed: ({ parent: r }) => r.definition.type === "apiKey",
            required: !0,
            type: "string",
            enum: t === 2 ? ["query", "header"] : ["query", "header", "cookie"]
          },
          name: {
            allowed: ({ parent: r }) => r.definition.type === "apiKey",
            required: !0,
            type: "string"
          },
          openIdConnectUrl: {
            allowed: t === 3,
            required: ({ parent: r }) => r.definition.type === "openIdConnect",
            type: "string"
          },
          scheme: {
            allowed: ({ parent: r }) => t === 3 && r.definition.type === "http",
            required: !0,
            type: "string"
          },
          scopes: {
            allowed: ({ parent: r }) => t === 2 && r.definition.type === "oauth2",
            type: "object",
            required: !0,
            additionalProperties: {
              type: "string"
            }
          },
          tokenUrl: {
            allowed: ({ parent: r }) => t === 2 && r.definition.type === "oauth2",
            required: ({ parent: r }) => ["password", "application", "accessCode"].includes(r.definition.flow)
          },
          type: {
            weight: -10,
            required: !0,
            type: "string",
            enum: t === 2 ? ["basic", "apiKey", "oauth2"] : ["apiKey", "http", "oauth2", "openIdConnect"]
          }
        }
      };
    }
  }, _m;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var wm, r2;
function LP() {
  if (r2)
    return wm;
  r2 = 1;
  const e = rr, t = Nn, r = hs, i = bf(), n = Yt, s = /^((?:https?|wss?):\/\/)?(.+?)(\/.+)?$/, a = /^\d+\.\d+\.\d+$/;
  return wm = {
    init: function(o) {
    },
    prototype: {
      /**
       * Get path parameters and operation from a method and path.
       * @param {string} method
       * @param {string} path
       * @returns {EnforcerResult<{operation:OperationEnforcer, params:Object}>}
       */
      path: function(o, c) {
        const l = t("Request has one or more errors");
        c = this.enforcerData.options.disablePathNormalization ? c.split("?")[0] : n.edgeSlashes(c.split("?")[0], !0, !1), o = o.toLowerCase();
        const d = this.paths.findMatches(c);
        if (d.length === 0)
          return l.message("Path not found"), l.statusCode = 404, new r(void 0, l);
        const p = d.find((_) => _.path.methods.includes(o));
        if (!p) {
          const _ = /* @__PURE__ */ new Set();
          return d.forEach((y) => {
            y.path.methods.forEach((w) => {
              _.add(w.toUpperCase());
            });
          }), l.message("Method not allowed: " + o.toUpperCase()), l.statusCode = 405, l.pathItem = d[0].path, l.pathItems = d.map((y) => y.path), l.headers = { Allow: Array.from(_).join(", ") }, new r(void 0, l);
        }
        const g = p.path[o], m = g.parametersMap.path, v = p.params;
        if (m) {
          const _ = l.nest("Error in one or more path parameters");
          Object.keys(m).forEach((y) => {
            const w = m[y], $ = m[y].schema;
            let E = w.parse(v[y]);
            E.error || (E = $.deserialize(E.value)), E.error || (E.error = $.validate(E.value)), E.error ? _.at(y).push(E.error) : v[y] = E.value;
          });
        }
        return l.hasException && (l.statusCode = 400, l.operation = g, l.pathKey = p.pathKey), new r({
          operation: g,
          params: v,
          pathKey: p.pathKey
        }, l);
      },
      /**
       * Deserialize and validate a request.
       * @param {object} [request]
       * @param {object|string} [request.body]
       * @param {Object<string,string>} [request.headers={}] The request headers
       * @param {string} [request.method='get']
       * @param {string} [request.path='/']
       * @param {Object<string,string>} [request.query] Will be overwritten if the path includes query string parameters.
       * @param {object} [options]
       * @param {boolean,string[]} [options.allowOtherQueryParameters=false] Allow query parameter data that is not specified in the OAS document
       * @returns {EnforcerResult<{ body:*, cookie:object, headers:object, operation: Operation, path:object, query:object, response:function }>}
       */
      request: function(o, c) {
        if (o = this.toRequestObject(o), !o || typeof o != "object")
          throw Error("Invalid request. Expected a non-null object. Received: " + o);
        if (o.hasOwnProperty("body") && !(typeof o.body == "string" || typeof o.body == "object"))
          throw Error("Invalid body provided");
        if (o.hasOwnProperty("headers") && !n.isObjectStringMap(o.headers))
          throw Error("Invalid request headers. Expected an object with string keys and string values");
        if (o.hasOwnProperty("method") && typeof o.method != "string")
          throw Error("Invalid request method. Expected a string");
        if (!o.hasOwnProperty("path"))
          throw Error("Missing required request path");
        if (typeof o.path != "string")
          throw Error("Invalid request path. Expected a string");
        if (o.hasOwnProperty("query") && !n.isObjectStringMap(o.query))
          throw Error("Invalid request query. Expected an object with string keys and string values");
        if (c || (c = {}), typeof c != "object")
          throw Error("Invalid options. Expected an object. Received: " + c);
        c = Object.assign({}, c), c.hasOwnProperty("allowOtherQueryParameters") || (c.allowOtherQueryParameters = !1), c.pathParametersProcessed = !0;
        const l = o.hasOwnProperty("method") ? o.method.toLowerCase() : "get";
        let [d, p] = o.path.split("?");
        !p && o.hasOwnProperty("query") && (p = n.toQueryString(o.query));
        const h = this.enforcerData.options.disablePathNormalization ? d : n.edgeSlashes(d, !0, !1), [g, m] = this.path(l, h);
        if (m)
          return new r(void 0, m);
        const { operation: v, params: _, pathKey: y } = g, w = {
          headers: o.headers || {},
          path: _,
          query: p || ""
        };
        o.hasOwnProperty("body") && (w.body = o.body);
        const $ = v.request(w, c);
        return $.value ? ($.value.operation = v, $.value.response = (E, S, R = {}) => {
          if (R = n.lowerCaseObjectProperties(R), !R["content-type"] && w.headers.accept) {
            const j = v.getResponseContentTypeMatches(E, w.headers.accept);
            j.length && (R["content-type"] = j[0]);
          }
          return v.response(E, S, R);
        }, $.value.pathKey = y) : ($.error.statusCode = 400, $.error.operation = v, $.error.pathKey = g.pathKey), $;
      },
      toRequestObject: i.prototype.toRequestObject
    },
    validator: function({ major: o }) {
      return {
        type: "object",
        properties: {
          basePath: {
            allowed: o === 2,
            type: "string",
            errors: ({ exception: c, definition: l }) => {
              l[0] !== "/" && c.message("Value must start with a forward slash");
            }
          },
          components: e("Components", { weight: -1, allowed: o === 3 }),
          consumes: {
            allowed: o === 2,
            type: "array",
            items: {
              type: "string"
            }
          },
          definitions: {
            weight: -1,
            allowed: o === 2,
            type: "object",
            additionalProperties: e("Schema")
          },
          host: {
            type: "string",
            allowed: o === 2,
            errors: ({ exception: c, definition: l }) => {
              const d = s.exec(l);
              d && (d[1] && c.message("Value must not include the scheme: " + d[1]), d[3] && c.message("Value must not include sub path: " + d[3]));
            }
          },
          info: e("Info", { required: !0 }),
          openapi: {
            allowed: o === 3,
            required: !0,
            type: "string",
            errors: ({ exception: c, definition: l }) => {
              a.test(l) || c.message("Value must be a semantic version number");
            }
          },
          parameters: {
            allowed: o === 2,
            type: "object",
            additionalProperties: e("Parameter")
          },
          paths: e("Paths", { required: !0 }),
          produces: {
            allowed: o === 2,
            type: "array",
            items: {
              type: "string"
            }
          },
          responses: {
            allowed: o === 2,
            type: "object",
            additionalProperties: e("Response")
          },
          schemes: {
            allowed: o === 2,
            type: "array",
            items: {
              type: "string",
              enum: ["http", "https", "ws", "wss"]
            }
          },
          security: {
            type: "array",
            items: e("SecurityRequirement")
          },
          securityDefinitions: {
            allowed: o === 2,
            type: "object",
            additionalProperties: e("SecurityScheme")
          },
          servers: {
            allowed: o === 3,
            type: "array",
            items: e("Server")
          },
          swagger: {
            allowed: o === 2,
            required: !0,
            type: "string",
            enum: ["2.0"]
          },
          tags: {
            type: "array",
            items: e("Tag")
          },
          externalDocs: e("ExternalDocumentation")
        }
      };
    }
  }, wm;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var $m, n2;
function Rz() {
  return n2 || (n2 = 1, $m = LP()), $m;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var Em, i2;
function s2() {
  if (i2)
    return Em;
  i2 = 1;
  const e = rr;
  return Em = {
    init: function(t) {
    },
    prototype: {},
    validator: function(t) {
      return {
        type: "object",
        properties: {
          name: {
            required: !0,
            type: "string"
          },
          description: "string",
          externalDocs: e("ExternalDocumentation")
        }
      };
    }
  }, Em;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var xm, a2;
function o2() {
  return a2 || (a2 = 1, xm = {
    init: function(e) {
    },
    prototype: {},
    validator: function() {
      return {
        type: "object",
        properties: {
          name: "string",
          namespace: "string",
          prefix: "string",
          attribute: {
            type: "boolean",
            default: !1
          },
          wrapped: {
            type: "boolean",
            default: !1
          }
        }
      };
    }
  }), xm;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var Om, u2;
function Tz() {
  if (u2)
    return Om;
  u2 = 1;
  const e = rr;
  return Om = {
    init: function(t) {
    },
    prototype: {},
    validator: function() {
      return {
        type: "object",
        additionalProperties: e("PathItem")
      };
    }
  }, Om;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var Pm, c2;
function Iz() {
  if (c2)
    return Pm;
  c2 = 1;
  const e = rr;
  return Pm = {
    init: function(t) {
    },
    prototype: {},
    validator: function({ major: t }) {
      return {
        allowed: t === 3,
        type: "object",
        properties: {
          callbacks: {
            type: "object",
            additionalProperties: e("Callback")
          },
          examples: {
            type: "object",
            additionalProperties: e("Example")
          },
          headers: {
            type: "object",
            additionalProperties: e("Header")
          },
          links: {
            type: "object",
            additionalProperties: e("Link")
          },
          parameters: {
            type: "object",
            additionalProperties: e("Parameter")
          },
          requestBodies: {
            type: "object",
            additionalProperties: e("RequestBody")
          },
          responses: {
            type: "object",
            additionalProperties: e("Response")
          },
          schemas: {
            type: "object",
            additionalProperties: e("Schema")
          },
          securitySchemes: {
            type: "object",
            additionalProperties: e("SecurityScheme")
          }
        }
      };
    }
  }, Pm;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var Sm, l2;
function jz() {
  if (l2)
    return Sm;
  l2 = 1;
  const e = rr, t = /^([a-z-]+)\/(\*|[a-z-]+)(?:\+([a-z-]+))?/;
  return Sm = {
    init: function(r) {
    },
    prototype: {},
    validator: function(r) {
      return {
        type: "object",
        allowed: ({ exception: i, key: n, parent: s }) => {
          const a = s && s.parent && s.parent.definition && s.parent.definition.schema;
          return a && a.type === "object" && a.properties && a.properties.hasOwnProperty(n) ? !0 : "Encoding property " + n + " not found among schema object properties";
        },
        properties: {
          allowReserved: {
            type: "boolean",
            ignored: ({ parent: i }) => i.parent.parent.key !== "application/x-www-form-urlencoded",
            default: !1
          },
          contentType: {
            type: "string",
            default: ({ parent: i }) => {
              const n = i.key, s = i.parent.parent.definition.schema.properties[n];
              if (s.type === "string" && s.format === "binary")
                return "application/octet-stream";
              if (s.type === "object")
                return "application/json";
              if (s.type === "array") {
                const a = s.items;
                if (a.type === "string" && a.format === "binary")
                  return "application/octet-stream";
                if (a.type === "object" || a.type === "array")
                  return "application/json";
              }
              return "text/plain";
            },
            errors: ({ exception: i, definition: n }) => {
              t.test(n) || i.message("Value is not a valid content-type");
            }
          },
          headers: {
            ignored: ({ parent: i }) => !i.parent.parent.key.startsWith("multipart/"),
            type: "object",
            additionalProperties: e("Header", {
              ignored: ({ key: i }) => i.toLowerCase() === "content-type"
            })
          },
          style: {
            weight: -5,
            type: "string",
            ignored: ({ parent: i }) => i.parent.parent.key !== "application/x-www-form-urlencoded",
            default: "form",
            enum: ["form", "spaceDelimited", "pipeDelimited", "deepObject"],
            errors: ({ exception: i, parent: n, definition: s }) => {
              const a = n.parent.parent.definition.schema.type;
              if (!a || !s)
                return !1;
              n.definition.in === "query" && s !== "form" && !(s === "spaceDelimited" && a === "array") && !(s === "pipeDelimited" && a === "array") && !(s === "deepObject" && a === "object") && i.message('Style "' + s + '" is incompatible with schema type: ' + a);
            }
          },
          explode: {
            type: "boolean",
            ignored: ({ parent: i }) => i.parent.parent.key !== "application/x-www-form-urlencoded",
            default: ({ parent: i }) => i.definition.style === "form"
          }
        }
      };
    }
  }, Sm;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var Am, f2;
function kz() {
  return f2 || (f2 = 1, Am = {
    init: function(e) {
    },
    prototype: {},
    validator: function(e) {
      return {
        type: "object",
        properties: {
          summary: { type: "string" },
          description: { type: "string" },
          value: { allowed: !0, freeForm: !0 },
          externalValue: { type: "string" }
        },
        errors: ({ exception: t, definition: r }) => {
          r.hasOwnProperty("value") && r.hasOwnProperty("externalValue") && t.message('Cannot have both "externalValue" and "value" properties');
        }
      };
    }
  }), Am;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var Cm, d2;
function Mz() {
  if (d2)
    return Cm;
  d2 = 1;
  const e = rr;
  return Cm = {
    init: function(t) {
    },
    prototype: {},
    validator: function(t) {
      return {
        type: "object",
        properties: {
          description: {
            type: "string"
          },
          operationRef: {
            type: "string"
          },
          operationId: {
            type: "string"
          },
          parameters: {
            type: "object",
            additionalProperties: !0
          },
          requestBody: {},
          server: e("Server")
        },
        errors: ({ definition: r, exception: i }) => {
          r.hasOwnProperty("operationRef") && r.hasOwnProperty("operationId") && i.message("Must not define both operationId and operationRef");
        }
      };
    }
  }, Cm;
}
var Rm = { exports: {} };
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var Tm, p2;
function qP() {
  if (p2)
    return Tm;
  p2 = 1;
  const e = rr;
  return Tm = {
    init: function(t) {
    },
    prototype: {},
    validator: function({ major: t }) {
      return {
        allowed: t === 3,
        type: "object",
        properties: {
          description: {
            type: "string"
          },
          content: {
            type: "object",
            required: !0,
            additionalProperties: e("MediaType")
          },
          required: {
            type: "boolean",
            default: !1
          }
        }
      };
    }
  }, Tm;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var h2;
function Nz() {
  return h2 || (h2 = 1, function(e) {
    const t = rr, r = qP(), i = Yt, n = /(?:^multipart\/)|(?:^application\/x-www-form-urlencoded$)/;
    e.exports = {
      init: function(s) {
        const { exception: a, warn: o, plugins: c, options: l } = s;
        c.push(() => {
          i.validateExamples(this, a, o, l);
        });
      },
      prototype: {},
      validator: function(s) {
        const a = s.options.exceptionEscalateCodes, o = s.options.exceptionSkipCodes, c = s.definition;
        return {
          type: "object",
          properties: {
            encoding: {
              type: "object",
              allowed: ({ parent: l }) => l.parent.parent.validator === r.validator,
              additionalProperties: t("Encoding"),
              errors: ({ exception: l, parent: d }) => {
                n.test(d.key) || l.message("Mime type must be multipart/* or application/x-www-form-urlencoded. Found: " + d.key);
              }
            },
            example: { allowed: !0, freeForm: !0 },
            examples: {
              type: "object",
              additionalProperties: t("Example")
            },
            schema: t("Schema")
          },
          errors: ({ parent: l, key: d, exception: p, warn: h }) => {
            l && l.key === "content" && !e.exports.rx.mediaType.test(d) && !o.WMED001 && !i.schemaObjectHasSkipCode(c, "WMED001") && (a.WMED001 ? p : h).message("Media type appears invalid. [WMED001]");
          }
        };
      },
      rx: {
        mediaType: /^(?:\*|(application|audio|example|font|image|message|model|multipart|text|video|x-\S+))\/(?:\*|(?:([\w.\-]+)\+)?([\w.\-]+)(?:; *(.+))?)$/
      }
    };
  }(Rm)), Rm.exports;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var Im, m2;
function Dz() {
  return m2 || (m2 = 1, Im = {
    init: function(e) {
    },
    prototype: {},
    validator: function(e) {
      return {
        type: "object",
        properties: {
          authorizationUrl: {
            allowed: ({ parent: t }) => t && ["implicit", "authorizationCode"].includes(t.key),
            required: !0,
            type: "string"
          },
          refreshUrl: {
            type: "string"
          },
          scopes: {
            required: !0,
            type: "object",
            additionalProperties: {
              type: "string"
            }
          },
          tokenUrl: {
            allowed: ({ parent: t }) => t && ["password", "clientCredentials", "authorizationCode"].includes(t.key),
            required: !0,
            type: "string"
          }
        }
      };
    }
  }), Im;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var jm, y2;
function Lz() {
  if (y2)
    return jm;
  y2 = 1;
  const e = rr;
  return jm = {
    init: function(t) {
    },
    prototype: {},
    validator: function(t) {
      return {
        type: "object",
        properties: {
          authorizationCode: e("OAuthFlow"),
          clientCredentials: e("OAuthFlow"),
          implicit: e("OAuthFlow"),
          password: e("OAuthFlow")
        }
      };
    }
  }, jm;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var km, g2;
function qz() {
  if (g2)
    return km;
  g2 = 1;
  const e = rr;
  return km = {
    init: function(t) {
    },
    prototype: {},
    validator: function(t) {
      return {
        type: "object",
        properties: {
          description: {
            type: "string"
          },
          url: {
            type: "string",
            required: !0
          },
          variables: e("ServerVariable")
        }
      };
    }
  }, km;
}
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var Mm, v2;
function Fz() {
  return v2 || (v2 = 1, Mm = {
    init: function(e) {
    },
    prototype: {},
    validator: function(e) {
      return {
        type: "object",
        additionalProperties: {
          type: "object",
          properties: {
            default: {
              type: "string",
              required: !0
            },
            description: {
              type: "string"
            },
            enum: {
              type: "array",
              items: {
                type: "string"
              }
            }
          }
        }
      };
    }
  }), Mm;
}
const Uz = "openapi-enforcer", Bz = "1.22.3", Vz = "Library for validating, parsing, and formatting data against open api schemas.", Zz = "index.js", zz = {
  test: "tests"
}, Wz = {
  test: "mocha --recursive test",
  coverage: "nyc --reporter=html npm test",
  "coverage:report": "nyc npm test && nyc report --reporter=text-lcov | coveralls",
  "coverage:watch": "chokidar 'test/**/*' 'bin/**/*' -c 'npm run coverage'",
  "docs:build": "markdown-docs build docs-src docs",
  "docs:dev": "markdown-docs dev docs-src",
  prepublishOnly: "npm test"
}, Hz = {
  type: "git",
  url: "git+https://github.com/byu-oit/openapi-enforcer.git"
}, Gz = "openapi-enforcer.d.ts", Kz = [
  "openapi",
  "swagger",
  "validate",
  "response",
  "build",
  "compose",
  "parse",
  "format",
  "deserialize",
  "serialize",
  "request validation",
  "request parsing",
  "response validation",
  "response serializing",
  "utility",
  "utils",
  "plugable"
], Yz = "James Speirs", Jz = "Apache-2.0", Xz = {
  url: "https://github.com/byu-oit/openapi-enforcer/issues"
}, Qz = "https://openapi-enforcer.com", eW = {
  chai: "^4.3.4",
  coveralls: "^3.1.1",
  mocha: "^9.1.3",
  nyc: "^15.1.0"
}, tW = {
  "js-yaml": "^4.1.0",
  randexp: "^0.5.3"
}, rW = {
  name: Uz,
  version: Bz,
  description: Vz,
  main: Zz,
  directories: zz,
  scripts: Wz,
  repository: Hz,
  types: Gz,
  keywords: Kz,
  author: Yz,
  license: Jz,
  bugs: Xz,
  homepage: Qz,
  devDependencies: eW,
  dependencies: tW
};
/**
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
var Nm, b2;
function _0() {
  if (b2)
    return Nm;
  b2 = 1, Nm = a;
  const e = ec, t = Nn, r = CP, i = hs, n = gz, s = Yt;
  async function a(l, d) {
    let p, h = t("One or more warnings exist int he OpenAPI definition");
    d = Object.assign({}, d), d.hasOwnProperty("hideWarnings") || (d.hideWarnings = !1), d.hasOwnProperty("fullResult") || (d.fullResult = !1), d.hasOwnProperty("componentOptions") || (d.componentOptions = {});
    let g;
    l = s.copy(l);
    const m = new r(l), [v, _] = await m.dereference();
    if (l = v, g = _, !g) {
      g = t("One or more errors exist in the OpenAPI definition");
      const y = l.hasOwnProperty("swagger");
      if (!y && !l.hasOwnProperty("openapi"))
        g.message('Missing required "openapi" or "swagger" property');
      else {
        const w = /^(\d+)(?:\.(\d+))(?:\.(\d+))?$/.exec(l.swagger || l.openapi);
        w ? [p, g, h] = (+w[1] === 2 ? a.v2_0.Swagger : a.v3_0.OpenApi)(l, m, d.componentOptions) : g.at(y ? "swagger" : "openapi").message("Invalid value");
      }
    }
    if (d.fullResult)
      return new i(p, g, h);
    if (!d.hideWarnings && h && h.hasException && console.warn(h.toString()), g && g.hasException)
      throw Error(g.toString());
    return p.getBundledDefinition = async function() {
      const y = await m.bundle();
      if (y.error)
        throw Error(y.error);
      return y.value;
    }, p;
  }
  a.config = {
    examplesWarnAdditionalProperty: !0,
    useCaseSensitivePaths: !0,
    useNewRefParser: !1
  }, a.bundle = async function(l) {
    const p = await new r(l).bundle();
    if (a.config.useNewRefParser)
      return p;
    {
      const [h, g] = p;
      if (g)
        throw g;
      return h;
    }
  }, a.dereference = async function(l) {
    const p = await new r(l).dereference();
    if (a.config.useNewRefParser)
      return p;
    {
      const [h, g] = p;
      if (g)
        throw g;
      return h;
    }
  }, a.Enforcer = a, a.Exception = t, a.Result = i, a.toPlainObject = s.toPlainObject;
  const o = a.v2_0 = {};
  Object.defineProperty(o, "version", { value: "2.0" }), Object.assign(o, {
    Contact: n(o, "Contact", d$()),
    ExternalDocumentation: n(o, "ExternalDocumentation", h$()),
    Header: n(o, "Header", g$()),
    Info: n(o, "Info", b$()),
    License: n(o, "License", w$()),
    Operation: n(o, "Operation", bf()),
    Parameter: n(o, "Parameter", O$()),
    PathItem: n(o, "PathItem", S$()),
    Paths: n(o, "Paths", C$()),
    Reference: n(o, "Reference", T$()),
    Response: n(o, "Response", j$()),
    Responses: n(o, "Responses", M$()),
    Schema: n(o, "Schema", J$()),
    SecurityRequirement: n(o, "SecurityRequirement", Q$()),
    SecurityScheme: n(o, "SecurityScheme", t2()),
    Swagger: n(o, "Swagger", Rz()),
    Tag: n(o, "Tag", s2()),
    Xml: n(o, "Xml", o2())
  });
  const c = a.v3_0 = {};
  return Object.defineProperty(c, "version", { value: "3.0" }), Object.assign(c, {
    Callback: n(c, "Callback", Tz()),
    Components: n(c, "Components", Iz()),
    Contact: n(c, "Contact", d$()),
    Encoding: n(c, "Encoding", jz()),
    Example: n(c, "Example", kz()),
    ExternalDocumentation: n(c, "ExternalDocumentation", h$()),
    Header: n(c, "Header", g$()),
    Info: n(c, "Info", b$()),
    License: n(c, "License", w$()),
    Link: n(c, "Link", Mz()),
    MediaType: n(c, "MediaType", Nz()),
    OAuthFlow: n(c, "OAuthFlow", Dz()),
    OAuthFlows: n(c, "OAuthFlows", Lz()),
    OpenApi: n(c, "OpenApi", LP()),
    Operation: n(c, "Operation", bf()),
    Parameter: n(c, "Parameter", O$()),
    PathItem: n(c, "PathItem", S$()),
    Paths: n(c, "Paths", C$()),
    Reference: n(c, "Reference", T$()),
    RequestBody: n(c, "RequestBody", qP()),
    Response: n(c, "Response", j$()),
    Responses: n(c, "Responses", M$()),
    Schema: n(c, "Schema", J$()),
    SecurityRequirement: n(c, "SecurityRequirement", Q$()),
    SecurityScheme: n(c, "SecurityScheme", t2()),
    Server: n(c, "Server", qz()),
    ServerVariable: n(c, "ServerVariable", Fz()),
    Tag: n(c, "Tag", s2()),
    Xml: n(c, "Xml", o2())
  }), Object.defineProperty(a, "version", {
    configurable: !1,
    value: rW.version
  }), [a.v2_0.Schema, a.v3_0.Schema].forEach((l) => {
    l.defineDataTypeFormat("integer", "int32", null), l.defineDataTypeFormat("integer", "int64", null), l.defineDataTypeFormat("number", "float", null), l.defineDataTypeFormat("number", "double", null), l.defineDataTypeFormat("string", "binary", e.binary), l.defineDataTypeFormat("string", "byte", e.byte), l.defineDataTypeFormat("string", "date", e.date), l.defineDataTypeFormat("string", "date-time", e.dateTime);
  }), Nm;
}
var nW = _0();
const FP = /* @__PURE__ */ Ks(nW);
var _f = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
_f.exports;
(function(e, t) {
  (function() {
    var r, i = "4.17.21", n = 200, s = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", a = "Expected a function", o = "Invalid `variable` option passed into `_.template`", c = "__lodash_hash_undefined__", l = 500, d = "__lodash_placeholder__", p = 1, h = 2, g = 4, m = 1, v = 2, _ = 1, y = 2, w = 4, $ = 8, E = 16, S = 32, R = 64, j = 128, L = 256, K = 512, ae = 30, ye = "...", xe = 800, Pe = 16, te = 1, pe = 2, de = 3, Ee = 1 / 0, Re = 9007199254740991, _e = 17976931348623157e292, ie = 0 / 0, Y = 4294967295, V = Y - 1, z = Y >>> 1, T = [
      ["ary", j],
      ["bind", _],
      ["bindKey", y],
      ["curry", $],
      ["curryRight", E],
      ["flip", K],
      ["partial", S],
      ["partialRight", R],
      ["rearg", L]
    ], F = "[object Arguments]", D = "[object Array]", U = "[object AsyncFunction]", k = "[object Boolean]", Z = "[object Date]", J = "[object DOMException]", A = "[object Error]", I = "[object Function]", X = "[object GeneratorFunction]", oe = "[object Map]", Ae = "[object Number]", je = "[object Null]", Be = "[object Object]", vt = "[object Promise]", $e = "[object Proxy]", ht = "[object RegExp]", nt = "[object Set]", De = "[object String]", Le = "[object Symbol]", at = "[object Undefined]", mt = "[object WeakMap]", Ue = "[object WeakSet]", q = "[object ArrayBuffer]", x = "[object DataView]", C = "[object Float32Array]", G = "[object Float64Array]", fe = "[object Int8Array]", ge = "[object Int16Array]", Oe = "[object Int32Array]", ut = "[object Uint8Array]", kt = "[object Uint8ClampedArray]", Rt = "[object Uint16Array]", $t = "[object Uint32Array]", Tt = /\b__p \+= '';/g, ho = /\b(__p \+=) '' \+/g, mo = /(__e\(.*?\)|\b__t\)) \+\n'';/g, ra = /&(?:amp|lt|gt|quot|#39);/g, na = /[&<>"']/g, yo = RegExp(ra.source), Dn = RegExp(na.source), go = /<%-([\s\S]+?)%>/g, ia = /<%([\s\S]+?)%>/g, sa = /<%=([\s\S]+?)%>/g, ys = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, aa = /^\w*$/, vo = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Ii = /[\\^$.*+?()[\]{}|]/g, bo = RegExp(Ii.source), ji = /^\s+/, ue = /\s/, Q = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, le = /\{\n\/\* \[wrapped with (.+)\] \*/, be = /,? & /, ve = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, Ye = /[()=,{}\[\]\/\s]/, Xe = /\\(\\)?/g, xt = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, Mt = /\w*$/, Zt = /^[-+]0x[0-9a-f]+$/i, bt = /^0b[01]+$/i, ee = /^\[object .+?Constructor\]$/, O = /^0o[0-7]+$/i, M = /^(?:0|[1-9]\d*)$/, W = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, se = /($^)/, ne = /['\n\r\u2028\u2029\\]/g, Me = "\\ud800-\\udfff", Ce = "\\u0300-\\u036f", Ke = "\\ufe20-\\ufe2f", We = "\\u20d0-\\u20ff", ct = Ce + Ke + We, qt = "\\u2700-\\u27bf", Dr = "a-z\\xdf-\\xf6\\xf8-\\xff", Zr = "\\xac\\xb1\\xd7\\xf7", mn = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", gs = "\\u2000-\\u206f", nc = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", _o = "A-Z\\xc0-\\xd6\\xd8-\\xde", vs = "\\ufe0e\\ufe0f", bs = Zr + mn + gs + nc, ki = "[']", ic = "[" + Me + "]", wo = "[" + bs + "]", Ln = "[" + ct + "]", w0 = "\\d+", VP = "[" + qt + "]", $0 = "[" + Dr + "]", E0 = "[^" + Me + bs + w0 + qt + Dr + _o + "]", cd = "\\ud83c[\\udffb-\\udfff]", ZP = "(?:" + Ln + "|" + cd + ")", x0 = "[^" + Me + "]", ld = "(?:\\ud83c[\\udde6-\\uddff]){2}", fd = "[\\ud800-\\udbff][\\udc00-\\udfff]", oa = "[" + _o + "]", O0 = "\\u200d", P0 = "(?:" + $0 + "|" + E0 + ")", zP = "(?:" + oa + "|" + E0 + ")", S0 = "(?:" + ki + "(?:d|ll|m|re|s|t|ve))?", A0 = "(?:" + ki + "(?:D|LL|M|RE|S|T|VE))?", C0 = ZP + "?", R0 = "[" + vs + "]?", WP = "(?:" + O0 + "(?:" + [x0, ld, fd].join("|") + ")" + R0 + C0 + ")*", HP = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", GP = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", T0 = R0 + C0 + WP, KP = "(?:" + [VP, ld, fd].join("|") + ")" + T0, YP = "(?:" + [x0 + Ln + "?", Ln, ld, fd, ic].join("|") + ")", JP = RegExp(ki, "g"), XP = RegExp(Ln, "g"), dd = RegExp(cd + "(?=" + cd + ")|" + YP + T0, "g"), QP = RegExp([
      oa + "?" + $0 + "+" + S0 + "(?=" + [wo, oa, "$"].join("|") + ")",
      zP + "+" + A0 + "(?=" + [wo, oa + P0, "$"].join("|") + ")",
      oa + "?" + P0 + "+" + S0,
      oa + "+" + A0,
      GP,
      HP,
      w0,
      KP
    ].join("|"), "g"), eS = RegExp("[" + O0 + Me + ct + vs + "]"), tS = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, rS = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ], nS = -1, zt = {};
    zt[C] = zt[G] = zt[fe] = zt[ge] = zt[Oe] = zt[ut] = zt[kt] = zt[Rt] = zt[$t] = !0, zt[F] = zt[D] = zt[q] = zt[k] = zt[x] = zt[Z] = zt[A] = zt[I] = zt[oe] = zt[Ae] = zt[Be] = zt[ht] = zt[nt] = zt[De] = zt[mt] = !1;
    var Vt = {};
    Vt[F] = Vt[D] = Vt[q] = Vt[x] = Vt[k] = Vt[Z] = Vt[C] = Vt[G] = Vt[fe] = Vt[ge] = Vt[Oe] = Vt[oe] = Vt[Ae] = Vt[Be] = Vt[ht] = Vt[nt] = Vt[De] = Vt[Le] = Vt[ut] = Vt[kt] = Vt[Rt] = Vt[$t] = !0, Vt[A] = Vt[I] = Vt[mt] = !1;
    var iS = {
      // Latin-1 Supplement block.
      : "A",
      : "A",
      : "A",
      : "A",
      : "A",
      : "A",
      : "a",
      : "a",
      : "a",
      : "a",
      : "a",
      : "a",
      : "C",
      : "c",
      : "D",
      : "d",
      : "E",
      : "E",
      : "E",
      : "E",
      : "e",
      : "e",
      : "e",
      : "e",
      : "I",
      : "I",
      : "I",
      : "I",
      : "i",
      : "i",
      : "i",
      : "i",
      : "N",
      : "n",
      : "O",
      : "O",
      : "O",
      : "O",
      : "O",
      : "O",
      : "o",
      : "o",
      : "o",
      : "o",
      : "o",
      : "o",
      : "U",
      : "U",
      : "U",
      : "U",
      : "u",
      : "u",
      : "u",
      : "u",
      : "Y",
      : "y",
      : "y",
      : "Ae",
      : "ae",
      : "Th",
      : "th",
      : "ss",
      // Latin Extended-A block.
      : "A",
      : "A",
      : "A",
      : "a",
      : "a",
      : "a",
      : "C",
      : "C",
      : "C",
      : "C",
      : "c",
      : "c",
      : "c",
      : "c",
      : "D",
      : "D",
      : "d",
      : "d",
      : "E",
      : "E",
      : "E",
      : "E",
      : "E",
      : "e",
      : "e",
      : "e",
      : "e",
      : "e",
      : "G",
      : "G",
      : "G",
      : "G",
      : "g",
      : "g",
      : "g",
      : "g",
      : "H",
      : "H",
      : "h",
      : "h",
      : "I",
      : "I",
      : "I",
      : "I",
      : "I",
      : "i",
      : "i",
      : "i",
      : "i",
      : "i",
      : "J",
      : "j",
      : "K",
      : "k",
      : "k",
      : "L",
      : "L",
      : "L",
      : "L",
      : "L",
      : "l",
      : "l",
      : "l",
      : "l",
      : "l",
      : "N",
      : "N",
      : "N",
      : "N",
      : "n",
      : "n",
      : "n",
      : "n",
      : "O",
      : "O",
      : "O",
      : "o",
      : "o",
      : "o",
      : "R",
      : "R",
      : "R",
      : "r",
      : "r",
      : "r",
      : "S",
      : "S",
      : "S",
      : "S",
      : "s",
      : "s",
      : "s",
      : "s",
      : "T",
      : "T",
      : "T",
      : "t",
      : "t",
      : "t",
      : "U",
      : "U",
      : "U",
      : "U",
      : "U",
      : "U",
      : "u",
      : "u",
      : "u",
      : "u",
      : "u",
      : "u",
      : "W",
      : "w",
      : "Y",
      : "y",
      : "Y",
      : "Z",
      : "Z",
      : "Z",
      : "z",
      : "z",
      : "z",
      : "IJ",
      : "ij",
      : "Oe",
      : "oe",
      : "'n",
      : "s"
    }, sS = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    }, aS = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    }, oS = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    }, uS = parseFloat, cS = parseInt, I0 = typeof tt == "object" && tt && tt.Object === Object && tt, lS = typeof self == "object" && self && self.Object === Object && self, dr = I0 || lS || Function("return this")(), pd = t && !t.nodeType && t, _s = pd && !0 && e && !e.nodeType && e, j0 = _s && _s.exports === pd, hd = j0 && I0.process, en = function() {
      try {
        var he = _s && _s.require && _s.require("util").types;
        return he || hd && hd.binding && hd.binding("util");
      } catch {
      }
    }(), k0 = en && en.isArrayBuffer, M0 = en && en.isDate, N0 = en && en.isMap, D0 = en && en.isRegExp, L0 = en && en.isSet, q0 = en && en.isTypedArray;
    function zr(he, Se, we) {
      switch (we.length) {
        case 0:
          return he.call(Se);
        case 1:
          return he.call(Se, we[0]);
        case 2:
          return he.call(Se, we[0], we[1]);
        case 3:
          return he.call(Se, we[0], we[1], we[2]);
      }
      return he.apply(Se, we);
    }
    function fS(he, Se, we, He) {
      for (var lt = -1, jt = he == null ? 0 : he.length; ++lt < jt; ) {
        var sr = he[lt];
        Se(He, sr, we(sr), he);
      }
      return He;
    }
    function tn(he, Se) {
      for (var we = -1, He = he == null ? 0 : he.length; ++we < He && Se(he[we], we, he) !== !1; )
        ;
      return he;
    }
    function dS(he, Se) {
      for (var we = he == null ? 0 : he.length; we-- && Se(he[we], we, he) !== !1; )
        ;
      return he;
    }
    function F0(he, Se) {
      for (var we = -1, He = he == null ? 0 : he.length; ++we < He; )
        if (!Se(he[we], we, he))
          return !1;
      return !0;
    }
    function Mi(he, Se) {
      for (var we = -1, He = he == null ? 0 : he.length, lt = 0, jt = []; ++we < He; ) {
        var sr = he[we];
        Se(sr, we, he) && (jt[lt++] = sr);
      }
      return jt;
    }
    function sc(he, Se) {
      var we = he == null ? 0 : he.length;
      return !!we && ua(he, Se, 0) > -1;
    }
    function md(he, Se, we) {
      for (var He = -1, lt = he == null ? 0 : he.length; ++He < lt; )
        if (we(Se, he[He]))
          return !0;
      return !1;
    }
    function Wt(he, Se) {
      for (var we = -1, He = he == null ? 0 : he.length, lt = Array(He); ++we < He; )
        lt[we] = Se(he[we], we, he);
      return lt;
    }
    function Ni(he, Se) {
      for (var we = -1, He = Se.length, lt = he.length; ++we < He; )
        he[lt + we] = Se[we];
      return he;
    }
    function yd(he, Se, we, He) {
      var lt = -1, jt = he == null ? 0 : he.length;
      for (He && jt && (we = he[++lt]); ++lt < jt; )
        we = Se(we, he[lt], lt, he);
      return we;
    }
    function pS(he, Se, we, He) {
      var lt = he == null ? 0 : he.length;
      for (He && lt && (we = he[--lt]); lt--; )
        we = Se(we, he[lt], lt, he);
      return we;
    }
    function gd(he, Se) {
      for (var we = -1, He = he == null ? 0 : he.length; ++we < He; )
        if (Se(he[we], we, he))
          return !0;
      return !1;
    }
    var hS = vd("length");
    function mS(he) {
      return he.split("");
    }
    function yS(he) {
      return he.match(ve) || [];
    }
    function U0(he, Se, we) {
      var He;
      return we(he, function(lt, jt, sr) {
        if (Se(lt, jt, sr))
          return He = jt, !1;
      }), He;
    }
    function ac(he, Se, we, He) {
      for (var lt = he.length, jt = we + (He ? 1 : -1); He ? jt-- : ++jt < lt; )
        if (Se(he[jt], jt, he))
          return jt;
      return -1;
    }
    function ua(he, Se, we) {
      return Se === Se ? AS(he, Se, we) : ac(he, B0, we);
    }
    function gS(he, Se, we, He) {
      for (var lt = we - 1, jt = he.length; ++lt < jt; )
        if (He(he[lt], Se))
          return lt;
      return -1;
    }
    function B0(he) {
      return he !== he;
    }
    function V0(he, Se) {
      var we = he == null ? 0 : he.length;
      return we ? _d(he, Se) / we : ie;
    }
    function vd(he) {
      return function(Se) {
        return Se == null ? r : Se[he];
      };
    }
    function bd(he) {
      return function(Se) {
        return he == null ? r : he[Se];
      };
    }
    function Z0(he, Se, we, He, lt) {
      return lt(he, function(jt, sr, Bt) {
        we = He ? (He = !1, jt) : Se(we, jt, sr, Bt);
      }), we;
    }
    function vS(he, Se) {
      var we = he.length;
      for (he.sort(Se); we--; )
        he[we] = he[we].value;
      return he;
    }
    function _d(he, Se) {
      for (var we, He = -1, lt = he.length; ++He < lt; ) {
        var jt = Se(he[He]);
        jt !== r && (we = we === r ? jt : we + jt);
      }
      return we;
    }
    function wd(he, Se) {
      for (var we = -1, He = Array(he); ++we < he; )
        He[we] = Se(we);
      return He;
    }
    function bS(he, Se) {
      return Wt(Se, function(we) {
        return [we, he[we]];
      });
    }
    function z0(he) {
      return he && he.slice(0, K0(he) + 1).replace(ji, "");
    }
    function Wr(he) {
      return function(Se) {
        return he(Se);
      };
    }
    function $d(he, Se) {
      return Wt(Se, function(we) {
        return he[we];
      });
    }
    function $o(he, Se) {
      return he.has(Se);
    }
    function W0(he, Se) {
      for (var we = -1, He = he.length; ++we < He && ua(Se, he[we], 0) > -1; )
        ;
      return we;
    }
    function H0(he, Se) {
      for (var we = he.length; we-- && ua(Se, he[we], 0) > -1; )
        ;
      return we;
    }
    function _S(he, Se) {
      for (var we = he.length, He = 0; we--; )
        he[we] === Se && ++He;
      return He;
    }
    var wS = bd(iS), $S = bd(sS);
    function ES(he) {
      return "\\" + oS[he];
    }
    function xS(he, Se) {
      return he == null ? r : he[Se];
    }
    function ca(he) {
      return eS.test(he);
    }
    function OS(he) {
      return tS.test(he);
    }
    function PS(he) {
      for (var Se, we = []; !(Se = he.next()).done; )
        we.push(Se.value);
      return we;
    }
    function Ed(he) {
      var Se = -1, we = Array(he.size);
      return he.forEach(function(He, lt) {
        we[++Se] = [lt, He];
      }), we;
    }
    function G0(he, Se) {
      return function(we) {
        return he(Se(we));
      };
    }
    function Di(he, Se) {
      for (var we = -1, He = he.length, lt = 0, jt = []; ++we < He; ) {
        var sr = he[we];
        (sr === Se || sr === d) && (he[we] = d, jt[lt++] = we);
      }
      return jt;
    }
    function oc(he) {
      var Se = -1, we = Array(he.size);
      return he.forEach(function(He) {
        we[++Se] = He;
      }), we;
    }
    function SS(he) {
      var Se = -1, we = Array(he.size);
      return he.forEach(function(He) {
        we[++Se] = [He, He];
      }), we;
    }
    function AS(he, Se, we) {
      for (var He = we - 1, lt = he.length; ++He < lt; )
        if (he[He] === Se)
          return He;
      return -1;
    }
    function CS(he, Se, we) {
      for (var He = we + 1; He--; )
        if (he[He] === Se)
          return He;
      return He;
    }
    function la(he) {
      return ca(he) ? TS(he) : hS(he);
    }
    function yn(he) {
      return ca(he) ? IS(he) : mS(he);
    }
    function K0(he) {
      for (var Se = he.length; Se-- && ue.test(he.charAt(Se)); )
        ;
      return Se;
    }
    var RS = bd(aS);
    function TS(he) {
      for (var Se = dd.lastIndex = 0; dd.test(he); )
        ++Se;
      return Se;
    }
    function IS(he) {
      return he.match(dd) || [];
    }
    function jS(he) {
      return he.match(QP) || [];
    }
    var kS = function he(Se) {
      Se = Se == null ? dr : fa.defaults(dr.Object(), Se, fa.pick(dr, rS));
      var we = Se.Array, He = Se.Date, lt = Se.Error, jt = Se.Function, sr = Se.Math, Bt = Se.Object, xd = Se.RegExp, MS = Se.String, rn = Se.TypeError, uc = we.prototype, NS = jt.prototype, da = Bt.prototype, cc = Se["__core-js_shared__"], lc = NS.toString, Dt = da.hasOwnProperty, DS = 0, Y0 = function() {
        var u = /[^.]+$/.exec(cc && cc.keys && cc.keys.IE_PROTO || "");
        return u ? "Symbol(src)_1." + u : "";
      }(), fc = da.toString, LS = lc.call(Bt), qS = dr._, FS = xd(
        "^" + lc.call(Dt).replace(Ii, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      ), dc = j0 ? Se.Buffer : r, Li = Se.Symbol, pc = Se.Uint8Array, J0 = dc ? dc.allocUnsafe : r, hc = G0(Bt.getPrototypeOf, Bt), X0 = Bt.create, Q0 = da.propertyIsEnumerable, mc = uc.splice, ev = Li ? Li.isConcatSpreadable : r, Eo = Li ? Li.iterator : r, ws = Li ? Li.toStringTag : r, yc = function() {
        try {
          var u = Ps(Bt, "defineProperty");
          return u({}, "", {}), u;
        } catch {
        }
      }(), US = Se.clearTimeout !== dr.clearTimeout && Se.clearTimeout, BS = He && He.now !== dr.Date.now && He.now, VS = Se.setTimeout !== dr.setTimeout && Se.setTimeout, gc = sr.ceil, vc = sr.floor, Od = Bt.getOwnPropertySymbols, ZS = dc ? dc.isBuffer : r, tv = Se.isFinite, zS = uc.join, WS = G0(Bt.keys, Bt), ar = sr.max, vr = sr.min, HS = He.now, GS = Se.parseInt, rv = sr.random, KS = uc.reverse, Pd = Ps(Se, "DataView"), xo = Ps(Se, "Map"), Sd = Ps(Se, "Promise"), pa = Ps(Se, "Set"), Oo = Ps(Se, "WeakMap"), Po = Ps(Bt, "create"), bc = Oo && new Oo(), ha = {}, YS = Ss(Pd), JS = Ss(xo), XS = Ss(Sd), QS = Ss(pa), eA = Ss(Oo), _c = Li ? Li.prototype : r, So = _c ? _c.valueOf : r, nv = _c ? _c.toString : r;
      function B(u) {
        if (Kt(u) && !dt(u) && !(u instanceof St)) {
          if (u instanceof nn)
            return u;
          if (Dt.call(u, "__wrapped__"))
            return ib(u);
        }
        return new nn(u);
      }
      var ma = function() {
        function u() {
        }
        return function(f) {
          if (!Ht(f))
            return {};
          if (X0)
            return X0(f);
          u.prototype = f;
          var b = new u();
          return u.prototype = r, b;
        };
      }();
      function wc() {
      }
      function nn(u, f) {
        this.__wrapped__ = u, this.__actions__ = [], this.__chain__ = !!f, this.__index__ = 0, this.__values__ = r;
      }
      B.templateSettings = {
        /**
         * Used to detect `data` property values to be HTML-escaped.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        escape: go,
        /**
         * Used to detect code to be evaluated.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        evaluate: ia,
        /**
         * Used to detect `data` property values to inject.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        interpolate: sa,
        /**
         * Used to reference the data object in the template text.
         *
         * @memberOf _.templateSettings
         * @type {string}
         */
        variable: "",
        /**
         * Used to import variables into the compiled template.
         *
         * @memberOf _.templateSettings
         * @type {Object}
         */
        imports: {
          /**
           * A reference to the `lodash` function.
           *
           * @memberOf _.templateSettings.imports
           * @type {Function}
           */
          _: B
        }
      }, B.prototype = wc.prototype, B.prototype.constructor = B, nn.prototype = ma(wc.prototype), nn.prototype.constructor = nn;
      function St(u) {
        this.__wrapped__ = u, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = Y, this.__views__ = [];
      }
      function tA() {
        var u = new St(this.__wrapped__);
        return u.__actions__ = Lr(this.__actions__), u.__dir__ = this.__dir__, u.__filtered__ = this.__filtered__, u.__iteratees__ = Lr(this.__iteratees__), u.__takeCount__ = this.__takeCount__, u.__views__ = Lr(this.__views__), u;
      }
      function rA() {
        if (this.__filtered__) {
          var u = new St(this);
          u.__dir__ = -1, u.__filtered__ = !0;
        } else
          u = this.clone(), u.__dir__ *= -1;
        return u;
      }
      function nA() {
        var u = this.__wrapped__.value(), f = this.__dir__, b = dt(u), P = f < 0, N = b ? u.length : 0, H = mC(0, N, this.__views__), re = H.start, ce = H.end, me = ce - re, Te = P ? ce : re - 1, Ie = this.__iteratees__, Ne = Ie.length, Ve = 0, Je = vr(me, this.__takeCount__);
        if (!b || !P && N == me && Je == me)
          return Sv(u, this.__actions__);
        var it = [];
        e:
          for (; me-- && Ve < Je; ) {
            Te += f;
            for (var _t = -1, st = u[Te]; ++_t < Ne; ) {
              var Ot = Ie[_t], Ct = Ot.iteratee, Kr = Ot.type, Rr = Ct(st);
              if (Kr == pe)
                st = Rr;
              else if (!Rr) {
                if (Kr == te)
                  continue e;
                break e;
              }
            }
            it[Ve++] = st;
          }
        return it;
      }
      St.prototype = ma(wc.prototype), St.prototype.constructor = St;
      function $s(u) {
        var f = -1, b = u == null ? 0 : u.length;
        for (this.clear(); ++f < b; ) {
          var P = u[f];
          this.set(P[0], P[1]);
        }
      }
      function iA() {
        this.__data__ = Po ? Po(null) : {}, this.size = 0;
      }
      function sA(u) {
        var f = this.has(u) && delete this.__data__[u];
        return this.size -= f ? 1 : 0, f;
      }
      function aA(u) {
        var f = this.__data__;
        if (Po) {
          var b = f[u];
          return b === c ? r : b;
        }
        return Dt.call(f, u) ? f[u] : r;
      }
      function oA(u) {
        var f = this.__data__;
        return Po ? f[u] !== r : Dt.call(f, u);
      }
      function uA(u, f) {
        var b = this.__data__;
        return this.size += this.has(u) ? 0 : 1, b[u] = Po && f === r ? c : f, this;
      }
      $s.prototype.clear = iA, $s.prototype.delete = sA, $s.prototype.get = aA, $s.prototype.has = oA, $s.prototype.set = uA;
      function ii(u) {
        var f = -1, b = u == null ? 0 : u.length;
        for (this.clear(); ++f < b; ) {
          var P = u[f];
          this.set(P[0], P[1]);
        }
      }
      function cA() {
        this.__data__ = [], this.size = 0;
      }
      function lA(u) {
        var f = this.__data__, b = $c(f, u);
        if (b < 0)
          return !1;
        var P = f.length - 1;
        return b == P ? f.pop() : mc.call(f, b, 1), --this.size, !0;
      }
      function fA(u) {
        var f = this.__data__, b = $c(f, u);
        return b < 0 ? r : f[b][1];
      }
      function dA(u) {
        return $c(this.__data__, u) > -1;
      }
      function pA(u, f) {
        var b = this.__data__, P = $c(b, u);
        return P < 0 ? (++this.size, b.push([u, f])) : b[P][1] = f, this;
      }
      ii.prototype.clear = cA, ii.prototype.delete = lA, ii.prototype.get = fA, ii.prototype.has = dA, ii.prototype.set = pA;
      function si(u) {
        var f = -1, b = u == null ? 0 : u.length;
        for (this.clear(); ++f < b; ) {
          var P = u[f];
          this.set(P[0], P[1]);
        }
      }
      function hA() {
        this.size = 0, this.__data__ = {
          hash: new $s(),
          map: new (xo || ii)(),
          string: new $s()
        };
      }
      function mA(u) {
        var f = kc(this, u).delete(u);
        return this.size -= f ? 1 : 0, f;
      }
      function yA(u) {
        return kc(this, u).get(u);
      }
      function gA(u) {
        return kc(this, u).has(u);
      }
      function vA(u, f) {
        var b = kc(this, u), P = b.size;
        return b.set(u, f), this.size += b.size == P ? 0 : 1, this;
      }
      si.prototype.clear = hA, si.prototype.delete = mA, si.prototype.get = yA, si.prototype.has = gA, si.prototype.set = vA;
      function Es(u) {
        var f = -1, b = u == null ? 0 : u.length;
        for (this.__data__ = new si(); ++f < b; )
          this.add(u[f]);
      }
      function bA(u) {
        return this.__data__.set(u, c), this;
      }
      function _A(u) {
        return this.__data__.has(u);
      }
      Es.prototype.add = Es.prototype.push = bA, Es.prototype.has = _A;
      function gn(u) {
        var f = this.__data__ = new ii(u);
        this.size = f.size;
      }
      function wA() {
        this.__data__ = new ii(), this.size = 0;
      }
      function $A(u) {
        var f = this.__data__, b = f.delete(u);
        return this.size = f.size, b;
      }
      function EA(u) {
        return this.__data__.get(u);
      }
      function xA(u) {
        return this.__data__.has(u);
      }
      function OA(u, f) {
        var b = this.__data__;
        if (b instanceof ii) {
          var P = b.__data__;
          if (!xo || P.length < n - 1)
            return P.push([u, f]), this.size = ++b.size, this;
          b = this.__data__ = new si(P);
        }
        return b.set(u, f), this.size = b.size, this;
      }
      gn.prototype.clear = wA, gn.prototype.delete = $A, gn.prototype.get = EA, gn.prototype.has = xA, gn.prototype.set = OA;
      function iv(u, f) {
        var b = dt(u), P = !b && As(u), N = !b && !P && Vi(u), H = !b && !P && !N && ba(u), re = b || P || N || H, ce = re ? wd(u.length, MS) : [], me = ce.length;
        for (var Te in u)
          (f || Dt.call(u, Te)) && !(re && // Safari 9 has enumerable `arguments.length` in strict mode.
          (Te == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          N && (Te == "offset" || Te == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          H && (Te == "buffer" || Te == "byteLength" || Te == "byteOffset") || // Skip index properties.
          ci(Te, me))) && ce.push(Te);
        return ce;
      }
      function sv(u) {
        var f = u.length;
        return f ? u[Ld(0, f - 1)] : r;
      }
      function PA(u, f) {
        return Mc(Lr(u), xs(f, 0, u.length));
      }
      function SA(u) {
        return Mc(Lr(u));
      }
      function Ad(u, f, b) {
        (b !== r && !vn(u[f], b) || b === r && !(f in u)) && ai(u, f, b);
      }
      function Ao(u, f, b) {
        var P = u[f];
        (!(Dt.call(u, f) && vn(P, b)) || b === r && !(f in u)) && ai(u, f, b);
      }
      function $c(u, f) {
        for (var b = u.length; b--; )
          if (vn(u[b][0], f))
            return b;
        return -1;
      }
      function AA(u, f, b, P) {
        return qi(u, function(N, H, re) {
          f(P, N, b(N), re);
        }), P;
      }
      function av(u, f) {
        return u && Fn(f, cr(f), u);
      }
      function CA(u, f) {
        return u && Fn(f, Fr(f), u);
      }
      function ai(u, f, b) {
        f == "__proto__" && yc ? yc(u, f, {
          configurable: !0,
          enumerable: !0,
          value: b,
          writable: !0
        }) : u[f] = b;
      }
      function Cd(u, f) {
        for (var b = -1, P = f.length, N = we(P), H = u == null; ++b < P; )
          N[b] = H ? r : cp(u, f[b]);
        return N;
      }
      function xs(u, f, b) {
        return u === u && (b !== r && (u = u <= b ? u : b), f !== r && (u = u >= f ? u : f)), u;
      }
      function sn(u, f, b, P, N, H) {
        var re, ce = f & p, me = f & h, Te = f & g;
        if (b && (re = N ? b(u, P, N, H) : b(u)), re !== r)
          return re;
        if (!Ht(u))
          return u;
        var Ie = dt(u);
        if (Ie) {
          if (re = gC(u), !ce)
            return Lr(u, re);
        } else {
          var Ne = br(u), Ve = Ne == I || Ne == X;
          if (Vi(u))
            return Rv(u, ce);
          if (Ne == Be || Ne == F || Ve && !N) {
            if (re = me || Ve ? {} : Kv(u), !ce)
              return me ? aC(u, CA(re, u)) : sC(u, av(re, u));
          } else {
            if (!Vt[Ne])
              return N ? u : {};
            re = vC(u, Ne, ce);
          }
        }
        H || (H = new gn());
        var Je = H.get(u);
        if (Je)
          return Je;
        H.set(u, re), xb(u) ? u.forEach(function(st) {
          re.add(sn(st, f, b, st, u, H));
        }) : $b(u) && u.forEach(function(st, Ot) {
          re.set(Ot, sn(st, f, b, Ot, u, H));
        });
        var it = Te ? me ? Kd : Gd : me ? Fr : cr, _t = Ie ? r : it(u);
        return tn(_t || u, function(st, Ot) {
          _t && (Ot = st, st = u[Ot]), Ao(re, Ot, sn(st, f, b, Ot, u, H));
        }), re;
      }
      function RA(u) {
        var f = cr(u);
        return function(b) {
          return ov(b, u, f);
        };
      }
      function ov(u, f, b) {
        var P = b.length;
        if (u == null)
          return !P;
        for (u = Bt(u); P--; ) {
          var N = b[P], H = f[N], re = u[N];
          if (re === r && !(N in u) || !H(re))
            return !1;
        }
        return !0;
      }
      function uv(u, f, b) {
        if (typeof u != "function")
          throw new rn(a);
        return Mo(function() {
          u.apply(r, b);
        }, f);
      }
      function Co(u, f, b, P) {
        var N = -1, H = sc, re = !0, ce = u.length, me = [], Te = f.length;
        if (!ce)
          return me;
        b && (f = Wt(f, Wr(b))), P ? (H = md, re = !1) : f.length >= n && (H = $o, re = !1, f = new Es(f));
        e:
          for (; ++N < ce; ) {
            var Ie = u[N], Ne = b == null ? Ie : b(Ie);
            if (Ie = P || Ie !== 0 ? Ie : 0, re && Ne === Ne) {
              for (var Ve = Te; Ve--; )
                if (f[Ve] === Ne)
                  continue e;
              me.push(Ie);
            } else
              H(f, Ne, P) || me.push(Ie);
          }
        return me;
      }
      var qi = Mv(qn), cv = Mv(Td, !0);
      function TA(u, f) {
        var b = !0;
        return qi(u, function(P, N, H) {
          return b = !!f(P, N, H), b;
        }), b;
      }
      function Ec(u, f, b) {
        for (var P = -1, N = u.length; ++P < N; ) {
          var H = u[P], re = f(H);
          if (re != null && (ce === r ? re === re && !Gr(re) : b(re, ce)))
            var ce = re, me = H;
        }
        return me;
      }
      function IA(u, f, b, P) {
        var N = u.length;
        for (b = gt(b), b < 0 && (b = -b > N ? 0 : N + b), P = P === r || P > N ? N : gt(P), P < 0 && (P += N), P = b > P ? 0 : Pb(P); b < P; )
          u[b++] = f;
        return u;
      }
      function lv(u, f) {
        var b = [];
        return qi(u, function(P, N, H) {
          f(P, N, H) && b.push(P);
        }), b;
      }
      function pr(u, f, b, P, N) {
        var H = -1, re = u.length;
        for (b || (b = _C), N || (N = []); ++H < re; ) {
          var ce = u[H];
          f > 0 && b(ce) ? f > 1 ? pr(ce, f - 1, b, P, N) : Ni(N, ce) : P || (N[N.length] = ce);
        }
        return N;
      }
      var Rd = Nv(), fv = Nv(!0);
      function qn(u, f) {
        return u && Rd(u, f, cr);
      }
      function Td(u, f) {
        return u && fv(u, f, cr);
      }
      function xc(u, f) {
        return Mi(f, function(b) {
          return li(u[b]);
        });
      }
      function Os(u, f) {
        f = Ui(f, u);
        for (var b = 0, P = f.length; u != null && b < P; )
          u = u[Un(f[b++])];
        return b && b == P ? u : r;
      }
      function dv(u, f, b) {
        var P = f(u);
        return dt(u) ? P : Ni(P, b(u));
      }
      function Ar(u) {
        return u == null ? u === r ? at : je : ws && ws in Bt(u) ? hC(u) : SC(u);
      }
      function Id(u, f) {
        return u > f;
      }
      function jA(u, f) {
        return u != null && Dt.call(u, f);
      }
      function kA(u, f) {
        return u != null && f in Bt(u);
      }
      function MA(u, f, b) {
        return u >= vr(f, b) && u < ar(f, b);
      }
      function jd(u, f, b) {
        for (var P = b ? md : sc, N = u[0].length, H = u.length, re = H, ce = we(H), me = 1 / 0, Te = []; re--; ) {
          var Ie = u[re];
          re && f && (Ie = Wt(Ie, Wr(f))), me = vr(Ie.length, me), ce[re] = !b && (f || N >= 120 && Ie.length >= 120) ? new Es(re && Ie) : r;
        }
        Ie = u[0];
        var Ne = -1, Ve = ce[0];
        e:
          for (; ++Ne < N && Te.length < me; ) {
            var Je = Ie[Ne], it = f ? f(Je) : Je;
            if (Je = b || Je !== 0 ? Je : 0, !(Ve ? $o(Ve, it) : P(Te, it, b))) {
              for (re = H; --re; ) {
                var _t = ce[re];
                if (!(_t ? $o(_t, it) : P(u[re], it, b)))
                  continue e;
              }
              Ve && Ve.push(it), Te.push(Je);
            }
          }
        return Te;
      }
      function NA(u, f, b, P) {
        return qn(u, function(N, H, re) {
          f(P, b(N), H, re);
        }), P;
      }
      function Ro(u, f, b) {
        f = Ui(f, u), u = Qv(u, f);
        var P = u == null ? u : u[Un(on(f))];
        return P == null ? r : zr(P, u, b);
      }
      function pv(u) {
        return Kt(u) && Ar(u) == F;
      }
      function DA(u) {
        return Kt(u) && Ar(u) == q;
      }
      function LA(u) {
        return Kt(u) && Ar(u) == Z;
      }
      function To(u, f, b, P, N) {
        return u === f ? !0 : u == null || f == null || !Kt(u) && !Kt(f) ? u !== u && f !== f : qA(u, f, b, P, To, N);
      }
      function qA(u, f, b, P, N, H) {
        var re = dt(u), ce = dt(f), me = re ? D : br(u), Te = ce ? D : br(f);
        me = me == F ? Be : me, Te = Te == F ? Be : Te;
        var Ie = me == Be, Ne = Te == Be, Ve = me == Te;
        if (Ve && Vi(u)) {
          if (!Vi(f))
            return !1;
          re = !0, Ie = !1;
        }
        if (Ve && !Ie)
          return H || (H = new gn()), re || ba(u) ? Wv(u, f, b, P, N, H) : dC(u, f, me, b, P, N, H);
        if (!(b & m)) {
          var Je = Ie && Dt.call(u, "__wrapped__"), it = Ne && Dt.call(f, "__wrapped__");
          if (Je || it) {
            var _t = Je ? u.value() : u, st = it ? f.value() : f;
            return H || (H = new gn()), N(_t, st, b, P, H);
          }
        }
        return Ve ? (H || (H = new gn()), pC(u, f, b, P, N, H)) : !1;
      }
      function FA(u) {
        return Kt(u) && br(u) == oe;
      }
      function kd(u, f, b, P) {
        var N = b.length, H = N, re = !P;
        if (u == null)
          return !H;
        for (u = Bt(u); N--; ) {
          var ce = b[N];
          if (re && ce[2] ? ce[1] !== u[ce[0]] : !(ce[0] in u))
            return !1;
        }
        for (; ++N < H; ) {
          ce = b[N];
          var me = ce[0], Te = u[me], Ie = ce[1];
          if (re && ce[2]) {
            if (Te === r && !(me in u))
              return !1;
          } else {
            var Ne = new gn();
            if (P)
              var Ve = P(Te, Ie, me, u, f, Ne);
            if (!(Ve === r ? To(Ie, Te, m | v, P, Ne) : Ve))
              return !1;
          }
        }
        return !0;
      }
      function hv(u) {
        if (!Ht(u) || $C(u))
          return !1;
        var f = li(u) ? FS : ee;
        return f.test(Ss(u));
      }
      function UA(u) {
        return Kt(u) && Ar(u) == ht;
      }
      function BA(u) {
        return Kt(u) && br(u) == nt;
      }
      function VA(u) {
        return Kt(u) && Uc(u.length) && !!zt[Ar(u)];
      }
      function mv(u) {
        return typeof u == "function" ? u : u == null ? Ur : typeof u == "object" ? dt(u) ? vv(u[0], u[1]) : gv(u) : Db(u);
      }
      function Md(u) {
        if (!ko(u))
          return WS(u);
        var f = [];
        for (var b in Bt(u))
          Dt.call(u, b) && b != "constructor" && f.push(b);
        return f;
      }
      function ZA(u) {
        if (!Ht(u))
          return PC(u);
        var f = ko(u), b = [];
        for (var P in u)
          P == "constructor" && (f || !Dt.call(u, P)) || b.push(P);
        return b;
      }
      function Nd(u, f) {
        return u < f;
      }
      function yv(u, f) {
        var b = -1, P = qr(u) ? we(u.length) : [];
        return qi(u, function(N, H, re) {
          P[++b] = f(N, H, re);
        }), P;
      }
      function gv(u) {
        var f = Jd(u);
        return f.length == 1 && f[0][2] ? Jv(f[0][0], f[0][1]) : function(b) {
          return b === u || kd(b, u, f);
        };
      }
      function vv(u, f) {
        return Qd(u) && Yv(f) ? Jv(Un(u), f) : function(b) {
          var P = cp(b, u);
          return P === r && P === f ? lp(b, u) : To(f, P, m | v);
        };
      }
      function Oc(u, f, b, P, N) {
        u !== f && Rd(f, function(H, re) {
          if (N || (N = new gn()), Ht(H))
            zA(u, f, re, b, Oc, P, N);
          else {
            var ce = P ? P(tp(u, re), H, re + "", u, f, N) : r;
            ce === r && (ce = H), Ad(u, re, ce);
          }
        }, Fr);
      }
      function zA(u, f, b, P, N, H, re) {
        var ce = tp(u, b), me = tp(f, b), Te = re.get(me);
        if (Te) {
          Ad(u, b, Te);
          return;
        }
        var Ie = H ? H(ce, me, b + "", u, f, re) : r, Ne = Ie === r;
        if (Ne) {
          var Ve = dt(me), Je = !Ve && Vi(me), it = !Ve && !Je && ba(me);
          Ie = me, Ve || Je || it ? dt(ce) ? Ie = ce : Jt(ce) ? Ie = Lr(ce) : Je ? (Ne = !1, Ie = Rv(me, !0)) : it ? (Ne = !1, Ie = Tv(me, !0)) : Ie = [] : No(me) || As(me) ? (Ie = ce, As(ce) ? Ie = Sb(ce) : (!Ht(ce) || li(ce)) && (Ie = Kv(me))) : Ne = !1;
        }
        Ne && (re.set(me, Ie), N(Ie, me, P, H, re), re.delete(me)), Ad(u, b, Ie);
      }
      function bv(u, f) {
        var b = u.length;
        if (b)
          return f += f < 0 ? b : 0, ci(f, b) ? u[f] : r;
      }
      function _v(u, f, b) {
        f.length ? f = Wt(f, function(H) {
          return dt(H) ? function(re) {
            return Os(re, H.length === 1 ? H[0] : H);
          } : H;
        }) : f = [Ur];
        var P = -1;
        f = Wt(f, Wr(rt()));
        var N = yv(u, function(H, re, ce) {
          var me = Wt(f, function(Te) {
            return Te(H);
          });
          return { criteria: me, index: ++P, value: H };
        });
        return vS(N, function(H, re) {
          return iC(H, re, b);
        });
      }
      function WA(u, f) {
        return wv(u, f, function(b, P) {
          return lp(u, P);
        });
      }
      function wv(u, f, b) {
        for (var P = -1, N = f.length, H = {}; ++P < N; ) {
          var re = f[P], ce = Os(u, re);
          b(ce, re) && Io(H, Ui(re, u), ce);
        }
        return H;
      }
      function HA(u) {
        return function(f) {
          return Os(f, u);
        };
      }
      function Dd(u, f, b, P) {
        var N = P ? gS : ua, H = -1, re = f.length, ce = u;
        for (u === f && (f = Lr(f)), b && (ce = Wt(u, Wr(b))); ++H < re; )
          for (var me = 0, Te = f[H], Ie = b ? b(Te) : Te; (me = N(ce, Ie, me, P)) > -1; )
            ce !== u && mc.call(ce, me, 1), mc.call(u, me, 1);
        return u;
      }
      function $v(u, f) {
        for (var b = u ? f.length : 0, P = b - 1; b--; ) {
          var N = f[b];
          if (b == P || N !== H) {
            var H = N;
            ci(N) ? mc.call(u, N, 1) : Ud(u, N);
          }
        }
        return u;
      }
      function Ld(u, f) {
        return u + vc(rv() * (f - u + 1));
      }
      function GA(u, f, b, P) {
        for (var N = -1, H = ar(gc((f - u) / (b || 1)), 0), re = we(H); H--; )
          re[P ? H : ++N] = u, u += b;
        return re;
      }
      function qd(u, f) {
        var b = "";
        if (!u || f < 1 || f > Re)
          return b;
        do
          f % 2 && (b += u), f = vc(f / 2), f && (u += u);
        while (f);
        return b;
      }
      function Et(u, f) {
        return rp(Xv(u, f, Ur), u + "");
      }
      function KA(u) {
        return sv(_a(u));
      }
      function YA(u, f) {
        var b = _a(u);
        return Mc(b, xs(f, 0, b.length));
      }
      function Io(u, f, b, P) {
        if (!Ht(u))
          return u;
        f = Ui(f, u);
        for (var N = -1, H = f.length, re = H - 1, ce = u; ce != null && ++N < H; ) {
          var me = Un(f[N]), Te = b;
          if (me === "__proto__" || me === "constructor" || me === "prototype")
            return u;
          if (N != re) {
            var Ie = ce[me];
            Te = P ? P(Ie, me, ce) : r, Te === r && (Te = Ht(Ie) ? Ie : ci(f[N + 1]) ? [] : {});
          }
          Ao(ce, me, Te), ce = ce[me];
        }
        return u;
      }
      var Ev = bc ? function(u, f) {
        return bc.set(u, f), u;
      } : Ur, JA = yc ? function(u, f) {
        return yc(u, "toString", {
          configurable: !0,
          enumerable: !1,
          value: dp(f),
          writable: !0
        });
      } : Ur;
      function XA(u) {
        return Mc(_a(u));
      }
      function an(u, f, b) {
        var P = -1, N = u.length;
        f < 0 && (f = -f > N ? 0 : N + f), b = b > N ? N : b, b < 0 && (b += N), N = f > b ? 0 : b - f >>> 0, f >>>= 0;
        for (var H = we(N); ++P < N; )
          H[P] = u[P + f];
        return H;
      }
      function QA(u, f) {
        var b;
        return qi(u, function(P, N, H) {
          return b = f(P, N, H), !b;
        }), !!b;
      }
      function Pc(u, f, b) {
        var P = 0, N = u == null ? P : u.length;
        if (typeof f == "number" && f === f && N <= z) {
          for (; P < N; ) {
            var H = P + N >>> 1, re = u[H];
            re !== null && !Gr(re) && (b ? re <= f : re < f) ? P = H + 1 : N = H;
          }
          return N;
        }
        return Fd(u, f, Ur, b);
      }
      function Fd(u, f, b, P) {
        var N = 0, H = u == null ? 0 : u.length;
        if (H === 0)
          return 0;
        f = b(f);
        for (var re = f !== f, ce = f === null, me = Gr(f), Te = f === r; N < H; ) {
          var Ie = vc((N + H) / 2), Ne = b(u[Ie]), Ve = Ne !== r, Je = Ne === null, it = Ne === Ne, _t = Gr(Ne);
          if (re)
            var st = P || it;
          else
            Te ? st = it && (P || Ve) : ce ? st = it && Ve && (P || !Je) : me ? st = it && Ve && !Je && (P || !_t) : Je || _t ? st = !1 : st = P ? Ne <= f : Ne < f;
          st ? N = Ie + 1 : H = Ie;
        }
        return vr(H, V);
      }
      function xv(u, f) {
        for (var b = -1, P = u.length, N = 0, H = []; ++b < P; ) {
          var re = u[b], ce = f ? f(re) : re;
          if (!b || !vn(ce, me)) {
            var me = ce;
            H[N++] = re === 0 ? 0 : re;
          }
        }
        return H;
      }
      function Ov(u) {
        return typeof u == "number" ? u : Gr(u) ? ie : +u;
      }
      function Hr(u) {
        if (typeof u == "string")
          return u;
        if (dt(u))
          return Wt(u, Hr) + "";
        if (Gr(u))
          return nv ? nv.call(u) : "";
        var f = u + "";
        return f == "0" && 1 / u == -Ee ? "-0" : f;
      }
      function Fi(u, f, b) {
        var P = -1, N = sc, H = u.length, re = !0, ce = [], me = ce;
        if (b)
          re = !1, N = md;
        else if (H >= n) {
          var Te = f ? null : lC(u);
          if (Te)
            return oc(Te);
          re = !1, N = $o, me = new Es();
        } else
          me = f ? [] : ce;
        e:
          for (; ++P < H; ) {
            var Ie = u[P], Ne = f ? f(Ie) : Ie;
            if (Ie = b || Ie !== 0 ? Ie : 0, re && Ne === Ne) {
              for (var Ve = me.length; Ve--; )
                if (me[Ve] === Ne)
                  continue e;
              f && me.push(Ne), ce.push(Ie);
            } else
              N(me, Ne, b) || (me !== ce && me.push(Ne), ce.push(Ie));
          }
        return ce;
      }
      function Ud(u, f) {
        return f = Ui(f, u), u = Qv(u, f), u == null || delete u[Un(on(f))];
      }
      function Pv(u, f, b, P) {
        return Io(u, f, b(Os(u, f)), P);
      }
      function Sc(u, f, b, P) {
        for (var N = u.length, H = P ? N : -1; (P ? H-- : ++H < N) && f(u[H], H, u); )
          ;
        return b ? an(u, P ? 0 : H, P ? H + 1 : N) : an(u, P ? H + 1 : 0, P ? N : H);
      }
      function Sv(u, f) {
        var b = u;
        return b instanceof St && (b = b.value()), yd(f, function(P, N) {
          return N.func.apply(N.thisArg, Ni([P], N.args));
        }, b);
      }
      function Bd(u, f, b) {
        var P = u.length;
        if (P < 2)
          return P ? Fi(u[0]) : [];
        for (var N = -1, H = we(P); ++N < P; )
          for (var re = u[N], ce = -1; ++ce < P; )
            ce != N && (H[N] = Co(H[N] || re, u[ce], f, b));
        return Fi(pr(H, 1), f, b);
      }
      function Av(u, f, b) {
        for (var P = -1, N = u.length, H = f.length, re = {}; ++P < N; ) {
          var ce = P < H ? f[P] : r;
          b(re, u[P], ce);
        }
        return re;
      }
      function Vd(u) {
        return Jt(u) ? u : [];
      }
      function Zd(u) {
        return typeof u == "function" ? u : Ur;
      }
      function Ui(u, f) {
        return dt(u) ? u : Qd(u, f) ? [u] : nb(Nt(u));
      }
      var eC = Et;
      function Bi(u, f, b) {
        var P = u.length;
        return b = b === r ? P : b, !f && b >= P ? u : an(u, f, b);
      }
      var Cv = US || function(u) {
        return dr.clearTimeout(u);
      };
      function Rv(u, f) {
        if (f)
          return u.slice();
        var b = u.length, P = J0 ? J0(b) : new u.constructor(b);
        return u.copy(P), P;
      }
      function zd(u) {
        var f = new u.constructor(u.byteLength);
        return new pc(f).set(new pc(u)), f;
      }
      function tC(u, f) {
        var b = f ? zd(u.buffer) : u.buffer;
        return new u.constructor(b, u.byteOffset, u.byteLength);
      }
      function rC(u) {
        var f = new u.constructor(u.source, Mt.exec(u));
        return f.lastIndex = u.lastIndex, f;
      }
      function nC(u) {
        return So ? Bt(So.call(u)) : {};
      }
      function Tv(u, f) {
        var b = f ? zd(u.buffer) : u.buffer;
        return new u.constructor(b, u.byteOffset, u.length);
      }
      function Iv(u, f) {
        if (u !== f) {
          var b = u !== r, P = u === null, N = u === u, H = Gr(u), re = f !== r, ce = f === null, me = f === f, Te = Gr(f);
          if (!ce && !Te && !H && u > f || H && re && me && !ce && !Te || P && re && me || !b && me || !N)
            return 1;
          if (!P && !H && !Te && u < f || Te && b && N && !P && !H || ce && b && N || !re && N || !me)
            return -1;
        }
        return 0;
      }
      function iC(u, f, b) {
        for (var P = -1, N = u.criteria, H = f.criteria, re = N.length, ce = b.length; ++P < re; ) {
          var me = Iv(N[P], H[P]);
          if (me) {
            if (P >= ce)
              return me;
            var Te = b[P];
            return me * (Te == "desc" ? -1 : 1);
          }
        }
        return u.index - f.index;
      }
      function jv(u, f, b, P) {
        for (var N = -1, H = u.length, re = b.length, ce = -1, me = f.length, Te = ar(H - re, 0), Ie = we(me + Te), Ne = !P; ++ce < me; )
          Ie[ce] = f[ce];
        for (; ++N < re; )
          (Ne || N < H) && (Ie[b[N]] = u[N]);
        for (; Te--; )
          Ie[ce++] = u[N++];
        return Ie;
      }
      function kv(u, f, b, P) {
        for (var N = -1, H = u.length, re = -1, ce = b.length, me = -1, Te = f.length, Ie = ar(H - ce, 0), Ne = we(Ie + Te), Ve = !P; ++N < Ie; )
          Ne[N] = u[N];
        for (var Je = N; ++me < Te; )
          Ne[Je + me] = f[me];
        for (; ++re < ce; )
          (Ve || N < H) && (Ne[Je + b[re]] = u[N++]);
        return Ne;
      }
      function Lr(u, f) {
        var b = -1, P = u.length;
        for (f || (f = we(P)); ++b < P; )
          f[b] = u[b];
        return f;
      }
      function Fn(u, f, b, P) {
        var N = !b;
        b || (b = {});
        for (var H = -1, re = f.length; ++H < re; ) {
          var ce = f[H], me = P ? P(b[ce], u[ce], ce, b, u) : r;
          me === r && (me = u[ce]), N ? ai(b, ce, me) : Ao(b, ce, me);
        }
        return b;
      }
      function sC(u, f) {
        return Fn(u, Xd(u), f);
      }
      function aC(u, f) {
        return Fn(u, Hv(u), f);
      }
      function Ac(u, f) {
        return function(b, P) {
          var N = dt(b) ? fS : AA, H = f ? f() : {};
          return N(b, u, rt(P, 2), H);
        };
      }
      function ya(u) {
        return Et(function(f, b) {
          var P = -1, N = b.length, H = N > 1 ? b[N - 1] : r, re = N > 2 ? b[2] : r;
          for (H = u.length > 3 && typeof H == "function" ? (N--, H) : r, re && Cr(b[0], b[1], re) && (H = N < 3 ? r : H, N = 1), f = Bt(f); ++P < N; ) {
            var ce = b[P];
            ce && u(f, ce, P, H);
          }
          return f;
        });
      }
      function Mv(u, f) {
        return function(b, P) {
          if (b == null)
            return b;
          if (!qr(b))
            return u(b, P);
          for (var N = b.length, H = f ? N : -1, re = Bt(b); (f ? H-- : ++H < N) && P(re[H], H, re) !== !1; )
            ;
          return b;
        };
      }
      function Nv(u) {
        return function(f, b, P) {
          for (var N = -1, H = Bt(f), re = P(f), ce = re.length; ce--; ) {
            var me = re[u ? ce : ++N];
            if (b(H[me], me, H) === !1)
              break;
          }
          return f;
        };
      }
      function oC(u, f, b) {
        var P = f & _, N = jo(u);
        function H() {
          var re = this && this !== dr && this instanceof H ? N : u;
          return re.apply(P ? b : this, arguments);
        }
        return H;
      }
      function Dv(u) {
        return function(f) {
          f = Nt(f);
          var b = ca(f) ? yn(f) : r, P = b ? b[0] : f.charAt(0), N = b ? Bi(b, 1).join("") : f.slice(1);
          return P[u]() + N;
        };
      }
      function ga(u) {
        return function(f) {
          return yd(Mb(kb(f).replace(JP, "")), u, "");
        };
      }
      function jo(u) {
        return function() {
          var f = arguments;
          switch (f.length) {
            case 0:
              return new u();
            case 1:
              return new u(f[0]);
            case 2:
              return new u(f[0], f[1]);
            case 3:
              return new u(f[0], f[1], f[2]);
            case 4:
              return new u(f[0], f[1], f[2], f[3]);
            case 5:
              return new u(f[0], f[1], f[2], f[3], f[4]);
            case 6:
              return new u(f[0], f[1], f[2], f[3], f[4], f[5]);
            case 7:
              return new u(f[0], f[1], f[2], f[3], f[4], f[5], f[6]);
          }
          var b = ma(u.prototype), P = u.apply(b, f);
          return Ht(P) ? P : b;
        };
      }
      function uC(u, f, b) {
        var P = jo(u);
        function N() {
          for (var H = arguments.length, re = we(H), ce = H, me = va(N); ce--; )
            re[ce] = arguments[ce];
          var Te = H < 3 && re[0] !== me && re[H - 1] !== me ? [] : Di(re, me);
          if (H -= Te.length, H < b)
            return Bv(
              u,
              f,
              Cc,
              N.placeholder,
              r,
              re,
              Te,
              r,
              r,
              b - H
            );
          var Ie = this && this !== dr && this instanceof N ? P : u;
          return zr(Ie, this, re);
        }
        return N;
      }
      function Lv(u) {
        return function(f, b, P) {
          var N = Bt(f);
          if (!qr(f)) {
            var H = rt(b, 3);
            f = cr(f), b = function(ce) {
              return H(N[ce], ce, N);
            };
          }
          var re = u(f, b, P);
          return re > -1 ? N[H ? f[re] : re] : r;
        };
      }
      function qv(u) {
        return ui(function(f) {
          var b = f.length, P = b, N = nn.prototype.thru;
          for (u && f.reverse(); P--; ) {
            var H = f[P];
            if (typeof H != "function")
              throw new rn(a);
            if (N && !re && jc(H) == "wrapper")
              var re = new nn([], !0);
          }
          for (P = re ? P : b; ++P < b; ) {
            H = f[P];
            var ce = jc(H), me = ce == "wrapper" ? Yd(H) : r;
            me && ep(me[0]) && me[1] == (j | $ | S | L) && !me[4].length && me[9] == 1 ? re = re[jc(me[0])].apply(re, me[3]) : re = H.length == 1 && ep(H) ? re[ce]() : re.thru(H);
          }
          return function() {
            var Te = arguments, Ie = Te[0];
            if (re && Te.length == 1 && dt(Ie))
              return re.plant(Ie).value();
            for (var Ne = 0, Ve = b ? f[Ne].apply(this, Te) : Ie; ++Ne < b; )
              Ve = f[Ne].call(this, Ve);
            return Ve;
          };
        });
      }
      function Cc(u, f, b, P, N, H, re, ce, me, Te) {
        var Ie = f & j, Ne = f & _, Ve = f & y, Je = f & ($ | E), it = f & K, _t = Ve ? r : jo(u);
        function st() {
          for (var Ot = arguments.length, Ct = we(Ot), Kr = Ot; Kr--; )
            Ct[Kr] = arguments[Kr];
          if (Je)
            var Rr = va(st), Yr = _S(Ct, Rr);
          if (P && (Ct = jv(Ct, P, N, Je)), H && (Ct = kv(Ct, H, re, Je)), Ot -= Yr, Je && Ot < Te) {
            var Xt = Di(Ct, Rr);
            return Bv(
              u,
              f,
              Cc,
              st.placeholder,
              b,
              Ct,
              Xt,
              ce,
              me,
              Te - Ot
            );
          }
          var bn = Ne ? b : this, di = Ve ? bn[u] : u;
          return Ot = Ct.length, ce ? Ct = AC(Ct, ce) : it && Ot > 1 && Ct.reverse(), Ie && me < Ot && (Ct.length = me), this && this !== dr && this instanceof st && (di = _t || jo(di)), di.apply(bn, Ct);
        }
        return st;
      }
      function Fv(u, f) {
        return function(b, P) {
          return NA(b, u, f(P), {});
        };
      }
      function Rc(u, f) {
        return function(b, P) {
          var N;
          if (b === r && P === r)
            return f;
          if (b !== r && (N = b), P !== r) {
            if (N === r)
              return P;
            typeof b == "string" || typeof P == "string" ? (b = Hr(b), P = Hr(P)) : (b = Ov(b), P = Ov(P)), N = u(b, P);
          }
          return N;
        };
      }
      function Wd(u) {
        return ui(function(f) {
          return f = Wt(f, Wr(rt())), Et(function(b) {
            var P = this;
            return u(f, function(N) {
              return zr(N, P, b);
            });
          });
        });
      }
      function Tc(u, f) {
        f = f === r ? " " : Hr(f);
        var b = f.length;
        if (b < 2)
          return b ? qd(f, u) : f;
        var P = qd(f, gc(u / la(f)));
        return ca(f) ? Bi(yn(P), 0, u).join("") : P.slice(0, u);
      }
      function cC(u, f, b, P) {
        var N = f & _, H = jo(u);
        function re() {
          for (var ce = -1, me = arguments.length, Te = -1, Ie = P.length, Ne = we(Ie + me), Ve = this && this !== dr && this instanceof re ? H : u; ++Te < Ie; )
            Ne[Te] = P[Te];
          for (; me--; )
            Ne[Te++] = arguments[++ce];
          return zr(Ve, N ? b : this, Ne);
        }
        return re;
      }
      function Uv(u) {
        return function(f, b, P) {
          return P && typeof P != "number" && Cr(f, b, P) && (b = P = r), f = fi(f), b === r ? (b = f, f = 0) : b = fi(b), P = P === r ? f < b ? 1 : -1 : fi(P), GA(f, b, P, u);
        };
      }
      function Ic(u) {
        return function(f, b) {
          return typeof f == "string" && typeof b == "string" || (f = un(f), b = un(b)), u(f, b);
        };
      }
      function Bv(u, f, b, P, N, H, re, ce, me, Te) {
        var Ie = f & $, Ne = Ie ? re : r, Ve = Ie ? r : re, Je = Ie ? H : r, it = Ie ? r : H;
        f |= Ie ? S : R, f &= ~(Ie ? R : S), f & w || (f &= ~(_ | y));
        var _t = [
          u,
          f,
          N,
          Je,
          Ne,
          it,
          Ve,
          ce,
          me,
          Te
        ], st = b.apply(r, _t);
        return ep(u) && eb(st, _t), st.placeholder = P, tb(st, u, f);
      }
      function Hd(u) {
        var f = sr[u];
        return function(b, P) {
          if (b = un(b), P = P == null ? 0 : vr(gt(P), 292), P && tv(b)) {
            var N = (Nt(b) + "e").split("e"), H = f(N[0] + "e" + (+N[1] + P));
            return N = (Nt(H) + "e").split("e"), +(N[0] + "e" + (+N[1] - P));
          }
          return f(b);
        };
      }
      var lC = pa && 1 / oc(new pa([, -0]))[1] == Ee ? function(u) {
        return new pa(u);
      } : mp;
      function Vv(u) {
        return function(f) {
          var b = br(f);
          return b == oe ? Ed(f) : b == nt ? SS(f) : bS(f, u(f));
        };
      }
      function oi(u, f, b, P, N, H, re, ce) {
        var me = f & y;
        if (!me && typeof u != "function")
          throw new rn(a);
        var Te = P ? P.length : 0;
        if (Te || (f &= ~(S | R), P = N = r), re = re === r ? re : ar(gt(re), 0), ce = ce === r ? ce : gt(ce), Te -= N ? N.length : 0, f & R) {
          var Ie = P, Ne = N;
          P = N = r;
        }
        var Ve = me ? r : Yd(u), Je = [
          u,
          f,
          b,
          P,
          N,
          Ie,
          Ne,
          H,
          re,
          ce
        ];
        if (Ve && OC(Je, Ve), u = Je[0], f = Je[1], b = Je[2], P = Je[3], N = Je[4], ce = Je[9] = Je[9] === r ? me ? 0 : u.length : ar(Je[9] - Te, 0), !ce && f & ($ | E) && (f &= ~($ | E)), !f || f == _)
          var it = oC(u, f, b);
        else
          f == $ || f == E ? it = uC(u, f, ce) : (f == S || f == (_ | S)) && !N.length ? it = cC(u, f, b, P) : it = Cc.apply(r, Je);
        var _t = Ve ? Ev : eb;
        return tb(_t(it, Je), u, f);
      }
      function Zv(u, f, b, P) {
        return u === r || vn(u, da[b]) && !Dt.call(P, b) ? f : u;
      }
      function zv(u, f, b, P, N, H) {
        return Ht(u) && Ht(f) && (H.set(f, u), Oc(u, f, r, zv, H), H.delete(f)), u;
      }
      function fC(u) {
        return No(u) ? r : u;
      }
      function Wv(u, f, b, P, N, H) {
        var re = b & m, ce = u.length, me = f.length;
        if (ce != me && !(re && me > ce))
          return !1;
        var Te = H.get(u), Ie = H.get(f);
        if (Te && Ie)
          return Te == f && Ie == u;
        var Ne = -1, Ve = !0, Je = b & v ? new Es() : r;
        for (H.set(u, f), H.set(f, u); ++Ne < ce; ) {
          var it = u[Ne], _t = f[Ne];
          if (P)
            var st = re ? P(_t, it, Ne, f, u, H) : P(it, _t, Ne, u, f, H);
          if (st !== r) {
            if (st)
              continue;
            Ve = !1;
            break;
          }
          if (Je) {
            if (!gd(f, function(Ot, Ct) {
              if (!$o(Je, Ct) && (it === Ot || N(it, Ot, b, P, H)))
                return Je.push(Ct);
            })) {
              Ve = !1;
              break;
            }
          } else if (!(it === _t || N(it, _t, b, P, H))) {
            Ve = !1;
            break;
          }
        }
        return H.delete(u), H.delete(f), Ve;
      }
      function dC(u, f, b, P, N, H, re) {
        switch (b) {
          case x:
            if (u.byteLength != f.byteLength || u.byteOffset != f.byteOffset)
              return !1;
            u = u.buffer, f = f.buffer;
          case q:
            return !(u.byteLength != f.byteLength || !H(new pc(u), new pc(f)));
          case k:
          case Z:
          case Ae:
            return vn(+u, +f);
          case A:
            return u.name == f.name && u.message == f.message;
          case ht:
          case De:
            return u == f + "";
          case oe:
            var ce = Ed;
          case nt:
            var me = P & m;
            if (ce || (ce = oc), u.size != f.size && !me)
              return !1;
            var Te = re.get(u);
            if (Te)
              return Te == f;
            P |= v, re.set(u, f);
            var Ie = Wv(ce(u), ce(f), P, N, H, re);
            return re.delete(u), Ie;
          case Le:
            if (So)
              return So.call(u) == So.call(f);
        }
        return !1;
      }
      function pC(u, f, b, P, N, H) {
        var re = b & m, ce = Gd(u), me = ce.length, Te = Gd(f), Ie = Te.length;
        if (me != Ie && !re)
          return !1;
        for (var Ne = me; Ne--; ) {
          var Ve = ce[Ne];
          if (!(re ? Ve in f : Dt.call(f, Ve)))
            return !1;
        }
        var Je = H.get(u), it = H.get(f);
        if (Je && it)
          return Je == f && it == u;
        var _t = !0;
        H.set(u, f), H.set(f, u);
        for (var st = re; ++Ne < me; ) {
          Ve = ce[Ne];
          var Ot = u[Ve], Ct = f[Ve];
          if (P)
            var Kr = re ? P(Ct, Ot, Ve, f, u, H) : P(Ot, Ct, Ve, u, f, H);
          if (!(Kr === r ? Ot === Ct || N(Ot, Ct, b, P, H) : Kr)) {
            _t = !1;
            break;
          }
          st || (st = Ve == "constructor");
        }
        if (_t && !st) {
          var Rr = u.constructor, Yr = f.constructor;
          Rr != Yr && "constructor" in u && "constructor" in f && !(typeof Rr == "function" && Rr instanceof Rr && typeof Yr == "function" && Yr instanceof Yr) && (_t = !1);
        }
        return H.delete(u), H.delete(f), _t;
      }
      function ui(u) {
        return rp(Xv(u, r, ob), u + "");
      }
      function Gd(u) {
        return dv(u, cr, Xd);
      }
      function Kd(u) {
        return dv(u, Fr, Hv);
      }
      var Yd = bc ? function(u) {
        return bc.get(u);
      } : mp;
      function jc(u) {
        for (var f = u.name + "", b = ha[f], P = Dt.call(ha, f) ? b.length : 0; P--; ) {
          var N = b[P], H = N.func;
          if (H == null || H == u)
            return N.name;
        }
        return f;
      }
      function va(u) {
        var f = Dt.call(B, "placeholder") ? B : u;
        return f.placeholder;
      }
      function rt() {
        var u = B.iteratee || pp;
        return u = u === pp ? mv : u, arguments.length ? u(arguments[0], arguments[1]) : u;
      }
      function kc(u, f) {
        var b = u.__data__;
        return wC(f) ? b[typeof f == "string" ? "string" : "hash"] : b.map;
      }
      function Jd(u) {
        for (var f = cr(u), b = f.length; b--; ) {
          var P = f[b], N = u[P];
          f[b] = [P, N, Yv(N)];
        }
        return f;
      }
      function Ps(u, f) {
        var b = xS(u, f);
        return hv(b) ? b : r;
      }
      function hC(u) {
        var f = Dt.call(u, ws), b = u[ws];
        try {
          u[ws] = r;
          var P = !0;
        } catch {
        }
        var N = fc.call(u);
        return P && (f ? u[ws] = b : delete u[ws]), N;
      }
      var Xd = Od ? function(u) {
        return u == null ? [] : (u = Bt(u), Mi(Od(u), function(f) {
          return Q0.call(u, f);
        }));
      } : yp, Hv = Od ? function(u) {
        for (var f = []; u; )
          Ni(f, Xd(u)), u = hc(u);
        return f;
      } : yp, br = Ar;
      (Pd && br(new Pd(new ArrayBuffer(1))) != x || xo && br(new xo()) != oe || Sd && br(Sd.resolve()) != vt || pa && br(new pa()) != nt || Oo && br(new Oo()) != mt) && (br = function(u) {
        var f = Ar(u), b = f == Be ? u.constructor : r, P = b ? Ss(b) : "";
        if (P)
          switch (P) {
            case YS:
              return x;
            case JS:
              return oe;
            case XS:
              return vt;
            case QS:
              return nt;
            case eA:
              return mt;
          }
        return f;
      });
      function mC(u, f, b) {
        for (var P = -1, N = b.length; ++P < N; ) {
          var H = b[P], re = H.size;
          switch (H.type) {
            case "drop":
              u += re;
              break;
            case "dropRight":
              f -= re;
              break;
            case "take":
              f = vr(f, u + re);
              break;
            case "takeRight":
              u = ar(u, f - re);
              break;
          }
        }
        return { start: u, end: f };
      }
      function yC(u) {
        var f = u.match(le);
        return f ? f[1].split(be) : [];
      }
      function Gv(u, f, b) {
        f = Ui(f, u);
        for (var P = -1, N = f.length, H = !1; ++P < N; ) {
          var re = Un(f[P]);
          if (!(H = u != null && b(u, re)))
            break;
          u = u[re];
        }
        return H || ++P != N ? H : (N = u == null ? 0 : u.length, !!N && Uc(N) && ci(re, N) && (dt(u) || As(u)));
      }
      function gC(u) {
        var f = u.length, b = new u.constructor(f);
        return f && typeof u[0] == "string" && Dt.call(u, "index") && (b.index = u.index, b.input = u.input), b;
      }
      function Kv(u) {
        return typeof u.constructor == "function" && !ko(u) ? ma(hc(u)) : {};
      }
      function vC(u, f, b) {
        var P = u.constructor;
        switch (f) {
          case q:
            return zd(u);
          case k:
          case Z:
            return new P(+u);
          case x:
            return tC(u, b);
          case C:
          case G:
          case fe:
          case ge:
          case Oe:
          case ut:
          case kt:
          case Rt:
          case $t:
            return Tv(u, b);
          case oe:
            return new P();
          case Ae:
          case De:
            return new P(u);
          case ht:
            return rC(u);
          case nt:
            return new P();
          case Le:
            return nC(u);
        }
      }
      function bC(u, f) {
        var b = f.length;
        if (!b)
          return u;
        var P = b - 1;
        return f[P] = (b > 1 ? "& " : "") + f[P], f = f.join(b > 2 ? ", " : " "), u.replace(Q, `{
/* [wrapped with ` + f + `] */
`);
      }
      function _C(u) {
        return dt(u) || As(u) || !!(ev && u && u[ev]);
      }
      function ci(u, f) {
        var b = typeof u;
        return f = f ?? Re, !!f && (b == "number" || b != "symbol" && M.test(u)) && u > -1 && u % 1 == 0 && u < f;
      }
      function Cr(u, f, b) {
        if (!Ht(b))
          return !1;
        var P = typeof f;
        return (P == "number" ? qr(b) && ci(f, b.length) : P == "string" && f in b) ? vn(b[f], u) : !1;
      }
      function Qd(u, f) {
        if (dt(u))
          return !1;
        var b = typeof u;
        return b == "number" || b == "symbol" || b == "boolean" || u == null || Gr(u) ? !0 : aa.test(u) || !ys.test(u) || f != null && u in Bt(f);
      }
      function wC(u) {
        var f = typeof u;
        return f == "string" || f == "number" || f == "symbol" || f == "boolean" ? u !== "__proto__" : u === null;
      }
      function ep(u) {
        var f = jc(u), b = B[f];
        if (typeof b != "function" || !(f in St.prototype))
          return !1;
        if (u === b)
          return !0;
        var P = Yd(b);
        return !!P && u === P[0];
      }
      function $C(u) {
        return !!Y0 && Y0 in u;
      }
      var EC = cc ? li : gp;
      function ko(u) {
        var f = u && u.constructor, b = typeof f == "function" && f.prototype || da;
        return u === b;
      }
      function Yv(u) {
        return u === u && !Ht(u);
      }
      function Jv(u, f) {
        return function(b) {
          return b == null ? !1 : b[u] === f && (f !== r || u in Bt(b));
        };
      }
      function xC(u) {
        var f = qc(u, function(P) {
          return b.size === l && b.clear(), P;
        }), b = f.cache;
        return f;
      }
      function OC(u, f) {
        var b = u[1], P = f[1], N = b | P, H = N < (_ | y | j), re = P == j && b == $ || P == j && b == L && u[7].length <= f[8] || P == (j | L) && f[7].length <= f[8] && b == $;
        if (!(H || re))
          return u;
        P & _ && (u[2] = f[2], N |= b & _ ? 0 : w);
        var ce = f[3];
        if (ce) {
          var me = u[3];
          u[3] = me ? jv(me, ce, f[4]) : ce, u[4] = me ? Di(u[3], d) : f[4];
        }
        return ce = f[5], ce && (me = u[5], u[5] = me ? kv(me, ce, f[6]) : ce, u[6] = me ? Di(u[5], d) : f[6]), ce = f[7], ce && (u[7] = ce), P & j && (u[8] = u[8] == null ? f[8] : vr(u[8], f[8])), u[9] == null && (u[9] = f[9]), u[0] = f[0], u[1] = N, u;
      }
      function PC(u) {
        var f = [];
        if (u != null)
          for (var b in Bt(u))
            f.push(b);
        return f;
      }
      function SC(u) {
        return fc.call(u);
      }
      function Xv(u, f, b) {
        return f = ar(f === r ? u.length - 1 : f, 0), function() {
          for (var P = arguments, N = -1, H = ar(P.length - f, 0), re = we(H); ++N < H; )
            re[N] = P[f + N];
          N = -1;
          for (var ce = we(f + 1); ++N < f; )
            ce[N] = P[N];
          return ce[f] = b(re), zr(u, this, ce);
        };
      }
      function Qv(u, f) {
        return f.length < 2 ? u : Os(u, an(f, 0, -1));
      }
      function AC(u, f) {
        for (var b = u.length, P = vr(f.length, b), N = Lr(u); P--; ) {
          var H = f[P];
          u[P] = ci(H, b) ? N[H] : r;
        }
        return u;
      }
      function tp(u, f) {
        if (!(f === "constructor" && typeof u[f] == "function") && f != "__proto__")
          return u[f];
      }
      var eb = rb(Ev), Mo = VS || function(u, f) {
        return dr.setTimeout(u, f);
      }, rp = rb(JA);
      function tb(u, f, b) {
        var P = f + "";
        return rp(u, bC(P, CC(yC(P), b)));
      }
      function rb(u) {
        var f = 0, b = 0;
        return function() {
          var P = HS(), N = Pe - (P - b);
          if (b = P, N > 0) {
            if (++f >= xe)
              return arguments[0];
          } else
            f = 0;
          return u.apply(r, arguments);
        };
      }
      function Mc(u, f) {
        var b = -1, P = u.length, N = P - 1;
        for (f = f === r ? P : f; ++b < f; ) {
          var H = Ld(b, N), re = u[H];
          u[H] = u[b], u[b] = re;
        }
        return u.length = f, u;
      }
      var nb = xC(function(u) {
        var f = [];
        return u.charCodeAt(0) === 46 && f.push(""), u.replace(vo, function(b, P, N, H) {
          f.push(N ? H.replace(Xe, "$1") : P || b);
        }), f;
      });
      function Un(u) {
        if (typeof u == "string" || Gr(u))
          return u;
        var f = u + "";
        return f == "0" && 1 / u == -Ee ? "-0" : f;
      }
      function Ss(u) {
        if (u != null) {
          try {
            return lc.call(u);
          } catch {
          }
          try {
            return u + "";
          } catch {
          }
        }
        return "";
      }
      function CC(u, f) {
        return tn(T, function(b) {
          var P = "_." + b[0];
          f & b[1] && !sc(u, P) && u.push(P);
        }), u.sort();
      }
      function ib(u) {
        if (u instanceof St)
          return u.clone();
        var f = new nn(u.__wrapped__, u.__chain__);
        return f.__actions__ = Lr(u.__actions__), f.__index__ = u.__index__, f.__values__ = u.__values__, f;
      }
      function RC(u, f, b) {
        (b ? Cr(u, f, b) : f === r) ? f = 1 : f = ar(gt(f), 0);
        var P = u == null ? 0 : u.length;
        if (!P || f < 1)
          return [];
        for (var N = 0, H = 0, re = we(gc(P / f)); N < P; )
          re[H++] = an(u, N, N += f);
        return re;
      }
      function TC(u) {
        for (var f = -1, b = u == null ? 0 : u.length, P = 0, N = []; ++f < b; ) {
          var H = u[f];
          H && (N[P++] = H);
        }
        return N;
      }
      function IC() {
        var u = arguments.length;
        if (!u)
          return [];
        for (var f = we(u - 1), b = arguments[0], P = u; P--; )
          f[P - 1] = arguments[P];
        return Ni(dt(b) ? Lr(b) : [b], pr(f, 1));
      }
      var jC = Et(function(u, f) {
        return Jt(u) ? Co(u, pr(f, 1, Jt, !0)) : [];
      }), kC = Et(function(u, f) {
        var b = on(f);
        return Jt(b) && (b = r), Jt(u) ? Co(u, pr(f, 1, Jt, !0), rt(b, 2)) : [];
      }), MC = Et(function(u, f) {
        var b = on(f);
        return Jt(b) && (b = r), Jt(u) ? Co(u, pr(f, 1, Jt, !0), r, b) : [];
      });
      function NC(u, f, b) {
        var P = u == null ? 0 : u.length;
        return P ? (f = b || f === r ? 1 : gt(f), an(u, f < 0 ? 0 : f, P)) : [];
      }
      function DC(u, f, b) {
        var P = u == null ? 0 : u.length;
        return P ? (f = b || f === r ? 1 : gt(f), f = P - f, an(u, 0, f < 0 ? 0 : f)) : [];
      }
      function LC(u, f) {
        return u && u.length ? Sc(u, rt(f, 3), !0, !0) : [];
      }
      function qC(u, f) {
        return u && u.length ? Sc(u, rt(f, 3), !0) : [];
      }
      function FC(u, f, b, P) {
        var N = u == null ? 0 : u.length;
        return N ? (b && typeof b != "number" && Cr(u, f, b) && (b = 0, P = N), IA(u, f, b, P)) : [];
      }
      function sb(u, f, b) {
        var P = u == null ? 0 : u.length;
        if (!P)
          return -1;
        var N = b == null ? 0 : gt(b);
        return N < 0 && (N = ar(P + N, 0)), ac(u, rt(f, 3), N);
      }
      function ab(u, f, b) {
        var P = u == null ? 0 : u.length;
        if (!P)
          return -1;
        var N = P - 1;
        return b !== r && (N = gt(b), N = b < 0 ? ar(P + N, 0) : vr(N, P - 1)), ac(u, rt(f, 3), N, !0);
      }
      function ob(u) {
        var f = u == null ? 0 : u.length;
        return f ? pr(u, 1) : [];
      }
      function UC(u) {
        var f = u == null ? 0 : u.length;
        return f ? pr(u, Ee) : [];
      }
      function BC(u, f) {
        var b = u == null ? 0 : u.length;
        return b ? (f = f === r ? 1 : gt(f), pr(u, f)) : [];
      }
      function VC(u) {
        for (var f = -1, b = u == null ? 0 : u.length, P = {}; ++f < b; ) {
          var N = u[f];
          P[N[0]] = N[1];
        }
        return P;
      }
      function ub(u) {
        return u && u.length ? u[0] : r;
      }
      function ZC(u, f, b) {
        var P = u == null ? 0 : u.length;
        if (!P)
          return -1;
        var N = b == null ? 0 : gt(b);
        return N < 0 && (N = ar(P + N, 0)), ua(u, f, N);
      }
      function zC(u) {
        var f = u == null ? 0 : u.length;
        return f ? an(u, 0, -1) : [];
      }
      var WC = Et(function(u) {
        var f = Wt(u, Vd);
        return f.length && f[0] === u[0] ? jd(f) : [];
      }), HC = Et(function(u) {
        var f = on(u), b = Wt(u, Vd);
        return f === on(b) ? f = r : b.pop(), b.length && b[0] === u[0] ? jd(b, rt(f, 2)) : [];
      }), GC = Et(function(u) {
        var f = on(u), b = Wt(u, Vd);
        return f = typeof f == "function" ? f : r, f && b.pop(), b.length && b[0] === u[0] ? jd(b, r, f) : [];
      });
      function KC(u, f) {
        return u == null ? "" : zS.call(u, f);
      }
      function on(u) {
        var f = u == null ? 0 : u.length;
        return f ? u[f - 1] : r;
      }
      function YC(u, f, b) {
        var P = u == null ? 0 : u.length;
        if (!P)
          return -1;
        var N = P;
        return b !== r && (N = gt(b), N = N < 0 ? ar(P + N, 0) : vr(N, P - 1)), f === f ? CS(u, f, N) : ac(u, B0, N, !0);
      }
      function JC(u, f) {
        return u && u.length ? bv(u, gt(f)) : r;
      }
      var XC = Et(cb);
      function cb(u, f) {
        return u && u.length && f && f.length ? Dd(u, f) : u;
      }
      function QC(u, f, b) {
        return u && u.length && f && f.length ? Dd(u, f, rt(b, 2)) : u;
      }
      function eR(u, f, b) {
        return u && u.length && f && f.length ? Dd(u, f, r, b) : u;
      }
      var tR = ui(function(u, f) {
        var b = u == null ? 0 : u.length, P = Cd(u, f);
        return $v(u, Wt(f, function(N) {
          return ci(N, b) ? +N : N;
        }).sort(Iv)), P;
      });
      function rR(u, f) {
        var b = [];
        if (!(u && u.length))
          return b;
        var P = -1, N = [], H = u.length;
        for (f = rt(f, 3); ++P < H; ) {
          var re = u[P];
          f(re, P, u) && (b.push(re), N.push(P));
        }
        return $v(u, N), b;
      }
      function np(u) {
        return u == null ? u : KS.call(u);
      }
      function nR(u, f, b) {
        var P = u == null ? 0 : u.length;
        return P ? (b && typeof b != "number" && Cr(u, f, b) ? (f = 0, b = P) : (f = f == null ? 0 : gt(f), b = b === r ? P : gt(b)), an(u, f, b)) : [];
      }
      function iR(u, f) {
        return Pc(u, f);
      }
      function sR(u, f, b) {
        return Fd(u, f, rt(b, 2));
      }
      function aR(u, f) {
        var b = u == null ? 0 : u.length;
        if (b) {
          var P = Pc(u, f);
          if (P < b && vn(u[P], f))
            return P;
        }
        return -1;
      }
      function oR(u, f) {
        return Pc(u, f, !0);
      }
      function uR(u, f, b) {
        return Fd(u, f, rt(b, 2), !0);
      }
      function cR(u, f) {
        var b = u == null ? 0 : u.length;
        if (b) {
          var P = Pc(u, f, !0) - 1;
          if (vn(u[P], f))
            return P;
        }
        return -1;
      }
      function lR(u) {
        return u && u.length ? xv(u) : [];
      }
      function fR(u, f) {
        return u && u.length ? xv(u, rt(f, 2)) : [];
      }
      function dR(u) {
        var f = u == null ? 0 : u.length;
        return f ? an(u, 1, f) : [];
      }
      function pR(u, f, b) {
        return u && u.length ? (f = b || f === r ? 1 : gt(f), an(u, 0, f < 0 ? 0 : f)) : [];
      }
      function hR(u, f, b) {
        var P = u == null ? 0 : u.length;
        return P ? (f = b || f === r ? 1 : gt(f), f = P - f, an(u, f < 0 ? 0 : f, P)) : [];
      }
      function mR(u, f) {
        return u && u.length ? Sc(u, rt(f, 3), !1, !0) : [];
      }
      function yR(u, f) {
        return u && u.length ? Sc(u, rt(f, 3)) : [];
      }
      var gR = Et(function(u) {
        return Fi(pr(u, 1, Jt, !0));
      }), vR = Et(function(u) {
        var f = on(u);
        return Jt(f) && (f = r), Fi(pr(u, 1, Jt, !0), rt(f, 2));
      }), bR = Et(function(u) {
        var f = on(u);
        return f = typeof f == "function" ? f : r, Fi(pr(u, 1, Jt, !0), r, f);
      });
      function _R(u) {
        return u && u.length ? Fi(u) : [];
      }
      function wR(u, f) {
        return u && u.length ? Fi(u, rt(f, 2)) : [];
      }
      function $R(u, f) {
        return f = typeof f == "function" ? f : r, u && u.length ? Fi(u, r, f) : [];
      }
      function ip(u) {
        if (!(u && u.length))
          return [];
        var f = 0;
        return u = Mi(u, function(b) {
          if (Jt(b))
            return f = ar(b.length, f), !0;
        }), wd(f, function(b) {
          return Wt(u, vd(b));
        });
      }
      function lb(u, f) {
        if (!(u && u.length))
          return [];
        var b = ip(u);
        return f == null ? b : Wt(b, function(P) {
          return zr(f, r, P);
        });
      }
      var ER = Et(function(u, f) {
        return Jt(u) ? Co(u, f) : [];
      }), xR = Et(function(u) {
        return Bd(Mi(u, Jt));
      }), OR = Et(function(u) {
        var f = on(u);
        return Jt(f) && (f = r), Bd(Mi(u, Jt), rt(f, 2));
      }), PR = Et(function(u) {
        var f = on(u);
        return f = typeof f == "function" ? f : r, Bd(Mi(u, Jt), r, f);
      }), SR = Et(ip);
      function AR(u, f) {
        return Av(u || [], f || [], Ao);
      }
      function CR(u, f) {
        return Av(u || [], f || [], Io);
      }
      var RR = Et(function(u) {
        var f = u.length, b = f > 1 ? u[f - 1] : r;
        return b = typeof b == "function" ? (u.pop(), b) : r, lb(u, b);
      });
      function fb(u) {
        var f = B(u);
        return f.__chain__ = !0, f;
      }
      function TR(u, f) {
        return f(u), u;
      }
      function Nc(u, f) {
        return f(u);
      }
      var IR = ui(function(u) {
        var f = u.length, b = f ? u[0] : 0, P = this.__wrapped__, N = function(H) {
          return Cd(H, u);
        };
        return f > 1 || this.__actions__.length || !(P instanceof St) || !ci(b) ? this.thru(N) : (P = P.slice(b, +b + (f ? 1 : 0)), P.__actions__.push({
          func: Nc,
          args: [N],
          thisArg: r
        }), new nn(P, this.__chain__).thru(function(H) {
          return f && !H.length && H.push(r), H;
        }));
      });
      function jR() {
        return fb(this);
      }
      function kR() {
        return new nn(this.value(), this.__chain__);
      }
      function MR() {
        this.__values__ === r && (this.__values__ = Ob(this.value()));
        var u = this.__index__ >= this.__values__.length, f = u ? r : this.__values__[this.__index__++];
        return { done: u, value: f };
      }
      function NR() {
        return this;
      }
      function DR(u) {
        for (var f, b = this; b instanceof wc; ) {
          var P = ib(b);
          P.__index__ = 0, P.__values__ = r, f ? N.__wrapped__ = P : f = P;
          var N = P;
          b = b.__wrapped__;
        }
        return N.__wrapped__ = u, f;
      }
      function LR() {
        var u = this.__wrapped__;
        if (u instanceof St) {
          var f = u;
          return this.__actions__.length && (f = new St(this)), f = f.reverse(), f.__actions__.push({
            func: Nc,
            args: [np],
            thisArg: r
          }), new nn(f, this.__chain__);
        }
        return this.thru(np);
      }
      function qR() {
        return Sv(this.__wrapped__, this.__actions__);
      }
      var FR = Ac(function(u, f, b) {
        Dt.call(u, b) ? ++u[b] : ai(u, b, 1);
      });
      function UR(u, f, b) {
        var P = dt(u) ? F0 : TA;
        return b && Cr(u, f, b) && (f = r), P(u, rt(f, 3));
      }
      function BR(u, f) {
        var b = dt(u) ? Mi : lv;
        return b(u, rt(f, 3));
      }
      var VR = Lv(sb), ZR = Lv(ab);
      function zR(u, f) {
        return pr(Dc(u, f), 1);
      }
      function WR(u, f) {
        return pr(Dc(u, f), Ee);
      }
      function HR(u, f, b) {
        return b = b === r ? 1 : gt(b), pr(Dc(u, f), b);
      }
      function db(u, f) {
        var b = dt(u) ? tn : qi;
        return b(u, rt(f, 3));
      }
      function pb(u, f) {
        var b = dt(u) ? dS : cv;
        return b(u, rt(f, 3));
      }
      var GR = Ac(function(u, f, b) {
        Dt.call(u, b) ? u[b].push(f) : ai(u, b, [f]);
      });
      function KR(u, f, b, P) {
        u = qr(u) ? u : _a(u), b = b && !P ? gt(b) : 0;
        var N = u.length;
        return b < 0 && (b = ar(N + b, 0)), Bc(u) ? b <= N && u.indexOf(f, b) > -1 : !!N && ua(u, f, b) > -1;
      }
      var YR = Et(function(u, f, b) {
        var P = -1, N = typeof f == "function", H = qr(u) ? we(u.length) : [];
        return qi(u, function(re) {
          H[++P] = N ? zr(f, re, b) : Ro(re, f, b);
        }), H;
      }), JR = Ac(function(u, f, b) {
        ai(u, b, f);
      });
      function Dc(u, f) {
        var b = dt(u) ? Wt : yv;
        return b(u, rt(f, 3));
      }
      function XR(u, f, b, P) {
        return u == null ? [] : (dt(f) || (f = f == null ? [] : [f]), b = P ? r : b, dt(b) || (b = b == null ? [] : [b]), _v(u, f, b));
      }
      var QR = Ac(function(u, f, b) {
        u[b ? 0 : 1].push(f);
      }, function() {
        return [[], []];
      });
      function eT(u, f, b) {
        var P = dt(u) ? yd : Z0, N = arguments.length < 3;
        return P(u, rt(f, 4), b, N, qi);
      }
      function tT(u, f, b) {
        var P = dt(u) ? pS : Z0, N = arguments.length < 3;
        return P(u, rt(f, 4), b, N, cv);
      }
      function rT(u, f) {
        var b = dt(u) ? Mi : lv;
        return b(u, Fc(rt(f, 3)));
      }
      function nT(u) {
        var f = dt(u) ? sv : KA;
        return f(u);
      }
      function iT(u, f, b) {
        (b ? Cr(u, f, b) : f === r) ? f = 1 : f = gt(f);
        var P = dt(u) ? PA : YA;
        return P(u, f);
      }
      function sT(u) {
        var f = dt(u) ? SA : XA;
        return f(u);
      }
      function aT(u) {
        if (u == null)
          return 0;
        if (qr(u))
          return Bc(u) ? la(u) : u.length;
        var f = br(u);
        return f == oe || f == nt ? u.size : Md(u).length;
      }
      function oT(u, f, b) {
        var P = dt(u) ? gd : QA;
        return b && Cr(u, f, b) && (f = r), P(u, rt(f, 3));
      }
      var uT = Et(function(u, f) {
        if (u == null)
          return [];
        var b = f.length;
        return b > 1 && Cr(u, f[0], f[1]) ? f = [] : b > 2 && Cr(f[0], f[1], f[2]) && (f = [f[0]]), _v(u, pr(f, 1), []);
      }), Lc = BS || function() {
        return dr.Date.now();
      };
      function cT(u, f) {
        if (typeof f != "function")
          throw new rn(a);
        return u = gt(u), function() {
          if (--u < 1)
            return f.apply(this, arguments);
        };
      }
      function hb(u, f, b) {
        return f = b ? r : f, f = u && f == null ? u.length : f, oi(u, j, r, r, r, r, f);
      }
      function mb(u, f) {
        var b;
        if (typeof f != "function")
          throw new rn(a);
        return u = gt(u), function() {
          return --u > 0 && (b = f.apply(this, arguments)), u <= 1 && (f = r), b;
        };
      }
      var sp = Et(function(u, f, b) {
        var P = _;
        if (b.length) {
          var N = Di(b, va(sp));
          P |= S;
        }
        return oi(u, P, f, b, N);
      }), yb = Et(function(u, f, b) {
        var P = _ | y;
        if (b.length) {
          var N = Di(b, va(yb));
          P |= S;
        }
        return oi(f, P, u, b, N);
      });
      function gb(u, f, b) {
        f = b ? r : f;
        var P = oi(u, $, r, r, r, r, r, f);
        return P.placeholder = gb.placeholder, P;
      }
      function vb(u, f, b) {
        f = b ? r : f;
        var P = oi(u, E, r, r, r, r, r, f);
        return P.placeholder = vb.placeholder, P;
      }
      function bb(u, f, b) {
        var P, N, H, re, ce, me, Te = 0, Ie = !1, Ne = !1, Ve = !0;
        if (typeof u != "function")
          throw new rn(a);
        f = un(f) || 0, Ht(b) && (Ie = !!b.leading, Ne = "maxWait" in b, H = Ne ? ar(un(b.maxWait) || 0, f) : H, Ve = "trailing" in b ? !!b.trailing : Ve);
        function Je(Xt) {
          var bn = P, di = N;
          return P = N = r, Te = Xt, re = u.apply(di, bn), re;
        }
        function it(Xt) {
          return Te = Xt, ce = Mo(Ot, f), Ie ? Je(Xt) : re;
        }
        function _t(Xt) {
          var bn = Xt - me, di = Xt - Te, Lb = f - bn;
          return Ne ? vr(Lb, H - di) : Lb;
        }
        function st(Xt) {
          var bn = Xt - me, di = Xt - Te;
          return me === r || bn >= f || bn < 0 || Ne && di >= H;
        }
        function Ot() {
          var Xt = Lc();
          if (st(Xt))
            return Ct(Xt);
          ce = Mo(Ot, _t(Xt));
        }
        function Ct(Xt) {
          return ce = r, Ve && P ? Je(Xt) : (P = N = r, re);
        }
        function Kr() {
          ce !== r && Cv(ce), Te = 0, P = me = N = ce = r;
        }
        function Rr() {
          return ce === r ? re : Ct(Lc());
        }
        function Yr() {
          var Xt = Lc(), bn = st(Xt);
          if (P = arguments, N = this, me = Xt, bn) {
            if (ce === r)
              return it(me);
            if (Ne)
              return Cv(ce), ce = Mo(Ot, f), Je(me);
          }
          return ce === r && (ce = Mo(Ot, f)), re;
        }
        return Yr.cancel = Kr, Yr.flush = Rr, Yr;
      }
      var lT = Et(function(u, f) {
        return uv(u, 1, f);
      }), fT = Et(function(u, f, b) {
        return uv(u, un(f) || 0, b);
      });
      function dT(u) {
        return oi(u, K);
      }
      function qc(u, f) {
        if (typeof u != "function" || f != null && typeof f != "function")
          throw new rn(a);
        var b = function() {
          var P = arguments, N = f ? f.apply(this, P) : P[0], H = b.cache;
          if (H.has(N))
            return H.get(N);
          var re = u.apply(this, P);
          return b.cache = H.set(N, re) || H, re;
        };
        return b.cache = new (qc.Cache || si)(), b;
      }
      qc.Cache = si;
      function Fc(u) {
        if (typeof u != "function")
          throw new rn(a);
        return function() {
          var f = arguments;
          switch (f.length) {
            case 0:
              return !u.call(this);
            case 1:
              return !u.call(this, f[0]);
            case 2:
              return !u.call(this, f[0], f[1]);
            case 3:
              return !u.call(this, f[0], f[1], f[2]);
          }
          return !u.apply(this, f);
        };
      }
      function pT(u) {
        return mb(2, u);
      }
      var hT = eC(function(u, f) {
        f = f.length == 1 && dt(f[0]) ? Wt(f[0], Wr(rt())) : Wt(pr(f, 1), Wr(rt()));
        var b = f.length;
        return Et(function(P) {
          for (var N = -1, H = vr(P.length, b); ++N < H; )
            P[N] = f[N].call(this, P[N]);
          return zr(u, this, P);
        });
      }), ap = Et(function(u, f) {
        var b = Di(f, va(ap));
        return oi(u, S, r, f, b);
      }), _b = Et(function(u, f) {
        var b = Di(f, va(_b));
        return oi(u, R, r, f, b);
      }), mT = ui(function(u, f) {
        return oi(u, L, r, r, r, f);
      });
      function yT(u, f) {
        if (typeof u != "function")
          throw new rn(a);
        return f = f === r ? f : gt(f), Et(u, f);
      }
      function gT(u, f) {
        if (typeof u != "function")
          throw new rn(a);
        return f = f == null ? 0 : ar(gt(f), 0), Et(function(b) {
          var P = b[f], N = Bi(b, 0, f);
          return P && Ni(N, P), zr(u, this, N);
        });
      }
      function vT(u, f, b) {
        var P = !0, N = !0;
        if (typeof u != "function")
          throw new rn(a);
        return Ht(b) && (P = "leading" in b ? !!b.leading : P, N = "trailing" in b ? !!b.trailing : N), bb(u, f, {
          leading: P,
          maxWait: f,
          trailing: N
        });
      }
      function bT(u) {
        return hb(u, 1);
      }
      function _T(u, f) {
        return ap(Zd(f), u);
      }
      function wT() {
        if (!arguments.length)
          return [];
        var u = arguments[0];
        return dt(u) ? u : [u];
      }
      function $T(u) {
        return sn(u, g);
      }
      function ET(u, f) {
        return f = typeof f == "function" ? f : r, sn(u, g, f);
      }
      function xT(u) {
        return sn(u, p | g);
      }
      function OT(u, f) {
        return f = typeof f == "function" ? f : r, sn(u, p | g, f);
      }
      function PT(u, f) {
        return f == null || ov(u, f, cr(f));
      }
      function vn(u, f) {
        return u === f || u !== u && f !== f;
      }
      var ST = Ic(Id), AT = Ic(function(u, f) {
        return u >= f;
      }), As = pv(function() {
        return arguments;
      }()) ? pv : function(u) {
        return Kt(u) && Dt.call(u, "callee") && !Q0.call(u, "callee");
      }, dt = we.isArray, CT = k0 ? Wr(k0) : DA;
      function qr(u) {
        return u != null && Uc(u.length) && !li(u);
      }
      function Jt(u) {
        return Kt(u) && qr(u);
      }
      function RT(u) {
        return u === !0 || u === !1 || Kt(u) && Ar(u) == k;
      }
      var Vi = ZS || gp, TT = M0 ? Wr(M0) : LA;
      function IT(u) {
        return Kt(u) && u.nodeType === 1 && !No(u);
      }
      function jT(u) {
        if (u == null)
          return !0;
        if (qr(u) && (dt(u) || typeof u == "string" || typeof u.splice == "function" || Vi(u) || ba(u) || As(u)))
          return !u.length;
        var f = br(u);
        if (f == oe || f == nt)
          return !u.size;
        if (ko(u))
          return !Md(u).length;
        for (var b in u)
          if (Dt.call(u, b))
            return !1;
        return !0;
      }
      function kT(u, f) {
        return To(u, f);
      }
      function MT(u, f, b) {
        b = typeof b == "function" ? b : r;
        var P = b ? b(u, f) : r;
        return P === r ? To(u, f, r, b) : !!P;
      }
      function op(u) {
        if (!Kt(u))
          return !1;
        var f = Ar(u);
        return f == A || f == J || typeof u.message == "string" && typeof u.name == "string" && !No(u);
      }
      function NT(u) {
        return typeof u == "number" && tv(u);
      }
      function li(u) {
        if (!Ht(u))
          return !1;
        var f = Ar(u);
        return f == I || f == X || f == U || f == $e;
      }
      function wb(u) {
        return typeof u == "number" && u == gt(u);
      }
      function Uc(u) {
        return typeof u == "number" && u > -1 && u % 1 == 0 && u <= Re;
      }
      function Ht(u) {
        var f = typeof u;
        return u != null && (f == "object" || f == "function");
      }
      function Kt(u) {
        return u != null && typeof u == "object";
      }
      var $b = N0 ? Wr(N0) : FA;
      function DT(u, f) {
        return u === f || kd(u, f, Jd(f));
      }
      function LT(u, f, b) {
        return b = typeof b == "function" ? b : r, kd(u, f, Jd(f), b);
      }
      function qT(u) {
        return Eb(u) && u != +u;
      }
      function FT(u) {
        if (EC(u))
          throw new lt(s);
        return hv(u);
      }
      function UT(u) {
        return u === null;
      }
      function BT(u) {
        return u == null;
      }
      function Eb(u) {
        return typeof u == "number" || Kt(u) && Ar(u) == Ae;
      }
      function No(u) {
        if (!Kt(u) || Ar(u) != Be)
          return !1;
        var f = hc(u);
        if (f === null)
          return !0;
        var b = Dt.call(f, "constructor") && f.constructor;
        return typeof b == "function" && b instanceof b && lc.call(b) == LS;
      }
      var up = D0 ? Wr(D0) : UA;
      function VT(u) {
        return wb(u) && u >= -Re && u <= Re;
      }
      var xb = L0 ? Wr(L0) : BA;
      function Bc(u) {
        return typeof u == "string" || !dt(u) && Kt(u) && Ar(u) == De;
      }
      function Gr(u) {
        return typeof u == "symbol" || Kt(u) && Ar(u) == Le;
      }
      var ba = q0 ? Wr(q0) : VA;
      function ZT(u) {
        return u === r;
      }
      function zT(u) {
        return Kt(u) && br(u) == mt;
      }
      function WT(u) {
        return Kt(u) && Ar(u) == Ue;
      }
      var HT = Ic(Nd), GT = Ic(function(u, f) {
        return u <= f;
      });
      function Ob(u) {
        if (!u)
          return [];
        if (qr(u))
          return Bc(u) ? yn(u) : Lr(u);
        if (Eo && u[Eo])
          return PS(u[Eo]());
        var f = br(u), b = f == oe ? Ed : f == nt ? oc : _a;
        return b(u);
      }
      function fi(u) {
        if (!u)
          return u === 0 ? u : 0;
        if (u = un(u), u === Ee || u === -Ee) {
          var f = u < 0 ? -1 : 1;
          return f * _e;
        }
        return u === u ? u : 0;
      }
      function gt(u) {
        var f = fi(u), b = f % 1;
        return f === f ? b ? f - b : f : 0;
      }
      function Pb(u) {
        return u ? xs(gt(u), 0, Y) : 0;
      }
      function un(u) {
        if (typeof u == "number")
          return u;
        if (Gr(u))
          return ie;
        if (Ht(u)) {
          var f = typeof u.valueOf == "function" ? u.valueOf() : u;
          u = Ht(f) ? f + "" : f;
        }
        if (typeof u != "string")
          return u === 0 ? u : +u;
        u = z0(u);
        var b = bt.test(u);
        return b || O.test(u) ? cS(u.slice(2), b ? 2 : 8) : Zt.test(u) ? ie : +u;
      }
      function Sb(u) {
        return Fn(u, Fr(u));
      }
      function KT(u) {
        return u ? xs(gt(u), -Re, Re) : u === 0 ? u : 0;
      }
      function Nt(u) {
        return u == null ? "" : Hr(u);
      }
      var YT = ya(function(u, f) {
        if (ko(f) || qr(f)) {
          Fn(f, cr(f), u);
          return;
        }
        for (var b in f)
          Dt.call(f, b) && Ao(u, b, f[b]);
      }), Ab = ya(function(u, f) {
        Fn(f, Fr(f), u);
      }), Vc = ya(function(u, f, b, P) {
        Fn(f, Fr(f), u, P);
      }), JT = ya(function(u, f, b, P) {
        Fn(f, cr(f), u, P);
      }), XT = ui(Cd);
      function QT(u, f) {
        var b = ma(u);
        return f == null ? b : av(b, f);
      }
      var eI = Et(function(u, f) {
        u = Bt(u);
        var b = -1, P = f.length, N = P > 2 ? f[2] : r;
        for (N && Cr(f[0], f[1], N) && (P = 1); ++b < P; )
          for (var H = f[b], re = Fr(H), ce = -1, me = re.length; ++ce < me; ) {
            var Te = re[ce], Ie = u[Te];
            (Ie === r || vn(Ie, da[Te]) && !Dt.call(u, Te)) && (u[Te] = H[Te]);
          }
        return u;
      }), tI = Et(function(u) {
        return u.push(r, zv), zr(Cb, r, u);
      });
      function rI(u, f) {
        return U0(u, rt(f, 3), qn);
      }
      function nI(u, f) {
        return U0(u, rt(f, 3), Td);
      }
      function iI(u, f) {
        return u == null ? u : Rd(u, rt(f, 3), Fr);
      }
      function sI(u, f) {
        return u == null ? u : fv(u, rt(f, 3), Fr);
      }
      function aI(u, f) {
        return u && qn(u, rt(f, 3));
      }
      function oI(u, f) {
        return u && Td(u, rt(f, 3));
      }
      function uI(u) {
        return u == null ? [] : xc(u, cr(u));
      }
      function cI(u) {
        return u == null ? [] : xc(u, Fr(u));
      }
      function cp(u, f, b) {
        var P = u == null ? r : Os(u, f);
        return P === r ? b : P;
      }
      function lI(u, f) {
        return u != null && Gv(u, f, jA);
      }
      function lp(u, f) {
        return u != null && Gv(u, f, kA);
      }
      var fI = Fv(function(u, f, b) {
        f != null && typeof f.toString != "function" && (f = fc.call(f)), u[f] = b;
      }, dp(Ur)), dI = Fv(function(u, f, b) {
        f != null && typeof f.toString != "function" && (f = fc.call(f)), Dt.call(u, f) ? u[f].push(b) : u[f] = [b];
      }, rt), pI = Et(Ro);
      function cr(u) {
        return qr(u) ? iv(u) : Md(u);
      }
      function Fr(u) {
        return qr(u) ? iv(u, !0) : ZA(u);
      }
      function hI(u, f) {
        var b = {};
        return f = rt(f, 3), qn(u, function(P, N, H) {
          ai(b, f(P, N, H), P);
        }), b;
      }
      function mI(u, f) {
        var b = {};
        return f = rt(f, 3), qn(u, function(P, N, H) {
          ai(b, N, f(P, N, H));
        }), b;
      }
      var yI = ya(function(u, f, b) {
        Oc(u, f, b);
      }), Cb = ya(function(u, f, b, P) {
        Oc(u, f, b, P);
      }), gI = ui(function(u, f) {
        var b = {};
        if (u == null)
          return b;
        var P = !1;
        f = Wt(f, function(H) {
          return H = Ui(H, u), P || (P = H.length > 1), H;
        }), Fn(u, Kd(u), b), P && (b = sn(b, p | h | g, fC));
        for (var N = f.length; N--; )
          Ud(b, f[N]);
        return b;
      });
      function vI(u, f) {
        return Rb(u, Fc(rt(f)));
      }
      var bI = ui(function(u, f) {
        return u == null ? {} : WA(u, f);
      });
      function Rb(u, f) {
        if (u == null)
          return {};
        var b = Wt(Kd(u), function(P) {
          return [P];
        });
        return f = rt(f), wv(u, b, function(P, N) {
          return f(P, N[0]);
        });
      }
      function _I(u, f, b) {
        f = Ui(f, u);
        var P = -1, N = f.length;
        for (N || (N = 1, u = r); ++P < N; ) {
          var H = u == null ? r : u[Un(f[P])];
          H === r && (P = N, H = b), u = li(H) ? H.call(u) : H;
        }
        return u;
      }
      function wI(u, f, b) {
        return u == null ? u : Io(u, f, b);
      }
      function $I(u, f, b, P) {
        return P = typeof P == "function" ? P : r, u == null ? u : Io(u, f, b, P);
      }
      var Tb = Vv(cr), Ib = Vv(Fr);
      function EI(u, f, b) {
        var P = dt(u), N = P || Vi(u) || ba(u);
        if (f = rt(f, 4), b == null) {
          var H = u && u.constructor;
          N ? b = P ? new H() : [] : Ht(u) ? b = li(H) ? ma(hc(u)) : {} : b = {};
        }
        return (N ? tn : qn)(u, function(re, ce, me) {
          return f(b, re, ce, me);
        }), b;
      }
      function xI(u, f) {
        return u == null ? !0 : Ud(u, f);
      }
      function OI(u, f, b) {
        return u == null ? u : Pv(u, f, Zd(b));
      }
      function PI(u, f, b, P) {
        return P = typeof P == "function" ? P : r, u == null ? u : Pv(u, f, Zd(b), P);
      }
      function _a(u) {
        return u == null ? [] : $d(u, cr(u));
      }
      function SI(u) {
        return u == null ? [] : $d(u, Fr(u));
      }
      function AI(u, f, b) {
        return b === r && (b = f, f = r), b !== r && (b = un(b), b = b === b ? b : 0), f !== r && (f = un(f), f = f === f ? f : 0), xs(un(u), f, b);
      }
      function CI(u, f, b) {
        return f = fi(f), b === r ? (b = f, f = 0) : b = fi(b), u = un(u), MA(u, f, b);
      }
      function RI(u, f, b) {
        if (b && typeof b != "boolean" && Cr(u, f, b) && (f = b = r), b === r && (typeof f == "boolean" ? (b = f, f = r) : typeof u == "boolean" && (b = u, u = r)), u === r && f === r ? (u = 0, f = 1) : (u = fi(u), f === r ? (f = u, u = 0) : f = fi(f)), u > f) {
          var P = u;
          u = f, f = P;
        }
        if (b || u % 1 || f % 1) {
          var N = rv();
          return vr(u + N * (f - u + uS("1e-" + ((N + "").length - 1))), f);
        }
        return Ld(u, f);
      }
      var TI = ga(function(u, f, b) {
        return f = f.toLowerCase(), u + (b ? jb(f) : f);
      });
      function jb(u) {
        return fp(Nt(u).toLowerCase());
      }
      function kb(u) {
        return u = Nt(u), u && u.replace(W, wS).replace(XP, "");
      }
      function II(u, f, b) {
        u = Nt(u), f = Hr(f);
        var P = u.length;
        b = b === r ? P : xs(gt(b), 0, P);
        var N = b;
        return b -= f.length, b >= 0 && u.slice(b, N) == f;
      }
      function jI(u) {
        return u = Nt(u), u && Dn.test(u) ? u.replace(na, $S) : u;
      }
      function kI(u) {
        return u = Nt(u), u && bo.test(u) ? u.replace(Ii, "\\$&") : u;
      }
      var MI = ga(function(u, f, b) {
        return u + (b ? "-" : "") + f.toLowerCase();
      }), NI = ga(function(u, f, b) {
        return u + (b ? " " : "") + f.toLowerCase();
      }), DI = Dv("toLowerCase");
      function LI(u, f, b) {
        u = Nt(u), f = gt(f);
        var P = f ? la(u) : 0;
        if (!f || P >= f)
          return u;
        var N = (f - P) / 2;
        return Tc(vc(N), b) + u + Tc(gc(N), b);
      }
      function qI(u, f, b) {
        u = Nt(u), f = gt(f);
        var P = f ? la(u) : 0;
        return f && P < f ? u + Tc(f - P, b) : u;
      }
      function FI(u, f, b) {
        u = Nt(u), f = gt(f);
        var P = f ? la(u) : 0;
        return f && P < f ? Tc(f - P, b) + u : u;
      }
      function UI(u, f, b) {
        return b || f == null ? f = 0 : f && (f = +f), GS(Nt(u).replace(ji, ""), f || 0);
      }
      function BI(u, f, b) {
        return (b ? Cr(u, f, b) : f === r) ? f = 1 : f = gt(f), qd(Nt(u), f);
      }
      function VI() {
        var u = arguments, f = Nt(u[0]);
        return u.length < 3 ? f : f.replace(u[1], u[2]);
      }
      var ZI = ga(function(u, f, b) {
        return u + (b ? "_" : "") + f.toLowerCase();
      });
      function zI(u, f, b) {
        return b && typeof b != "number" && Cr(u, f, b) && (f = b = r), b = b === r ? Y : b >>> 0, b ? (u = Nt(u), u && (typeof f == "string" || f != null && !up(f)) && (f = Hr(f), !f && ca(u)) ? Bi(yn(u), 0, b) : u.split(f, b)) : [];
      }
      var WI = ga(function(u, f, b) {
        return u + (b ? " " : "") + fp(f);
      });
      function HI(u, f, b) {
        return u = Nt(u), b = b == null ? 0 : xs(gt(b), 0, u.length), f = Hr(f), u.slice(b, b + f.length) == f;
      }
      function GI(u, f, b) {
        var P = B.templateSettings;
        b && Cr(u, f, b) && (f = r), u = Nt(u), f = Vc({}, f, P, Zv);
        var N = Vc({}, f.imports, P.imports, Zv), H = cr(N), re = $d(N, H), ce, me, Te = 0, Ie = f.interpolate || se, Ne = "__p += '", Ve = xd(
          (f.escape || se).source + "|" + Ie.source + "|" + (Ie === sa ? xt : se).source + "|" + (f.evaluate || se).source + "|$",
          "g"
        ), Je = "//# sourceURL=" + (Dt.call(f, "sourceURL") ? (f.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++nS + "]") + `
`;
        u.replace(Ve, function(st, Ot, Ct, Kr, Rr, Yr) {
          return Ct || (Ct = Kr), Ne += u.slice(Te, Yr).replace(ne, ES), Ot && (ce = !0, Ne += `' +
__e(` + Ot + `) +
'`), Rr && (me = !0, Ne += `';
` + Rr + `;
__p += '`), Ct && (Ne += `' +
((__t = (` + Ct + `)) == null ? '' : __t) +
'`), Te = Yr + st.length, st;
        }), Ne += `';
`;
        var it = Dt.call(f, "variable") && f.variable;
        if (!it)
          Ne = `with (obj) {
` + Ne + `
}
`;
        else if (Ye.test(it))
          throw new lt(o);
        Ne = (me ? Ne.replace(Tt, "") : Ne).replace(ho, "$1").replace(mo, "$1;"), Ne = "function(" + (it || "obj") + `) {
` + (it ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (ce ? ", __e = _.escape" : "") + (me ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + Ne + `return __p
}`;
        var _t = Nb(function() {
          return jt(H, Je + "return " + Ne).apply(r, re);
        });
        if (_t.source = Ne, op(_t))
          throw _t;
        return _t;
      }
      function KI(u) {
        return Nt(u).toLowerCase();
      }
      function YI(u) {
        return Nt(u).toUpperCase();
      }
      function JI(u, f, b) {
        if (u = Nt(u), u && (b || f === r))
          return z0(u);
        if (!u || !(f = Hr(f)))
          return u;
        var P = yn(u), N = yn(f), H = W0(P, N), re = H0(P, N) + 1;
        return Bi(P, H, re).join("");
      }
      function XI(u, f, b) {
        if (u = Nt(u), u && (b || f === r))
          return u.slice(0, K0(u) + 1);
        if (!u || !(f = Hr(f)))
          return u;
        var P = yn(u), N = H0(P, yn(f)) + 1;
        return Bi(P, 0, N).join("");
      }
      function QI(u, f, b) {
        if (u = Nt(u), u && (b || f === r))
          return u.replace(ji, "");
        if (!u || !(f = Hr(f)))
          return u;
        var P = yn(u), N = W0(P, yn(f));
        return Bi(P, N).join("");
      }
      function ej(u, f) {
        var b = ae, P = ye;
        if (Ht(f)) {
          var N = "separator" in f ? f.separator : N;
          b = "length" in f ? gt(f.length) : b, P = "omission" in f ? Hr(f.omission) : P;
        }
        u = Nt(u);
        var H = u.length;
        if (ca(u)) {
          var re = yn(u);
          H = re.length;
        }
        if (b >= H)
          return u;
        var ce = b - la(P);
        if (ce < 1)
          return P;
        var me = re ? Bi(re, 0, ce).join("") : u.slice(0, ce);
        if (N === r)
          return me + P;
        if (re && (ce += me.length - ce), up(N)) {
          if (u.slice(ce).search(N)) {
            var Te, Ie = me;
            for (N.global || (N = xd(N.source, Nt(Mt.exec(N)) + "g")), N.lastIndex = 0; Te = N.exec(Ie); )
              var Ne = Te.index;
            me = me.slice(0, Ne === r ? ce : Ne);
          }
        } else if (u.indexOf(Hr(N), ce) != ce) {
          var Ve = me.lastIndexOf(N);
          Ve > -1 && (me = me.slice(0, Ve));
        }
        return me + P;
      }
      function tj(u) {
        return u = Nt(u), u && yo.test(u) ? u.replace(ra, RS) : u;
      }
      var rj = ga(function(u, f, b) {
        return u + (b ? " " : "") + f.toUpperCase();
      }), fp = Dv("toUpperCase");
      function Mb(u, f, b) {
        return u = Nt(u), f = b ? r : f, f === r ? OS(u) ? jS(u) : yS(u) : u.match(f) || [];
      }
      var Nb = Et(function(u, f) {
        try {
          return zr(u, r, f);
        } catch (b) {
          return op(b) ? b : new lt(b);
        }
      }), nj = ui(function(u, f) {
        return tn(f, function(b) {
          b = Un(b), ai(u, b, sp(u[b], u));
        }), u;
      });
      function ij(u) {
        var f = u == null ? 0 : u.length, b = rt();
        return u = f ? Wt(u, function(P) {
          if (typeof P[1] != "function")
            throw new rn(a);
          return [b(P[0]), P[1]];
        }) : [], Et(function(P) {
          for (var N = -1; ++N < f; ) {
            var H = u[N];
            if (zr(H[0], this, P))
              return zr(H[1], this, P);
          }
        });
      }
      function sj(u) {
        return RA(sn(u, p));
      }
      function dp(u) {
        return function() {
          return u;
        };
      }
      function aj(u, f) {
        return u == null || u !== u ? f : u;
      }
      var oj = qv(), uj = qv(!0);
      function Ur(u) {
        return u;
      }
      function pp(u) {
        return mv(typeof u == "function" ? u : sn(u, p));
      }
      function cj(u) {
        return gv(sn(u, p));
      }
      function lj(u, f) {
        return vv(u, sn(f, p));
      }
      var fj = Et(function(u, f) {
        return function(b) {
          return Ro(b, u, f);
        };
      }), dj = Et(function(u, f) {
        return function(b) {
          return Ro(u, b, f);
        };
      });
      function hp(u, f, b) {
        var P = cr(f), N = xc(f, P);
        b == null && !(Ht(f) && (N.length || !P.length)) && (b = f, f = u, u = this, N = xc(f, cr(f)));
        var H = !(Ht(b) && "chain" in b) || !!b.chain, re = li(u);
        return tn(N, function(ce) {
          var me = f[ce];
          u[ce] = me, re && (u.prototype[ce] = function() {
            var Te = this.__chain__;
            if (H || Te) {
              var Ie = u(this.__wrapped__), Ne = Ie.__actions__ = Lr(this.__actions__);
              return Ne.push({ func: me, args: arguments, thisArg: u }), Ie.__chain__ = Te, Ie;
            }
            return me.apply(u, Ni([this.value()], arguments));
          });
        }), u;
      }
      function pj() {
        return dr._ === this && (dr._ = qS), this;
      }
      function mp() {
      }
      function hj(u) {
        return u = gt(u), Et(function(f) {
          return bv(f, u);
        });
      }
      var mj = Wd(Wt), yj = Wd(F0), gj = Wd(gd);
      function Db(u) {
        return Qd(u) ? vd(Un(u)) : HA(u);
      }
      function vj(u) {
        return function(f) {
          return u == null ? r : Os(u, f);
        };
      }
      var bj = Uv(), _j = Uv(!0);
      function yp() {
        return [];
      }
      function gp() {
        return !1;
      }
      function wj() {
        return {};
      }
      function $j() {
        return "";
      }
      function Ej() {
        return !0;
      }
      function xj(u, f) {
        if (u = gt(u), u < 1 || u > Re)
          return [];
        var b = Y, P = vr(u, Y);
        f = rt(f), u -= Y;
        for (var N = wd(P, f); ++b < u; )
          f(b);
        return N;
      }
      function Oj(u) {
        return dt(u) ? Wt(u, Un) : Gr(u) ? [u] : Lr(nb(Nt(u)));
      }
      function Pj(u) {
        var f = ++DS;
        return Nt(u) + f;
      }
      var Sj = Rc(function(u, f) {
        return u + f;
      }, 0), Aj = Hd("ceil"), Cj = Rc(function(u, f) {
        return u / f;
      }, 1), Rj = Hd("floor");
      function Tj(u) {
        return u && u.length ? Ec(u, Ur, Id) : r;
      }
      function Ij(u, f) {
        return u && u.length ? Ec(u, rt(f, 2), Id) : r;
      }
      function jj(u) {
        return V0(u, Ur);
      }
      function kj(u, f) {
        return V0(u, rt(f, 2));
      }
      function Mj(u) {
        return u && u.length ? Ec(u, Ur, Nd) : r;
      }
      function Nj(u, f) {
        return u && u.length ? Ec(u, rt(f, 2), Nd) : r;
      }
      var Dj = Rc(function(u, f) {
        return u * f;
      }, 1), Lj = Hd("round"), qj = Rc(function(u, f) {
        return u - f;
      }, 0);
      function Fj(u) {
        return u && u.length ? _d(u, Ur) : 0;
      }
      function Uj(u, f) {
        return u && u.length ? _d(u, rt(f, 2)) : 0;
      }
      return B.after = cT, B.ary = hb, B.assign = YT, B.assignIn = Ab, B.assignInWith = Vc, B.assignWith = JT, B.at = XT, B.before = mb, B.bind = sp, B.bindAll = nj, B.bindKey = yb, B.castArray = wT, B.chain = fb, B.chunk = RC, B.compact = TC, B.concat = IC, B.cond = ij, B.conforms = sj, B.constant = dp, B.countBy = FR, B.create = QT, B.curry = gb, B.curryRight = vb, B.debounce = bb, B.defaults = eI, B.defaultsDeep = tI, B.defer = lT, B.delay = fT, B.difference = jC, B.differenceBy = kC, B.differenceWith = MC, B.drop = NC, B.dropRight = DC, B.dropRightWhile = LC, B.dropWhile = qC, B.fill = FC, B.filter = BR, B.flatMap = zR, B.flatMapDeep = WR, B.flatMapDepth = HR, B.flatten = ob, B.flattenDeep = UC, B.flattenDepth = BC, B.flip = dT, B.flow = oj, B.flowRight = uj, B.fromPairs = VC, B.functions = uI, B.functionsIn = cI, B.groupBy = GR, B.initial = zC, B.intersection = WC, B.intersectionBy = HC, B.intersectionWith = GC, B.invert = fI, B.invertBy = dI, B.invokeMap = YR, B.iteratee = pp, B.keyBy = JR, B.keys = cr, B.keysIn = Fr, B.map = Dc, B.mapKeys = hI, B.mapValues = mI, B.matches = cj, B.matchesProperty = lj, B.memoize = qc, B.merge = yI, B.mergeWith = Cb, B.method = fj, B.methodOf = dj, B.mixin = hp, B.negate = Fc, B.nthArg = hj, B.omit = gI, B.omitBy = vI, B.once = pT, B.orderBy = XR, B.over = mj, B.overArgs = hT, B.overEvery = yj, B.overSome = gj, B.partial = ap, B.partialRight = _b, B.partition = QR, B.pick = bI, B.pickBy = Rb, B.property = Db, B.propertyOf = vj, B.pull = XC, B.pullAll = cb, B.pullAllBy = QC, B.pullAllWith = eR, B.pullAt = tR, B.range = bj, B.rangeRight = _j, B.rearg = mT, B.reject = rT, B.remove = rR, B.rest = yT, B.reverse = np, B.sampleSize = iT, B.set = wI, B.setWith = $I, B.shuffle = sT, B.slice = nR, B.sortBy = uT, B.sortedUniq = lR, B.sortedUniqBy = fR, B.split = zI, B.spread = gT, B.tail = dR, B.take = pR, B.takeRight = hR, B.takeRightWhile = mR, B.takeWhile = yR, B.tap = TR, B.throttle = vT, B.thru = Nc, B.toArray = Ob, B.toPairs = Tb, B.toPairsIn = Ib, B.toPath = Oj, B.toPlainObject = Sb, B.transform = EI, B.unary = bT, B.union = gR, B.unionBy = vR, B.unionWith = bR, B.uniq = _R, B.uniqBy = wR, B.uniqWith = $R, B.unset = xI, B.unzip = ip, B.unzipWith = lb, B.update = OI, B.updateWith = PI, B.values = _a, B.valuesIn = SI, B.without = ER, B.words = Mb, B.wrap = _T, B.xor = xR, B.xorBy = OR, B.xorWith = PR, B.zip = SR, B.zipObject = AR, B.zipObjectDeep = CR, B.zipWith = RR, B.entries = Tb, B.entriesIn = Ib, B.extend = Ab, B.extendWith = Vc, hp(B, B), B.add = Sj, B.attempt = Nb, B.camelCase = TI, B.capitalize = jb, B.ceil = Aj, B.clamp = AI, B.clone = $T, B.cloneDeep = xT, B.cloneDeepWith = OT, B.cloneWith = ET, B.conformsTo = PT, B.deburr = kb, B.defaultTo = aj, B.divide = Cj, B.endsWith = II, B.eq = vn, B.escape = jI, B.escapeRegExp = kI, B.every = UR, B.find = VR, B.findIndex = sb, B.findKey = rI, B.findLast = ZR, B.findLastIndex = ab, B.findLastKey = nI, B.floor = Rj, B.forEach = db, B.forEachRight = pb, B.forIn = iI, B.forInRight = sI, B.forOwn = aI, B.forOwnRight = oI, B.get = cp, B.gt = ST, B.gte = AT, B.has = lI, B.hasIn = lp, B.head = ub, B.identity = Ur, B.includes = KR, B.indexOf = ZC, B.inRange = CI, B.invoke = pI, B.isArguments = As, B.isArray = dt, B.isArrayBuffer = CT, B.isArrayLike = qr, B.isArrayLikeObject = Jt, B.isBoolean = RT, B.isBuffer = Vi, B.isDate = TT, B.isElement = IT, B.isEmpty = jT, B.isEqual = kT, B.isEqualWith = MT, B.isError = op, B.isFinite = NT, B.isFunction = li, B.isInteger = wb, B.isLength = Uc, B.isMap = $b, B.isMatch = DT, B.isMatchWith = LT, B.isNaN = qT, B.isNative = FT, B.isNil = BT, B.isNull = UT, B.isNumber = Eb, B.isObject = Ht, B.isObjectLike = Kt, B.isPlainObject = No, B.isRegExp = up, B.isSafeInteger = VT, B.isSet = xb, B.isString = Bc, B.isSymbol = Gr, B.isTypedArray = ba, B.isUndefined = ZT, B.isWeakMap = zT, B.isWeakSet = WT, B.join = KC, B.kebabCase = MI, B.last = on, B.lastIndexOf = YC, B.lowerCase = NI, B.lowerFirst = DI, B.lt = HT, B.lte = GT, B.max = Tj, B.maxBy = Ij, B.mean = jj, B.meanBy = kj, B.min = Mj, B.minBy = Nj, B.stubArray = yp, B.stubFalse = gp, B.stubObject = wj, B.stubString = $j, B.stubTrue = Ej, B.multiply = Dj, B.nth = JC, B.noConflict = pj, B.noop = mp, B.now = Lc, B.pad = LI, B.padEnd = qI, B.padStart = FI, B.parseInt = UI, B.random = RI, B.reduce = eT, B.reduceRight = tT, B.repeat = BI, B.replace = VI, B.result = _I, B.round = Lj, B.runInContext = he, B.sample = nT, B.size = aT, B.snakeCase = ZI, B.some = oT, B.sortedIndex = iR, B.sortedIndexBy = sR, B.sortedIndexOf = aR, B.sortedLastIndex = oR, B.sortedLastIndexBy = uR, B.sortedLastIndexOf = cR, B.startCase = WI, B.startsWith = HI, B.subtract = qj, B.sum = Fj, B.sumBy = Uj, B.template = GI, B.times = xj, B.toFinite = fi, B.toInteger = gt, B.toLength = Pb, B.toLower = KI, B.toNumber = un, B.toSafeInteger = KT, B.toString = Nt, B.toUpper = YI, B.trim = JI, B.trimEnd = XI, B.trimStart = QI, B.truncate = ej, B.unescape = tj, B.uniqueId = Pj, B.upperCase = rj, B.upperFirst = fp, B.each = db, B.eachRight = pb, B.first = ub, hp(B, function() {
        var u = {};
        return qn(B, function(f, b) {
          Dt.call(B.prototype, b) || (u[b] = f);
        }), u;
      }(), { chain: !1 }), B.VERSION = i, tn(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(u) {
        B[u].placeholder = B;
      }), tn(["drop", "take"], function(u, f) {
        St.prototype[u] = function(b) {
          b = b === r ? 1 : ar(gt(b), 0);
          var P = this.__filtered__ && !f ? new St(this) : this.clone();
          return P.__filtered__ ? P.__takeCount__ = vr(b, P.__takeCount__) : P.__views__.push({
            size: vr(b, Y),
            type: u + (P.__dir__ < 0 ? "Right" : "")
          }), P;
        }, St.prototype[u + "Right"] = function(b) {
          return this.reverse()[u](b).reverse();
        };
      }), tn(["filter", "map", "takeWhile"], function(u, f) {
        var b = f + 1, P = b == te || b == de;
        St.prototype[u] = function(N) {
          var H = this.clone();
          return H.__iteratees__.push({
            iteratee: rt(N, 3),
            type: b
          }), H.__filtered__ = H.__filtered__ || P, H;
        };
      }), tn(["head", "last"], function(u, f) {
        var b = "take" + (f ? "Right" : "");
        St.prototype[u] = function() {
          return this[b](1).value()[0];
        };
      }), tn(["initial", "tail"], function(u, f) {
        var b = "drop" + (f ? "" : "Right");
        St.prototype[u] = function() {
          return this.__filtered__ ? new St(this) : this[b](1);
        };
      }), St.prototype.compact = function() {
        return this.filter(Ur);
      }, St.prototype.find = function(u) {
        return this.filter(u).head();
      }, St.prototype.findLast = function(u) {
        return this.reverse().find(u);
      }, St.prototype.invokeMap = Et(function(u, f) {
        return typeof u == "function" ? new St(this) : this.map(function(b) {
          return Ro(b, u, f);
        });
      }), St.prototype.reject = function(u) {
        return this.filter(Fc(rt(u)));
      }, St.prototype.slice = function(u, f) {
        u = gt(u);
        var b = this;
        return b.__filtered__ && (u > 0 || f < 0) ? new St(b) : (u < 0 ? b = b.takeRight(-u) : u && (b = b.drop(u)), f !== r && (f = gt(f), b = f < 0 ? b.dropRight(-f) : b.take(f - u)), b);
      }, St.prototype.takeRightWhile = function(u) {
        return this.reverse().takeWhile(u).reverse();
      }, St.prototype.toArray = function() {
        return this.take(Y);
      }, qn(St.prototype, function(u, f) {
        var b = /^(?:filter|find|map|reject)|While$/.test(f), P = /^(?:head|last)$/.test(f), N = B[P ? "take" + (f == "last" ? "Right" : "") : f], H = P || /^find/.test(f);
        N && (B.prototype[f] = function() {
          var re = this.__wrapped__, ce = P ? [1] : arguments, me = re instanceof St, Te = ce[0], Ie = me || dt(re), Ne = function(Ot) {
            var Ct = N.apply(B, Ni([Ot], ce));
            return P && Ve ? Ct[0] : Ct;
          };
          Ie && b && typeof Te == "function" && Te.length != 1 && (me = Ie = !1);
          var Ve = this.__chain__, Je = !!this.__actions__.length, it = H && !Ve, _t = me && !Je;
          if (!H && Ie) {
            re = _t ? re : new St(this);
            var st = u.apply(re, ce);
            return st.__actions__.push({ func: Nc, args: [Ne], thisArg: r }), new nn(st, Ve);
          }
          return it && _t ? u.apply(this, ce) : (st = this.thru(Ne), it ? P ? st.value()[0] : st.value() : st);
        });
      }), tn(["pop", "push", "shift", "sort", "splice", "unshift"], function(u) {
        var f = uc[u], b = /^(?:push|sort|unshift)$/.test(u) ? "tap" : "thru", P = /^(?:pop|shift)$/.test(u);
        B.prototype[u] = function() {
          var N = arguments;
          if (P && !this.__chain__) {
            var H = this.value();
            return f.apply(dt(H) ? H : [], N);
          }
          return this[b](function(re) {
            return f.apply(dt(re) ? re : [], N);
          });
        };
      }), qn(St.prototype, function(u, f) {
        var b = B[f];
        if (b) {
          var P = b.name + "";
          Dt.call(ha, P) || (ha[P] = []), ha[P].push({ name: f, func: b });
        }
      }), ha[Cc(r, y).name] = [{
        name: "wrapper",
        func: r
      }], St.prototype.clone = tA, St.prototype.reverse = rA, St.prototype.value = nA, B.prototype.at = IR, B.prototype.chain = jR, B.prototype.commit = kR, B.prototype.next = MR, B.prototype.plant = DR, B.prototype.reverse = LR, B.prototype.toJSON = B.prototype.valueOf = B.prototype.value = qR, B.prototype.first = B.prototype.head, Eo && (B.prototype[Eo] = NR), B;
    }, fa = kS();
    _s ? ((_s.exports = fa)._ = fa, pd._ = fa) : dr._ = fa;
  }).call(tt);
})(_f, _f.exports);
var iW = _f.exports;
const sW = /* @__PURE__ */ Ks(iW), UP = (e) => {
  const t = {};
  return Object.keys(e.schema.paths).map((r) => {
    const i = r.replace("/", "");
    t[i] = async (n) => new Promise((s, a) => {
      e.fns[i].fn({
        ...n,
        onData: n == null ? void 0 : n.onData,
        onDone: s,
        onError: a
      });
    });
  }), t;
}, BP = async ({ id: e, desc: t, version: r }) => {
  const i = {}, n = {}, s = {};
  return {
    addMethod: ({ id: o, fn: c, desc: l, settings: d }) => {
      i[o] = {
        fn: async (h) => c(h),
        settings: d,
        desc: l
      };
      const p = {
        addInput: ({ schema: h }) => {
          if (n[o])
            throw new Error(`Method ${o} already has an input, only one input per method allowed`);
          return n[o] = t$({ schema: h }), p;
        },
        addOutput: ({ schema: h, desc: g, code: m }) => (s[o] || (s[o] = []), s[o].push({ schema: t$({ schema: h }), desc: g, code: m }), p),
        setMultiplier: ({ multiplier: h }) => {
          var g;
          return (g = i[o]) != null && g.settings || (i[o].settings = {}), i[o].settings = { ...i[o].settings, multiplier: h }, p;
        }
      };
      return p;
    },
    run: async () => {
      const o = {};
      Object.keys(i).forEach((g) => {
        var v;
        const m = {
          required: !1,
          content: {}
        };
        o[`/${g}`] = {
          post: {
            summary: i[g].desc,
            operationId: g,
            tags: (v = sW.keys(i[g].settings)) == null ? void 0 : v.map((_) => {
              var w, $;
              const y = ($ = (w = i[g]) == null ? void 0 : w.settings) == null ? void 0 : $[_];
              return `${_}=${y}`;
            }),
            //FNS[fn_id].settings?.free ? ["free=true"] : [],
            requestBody: n[g] ? {
              required: !0,
              content: {
                "application/json": {
                  schema: n[g]
                }
              }
            } : m,
            responses: {}
          }
        }, s[g].forEach((_) => {
          o[`/${g}`].post.responses[_.code] = {
            description: _.desc,
            content: {
              "application/json": {
                schema: _.schema
              }
            }
          };
        });
      });
      const c = {};
      Object.keys(i).forEach((g) => {
        c[g] = {
          fn: i[g].fn,
          desc: i[g].desc,
          settings: i[g].settings
        };
      });
      const l = {
        id: e,
        fns: c,
        schema: {
          openapi: "3.0.0",
          info: {
            title: e,
            description: t,
            version: r || "1.0.0"
          },
          paths: o
        }
      }, [d, p, h] = await FP(l.schema, {
        fullResult: !0
      });
      if (p)
        throw new Error(`Module ${e} verification failed: ${p.message()}`);
      return l;
    }
  };
}, _2 = new Vu({ ttl: 1e4 }), w2 = new Vu({ ttl: 1e4 }), $2 = new Vu({ ttl: 1e4 }), aW = async ({ user_id: e }) => {
  const t = _2.get(e);
  if (t)
    return t;
  const r = await od({
    ms: 15e3,
    fn: fetch("https://wallet.promptc0.com/getStatus", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ user_id: e })
    })
  }).then((i) => "json" in i && i.json());
  return !r || "error" in r || typeof r.result === void 0 ? !1 : (_2.put(e, r.result), r.result);
}, oW = async ({ user_id: e }) => {
  const t = w2.get(e);
  if (t)
    return t;
  const r = await od({
    ms: 15e3,
    fn: fetch("https://wallet.promptc0.com/getBalance", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ user_id: e })
    })
  }).then((i) => "json" in i && i.json());
  return !r || "error" in r || typeof r.result === void 0 ? !1 : (w2.put(e, r.result), r.result);
}, uW = async ({ user_id: e }) => {
  const t = $2.get(e);
  if (t)
    return t;
  const r = await od({
    ms: 15e3,
    fn: fetch("https://wallet.promptc0.com/getBalance", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ user_id: e })
    })
  }).then((i) => "json" in i && i.json());
  return !r || "error" in r || typeof r.result === void 0 ? !1 : ($2.put(e, r.result), r.result);
}, cW = async ({ receipt: e }) => od({
  ms: 15e3,
  fn: fetch("https://wallet.promptc0.com/charge", {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify({ receipt: e })
  }).then((t) => t.json())
}), pl = ad("module:handshake"), Ky = async () => {
  const e = await BP({
    id: "wallet",
    desc: "Wallet module",
    version: "1.0.0"
  });
  return e.addMethod({
    id: "getStatus",
    desc: "Get wallet status",
    fn: async ({ onData: t, onError: r, onDone: i, user_id: n }) => {
      const s = await aW({ user_id: n });
      return !s || "error" in s ? r({ error: (s == null ? void 0 : s.error) || "Unknown error", code: 500 }) : (pl(`fetched status ${s} for ${n}`), i({ result: s }), {
        abort: () => {
        }
      });
    }
  }).addInput({
    schema: ke.object({
      user_id: ke.string()
    })
  }).addOutput({
    code: 200,
    desc: "Returns wallet status",
    schema: ke.object({
      result: ke.string()
    })
  }), e.addMethod({
    id: "getBalance",
    desc: "Get wallet balance",
    fn: async ({ onData: t, onError: r, onDone: i, user_id: n }) => {
      const s = await oW({ user_id: n });
      return typeof s === void 0 || typeof s == "object" && "error" in s ? r({ error: (s == null ? void 0 : s.error) || "Unknown error", code: 500 }) : (pl(`fetched balance ${s} for ${n}`), i({ result: s }), {
        abort: () => {
        }
      });
    }
  }).addInput({
    schema: ke.object({
      user_id: ke.string()
    })
  }).addOutput({
    code: 200,
    desc: "Returns wallet balance",
    schema: ke.object({
      result: ke.number()
    })
  }), e.addMethod({
    id: "getSubsidizedBalance",
    desc: "Get wallet's subsidized credits",
    fn: async ({ onData: t, onError: r, onDone: i, user_id: n }) => {
      const s = await uW({ user_id: n });
      return !s || "error" in s ? r({ error: (s == null ? void 0 : s.error) || "Unknown error", code: 500 }) : (pl(`fetched subsidized balance ${s} for ${n}`), i({ result: s }), {
        abort: () => {
        }
      });
    }
  }).addInput({
    schema: ke.object({
      user_id: ke.string()
    })
  }).addOutput({
    code: 200,
    desc: "Returns wallet's subsidized credits",
    schema: ke.object({
      result: ke.number()
    })
  }), e.addMethod({
    id: "charge",
    desc: "Charge wallet",
    fn: async ({ onData: t, onError: r, onDone: i, receipt: n }) => {
      const s = await cW({ receipt: n });
      return s && "error" in s ? r({ error: s.error, code: 500 }) : (pl(`charged wallet ${n.user_id} with ${n.amount}`), i({ result: s.body }), {
        abort: () => {
        }
      });
    }
  }).addInput({
    schema: ke.object({
      receipt: Yy
    })
  }).addOutput({
    code: 200,
    desc: "Charge wallet",
    schema: ke.object({
      result: ke.number()
    })
  }), e.run();
};
async function E2({
  input: e,
  globals: t,
  request: r
}) {
  var m;
  const { MODULES: i, PROTOCOLS: n, REQUESTS: s } = t;
  if (s[e.id])
    return;
  e.offer.call.module_id !== "handshake" && (s[e.id] = !0);
  const { call: a } = e.offer, o = a.method_id.replace("/", ""), c = i.find(
    (v) => v.id === a.module_id && v.schema.paths[`/${a.method_id}`] && v.fns[o]
  );
  if (!c)
    return r.onError({ error: `Unknown call ${a.module_id}`, code: 404 });
  if (typeof ((m = c.fns[o]) == null ? void 0 : m.fn) != "function")
    return r.onError({ error: "Function id references are not supported yet", code: 404 });
  const l = {
    openapi: "3.0.0",
    ...c.schema
  };
  l.info.title = c.id;
  const [d, p, h] = await FP(l, {
    fullResult: !0
  });
  if (p)
    return r.onError({ error: p.message(), code: 500 });
  h && console.warn(h.message);
  const g = c.fns[o].fn;
  if (console.log(`Executing ${a.module_id}:${a.method_id} / ${e.id}`), typeof g == "function") {
    let v = 0;
    const _ = async ($) => {
      const E = $ == null ? void 0 : $.data;
      E && (v += Il(E)), r != null && r.onData && r.onData($);
    }, y = async ($) => {
      var R, j;
      const E = {
        id: Tf(),
        user_id: e.meta.user_id,
        offer: e.offer,
        details: {
          input: {
            bytes: 0,
            tokens: 0
          },
          output: {
            bytes: 0,
            tokens: 0
          }
        },
        total_bytes: 0,
        total_tokens: 0
      };
      let S = 0;
      if (e != null && e.signed_transaction && ((R = e == null ? void 0 : e.offer) != null && R.multiplier)) {
        let L = v;
        $ != null && $.data && (L = Il($ == null ? void 0 : $.data)), S = ((j = c.fns[o].settings) == null ? void 0 : j.multiplier) || 0;
        const K = Il(e.params || 0);
        E.details = {
          input: {
            bytes: K,
            tokens: K * S
          },
          output: {
            bytes: L,
            tokens: S * L
          }
        }, E.total_tokens = E.details.input.tokens + E.details.output.tokens, E.total_bytes = E.details.input.bytes + E.details.output.bytes;
        const ae = await pf(JSON.stringify(E), hf({ input: t.private_key }));
        E.sig = Xr({ input: ae });
        const ye = Yy.safeParse(E);
        if (!ye.success)
          return (r == null ? void 0 : r.onError) && r.onError({ error: "invalid receipt", code: 500 });
        $.receipt = ye.data;
        const xe = UP(await Ky());
        try {
          const Pe = await xe.charge({
            receipt: $.receipt
          });
        } catch (Pe) {
          return (r == null ? void 0 : r.onError) && r.onError(Pe);
        }
      }
      r != null && r.onDone && r.onDone($);
    }, w = await g({
      stripe: t.stripe,
      ...e.params,
      user_id: e.meta.user_id,
      onData: _,
      onDone: y,
      onError: r.onError
    });
    return typeof w == "object" && "error" in w ? r.onError({ ...w == null ? void 0 : w.error }) : (e.offer.id !== "handshake" && (s[e.id] = w), w);
  } else
    return r.onError({ error: `Unknown function ${e.offer.call.method_id}`, code: 404 });
}
const lW = ad("module:handshake"), fW = async () => {
  const e = await BP({
    id: "handshake",
    desc: "Handshake module",
    version: "1.0.0"
  });
  return e.addMethod({
    id: "challenge",
    fn: async ({ onData: t, onError: r, onDone: i, request_id: n, ip: s }) => {
      const a = await fZ({ request_id: n, ip: s || "localhost" });
      return lW(`generated challenge ${a} for ${n}`), i && i({ result: a }), {
        abort: () => {
        }
      };
    },
    desc: "Generate security challenge",
    settings: { free: !0 }
  }).addInput({
    schema: ke.object({
      request_id: ke.string(),
      ip: ke.string()
    })
  }).addOutput({
    code: 200,
    desc: "Returns a random nonce for signing",
    schema: ke.object({
      result: ke.string()
    })
  }), e.run();
}, Ko = ad("server"), Ca = [], Dm = [], Lm = {}, qm = {};
async function dW({
  modules: e,
  private_key: t,
  protocols: r,
  globals: i,
  type: n = "events",
  no_auth: s = !1,
  host: a = "127.0.0.1",
  port: o = 8080
}) {
  if (t || (t = (await mP()).private_key), i)
    for (const l in i)
      Ko(`setting global ${l}`), Lm[l] = i[l];
  e = [...e, await fW(), await Ky()];
  for (const l of e) {
    if (!Ub.safeParse(l).success)
      throw Ko(`invalid module ${l.id}`), new Error("Invalid Module");
    Ca.push(l), Ko(`loaded module ${l.id}`);
  }
  if (r)
    for (const l of r) {
      if (!Zm.safeParse(l).success)
        throw new Error("Invalid Protocol");
      Dm.push(l), Ko(`loaded protocol ${l.id}`);
    }
  const c = {
    getModules: () => Ca,
    execute: async function({
      input: l,
      globals: d,
      onData: p,
      onDone: h,
      onError: g
    }) {
      var $, E, S, R;
      Ko(`executing ${l.offer.call.module_id}:${l.offer.call.method_id} / ${l.id}`);
      const m = Zm.safeParse(l);
      if (!m.success)
        return { error: "Invalid payload", code: 400 };
      if (!s && l.offer.call.module_id === "handshake" && l.offer.call.method_id === "challenge") {
        const j = async (L) => {
          const K = L.result;
          if (!K)
            return g({ error: "Invalid challenge", code: 400 });
          h({ request_id: l.id, status: "challenge", data: { challenge: K } });
        };
        return E2({
          input: { ...m.data, params: { request_id: l.id, ip: (d == null ? void 0 : d.ip) || "localhost" } },
          globals: { MODULES: Ca, PROTOCOLS: Dm, REQUESTS: qm, ...Lm, ...d },
          request: {
            request_id: l.id,
            abort: async () => {
            },
            setAbort: async () => {
            },
            onDone: j,
            onError: g
          },
          onData: p,
          onDone: j,
          onError: g
        });
      }
      if (!s && !await hZ({ ...l, request_id: l.id, ip: (d == null ? void 0 : d.ip) || "localhost" }))
        return { error: "Unauthorized", code: 401 };
      const v = Ca.find((j) => j.id === l.offer.call.module_id), _ = (E = ($ = v == null ? void 0 : v.schema) == null ? void 0 : $.paths[`/${l.offer.call.method_id}`]) == null ? void 0 : E.post;
      if (!_)
        return { error: "Invalid module method", code: 404 };
      const y = lZ(((R = (S = _.tags) == null ? void 0 : S.find((j) => j.startsWith("multiplier="))) == null ? void 0 : R.split("=")[1]) || "0");
      if (y && typeof y == "number") {
        if (!l.signed_transaction)
          return { error: "Missing tx", code: 400 };
        if (!j2.safeParse(l.signed_transaction).success)
          return { error: "Invalid tx", code: 400 };
        const L = await UP(await Ky()).getBalance({ user_id: l.meta.user_id }) || 0;
        if ((L == null ? void 0 : L.result) === void 0)
          return { error: "Invalid balance", code: 400 };
        if (await Il(l.params || {}) * y > (L == null ? void 0 : L.result))
          return { error: "Insufficient balance", code: 402 };
      }
      const w = await Bj({
        module_id: l.offer.call.module_id,
        method_id: l.offer.call.method_id,
        request_id: l.id,
        onData: p,
        onDone: h,
        onError: g,
        tx: l.signed_transaction || void 0
      });
      return "error" in w ? { error: w.error, code: 500 } : E2({
        input: { ...m.data, params: (l == null ? void 0 : l.params) || null },
        globals: { MODULES: Ca, PROTOCOLS: Dm, REQUESTS: qm, ...Lm, ...d, private_key: t },
        request: w,
        onData: p,
        onDone: h,
        onError: g
      });
    },
    abort: async function({ request_id: l }) {
      const d = qm[l];
      return d ? typeof d == "object" && d.abort() : { error: "Unknown request", code: 404 };
    },
    registerModule: async function({ module: l }) {
      return Ub.safeParse(l).success ? (Ca.push(l), { code: 200 }) : { error: "Invalid Module", code: 400 };
    },
    signOffer: async function(l) {
      if (!t)
        return { error: "No private key", code: 500 };
      const d = to({ str: JSON.stringify(l) }), p = await pf(d, hf({ input: t }));
      return {
        ...l,
        id: Tf(),
        sig: {
          c: Xr({ input: d }),
          s: Xr({ input: p }),
          pk: await mZ({ private_key: t })
        }
      };
    }
  };
  switch (n) {
    case "events":
      bZ({ API: c });
      break;
    case "websocket":
      EZ({ API: c, host: a, port: o });
      break;
  }
  return c;
}
async function EW({
  host: e,
  type: t = "events",
  server_modules: r = [],
  server_private_key: i
}) {
  let n;
  switch (t) {
    case "websocket":
      n = wZ;
      break;
    case "events":
      n = vZ;
      break;
  }
  const s = {
    request: async ({ user: a, offer: o, params: c, tx: l }) => {
      var E, S, R;
      const d = Tf(), p = new Promise((j, L) => {
        const K = setTimeout(
          () => {
            L("timeout");
          },
          uZ() ? 1e6 : 1e4
        );
        s.compute({
          onData: () => {
          },
          onDone: (ae) => {
            clearTimeout(K), j(ae.data);
          },
          onError: (ae) => {
            clearTimeout(K), L(ae);
          },
          request: {
            id: d,
            meta: {
              user_id: a.user_id
            },
            params: c,
            offer: {
              id: "handshake",
              call: {
                module_id: "handshake",
                method_id: "challenge"
              },
              sig: {
                n: "",
                c: "",
                s: "",
                pk: a.public_key
              }
            },
            auth: {
              n: "",
              c: "",
              s: "",
              pk: a.public_key
            }
          }
        });
      }), [h] = await Promise.all([p]);
      if (!((E = h == null ? void 0 : h.data) != null && E.challenge))
        return { error: "Invalid challenge", code: 400 };
      const g = to({
        str: JSON.stringify({ offer: o, params: c || {}, nonce: (S = h == null ? void 0 : h.data) == null ? void 0 : S.challenge, request_id: d })
      });
      Xr({ input: g });
      const m = await pf(g, hf({ input: a.private_key })), v = {
        n: (R = h == null ? void 0 : h.data) == null ? void 0 : R.challenge,
        c: Xr({ input: g }),
        s: Xr({ input: m }),
        pk: a.public_key
      }, _ = to({
        str: JSON.stringify({ offer: o, params: c || {}, request_id: d, max_spent: (l == null ? void 0 : l.max_spent) || 0 })
      }), y = await pf(_, hf({ input: a.private_key })), w = {
        max_spent: (l == null ? void 0 : l.max_spent) || 0,
        signature: {
          c: Xr({ input: _ }),
          s: Xr({ input: y }),
          pk: a.public_key
        }
      };
      return {
        id: d,
        meta: {
          user_id: a.user_id
        },
        params: c,
        auth: v,
        signed_transaction: w,
        offer: o
      };
    },
    compute: async ({ request: a, onData: o, onDone: c, onError: l }) => {
      if (!n)
        return { error: "Invalid channel type", code: 400 };
      const { write: d, close: p } = await n({
        request_id: a.id,
        host: e,
        onData: o,
        onDone: c,
        onError: l
      });
      return d({ input: a }), {
        abort: () => {
          d({ input: a, abort: !0 });
        }
      };
    }
  };
  if (e === "localhost") {
    const a = await dW({
      modules: r,
      type: "events",
      private_key: i || void 0
    });
    if ("error" in a)
      throw new Error(JSON.stringify(a.error));
  }
  return s;
}
export {
  EW as Client,
  Bj as Request,
  dW as Server,
  t$ as convertZod,
  $W as generateUser,
  BP as moduleGenerator,
  ke as z
};
//# sourceMappingURL=bundle.js.map
